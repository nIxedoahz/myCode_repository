/**
 * @copyright (c) Copyright 2020 Secsmart. All Rights Reserved.
 * @license
 * @file  : sqlquery_lexer.hpp
 * @author: Jona 
 * @email : wuzhenyu@secsmart.net
 * @date  : 2020-08-07
 * @brief : sqlquery lexer definition
*/

#ifndef __SQLQUERY_LEXER_H__
#define __SQLQUERY_LEXER_H__

#include <ctype.h>
#include <vector>
#include <iostream>

#include <string.h>

#include "lexer.hpp"
#include "token.hpp"

enum {
  SPACE=2, PERCENT, AMPERSAND, LEFT_PAREN, RIGHT_PAREN, ASTERISK, PLUS, COMMA, MINUS, PERIOD, SOLIDUS, COLON, SEMI, LESS_THAN,
  EQUALS, GREATER_THAN, QUESTION, LEFT_BRACKET, RIGHT_BRACKET, CIRCUMFLEX, BAR, LEFT_BRACE, RIGHT_BRACE,
  ABS, ABSOLUTE, ACTION, ADA, ADD, ADMIN, AFTER, ALL, ALLOCATE,
  ALTER, AND, ANY, ARE, ARRAY, AS, ASC, ASENSITIVE, ASSERTION, ASSIGNMENT, ASYMMETRIC,
  AT, ATOMIC, AUTHORIZATION, AVG, BEFORE, BEGIN, BETWEEN, BIN, BINARY, BIT, BLOB,
  BOOLEAN, BY, C, CALL, CALLED, CARDINALITY, CASCADE, CASCADED, CASE, CAST, CATALOG,
  CHAIN, CHAR, CHARACTER, CHECK, CHECKED, CLI, CLOB, CLOSE, COBOL, COLLATE, COLLATION,
  COLUMN, COMMIT, CONNECT, CONNECTION, CONSTRAINT, CONSTRAINTS, CONSTRUCTOR, CONTINUE, CORRESPONDING, COUNT, CREATE,
  CROSS, CUBE, CURRENT, CURSOR, DATE, DAY, DEALLOCATE, DEC, DECIMAL, DECLARE, DEFAULT,
  DEFERRABLE, DEFERRED, DEFIN, DEFOUT, DEGREE, DELETE, DEPTH, DEREF, DERIVED, DESCRIPTOR, DETERMINISTIC,
  DIAGNOSTICS, DISCONNECT, DISPLAY, DISTINCT, DO, DOMAIN, DROP, ELSE, ELSEIF, END, 
  ESCAPE, EVERY, EXCEPT, EXEC, EXECUTE, EXISTS, EXIT, FALSE, FETCH, FINAL, FIRST,
  FLOAT, FOR, FOREIGN, FORTRAN, FOUND, FROM, FULL, FUNCTION, G, GENERATED, GET,
  GLOBAL, GO, GOTO, GRANT, GRANTED, GROUP, GROUPING, HAVING, HIERARCHY, HOLD, HOUR,
  IF, IMMEDIATE, IN, INDICATOR, INITIALLY, INNER, INOUT, INPUT, INSENSITIVE, INSERT, INSTANCE,
  INSTANTIABLE, INT, INTERSECT, INTERVAL, INTO, IS, ISO, ISOLATION, ITERATE, JOIN, K,
  KEY, KIND, LANGUAGE, LARGE, LAST, LATERAL, LEADING, LEAVE, LEFT, LIKE, LOCAL,
  LOCALTIME, LOCALTIMESTAMP, LOCATOR, LOOP, LOWER, M, MAP, MATCH, MAX, METHOD, MIN,
  MINUTE, MODIFIES, MODULE, MONTH, MORE, MUMPS, N, NAME, NAMES, NATIONAL, NATURAL,
  NCHAR, NCLOB, NESTING, NEW, NO, NONE, NOT, SQL_NULL, NULLABLE, NUMBER, OBJECT,
  OF, OLD, ON, ONLY, OPEN, OPTION, OPTIONS, OR, ORDER, ORDERING, ORDINALITY,
  OUT, OUTER, OUTPUT, OVERLAPS, OVERLAY, OVERRIDING, PAD, PARAMETER, PARTIAL, PASCAL, PATH,
  PIC, PICTURE, PLACING, PLI, PRESERVE, PRIMARY, PRIOR, PRIVILEGES, PROCEDURE, PUBLIC, READ,
  READS, REAL, RECURSIVE, REDO, REF, REFERENCES, REFERENCING, RELATIVE, RELEASE, REPEAT, RESIGNAL,
  RESTRICT, RESULT, RETURN, RETURNS, REVOKE, RIGHT, ROLE, ROLLBACK, ROLLUP, ROW, S,
  SAVEPOINT, SCHEMA, SCOPE, SCROLL, SEARCH, SECOND, SECTION, SECURITY, SELECT, SELF, SENSITIVE,
  SESSION, SET, SETS, SIGNAL, SIMILAR, SIMPLE, SOME, SOURCE, SPECIFIC, SPECIFICTYPE,
  SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, START, STATE, STATEMENT, STATIC, SUBSTRING, SUM, SYMMETRIC,
  SYSTEM, TABLE, TEMPORARY, THEN, TIME, TIMESTAMP, TO, TRAILING, TRANSACTION, TRANSFORM, TRANSFORMS,
  TRANSLATE, TRANSLATION, TREAT, TRIGGER, TRIM, TRUE, TYPE, UNDER, UNDO, UNION, UNIQUE,
  UNKNOWN, UNNAMED, UNNEST, UNTIL, UPDATE, UPPER, USAGE, USER, USING, V, VALUE,
  VALUES, VARCHAR, VARYING, VIEW, WHEN, WHENEVER, WHERE, WHILE, WITH, WITHOUT, WORK,
  X, YEAR, ZONE, DOUBLE_STRINGS, STRINGS, IDENTIFIER, INTEGER
};

const static std::vector<std::string> TokenNames = {
  "n/a", "<EOF>", "SPACE", "PERCENT", "AMPERSAND" /*&*/, "LEFT_PAREN", "RIGHT_PAREN", "ASTERISK", "PLUS", "COMMA", "MINUS", "PERIOD", "SOLIDUS", 
  "COLON", "SEMI", "LESS_THAN", "EQUALS", "GREATER_THAN", "QUESTION", "LEFT_BRACKET", "RIGHT_BRACKET", "CIRCUMFLEX"/*^*/, "BAR", "LEFT_BRACE",
  "RIGHT_BRACE", "ABS", "ABSOLUTE", "ACTION", "ADA", "ADD", "ADMIN", "AFTER", "ALL", 
  "ALLOCATE", "ALTER", "AND", "ANY", "ARE", "ARRAY", "AS", "ASC", "ASENSITIVE", "ASSERTION", "ASSIGNMENT", 
  "ASYMMETRIC", "AT", "ATOMIC", "AUTHORIZATION", "AVG", "BEFORE", "BEGIN", "BETWEEN", "BIN", "BINARY", "BIT", 
  "BLOB", "BOOLEAN", "BY", "C", "CALL", "CALLED", "CARDINALITY", "CASCADE", "CASCADED", "CASE", "CAST", 
  "CATALOG", "CHAIN", "CHAR", "CHARACTER", "CHECK", "CHECKED", "CLI", "CLOB", "CLOSE", "COBOL", "COLLATE", 
  "COLLATION", "COLUMN", "COMMIT", "CONNECT", "CONNECTION", "CONSTRAINT", "CONSTRAINTS", "CONSTRUCTOR", "CONTINUE", "CORRESPONDING", "COUNT", 
  "CREATE", "CROSS", "CUBE", "CURRENT", "CURSOR", "DATE", "DAY", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", 
  "DEFAULT", "DEFERRABLE", "DEFERRED", "DEFIN", "DEFOUT", "DEGREE", "DELETE", "DEPTH", "DEREF", "DERIVED", "DESCRIPTOR", 
  "DETERMINISTIC", "DIAGNOSTICS", "DISCONNECT", "DISPLAY", "DISTINCT", "DO", "DOMAIN", "DROP", "ELSE", "ELSEIF", "END", 
  "ESCAPE", "EVERY", "EXCEPT", "EXEC", "EXECUTE", "EXISTS", "EXIT", "FALSE", "FETCH", "FINAL", 
  "FIRST", "FLOAT", "FOR", "FOREIGN", "FORTRAN", "FOUND", "FROM", "FULL", "FUNCTION", "G", "GENERATED", 
  "GET", "GLOBAL", "GO", "GOTO", "GRANT", "GRANTED", "GROUP", "GROUPING", "HAVING", "HIERARCHY", "HOLD", 
  "HOUR", "IF", "IMMEDIATE", "IN", "INDICATOR", "INITIALLY", "INNER", "INOUT", "INPUT", "INSENSITIVE", "INSERT", 
  "INSTANCE", "INSTANTIABLE", "INT", "INTERSECT", "INTERVAL", "INTO", "IS", "ISO", "ISOLATION", "ITERATE", "JOIN", 
  "K", "KEY", "KIND", "LANGUAGE", "LARGE", "LAST", "LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", 
  "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATOR", "LOOP", "LOWER", "M", "MAP", "MATCH", "MAX", "METHOD", 
  "MIN", "MINUTE", "MODIFIES", "MODULE", "MONTH", "MORE", "MUMPS", "N", "NAME", "NAMES", "NATIONAL", 
  "NATURAL", "NCHAR", "NCLOB", "NESTING", "NEW", "NO", "NONE", "NOT", "NULL", "NULLABLE", "NUMBER", 
  "OBJECT", "OF", "OLD", "ON", "ONLY", "OPEN", "OPTION", "OPTIONS", "OR", "ORDER", "ORDERING", 
  "ORDINALITY", "OUT", "OUTER", "OUTPUT", "OVERLAPS", "OVERLAY", "OVERRIDING", "PAD", "PARAMETER", "PARTIAL", "PASCAL", 
  "PATH", "PIC", "PICTURE", "PLACING", "PLI", "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURE", "PUBLIC", 
  "READ", "READS", "REAL", "RECURSIVE", "REDO", "REF", "REFERENCES", "REFERENCING", "RELATIVE", "RELEASE", "REPEAT", 
  "RESIGNAL", "RESTRICT", "RESULT", "RETURN", "RETURNS", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROLLUP", "ROW", 
  "S", "SAVEPOINT", "SCHEMA", "SCOPE", "SCROLL", "SEARCH", "SECOND", "SECTION", "SECURITY", "SELECT", "SELF", 
  "SENSITIVE", "SESSION", "SET", "SETS", "SIGNAL", "SIMILAR", "SIMPLE", "SOME", "SOURCE", "SPECIFIC", 
  "SPECIFICTYPE", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "START", "STATE", "STATEMENT", "STATIC", "SUBSTRING", "SUM", 
  "SYMMETRIC", "SYSTEM", "TABLE", "TEMPORARY", "THEN", "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION", "TRANSFORM", 
  "TRANSFORMS", "TRANSLATE", "TRANSLATION", "TREAT", "TRIGGER", "TRIM", "TRUE", "TYPE", "UNDER", "UNDO", "UNION", 
  "UNIQUE", "UNKNOWN", "UNNAMED", "UNNEST", "UNTIL", "UPDATE", "UPPER", "USAGE", "USER", "USING", "V", 
  "VALUE", "VALUES", "VARCHAR", "VARYING", "VIEW", "WHEN", "WHENEVER", "WHERE", "WHILE", "WITH", "WITHOUT", 
  "WORK", "X", "YEAR", "ZONE", "DOUBLE_STRINGS", "STRINGS", "IDENTIFIER", "INTEGER"
};

class SqlQueryLexer : public Lexer {
public:
  SqlQueryLexer(std::string input);
  virtual ~SqlQueryLexer();

  std::string GetTokenName(int token_type);
  bool IsLetter();
  bool IsDigit();
  Token* NextToken();
  Token* GetStringToken();
  Token* GetToken();
  Token* GetDigitToken();
  Token* WS();
};

#endif /* __SQLQUERY_LEXER_H__ */
