
// Generated from /home/jona/myGit/myCode_repository/antlr4_cpp/greenplum/GreenPlumParser.g4 by ANTLR 4.7.1


#include "GreenPlumParserListener.h"
#include "GreenPlumParserVisitor.h"

#include "GreenPlumParser.h"


#include <string.h>


using namespace antlrcpp;
using namespace antlr4;

GreenPlumParser::GreenPlumParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

GreenPlumParser::~GreenPlumParser() {
  delete _interpreter;
}

std::string GreenPlumParser::getGrammarFileName() const {
  return "GreenPlumParser.g4";
}

const std::vector<std::string>& GreenPlumParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& GreenPlumParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- StmtblockContext ------------------------------------------------------------------

GreenPlumParser::StmtblockContext::StmtblockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::StmtmultiContext* GreenPlumParser::StmtblockContext::stmtmulti() {
  return getRuleContext<GreenPlumParser::StmtmultiContext>(0);
}

tree::TerminalNode* GreenPlumParser::StmtblockContext::EOF() {
  return getToken(GreenPlumParser::EOF, 0);
}

tree::TerminalNode* GreenPlumParser::StmtblockContext::SEMICOLON() {
  return getToken(GreenPlumParser::SEMICOLON, 0);
}


size_t GreenPlumParser::StmtblockContext::getRuleIndex() const {
  return GreenPlumParser::RuleStmtblock;
}

void GreenPlumParser::StmtblockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmtblock(this);
}

void GreenPlumParser::StmtblockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmtblock(this);
}


antlrcpp::Any GreenPlumParser::StmtblockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitStmtblock(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::StmtblockContext* GreenPlumParser::stmtblock() {
  StmtblockContext *_localctx = _tracker.createInstance<StmtblockContext>(_ctx, getState());
  enterRule(_localctx, 0, GreenPlumParser::RuleStmtblock);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1072);
    stmtmulti();
    setState(1074);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::SEMICOLON) {
      setState(1073);
      match(GreenPlumParser::SEMICOLON);
    }
    setState(1076);
    match(GreenPlumParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtmultiContext ------------------------------------------------------------------

GreenPlumParser::StmtmultiContext::StmtmultiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::StmtContext *> GreenPlumParser::StmtmultiContext::stmt() {
  return getRuleContexts<GreenPlumParser::StmtContext>();
}

GreenPlumParser::StmtContext* GreenPlumParser::StmtmultiContext::stmt(size_t i) {
  return getRuleContext<GreenPlumParser::StmtContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::StmtmultiContext::SEMICOLON() {
  return getTokens(GreenPlumParser::SEMICOLON);
}

tree::TerminalNode* GreenPlumParser::StmtmultiContext::SEMICOLON(size_t i) {
  return getToken(GreenPlumParser::SEMICOLON, i);
}


size_t GreenPlumParser::StmtmultiContext::getRuleIndex() const {
  return GreenPlumParser::RuleStmtmulti;
}

void GreenPlumParser::StmtmultiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmtmulti(this);
}

void GreenPlumParser::StmtmultiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmtmulti(this);
}


antlrcpp::Any GreenPlumParser::StmtmultiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitStmtmulti(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::StmtmultiContext* GreenPlumParser::stmtmulti() {
  StmtmultiContext *_localctx = _tracker.createInstance<StmtmultiContext>(_ctx, getState());
  enterRule(_localctx, 2, GreenPlumParser::RuleStmtmulti);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1078);
    stmt();
    setState(1083);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1079);
        match(GreenPlumParser::SEMICOLON);
        setState(1080);
        stmt(); 
      }
      setState(1085);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

GreenPlumParser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Alter_database_stmtContext* GreenPlumParser::StmtContext::alter_database_stmt() {
  return getRuleContext<GreenPlumParser::Alter_database_stmtContext>(0);
}

GreenPlumParser::Alter_database_set_stmtContext* GreenPlumParser::StmtContext::alter_database_set_stmt() {
  return getRuleContext<GreenPlumParser::Alter_database_set_stmtContext>(0);
}

GreenPlumParser::Alter_domain_stmtContext* GreenPlumParser::StmtContext::alter_domain_stmt() {
  return getRuleContext<GreenPlumParser::Alter_domain_stmtContext>(0);
}

GreenPlumParser::Alter_extension_stmtContext* GreenPlumParser::StmtContext::alter_extension_stmt() {
  return getRuleContext<GreenPlumParser::Alter_extension_stmtContext>(0);
}

GreenPlumParser::Alter_extension_content_stmtContext* GreenPlumParser::StmtContext::alter_extension_content_stmt() {
  return getRuleContext<GreenPlumParser::Alter_extension_content_stmtContext>(0);
}

GreenPlumParser::Alter_function_stmtContext* GreenPlumParser::StmtContext::alter_function_stmt() {
  return getRuleContext<GreenPlumParser::Alter_function_stmtContext>(0);
}

GreenPlumParser::Alter_group_stmtContext* GreenPlumParser::StmtContext::alter_group_stmt() {
  return getRuleContext<GreenPlumParser::Alter_group_stmtContext>(0);
}

GreenPlumParser::Alter_object_schema_stmtContext* GreenPlumParser::StmtContext::alter_object_schema_stmt() {
  return getRuleContext<GreenPlumParser::Alter_object_schema_stmtContext>(0);
}

GreenPlumParser::Alter_owner_stmtContext* GreenPlumParser::StmtContext::alter_owner_stmt() {
  return getRuleContext<GreenPlumParser::Alter_owner_stmtContext>(0);
}

GreenPlumParser::Alter_queue_stmtContext* GreenPlumParser::StmtContext::alter_queue_stmt() {
  return getRuleContext<GreenPlumParser::Alter_queue_stmtContext>(0);
}

GreenPlumParser::Alter_resource_group_stmtContext* GreenPlumParser::StmtContext::alter_resource_group_stmt() {
  return getRuleContext<GreenPlumParser::Alter_resource_group_stmtContext>(0);
}

GreenPlumParser::Alter_role_set_stmtContext* GreenPlumParser::StmtContext::alter_role_set_stmt() {
  return getRuleContext<GreenPlumParser::Alter_role_set_stmtContext>(0);
}

GreenPlumParser::Alter_role_stmtContext* GreenPlumParser::StmtContext::alter_role_stmt() {
  return getRuleContext<GreenPlumParser::Alter_role_stmtContext>(0);
}

GreenPlumParser::Alter_tsconfiguration_stmtContext* GreenPlumParser::StmtContext::alter_tsconfiguration_stmt() {
  return getRuleContext<GreenPlumParser::Alter_tsconfiguration_stmtContext>(0);
}

GreenPlumParser::Alter_tsdictionary_stmtContext* GreenPlumParser::StmtContext::alter_tsdictionary_stmt() {
  return getRuleContext<GreenPlumParser::Alter_tsdictionary_stmtContext>(0);
}

GreenPlumParser::Alter_seq_stmtContext* GreenPlumParser::StmtContext::alter_seq_stmt() {
  return getRuleContext<GreenPlumParser::Alter_seq_stmtContext>(0);
}

GreenPlumParser::Alter_table_stmtContext* GreenPlumParser::StmtContext::alter_table_stmt() {
  return getRuleContext<GreenPlumParser::Alter_table_stmtContext>(0);
}

GreenPlumParser::Alter_type_stmtContext* GreenPlumParser::StmtContext::alter_type_stmt() {
  return getRuleContext<GreenPlumParser::Alter_type_stmtContext>(0);
}

GreenPlumParser::Alter_user_set_stmtContext* GreenPlumParser::StmtContext::alter_user_set_stmt() {
  return getRuleContext<GreenPlumParser::Alter_user_set_stmtContext>(0);
}

GreenPlumParser::Alter_user_stmtContext* GreenPlumParser::StmtContext::alter_user_stmt() {
  return getRuleContext<GreenPlumParser::Alter_user_stmtContext>(0);
}

GreenPlumParser::Analyze_stmtContext* GreenPlumParser::StmtContext::analyze_stmt() {
  return getRuleContext<GreenPlumParser::Analyze_stmtContext>(0);
}

GreenPlumParser::Check_point_stmtContext* GreenPlumParser::StmtContext::check_point_stmt() {
  return getRuleContext<GreenPlumParser::Check_point_stmtContext>(0);
}

GreenPlumParser::Close_portal_stmtContext* GreenPlumParser::StmtContext::close_portal_stmt() {
  return getRuleContext<GreenPlumParser::Close_portal_stmtContext>(0);
}

GreenPlumParser::Cluster_stmtContext* GreenPlumParser::StmtContext::cluster_stmt() {
  return getRuleContext<GreenPlumParser::Cluster_stmtContext>(0);
}

GreenPlumParser::Comment_stmtContext* GreenPlumParser::StmtContext::comment_stmt() {
  return getRuleContext<GreenPlumParser::Comment_stmtContext>(0);
}

GreenPlumParser::Constraints_set_stmtContext* GreenPlumParser::StmtContext::constraints_set_stmt() {
  return getRuleContext<GreenPlumParser::Constraints_set_stmtContext>(0);
}

GreenPlumParser::Copy_stmtContext* GreenPlumParser::StmtContext::copy_stmt() {
  return getRuleContext<GreenPlumParser::Copy_stmtContext>(0);
}

GreenPlumParser::Create_as_stmtContext* GreenPlumParser::StmtContext::create_as_stmt() {
  return getRuleContext<GreenPlumParser::Create_as_stmtContext>(0);
}

GreenPlumParser::Create_assert_stmtContext* GreenPlumParser::StmtContext::create_assert_stmt() {
  return getRuleContext<GreenPlumParser::Create_assert_stmtContext>(0);
}

GreenPlumParser::Create_cast_stmtContext* GreenPlumParser::StmtContext::create_cast_stmt() {
  return getRuleContext<GreenPlumParser::Create_cast_stmtContext>(0);
}

GreenPlumParser::Create_conversion_stmtContext* GreenPlumParser::StmtContext::create_conversion_stmt() {
  return getRuleContext<GreenPlumParser::Create_conversion_stmtContext>(0);
}

GreenPlumParser::Create_domain_stmtContext* GreenPlumParser::StmtContext::create_domain_stmt() {
  return getRuleContext<GreenPlumParser::Create_domain_stmtContext>(0);
}

GreenPlumParser::Create_extension_stmtContext* GreenPlumParser::StmtContext::create_extension_stmt() {
  return getRuleContext<GreenPlumParser::Create_extension_stmtContext>(0);
}

GreenPlumParser::Create_external_stmtContext* GreenPlumParser::StmtContext::create_external_stmt() {
  return getRuleContext<GreenPlumParser::Create_external_stmtContext>(0);
}

GreenPlumParser::Create_file_space_stmtContext* GreenPlumParser::StmtContext::create_file_space_stmt() {
  return getRuleContext<GreenPlumParser::Create_file_space_stmtContext>(0);
}

GreenPlumParser::Create_function_stmtContext* GreenPlumParser::StmtContext::create_function_stmt() {
  return getRuleContext<GreenPlumParser::Create_function_stmtContext>(0);
}

GreenPlumParser::Create_group_stmtContext* GreenPlumParser::StmtContext::create_group_stmt() {
  return getRuleContext<GreenPlumParser::Create_group_stmtContext>(0);
}

GreenPlumParser::Create_op_class_stmtContext* GreenPlumParser::StmtContext::create_op_class_stmt() {
  return getRuleContext<GreenPlumParser::Create_op_class_stmtContext>(0);
}

GreenPlumParser::Create_op_family_stmtContext* GreenPlumParser::StmtContext::create_op_family_stmt() {
  return getRuleContext<GreenPlumParser::Create_op_family_stmtContext>(0);
}

GreenPlumParser::Alter_op_family_stmtContext* GreenPlumParser::StmtContext::alter_op_family_stmt() {
  return getRuleContext<GreenPlumParser::Alter_op_family_stmtContext>(0);
}

GreenPlumParser::Create_p_lang_stmtContext* GreenPlumParser::StmtContext::create_p_lang_stmt() {
  return getRuleContext<GreenPlumParser::Create_p_lang_stmtContext>(0);
}

GreenPlumParser::Create_queue_stmtContext* GreenPlumParser::StmtContext::create_queue_stmt() {
  return getRuleContext<GreenPlumParser::Create_queue_stmtContext>(0);
}

GreenPlumParser::Create_resource_group_stmtContext* GreenPlumParser::StmtContext::create_resource_group_stmt() {
  return getRuleContext<GreenPlumParser::Create_resource_group_stmtContext>(0);
}

GreenPlumParser::Create_schema_stmtContext* GreenPlumParser::StmtContext::create_schema_stmt() {
  return getRuleContext<GreenPlumParser::Create_schema_stmtContext>(0);
}

GreenPlumParser::Create_seq_stmtContext* GreenPlumParser::StmtContext::create_seq_stmt() {
  return getRuleContext<GreenPlumParser::Create_seq_stmtContext>(0);
}

GreenPlumParser::Create_stmtContext* GreenPlumParser::StmtContext::create_stmt() {
  return getRuleContext<GreenPlumParser::Create_stmtContext>(0);
}

GreenPlumParser::Create_table_space_stmtContext* GreenPlumParser::StmtContext::create_table_space_stmt() {
  return getRuleContext<GreenPlumParser::Create_table_space_stmtContext>(0);
}

GreenPlumParser::Create_trig_stmtContext* GreenPlumParser::StmtContext::create_trig_stmt() {
  return getRuleContext<GreenPlumParser::Create_trig_stmtContext>(0);
}

GreenPlumParser::Create_role_stmtContext* GreenPlumParser::StmtContext::create_role_stmt() {
  return getRuleContext<GreenPlumParser::Create_role_stmtContext>(0);
}

GreenPlumParser::Create_user_stmtContext* GreenPlumParser::StmtContext::create_user_stmt() {
  return getRuleContext<GreenPlumParser::Create_user_stmtContext>(0);
}

GreenPlumParser::Createdb_stmtContext* GreenPlumParser::StmtContext::createdb_stmt() {
  return getRuleContext<GreenPlumParser::Createdb_stmtContext>(0);
}

GreenPlumParser::Deallocate_stmtContext* GreenPlumParser::StmtContext::deallocate_stmt() {
  return getRuleContext<GreenPlumParser::Deallocate_stmtContext>(0);
}

GreenPlumParser::Declare_cursor_stmtContext* GreenPlumParser::StmtContext::declare_cursor_stmt() {
  return getRuleContext<GreenPlumParser::Declare_cursor_stmtContext>(0);
}

GreenPlumParser::Define_stmtContext* GreenPlumParser::StmtContext::define_stmt() {
  return getRuleContext<GreenPlumParser::Define_stmtContext>(0);
}

GreenPlumParser::Delete_stmtContext* GreenPlumParser::StmtContext::delete_stmt() {
  return getRuleContext<GreenPlumParser::Delete_stmtContext>(0);
}

GreenPlumParser::Discard_stmtContext* GreenPlumParser::StmtContext::discard_stmt() {
  return getRuleContext<GreenPlumParser::Discard_stmtContext>(0);
}

GreenPlumParser::Do_stmtContext* GreenPlumParser::StmtContext::do_stmt() {
  return getRuleContext<GreenPlumParser::Do_stmtContext>(0);
}

GreenPlumParser::Drop_assert_stmtContext* GreenPlumParser::StmtContext::drop_assert_stmt() {
  return getRuleContext<GreenPlumParser::Drop_assert_stmtContext>(0);
}

GreenPlumParser::Drop_cast_stmtContext* GreenPlumParser::StmtContext::drop_cast_stmt() {
  return getRuleContext<GreenPlumParser::Drop_cast_stmtContext>(0);
}

GreenPlumParser::Drop_group_stmtContext* GreenPlumParser::StmtContext::drop_group_stmt() {
  return getRuleContext<GreenPlumParser::Drop_group_stmtContext>(0);
}

GreenPlumParser::Drop_op_class_stmtContext* GreenPlumParser::StmtContext::drop_op_class_stmt() {
  return getRuleContext<GreenPlumParser::Drop_op_class_stmtContext>(0);
}

GreenPlumParser::Drop_op_family_stmtContext* GreenPlumParser::StmtContext::drop_op_family_stmt() {
  return getRuleContext<GreenPlumParser::Drop_op_family_stmtContext>(0);
}

GreenPlumParser::Drop_owned_stmtContext* GreenPlumParser::StmtContext::drop_owned_stmt() {
  return getRuleContext<GreenPlumParser::Drop_owned_stmtContext>(0);
}

GreenPlumParser::Drop_p_lang_stmtContext* GreenPlumParser::StmtContext::drop_p_lang_stmt() {
  return getRuleContext<GreenPlumParser::Drop_p_lang_stmtContext>(0);
}

GreenPlumParser::Drop_queue_stmtContext* GreenPlumParser::StmtContext::drop_queue_stmt() {
  return getRuleContext<GreenPlumParser::Drop_queue_stmtContext>(0);
}

GreenPlumParser::Drop_resource_group_stmtContext* GreenPlumParser::StmtContext::drop_resource_group_stmt() {
  return getRuleContext<GreenPlumParser::Drop_resource_group_stmtContext>(0);
}

GreenPlumParser::Drop_rule_stmtContext* GreenPlumParser::StmtContext::drop_rule_stmt() {
  return getRuleContext<GreenPlumParser::Drop_rule_stmtContext>(0);
}

GreenPlumParser::Drop_stmtContext* GreenPlumParser::StmtContext::drop_stmt() {
  return getRuleContext<GreenPlumParser::Drop_stmtContext>(0);
}

GreenPlumParser::Drop_trig_stmtContext* GreenPlumParser::StmtContext::drop_trig_stmt() {
  return getRuleContext<GreenPlumParser::Drop_trig_stmtContext>(0);
}

GreenPlumParser::Drop_role_stmtContext* GreenPlumParser::StmtContext::drop_role_stmt() {
  return getRuleContext<GreenPlumParser::Drop_role_stmtContext>(0);
}

GreenPlumParser::Drop_user_stmtContext* GreenPlumParser::StmtContext::drop_user_stmt() {
  return getRuleContext<GreenPlumParser::Drop_user_stmtContext>(0);
}

GreenPlumParser::Dropdb_stmtContext* GreenPlumParser::StmtContext::dropdb_stmt() {
  return getRuleContext<GreenPlumParser::Dropdb_stmtContext>(0);
}

GreenPlumParser::Execute_stmtContext* GreenPlumParser::StmtContext::execute_stmt() {
  return getRuleContext<GreenPlumParser::Execute_stmtContext>(0);
}

GreenPlumParser::Explain_stmtContext* GreenPlumParser::StmtContext::explain_stmt() {
  return getRuleContext<GreenPlumParser::Explain_stmtContext>(0);
}

GreenPlumParser::Fetch_stmtContext* GreenPlumParser::StmtContext::fetch_stmt() {
  return getRuleContext<GreenPlumParser::Fetch_stmtContext>(0);
}

GreenPlumParser::Grant_stmtContext* GreenPlumParser::StmtContext::grant_stmt() {
  return getRuleContext<GreenPlumParser::Grant_stmtContext>(0);
}

GreenPlumParser::Grant_role_stmtContext* GreenPlumParser::StmtContext::grant_role_stmt() {
  return getRuleContext<GreenPlumParser::Grant_role_stmtContext>(0);
}

GreenPlumParser::Index_stmtContext* GreenPlumParser::StmtContext::index_stmt() {
  return getRuleContext<GreenPlumParser::Index_stmtContext>(0);
}

GreenPlumParser::Insert_stmtContext* GreenPlumParser::StmtContext::insert_stmt() {
  return getRuleContext<GreenPlumParser::Insert_stmtContext>(0);
}

GreenPlumParser::Listen_stmtContext* GreenPlumParser::StmtContext::listen_stmt() {
  return getRuleContext<GreenPlumParser::Listen_stmtContext>(0);
}

GreenPlumParser::Load_stmtContext* GreenPlumParser::StmtContext::load_stmt() {
  return getRuleContext<GreenPlumParser::Load_stmtContext>(0);
}

GreenPlumParser::Lock_stmtContext* GreenPlumParser::StmtContext::lock_stmt() {
  return getRuleContext<GreenPlumParser::Lock_stmtContext>(0);
}

GreenPlumParser::Notify_stmtContext* GreenPlumParser::StmtContext::notify_stmt() {
  return getRuleContext<GreenPlumParser::Notify_stmtContext>(0);
}

GreenPlumParser::Prepare_stmtContext* GreenPlumParser::StmtContext::prepare_stmt() {
  return getRuleContext<GreenPlumParser::Prepare_stmtContext>(0);
}

GreenPlumParser::Reassign_owned_stmtContext* GreenPlumParser::StmtContext::reassign_owned_stmt() {
  return getRuleContext<GreenPlumParser::Reassign_owned_stmtContext>(0);
}

GreenPlumParser::Reindex_stmtContext* GreenPlumParser::StmtContext::reindex_stmt() {
  return getRuleContext<GreenPlumParser::Reindex_stmtContext>(0);
}

GreenPlumParser::Remove_aggr_stmtContext* GreenPlumParser::StmtContext::remove_aggr_stmt() {
  return getRuleContext<GreenPlumParser::Remove_aggr_stmtContext>(0);
}

GreenPlumParser::Remove_func_stmtContext* GreenPlumParser::StmtContext::remove_func_stmt() {
  return getRuleContext<GreenPlumParser::Remove_func_stmtContext>(0);
}

GreenPlumParser::Remove_oper_stmtContext* GreenPlumParser::StmtContext::remove_oper_stmt() {
  return getRuleContext<GreenPlumParser::Remove_oper_stmtContext>(0);
}

GreenPlumParser::Rename_stmtContext* GreenPlumParser::StmtContext::rename_stmt() {
  return getRuleContext<GreenPlumParser::Rename_stmtContext>(0);
}

GreenPlumParser::Revoke_stmtContext* GreenPlumParser::StmtContext::revoke_stmt() {
  return getRuleContext<GreenPlumParser::Revoke_stmtContext>(0);
}

GreenPlumParser::Revoke_role_stmtContext* GreenPlumParser::StmtContext::revoke_role_stmt() {
  return getRuleContext<GreenPlumParser::Revoke_role_stmtContext>(0);
}

GreenPlumParser::Rule_stmtContext* GreenPlumParser::StmtContext::rule_stmt() {
  return getRuleContext<GreenPlumParser::Rule_stmtContext>(0);
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::StmtContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

GreenPlumParser::Transaction_stmtContext* GreenPlumParser::StmtContext::transaction_stmt() {
  return getRuleContext<GreenPlumParser::Transaction_stmtContext>(0);
}

GreenPlumParser::Truncate_stmtContext* GreenPlumParser::StmtContext::truncate_stmt() {
  return getRuleContext<GreenPlumParser::Truncate_stmtContext>(0);
}

GreenPlumParser::Unlisten_stmtContext* GreenPlumParser::StmtContext::unlisten_stmt() {
  return getRuleContext<GreenPlumParser::Unlisten_stmtContext>(0);
}

GreenPlumParser::Update_stmtContext* GreenPlumParser::StmtContext::update_stmt() {
  return getRuleContext<GreenPlumParser::Update_stmtContext>(0);
}

GreenPlumParser::Vacuum_stmtContext* GreenPlumParser::StmtContext::vacuum_stmt() {
  return getRuleContext<GreenPlumParser::Vacuum_stmtContext>(0);
}

GreenPlumParser::Variable_reset_stmtContext* GreenPlumParser::StmtContext::variable_reset_stmt() {
  return getRuleContext<GreenPlumParser::Variable_reset_stmtContext>(0);
}

GreenPlumParser::Variable_set_stmtContext* GreenPlumParser::StmtContext::variable_set_stmt() {
  return getRuleContext<GreenPlumParser::Variable_set_stmtContext>(0);
}

GreenPlumParser::Variable_show_stmtContext* GreenPlumParser::StmtContext::variable_show_stmt() {
  return getRuleContext<GreenPlumParser::Variable_show_stmtContext>(0);
}

GreenPlumParser::View_stmtContext* GreenPlumParser::StmtContext::view_stmt() {
  return getRuleContext<GreenPlumParser::View_stmtContext>(0);
}

tree::TerminalNode* GreenPlumParser::StmtContext::SEMICOLON() {
  return getToken(GreenPlumParser::SEMICOLON, 0);
}


size_t GreenPlumParser::StmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleStmt;
}

void GreenPlumParser::StmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmt(this);
}

void GreenPlumParser::StmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmt(this);
}


antlrcpp::Any GreenPlumParser::StmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitStmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::StmtContext* GreenPlumParser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 4, GreenPlumParser::RuleStmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1190);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1086);
      alter_database_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1087);
      alter_database_set_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1088);
      alter_domain_stmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1089);
      alter_extension_stmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1090);
      alter_extension_content_stmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1091);
      alter_function_stmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1092);
      alter_group_stmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1093);
      alter_object_schema_stmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1094);
      alter_owner_stmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1095);
      alter_queue_stmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1096);
      alter_resource_group_stmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1097);
      alter_role_set_stmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1098);
      alter_role_stmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1099);
      alter_tsconfiguration_stmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1100);
      alter_tsdictionary_stmt();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1101);
      alter_seq_stmt();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1102);
      alter_table_stmt();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1103);
      alter_type_stmt();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1104);
      alter_user_set_stmt();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1105);
      alter_user_stmt();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1106);
      analyze_stmt();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1107);
      check_point_stmt();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1108);
      close_portal_stmt();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(1109);
      cluster_stmt();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(1110);
      comment_stmt();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(1111);
      constraints_set_stmt();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(1112);
      copy_stmt();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(1113);
      create_as_stmt();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(1114);
      create_assert_stmt();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(1115);
      create_cast_stmt();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(1116);
      create_conversion_stmt();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(1117);
      create_domain_stmt();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(1118);
      create_extension_stmt();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(1119);
      create_external_stmt();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(1120);
      create_file_space_stmt();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(1121);
      create_function_stmt();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(1122);
      create_group_stmt();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(1123);
      create_op_class_stmt();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(1124);
      create_op_family_stmt();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(1125);
      alter_op_family_stmt();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(1126);
      create_p_lang_stmt();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(1127);
      create_queue_stmt();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(1128);
      create_resource_group_stmt();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(1129);
      create_schema_stmt();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(1130);
      create_seq_stmt();
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(1131);
      create_stmt();
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(1132);
      create_table_space_stmt();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(1133);
      create_trig_stmt();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(1134);
      create_role_stmt();
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(1135);
      create_user_stmt();
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(1136);
      createdb_stmt();
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(1137);
      deallocate_stmt();
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(1138);
      declare_cursor_stmt();
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(1139);
      define_stmt();
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(1140);
      delete_stmt();
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(1141);
      discard_stmt();
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(1142);
      do_stmt();
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(1143);
      drop_assert_stmt();
      break;
    }

    case 59: {
      enterOuterAlt(_localctx, 59);
      setState(1144);
      drop_cast_stmt();
      break;
    }

    case 60: {
      enterOuterAlt(_localctx, 60);
      setState(1145);
      drop_group_stmt();
      break;
    }

    case 61: {
      enterOuterAlt(_localctx, 61);
      setState(1146);
      drop_op_class_stmt();
      break;
    }

    case 62: {
      enterOuterAlt(_localctx, 62);
      setState(1147);
      drop_op_family_stmt();
      break;
    }

    case 63: {
      enterOuterAlt(_localctx, 63);
      setState(1148);
      drop_owned_stmt();
      break;
    }

    case 64: {
      enterOuterAlt(_localctx, 64);
      setState(1149);
      drop_p_lang_stmt();
      break;
    }

    case 65: {
      enterOuterAlt(_localctx, 65);
      setState(1150);
      drop_queue_stmt();
      break;
    }

    case 66: {
      enterOuterAlt(_localctx, 66);
      setState(1151);
      drop_resource_group_stmt();
      break;
    }

    case 67: {
      enterOuterAlt(_localctx, 67);
      setState(1152);
      drop_rule_stmt();
      break;
    }

    case 68: {
      enterOuterAlt(_localctx, 68);
      setState(1153);
      drop_stmt();
      break;
    }

    case 69: {
      enterOuterAlt(_localctx, 69);
      setState(1154);
      drop_trig_stmt();
      break;
    }

    case 70: {
      enterOuterAlt(_localctx, 70);
      setState(1155);
      drop_role_stmt();
      break;
    }

    case 71: {
      enterOuterAlt(_localctx, 71);
      setState(1156);
      drop_user_stmt();
      break;
    }

    case 72: {
      enterOuterAlt(_localctx, 72);
      setState(1157);
      dropdb_stmt();
      break;
    }

    case 73: {
      enterOuterAlt(_localctx, 73);
      setState(1158);
      execute_stmt();
      break;
    }

    case 74: {
      enterOuterAlt(_localctx, 74);
      setState(1159);
      explain_stmt();
      break;
    }

    case 75: {
      enterOuterAlt(_localctx, 75);
      setState(1160);
      fetch_stmt();
      break;
    }

    case 76: {
      enterOuterAlt(_localctx, 76);
      setState(1161);
      grant_stmt();
      break;
    }

    case 77: {
      enterOuterAlt(_localctx, 77);
      setState(1162);
      grant_role_stmt();
      break;
    }

    case 78: {
      enterOuterAlt(_localctx, 78);
      setState(1163);
      index_stmt();
      break;
    }

    case 79: {
      enterOuterAlt(_localctx, 79);
      setState(1164);
      insert_stmt();
      break;
    }

    case 80: {
      enterOuterAlt(_localctx, 80);
      setState(1165);
      listen_stmt();
      break;
    }

    case 81: {
      enterOuterAlt(_localctx, 81);
      setState(1166);
      load_stmt();
      break;
    }

    case 82: {
      enterOuterAlt(_localctx, 82);
      setState(1167);
      lock_stmt();
      break;
    }

    case 83: {
      enterOuterAlt(_localctx, 83);
      setState(1168);
      notify_stmt();
      break;
    }

    case 84: {
      enterOuterAlt(_localctx, 84);
      setState(1169);
      prepare_stmt();
      break;
    }

    case 85: {
      enterOuterAlt(_localctx, 85);
      setState(1170);
      reassign_owned_stmt();
      break;
    }

    case 86: {
      enterOuterAlt(_localctx, 86);
      setState(1171);
      reindex_stmt();
      break;
    }

    case 87: {
      enterOuterAlt(_localctx, 87);
      setState(1172);
      remove_aggr_stmt();
      break;
    }

    case 88: {
      enterOuterAlt(_localctx, 88);
      setState(1173);
      remove_func_stmt();
      break;
    }

    case 89: {
      enterOuterAlt(_localctx, 89);
      setState(1174);
      remove_oper_stmt();
      break;
    }

    case 90: {
      enterOuterAlt(_localctx, 90);
      setState(1175);
      rename_stmt();
      break;
    }

    case 91: {
      enterOuterAlt(_localctx, 91);
      setState(1176);
      revoke_stmt();
      break;
    }

    case 92: {
      enterOuterAlt(_localctx, 92);
      setState(1177);
      revoke_role_stmt();
      break;
    }

    case 93: {
      enterOuterAlt(_localctx, 93);
      setState(1178);
      rule_stmt();
      break;
    }

    case 94: {
      enterOuterAlt(_localctx, 94);
      setState(1179);
      select_stmt();
      break;
    }

    case 95: {
      enterOuterAlt(_localctx, 95);
      setState(1180);
      transaction_stmt();
      break;
    }

    case 96: {
      enterOuterAlt(_localctx, 96);
      setState(1181);
      truncate_stmt();
      break;
    }

    case 97: {
      enterOuterAlt(_localctx, 97);
      setState(1182);
      unlisten_stmt();
      break;
    }

    case 98: {
      enterOuterAlt(_localctx, 98);
      setState(1183);
      update_stmt();
      break;
    }

    case 99: {
      enterOuterAlt(_localctx, 99);
      setState(1184);
      vacuum_stmt();
      break;
    }

    case 100: {
      enterOuterAlt(_localctx, 100);
      setState(1185);
      variable_reset_stmt();
      break;
    }

    case 101: {
      enterOuterAlt(_localctx, 101);
      setState(1186);
      variable_set_stmt();
      break;
    }

    case 102: {
      enterOuterAlt(_localctx, 102);
      setState(1187);
      variable_show_stmt();
      break;
    }

    case 103: {
      enterOuterAlt(_localctx, 103);
      setState(1188);
      view_stmt();
      break;
    }

    case 104: {
      enterOuterAlt(_localctx, 104);
      setState(1189);
      match(GreenPlumParser::SEMICOLON);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_queue_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_queue_stmtContext::Create_queue_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_queue_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_queue_stmtContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_queue_stmtContext::QUEUE() {
  return getToken(GreenPlumParser::QUEUE, 0);
}

GreenPlumParser::Queue_idContext* GreenPlumParser::Create_queue_stmtContext::queue_id() {
  return getRuleContext<GreenPlumParser::Queue_idContext>(0);
}

std::vector<GreenPlumParser::Opt_queue_elemContext *> GreenPlumParser::Create_queue_stmtContext::opt_queue_elem() {
  return getRuleContexts<GreenPlumParser::Opt_queue_elemContext>();
}

GreenPlumParser::Opt_queue_elemContext* GreenPlumParser::Create_queue_stmtContext::opt_queue_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Opt_queue_elemContext>(i);
}

tree::TerminalNode* GreenPlumParser::Create_queue_stmtContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Create_queue_stmtContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}


size_t GreenPlumParser::Create_queue_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_queue_stmt;
}

void GreenPlumParser::Create_queue_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_queue_stmt(this);
}

void GreenPlumParser::Create_queue_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_queue_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_queue_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_queue_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_queue_stmtContext* GreenPlumParser::create_queue_stmt() {
  Create_queue_stmtContext *_localctx = _tracker.createInstance<Create_queue_stmtContext>(_ctx, getState());
  enterRule(_localctx, 6, GreenPlumParser::RuleCreate_queue_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1215);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1192);
      match(GreenPlumParser::CREATE);
      setState(1193);
      match(GreenPlumParser::RESOURCE);
      setState(1194);
      match(GreenPlumParser::QUEUE);
      setState(1195);
      queue_id();
      setState(1199);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GreenPlumParser::ACTIVE || _la == GreenPlumParser::COST || _la == GreenPlumParser::IGNORE_P || _la == GreenPlumParser::NOOVERCOMMIT

      || _la == GreenPlumParser::OVERCOMMIT) {
        setState(1196);
        opt_queue_elem();
        setState(1201);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1202);
      match(GreenPlumParser::CREATE);
      setState(1203);
      match(GreenPlumParser::RESOURCE);
      setState(1204);
      match(GreenPlumParser::QUEUE);
      setState(1205);
      queue_id();
      setState(1209);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GreenPlumParser::ACTIVE || _la == GreenPlumParser::COST || _la == GreenPlumParser::IGNORE_P || _la == GreenPlumParser::NOOVERCOMMIT

      || _la == GreenPlumParser::OVERCOMMIT) {
        setState(1206);
        opt_queue_elem();
        setState(1211);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1212);
      match(GreenPlumParser::WITH);
      setState(1213);
      definition();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_queue_elemContext ------------------------------------------------------------------

GreenPlumParser::Opt_queue_elemContext::Opt_queue_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_queue_elemContext::ACTIVE() {
  return getToken(GreenPlumParser::ACTIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_queue_elemContext::THRESHOLD() {
  return getToken(GreenPlumParser::THRESHOLD, 0);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::Opt_queue_elemContext::numberic_only() {
  return getRuleContext<GreenPlumParser::Numberic_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_queue_elemContext::COST() {
  return getToken(GreenPlumParser::COST, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_queue_elemContext::IGNORE_P() {
  return getToken(GreenPlumParser::IGNORE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_queue_elemContext::OVERCOMMIT() {
  return getToken(GreenPlumParser::OVERCOMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_queue_elemContext::NOOVERCOMMIT() {
  return getToken(GreenPlumParser::NOOVERCOMMIT, 0);
}


size_t GreenPlumParser::Opt_queue_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_queue_elem;
}

void GreenPlumParser::Opt_queue_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_queue_elem(this);
}

void GreenPlumParser::Opt_queue_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_queue_elem(this);
}


antlrcpp::Any GreenPlumParser::Opt_queue_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_queue_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_queue_elemContext* GreenPlumParser::opt_queue_elem() {
  Opt_queue_elemContext *_localctx = _tracker.createInstance<Opt_queue_elemContext>(_ctx, getState());
  enterRule(_localctx, 8, GreenPlumParser::RuleOpt_queue_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1228);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ACTIVE: {
        enterOuterAlt(_localctx, 1);
        setState(1217);
        match(GreenPlumParser::ACTIVE);
        setState(1218);
        match(GreenPlumParser::THRESHOLD);
        setState(1219);
        numberic_only();
        break;
      }

      case GreenPlumParser::COST: {
        enterOuterAlt(_localctx, 2);
        setState(1220);
        match(GreenPlumParser::COST);
        setState(1221);
        match(GreenPlumParser::THRESHOLD);
        setState(1222);
        numberic_only();
        break;
      }

      case GreenPlumParser::IGNORE_P: {
        enterOuterAlt(_localctx, 3);
        setState(1223);
        match(GreenPlumParser::IGNORE_P);
        setState(1224);
        match(GreenPlumParser::THRESHOLD);
        setState(1225);
        numberic_only();
        break;
      }

      case GreenPlumParser::OVERCOMMIT: {
        enterOuterAlt(_localctx, 4);
        setState(1226);
        match(GreenPlumParser::OVERCOMMIT);
        break;
      }

      case GreenPlumParser::NOOVERCOMMIT: {
        enterOuterAlt(_localctx, 5);
        setState(1227);
        match(GreenPlumParser::NOOVERCOMMIT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_queue_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_queue_stmtContext::Alter_queue_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_queue_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_queue_stmtContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_queue_stmtContext::QUEUE() {
  return getToken(GreenPlumParser::QUEUE, 0);
}

GreenPlumParser::Queue_idContext* GreenPlumParser::Alter_queue_stmtContext::queue_id() {
  return getRuleContext<GreenPlumParser::Queue_idContext>(0);
}

std::vector<GreenPlumParser::Opt_queue_elemContext *> GreenPlumParser::Alter_queue_stmtContext::opt_queue_elem() {
  return getRuleContexts<GreenPlumParser::Opt_queue_elemContext>();
}

GreenPlumParser::Opt_queue_elemContext* GreenPlumParser::Alter_queue_stmtContext::opt_queue_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Opt_queue_elemContext>(i);
}

std::vector<GreenPlumParser::With_out_definitionContext *> GreenPlumParser::Alter_queue_stmtContext::with_out_definition() {
  return getRuleContexts<GreenPlumParser::With_out_definitionContext>();
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::Alter_queue_stmtContext::with_out_definition(size_t i) {
  return getRuleContext<GreenPlumParser::With_out_definitionContext>(i);
}


size_t GreenPlumParser::Alter_queue_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_queue_stmt;
}

void GreenPlumParser::Alter_queue_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_queue_stmt(this);
}

void GreenPlumParser::Alter_queue_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_queue_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_queue_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_queue_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_queue_stmtContext* GreenPlumParser::alter_queue_stmt() {
  Alter_queue_stmtContext *_localctx = _tracker.createInstance<Alter_queue_stmtContext>(_ctx, getState());
  enterRule(_localctx, 10, GreenPlumParser::RuleAlter_queue_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1230);
    match(GreenPlumParser::ALTER);
    setState(1231);
    match(GreenPlumParser::RESOURCE);
    setState(1232);
    match(GreenPlumParser::QUEUE);
    setState(1233);
    queue_id();
    setState(1237);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::ACTIVE || _la == GreenPlumParser::COST || _la == GreenPlumParser::IGNORE_P || _la == GreenPlumParser::NOOVERCOMMIT

    || _la == GreenPlumParser::OVERCOMMIT) {
      setState(1234);
      opt_queue_elem();
      setState(1239);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1243);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT) {
      setState(1240);
      with_out_definition();
      setState(1245);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_out_definitionContext ------------------------------------------------------------------

GreenPlumParser::With_out_definitionContext::With_out_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::DefinitionContext* GreenPlumParser::With_out_definitionContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}

tree::TerminalNode* GreenPlumParser::With_out_definitionContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::With_out_definitionContext::WITHOUT() {
  return getToken(GreenPlumParser::WITHOUT, 0);
}


size_t GreenPlumParser::With_out_definitionContext::getRuleIndex() const {
  return GreenPlumParser::RuleWith_out_definition;
}

void GreenPlumParser::With_out_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_out_definition(this);
}

void GreenPlumParser::With_out_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_out_definition(this);
}


antlrcpp::Any GreenPlumParser::With_out_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWith_out_definition(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::with_out_definition() {
  With_out_definitionContext *_localctx = _tracker.createInstance<With_out_definitionContext>(_ctx, getState());
  enterRule(_localctx, 12, GreenPlumParser::RuleWith_out_definition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1246);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1247);
    definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_queue_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_queue_stmtContext::Drop_queue_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_queue_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_queue_stmtContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_queue_stmtContext::QUEUE() {
  return getToken(GreenPlumParser::QUEUE, 0);
}

GreenPlumParser::Queue_idContext* GreenPlumParser::Drop_queue_stmtContext::queue_id() {
  return getRuleContext<GreenPlumParser::Queue_idContext>(0);
}


size_t GreenPlumParser::Drop_queue_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_queue_stmt;
}

void GreenPlumParser::Drop_queue_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_queue_stmt(this);
}

void GreenPlumParser::Drop_queue_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_queue_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_queue_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_queue_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_queue_stmtContext* GreenPlumParser::drop_queue_stmt() {
  Drop_queue_stmtContext *_localctx = _tracker.createInstance<Drop_queue_stmtContext>(_ctx, getState());
  enterRule(_localctx, 14, GreenPlumParser::RuleDrop_queue_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1249);
    match(GreenPlumParser::DROP);
    setState(1250);
    match(GreenPlumParser::RESOURCE);
    setState(1251);
    match(GreenPlumParser::QUEUE);
    setState(1252);
    queue_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_resource_group_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_resource_group_stmtContext::Create_resource_group_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_resource_group_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_resource_group_stmtContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_resource_group_stmtContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Create_resource_group_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::Create_resource_group_stmtContext::with_out_definition() {
  return getRuleContext<GreenPlumParser::With_out_definitionContext>(0);
}


size_t GreenPlumParser::Create_resource_group_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_resource_group_stmt;
}

void GreenPlumParser::Create_resource_group_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_resource_group_stmt(this);
}

void GreenPlumParser::Create_resource_group_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_resource_group_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_resource_group_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_resource_group_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_resource_group_stmtContext* GreenPlumParser::create_resource_group_stmt() {
  Create_resource_group_stmtContext *_localctx = _tracker.createInstance<Create_resource_group_stmtContext>(_ctx, getState());
  enterRule(_localctx, 16, GreenPlumParser::RuleCreate_resource_group_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1254);
    match(GreenPlumParser::CREATE);
    setState(1255);
    match(GreenPlumParser::RESOURCE);
    setState(1256);
    match(GreenPlumParser::GROUP_P);
    setState(1257);
    name();
    setState(1258);
    with_out_definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_resource_group_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_resource_group_stmtContext::Drop_resource_group_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_resource_group_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_resource_group_stmtContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_resource_group_stmtContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Drop_resource_group_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Drop_resource_group_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_resource_group_stmt;
}

void GreenPlumParser::Drop_resource_group_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_resource_group_stmt(this);
}

void GreenPlumParser::Drop_resource_group_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_resource_group_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_resource_group_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_resource_group_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_resource_group_stmtContext* GreenPlumParser::drop_resource_group_stmt() {
  Drop_resource_group_stmtContext *_localctx = _tracker.createInstance<Drop_resource_group_stmtContext>(_ctx, getState());
  enterRule(_localctx, 18, GreenPlumParser::RuleDrop_resource_group_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1260);
    match(GreenPlumParser::DROP);
    setState(1261);
    match(GreenPlumParser::RESOURCE);
    setState(1262);
    match(GreenPlumParser::GROUP_P);
    setState(1263);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_resource_group_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_resource_group_stmtContext::Alter_resource_group_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_resource_group_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_resource_group_stmtContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_resource_group_stmtContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_resource_group_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_resource_group_stmtContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

GreenPlumParser::Resource_group_elemContext* GreenPlumParser::Alter_resource_group_stmtContext::resource_group_elem() {
  return getRuleContext<GreenPlumParser::Resource_group_elemContext>(0);
}


size_t GreenPlumParser::Alter_resource_group_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_resource_group_stmt;
}

void GreenPlumParser::Alter_resource_group_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_resource_group_stmt(this);
}

void GreenPlumParser::Alter_resource_group_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_resource_group_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_resource_group_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_resource_group_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_resource_group_stmtContext* GreenPlumParser::alter_resource_group_stmt() {
  Alter_resource_group_stmtContext *_localctx = _tracker.createInstance<Alter_resource_group_stmtContext>(_ctx, getState());
  enterRule(_localctx, 20, GreenPlumParser::RuleAlter_resource_group_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1265);
    match(GreenPlumParser::ALTER);
    setState(1266);
    match(GreenPlumParser::RESOURCE);
    setState(1267);
    match(GreenPlumParser::GROUP_P);
    setState(1268);
    name();
    setState(1269);
    match(GreenPlumParser::SET);
    setState(1271);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & ((1ULL << (GreenPlumParser::CONCURRENCY - 58))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 58))
      | (1ULL << (GreenPlumParser::CPUSET - 58)))) != 0) || ((((_la - 232) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 232)) & ((1ULL << (GreenPlumParser::MEMORY_LIMIT - 232))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 232))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 232)))) != 0)) {
      setState(1270);
      resource_group_elem();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Resource_group_elemContext ------------------------------------------------------------------

GreenPlumParser::Resource_group_elemContext::Resource_group_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Resource_group_elemContext::CONCURRENCY() {
  return getToken(GreenPlumParser::CONCURRENCY, 0);
}

GreenPlumParser::Integer_onlyContext* GreenPlumParser::Resource_group_elemContext::integer_only() {
  return getRuleContext<GreenPlumParser::Integer_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Resource_group_elemContext::CPU_RATE_LIMIT() {
  return getToken(GreenPlumParser::CPU_RATE_LIMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Resource_group_elemContext::CPUSET() {
  return getToken(GreenPlumParser::CPUSET, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Resource_group_elemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Resource_group_elemContext::MEMORY_SHARED_QUOTA() {
  return getToken(GreenPlumParser::MEMORY_SHARED_QUOTA, 0);
}

tree::TerminalNode* GreenPlumParser::Resource_group_elemContext::MEMORY_LIMIT() {
  return getToken(GreenPlumParser::MEMORY_LIMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Resource_group_elemContext::MEMORY_SPILL_RATIO() {
  return getToken(GreenPlumParser::MEMORY_SPILL_RATIO, 0);
}


size_t GreenPlumParser::Resource_group_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleResource_group_elem;
}

void GreenPlumParser::Resource_group_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResource_group_elem(this);
}

void GreenPlumParser::Resource_group_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResource_group_elem(this);
}


antlrcpp::Any GreenPlumParser::Resource_group_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitResource_group_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Resource_group_elemContext* GreenPlumParser::resource_group_elem() {
  Resource_group_elemContext *_localctx = _tracker.createInstance<Resource_group_elemContext>(_ctx, getState());
  enterRule(_localctx, 22, GreenPlumParser::RuleResource_group_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1285);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CONCURRENCY: {
        enterOuterAlt(_localctx, 1);
        setState(1273);
        match(GreenPlumParser::CONCURRENCY);
        setState(1274);
        integer_only();
        break;
      }

      case GreenPlumParser::CPU_RATE_LIMIT: {
        enterOuterAlt(_localctx, 2);
        setState(1275);
        match(GreenPlumParser::CPU_RATE_LIMIT);
        setState(1276);
        integer_only();
        break;
      }

      case GreenPlumParser::CPUSET: {
        enterOuterAlt(_localctx, 3);
        setState(1277);
        match(GreenPlumParser::CPUSET);
        setState(1278);
        sconst();
        break;
      }

      case GreenPlumParser::MEMORY_SHARED_QUOTA: {
        enterOuterAlt(_localctx, 4);
        setState(1279);
        match(GreenPlumParser::MEMORY_SHARED_QUOTA);
        setState(1280);
        integer_only();
        break;
      }

      case GreenPlumParser::MEMORY_LIMIT: {
        enterOuterAlt(_localctx, 5);
        setState(1281);
        match(GreenPlumParser::MEMORY_LIMIT);
        setState(1282);
        integer_only();
        break;
      }

      case GreenPlumParser::MEMORY_SPILL_RATIO: {
        enterOuterAlt(_localctx, 6);
        setState(1283);
        match(GreenPlumParser::MEMORY_SPILL_RATIO);
        setState(1284);
        integer_only();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_role_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_role_stmtContext::Create_role_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_role_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_role_stmtContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Create_role_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Create_role_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Role_elemContext *> GreenPlumParser::Create_role_stmtContext::role_elem() {
  return getRuleContexts<GreenPlumParser::Role_elemContext>();
}

GreenPlumParser::Role_elemContext* GreenPlumParser::Create_role_stmtContext::role_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Role_elemContext>(i);
}


size_t GreenPlumParser::Create_role_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_role_stmt;
}

void GreenPlumParser::Create_role_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_role_stmt(this);
}

void GreenPlumParser::Create_role_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_role_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_role_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_role_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_role_stmtContext* GreenPlumParser::create_role_stmt() {
  Create_role_stmtContext *_localctx = _tracker.createInstance<Create_role_stmtContext>(_ctx, getState());
  enterRule(_localctx, 24, GreenPlumParser::RuleCreate_role_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1287);
    match(GreenPlumParser::CREATE);
    setState(1288);
    match(GreenPlumParser::ROLE);
    setState(1289);
    role_id();
    setState(1291);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(1290);
      opt_with();
    }
    setState(1296);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::ADMIN

    || _la == GreenPlumParser::CONNECTION || ((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & ((1ULL << (GreenPlumParser::CREATEDB - 74))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 74))
      | (1ULL << (GreenPlumParser::CREATEROLE - 74))
      | (1ULL << (GreenPlumParser::CREATEUSER - 74))
      | (1ULL << (GreenPlumParser::DENY - 74))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 74)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & ((1ULL << (GreenPlumParser::INHERIT - 186))
      | (1ULL << (GreenPlumParser::IN_P - 186))
      | (1ULL << (GreenPlumParser::LOGIN_P - 186)))) != 0) || ((((_la - 253) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 253)) & ((1ULL << (GreenPlumParser::NOCREATEDB - 253))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 253))
      | (1ULL << (GreenPlumParser::NOINHERIT - 253))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 253))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 253))
      | (1ULL << (GreenPlumParser::PASSWORD - 253)))) != 0) || ((((_la - 343) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 343)) & ((1ULL << (GreenPlumParser::RESOURCE - 343))
      | (1ULL << (GreenPlumParser::ROLE - 343))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 343))
      | (1ULL << (GreenPlumParser::SYSID - 343)))) != 0) || ((((_la - 422) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 422)) & ((1ULL << (GreenPlumParser::UNENCRYPTED - 422))
      | (1ULL << (GreenPlumParser::USER - 422))
      | (1ULL << (GreenPlumParser::VALID - 422)))) != 0)) {
      setState(1293);
      role_elem();
      setState(1298);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_withContext ------------------------------------------------------------------

GreenPlumParser::Opt_withContext::Opt_withContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_withContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}


size_t GreenPlumParser::Opt_withContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_with;
}

void GreenPlumParser::Opt_withContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_with(this);
}

void GreenPlumParser::Opt_withContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_with(this);
}


antlrcpp::Any GreenPlumParser::Opt_withContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_with(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::opt_with() {
  Opt_withContext *_localctx = _tracker.createInstance<Opt_withContext>(_ctx, getState());
  enterRule(_localctx, 26, GreenPlumParser::RuleOpt_with);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1299);
    match(GreenPlumParser::WITH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Role_elemContext ------------------------------------------------------------------

GreenPlumParser::Role_elemContext::Role_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::PASSWORD() {
  return getToken(GreenPlumParser::PASSWORD, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Role_elemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::ENCRYPTED() {
  return getToken(GreenPlumParser::ENCRYPTED, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::UNENCRYPTED() {
  return getToken(GreenPlumParser::UNENCRYPTED, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::SUPERUSER_P() {
  return getToken(GreenPlumParser::SUPERUSER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NOSUPERUSER() {
  return getToken(GreenPlumParser::NOSUPERUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::INHERIT() {
  return getToken(GreenPlumParser::INHERIT, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NOINHERIT() {
  return getToken(GreenPlumParser::NOINHERIT, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::CREATEDB() {
  return getToken(GreenPlumParser::CREATEDB, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NOCREATEDB() {
  return getToken(GreenPlumParser::NOCREATEDB, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::CREATEROLE() {
  return getToken(GreenPlumParser::CREATEROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NOCREATEROLE() {
  return getToken(GreenPlumParser::NOCREATEROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::CREATEUSER() {
  return getToken(GreenPlumParser::CREATEUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NOCREATEUSER() {
  return getToken(GreenPlumParser::NOCREATEUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::LOGIN_P() {
  return getToken(GreenPlumParser::LOGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NOLOGIN_P() {
  return getToken(GreenPlumParser::NOLOGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::CONNECTION() {
  return getToken(GreenPlumParser::CONNECTION, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::LIMIT() {
  return getToken(GreenPlumParser::LIMIT, 0);
}

GreenPlumParser::Signed_iconstContext* GreenPlumParser::Role_elemContext::signed_iconst() {
  return getRuleContext<GreenPlumParser::Signed_iconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::VALID() {
  return getToken(GreenPlumParser::VALID, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::UNTIL() {
  return getToken(GreenPlumParser::UNTIL, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::QUEUE() {
  return getToken(GreenPlumParser::QUEUE, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Role_elemContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Role_elemContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::SYSID() {
  return getToken(GreenPlumParser::SYSID, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Role_elemContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::ADMIN() {
  return getToken(GreenPlumParser::ADMIN, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::IN_P() {
  return getToken(GreenPlumParser::IN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::CREATEEXTTABLE() {
  return getToken(GreenPlumParser::CREATEEXTTABLE, 0);
}

GreenPlumParser::Exttab_auth_listContext* GreenPlumParser::Role_elemContext::exttab_auth_list() {
  return getRuleContext<GreenPlumParser::Exttab_auth_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Role_elemContext::NOCREATEEXTTABLE() {
  return getToken(GreenPlumParser::NOCREATEEXTTABLE, 0);
}

GreenPlumParser::Deny_login_roleContext* GreenPlumParser::Role_elemContext::deny_login_role() {
  return getRuleContext<GreenPlumParser::Deny_login_roleContext>(0);
}


size_t GreenPlumParser::Role_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleRole_elem;
}

void GreenPlumParser::Role_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRole_elem(this);
}

void GreenPlumParser::Role_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRole_elem(this);
}


antlrcpp::Any GreenPlumParser::Role_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRole_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Role_elemContext* GreenPlumParser::role_elem() {
  Role_elemContext *_localctx = _tracker.createInstance<Role_elemContext>(_ctx, getState());
  enterRule(_localctx, 28, GreenPlumParser::RuleRole_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1354);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1301);
      match(GreenPlumParser::PASSWORD);
      setState(1302);
      sconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1303);
      match(GreenPlumParser::PASSWORD);
      setState(1304);
      match(GreenPlumParser::NULL_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1305);
      match(GreenPlumParser::ENCRYPTED);
      setState(1306);
      match(GreenPlumParser::PASSWORD);
      setState(1307);
      sconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1308);
      match(GreenPlumParser::UNENCRYPTED);
      setState(1309);
      match(GreenPlumParser::PASSWORD);
      setState(1310);
      sconst();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1311);
      match(GreenPlumParser::SUPERUSER_P);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1312);
      match(GreenPlumParser::NOSUPERUSER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1313);
      match(GreenPlumParser::INHERIT);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1314);
      match(GreenPlumParser::NOINHERIT);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1315);
      match(GreenPlumParser::CREATEDB);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1316);
      match(GreenPlumParser::NOCREATEDB);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1317);
      match(GreenPlumParser::CREATEROLE);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1318);
      match(GreenPlumParser::NOCREATEROLE);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1319);
      match(GreenPlumParser::CREATEUSER);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1320);
      match(GreenPlumParser::NOCREATEUSER);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1321);
      match(GreenPlumParser::LOGIN_P);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1322);
      match(GreenPlumParser::NOLOGIN_P);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1323);
      match(GreenPlumParser::CONNECTION);
      setState(1324);
      match(GreenPlumParser::LIMIT);
      setState(1325);
      signed_iconst();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1326);
      match(GreenPlumParser::VALID);
      setState(1327);
      match(GreenPlumParser::UNTIL);
      setState(1328);
      sconst();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1329);
      match(GreenPlumParser::RESOURCE);
      setState(1330);
      match(GreenPlumParser::QUEUE);
      setState(1331);
      any_name();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1332);
      match(GreenPlumParser::RESOURCE);
      setState(1333);
      match(GreenPlumParser::GROUP_P);
      setState(1334);
      any_name();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1335);
      match(GreenPlumParser::USER);
      setState(1336);
      name_list();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1337);
      match(GreenPlumParser::SYSID);
      setState(1338);
      iconst();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1339);
      match(GreenPlumParser::ADMIN);
      setState(1340);
      name_list();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(1341);
      match(GreenPlumParser::ROLE);
      setState(1342);
      name_list();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(1343);
      match(GreenPlumParser::IN_P);
      setState(1344);
      match(GreenPlumParser::ROLE);
      setState(1345);
      name_list();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(1346);
      match(GreenPlumParser::IN_P);
      setState(1347);
      match(GreenPlumParser::GROUP_P);
      setState(1348);
      name_list();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(1349);
      match(GreenPlumParser::CREATEEXTTABLE);
      setState(1350);
      exttab_auth_list();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(1351);
      match(GreenPlumParser::NOCREATEEXTTABLE);
      setState(1352);
      exttab_auth_list();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(1353);
      deny_login_role();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deny_login_roleContext ------------------------------------------------------------------

GreenPlumParser::Deny_login_roleContext::Deny_login_roleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Deny_login_roleContext::DENY() {
  return getToken(GreenPlumParser::DENY, 0);
}

GreenPlumParser::Deny_intervalContext* GreenPlumParser::Deny_login_roleContext::deny_interval() {
  return getRuleContext<GreenPlumParser::Deny_intervalContext>(0);
}

GreenPlumParser::Deny_pointContext* GreenPlumParser::Deny_login_roleContext::deny_point() {
  return getRuleContext<GreenPlumParser::Deny_pointContext>(0);
}


size_t GreenPlumParser::Deny_login_roleContext::getRuleIndex() const {
  return GreenPlumParser::RuleDeny_login_role;
}

void GreenPlumParser::Deny_login_roleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeny_login_role(this);
}

void GreenPlumParser::Deny_login_roleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeny_login_role(this);
}


antlrcpp::Any GreenPlumParser::Deny_login_roleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDeny_login_role(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Deny_login_roleContext* GreenPlumParser::deny_login_role() {
  Deny_login_roleContext *_localctx = _tracker.createInstance<Deny_login_roleContext>(_ctx, getState());
  enterRule(_localctx, 30, GreenPlumParser::RuleDeny_login_role);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1360);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1356);
      match(GreenPlumParser::DENY);
      setState(1357);
      deny_interval();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1358);
      match(GreenPlumParser::DENY);
      setState(1359);
      deny_point();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deny_intervalContext ------------------------------------------------------------------

GreenPlumParser::Deny_intervalContext::Deny_intervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Deny_intervalContext::BETWEEN() {
  return getToken(GreenPlumParser::BETWEEN, 0);
}

std::vector<GreenPlumParser::Deny_pointContext *> GreenPlumParser::Deny_intervalContext::deny_point() {
  return getRuleContexts<GreenPlumParser::Deny_pointContext>();
}

GreenPlumParser::Deny_pointContext* GreenPlumParser::Deny_intervalContext::deny_point(size_t i) {
  return getRuleContext<GreenPlumParser::Deny_pointContext>(i);
}

tree::TerminalNode* GreenPlumParser::Deny_intervalContext::AND() {
  return getToken(GreenPlumParser::AND, 0);
}


size_t GreenPlumParser::Deny_intervalContext::getRuleIndex() const {
  return GreenPlumParser::RuleDeny_interval;
}

void GreenPlumParser::Deny_intervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeny_interval(this);
}

void GreenPlumParser::Deny_intervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeny_interval(this);
}


antlrcpp::Any GreenPlumParser::Deny_intervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDeny_interval(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Deny_intervalContext* GreenPlumParser::deny_interval() {
  Deny_intervalContext *_localctx = _tracker.createInstance<Deny_intervalContext>(_ctx, getState());
  enterRule(_localctx, 32, GreenPlumParser::RuleDeny_interval);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1362);
    match(GreenPlumParser::BETWEEN);
    setState(1363);
    deny_point();
    setState(1364);
    match(GreenPlumParser::AND);
    setState(1365);
    deny_point();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deny_day_specifierContext ------------------------------------------------------------------

GreenPlumParser::Deny_day_specifierContext::Deny_day_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::SconstContext* GreenPlumParser::Deny_day_specifierContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Deny_day_specifierContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}


size_t GreenPlumParser::Deny_day_specifierContext::getRuleIndex() const {
  return GreenPlumParser::RuleDeny_day_specifier;
}

void GreenPlumParser::Deny_day_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeny_day_specifier(this);
}

void GreenPlumParser::Deny_day_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeny_day_specifier(this);
}


antlrcpp::Any GreenPlumParser::Deny_day_specifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDeny_day_specifier(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Deny_day_specifierContext* GreenPlumParser::deny_day_specifier() {
  Deny_day_specifierContext *_localctx = _tracker.createInstance<Deny_day_specifierContext>(_ctx, getState());
  enterRule(_localctx, 34, GreenPlumParser::RuleDeny_day_specifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1369);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(1367);
        sconst();
        break;
      }

      case GreenPlumParser::ICONST: {
        enterOuterAlt(_localctx, 2);
        setState(1368);
        iconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deny_pointContext ------------------------------------------------------------------

GreenPlumParser::Deny_pointContext::Deny_pointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Deny_pointContext::DAY_P() {
  return getToken(GreenPlumParser::DAY_P, 0);
}

GreenPlumParser::Deny_day_specifierContext* GreenPlumParser::Deny_pointContext::deny_day_specifier() {
  return getRuleContext<GreenPlumParser::Deny_day_specifierContext>(0);
}

GreenPlumParser::Opt_timeContext* GreenPlumParser::Deny_pointContext::opt_time() {
  return getRuleContext<GreenPlumParser::Opt_timeContext>(0);
}


size_t GreenPlumParser::Deny_pointContext::getRuleIndex() const {
  return GreenPlumParser::RuleDeny_point;
}

void GreenPlumParser::Deny_pointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeny_point(this);
}

void GreenPlumParser::Deny_pointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeny_point(this);
}


antlrcpp::Any GreenPlumParser::Deny_pointContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDeny_point(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Deny_pointContext* GreenPlumParser::deny_point() {
  Deny_pointContext *_localctx = _tracker.createInstance<Deny_pointContext>(_ctx, getState());
  enterRule(_localctx, 36, GreenPlumParser::RuleDeny_point);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1371);
    match(GreenPlumParser::DAY_P);
    setState(1372);
    deny_day_specifier();
    setState(1373);
    opt_time();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_timeContext ------------------------------------------------------------------

GreenPlumParser::Opt_timeContext::Opt_timeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_timeContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Opt_timeContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::Opt_timeContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_time;
}

void GreenPlumParser::Opt_timeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_time(this);
}

void GreenPlumParser::Opt_timeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_time(this);
}


antlrcpp::Any GreenPlumParser::Opt_timeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_time(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_timeContext* GreenPlumParser::opt_time() {
  Opt_timeContext *_localctx = _tracker.createInstance<Opt_timeContext>(_ctx, getState());
  enterRule(_localctx, 38, GreenPlumParser::RuleOpt_time);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1375);
    match(GreenPlumParser::TIME);
    setState(1376);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exttab_auth_listContext ------------------------------------------------------------------

GreenPlumParser::Exttab_auth_listContext::Exttab_auth_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Exttab_auth_listContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Keyvalue_listContext* GreenPlumParser::Exttab_auth_listContext::keyvalue_list() {
  return getRuleContext<GreenPlumParser::Keyvalue_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Exttab_auth_listContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Exttab_auth_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleExttab_auth_list;
}

void GreenPlumParser::Exttab_auth_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExttab_auth_list(this);
}

void GreenPlumParser::Exttab_auth_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExttab_auth_list(this);
}


antlrcpp::Any GreenPlumParser::Exttab_auth_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExttab_auth_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Exttab_auth_listContext* GreenPlumParser::exttab_auth_list() {
  Exttab_auth_listContext *_localctx = _tracker.createInstance<Exttab_auth_listContext>(_ctx, getState());
  enterRule(_localctx, 40, GreenPlumParser::RuleExttab_auth_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1378);
    match(GreenPlumParser::LEFT_PAREN);
    setState(1379);
    keyvalue_list();
    setState(1380);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyvalue_listContext ------------------------------------------------------------------

GreenPlumParser::Keyvalue_listContext::Keyvalue_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Keyvalue_pairContext *> GreenPlumParser::Keyvalue_listContext::keyvalue_pair() {
  return getRuleContexts<GreenPlumParser::Keyvalue_pairContext>();
}

GreenPlumParser::Keyvalue_pairContext* GreenPlumParser::Keyvalue_listContext::keyvalue_pair(size_t i) {
  return getRuleContext<GreenPlumParser::Keyvalue_pairContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Keyvalue_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Keyvalue_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Keyvalue_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleKeyvalue_list;
}

void GreenPlumParser::Keyvalue_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyvalue_list(this);
}

void GreenPlumParser::Keyvalue_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyvalue_list(this);
}


antlrcpp::Any GreenPlumParser::Keyvalue_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKeyvalue_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Keyvalue_listContext* GreenPlumParser::keyvalue_list() {
  Keyvalue_listContext *_localctx = _tracker.createInstance<Keyvalue_listContext>(_ctx, getState());
  enterRule(_localctx, 42, GreenPlumParser::RuleKeyvalue_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1382);
    keyvalue_pair();
    setState(1387);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(1383);
      match(GreenPlumParser::COMMA);
      setState(1384);
      keyvalue_pair();
      setState(1389);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyvalue_pairContext ------------------------------------------------------------------

GreenPlumParser::Keyvalue_pairContext::Keyvalue_pairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Keyvalue_pairContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}

tree::TerminalNode* GreenPlumParser::Keyvalue_pairContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Keyvalue_pairContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::Keyvalue_pairContext::getRuleIndex() const {
  return GreenPlumParser::RuleKeyvalue_pair;
}

void GreenPlumParser::Keyvalue_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyvalue_pair(this);
}

void GreenPlumParser::Keyvalue_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyvalue_pair(this);
}


antlrcpp::Any GreenPlumParser::Keyvalue_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKeyvalue_pair(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Keyvalue_pairContext* GreenPlumParser::keyvalue_pair() {
  Keyvalue_pairContext *_localctx = _tracker.createInstance<Keyvalue_pairContext>(_ctx, getState());
  enterRule(_localctx, 44, GreenPlumParser::RuleKeyvalue_pair);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1390);
    col_label();
    setState(1391);
    match(GreenPlumParser::EQUALS_OP);
    setState(1392);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_user_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_user_stmtContext::Create_user_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_user_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_user_stmtContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Create_user_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Create_user_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Role_elemContext *> GreenPlumParser::Create_user_stmtContext::role_elem() {
  return getRuleContexts<GreenPlumParser::Role_elemContext>();
}

GreenPlumParser::Role_elemContext* GreenPlumParser::Create_user_stmtContext::role_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Role_elemContext>(i);
}


size_t GreenPlumParser::Create_user_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_user_stmt;
}

void GreenPlumParser::Create_user_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_user_stmt(this);
}

void GreenPlumParser::Create_user_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_user_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_user_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_user_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_user_stmtContext* GreenPlumParser::create_user_stmt() {
  Create_user_stmtContext *_localctx = _tracker.createInstance<Create_user_stmtContext>(_ctx, getState());
  enterRule(_localctx, 46, GreenPlumParser::RuleCreate_user_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1394);
    match(GreenPlumParser::CREATE);
    setState(1395);
    match(GreenPlumParser::USER);
    setState(1396);
    role_id();
    setState(1398);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(1397);
      opt_with();
    }
    setState(1403);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::ADMIN

    || _la == GreenPlumParser::CONNECTION || ((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & ((1ULL << (GreenPlumParser::CREATEDB - 74))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 74))
      | (1ULL << (GreenPlumParser::CREATEROLE - 74))
      | (1ULL << (GreenPlumParser::CREATEUSER - 74))
      | (1ULL << (GreenPlumParser::DENY - 74))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 74)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & ((1ULL << (GreenPlumParser::INHERIT - 186))
      | (1ULL << (GreenPlumParser::IN_P - 186))
      | (1ULL << (GreenPlumParser::LOGIN_P - 186)))) != 0) || ((((_la - 253) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 253)) & ((1ULL << (GreenPlumParser::NOCREATEDB - 253))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 253))
      | (1ULL << (GreenPlumParser::NOINHERIT - 253))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 253))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 253))
      | (1ULL << (GreenPlumParser::PASSWORD - 253)))) != 0) || ((((_la - 343) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 343)) & ((1ULL << (GreenPlumParser::RESOURCE - 343))
      | (1ULL << (GreenPlumParser::ROLE - 343))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 343))
      | (1ULL << (GreenPlumParser::SYSID - 343)))) != 0) || ((((_la - 422) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 422)) & ((1ULL << (GreenPlumParser::UNENCRYPTED - 422))
      | (1ULL << (GreenPlumParser::USER - 422))
      | (1ULL << (GreenPlumParser::VALID - 422)))) != 0)) {
      setState(1400);
      role_elem();
      setState(1405);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_role_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_role_stmtContext::Alter_role_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_role_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_role_stmtContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Alter_role_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Alter_role_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Alter_role_elemContext *> GreenPlumParser::Alter_role_stmtContext::alter_role_elem() {
  return getRuleContexts<GreenPlumParser::Alter_role_elemContext>();
}

GreenPlumParser::Alter_role_elemContext* GreenPlumParser::Alter_role_stmtContext::alter_role_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Alter_role_elemContext>(i);
}


size_t GreenPlumParser::Alter_role_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_role_stmt;
}

void GreenPlumParser::Alter_role_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_role_stmt(this);
}

void GreenPlumParser::Alter_role_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_role_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_role_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_role_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_role_stmtContext* GreenPlumParser::alter_role_stmt() {
  Alter_role_stmtContext *_localctx = _tracker.createInstance<Alter_role_stmtContext>(_ctx, getState());
  enterRule(_localctx, 48, GreenPlumParser::RuleAlter_role_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1406);
    match(GreenPlumParser::ALTER);
    setState(1407);
    match(GreenPlumParser::ROLE);
    setState(1408);
    role_id();
    setState(1410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(1409);
      opt_with();
    }
    setState(1415);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::ADMIN

    || _la == GreenPlumParser::CONNECTION || ((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & ((1ULL << (GreenPlumParser::CREATEDB - 74))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 74))
      | (1ULL << (GreenPlumParser::CREATEROLE - 74))
      | (1ULL << (GreenPlumParser::CREATEUSER - 74))
      | (1ULL << (GreenPlumParser::DENY - 74))
      | (1ULL << (GreenPlumParser::DROP - 74))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 74)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & ((1ULL << (GreenPlumParser::INHERIT - 186))
      | (1ULL << (GreenPlumParser::IN_P - 186))
      | (1ULL << (GreenPlumParser::LOGIN_P - 186)))) != 0) || ((((_la - 253) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 253)) & ((1ULL << (GreenPlumParser::NOCREATEDB - 253))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 253))
      | (1ULL << (GreenPlumParser::NOINHERIT - 253))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 253))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 253))
      | (1ULL << (GreenPlumParser::PASSWORD - 253)))) != 0) || ((((_la - 343) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 343)) & ((1ULL << (GreenPlumParser::RESOURCE - 343))
      | (1ULL << (GreenPlumParser::ROLE - 343))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 343))
      | (1ULL << (GreenPlumParser::SYSID - 343)))) != 0) || ((((_la - 422) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 422)) & ((1ULL << (GreenPlumParser::UNENCRYPTED - 422))
      | (1ULL << (GreenPlumParser::USER - 422))
      | (1ULL << (GreenPlumParser::VALID - 422)))) != 0)) {
      setState(1412);
      alter_role_elem();
      setState(1417);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_role_set_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_role_set_stmtContext::Alter_role_set_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_role_set_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_role_set_stmtContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Alter_role_set_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Set_reset_clauseContext* GreenPlumParser::Alter_role_set_stmtContext::set_reset_clause() {
  return getRuleContext<GreenPlumParser::Set_reset_clauseContext>(0);
}


size_t GreenPlumParser::Alter_role_set_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_role_set_stmt;
}

void GreenPlumParser::Alter_role_set_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_role_set_stmt(this);
}

void GreenPlumParser::Alter_role_set_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_role_set_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_role_set_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_role_set_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_role_set_stmtContext* GreenPlumParser::alter_role_set_stmt() {
  Alter_role_set_stmtContext *_localctx = _tracker.createInstance<Alter_role_set_stmtContext>(_ctx, getState());
  enterRule(_localctx, 50, GreenPlumParser::RuleAlter_role_set_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1418);
    match(GreenPlumParser::ALTER);
    setState(1419);
    match(GreenPlumParser::ROLE);
    setState(1420);
    role_id();
    setState(1421);
    set_reset_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_role_elemContext ------------------------------------------------------------------

GreenPlumParser::Alter_role_elemContext::Alter_role_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Role_elemContext* GreenPlumParser::Alter_role_elemContext::role_elem() {
  return getRuleContext<GreenPlumParser::Role_elemContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_role_elemContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_role_elemContext::DENY() {
  return getToken(GreenPlumParser::DENY, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_role_elemContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

GreenPlumParser::Deny_pointContext* GreenPlumParser::Alter_role_elemContext::deny_point() {
  return getRuleContext<GreenPlumParser::Deny_pointContext>(0);
}


size_t GreenPlumParser::Alter_role_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_role_elem;
}

void GreenPlumParser::Alter_role_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_role_elem(this);
}

void GreenPlumParser::Alter_role_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_role_elem(this);
}


antlrcpp::Any GreenPlumParser::Alter_role_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_role_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_role_elemContext* GreenPlumParser::alter_role_elem() {
  Alter_role_elemContext *_localctx = _tracker.createInstance<Alter_role_elemContext>(_ctx, getState());
  enterRule(_localctx, 52, GreenPlumParser::RuleAlter_role_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1428);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::DENY:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::IN_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::USER:
      case GreenPlumParser::VALID: {
        enterOuterAlt(_localctx, 1);
        setState(1423);
        role_elem();
        break;
      }

      case GreenPlumParser::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(1424);
        match(GreenPlumParser::DROP);
        setState(1425);
        match(GreenPlumParser::DENY);
        setState(1426);
        match(GreenPlumParser::FOR);
        setState(1427);
        deny_point();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_user_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_user_stmtContext::Alter_user_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_user_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_user_stmtContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Alter_user_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Alter_user_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Alter_role_elemContext *> GreenPlumParser::Alter_user_stmtContext::alter_role_elem() {
  return getRuleContexts<GreenPlumParser::Alter_role_elemContext>();
}

GreenPlumParser::Alter_role_elemContext* GreenPlumParser::Alter_user_stmtContext::alter_role_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Alter_role_elemContext>(i);
}


size_t GreenPlumParser::Alter_user_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_user_stmt;
}

void GreenPlumParser::Alter_user_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_user_stmt(this);
}

void GreenPlumParser::Alter_user_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_user_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_user_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_user_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_user_stmtContext* GreenPlumParser::alter_user_stmt() {
  Alter_user_stmtContext *_localctx = _tracker.createInstance<Alter_user_stmtContext>(_ctx, getState());
  enterRule(_localctx, 54, GreenPlumParser::RuleAlter_user_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1430);
    match(GreenPlumParser::ALTER);
    setState(1431);
    match(GreenPlumParser::USER);
    setState(1432);
    role_id();
    setState(1434);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(1433);
      opt_with();
    }
    setState(1439);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::ADMIN

    || _la == GreenPlumParser::CONNECTION || ((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & ((1ULL << (GreenPlumParser::CREATEDB - 74))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 74))
      | (1ULL << (GreenPlumParser::CREATEROLE - 74))
      | (1ULL << (GreenPlumParser::CREATEUSER - 74))
      | (1ULL << (GreenPlumParser::DENY - 74))
      | (1ULL << (GreenPlumParser::DROP - 74))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 74)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & ((1ULL << (GreenPlumParser::INHERIT - 186))
      | (1ULL << (GreenPlumParser::IN_P - 186))
      | (1ULL << (GreenPlumParser::LOGIN_P - 186)))) != 0) || ((((_la - 253) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 253)) & ((1ULL << (GreenPlumParser::NOCREATEDB - 253))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 253))
      | (1ULL << (GreenPlumParser::NOINHERIT - 253))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 253))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 253))
      | (1ULL << (GreenPlumParser::PASSWORD - 253)))) != 0) || ((((_la - 343) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 343)) & ((1ULL << (GreenPlumParser::RESOURCE - 343))
      | (1ULL << (GreenPlumParser::ROLE - 343))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 343))
      | (1ULL << (GreenPlumParser::SYSID - 343)))) != 0) || ((((_la - 422) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 422)) & ((1ULL << (GreenPlumParser::UNENCRYPTED - 422))
      | (1ULL << (GreenPlumParser::USER - 422))
      | (1ULL << (GreenPlumParser::VALID - 422)))) != 0)) {
      setState(1436);
      alter_role_elem();
      setState(1441);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_user_set_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_user_set_stmtContext::Alter_user_set_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_user_set_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_user_set_stmtContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Alter_user_set_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Set_reset_clauseContext* GreenPlumParser::Alter_user_set_stmtContext::set_reset_clause() {
  return getRuleContext<GreenPlumParser::Set_reset_clauseContext>(0);
}


size_t GreenPlumParser::Alter_user_set_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_user_set_stmt;
}

void GreenPlumParser::Alter_user_set_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_user_set_stmt(this);
}

void GreenPlumParser::Alter_user_set_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_user_set_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_user_set_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_user_set_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_user_set_stmtContext* GreenPlumParser::alter_user_set_stmt() {
  Alter_user_set_stmtContext *_localctx = _tracker.createInstance<Alter_user_set_stmtContext>(_ctx, getState());
  enterRule(_localctx, 56, GreenPlumParser::RuleAlter_user_set_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1442);
    match(GreenPlumParser::ALTER);
    setState(1443);
    match(GreenPlumParser::USER);
    setState(1444);
    role_id();
    setState(1445);
    set_reset_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_role_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_role_stmtContext::Drop_role_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_role_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_role_stmtContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Drop_role_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_role_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_role_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}


size_t GreenPlumParser::Drop_role_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_role_stmt;
}

void GreenPlumParser::Drop_role_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_role_stmt(this);
}

void GreenPlumParser::Drop_role_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_role_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_role_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_role_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_role_stmtContext* GreenPlumParser::drop_role_stmt() {
  Drop_role_stmtContext *_localctx = _tracker.createInstance<Drop_role_stmtContext>(_ctx, getState());
  enterRule(_localctx, 58, GreenPlumParser::RuleDrop_role_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1455);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1447);
      match(GreenPlumParser::DROP);
      setState(1448);
      match(GreenPlumParser::ROLE);
      setState(1449);
      name_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1450);
      match(GreenPlumParser::DROP);
      setState(1451);
      match(GreenPlumParser::ROLE);
      setState(1452);
      match(GreenPlumParser::IF_P);
      setState(1453);
      match(GreenPlumParser::EXISTS);
      setState(1454);
      name_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_user_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_user_stmtContext::Drop_user_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_user_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_user_stmtContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Drop_user_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_user_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_user_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}


size_t GreenPlumParser::Drop_user_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_user_stmt;
}

void GreenPlumParser::Drop_user_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_user_stmt(this);
}

void GreenPlumParser::Drop_user_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_user_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_user_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_user_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_user_stmtContext* GreenPlumParser::drop_user_stmt() {
  Drop_user_stmtContext *_localctx = _tracker.createInstance<Drop_user_stmtContext>(_ctx, getState());
  enterRule(_localctx, 60, GreenPlumParser::RuleDrop_user_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1465);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1457);
      match(GreenPlumParser::DROP);
      setState(1458);
      match(GreenPlumParser::USER);
      setState(1459);
      name_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1460);
      match(GreenPlumParser::DROP);
      setState(1461);
      match(GreenPlumParser::USER);
      setState(1462);
      match(GreenPlumParser::IF_P);
      setState(1463);
      match(GreenPlumParser::EXISTS);
      setState(1464);
      name_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_group_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_group_stmtContext::Create_group_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_group_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_group_stmtContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Create_group_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Create_group_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Role_elemContext *> GreenPlumParser::Create_group_stmtContext::role_elem() {
  return getRuleContexts<GreenPlumParser::Role_elemContext>();
}

GreenPlumParser::Role_elemContext* GreenPlumParser::Create_group_stmtContext::role_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Role_elemContext>(i);
}


size_t GreenPlumParser::Create_group_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_group_stmt;
}

void GreenPlumParser::Create_group_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_group_stmt(this);
}

void GreenPlumParser::Create_group_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_group_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_group_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_group_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_group_stmtContext* GreenPlumParser::create_group_stmt() {
  Create_group_stmtContext *_localctx = _tracker.createInstance<Create_group_stmtContext>(_ctx, getState());
  enterRule(_localctx, 62, GreenPlumParser::RuleCreate_group_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1467);
    match(GreenPlumParser::CREATE);
    setState(1468);
    match(GreenPlumParser::GROUP_P);
    setState(1469);
    role_id();
    setState(1471);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(1470);
      opt_with();
    }
    setState(1476);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::ADMIN

    || _la == GreenPlumParser::CONNECTION || ((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & ((1ULL << (GreenPlumParser::CREATEDB - 74))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 74))
      | (1ULL << (GreenPlumParser::CREATEROLE - 74))
      | (1ULL << (GreenPlumParser::CREATEUSER - 74))
      | (1ULL << (GreenPlumParser::DENY - 74))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 74)))) != 0) || ((((_la - 186) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 186)) & ((1ULL << (GreenPlumParser::INHERIT - 186))
      | (1ULL << (GreenPlumParser::IN_P - 186))
      | (1ULL << (GreenPlumParser::LOGIN_P - 186)))) != 0) || ((((_la - 253) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 253)) & ((1ULL << (GreenPlumParser::NOCREATEDB - 253))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 253))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 253))
      | (1ULL << (GreenPlumParser::NOINHERIT - 253))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 253))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 253))
      | (1ULL << (GreenPlumParser::PASSWORD - 253)))) != 0) || ((((_la - 343) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 343)) & ((1ULL << (GreenPlumParser::RESOURCE - 343))
      | (1ULL << (GreenPlumParser::ROLE - 343))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 343))
      | (1ULL << (GreenPlumParser::SYSID - 343)))) != 0) || ((((_la - 422) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 422)) & ((1ULL << (GreenPlumParser::UNENCRYPTED - 422))
      | (1ULL << (GreenPlumParser::USER - 422))
      | (1ULL << (GreenPlumParser::VALID - 422)))) != 0)) {
      setState(1473);
      role_elem();
      setState(1478);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_group_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_group_stmtContext::Alter_group_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_group_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_group_stmtContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Alter_group_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Add_dropContext* GreenPlumParser::Alter_group_stmtContext::add_drop() {
  return getRuleContext<GreenPlumParser::Add_dropContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_group_stmtContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Alter_group_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}


size_t GreenPlumParser::Alter_group_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_group_stmt;
}

void GreenPlumParser::Alter_group_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_group_stmt(this);
}

void GreenPlumParser::Alter_group_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_group_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_group_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_group_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_group_stmtContext* GreenPlumParser::alter_group_stmt() {
  Alter_group_stmtContext *_localctx = _tracker.createInstance<Alter_group_stmtContext>(_ctx, getState());
  enterRule(_localctx, 64, GreenPlumParser::RuleAlter_group_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1479);
    match(GreenPlumParser::ALTER);
    setState(1480);
    match(GreenPlumParser::GROUP_P);
    setState(1481);
    role_id();
    setState(1482);
    add_drop();
    setState(1483);
    match(GreenPlumParser::USER);
    setState(1484);
    name_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Add_dropContext ------------------------------------------------------------------

GreenPlumParser::Add_dropContext::Add_dropContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Add_dropContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

tree::TerminalNode* GreenPlumParser::Add_dropContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}


size_t GreenPlumParser::Add_dropContext::getRuleIndex() const {
  return GreenPlumParser::RuleAdd_drop;
}

void GreenPlumParser::Add_dropContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdd_drop(this);
}

void GreenPlumParser::Add_dropContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdd_drop(this);
}


antlrcpp::Any GreenPlumParser::Add_dropContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAdd_drop(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Add_dropContext* GreenPlumParser::add_drop() {
  Add_dropContext *_localctx = _tracker.createInstance<Add_dropContext>(_ctx, getState());
  enterRule(_localctx, 66, GreenPlumParser::RuleAdd_drop);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1486);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::ADD_P || _la == GreenPlumParser::DROP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_group_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_group_stmtContext::Drop_group_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_group_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_group_stmtContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Drop_group_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_group_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_group_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}


size_t GreenPlumParser::Drop_group_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_group_stmt;
}

void GreenPlumParser::Drop_group_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_group_stmt(this);
}

void GreenPlumParser::Drop_group_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_group_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_group_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_group_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_group_stmtContext* GreenPlumParser::drop_group_stmt() {
  Drop_group_stmtContext *_localctx = _tracker.createInstance<Drop_group_stmtContext>(_ctx, getState());
  enterRule(_localctx, 68, GreenPlumParser::RuleDrop_group_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1488);
    match(GreenPlumParser::DROP);
    setState(1489);
    match(GreenPlumParser::GROUP_P);
    setState(1492);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(1490);
      match(GreenPlumParser::IF_P);
      setState(1491);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(1494);
    name_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_schema_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_schema_stmtContext::Create_schema_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_schema_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_schema_stmtContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Create_schema_stmtContext::AUTHORIZATION() {
  return getToken(GreenPlumParser::AUTHORIZATION, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Create_schema_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Schema_nameContext* GreenPlumParser::Create_schema_stmtContext::schema_name() {
  return getRuleContext<GreenPlumParser::Schema_nameContext>(0);
}

std::vector<GreenPlumParser::Schema_stmtContext *> GreenPlumParser::Create_schema_stmtContext::schema_stmt() {
  return getRuleContexts<GreenPlumParser::Schema_stmtContext>();
}

GreenPlumParser::Schema_stmtContext* GreenPlumParser::Create_schema_stmtContext::schema_stmt(size_t i) {
  return getRuleContext<GreenPlumParser::Schema_stmtContext>(i);
}

GreenPlumParser::ColidContext* GreenPlumParser::Create_schema_stmtContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Create_schema_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_schema_stmt;
}

void GreenPlumParser::Create_schema_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_schema_stmt(this);
}

void GreenPlumParser::Create_schema_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_schema_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_schema_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_schema_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_schema_stmtContext* GreenPlumParser::create_schema_stmt() {
  Create_schema_stmtContext *_localctx = _tracker.createInstance<Create_schema_stmtContext>(_ctx, getState());
  enterRule(_localctx, 70, GreenPlumParser::RuleCreate_schema_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(1518);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1496);
      match(GreenPlumParser::CREATE);
      setState(1497);
      match(GreenPlumParser::SCHEMA);
      setState(1499);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
        setState(1498);
        schema_name();
      }
      setState(1501);
      match(GreenPlumParser::AUTHORIZATION);
      setState(1502);
      role_id();
      setState(1506);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
      while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1 + 1) {
          setState(1503);
          schema_stmt(); 
        }
        setState(1508);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1509);
      match(GreenPlumParser::CREATE);
      setState(1510);
      match(GreenPlumParser::SCHEMA);
      setState(1511);
      colid();
      setState(1515);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
      while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1 + 1) {
          setState(1512);
          schema_stmt(); 
        }
        setState(1517);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_nameContext ------------------------------------------------------------------

GreenPlumParser::Schema_nameContext::Schema_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Schema_nameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Schema_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleSchema_name;
}

void GreenPlumParser::Schema_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_name(this);
}

void GreenPlumParser::Schema_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_name(this);
}


antlrcpp::Any GreenPlumParser::Schema_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSchema_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Schema_nameContext* GreenPlumParser::schema_name() {
  Schema_nameContext *_localctx = _tracker.createInstance<Schema_nameContext>(_ctx, getState());
  enterRule(_localctx, 72, GreenPlumParser::RuleSchema_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1520);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_stmtContext ------------------------------------------------------------------

GreenPlumParser::Schema_stmtContext::Schema_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Create_stmtContext* GreenPlumParser::Schema_stmtContext::create_stmt() {
  return getRuleContext<GreenPlumParser::Create_stmtContext>(0);
}

GreenPlumParser::Index_stmtContext* GreenPlumParser::Schema_stmtContext::index_stmt() {
  return getRuleContext<GreenPlumParser::Index_stmtContext>(0);
}

GreenPlumParser::Create_seq_stmtContext* GreenPlumParser::Schema_stmtContext::create_seq_stmt() {
  return getRuleContext<GreenPlumParser::Create_seq_stmtContext>(0);
}

GreenPlumParser::Create_trig_stmtContext* GreenPlumParser::Schema_stmtContext::create_trig_stmt() {
  return getRuleContext<GreenPlumParser::Create_trig_stmtContext>(0);
}

GreenPlumParser::Grant_stmtContext* GreenPlumParser::Schema_stmtContext::grant_stmt() {
  return getRuleContext<GreenPlumParser::Grant_stmtContext>(0);
}

GreenPlumParser::View_stmtContext* GreenPlumParser::Schema_stmtContext::view_stmt() {
  return getRuleContext<GreenPlumParser::View_stmtContext>(0);
}


size_t GreenPlumParser::Schema_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleSchema_stmt;
}

void GreenPlumParser::Schema_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_stmt(this);
}

void GreenPlumParser::Schema_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_stmt(this);
}


antlrcpp::Any GreenPlumParser::Schema_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSchema_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Schema_stmtContext* GreenPlumParser::schema_stmt() {
  Schema_stmtContext *_localctx = _tracker.createInstance<Schema_stmtContext>(_ctx, getState());
  enterRule(_localctx, 74, GreenPlumParser::RuleSchema_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1528);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1522);
      create_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1523);
      index_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1524);
      create_seq_stmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1525);
      create_trig_stmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1526);
      grant_stmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1527);
      view_stmt();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_set_stmtContext ------------------------------------------------------------------

GreenPlumParser::Variable_set_stmtContext::Variable_set_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Variable_set_stmtContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

GreenPlumParser::Set_restContext* GreenPlumParser::Variable_set_stmtContext::set_rest() {
  return getRuleContext<GreenPlumParser::Set_restContext>(0);
}

tree::TerminalNode* GreenPlumParser::Variable_set_stmtContext::LOCAL() {
  return getToken(GreenPlumParser::LOCAL, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_set_stmtContext::SESSION() {
  return getToken(GreenPlumParser::SESSION, 0);
}


size_t GreenPlumParser::Variable_set_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleVariable_set_stmt;
}

void GreenPlumParser::Variable_set_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_set_stmt(this);
}

void GreenPlumParser::Variable_set_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_set_stmt(this);
}


antlrcpp::Any GreenPlumParser::Variable_set_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitVariable_set_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Variable_set_stmtContext* GreenPlumParser::variable_set_stmt() {
  Variable_set_stmtContext *_localctx = _tracker.createInstance<Variable_set_stmtContext>(_ctx, getState());
  enterRule(_localctx, 76, GreenPlumParser::RuleVariable_set_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1530);
    match(GreenPlumParser::SET);
    setState(1532);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(1531);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::LOCAL || _la == GreenPlumParser::SESSION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(1534);
    set_rest();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_restContext ------------------------------------------------------------------

GreenPlumParser::Set_restContext::Set_restContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Var_nameContext* GreenPlumParser::Set_restContext::var_name() {
  return getRuleContext<GreenPlumParser::Var_nameContext>(0);
}

GreenPlumParser::Var_listContext* GreenPlumParser::Set_restContext::var_list() {
  return getRuleContext<GreenPlumParser::Var_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::CURRENT_P() {
  return getToken(GreenPlumParser::CURRENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::ZONE() {
  return getToken(GreenPlumParser::ZONE, 0);
}

GreenPlumParser::Zone_valueContext* GreenPlumParser::Set_restContext::zone_value() {
  return getRuleContext<GreenPlumParser::Zone_valueContext>(0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::TRANSACTION() {
  return getToken(GreenPlumParser::TRANSACTION, 0);
}

GreenPlumParser::Transaction_mode_listContext* GreenPlumParser::Set_restContext::transaction_mode_list() {
  return getRuleContext<GreenPlumParser::Transaction_mode_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::SESSION() {
  return getToken(GreenPlumParser::SESSION, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::CHARACTERISTICS() {
  return getToken(GreenPlumParser::CHARACTERISTICS, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::NAMES() {
  return getToken(GreenPlumParser::NAMES, 0);
}

GreenPlumParser::Opt_encodingContext* GreenPlumParser::Set_restContext::opt_encoding() {
  return getRuleContext<GreenPlumParser::Opt_encodingContext>(0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

GreenPlumParser::Colid_or_sconstContext* GreenPlumParser::Set_restContext::colid_or_sconst() {
  return getRuleContext<GreenPlumParser::Colid_or_sconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::AUTHORIZATION() {
  return getToken(GreenPlumParser::AUTHORIZATION, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::XML_P() {
  return getToken(GreenPlumParser::XML_P, 0);
}

tree::TerminalNode* GreenPlumParser::Set_restContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}

GreenPlumParser::Document_or_contentContext* GreenPlumParser::Set_restContext::document_or_content() {
  return getRuleContext<GreenPlumParser::Document_or_contentContext>(0);
}


size_t GreenPlumParser::Set_restContext::getRuleIndex() const {
  return GreenPlumParser::RuleSet_rest;
}

void GreenPlumParser::Set_restContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_rest(this);
}

void GreenPlumParser::Set_restContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_rest(this);
}


antlrcpp::Any GreenPlumParser::Set_restContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSet_rest(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Set_restContext* GreenPlumParser::set_rest() {
  Set_restContext *_localctx = _tracker.createInstance<Set_restContext>(_ctx, getState());
  enterRule(_localctx, 78, GreenPlumParser::RuleSet_rest);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1575);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1536);
      dynamic_cast<Set_restContext *>(_localctx)->var_nameContext = var_name(0);
      setState(1537);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::TO || _la == GreenPlumParser::EQUALS_OP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1538);
      dynamic_cast<Set_restContext *>(_localctx)->var_listContext = var_list();
      if (strcasecmp("search_path", (dynamic_cast<Set_restContext *>(_localctx)->var_nameContext != nullptr ? _input->getText(dynamic_cast<Set_restContext *>(_localctx)->var_nameContext->start, dynamic_cast<Set_restContext *>(_localctx)->var_nameContext->stop) : nullptr).c_str()) == 0) dynamic_cast<Set_restContext *>(_localctx)->current_schema =  (dynamic_cast<Set_restContext *>(_localctx)->var_listContext != nullptr ? _input->getText(dynamic_cast<Set_restContext *>(_localctx)->var_listContext->start, dynamic_cast<Set_restContext *>(_localctx)->var_listContext->stop) : nullptr);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1541);
      dynamic_cast<Set_restContext *>(_localctx)->var_nameContext = var_name(0);
      setState(1542);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::TO || _la == GreenPlumParser::EQUALS_OP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1543);
      match(GreenPlumParser::DEFAULT);
      if (strcasecmp("search_path", (dynamic_cast<Set_restContext *>(_localctx)->var_nameContext != nullptr ? _input->getText(dynamic_cast<Set_restContext *>(_localctx)->var_nameContext->start, dynamic_cast<Set_restContext *>(_localctx)->var_nameContext->stop) : nullptr).c_str()) == 0) dynamic_cast<Set_restContext *>(_localctx)->current_schema =  "\"$user\",public";
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1546);
      var_name(0);
      setState(1547);
      match(GreenPlumParser::FROM);
      setState(1548);
      match(GreenPlumParser::CURRENT_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1550);
      match(GreenPlumParser::TIME);
      setState(1551);
      match(GreenPlumParser::ZONE);
      setState(1552);
      zone_value();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1553);
      match(GreenPlumParser::TRANSACTION);
      setState(1554);
      transaction_mode_list();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1555);
      match(GreenPlumParser::SESSION);
      setState(1556);
      match(GreenPlumParser::CHARACTERISTICS);
      setState(1557);
      match(GreenPlumParser::AS);
      setState(1558);
      match(GreenPlumParser::TRANSACTION);
      setState(1559);
      transaction_mode_list();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1560);
      match(GreenPlumParser::NAMES);
      setState(1562);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::DEFAULT || ((((_la - 501) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 501)) & ((1ULL << (GreenPlumParser::CHAR_STRING - 501))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 501))
        | (1ULL << (GreenPlumParser::SCONST - 501)))) != 0)) {
        setState(1561);
        opt_encoding();
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1564);
      match(GreenPlumParser::ROLE);
      setState(1565);
      colid_or_sconst();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1566);
      match(GreenPlumParser::SESSION);
      setState(1567);
      match(GreenPlumParser::AUTHORIZATION);
      setState(1570);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GreenPlumParser::ABORT_P:
        case GreenPlumParser::ABSOLUTE_P:
        case GreenPlumParser::ACCESS:
        case GreenPlumParser::ACTION:
        case GreenPlumParser::ACTIVE:
        case GreenPlumParser::ADD_P:
        case GreenPlumParser::ADMIN:
        case GreenPlumParser::AFTER:
        case GreenPlumParser::AGGREGATE:
        case GreenPlumParser::ALSO:
        case GreenPlumParser::ALTER:
        case GreenPlumParser::ALWAYS:
        case GreenPlumParser::ASSERTION:
        case GreenPlumParser::ASSIGNMENT:
        case GreenPlumParser::AT:
        case GreenPlumParser::BACKWARD:
        case GreenPlumParser::BEFORE:
        case GreenPlumParser::BEGIN_P:
        case GreenPlumParser::BY:
        case GreenPlumParser::CACHE:
        case GreenPlumParser::CALLED:
        case GreenPlumParser::CASCADE:
        case GreenPlumParser::CASCADED:
        case GreenPlumParser::CHAIN:
        case GreenPlumParser::CHARACTERISTICS:
        case GreenPlumParser::CHECKPOINT:
        case GreenPlumParser::CLASS:
        case GreenPlumParser::CLOSE:
        case GreenPlumParser::CLUSTER:
        case GreenPlumParser::COMMENT:
        case GreenPlumParser::COMMIT:
        case GreenPlumParser::COMMITTED:
        case GreenPlumParser::CONCURRENCY:
        case GreenPlumParser::CONCURRENTLY:
        case GreenPlumParser::CONFIGURATION:
        case GreenPlumParser::CONNECTION:
        case GreenPlumParser::CONSTRAINTS:
        case GreenPlumParser::CONTAINS:
        case GreenPlumParser::CONTENT_P:
        case GreenPlumParser::CONTINUE_P:
        case GreenPlumParser::CONVERSION_P:
        case GreenPlumParser::COPY:
        case GreenPlumParser::COST:
        case GreenPlumParser::CPU_RATE_LIMIT:
        case GreenPlumParser::CPUSET:
        case GreenPlumParser::CREATEDB:
        case GreenPlumParser::CREATEEXTTABLE:
        case GreenPlumParser::CREATEROLE:
        case GreenPlumParser::CREATEUSER:
        case GreenPlumParser::CSV:
        case GreenPlumParser::CURRENT_P:
        case GreenPlumParser::CURSOR:
        case GreenPlumParser::CYCLE:
        case GreenPlumParser::DATABASE:
        case GreenPlumParser::DATA_P:
        case GreenPlumParser::DAY_P:
        case GreenPlumParser::DEALLOCATE:
        case GreenPlumParser::DECLARE:
        case GreenPlumParser::DEFAULTS:
        case GreenPlumParser::DEFERRED:
        case GreenPlumParser::DEFINER:
        case GreenPlumParser::DELETE_P:
        case GreenPlumParser::DELIMITER:
        case GreenPlumParser::DELIMITERS:
        case GreenPlumParser::DENY:
        case GreenPlumParser::DICTIONARY:
        case GreenPlumParser::DISABLE_P:
        case GreenPlumParser::DISCARD:
        case GreenPlumParser::DOCUMENT_P:
        case GreenPlumParser::DOMAIN_P:
        case GreenPlumParser::DOUBLE_P:
        case GreenPlumParser::DROP:
        case GreenPlumParser::DXL:
        case GreenPlumParser::EACH:
        case GreenPlumParser::ENABLE_P:
        case GreenPlumParser::ENCODING:
        case GreenPlumParser::ENCRYPTED:
        case GreenPlumParser::ENUM_P:
        case GreenPlumParser::ERRORS:
        case GreenPlumParser::ESCAPE:
        case GreenPlumParser::EVERY:
        case GreenPlumParser::EXCHANGE:
        case GreenPlumParser::EXCLUDING:
        case GreenPlumParser::EXCLUSIVE:
        case GreenPlumParser::EXECUTE:
        case GreenPlumParser::EXPLAIN:
        case GreenPlumParser::EXTENSION:
        case GreenPlumParser::EXTERNAL:
        case GreenPlumParser::FAMILY:
        case GreenPlumParser::FIELDS:
        case GreenPlumParser::FILESPACE:
        case GreenPlumParser::FILL:
        case GreenPlumParser::FIRST_P:
        case GreenPlumParser::FORCE:
        case GreenPlumParser::FORMAT:
        case GreenPlumParser::FORWARD:
        case GreenPlumParser::FUNCTION:
        case GreenPlumParser::GLOBAL:
        case GreenPlumParser::GRANTED:
        case GreenPlumParser::HANDLER:
        case GreenPlumParser::HASH:
        case GreenPlumParser::HEADER_P:
        case GreenPlumParser::HOLD:
        case GreenPlumParser::HOST:
        case GreenPlumParser::HOUR_P:
        case GreenPlumParser::IDENTITY_P:
        case GreenPlumParser::IF_P:
        case GreenPlumParser::IGNORE_P:
        case GreenPlumParser::IMMEDIATE:
        case GreenPlumParser::IMMUTABLE:
        case GreenPlumParser::IMPLICIT_P:
        case GreenPlumParser::INCLUDING:
        case GreenPlumParser::INCLUSIVE:
        case GreenPlumParser::INCREMENT:
        case GreenPlumParser::INDEX:
        case GreenPlumParser::INDEXES:
        case GreenPlumParser::INHERIT:
        case GreenPlumParser::INHERITS:
        case GreenPlumParser::INLINE_P:
        case GreenPlumParser::INPUT_P:
        case GreenPlumParser::INSENSITIVE:
        case GreenPlumParser::INSERT:
        case GreenPlumParser::INSTEAD:
        case GreenPlumParser::INVOKER:
        case GreenPlumParser::ISOLATION:
        case GreenPlumParser::KEY:
        case GreenPlumParser::LANGUAGE:
        case GreenPlumParser::LARGE_P:
        case GreenPlumParser::LAST_P:
        case GreenPlumParser::LEVEL:
        case GreenPlumParser::LIST:
        case GreenPlumParser::LISTEN:
        case GreenPlumParser::LOAD:
        case GreenPlumParser::LOCAL:
        case GreenPlumParser::LOCATION:
        case GreenPlumParser::LOCK_P:
        case GreenPlumParser::LOGIN_P:
        case GreenPlumParser::MAPPING:
        case GreenPlumParser::MASTER:
        case GreenPlumParser::MATCH:
        case GreenPlumParser::MAXVALUE:
        case GreenPlumParser::MEMORY_LIMIT:
        case GreenPlumParser::MEMORY_SHARED_QUOTA:
        case GreenPlumParser::MEMORY_SPILL_RATIO:
        case GreenPlumParser::MERGE:
        case GreenPlumParser::MINUTE_P:
        case GreenPlumParser::MINVALUE:
        case GreenPlumParser::MISSING:
        case GreenPlumParser::MODE:
        case GreenPlumParser::MODIFIES:
        case GreenPlumParser::MODIFY:
        case GreenPlumParser::MONTH_P:
        case GreenPlumParser::MOVE:
        case GreenPlumParser::NAME_P:
        case GreenPlumParser::NAMES:
        case GreenPlumParser::NEXT:
        case GreenPlumParser::NO:
        case GreenPlumParser::NOCREATEDB:
        case GreenPlumParser::NOCREATEEXTTABLE:
        case GreenPlumParser::NOCREATEROLE:
        case GreenPlumParser::NOCREATEUSER:
        case GreenPlumParser::NOINHERIT:
        case GreenPlumParser::NOLOGIN_P:
        case GreenPlumParser::NOOVERCOMMIT:
        case GreenPlumParser::NOSUPERUSER:
        case GreenPlumParser::NOTHING:
        case GreenPlumParser::NOTIFY:
        case GreenPlumParser::NOWAIT:
        case GreenPlumParser::NULLS_P:
        case GreenPlumParser::OBJECT_P:
        case GreenPlumParser::OF:
        case GreenPlumParser::OIDS:
        case GreenPlumParser::OPERATOR:
        case GreenPlumParser::OPTION:
        case GreenPlumParser::OPTIONS:
        case GreenPlumParser::ORDERED:
        case GreenPlumParser::OTHERS:
        case GreenPlumParser::OVER:
        case GreenPlumParser::OVERCOMMIT:
        case GreenPlumParser::OWNED:
        case GreenPlumParser::OWNER:
        case GreenPlumParser::PARSER:
        case GreenPlumParser::PARTIAL:
        case GreenPlumParser::PARTITIONS:
        case GreenPlumParser::PASSING:
        case GreenPlumParser::PASSWORD:
        case GreenPlumParser::PERCENT:
        case GreenPlumParser::PLANS:
        case GreenPlumParser::PREPARE:
        case GreenPlumParser::PREPARED:
        case GreenPlumParser::PRESERVE:
        case GreenPlumParser::PRIOR:
        case GreenPlumParser::PRIVILEGES:
        case GreenPlumParser::PROCEDURAL:
        case GreenPlumParser::PROCEDURE:
        case GreenPlumParser::PROGRAM:
        case GreenPlumParser::PROTOCOL:
        case GreenPlumParser::PUBLIC:
        case GreenPlumParser::QUEUE:
        case GreenPlumParser::QUOTE:
        case GreenPlumParser::RANDOMLY:
        case GreenPlumParser::READ:
        case GreenPlumParser::READABLE:
        case GreenPlumParser::READS:
        case GreenPlumParser::REASSIGN:
        case GreenPlumParser::RECHECK:
        case GreenPlumParser::RECURSIVE:
        case GreenPlumParser::REF:
        case GreenPlumParser::REINDEX:
        case GreenPlumParser::REJECT_P:
        case GreenPlumParser::RELATIVE_P:
        case GreenPlumParser::RELEASE:
        case GreenPlumParser::RENAME:
        case GreenPlumParser::REPEATABLE:
        case GreenPlumParser::REPLACE:
        case GreenPlumParser::REPLICA:
        case GreenPlumParser::RESET:
        case GreenPlumParser::RESOURCE:
        case GreenPlumParser::RESTART:
        case GreenPlumParser::RESTRICT:
        case GreenPlumParser::RETURNS:
        case GreenPlumParser::REVOKE:
        case GreenPlumParser::ROLE:
        case GreenPlumParser::ROLLBACK:
        case GreenPlumParser::ROOTPARTITION:
        case GreenPlumParser::RULE:
        case GreenPlumParser::SAVEPOINT:
        case GreenPlumParser::SCHEMA:
        case GreenPlumParser::SCROLL:
        case GreenPlumParser::SEARCH:
        case GreenPlumParser::SECOND_P:
        case GreenPlumParser::SECURITY:
        case GreenPlumParser::SEGMENT:
        case GreenPlumParser::SEQUENCE:
        case GreenPlumParser::SERIALIZABLE:
        case GreenPlumParser::SESSION:
        case GreenPlumParser::SET:
        case GreenPlumParser::SHARE:
        case GreenPlumParser::SHOW:
        case GreenPlumParser::SIMPLE:
        case GreenPlumParser::SPLIT:
        case GreenPlumParser::SQL:
        case GreenPlumParser::STABLE:
        case GreenPlumParser::STANDALONE_P:
        case GreenPlumParser::START:
        case GreenPlumParser::STATEMENT:
        case GreenPlumParser::STATISTICS:
        case GreenPlumParser::STDIN:
        case GreenPlumParser::STDOUT:
        case GreenPlumParser::STORAGE:
        case GreenPlumParser::STRICT_P:
        case GreenPlumParser::STRIP_P:
        case GreenPlumParser::SUBPARTITION:
        case GreenPlumParser::SUBPARTITIONS:
        case GreenPlumParser::SUPERUSER_P:
        case GreenPlumParser::SYSID:
        case GreenPlumParser::SYSTEM_P:
        case GreenPlumParser::TABLESPACE:
        case GreenPlumParser::TEMP:
        case GreenPlumParser::TEMPLATE:
        case GreenPlumParser::TEMPORARY:
        case GreenPlumParser::TEXT_P:
        case GreenPlumParser::THRESHOLD:
        case GreenPlumParser::TIES:
        case GreenPlumParser::TRANSACTION:
        case GreenPlumParser::TRIGGER:
        case GreenPlumParser::TRUNCATE:
        case GreenPlumParser::TRUSTED:
        case GreenPlumParser::TYPE_P:
        case GreenPlumParser::UNCOMMITTED:
        case GreenPlumParser::UNENCRYPTED:
        case GreenPlumParser::UNKNOWN:
        case GreenPlumParser::UNLISTEN:
        case GreenPlumParser::UNTIL:
        case GreenPlumParser::UPDATE:
        case GreenPlumParser::VACUUM:
        case GreenPlumParser::VALID:
        case GreenPlumParser::VALIDATION:
        case GreenPlumParser::VALIDATOR:
        case GreenPlumParser::VALUE_P:
        case GreenPlumParser::VARYING:
        case GreenPlumParser::VERSION_P:
        case GreenPlumParser::VIEW:
        case GreenPlumParser::VOLATILE:
        case GreenPlumParser::WEB:
        case GreenPlumParser::WHITESPACE_P:
        case GreenPlumParser::WITHIN:
        case GreenPlumParser::WITHOUT:
        case GreenPlumParser::WORK:
        case GreenPlumParser::WRITABLE:
        case GreenPlumParser::WRITE:
        case GreenPlumParser::XML_P:
        case GreenPlumParser::YEAR_P:
        case GreenPlumParser::YES_P:
        case GreenPlumParser::ZONE:
        case GreenPlumParser::COLON:
        case GreenPlumParser::CHAR_STRING:
        case GreenPlumParser::REGULAR_ID:
        case GreenPlumParser::DELIMITED_STR:
        case GreenPlumParser::SCONST: {
          setState(1568);
          colid_or_sconst();
          break;
        }

        case GreenPlumParser::DEFAULT: {
          setState(1569);
          match(GreenPlumParser::DEFAULT);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1572);
      match(GreenPlumParser::XML_P);
      setState(1573);
      match(GreenPlumParser::OPTION);
      setState(1574);
      document_or_content();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_nameContext ------------------------------------------------------------------

GreenPlumParser::Var_nameContext::Var_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Var_nameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::Var_nameContext* GreenPlumParser::Var_nameContext::var_name() {
  return getRuleContext<GreenPlumParser::Var_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Var_nameContext::PERIOD() {
  return getToken(GreenPlumParser::PERIOD, 0);
}


size_t GreenPlumParser::Var_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleVar_name;
}

void GreenPlumParser::Var_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_name(this);
}

void GreenPlumParser::Var_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_name(this);
}


antlrcpp::Any GreenPlumParser::Var_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitVar_name(this);
  else
    return visitor->visitChildren(this);
}


GreenPlumParser::Var_nameContext* GreenPlumParser::var_name() {
   return var_name(0);
}

GreenPlumParser::Var_nameContext* GreenPlumParser::var_name(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::Var_nameContext *_localctx = _tracker.createInstance<Var_nameContext>(_ctx, parentState);
  GreenPlumParser::Var_nameContext *previousContext = _localctx;
  size_t startState = 80;
  enterRecursionRule(_localctx, 80, GreenPlumParser::RuleVar_name, precedence);

    

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1578);
    colid();
    _ctx->stop = _input->LT(-1);
    setState(1585);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Var_nameContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleVar_name);
        setState(1580);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(1581);
        match(GreenPlumParser::PERIOD);
        setState(1582);
        colid(); 
      }
      setState(1587);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Var_listContext ------------------------------------------------------------------

GreenPlumParser::Var_listContext::Var_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Var_valueContext *> GreenPlumParser::Var_listContext::var_value() {
  return getRuleContexts<GreenPlumParser::Var_valueContext>();
}

GreenPlumParser::Var_valueContext* GreenPlumParser::Var_listContext::var_value(size_t i) {
  return getRuleContext<GreenPlumParser::Var_valueContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Var_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Var_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Var_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleVar_list;
}

void GreenPlumParser::Var_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_list(this);
}

void GreenPlumParser::Var_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_list(this);
}


antlrcpp::Any GreenPlumParser::Var_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitVar_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Var_listContext* GreenPlumParser::var_list() {
  Var_listContext *_localctx = _tracker.createInstance<Var_listContext>(_ctx, getState());
  enterRule(_localctx, 82, GreenPlumParser::RuleVar_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1588);
    var_value();
    setState(1593);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1589);
        match(GreenPlumParser::COMMA);
        setState(1590);
        var_value(); 
      }
      setState(1595);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_valueContext ------------------------------------------------------------------

GreenPlumParser::Var_valueContext::Var_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Opt_booleanContext* GreenPlumParser::Var_valueContext::opt_boolean() {
  return getRuleContext<GreenPlumParser::Opt_booleanContext>(0);
}

GreenPlumParser::Colid_or_sconstContext* GreenPlumParser::Var_valueContext::colid_or_sconst() {
  return getRuleContext<GreenPlumParser::Colid_or_sconstContext>(0);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::Var_valueContext::numberic_only() {
  return getRuleContext<GreenPlumParser::Numberic_onlyContext>(0);
}


size_t GreenPlumParser::Var_valueContext::getRuleIndex() const {
  return GreenPlumParser::RuleVar_value;
}

void GreenPlumParser::Var_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_value(this);
}

void GreenPlumParser::Var_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_value(this);
}


antlrcpp::Any GreenPlumParser::Var_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitVar_value(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Var_valueContext* GreenPlumParser::var_value() {
  Var_valueContext *_localctx = _tracker.createInstance<Var_valueContext>(_ctx, getState());
  enterRule(_localctx, 84, GreenPlumParser::RuleVar_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1599);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::OFF:
      case GreenPlumParser::ON:
      case GreenPlumParser::TRUE_P: {
        enterOuterAlt(_localctx, 1);
        setState(1596);
        opt_boolean();
        break;
      }

      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 2);
        setState(1597);
        colid_or_sconst();
        break;
      }

      case GreenPlumParser::PLUS_SIGN:
      case GreenPlumParser::MINUS_SIGN:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST: {
        enterOuterAlt(_localctx, 3);
        setState(1598);
        numberic_only();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Iso_levelContext ------------------------------------------------------------------

GreenPlumParser::Iso_levelContext::Iso_levelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Iso_levelContext::READ() {
  return getToken(GreenPlumParser::READ, 0);
}

tree::TerminalNode* GreenPlumParser::Iso_levelContext::COMMITED() {
  return getToken(GreenPlumParser::COMMITED, 0);
}

tree::TerminalNode* GreenPlumParser::Iso_levelContext::UNCOMMITTED() {
  return getToken(GreenPlumParser::UNCOMMITTED, 0);
}

tree::TerminalNode* GreenPlumParser::Iso_levelContext::REPEATABLE() {
  return getToken(GreenPlumParser::REPEATABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Iso_levelContext::SERIALIZABLE() {
  return getToken(GreenPlumParser::SERIALIZABLE, 0);
}


size_t GreenPlumParser::Iso_levelContext::getRuleIndex() const {
  return GreenPlumParser::RuleIso_level;
}

void GreenPlumParser::Iso_levelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIso_level(this);
}

void GreenPlumParser::Iso_levelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIso_level(this);
}


antlrcpp::Any GreenPlumParser::Iso_levelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIso_level(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Iso_levelContext* GreenPlumParser::iso_level() {
  Iso_levelContext *_localctx = _tracker.createInstance<Iso_levelContext>(_ctx, getState());
  enterRule(_localctx, 86, GreenPlumParser::RuleIso_level);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1606);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::READ: {
        enterOuterAlt(_localctx, 1);
        setState(1601);
        match(GreenPlumParser::READ);
        setState(1602);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::COMMITED || _la == GreenPlumParser::UNCOMMITTED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case GreenPlumParser::REPEATABLE: {
        enterOuterAlt(_localctx, 2);
        setState(1603);
        match(GreenPlumParser::REPEATABLE);
        setState(1604);
        match(GreenPlumParser::READ);
        break;
      }

      case GreenPlumParser::SERIALIZABLE: {
        enterOuterAlt(_localctx, 3);
        setState(1605);
        match(GreenPlumParser::SERIALIZABLE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_booleanContext ------------------------------------------------------------------

GreenPlumParser::Opt_booleanContext::Opt_booleanContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_booleanContext::TRUE_P() {
  return getToken(GreenPlumParser::TRUE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_booleanContext::FALSE_P() {
  return getToken(GreenPlumParser::FALSE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_booleanContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_booleanContext::OFF() {
  return getToken(GreenPlumParser::OFF, 0);
}


size_t GreenPlumParser::Opt_booleanContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_boolean;
}

void GreenPlumParser::Opt_booleanContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_boolean(this);
}

void GreenPlumParser::Opt_booleanContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_boolean(this);
}


antlrcpp::Any GreenPlumParser::Opt_booleanContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_boolean(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_booleanContext* GreenPlumParser::opt_boolean() {
  Opt_booleanContext *_localctx = _tracker.createInstance<Opt_booleanContext>(_ctx, getState());
  enterRule(_localctx, 88, GreenPlumParser::RuleOpt_boolean);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1608);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::FALSE_P || _la == GreenPlumParser::OFF

    || _la == GreenPlumParser::ON || _la == GreenPlumParser::TRUE_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Zone_valueContext ------------------------------------------------------------------

GreenPlumParser::Zone_valueContext::Zone_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::SconstContext* GreenPlumParser::Zone_valueContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

GreenPlumParser::IdentifierContext* GreenPlumParser::Zone_valueContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}

GreenPlumParser::Const_intervalContext* GreenPlumParser::Zone_valueContext::const_interval() {
  return getRuleContext<GreenPlumParser::Const_intervalContext>(0);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::Zone_valueContext::paren_iconst() {
  return getRuleContext<GreenPlumParser::Paren_iconstContext>(0);
}

GreenPlumParser::Opt_intervalContext* GreenPlumParser::Zone_valueContext::opt_interval() {
  return getRuleContext<GreenPlumParser::Opt_intervalContext>(0);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::Zone_valueContext::numberic_only() {
  return getRuleContext<GreenPlumParser::Numberic_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Zone_valueContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Zone_valueContext::LOCAL() {
  return getToken(GreenPlumParser::LOCAL, 0);
}


size_t GreenPlumParser::Zone_valueContext::getRuleIndex() const {
  return GreenPlumParser::RuleZone_value;
}

void GreenPlumParser::Zone_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterZone_value(this);
}

void GreenPlumParser::Zone_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitZone_value(this);
}


antlrcpp::Any GreenPlumParser::Zone_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitZone_value(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Zone_valueContext* GreenPlumParser::zone_value() {
  Zone_valueContext *_localctx = _tracker.createInstance<Zone_valueContext>(_ctx, getState());
  enterRule(_localctx, 90, GreenPlumParser::RuleZone_value);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1623);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1610);
      sconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1611);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1612);
      const_interval();
      setState(1614);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(1613);
        paren_iconst();
      }
      setState(1616);
      sconst();
      setState(1618);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::DAY_P || _la == GreenPlumParser::HOUR_P

      || _la == GreenPlumParser::MINUTE_P || _la == GreenPlumParser::MONTH_P || _la == GreenPlumParser::SECOND_P || _la == GreenPlumParser::YEAR_P) {
        setState(1617);
        opt_interval();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1620);
      numberic_only();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1621);
      match(GreenPlumParser::DEFAULT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1622);
      match(GreenPlumParser::LOCAL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Paren_iconstContext ------------------------------------------------------------------

GreenPlumParser::Paren_iconstContext::Paren_iconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Paren_iconstContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Paren_iconstContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Paren_iconstContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Paren_iconstContext::getRuleIndex() const {
  return GreenPlumParser::RuleParen_iconst;
}

void GreenPlumParser::Paren_iconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParen_iconst(this);
}

void GreenPlumParser::Paren_iconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParen_iconst(this);
}


antlrcpp::Any GreenPlumParser::Paren_iconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParen_iconst(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::paren_iconst() {
  Paren_iconstContext *_localctx = _tracker.createInstance<Paren_iconstContext>(_ctx, getState());
  enterRule(_localctx, 92, GreenPlumParser::RuleParen_iconst);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1625);
    match(GreenPlumParser::LEFT_PAREN);
    setState(1626);
    iconst();
    setState(1627);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_encodingContext ------------------------------------------------------------------

GreenPlumParser::Opt_encodingContext::Opt_encodingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::SconstContext* GreenPlumParser::Opt_encodingContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_encodingContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Opt_encodingContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_encoding;
}

void GreenPlumParser::Opt_encodingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_encoding(this);
}

void GreenPlumParser::Opt_encodingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_encoding(this);
}


antlrcpp::Any GreenPlumParser::Opt_encodingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_encoding(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_encodingContext* GreenPlumParser::opt_encoding() {
  Opt_encodingContext *_localctx = _tracker.createInstance<Opt_encodingContext>(_ctx, getState());
  enterRule(_localctx, 94, GreenPlumParser::RuleOpt_encoding);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1631);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(1629);
        sconst();
        break;
      }

      case GreenPlumParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(1630);
        match(GreenPlumParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Colid_or_sconstContext ------------------------------------------------------------------

GreenPlumParser::Colid_or_sconstContext::Colid_or_sconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Colid_or_sconstContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Colid_or_sconstContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::Colid_or_sconstContext::getRuleIndex() const {
  return GreenPlumParser::RuleColid_or_sconst;
}

void GreenPlumParser::Colid_or_sconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColid_or_sconst(this);
}

void GreenPlumParser::Colid_or_sconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColid_or_sconst(this);
}


antlrcpp::Any GreenPlumParser::Colid_or_sconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitColid_or_sconst(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Colid_or_sconstContext* GreenPlumParser::colid_or_sconst() {
  Colid_or_sconstContext *_localctx = _tracker.createInstance<Colid_or_sconstContext>(_ctx, getState());
  enterRule(_localctx, 96, GreenPlumParser::RuleColid_or_sconst);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1635);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1633);
      colid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1634);
      sconst();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_reset_stmtContext ------------------------------------------------------------------

GreenPlumParser::Variable_reset_stmtContext::Variable_reset_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::RESET() {
  return getToken(GreenPlumParser::RESET, 0);
}

GreenPlumParser::Var_nameContext* GreenPlumParser::Variable_reset_stmtContext::var_name() {
  return getRuleContext<GreenPlumParser::Var_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::ZONE() {
  return getToken(GreenPlumParser::ZONE, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::TRANSACTION() {
  return getToken(GreenPlumParser::TRANSACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::ISOLATION() {
  return getToken(GreenPlumParser::ISOLATION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::LEVEL() {
  return getToken(GreenPlumParser::LEVEL, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::SESSION() {
  return getToken(GreenPlumParser::SESSION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::AUTHORIZATION() {
  return getToken(GreenPlumParser::AUTHORIZATION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_reset_stmtContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}


size_t GreenPlumParser::Variable_reset_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleVariable_reset_stmt;
}

void GreenPlumParser::Variable_reset_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_reset_stmt(this);
}

void GreenPlumParser::Variable_reset_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_reset_stmt(this);
}


antlrcpp::Any GreenPlumParser::Variable_reset_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitVariable_reset_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Variable_reset_stmtContext* GreenPlumParser::variable_reset_stmt() {
  Variable_reset_stmtContext *_localctx = _tracker.createInstance<Variable_reset_stmtContext>(_ctx, getState());
  enterRule(_localctx, 98, GreenPlumParser::RuleVariable_reset_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1651);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1637);
      match(GreenPlumParser::RESET);
      setState(1638);
      var_name(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1639);
      match(GreenPlumParser::RESET);
      setState(1640);
      match(GreenPlumParser::TIME);
      setState(1641);
      match(GreenPlumParser::ZONE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1642);
      match(GreenPlumParser::RESET);
      setState(1643);
      match(GreenPlumParser::TRANSACTION);
      setState(1644);
      match(GreenPlumParser::ISOLATION);
      setState(1645);
      match(GreenPlumParser::LEVEL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1646);
      match(GreenPlumParser::RESET);
      setState(1647);
      match(GreenPlumParser::SESSION);
      setState(1648);
      match(GreenPlumParser::AUTHORIZATION);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1649);
      match(GreenPlumParser::RESET);
      setState(1650);
      match(GreenPlumParser::ALL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_reset_clauseContext ------------------------------------------------------------------

GreenPlumParser::Set_reset_clauseContext::Set_reset_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Set_reset_clauseContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

GreenPlumParser::Set_restContext* GreenPlumParser::Set_reset_clauseContext::set_rest() {
  return getRuleContext<GreenPlumParser::Set_restContext>(0);
}

GreenPlumParser::Variable_reset_stmtContext* GreenPlumParser::Set_reset_clauseContext::variable_reset_stmt() {
  return getRuleContext<GreenPlumParser::Variable_reset_stmtContext>(0);
}


size_t GreenPlumParser::Set_reset_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleSet_reset_clause;
}

void GreenPlumParser::Set_reset_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_reset_clause(this);
}

void GreenPlumParser::Set_reset_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_reset_clause(this);
}


antlrcpp::Any GreenPlumParser::Set_reset_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSet_reset_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Set_reset_clauseContext* GreenPlumParser::set_reset_clause() {
  Set_reset_clauseContext *_localctx = _tracker.createInstance<Set_reset_clauseContext>(_ctx, getState());
  enterRule(_localctx, 100, GreenPlumParser::RuleSet_reset_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1656);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::SET: {
        enterOuterAlt(_localctx, 1);
        setState(1653);
        match(GreenPlumParser::SET);
        setState(1654);
        set_rest();
        break;
      }

      case GreenPlumParser::RESET: {
        enterOuterAlt(_localctx, 2);
        setState(1655);
        variable_reset_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_show_stmtContext ------------------------------------------------------------------

GreenPlumParser::Variable_show_stmtContext::Variable_show_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::SHOW() {
  return getToken(GreenPlumParser::SHOW, 0);
}

GreenPlumParser::Var_nameContext* GreenPlumParser::Variable_show_stmtContext::var_name() {
  return getRuleContext<GreenPlumParser::Var_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::ZONE() {
  return getToken(GreenPlumParser::ZONE, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::TRANSACTION() {
  return getToken(GreenPlumParser::TRANSACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::ISOLATION() {
  return getToken(GreenPlumParser::ISOLATION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::LEVEL() {
  return getToken(GreenPlumParser::LEVEL, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::SESSION() {
  return getToken(GreenPlumParser::SESSION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::AUTHORIZATION() {
  return getToken(GreenPlumParser::AUTHORIZATION, 0);
}

tree::TerminalNode* GreenPlumParser::Variable_show_stmtContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}


size_t GreenPlumParser::Variable_show_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleVariable_show_stmt;
}

void GreenPlumParser::Variable_show_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_show_stmt(this);
}

void GreenPlumParser::Variable_show_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_show_stmt(this);
}


antlrcpp::Any GreenPlumParser::Variable_show_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitVariable_show_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Variable_show_stmtContext* GreenPlumParser::variable_show_stmt() {
  Variable_show_stmtContext *_localctx = _tracker.createInstance<Variable_show_stmtContext>(_ctx, getState());
  enterRule(_localctx, 102, GreenPlumParser::RuleVariable_show_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1672);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1658);
      match(GreenPlumParser::SHOW);
      setState(1659);
      var_name(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1660);
      match(GreenPlumParser::SHOW);
      setState(1661);
      match(GreenPlumParser::TIME);
      setState(1662);
      match(GreenPlumParser::ZONE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1663);
      match(GreenPlumParser::SHOW);
      setState(1664);
      match(GreenPlumParser::TRANSACTION);
      setState(1665);
      match(GreenPlumParser::ISOLATION);
      setState(1666);
      match(GreenPlumParser::LEVEL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1667);
      match(GreenPlumParser::SHOW);
      setState(1668);
      match(GreenPlumParser::SESSION);
      setState(1669);
      match(GreenPlumParser::AUTHORIZATION);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1670);
      match(GreenPlumParser::SHOW);
      setState(1671);
      match(GreenPlumParser::ALL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraints_set_stmtContext ------------------------------------------------------------------

GreenPlumParser::Constraints_set_stmtContext::Constraints_set_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraints_set_stmtContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Constraints_set_stmtContext::CONSTRAINTS() {
  return getToken(GreenPlumParser::CONSTRAINTS, 0);
}

GreenPlumParser::Constraints_set_listContext* GreenPlumParser::Constraints_set_stmtContext::constraints_set_list() {
  return getRuleContext<GreenPlumParser::Constraints_set_listContext>(0);
}

GreenPlumParser::Constraints_set_modeContext* GreenPlumParser::Constraints_set_stmtContext::constraints_set_mode() {
  return getRuleContext<GreenPlumParser::Constraints_set_modeContext>(0);
}


size_t GreenPlumParser::Constraints_set_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraints_set_stmt;
}

void GreenPlumParser::Constraints_set_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraints_set_stmt(this);
}

void GreenPlumParser::Constraints_set_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraints_set_stmt(this);
}


antlrcpp::Any GreenPlumParser::Constraints_set_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraints_set_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraints_set_stmtContext* GreenPlumParser::constraints_set_stmt() {
  Constraints_set_stmtContext *_localctx = _tracker.createInstance<Constraints_set_stmtContext>(_ctx, getState());
  enterRule(_localctx, 104, GreenPlumParser::RuleConstraints_set_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1674);
    match(GreenPlumParser::SET);
    setState(1675);
    match(GreenPlumParser::CONSTRAINTS);
    setState(1676);
    constraints_set_list();
    setState(1677);
    constraints_set_mode();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraints_set_listContext ------------------------------------------------------------------

GreenPlumParser::Constraints_set_listContext::Constraints_set_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraints_set_listContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

GreenPlumParser::Qualified_name_listContext* GreenPlumParser::Constraints_set_listContext::qualified_name_list() {
  return getRuleContext<GreenPlumParser::Qualified_name_listContext>(0);
}


size_t GreenPlumParser::Constraints_set_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraints_set_list;
}

void GreenPlumParser::Constraints_set_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraints_set_list(this);
}

void GreenPlumParser::Constraints_set_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraints_set_list(this);
}


antlrcpp::Any GreenPlumParser::Constraints_set_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraints_set_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraints_set_listContext* GreenPlumParser::constraints_set_list() {
  Constraints_set_listContext *_localctx = _tracker.createInstance<Constraints_set_listContext>(_ctx, getState());
  enterRule(_localctx, 106, GreenPlumParser::RuleConstraints_set_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1681);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ALL: {
        enterOuterAlt(_localctx, 1);
        setState(1679);
        match(GreenPlumParser::ALL);
        break;
      }

      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 2);
        setState(1680);
        qualified_name_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraints_set_modeContext ------------------------------------------------------------------

GreenPlumParser::Constraints_set_modeContext::Constraints_set_modeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraints_set_modeContext::DEFERRED() {
  return getToken(GreenPlumParser::DEFERRED, 0);
}

tree::TerminalNode* GreenPlumParser::Constraints_set_modeContext::IMMEDIATE() {
  return getToken(GreenPlumParser::IMMEDIATE, 0);
}


size_t GreenPlumParser::Constraints_set_modeContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraints_set_mode;
}

void GreenPlumParser::Constraints_set_modeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraints_set_mode(this);
}

void GreenPlumParser::Constraints_set_modeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraints_set_mode(this);
}


antlrcpp::Any GreenPlumParser::Constraints_set_modeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraints_set_mode(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraints_set_modeContext* GreenPlumParser::constraints_set_mode() {
  Constraints_set_modeContext *_localctx = _tracker.createInstance<Constraints_set_modeContext>(_ctx, getState());
  enterRule(_localctx, 108, GreenPlumParser::RuleConstraints_set_mode);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1683);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::DEFERRED || _la == GreenPlumParser::IMMEDIATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Check_point_stmtContext ------------------------------------------------------------------

GreenPlumParser::Check_point_stmtContext::Check_point_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Check_point_stmtContext::CHECKPOINT() {
  return getToken(GreenPlumParser::CHECKPOINT, 0);
}


size_t GreenPlumParser::Check_point_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCheck_point_stmt;
}

void GreenPlumParser::Check_point_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheck_point_stmt(this);
}

void GreenPlumParser::Check_point_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheck_point_stmt(this);
}


antlrcpp::Any GreenPlumParser::Check_point_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCheck_point_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Check_point_stmtContext* GreenPlumParser::check_point_stmt() {
  Check_point_stmtContext *_localctx = _tracker.createInstance<Check_point_stmtContext>(_ctx, getState());
  enterRule(_localctx, 110, GreenPlumParser::RuleCheck_point_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1685);
    match(GreenPlumParser::CHECKPOINT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Discard_stmtContext ------------------------------------------------------------------

GreenPlumParser::Discard_stmtContext::Discard_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Discard_stmtContext::DISCARD() {
  return getToken(GreenPlumParser::DISCARD, 0);
}

tree::TerminalNode* GreenPlumParser::Discard_stmtContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

tree::TerminalNode* GreenPlumParser::Discard_stmtContext::TEMP() {
  return getToken(GreenPlumParser::TEMP, 0);
}

tree::TerminalNode* GreenPlumParser::Discard_stmtContext::TEMPORARY() {
  return getToken(GreenPlumParser::TEMPORARY, 0);
}

tree::TerminalNode* GreenPlumParser::Discard_stmtContext::PLANS() {
  return getToken(GreenPlumParser::PLANS, 0);
}


size_t GreenPlumParser::Discard_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDiscard_stmt;
}

void GreenPlumParser::Discard_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiscard_stmt(this);
}

void GreenPlumParser::Discard_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiscard_stmt(this);
}


antlrcpp::Any GreenPlumParser::Discard_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDiscard_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Discard_stmtContext* GreenPlumParser::discard_stmt() {
  Discard_stmtContext *_localctx = _tracker.createInstance<Discard_stmtContext>(_ctx, getState());
  enterRule(_localctx, 112, GreenPlumParser::RuleDiscard_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1687);
    match(GreenPlumParser::DISCARD);
    setState(1688);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::ALL || _la == GreenPlumParser::PLANS || _la == GreenPlumParser::TEMP

    || _la == GreenPlumParser::TEMPORARY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_table_stmtContext::Alter_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_table_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Relation_exprContext* GreenPlumParser::Alter_table_stmtContext::relation_expr() {
  return getRuleContext<GreenPlumParser::Relation_exprContext>(0);
}

GreenPlumParser::Alter_table_cmdsContext* GreenPlumParser::Alter_table_stmtContext::alter_table_cmds() {
  return getRuleContext<GreenPlumParser::Alter_table_cmdsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_stmtContext::EXTERNAL() {
  return getToken(GreenPlumParser::EXTERNAL, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_stmtContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

GreenPlumParser::Alter_rel_cmdsContext* GreenPlumParser::Alter_table_stmtContext::alter_rel_cmds() {
  return getRuleContext<GreenPlumParser::Alter_rel_cmdsContext>(0);
}


size_t GreenPlumParser::Alter_table_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_table_stmt;
}

void GreenPlumParser::Alter_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_stmt(this);
}

void GreenPlumParser::Alter_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_table_stmtContext* GreenPlumParser::alter_table_stmt() {
  Alter_table_stmtContext *_localctx = _tracker.createInstance<Alter_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 114, GreenPlumParser::RuleAlter_table_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1703);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1690);
      match(GreenPlumParser::ALTER);
      setState(1692);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::EXTERNAL) {
        setState(1691);
        match(GreenPlumParser::EXTERNAL);
      }
      setState(1694);
      match(GreenPlumParser::TABLE);
      setState(1695);
      relation_expr();
      setState(1696);
      alter_table_cmds();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1698);
      match(GreenPlumParser::ALTER);
      setState(1699);
      match(GreenPlumParser::INDEX);
      setState(1700);
      relation_expr();
      setState(1701);
      alter_rel_cmds();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_cmdsContext ------------------------------------------------------------------

GreenPlumParser::Alter_table_cmdsContext::Alter_table_cmdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Alter_table_cmdContext *> GreenPlumParser::Alter_table_cmdsContext::alter_table_cmd() {
  return getRuleContexts<GreenPlumParser::Alter_table_cmdContext>();
}

GreenPlumParser::Alter_table_cmdContext* GreenPlumParser::Alter_table_cmdsContext::alter_table_cmd(size_t i) {
  return getRuleContext<GreenPlumParser::Alter_table_cmdContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Alter_table_cmdsContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdsContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Alter_table_cmdsContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_table_cmds;
}

void GreenPlumParser::Alter_table_cmdsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_cmds(this);
}

void GreenPlumParser::Alter_table_cmdsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_cmds(this);
}


antlrcpp::Any GreenPlumParser::Alter_table_cmdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_cmds(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_table_cmdsContext* GreenPlumParser::alter_table_cmds() {
  Alter_table_cmdsContext *_localctx = _tracker.createInstance<Alter_table_cmdsContext>(_ctx, getState());
  enterRule(_localctx, 116, GreenPlumParser::RuleAlter_table_cmds);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1705);
    alter_table_cmd();
    setState(1710);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(1706);
      match(GreenPlumParser::COMMA);
      setState(1707);
      alter_table_cmd();
      setState(1712);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_cmdContext ------------------------------------------------------------------

GreenPlumParser::Alter_table_cmdContext::Alter_table_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

GreenPlumParser::Column_defContext* GreenPlumParser::Alter_table_cmdContext::column_def() {
  return getRuleContext<GreenPlumParser::Column_defContext>(0);
}

GreenPlumParser::Opt_columnContext* GreenPlumParser::Alter_table_cmdContext::opt_column() {
  return getRuleContext<GreenPlumParser::Opt_columnContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

std::vector<GreenPlumParser::ColidContext *> GreenPlumParser::Alter_table_cmdContext::colid() {
  return getRuleContexts<GreenPlumParser::ColidContext>();
}

GreenPlumParser::ColidContext* GreenPlumParser::Alter_table_cmdContext::colid(size_t i) {
  return getRuleContext<GreenPlumParser::ColidContext>(i);
}

GreenPlumParser::Alter_column_defaultContext* GreenPlumParser::Alter_table_cmdContext::alter_column_default() {
  return getRuleContext<GreenPlumParser::Alter_column_defaultContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::STATISTICS() {
  return getToken(GreenPlumParser::STATISTICS, 0);
}

GreenPlumParser::Integer_onlyContext* GreenPlumParser::Alter_table_cmdContext::integer_only() {
  return getRuleContext<GreenPlumParser::Integer_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::STORAGE() {
  return getToken(GreenPlumParser::STORAGE, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Alter_table_cmdContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Alter_table_cmdContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

GreenPlumParser::Alter_usingContext* GreenPlumParser::Alter_table_cmdContext::alter_using() {
  return getRuleContext<GreenPlumParser::Alter_usingContext>(0);
}

GreenPlumParser::Table_constraintContext* GreenPlumParser::Alter_table_cmdContext::table_constraint() {
  return getRuleContext<GreenPlumParser::Table_constraintContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::CONSTRAINT() {
  return getToken(GreenPlumParser::CONSTRAINT, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_table_cmdContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::WITHOUT() {
  return getToken(GreenPlumParser::WITHOUT, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::OIDS() {
  return getToken(GreenPlumParser::OIDS, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::CLUSTER() {
  return getToken(GreenPlumParser::CLUSTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::ENABLE_P() {
  return getToken(GreenPlumParser::ENABLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::ALWAYS() {
  return getToken(GreenPlumParser::ALWAYS, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::REPLICA() {
  return getToken(GreenPlumParser::REPLICA, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::DISABLE_P() {
  return getToken(GreenPlumParser::DISABLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::RULE() {
  return getToken(GreenPlumParser::RULE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::INHERIT() {
  return getToken(GreenPlumParser::INHERIT, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Alter_table_cmdContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_cmdContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

GreenPlumParser::Distributed_byContext* GreenPlumParser::Alter_table_cmdContext::distributed_by() {
  return getRuleContext<GreenPlumParser::Distributed_byContext>(0);
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::Alter_table_cmdContext::with_out_definition() {
  return getRuleContext<GreenPlumParser::With_out_definitionContext>(0);
}

GreenPlumParser::Alter_table_partition_cmdContext* GreenPlumParser::Alter_table_cmdContext::alter_table_partition_cmd() {
  return getRuleContext<GreenPlumParser::Alter_table_partition_cmdContext>(0);
}

GreenPlumParser::Alter_rel_cmdContext* GreenPlumParser::Alter_table_cmdContext::alter_rel_cmd() {
  return getRuleContext<GreenPlumParser::Alter_rel_cmdContext>(0);
}


size_t GreenPlumParser::Alter_table_cmdContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_table_cmd;
}

void GreenPlumParser::Alter_table_cmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_cmd(this);
}

void GreenPlumParser::Alter_table_cmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_cmd(this);
}


antlrcpp::Any GreenPlumParser::Alter_table_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_cmd(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_table_cmdContext* GreenPlumParser::alter_table_cmd() {
  Alter_table_cmdContext *_localctx = _tracker.createInstance<Alter_table_cmdContext>(_ctx, getState());
  enterRule(_localctx, 118, GreenPlumParser::RuleAlter_table_cmd);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1835);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1713);
      match(GreenPlumParser::ADD_P);
      setState(1715);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1714);
        opt_column();
      }
      setState(1717);
      column_def();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1718);
      match(GreenPlumParser::ALTER);
      setState(1720);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1719);
        opt_column();
      }
      setState(1722);
      colid();
      setState(1723);
      alter_column_default();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1725);
      match(GreenPlumParser::ALTER);
      setState(1727);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1726);
        opt_column();
      }
      setState(1729);
      colid();
      setState(1730);
      match(GreenPlumParser::DROP);
      setState(1731);
      match(GreenPlumParser::NOT);
      setState(1732);
      match(GreenPlumParser::NULL_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1734);
      match(GreenPlumParser::ALTER);
      setState(1736);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1735);
        opt_column();
      }
      setState(1738);
      colid();
      setState(1739);
      match(GreenPlumParser::SET);
      setState(1740);
      match(GreenPlumParser::NOT);
      setState(1741);
      match(GreenPlumParser::NULL_P);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1743);
      match(GreenPlumParser::ALTER);
      setState(1745);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1744);
        opt_column();
      }
      setState(1747);
      colid();
      setState(1748);
      match(GreenPlumParser::SET);
      setState(1749);
      match(GreenPlumParser::STATISTICS);
      setState(1750);
      integer_only();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1752);
      match(GreenPlumParser::ALTER);
      setState(1754);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1753);
        opt_column();
      }
      setState(1756);
      colid();
      setState(1757);
      match(GreenPlumParser::SET);
      setState(1758);
      match(GreenPlumParser::STORAGE);
      setState(1759);
      colid();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1761);
      match(GreenPlumParser::DROP);
      setState(1763);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1762);
        opt_column();
      }
      setState(1765);
      colid();
      setState(1767);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(1766);
        opt_drop_behavior();
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1769);
      match(GreenPlumParser::ALTER);
      setState(1771);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(1770);
        opt_column();
      }
      setState(1773);
      colid();
      setState(1774);
      match(GreenPlumParser::TYPE_P);
      setState(1775);
      typename_pg();
      setState(1777);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::USING) {
        setState(1776);
        alter_using();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1779);
      match(GreenPlumParser::ADD_P);
      setState(1780);
      table_constraint();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1781);
      match(GreenPlumParser::DROP);
      setState(1782);
      match(GreenPlumParser::CONSTRAINT);
      setState(1783);
      name();
      setState(1785);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(1784);
        opt_drop_behavior();
      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1787);
      match(GreenPlumParser::SET);
      setState(1788);
      match(GreenPlumParser::WITHOUT);
      setState(1789);
      match(GreenPlumParser::OIDS);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1790);
      match(GreenPlumParser::CLUSTER);
      setState(1791);
      match(GreenPlumParser::ON);
      setState(1792);
      name();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1793);
      match(GreenPlumParser::SET);
      setState(1794);
      match(GreenPlumParser::WITHOUT);
      setState(1795);
      match(GreenPlumParser::CLUSTER);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1796);
      match(GreenPlumParser::ENABLE_P);
      setState(1798);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ALWAYS || _la == GreenPlumParser::REPLICA) {
        setState(1797);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::ALWAYS || _la == GreenPlumParser::REPLICA)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1800);
      match(GreenPlumParser::TRIGGER);
      setState(1801);
      name();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1802);
      match(GreenPlumParser::ENABLE_P);
      setState(1803);
      match(GreenPlumParser::TRIGGER);
      setState(1804);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::ALL || _la == GreenPlumParser::USER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1805);
      match(GreenPlumParser::DISABLE_P);
      setState(1806);
      match(GreenPlumParser::TRIGGER);
      setState(1810);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GreenPlumParser::ABORT_P:
        case GreenPlumParser::ABSOLUTE_P:
        case GreenPlumParser::ACCESS:
        case GreenPlumParser::ACTION:
        case GreenPlumParser::ACTIVE:
        case GreenPlumParser::ADD_P:
        case GreenPlumParser::ADMIN:
        case GreenPlumParser::AFTER:
        case GreenPlumParser::AGGREGATE:
        case GreenPlumParser::ALSO:
        case GreenPlumParser::ALTER:
        case GreenPlumParser::ALWAYS:
        case GreenPlumParser::ASSERTION:
        case GreenPlumParser::ASSIGNMENT:
        case GreenPlumParser::AT:
        case GreenPlumParser::BACKWARD:
        case GreenPlumParser::BEFORE:
        case GreenPlumParser::BEGIN_P:
        case GreenPlumParser::BY:
        case GreenPlumParser::CACHE:
        case GreenPlumParser::CALLED:
        case GreenPlumParser::CASCADE:
        case GreenPlumParser::CASCADED:
        case GreenPlumParser::CHAIN:
        case GreenPlumParser::CHARACTERISTICS:
        case GreenPlumParser::CHECKPOINT:
        case GreenPlumParser::CLASS:
        case GreenPlumParser::CLOSE:
        case GreenPlumParser::CLUSTER:
        case GreenPlumParser::COMMENT:
        case GreenPlumParser::COMMIT:
        case GreenPlumParser::COMMITTED:
        case GreenPlumParser::CONCURRENCY:
        case GreenPlumParser::CONCURRENTLY:
        case GreenPlumParser::CONFIGURATION:
        case GreenPlumParser::CONNECTION:
        case GreenPlumParser::CONSTRAINTS:
        case GreenPlumParser::CONTAINS:
        case GreenPlumParser::CONTENT_P:
        case GreenPlumParser::CONTINUE_P:
        case GreenPlumParser::CONVERSION_P:
        case GreenPlumParser::COPY:
        case GreenPlumParser::COST:
        case GreenPlumParser::CPU_RATE_LIMIT:
        case GreenPlumParser::CPUSET:
        case GreenPlumParser::CREATEDB:
        case GreenPlumParser::CREATEEXTTABLE:
        case GreenPlumParser::CREATEROLE:
        case GreenPlumParser::CREATEUSER:
        case GreenPlumParser::CSV:
        case GreenPlumParser::CURRENT_P:
        case GreenPlumParser::CURSOR:
        case GreenPlumParser::CYCLE:
        case GreenPlumParser::DATABASE:
        case GreenPlumParser::DATA_P:
        case GreenPlumParser::DAY_P:
        case GreenPlumParser::DEALLOCATE:
        case GreenPlumParser::DECLARE:
        case GreenPlumParser::DEFAULTS:
        case GreenPlumParser::DEFERRED:
        case GreenPlumParser::DEFINER:
        case GreenPlumParser::DELETE_P:
        case GreenPlumParser::DELIMITER:
        case GreenPlumParser::DELIMITERS:
        case GreenPlumParser::DENY:
        case GreenPlumParser::DICTIONARY:
        case GreenPlumParser::DISABLE_P:
        case GreenPlumParser::DISCARD:
        case GreenPlumParser::DOCUMENT_P:
        case GreenPlumParser::DOMAIN_P:
        case GreenPlumParser::DOUBLE_P:
        case GreenPlumParser::DROP:
        case GreenPlumParser::DXL:
        case GreenPlumParser::EACH:
        case GreenPlumParser::ENABLE_P:
        case GreenPlumParser::ENCODING:
        case GreenPlumParser::ENCRYPTED:
        case GreenPlumParser::ENUM_P:
        case GreenPlumParser::ERRORS:
        case GreenPlumParser::ESCAPE:
        case GreenPlumParser::EVERY:
        case GreenPlumParser::EXCHANGE:
        case GreenPlumParser::EXCLUDING:
        case GreenPlumParser::EXCLUSIVE:
        case GreenPlumParser::EXECUTE:
        case GreenPlumParser::EXPLAIN:
        case GreenPlumParser::EXTENSION:
        case GreenPlumParser::EXTERNAL:
        case GreenPlumParser::FAMILY:
        case GreenPlumParser::FIELDS:
        case GreenPlumParser::FILESPACE:
        case GreenPlumParser::FILL:
        case GreenPlumParser::FIRST_P:
        case GreenPlumParser::FORCE:
        case GreenPlumParser::FORMAT:
        case GreenPlumParser::FORWARD:
        case GreenPlumParser::FUNCTION:
        case GreenPlumParser::GLOBAL:
        case GreenPlumParser::GRANTED:
        case GreenPlumParser::HANDLER:
        case GreenPlumParser::HASH:
        case GreenPlumParser::HEADER_P:
        case GreenPlumParser::HOLD:
        case GreenPlumParser::HOST:
        case GreenPlumParser::HOUR_P:
        case GreenPlumParser::IDENTITY_P:
        case GreenPlumParser::IF_P:
        case GreenPlumParser::IGNORE_P:
        case GreenPlumParser::IMMEDIATE:
        case GreenPlumParser::IMMUTABLE:
        case GreenPlumParser::IMPLICIT_P:
        case GreenPlumParser::INCLUDING:
        case GreenPlumParser::INCLUSIVE:
        case GreenPlumParser::INCREMENT:
        case GreenPlumParser::INDEX:
        case GreenPlumParser::INDEXES:
        case GreenPlumParser::INHERIT:
        case GreenPlumParser::INHERITS:
        case GreenPlumParser::INLINE_P:
        case GreenPlumParser::INPUT_P:
        case GreenPlumParser::INSENSITIVE:
        case GreenPlumParser::INSERT:
        case GreenPlumParser::INSTEAD:
        case GreenPlumParser::INVOKER:
        case GreenPlumParser::ISOLATION:
        case GreenPlumParser::KEY:
        case GreenPlumParser::LANGUAGE:
        case GreenPlumParser::LARGE_P:
        case GreenPlumParser::LAST_P:
        case GreenPlumParser::LEVEL:
        case GreenPlumParser::LIST:
        case GreenPlumParser::LISTEN:
        case GreenPlumParser::LOAD:
        case GreenPlumParser::LOCAL:
        case GreenPlumParser::LOCATION:
        case GreenPlumParser::LOCK_P:
        case GreenPlumParser::LOGIN_P:
        case GreenPlumParser::MAPPING:
        case GreenPlumParser::MASTER:
        case GreenPlumParser::MATCH:
        case GreenPlumParser::MAXVALUE:
        case GreenPlumParser::MEMORY_LIMIT:
        case GreenPlumParser::MEMORY_SHARED_QUOTA:
        case GreenPlumParser::MEMORY_SPILL_RATIO:
        case GreenPlumParser::MERGE:
        case GreenPlumParser::MINUTE_P:
        case GreenPlumParser::MINVALUE:
        case GreenPlumParser::MISSING:
        case GreenPlumParser::MODE:
        case GreenPlumParser::MODIFIES:
        case GreenPlumParser::MODIFY:
        case GreenPlumParser::MONTH_P:
        case GreenPlumParser::MOVE:
        case GreenPlumParser::NAME_P:
        case GreenPlumParser::NAMES:
        case GreenPlumParser::NEXT:
        case GreenPlumParser::NO:
        case GreenPlumParser::NOCREATEDB:
        case GreenPlumParser::NOCREATEEXTTABLE:
        case GreenPlumParser::NOCREATEROLE:
        case GreenPlumParser::NOCREATEUSER:
        case GreenPlumParser::NOINHERIT:
        case GreenPlumParser::NOLOGIN_P:
        case GreenPlumParser::NOOVERCOMMIT:
        case GreenPlumParser::NOSUPERUSER:
        case GreenPlumParser::NOTHING:
        case GreenPlumParser::NOTIFY:
        case GreenPlumParser::NOWAIT:
        case GreenPlumParser::NULLS_P:
        case GreenPlumParser::OBJECT_P:
        case GreenPlumParser::OF:
        case GreenPlumParser::OIDS:
        case GreenPlumParser::OPERATOR:
        case GreenPlumParser::OPTION:
        case GreenPlumParser::OPTIONS:
        case GreenPlumParser::ORDERED:
        case GreenPlumParser::OTHERS:
        case GreenPlumParser::OVER:
        case GreenPlumParser::OVERCOMMIT:
        case GreenPlumParser::OWNED:
        case GreenPlumParser::OWNER:
        case GreenPlumParser::PARSER:
        case GreenPlumParser::PARTIAL:
        case GreenPlumParser::PARTITIONS:
        case GreenPlumParser::PASSING:
        case GreenPlumParser::PASSWORD:
        case GreenPlumParser::PERCENT:
        case GreenPlumParser::PLANS:
        case GreenPlumParser::PREPARE:
        case GreenPlumParser::PREPARED:
        case GreenPlumParser::PRESERVE:
        case GreenPlumParser::PRIOR:
        case GreenPlumParser::PRIVILEGES:
        case GreenPlumParser::PROCEDURAL:
        case GreenPlumParser::PROCEDURE:
        case GreenPlumParser::PROGRAM:
        case GreenPlumParser::PROTOCOL:
        case GreenPlumParser::PUBLIC:
        case GreenPlumParser::QUEUE:
        case GreenPlumParser::QUOTE:
        case GreenPlumParser::RANDOMLY:
        case GreenPlumParser::READ:
        case GreenPlumParser::READABLE:
        case GreenPlumParser::READS:
        case GreenPlumParser::REASSIGN:
        case GreenPlumParser::RECHECK:
        case GreenPlumParser::RECURSIVE:
        case GreenPlumParser::REF:
        case GreenPlumParser::REINDEX:
        case GreenPlumParser::REJECT_P:
        case GreenPlumParser::RELATIVE_P:
        case GreenPlumParser::RELEASE:
        case GreenPlumParser::RENAME:
        case GreenPlumParser::REPEATABLE:
        case GreenPlumParser::REPLACE:
        case GreenPlumParser::REPLICA:
        case GreenPlumParser::RESET:
        case GreenPlumParser::RESOURCE:
        case GreenPlumParser::RESTART:
        case GreenPlumParser::RESTRICT:
        case GreenPlumParser::RETURNS:
        case GreenPlumParser::REVOKE:
        case GreenPlumParser::ROLE:
        case GreenPlumParser::ROLLBACK:
        case GreenPlumParser::ROOTPARTITION:
        case GreenPlumParser::RULE:
        case GreenPlumParser::SAVEPOINT:
        case GreenPlumParser::SCHEMA:
        case GreenPlumParser::SCROLL:
        case GreenPlumParser::SEARCH:
        case GreenPlumParser::SECOND_P:
        case GreenPlumParser::SECURITY:
        case GreenPlumParser::SEGMENT:
        case GreenPlumParser::SEQUENCE:
        case GreenPlumParser::SERIALIZABLE:
        case GreenPlumParser::SESSION:
        case GreenPlumParser::SET:
        case GreenPlumParser::SHARE:
        case GreenPlumParser::SHOW:
        case GreenPlumParser::SIMPLE:
        case GreenPlumParser::SPLIT:
        case GreenPlumParser::SQL:
        case GreenPlumParser::STABLE:
        case GreenPlumParser::STANDALONE_P:
        case GreenPlumParser::START:
        case GreenPlumParser::STATEMENT:
        case GreenPlumParser::STATISTICS:
        case GreenPlumParser::STDIN:
        case GreenPlumParser::STDOUT:
        case GreenPlumParser::STORAGE:
        case GreenPlumParser::STRICT_P:
        case GreenPlumParser::STRIP_P:
        case GreenPlumParser::SUBPARTITION:
        case GreenPlumParser::SUBPARTITIONS:
        case GreenPlumParser::SUPERUSER_P:
        case GreenPlumParser::SYSID:
        case GreenPlumParser::SYSTEM_P:
        case GreenPlumParser::TABLESPACE:
        case GreenPlumParser::TEMP:
        case GreenPlumParser::TEMPLATE:
        case GreenPlumParser::TEMPORARY:
        case GreenPlumParser::TEXT_P:
        case GreenPlumParser::THRESHOLD:
        case GreenPlumParser::TIES:
        case GreenPlumParser::TRANSACTION:
        case GreenPlumParser::TRIGGER:
        case GreenPlumParser::TRUNCATE:
        case GreenPlumParser::TRUSTED:
        case GreenPlumParser::TYPE_P:
        case GreenPlumParser::UNCOMMITTED:
        case GreenPlumParser::UNENCRYPTED:
        case GreenPlumParser::UNKNOWN:
        case GreenPlumParser::UNLISTEN:
        case GreenPlumParser::UNTIL:
        case GreenPlumParser::UPDATE:
        case GreenPlumParser::VACUUM:
        case GreenPlumParser::VALID:
        case GreenPlumParser::VALIDATION:
        case GreenPlumParser::VALIDATOR:
        case GreenPlumParser::VALUE_P:
        case GreenPlumParser::VARYING:
        case GreenPlumParser::VERSION_P:
        case GreenPlumParser::VIEW:
        case GreenPlumParser::VOLATILE:
        case GreenPlumParser::WEB:
        case GreenPlumParser::WHITESPACE_P:
        case GreenPlumParser::WITHIN:
        case GreenPlumParser::WITHOUT:
        case GreenPlumParser::WORK:
        case GreenPlumParser::WRITABLE:
        case GreenPlumParser::WRITE:
        case GreenPlumParser::XML_P:
        case GreenPlumParser::YEAR_P:
        case GreenPlumParser::YES_P:
        case GreenPlumParser::ZONE:
        case GreenPlumParser::COLON:
        case GreenPlumParser::CHAR_STRING:
        case GreenPlumParser::REGULAR_ID:
        case GreenPlumParser::SCONST: {
          setState(1807);
          name();
          break;
        }

        case GreenPlumParser::ALL: {
          setState(1808);
          match(GreenPlumParser::ALL);
          break;
        }

        case GreenPlumParser::USER: {
          setState(1809);
          match(GreenPlumParser::USER);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1812);
      match(GreenPlumParser::ENABLE_P);
      setState(1814);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ALWAYS || _la == GreenPlumParser::REPLICA) {
        setState(1813);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::ALWAYS || _la == GreenPlumParser::REPLICA)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1816);
      match(GreenPlumParser::RULE);
      setState(1817);
      name();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1818);
      match(GreenPlumParser::DISABLE_P);
      setState(1819);
      match(GreenPlumParser::RULE);
      setState(1820);
      name();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1822);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NO) {
        setState(1821);
        match(GreenPlumParser::NO);
      }
      setState(1824);
      match(GreenPlumParser::INHERIT);
      setState(1825);
      qualified_name();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1826);
      match(GreenPlumParser::SET);
      setState(1828);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::WITH

      || _la == GreenPlumParser::WITHOUT) {
        setState(1827);
        with_out_definition();
      }
      setState(1830);
      distributed_by();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1831);
      match(GreenPlumParser::SET);
      setState(1832);
      with_out_definition();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1833);
      alter_table_partition_cmd();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1834);
      alter_rel_cmd();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_table_partition_split_intoContext ------------------------------------------------------------------

GreenPlumParser::Opt_table_partition_split_intoContext::Opt_table_partition_split_intoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_split_intoContext::INTO() {
  return getToken(GreenPlumParser::INTO, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_split_intoContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

std::vector<GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext *> GreenPlumParser::Opt_table_partition_split_intoContext::alter_table_partition_id_spec_with_opt_default() {
  return getRuleContexts<GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext>();
}

GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext* GreenPlumParser::Opt_table_partition_split_intoContext::alter_table_partition_id_spec_with_opt_default(size_t i) {
  return getRuleContext<GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext>(i);
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_split_intoContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_split_intoContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Opt_table_partition_split_intoContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_table_partition_split_into;
}

void GreenPlumParser::Opt_table_partition_split_intoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_table_partition_split_into(this);
}

void GreenPlumParser::Opt_table_partition_split_intoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_table_partition_split_into(this);
}


antlrcpp::Any GreenPlumParser::Opt_table_partition_split_intoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_table_partition_split_into(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_table_partition_split_intoContext* GreenPlumParser::opt_table_partition_split_into() {
  Opt_table_partition_split_intoContext *_localctx = _tracker.createInstance<Opt_table_partition_split_intoContext>(_ctx, getState());
  enterRule(_localctx, 120, GreenPlumParser::RuleOpt_table_partition_split_into);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1837);
    match(GreenPlumParser::INTO);
    setState(1838);
    match(GreenPlumParser::LEFT_PAREN);
    setState(1839);
    alter_table_partition_id_spec_with_opt_default();
    setState(1840);
    match(GreenPlumParser::COMMA);
    setState(1841);
    alter_table_partition_id_spec_with_opt_default();
    setState(1842);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_table_partition_merge_intoContext ------------------------------------------------------------------

GreenPlumParser::Opt_table_partition_merge_intoContext::Opt_table_partition_merge_intoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_merge_intoContext::INTO() {
  return getToken(GreenPlumParser::INTO, 0);
}

GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext* GreenPlumParser::Opt_table_partition_merge_intoContext::alter_table_partition_id_spec_with_opt_default() {
  return getRuleContext<GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext>(0);
}


size_t GreenPlumParser::Opt_table_partition_merge_intoContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_table_partition_merge_into;
}

void GreenPlumParser::Opt_table_partition_merge_intoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_table_partition_merge_into(this);
}

void GreenPlumParser::Opt_table_partition_merge_intoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_table_partition_merge_into(this);
}


antlrcpp::Any GreenPlumParser::Opt_table_partition_merge_intoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_table_partition_merge_into(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_table_partition_merge_intoContext* GreenPlumParser::opt_table_partition_merge_into() {
  Opt_table_partition_merge_intoContext *_localctx = _tracker.createInstance<Opt_table_partition_merge_intoContext>(_ctx, getState());
  enterRule(_localctx, 122, GreenPlumParser::RuleOpt_table_partition_merge_into);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1844);
    match(GreenPlumParser::INTO);
    setState(1845);
    alter_table_partition_id_spec_with_opt_default();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_partition_modifyContext ------------------------------------------------------------------

GreenPlumParser::Table_partition_modifyContext::Table_partition_modifyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Tab_partition_boundary_spec_startContext* GreenPlumParser::Table_partition_modifyContext::tab_partition_boundary_spec_start() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_startContext>(0);
}

GreenPlumParser::Tab_partition_boundary_spec_endContext* GreenPlumParser::Table_partition_modifyContext::tab_partition_boundary_spec_end() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_endContext>(0);
}

GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext* GreenPlumParser::Table_partition_modifyContext::opt_tab_partition_boundary_spec_every() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext>(0);
}

GreenPlumParser::Add_dropContext* GreenPlumParser::Table_partition_modifyContext::add_drop() {
  return getRuleContext<GreenPlumParser::Add_dropContext>(0);
}

GreenPlumParser::Part_values_clauseContext* GreenPlumParser::Table_partition_modifyContext::part_values_clause() {
  return getRuleContext<GreenPlumParser::Part_values_clauseContext>(0);
}


size_t GreenPlumParser::Table_partition_modifyContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_partition_modify;
}

void GreenPlumParser::Table_partition_modifyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_partition_modify(this);
}

void GreenPlumParser::Table_partition_modifyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_partition_modify(this);
}


antlrcpp::Any GreenPlumParser::Table_partition_modifyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_partition_modify(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_partition_modifyContext* GreenPlumParser::table_partition_modify() {
  Table_partition_modifyContext *_localctx = _tracker.createInstance<Table_partition_modifyContext>(_ctx, getState());
  enterRule(_localctx, 124, GreenPlumParser::RuleTable_partition_modify);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1861);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::START: {
        enterOuterAlt(_localctx, 1);
        setState(1847);
        tab_partition_boundary_spec_start();
        setState(1849);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::END_P) {
          setState(1848);
          tab_partition_boundary_spec_end();
        }
        setState(1852);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EVERY) {
          setState(1851);
          opt_tab_partition_boundary_spec_every();
        }
        break;
      }

      case GreenPlumParser::END_P: {
        enterOuterAlt(_localctx, 2);
        setState(1854);
        tab_partition_boundary_spec_end();
        setState(1856);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EVERY) {
          setState(1855);
          opt_tab_partition_boundary_spec_every();
        }
        break;
      }

      case GreenPlumParser::ADD_P:
      case GreenPlumParser::DROP: {
        enterOuterAlt(_localctx, 3);
        setState(1858);
        add_drop();
        setState(1859);
        part_values_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_table_partition_exchange_validateContext ------------------------------------------------------------------

GreenPlumParser::Opt_table_partition_exchange_validateContext::Opt_table_partition_exchange_validateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_exchange_validateContext::VALIDATION() {
  return getToken(GreenPlumParser::VALIDATION, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_exchange_validateContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_table_partition_exchange_validateContext::WITHOUT() {
  return getToken(GreenPlumParser::WITHOUT, 0);
}


size_t GreenPlumParser::Opt_table_partition_exchange_validateContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_table_partition_exchange_validate;
}

void GreenPlumParser::Opt_table_partition_exchange_validateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_table_partition_exchange_validate(this);
}

void GreenPlumParser::Opt_table_partition_exchange_validateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_table_partition_exchange_validate(this);
}


antlrcpp::Any GreenPlumParser::Opt_table_partition_exchange_validateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_table_partition_exchange_validate(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_table_partition_exchange_validateContext* GreenPlumParser::opt_table_partition_exchange_validate() {
  Opt_table_partition_exchange_validateContext *_localctx = _tracker.createInstance<Opt_table_partition_exchange_validateContext>(_ctx, getState());
  enterRule(_localctx, 126, GreenPlumParser::RuleOpt_table_partition_exchange_validate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1863);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1864);
    match(GreenPlumParser::VALIDATION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_partition_id_specContext ------------------------------------------------------------------

GreenPlumParser::Alter_table_partition_id_specContext::Alter_table_partition_id_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Partition_colidContext* GreenPlumParser::Alter_table_partition_id_specContext::partition_colid() {
  return getRuleContext<GreenPlumParser::Partition_colidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_id_specContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_id_specContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Tab_partition_boundary_spec_val_listContext* GreenPlumParser::Alter_table_partition_id_specContext::tab_partition_boundary_spec_val_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_val_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_id_specContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Alter_table_partition_id_specContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Alter_table_partition_id_specContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}


size_t GreenPlumParser::Alter_table_partition_id_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_table_partition_id_spec;
}

void GreenPlumParser::Alter_table_partition_id_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_partition_id_spec(this);
}

void GreenPlumParser::Alter_table_partition_id_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_partition_id_spec(this);
}


antlrcpp::Any GreenPlumParser::Alter_table_partition_id_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_partition_id_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_table_partition_id_specContext* GreenPlumParser::alter_table_partition_id_spec() {
  Alter_table_partition_id_specContext *_localctx = _tracker.createInstance<Alter_table_partition_id_specContext>(_ctx, getState());
  enterRule(_localctx, 128, GreenPlumParser::RuleAlter_table_partition_id_spec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1878);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1866);
      partition_colid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1867);
      match(GreenPlumParser::FOR);
      setState(1868);
      match(GreenPlumParser::LEFT_PAREN);
      setState(1869);
      tab_partition_boundary_spec_val_list();
      setState(1870);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1872);
      match(GreenPlumParser::FOR);
      setState(1873);
      match(GreenPlumParser::LEFT_PAREN);
      setState(1874);
      func_name();
      setState(1875);
      paren_expr_list();
      setState(1876);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_partition_id_spec_with_opt_defaultContext ------------------------------------------------------------------

GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::Alter_table_partition_id_spec_with_opt_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::PARTITION() {
  return getToken(GreenPlumParser::PARTITION, 0);
}

GreenPlumParser::Alter_table_partition_id_specContext* GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::alter_table_partition_id_spec() {
  return getRuleContext<GreenPlumParser::Alter_table_partition_id_specContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_table_partition_id_spec_with_opt_default;
}

void GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_partition_id_spec_with_opt_default(this);
}

void GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_partition_id_spec_with_opt_default(this);
}


antlrcpp::Any GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_partition_id_spec_with_opt_default(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext* GreenPlumParser::alter_table_partition_id_spec_with_opt_default() {
  Alter_table_partition_id_spec_with_opt_defaultContext *_localctx = _tracker.createInstance<Alter_table_partition_id_spec_with_opt_defaultContext>(_ctx, getState());
  enterRule(_localctx, 130, GreenPlumParser::RuleAlter_table_partition_id_spec_with_opt_default);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1887);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1880);
      match(GreenPlumParser::PARTITION);
      setState(1881);
      alter_table_partition_id_spec();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1882);
      match(GreenPlumParser::DEFAULT);
      setState(1883);
      match(GreenPlumParser::PARTITION);
      setState(1884);
      alter_table_partition_id_spec();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1885);
      match(GreenPlumParser::DEFAULT);
      setState(1886);
      match(GreenPlumParser::PARTITION);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_partition_cmdContext ------------------------------------------------------------------

GreenPlumParser::Alter_table_partition_cmdContext::Alter_table_partition_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::PARTITION() {
  return getToken(GreenPlumParser::PARTITION, 0);
}

GreenPlumParser::Tab_partition_boundary_specContext* GreenPlumParser::Alter_table_partition_cmdContext::tab_partition_boundary_spec() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_specContext>(0);
}

GreenPlumParser::Opt_tab_partition_storage_attrContext* GreenPlumParser::Alter_table_partition_cmdContext::opt_tab_partition_storage_attr() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_storage_attrContext>(0);
}

GreenPlumParser::Opt_tab_sub_partition_specContext* GreenPlumParser::Alter_table_partition_cmdContext::opt_tab_sub_partition_spec() {
  return getRuleContext<GreenPlumParser::Opt_tab_sub_partition_specContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

GreenPlumParser::Alter_table_partition_id_specContext* GreenPlumParser::Alter_table_partition_cmdContext::alter_table_partition_id_spec() {
  return getRuleContext<GreenPlumParser::Alter_table_partition_id_specContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

std::vector<GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext *> GreenPlumParser::Alter_table_partition_cmdContext::alter_table_partition_id_spec_with_opt_default() {
  return getRuleContexts<GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext>();
}

GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext* GreenPlumParser::Alter_table_partition_cmdContext::alter_table_partition_id_spec_with_opt_default(size_t i) {
  return getRuleContext<GreenPlumParser::Alter_table_partition_id_spec_with_opt_defaultContext>(i);
}

GreenPlumParser::Alter_table_cmdContext* GreenPlumParser::Alter_table_partition_cmdContext::alter_table_cmd() {
  return getRuleContext<GreenPlumParser::Alter_table_cmdContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::COALESCE() {
  return getToken(GreenPlumParser::COALESCE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Alter_table_partition_cmdContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::EXCHANGE() {
  return getToken(GreenPlumParser::EXCHANGE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Alter_table_partition_cmdContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Opt_table_partition_exchange_validateContext* GreenPlumParser::Alter_table_partition_cmdContext::opt_table_partition_exchange_validate() {
  return getRuleContext<GreenPlumParser::Opt_table_partition_exchange_validateContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::MERGE() {
  return getToken(GreenPlumParser::MERGE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}

GreenPlumParser::Opt_table_partition_merge_intoContext* GreenPlumParser::Alter_table_partition_cmdContext::opt_table_partition_merge_into() {
  return getRuleContext<GreenPlumParser::Opt_table_partition_merge_intoContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::MODIFY() {
  return getToken(GreenPlumParser::MODIFY, 0);
}

GreenPlumParser::Table_partition_modifyContext* GreenPlumParser::Alter_table_partition_cmdContext::table_partition_modify() {
  return getRuleContext<GreenPlumParser::Table_partition_modifyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::RENAME() {
  return getToken(GreenPlumParser::RENAME, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::IdentifierContext* GreenPlumParser::Alter_table_partition_cmdContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::SUBPARTITION() {
  return getToken(GreenPlumParser::SUBPARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Tab_sub_partition_elem_listContext* GreenPlumParser::Alter_table_partition_cmdContext::tab_sub_partition_elem_list() {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_elem_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::SPLIT() {
  return getToken(GreenPlumParser::SPLIT, 0);
}

GreenPlumParser::Tab_partition_boundary_spec_startContext* GreenPlumParser::Alter_table_partition_cmdContext::tab_partition_boundary_spec_start() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_startContext>(0);
}

GreenPlumParser::Tab_partition_boundary_spec_endContext* GreenPlumParser::Alter_table_partition_cmdContext::tab_partition_boundary_spec_end() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_endContext>(0);
}

GreenPlumParser::Opt_table_partition_split_intoContext* GreenPlumParser::Alter_table_partition_cmdContext::opt_table_partition_split_into() {
  return getRuleContext<GreenPlumParser::Opt_table_partition_split_intoContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::AT() {
  return getToken(GreenPlumParser::AT, 0);
}

GreenPlumParser::Part_values_or_spec_listContext* GreenPlumParser::Alter_table_partition_cmdContext::part_values_or_spec_list() {
  return getRuleContext<GreenPlumParser::Part_values_or_spec_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_table_partition_cmdContext::TRUNCATE() {
  return getToken(GreenPlumParser::TRUNCATE, 0);
}


size_t GreenPlumParser::Alter_table_partition_cmdContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_table_partition_cmd;
}

void GreenPlumParser::Alter_table_partition_cmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_partition_cmd(this);
}

void GreenPlumParser::Alter_table_partition_cmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_partition_cmd(this);
}


antlrcpp::Any GreenPlumParser::Alter_table_partition_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_partition_cmd(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_table_partition_cmdContext* GreenPlumParser::alter_table_partition_cmd() {
  Alter_table_partition_cmdContext *_localctx = _tracker.createInstance<Alter_table_partition_cmdContext>(_ctx, getState());
  enterRule(_localctx, 132, GreenPlumParser::RuleAlter_table_partition_cmd);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2015);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1889);
      match(GreenPlumParser::ADD_P);
      setState(1890);
      match(GreenPlumParser::PARTITION);
      setState(1892);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::END_P || _la == GreenPlumParser::START

      || _la == GreenPlumParser::VALUES) {
        setState(1891);
        tab_partition_boundary_spec();
      }
      setState(1895);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TABLESPACE

      || _la == GreenPlumParser::WITH) {
        setState(1894);
        opt_tab_partition_storage_attr();
      }
      setState(1898);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(1897);
        opt_tab_sub_partition_spec();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1900);
      match(GreenPlumParser::ADD_P);
      setState(1901);
      match(GreenPlumParser::DEFAULT);
      setState(1902);
      match(GreenPlumParser::PARTITION);
      setState(1903);
      alter_table_partition_id_spec();
      setState(1905);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::END_P || _la == GreenPlumParser::START

      || _la == GreenPlumParser::VALUES) {
        setState(1904);
        tab_partition_boundary_spec();
      }
      setState(1908);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TABLESPACE

      || _la == GreenPlumParser::WITH) {
        setState(1907);
        opt_tab_partition_storage_attr();
      }
      setState(1911);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(1910);
        opt_tab_sub_partition_spec();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1913);
      match(GreenPlumParser::ADD_P);
      setState(1914);
      match(GreenPlumParser::PARTITION);
      setState(1915);
      alter_table_partition_id_spec();
      setState(1917);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::END_P || _la == GreenPlumParser::START

      || _la == GreenPlumParser::VALUES) {
        setState(1916);
        tab_partition_boundary_spec();
      }
      setState(1920);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TABLESPACE

      || _la == GreenPlumParser::WITH) {
        setState(1919);
        opt_tab_partition_storage_attr();
      }
      setState(1923);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(1922);
        opt_tab_sub_partition_spec();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1925);
      match(GreenPlumParser::ALTER);
      setState(1926);
      alter_table_partition_id_spec_with_opt_default();
      setState(1927);
      alter_table_cmd();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1929);
      match(GreenPlumParser::COALESCE);
      setState(1930);
      match(GreenPlumParser::PARTITION);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1931);
      match(GreenPlumParser::COALESCE);
      setState(1932);
      match(GreenPlumParser::PARTITION);
      setState(1933);
      alter_table_partition_id_spec();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1934);
      match(GreenPlumParser::DROP);
      setState(1935);
      match(GreenPlumParser::PARTITION);
      setState(1936);
      match(GreenPlumParser::IF_P);
      setState(1937);
      match(GreenPlumParser::EXISTS);
      setState(1938);
      alter_table_partition_id_spec();
      setState(1940);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(1939);
        opt_drop_behavior();
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1942);
      match(GreenPlumParser::DROP);
      setState(1943);
      match(GreenPlumParser::DEFAULT);
      setState(1944);
      match(GreenPlumParser::PARTITION);
      setState(1945);
      match(GreenPlumParser::IF_P);
      setState(1946);
      match(GreenPlumParser::EXISTS);
      setState(1948);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(1947);
        opt_drop_behavior();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1950);
      match(GreenPlumParser::DROP);
      setState(1951);
      alter_table_partition_id_spec_with_opt_default();
      setState(1953);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(1952);
        opt_drop_behavior();
      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1955);
      match(GreenPlumParser::DROP);
      setState(1956);
      match(GreenPlumParser::PARTITION);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1957);
      match(GreenPlumParser::EXCHANGE);
      setState(1958);
      alter_table_partition_id_spec_with_opt_default();
      setState(1959);
      match(GreenPlumParser::WITH);
      setState(1960);
      match(GreenPlumParser::TABLE);
      setState(1961);
      qualified_name();
      setState(1963);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::WITH

      || _la == GreenPlumParser::WITHOUT) {
        setState(1962);
        opt_table_partition_exchange_validate();
      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1965);
      match(GreenPlumParser::MERGE);
      setState(1966);
      alter_table_partition_id_spec_with_opt_default();
      setState(1967);
      match(GreenPlumParser::COMMA);
      setState(1968);
      alter_table_partition_id_spec_with_opt_default();
      setState(1970);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::INTO) {
        setState(1969);
        opt_table_partition_merge_into();
      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1972);
      match(GreenPlumParser::MODIFY);
      setState(1973);
      alter_table_partition_id_spec_with_opt_default();
      setState(1974);
      table_partition_modify();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1976);
      match(GreenPlumParser::RENAME);
      setState(1977);
      alter_table_partition_id_spec_with_opt_default();
      setState(1978);
      match(GreenPlumParser::TO);
      setState(1979);
      identifier();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1981);
      match(GreenPlumParser::SET);
      setState(1982);
      match(GreenPlumParser::SUBPARTITION);
      setState(1983);
      match(GreenPlumParser::TEMPLATE);
      setState(1984);
      match(GreenPlumParser::LEFT_PAREN);
      setState(1985);
      tab_sub_partition_elem_list();
      setState(1986);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1988);
      match(GreenPlumParser::SET);
      setState(1989);
      match(GreenPlumParser::SUBPARTITION);
      setState(1990);
      match(GreenPlumParser::TEMPLATE);
      setState(1991);
      match(GreenPlumParser::LEFT_PAREN);
      setState(1992);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1993);
      match(GreenPlumParser::SPLIT);
      setState(1994);
      match(GreenPlumParser::DEFAULT);
      setState(1995);
      match(GreenPlumParser::PARTITION);
      setState(1996);
      tab_partition_boundary_spec_start();
      setState(1997);
      tab_partition_boundary_spec_end();
      setState(1999);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::INTO) {
        setState(1998);
        opt_table_partition_split_into();
      }
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(2001);
      match(GreenPlumParser::SPLIT);
      setState(2002);
      alter_table_partition_id_spec_with_opt_default();
      setState(2003);
      match(GreenPlumParser::AT);
      setState(2004);
      match(GreenPlumParser::LEFT_PAREN);
      setState(2005);
      part_values_or_spec_list();
      setState(2006);
      match(GreenPlumParser::RIGHT_PAREN);
      setState(2008);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::INTO) {
        setState(2007);
        opt_table_partition_split_into();
      }
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(2010);
      match(GreenPlumParser::TRUNCATE);
      setState(2011);
      alter_table_partition_id_spec_with_opt_default();
      setState(2013);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(2012);
        opt_drop_behavior();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_rel_cmdsContext ------------------------------------------------------------------

GreenPlumParser::Alter_rel_cmdsContext::Alter_rel_cmdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Alter_rel_cmdContext *> GreenPlumParser::Alter_rel_cmdsContext::alter_rel_cmd() {
  return getRuleContexts<GreenPlumParser::Alter_rel_cmdContext>();
}

GreenPlumParser::Alter_rel_cmdContext* GreenPlumParser::Alter_rel_cmdsContext::alter_rel_cmd(size_t i) {
  return getRuleContext<GreenPlumParser::Alter_rel_cmdContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Alter_rel_cmdsContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Alter_rel_cmdsContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Alter_rel_cmdsContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_rel_cmds;
}

void GreenPlumParser::Alter_rel_cmdsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_rel_cmds(this);
}

void GreenPlumParser::Alter_rel_cmdsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_rel_cmds(this);
}


antlrcpp::Any GreenPlumParser::Alter_rel_cmdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_rel_cmds(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_rel_cmdsContext* GreenPlumParser::alter_rel_cmds() {
  Alter_rel_cmdsContext *_localctx = _tracker.createInstance<Alter_rel_cmdsContext>(_ctx, getState());
  enterRule(_localctx, 134, GreenPlumParser::RuleAlter_rel_cmds);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2017);
    alter_rel_cmd();
    setState(2022);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2018);
      match(GreenPlumParser::COMMA);
      setState(2019);
      alter_rel_cmd();
      setState(2024);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_rel_cmdContext ------------------------------------------------------------------

GreenPlumParser::Alter_rel_cmdContext::Alter_rel_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_rel_cmdContext::OWNER() {
  return getToken(GreenPlumParser::OWNER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_rel_cmdContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Alter_rel_cmdContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_rel_cmdContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_rel_cmdContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_rel_cmdContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Alter_rel_cmdContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_rel_cmdContext::RESET() {
  return getToken(GreenPlumParser::RESET, 0);
}


size_t GreenPlumParser::Alter_rel_cmdContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_rel_cmd;
}

void GreenPlumParser::Alter_rel_cmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_rel_cmd(this);
}

void GreenPlumParser::Alter_rel_cmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_rel_cmd(this);
}


antlrcpp::Any GreenPlumParser::Alter_rel_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_rel_cmd(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_rel_cmdContext* GreenPlumParser::alter_rel_cmd() {
  Alter_rel_cmdContext *_localctx = _tracker.createInstance<Alter_rel_cmdContext>(_ctx, getState());
  enterRule(_localctx, 136, GreenPlumParser::RuleAlter_rel_cmd);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2033);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2025);
      match(GreenPlumParser::OWNER);
      setState(2026);
      match(GreenPlumParser::TO);
      setState(2027);
      role_id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2028);
      match(GreenPlumParser::SET);
      setState(2029);
      match(GreenPlumParser::TABLESPACE);
      setState(2030);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2031);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::RESET

      || _la == GreenPlumParser::SET)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2032);
      definition();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_column_defaultContext ------------------------------------------------------------------

GreenPlumParser::Alter_column_defaultContext::Alter_column_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_column_defaultContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_column_defaultContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Alter_column_defaultContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_column_defaultContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}


size_t GreenPlumParser::Alter_column_defaultContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_column_default;
}

void GreenPlumParser::Alter_column_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_column_default(this);
}

void GreenPlumParser::Alter_column_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_column_default(this);
}


antlrcpp::Any GreenPlumParser::Alter_column_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_column_default(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_column_defaultContext* GreenPlumParser::alter_column_default() {
  Alter_column_defaultContext *_localctx = _tracker.createInstance<Alter_column_defaultContext>(_ctx, getState());
  enterRule(_localctx, 138, GreenPlumParser::RuleAlter_column_default);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2040);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::SET: {
        enterOuterAlt(_localctx, 1);
        setState(2035);
        match(GreenPlumParser::SET);
        setState(2036);
        match(GreenPlumParser::DEFAULT);
        setState(2037);
        a_expr();
        break;
      }

      case GreenPlumParser::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(2038);
        match(GreenPlumParser::DROP);
        setState(2039);
        match(GreenPlumParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_drop_behaviorContext ------------------------------------------------------------------

GreenPlumParser::Opt_drop_behaviorContext::Opt_drop_behaviorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_drop_behaviorContext::CASCADE() {
  return getToken(GreenPlumParser::CASCADE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_drop_behaviorContext::RESTRICT() {
  return getToken(GreenPlumParser::RESTRICT, 0);
}


size_t GreenPlumParser::Opt_drop_behaviorContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_drop_behavior;
}

void GreenPlumParser::Opt_drop_behaviorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_drop_behavior(this);
}

void GreenPlumParser::Opt_drop_behaviorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_drop_behavior(this);
}


antlrcpp::Any GreenPlumParser::Opt_drop_behaviorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_drop_behavior(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::opt_drop_behavior() {
  Opt_drop_behaviorContext *_localctx = _tracker.createInstance<Opt_drop_behaviorContext>(_ctx, getState());
  enterRule(_localctx, 140, GreenPlumParser::RuleOpt_drop_behavior);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2042);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_usingContext ------------------------------------------------------------------

GreenPlumParser::Alter_usingContext::Alter_usingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_usingContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Alter_usingContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Alter_usingContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_using;
}

void GreenPlumParser::Alter_usingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_using(this);
}

void GreenPlumParser::Alter_usingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_using(this);
}


antlrcpp::Any GreenPlumParser::Alter_usingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_using(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_usingContext* GreenPlumParser::alter_using() {
  Alter_usingContext *_localctx = _tracker.createInstance<Alter_usingContext>(_ctx, getState());
  enterRule(_localctx, 142, GreenPlumParser::RuleAlter_using);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2044);
    match(GreenPlumParser::USING);
    setState(2045);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Close_portal_stmtContext ------------------------------------------------------------------

GreenPlumParser::Close_portal_stmtContext::Close_portal_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Close_portal_stmtContext::CLOSE() {
  return getToken(GreenPlumParser::CLOSE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Close_portal_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Close_portal_stmtContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}


size_t GreenPlumParser::Close_portal_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleClose_portal_stmt;
}

void GreenPlumParser::Close_portal_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClose_portal_stmt(this);
}

void GreenPlumParser::Close_portal_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClose_portal_stmt(this);
}


antlrcpp::Any GreenPlumParser::Close_portal_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitClose_portal_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Close_portal_stmtContext* GreenPlumParser::close_portal_stmt() {
  Close_portal_stmtContext *_localctx = _tracker.createInstance<Close_portal_stmtContext>(_ctx, getState());
  enterRule(_localctx, 144, GreenPlumParser::RuleClose_portal_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2047);
    match(GreenPlumParser::CLOSE);
    setState(2050);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        setState(2048);
        name();
        break;
      }

      case GreenPlumParser::ALL: {
        setState(2049);
        match(GreenPlumParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_stmtContext ------------------------------------------------------------------

GreenPlumParser::Copy_stmtContext::Copy_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Copy_stmtContext::COPY() {
  return getToken(GreenPlumParser::COPY, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Copy_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Copy_fromContext* GreenPlumParser::Copy_stmtContext::copy_from() {
  return getRuleContext<GreenPlumParser::Copy_fromContext>(0);
}

GreenPlumParser::Copy_file_nameContext* GreenPlumParser::Copy_stmtContext::copy_file_name() {
  return getRuleContext<GreenPlumParser::Copy_file_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Copy_stmtContext::BINARY() {
  return getToken(GreenPlumParser::BINARY, 0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Copy_stmtContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}

GreenPlumParser::Opt_oidsContext* GreenPlumParser::Copy_stmtContext::opt_oids() {
  return getRuleContext<GreenPlumParser::Opt_oidsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Copy_stmtContext::PROGRAM() {
  return getToken(GreenPlumParser::PROGRAM, 0);
}

GreenPlumParser::Copy_delimiterContext* GreenPlumParser::Copy_stmtContext::copy_delimiter() {
  return getRuleContext<GreenPlumParser::Copy_delimiterContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Copy_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Copy_opt_itemContext *> GreenPlumParser::Copy_stmtContext::copy_opt_item() {
  return getRuleContexts<GreenPlumParser::Copy_opt_itemContext>();
}

GreenPlumParser::Copy_opt_itemContext* GreenPlumParser::Copy_stmtContext::copy_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Copy_opt_itemContext>(i);
}

GreenPlumParser::Opt_single_row_error_handlingContext* GreenPlumParser::Copy_stmtContext::opt_single_row_error_handling() {
  return getRuleContext<GreenPlumParser::Opt_single_row_error_handlingContext>(0);
}

GreenPlumParser::Skip_external_partitionContext* GreenPlumParser::Copy_stmtContext::skip_external_partition() {
  return getRuleContext<GreenPlumParser::Skip_external_partitionContext>(0);
}

GreenPlumParser::Select_with_parensContext* GreenPlumParser::Copy_stmtContext::select_with_parens() {
  return getRuleContext<GreenPlumParser::Select_with_parensContext>(0);
}

tree::TerminalNode* GreenPlumParser::Copy_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}


size_t GreenPlumParser::Copy_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCopy_stmt;
}

void GreenPlumParser::Copy_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_stmt(this);
}

void GreenPlumParser::Copy_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_stmt(this);
}


antlrcpp::Any GreenPlumParser::Copy_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCopy_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Copy_stmtContext* GreenPlumParser::copy_stmt() {
  Copy_stmtContext *_localctx = _tracker.createInstance<Copy_stmtContext>(_ctx, getState());
  enterRule(_localctx, 146, GreenPlumParser::RuleCopy_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2102);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2052);
      match(GreenPlumParser::COPY);
      setState(2054);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::BINARY) {
        setState(2053);
        match(GreenPlumParser::BINARY);
      }
      setState(2056);
      qualified_name();
      setState(2058);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(2057);
        paren_column_list();
      }
      setState(2061);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::WITH) {
        setState(2060);
        opt_oids();
      }
      setState(2063);
      copy_from();
      setState(2065);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PROGRAM) {
        setState(2064);
        match(GreenPlumParser::PROGRAM);
      }
      setState(2067);
      copy_file_name();
      setState(2069);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::DELIMITERS || _la == GreenPlumParser::USING) {
        setState(2068);
        copy_delimiter();
      }
      setState(2072);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::WITH) {
        setState(2071);
        opt_with();
      }
      setState(2077);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GreenPlumParser::BINARY || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & ((1ULL << (GreenPlumParser::CSV - 79))
        | (1ULL << (GreenPlumParser::DELIMITER - 79))
        | (1ULL << (GreenPlumParser::ESCAPE - 79)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 146)) & ((1ULL << (GreenPlumParser::FILL - 146))
        | (1ULL << (GreenPlumParser::FORCE - 146))
        | (1ULL << (GreenPlumParser::HEADER_P - 146)))) != 0) || ((((_la - 268) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 268)) & ((1ULL << (GreenPlumParser::NULL_P - 268))
        | (1ULL << (GreenPlumParser::OIDS - 268))
        | (1ULL << (GreenPlumParser::ON - 268))
        | (1ULL << (GreenPlumParser::QUOTE - 268)))) != 0)) {
        setState(2074);
        copy_opt_item();
        setState(2079);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2081);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LOG_P || _la == GreenPlumParser::SEGMENT) {
        setState(2080);
        opt_single_row_error_handling();
      }
      setState(2084);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::IGNORE_P) {
        setState(2083);
        skip_external_partition();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2086);
      match(GreenPlumParser::COPY);
      setState(2087);
      select_with_parens();
      setState(2088);
      match(GreenPlumParser::TO);
      setState(2090);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PROGRAM) {
        setState(2089);
        match(GreenPlumParser::PROGRAM);
      }
      setState(2092);
      copy_file_name();
      setState(2094);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::WITH) {
        setState(2093);
        opt_with();
      }
      setState(2099);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GreenPlumParser::BINARY || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & ((1ULL << (GreenPlumParser::CSV - 79))
        | (1ULL << (GreenPlumParser::DELIMITER - 79))
        | (1ULL << (GreenPlumParser::ESCAPE - 79)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 146)) & ((1ULL << (GreenPlumParser::FILL - 146))
        | (1ULL << (GreenPlumParser::FORCE - 146))
        | (1ULL << (GreenPlumParser::HEADER_P - 146)))) != 0) || ((((_la - 268) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 268)) & ((1ULL << (GreenPlumParser::NULL_P - 268))
        | (1ULL << (GreenPlumParser::OIDS - 268))
        | (1ULL << (GreenPlumParser::ON - 268))
        | (1ULL << (GreenPlumParser::QUOTE - 268)))) != 0)) {
        setState(2096);
        copy_opt_item();
        setState(2101);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_fromContext ------------------------------------------------------------------

GreenPlumParser::Copy_fromContext::Copy_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Copy_fromContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_fromContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}


size_t GreenPlumParser::Copy_fromContext::getRuleIndex() const {
  return GreenPlumParser::RuleCopy_from;
}

void GreenPlumParser::Copy_fromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_from(this);
}

void GreenPlumParser::Copy_fromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_from(this);
}


antlrcpp::Any GreenPlumParser::Copy_fromContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCopy_from(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Copy_fromContext* GreenPlumParser::copy_from() {
  Copy_fromContext *_localctx = _tracker.createInstance<Copy_fromContext>(_ctx, getState());
  enterRule(_localctx, 148, GreenPlumParser::RuleCopy_from);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2104);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::FROM || _la == GreenPlumParser::TO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Skip_external_partitionContext ------------------------------------------------------------------

GreenPlumParser::Skip_external_partitionContext::Skip_external_partitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Skip_external_partitionContext::IGNORE_P() {
  return getToken(GreenPlumParser::IGNORE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Skip_external_partitionContext::EXTERNAL() {
  return getToken(GreenPlumParser::EXTERNAL, 0);
}

tree::TerminalNode* GreenPlumParser::Skip_external_partitionContext::PARTITIONS() {
  return getToken(GreenPlumParser::PARTITIONS, 0);
}


size_t GreenPlumParser::Skip_external_partitionContext::getRuleIndex() const {
  return GreenPlumParser::RuleSkip_external_partition;
}

void GreenPlumParser::Skip_external_partitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSkip_external_partition(this);
}

void GreenPlumParser::Skip_external_partitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSkip_external_partition(this);
}


antlrcpp::Any GreenPlumParser::Skip_external_partitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSkip_external_partition(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Skip_external_partitionContext* GreenPlumParser::skip_external_partition() {
  Skip_external_partitionContext *_localctx = _tracker.createInstance<Skip_external_partitionContext>(_ctx, getState());
  enterRule(_localctx, 150, GreenPlumParser::RuleSkip_external_partition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2106);
    match(GreenPlumParser::IGNORE_P);
    setState(2107);
    match(GreenPlumParser::EXTERNAL);
    setState(2108);
    match(GreenPlumParser::PARTITIONS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_file_nameContext ------------------------------------------------------------------

GreenPlumParser::Copy_file_nameContext::Copy_file_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::SconstContext* GreenPlumParser::Copy_file_nameContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Copy_file_nameContext::STDIN() {
  return getToken(GreenPlumParser::STDIN, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_file_nameContext::STDOUT() {
  return getToken(GreenPlumParser::STDOUT, 0);
}


size_t GreenPlumParser::Copy_file_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleCopy_file_name;
}

void GreenPlumParser::Copy_file_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_file_name(this);
}

void GreenPlumParser::Copy_file_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_file_name(this);
}


antlrcpp::Any GreenPlumParser::Copy_file_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCopy_file_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Copy_file_nameContext* GreenPlumParser::copy_file_name() {
  Copy_file_nameContext *_localctx = _tracker.createInstance<Copy_file_nameContext>(_ctx, getState());
  enterRule(_localctx, 152, GreenPlumParser::RuleCopy_file_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2113);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(2110);
        sconst();
        break;
      }

      case GreenPlumParser::STDIN: {
        enterOuterAlt(_localctx, 2);
        setState(2111);
        match(GreenPlumParser::STDIN);
        break;
      }

      case GreenPlumParser::STDOUT: {
        enterOuterAlt(_localctx, 3);
        setState(2112);
        match(GreenPlumParser::STDOUT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Copy_opt_itemContext::Copy_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::BINARY() {
  return getToken(GreenPlumParser::BINARY, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::OIDS() {
  return getToken(GreenPlumParser::OIDS, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Copy_opt_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::DELIMITER() {
  return getToken(GreenPlumParser::DELIMITER, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::QUOTE() {
  return getToken(GreenPlumParser::QUOTE, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::ESCAPE() {
  return getToken(GreenPlumParser::ESCAPE, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::CSV() {
  return getToken(GreenPlumParser::CSV, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::HEADER_P() {
  return getToken(GreenPlumParser::HEADER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::FORCE() {
  return getToken(GreenPlumParser::FORCE, 0);
}

GreenPlumParser::Column_listContext* GreenPlumParser::Copy_opt_itemContext::column_list() {
  return getRuleContext<GreenPlumParser::Column_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::FILL() {
  return getToken(GreenPlumParser::FILL, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::MISSING() {
  return getToken(GreenPlumParser::MISSING, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::FIELDS() {
  return getToken(GreenPlumParser::FIELDS, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Copy_opt_itemContext::SEGMENT() {
  return getToken(GreenPlumParser::SEGMENT, 0);
}


size_t GreenPlumParser::Copy_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleCopy_opt_item;
}

void GreenPlumParser::Copy_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_opt_item(this);
}

void GreenPlumParser::Copy_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Copy_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCopy_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Copy_opt_itemContext* GreenPlumParser::copy_opt_item() {
  Copy_opt_itemContext *_localctx = _tracker.createInstance<Copy_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 154, GreenPlumParser::RuleCopy_opt_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2136);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2115);
      match(GreenPlumParser::BINARY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2116);
      match(GreenPlumParser::OIDS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2117);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::DELIMITER

      || _la == GreenPlumParser::ESCAPE || _la == GreenPlumParser::NULL_P

      || _la == GreenPlumParser::QUOTE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2119);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::AS) {
        setState(2118);
        match(GreenPlumParser::AS);
      }
      setState(2121);
      sconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2122);
      match(GreenPlumParser::CSV);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2123);
      match(GreenPlumParser::HEADER_P);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2124);
      match(GreenPlumParser::FORCE);
      setState(2125);
      match(GreenPlumParser::QUOTE);
      setState(2126);
      column_list();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2127);
      match(GreenPlumParser::FORCE);
      setState(2128);
      match(GreenPlumParser::NOT);
      setState(2129);
      match(GreenPlumParser::NULL_P);
      setState(2130);
      column_list();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2131);
      match(GreenPlumParser::FILL);
      setState(2132);
      match(GreenPlumParser::MISSING);
      setState(2133);
      match(GreenPlumParser::FIELDS);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2134);
      match(GreenPlumParser::ON);
      setState(2135);
      match(GreenPlumParser::SEGMENT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_oidsContext ------------------------------------------------------------------

GreenPlumParser::Opt_oidsContext::Opt_oidsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_oidsContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_oidsContext::OIDS() {
  return getToken(GreenPlumParser::OIDS, 0);
}


size_t GreenPlumParser::Opt_oidsContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_oids;
}

void GreenPlumParser::Opt_oidsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_oids(this);
}

void GreenPlumParser::Opt_oidsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_oids(this);
}


antlrcpp::Any GreenPlumParser::Opt_oidsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_oids(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_oidsContext* GreenPlumParser::opt_oids() {
  Opt_oidsContext *_localctx = _tracker.createInstance<Opt_oidsContext>(_ctx, getState());
  enterRule(_localctx, 156, GreenPlumParser::RuleOpt_oids);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2138);
    match(GreenPlumParser::WITH);
    setState(2139);
    match(GreenPlumParser::OIDS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_delimiterContext ------------------------------------------------------------------

GreenPlumParser::Copy_delimiterContext::Copy_delimiterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Copy_delimiterContext::DELIMITERS() {
  return getToken(GreenPlumParser::DELIMITERS, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Copy_delimiterContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Copy_delimiterContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}


size_t GreenPlumParser::Copy_delimiterContext::getRuleIndex() const {
  return GreenPlumParser::RuleCopy_delimiter;
}

void GreenPlumParser::Copy_delimiterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_delimiter(this);
}

void GreenPlumParser::Copy_delimiterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_delimiter(this);
}


antlrcpp::Any GreenPlumParser::Copy_delimiterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCopy_delimiter(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Copy_delimiterContext* GreenPlumParser::copy_delimiter() {
  Copy_delimiterContext *_localctx = _tracker.createInstance<Copy_delimiterContext>(_ctx, getState());
  enterRule(_localctx, 158, GreenPlumParser::RuleCopy_delimiter);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2142);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::USING) {
      setState(2141);
      match(GreenPlumParser::USING);
    }
    setState(2144);
    match(GreenPlumParser::DELIMITERS);
    setState(2145);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_stmtContext::Create_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Create_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Create_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Opt_tempContext* GreenPlumParser::Create_stmtContext::opt_temp() {
  return getRuleContext<GreenPlumParser::Opt_tempContext>(0);
}

GreenPlumParser::Table_element_listContext* GreenPlumParser::Create_stmtContext::table_element_list() {
  return getRuleContext<GreenPlumParser::Table_element_listContext>(0);
}

GreenPlumParser::Opt_inheritContext* GreenPlumParser::Create_stmtContext::opt_inherit() {
  return getRuleContext<GreenPlumParser::Opt_inheritContext>(0);
}

GreenPlumParser::Opt_with_def_oidsContext* GreenPlumParser::Create_stmtContext::opt_with_def_oids() {
  return getRuleContext<GreenPlumParser::Opt_with_def_oidsContext>(0);
}

GreenPlumParser::On_commit_optionContext* GreenPlumParser::Create_stmtContext::on_commit_option() {
  return getRuleContext<GreenPlumParser::On_commit_optionContext>(0);
}

GreenPlumParser::Opt_table_spaceContext* GreenPlumParser::Create_stmtContext::opt_table_space() {
  return getRuleContext<GreenPlumParser::Opt_table_spaceContext>(0);
}

GreenPlumParser::Opt_distributed_byContext* GreenPlumParser::Create_stmtContext::opt_distributed_by() {
  return getRuleContext<GreenPlumParser::Opt_distributed_byContext>(0);
}

GreenPlumParser::Opt_tab_partition_byContext* GreenPlumParser::Create_stmtContext::opt_tab_partition_by() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_byContext>(0);
}


size_t GreenPlumParser::Create_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_stmt;
}

void GreenPlumParser::Create_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_stmt(this);
}

void GreenPlumParser::Create_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_stmtContext* GreenPlumParser::create_stmt() {
  Create_stmtContext *_localctx = _tracker.createInstance<Create_stmtContext>(_ctx, getState());
  enterRule(_localctx, 160, GreenPlumParser::RuleCreate_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2147);
    match(GreenPlumParser::CREATE);
    setState(2149);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GLOBAL

    || _la == GreenPlumParser::LOCAL || _la == GreenPlumParser::TEMP

    || _la == GreenPlumParser::TEMPORARY) {
      setState(2148);
      opt_temp();
    }
    setState(2151);
    match(GreenPlumParser::TABLE);
    setState(2152);
    qualified_name();
    setState(2153);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2155);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECK)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COLUMN)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION)
      | (1ULL << GreenPlumParser::CONSTRAINT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULT - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FOREIGN - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIKE - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIMARY - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNIQUE - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
      setState(2154);
      table_element_list();
    }
    setState(2157);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(2159);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::INHERITS) {
      setState(2158);
      opt_inherit();
    }
    setState(2162);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT) {
      setState(2161);
      opt_with_def_oids();
    }
    setState(2165);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ON) {
      setState(2164);
      on_commit_option();
    }
    setState(2168);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TABLESPACE) {
      setState(2167);
      opt_table_space();
    }
    setState(2171);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DISTRIBUTED) {
      setState(2170);
      opt_distributed_by();
    }
    setState(2174);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PARTITION) {
      setState(2173);
      opt_tab_partition_by();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tempContext ------------------------------------------------------------------

GreenPlumParser::Opt_tempContext::Opt_tempContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_tempContext::TEMPORARY() {
  return getToken(GreenPlumParser::TEMPORARY, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempContext::TEMP() {
  return getToken(GreenPlumParser::TEMP, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempContext::LOCAL() {
  return getToken(GreenPlumParser::LOCAL, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempContext::GLOBAL() {
  return getToken(GreenPlumParser::GLOBAL, 0);
}


size_t GreenPlumParser::Opt_tempContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_temp;
}

void GreenPlumParser::Opt_tempContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_temp(this);
}

void GreenPlumParser::Opt_tempContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_temp(this);
}


antlrcpp::Any GreenPlumParser::Opt_tempContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_temp(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tempContext* GreenPlumParser::opt_temp() {
  Opt_tempContext *_localctx = _tracker.createInstance<Opt_tempContext>(_ctx, getState());
  enterRule(_localctx, 162, GreenPlumParser::RuleOpt_temp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2177);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GLOBAL

    || _la == GreenPlumParser::LOCAL) {
      setState(2176);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::GLOBAL

      || _la == GreenPlumParser::LOCAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2179);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::TEMP

    || _la == GreenPlumParser::TEMPORARY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_element_listContext ------------------------------------------------------------------

GreenPlumParser::Table_element_listContext::Table_element_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Table_elementContext *> GreenPlumParser::Table_element_listContext::table_element() {
  return getRuleContexts<GreenPlumParser::Table_elementContext>();
}

GreenPlumParser::Table_elementContext* GreenPlumParser::Table_element_listContext::table_element(size_t i) {
  return getRuleContext<GreenPlumParser::Table_elementContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Table_element_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Table_element_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Table_element_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_element_list;
}

void GreenPlumParser::Table_element_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_element_list(this);
}

void GreenPlumParser::Table_element_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_element_list(this);
}


antlrcpp::Any GreenPlumParser::Table_element_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_element_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_element_listContext* GreenPlumParser::table_element_list() {
  Table_element_listContext *_localctx = _tracker.createInstance<Table_element_listContext>(_ctx, getState());
  enterRule(_localctx, 164, GreenPlumParser::RuleTable_element_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2181);
    table_element();
    setState(2186);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2182);
      match(GreenPlumParser::COMMA);
      setState(2183);
      table_element();
      setState(2188);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_elementContext ------------------------------------------------------------------

GreenPlumParser::Table_elementContext::Table_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Column_defContext* GreenPlumParser::Table_elementContext::column_def() {
  return getRuleContext<GreenPlumParser::Column_defContext>(0);
}

GreenPlumParser::Table_like_clauseContext* GreenPlumParser::Table_elementContext::table_like_clause() {
  return getRuleContext<GreenPlumParser::Table_like_clauseContext>(0);
}

GreenPlumParser::Table_constraintContext* GreenPlumParser::Table_elementContext::table_constraint() {
  return getRuleContext<GreenPlumParser::Table_constraintContext>(0);
}

GreenPlumParser::Column_reference_storage_directiveContext* GreenPlumParser::Table_elementContext::column_reference_storage_directive() {
  return getRuleContext<GreenPlumParser::Column_reference_storage_directiveContext>(0);
}


size_t GreenPlumParser::Table_elementContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_element;
}

void GreenPlumParser::Table_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_element(this);
}

void GreenPlumParser::Table_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_element(this);
}


antlrcpp::Any GreenPlumParser::Table_elementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_element(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_elementContext* GreenPlumParser::table_element() {
  Table_elementContext *_localctx = _tracker.createInstance<Table_elementContext>(_ctx, getState());
  enterRule(_localctx, 166, GreenPlumParser::RuleTable_element);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2193);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(2189);
        column_def();
        break;
      }

      case GreenPlumParser::LIKE: {
        enterOuterAlt(_localctx, 2);
        setState(2190);
        table_like_clause();
        break;
      }

      case GreenPlumParser::CHECK:
      case GreenPlumParser::CONSTRAINT:
      case GreenPlumParser::FOREIGN:
      case GreenPlumParser::PRIMARY:
      case GreenPlumParser::UNIQUE: {
        enterOuterAlt(_localctx, 3);
        setState(2191);
        table_constraint();
        break;
      }

      case GreenPlumParser::COLUMN:
      case GreenPlumParser::DEFAULT: {
        enterOuterAlt(_localctx, 4);
        setState(2192);
        column_reference_storage_directive();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_reference_storage_directiveContext ------------------------------------------------------------------

GreenPlumParser::Column_reference_storage_directiveContext::Column_reference_storage_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Column_reference_storage_directiveContext::COLUMN() {
  return getToken(GreenPlumParser::COLUMN, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Column_reference_storage_directiveContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Column_reference_storage_directiveContext::ENCODING() {
  return getToken(GreenPlumParser::ENCODING, 0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Column_reference_storage_directiveContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Column_reference_storage_directiveContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Column_reference_storage_directiveContext::getRuleIndex() const {
  return GreenPlumParser::RuleColumn_reference_storage_directive;
}

void GreenPlumParser::Column_reference_storage_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_reference_storage_directive(this);
}

void GreenPlumParser::Column_reference_storage_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_reference_storage_directive(this);
}


antlrcpp::Any GreenPlumParser::Column_reference_storage_directiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitColumn_reference_storage_directive(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Column_reference_storage_directiveContext* GreenPlumParser::column_reference_storage_directive() {
  Column_reference_storage_directiveContext *_localctx = _tracker.createInstance<Column_reference_storage_directiveContext>(_ctx, getState());
  enterRule(_localctx, 168, GreenPlumParser::RuleColumn_reference_storage_directive);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2204);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::COLUMN: {
        enterOuterAlt(_localctx, 1);
        setState(2195);
        match(GreenPlumParser::COLUMN);
        setState(2196);
        colid();
        setState(2197);
        match(GreenPlumParser::ENCODING);
        setState(2198);
        definition();
        break;
      }

      case GreenPlumParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(2200);
        match(GreenPlumParser::DEFAULT);
        setState(2201);
        match(GreenPlumParser::COLUMN);
        setState(2202);
        match(GreenPlumParser::ENCODING);
        setState(2203);
        definition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_defContext ------------------------------------------------------------------

GreenPlumParser::Column_defContext::Column_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Column_defContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Column_defContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

std::vector<GreenPlumParser::Col_constraintContext *> GreenPlumParser::Column_defContext::col_constraint() {
  return getRuleContexts<GreenPlumParser::Col_constraintContext>();
}

GreenPlumParser::Col_constraintContext* GreenPlumParser::Column_defContext::col_constraint(size_t i) {
  return getRuleContext<GreenPlumParser::Col_constraintContext>(i);
}

GreenPlumParser::Opt_storage_encodingContext* GreenPlumParser::Column_defContext::opt_storage_encoding() {
  return getRuleContext<GreenPlumParser::Opt_storage_encodingContext>(0);
}


size_t GreenPlumParser::Column_defContext::getRuleIndex() const {
  return GreenPlumParser::RuleColumn_def;
}

void GreenPlumParser::Column_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def(this);
}

void GreenPlumParser::Column_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def(this);
}


antlrcpp::Any GreenPlumParser::Column_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitColumn_def(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Column_defContext* GreenPlumParser::column_def() {
  Column_defContext *_localctx = _tracker.createInstance<Column_defContext>(_ctx, getState());
  enterRule(_localctx, 170, GreenPlumParser::RuleColumn_def);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2206);
    colid();
    setState(2207);
    typename_pg();
    setState(2211);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 46) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 46)) & ((1ULL << (GreenPlumParser::CHECK - 46))
      | (1ULL << (GreenPlumParser::CONSTRAINT - 46))
      | (1ULL << (GreenPlumParser::DEFAULT - 46))
      | (1ULL << (GreenPlumParser::DEFERRABLE - 46)))) != 0) || _la == GreenPlumParser::INITIALLY || ((((_la - 262) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 262)) & ((1ULL << (GreenPlumParser::NOT - 262))
      | (1ULL << (GreenPlumParser::NULL_P - 262))
      | (1ULL << (GreenPlumParser::PRIMARY - 262)))) != 0) || _la == GreenPlumParser::REFERENCES || _la == GreenPlumParser::UNIQUE) {
      setState(2208);
      col_constraint();
      setState(2213);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2215);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ENCODING) {
      setState(2214);
      opt_storage_encoding();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Col_constraintContext ------------------------------------------------------------------

GreenPlumParser::Col_constraintContext::Col_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Col_constraintContext::CONSTRAINT() {
  return getToken(GreenPlumParser::CONSTRAINT, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Col_constraintContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::Col_constraint_elemContext* GreenPlumParser::Col_constraintContext::col_constraint_elem() {
  return getRuleContext<GreenPlumParser::Col_constraint_elemContext>(0);
}

GreenPlumParser::Constraint_attrContext* GreenPlumParser::Col_constraintContext::constraint_attr() {
  return getRuleContext<GreenPlumParser::Constraint_attrContext>(0);
}


size_t GreenPlumParser::Col_constraintContext::getRuleIndex() const {
  return GreenPlumParser::RuleCol_constraint;
}

void GreenPlumParser::Col_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCol_constraint(this);
}

void GreenPlumParser::Col_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCol_constraint(this);
}


antlrcpp::Any GreenPlumParser::Col_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCol_constraint(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Col_constraintContext* GreenPlumParser::col_constraint() {
  Col_constraintContext *_localctx = _tracker.createInstance<Col_constraintContext>(_ctx, getState());
  enterRule(_localctx, 172, GreenPlumParser::RuleCol_constraint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2223);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2217);
      match(GreenPlumParser::CONSTRAINT);
      setState(2218);
      name();
      setState(2219);
      col_constraint_elem();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2221);
      col_constraint_elem();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2222);
      constraint_attr();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_storage_encodingContext ------------------------------------------------------------------

GreenPlumParser::Opt_storage_encodingContext::Opt_storage_encodingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_storage_encodingContext::ENCODING() {
  return getToken(GreenPlumParser::ENCODING, 0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Opt_storage_encodingContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}


size_t GreenPlumParser::Opt_storage_encodingContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_storage_encoding;
}

void GreenPlumParser::Opt_storage_encodingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_storage_encoding(this);
}

void GreenPlumParser::Opt_storage_encodingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_storage_encoding(this);
}


antlrcpp::Any GreenPlumParser::Opt_storage_encodingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_storage_encoding(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_storage_encodingContext* GreenPlumParser::opt_storage_encoding() {
  Opt_storage_encodingContext *_localctx = _tracker.createInstance<Opt_storage_encodingContext>(_ctx, getState());
  enterRule(_localctx, 174, GreenPlumParser::RuleOpt_storage_encoding);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2225);
    match(GreenPlumParser::ENCODING);
    setState(2226);
    definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Col_constraint_elemContext ------------------------------------------------------------------

GreenPlumParser::Col_constraint_elemContext::Col_constraint_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::UNIQUE() {
  return getToken(GreenPlumParser::UNIQUE, 0);
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::Col_constraint_elemContext::with_out_definition() {
  return getRuleContext<GreenPlumParser::With_out_definitionContext>(0);
}

GreenPlumParser::Constraint_table_spaceContext* GreenPlumParser::Col_constraint_elemContext::constraint_table_space() {
  return getRuleContext<GreenPlumParser::Constraint_table_spaceContext>(0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::PRIMARY() {
  return getToken(GreenPlumParser::PRIMARY, 0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::KEY() {
  return getToken(GreenPlumParser::KEY, 0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::CHECK() {
  return getToken(GreenPlumParser::CHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Col_constraint_elemContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_constraint_elemContext::REFERENCES() {
  return getToken(GreenPlumParser::REFERENCES, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Col_constraint_elemContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Col_constraint_elemContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}

GreenPlumParser::Key_matchContext* GreenPlumParser::Col_constraint_elemContext::key_match() {
  return getRuleContext<GreenPlumParser::Key_matchContext>(0);
}

GreenPlumParser::Key_actionsContext* GreenPlumParser::Col_constraint_elemContext::key_actions() {
  return getRuleContext<GreenPlumParser::Key_actionsContext>(0);
}


size_t GreenPlumParser::Col_constraint_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleCol_constraint_elem;
}

void GreenPlumParser::Col_constraint_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCol_constraint_elem(this);
}

void GreenPlumParser::Col_constraint_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCol_constraint_elem(this);
}


antlrcpp::Any GreenPlumParser::Col_constraint_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCol_constraint_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Col_constraint_elemContext* GreenPlumParser::col_constraint_elem() {
  Col_constraint_elemContext *_localctx = _tracker.createInstance<Col_constraint_elemContext>(_ctx, getState());
  enterRule(_localctx, 176, GreenPlumParser::RuleCol_constraint_elem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2264);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(2228);
        match(GreenPlumParser::NOT);
        setState(2229);
        match(GreenPlumParser::NULL_P);
        break;
      }

      case GreenPlumParser::NULL_P: {
        enterOuterAlt(_localctx, 2);
        setState(2230);
        match(GreenPlumParser::NULL_P);
        break;
      }

      case GreenPlumParser::UNIQUE: {
        enterOuterAlt(_localctx, 3);
        setState(2231);
        match(GreenPlumParser::UNIQUE);
        setState(2233);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::WITH

        || _la == GreenPlumParser::WITHOUT) {
          setState(2232);
          with_out_definition();
        }
        setState(2236);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::USING) {
          setState(2235);
          constraint_table_space();
        }
        break;
      }

      case GreenPlumParser::PRIMARY: {
        enterOuterAlt(_localctx, 4);
        setState(2238);
        match(GreenPlumParser::PRIMARY);
        setState(2239);
        match(GreenPlumParser::KEY);
        setState(2241);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::WITH

        || _la == GreenPlumParser::WITHOUT) {
          setState(2240);
          with_out_definition();
        }
        setState(2244);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::USING) {
          setState(2243);
          constraint_table_space();
        }
        break;
      }

      case GreenPlumParser::CHECK: {
        enterOuterAlt(_localctx, 5);
        setState(2246);
        match(GreenPlumParser::CHECK);
        setState(2247);
        match(GreenPlumParser::LEFT_PAREN);
        setState(2248);
        a_expr();
        setState(2249);
        match(GreenPlumParser::RIGHT_PAREN);
        break;
      }

      case GreenPlumParser::DEFAULT: {
        enterOuterAlt(_localctx, 6);
        setState(2251);
        match(GreenPlumParser::DEFAULT);
        setState(2252);
        a_expr();
        break;
      }

      case GreenPlumParser::REFERENCES: {
        enterOuterAlt(_localctx, 7);
        setState(2253);
        match(GreenPlumParser::REFERENCES);
        setState(2254);
        qualified_name();
        setState(2256);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::LEFT_PAREN) {
          setState(2255);
          paren_column_list();
        }
        setState(2259);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::MATCH) {
          setState(2258);
          key_match();
        }
        setState(2262);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::ON) {
          setState(2261);
          key_actions();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_attrContext ------------------------------------------------------------------

GreenPlumParser::Constraint_attrContext::Constraint_attrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraint_attrContext::DEFERRABLE() {
  return getToken(GreenPlumParser::DEFERRABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_attrContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_attrContext::INITIALLY() {
  return getToken(GreenPlumParser::INITIALLY, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_attrContext::DEFERRED() {
  return getToken(GreenPlumParser::DEFERRED, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_attrContext::IMMEDIATE() {
  return getToken(GreenPlumParser::IMMEDIATE, 0);
}


size_t GreenPlumParser::Constraint_attrContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraint_attr;
}

void GreenPlumParser::Constraint_attrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_attr(this);
}

void GreenPlumParser::Constraint_attrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_attr(this);
}


antlrcpp::Any GreenPlumParser::Constraint_attrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraint_attr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraint_attrContext* GreenPlumParser::constraint_attr() {
  Constraint_attrContext *_localctx = _tracker.createInstance<Constraint_attrContext>(_ctx, getState());
  enterRule(_localctx, 178, GreenPlumParser::RuleConstraint_attr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2272);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::DEFERRABLE:
      case GreenPlumParser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(2267);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::NOT) {
          setState(2266);
          match(GreenPlumParser::NOT);
        }
        setState(2269);
        match(GreenPlumParser::DEFERRABLE);
        break;
      }

      case GreenPlumParser::INITIALLY: {
        enterOuterAlt(_localctx, 2);
        setState(2270);
        match(GreenPlumParser::INITIALLY);
        setState(2271);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::DEFERRED || _la == GreenPlumParser::IMMEDIATE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_like_clauseContext ------------------------------------------------------------------

GreenPlumParser::Table_like_clauseContext::Table_like_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Table_like_clauseContext::LIKE() {
  return getToken(GreenPlumParser::LIKE, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Table_like_clauseContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

std::vector<GreenPlumParser::Table_list_optionContext *> GreenPlumParser::Table_like_clauseContext::table_list_option() {
  return getRuleContexts<GreenPlumParser::Table_list_optionContext>();
}

GreenPlumParser::Table_list_optionContext* GreenPlumParser::Table_like_clauseContext::table_list_option(size_t i) {
  return getRuleContext<GreenPlumParser::Table_list_optionContext>(i);
}


size_t GreenPlumParser::Table_like_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_like_clause;
}

void GreenPlumParser::Table_like_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_like_clause(this);
}

void GreenPlumParser::Table_like_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_like_clause(this);
}


antlrcpp::Any GreenPlumParser::Table_like_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_like_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_like_clauseContext* GreenPlumParser::table_like_clause() {
  Table_like_clauseContext *_localctx = _tracker.createInstance<Table_like_clauseContext>(_ctx, getState());
  enterRule(_localctx, 180, GreenPlumParser::RuleTable_like_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2274);
    match(GreenPlumParser::LIKE);
    setState(2275);
    qualified_name();
    setState(2279);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::EXCLUDING

    || _la == GreenPlumParser::INCLUDING) {
      setState(2276);
      table_list_option();
      setState(2281);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_list_optionContext ------------------------------------------------------------------

GreenPlumParser::Table_list_optionContext::Table_list_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Table_list_optionContext::DEFAULTS() {
  return getToken(GreenPlumParser::DEFAULTS, 0);
}

tree::TerminalNode* GreenPlumParser::Table_list_optionContext::INCLUDING() {
  return getToken(GreenPlumParser::INCLUDING, 0);
}

tree::TerminalNode* GreenPlumParser::Table_list_optionContext::EXCLUDING() {
  return getToken(GreenPlumParser::EXCLUDING, 0);
}

tree::TerminalNode* GreenPlumParser::Table_list_optionContext::CONSTRAINTS() {
  return getToken(GreenPlumParser::CONSTRAINTS, 0);
}

tree::TerminalNode* GreenPlumParser::Table_list_optionContext::INDEXES() {
  return getToken(GreenPlumParser::INDEXES, 0);
}


size_t GreenPlumParser::Table_list_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_list_option;
}

void GreenPlumParser::Table_list_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_list_option(this);
}

void GreenPlumParser::Table_list_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_list_option(this);
}


antlrcpp::Any GreenPlumParser::Table_list_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_list_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_list_optionContext* GreenPlumParser::table_list_option() {
  Table_list_optionContext *_localctx = _tracker.createInstance<Table_list_optionContext>(_ctx, getState());
  enterRule(_localctx, 182, GreenPlumParser::RuleTable_list_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2288);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2282);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::EXCLUDING

      || _la == GreenPlumParser::INCLUDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2283);
      match(GreenPlumParser::DEFAULTS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2284);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::EXCLUDING

      || _la == GreenPlumParser::INCLUDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2285);
      match(GreenPlumParser::CONSTRAINTS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2286);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::EXCLUDING

      || _la == GreenPlumParser::INCLUDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2287);
      match(GreenPlumParser::INDEXES);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

GreenPlumParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Constraint_elemContext* GreenPlumParser::Table_constraintContext::constraint_elem() {
  return getRuleContext<GreenPlumParser::Constraint_elemContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_constraintContext::CONSTRAINT() {
  return getToken(GreenPlumParser::CONSTRAINT, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Table_constraintContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Table_constraintContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_constraint;
}

void GreenPlumParser::Table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_constraint(this);
}

void GreenPlumParser::Table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_constraint(this);
}


antlrcpp::Any GreenPlumParser::Table_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_constraint(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_constraintContext* GreenPlumParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 184, GreenPlumParser::RuleTable_constraint);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2292);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CONSTRAINT) {
      setState(2290);
      match(GreenPlumParser::CONSTRAINT);
      setState(2291);
      name();
    }
    setState(2294);
    constraint_elem();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_elemContext ------------------------------------------------------------------

GreenPlumParser::Constraint_elemContext::Constraint_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::CHECK() {
  return getToken(GreenPlumParser::CHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Constraint_elemContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

std::vector<GreenPlumParser::Paren_column_listContext *> GreenPlumParser::Constraint_elemContext::paren_column_list() {
  return getRuleContexts<GreenPlumParser::Paren_column_listContext>();
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Constraint_elemContext::paren_column_list(size_t i) {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(i);
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::UNIQUE() {
  return getToken(GreenPlumParser::UNIQUE, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::PRIMARY() {
  return getToken(GreenPlumParser::PRIMARY, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::KEY() {
  return getToken(GreenPlumParser::KEY, 0);
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::Constraint_elemContext::with_out_definition() {
  return getRuleContext<GreenPlumParser::With_out_definitionContext>(0);
}

GreenPlumParser::Constraint_table_spaceContext* GreenPlumParser::Constraint_elemContext::constraint_table_space() {
  return getRuleContext<GreenPlumParser::Constraint_table_spaceContext>(0);
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::FOREIGN() {
  return getToken(GreenPlumParser::FOREIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_elemContext::REFERENCES() {
  return getToken(GreenPlumParser::REFERENCES, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Constraint_elemContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Key_matchContext* GreenPlumParser::Constraint_elemContext::key_match() {
  return getRuleContext<GreenPlumParser::Key_matchContext>(0);
}

GreenPlumParser::Key_actionsContext* GreenPlumParser::Constraint_elemContext::key_actions() {
  return getRuleContext<GreenPlumParser::Key_actionsContext>(0);
}

GreenPlumParser::Constraint_attr_specContext* GreenPlumParser::Constraint_elemContext::constraint_attr_spec() {
  return getRuleContext<GreenPlumParser::Constraint_attr_specContext>(0);
}


size_t GreenPlumParser::Constraint_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraint_elem;
}

void GreenPlumParser::Constraint_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_elem(this);
}

void GreenPlumParser::Constraint_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_elem(this);
}


antlrcpp::Any GreenPlumParser::Constraint_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraint_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraint_elemContext* GreenPlumParser::constraint_elem() {
  Constraint_elemContext *_localctx = _tracker.createInstance<Constraint_elemContext>(_ctx, getState());
  enterRule(_localctx, 186, GreenPlumParser::RuleConstraint_elem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2330);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHECK: {
        enterOuterAlt(_localctx, 1);
        setState(2296);
        match(GreenPlumParser::CHECK);
        setState(2297);
        match(GreenPlumParser::LEFT_PAREN);
        setState(2298);
        a_expr();
        setState(2299);
        match(GreenPlumParser::RIGHT_PAREN);
        break;
      }

      case GreenPlumParser::PRIMARY:
      case GreenPlumParser::UNIQUE: {
        enterOuterAlt(_localctx, 2);
        setState(2304);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::UNIQUE: {
            setState(2301);
            match(GreenPlumParser::UNIQUE);
            break;
          }

          case GreenPlumParser::PRIMARY: {
            setState(2302);
            match(GreenPlumParser::PRIMARY);
            setState(2303);
            match(GreenPlumParser::KEY);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2306);
        paren_column_list();
        setState(2308);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::WITH

        || _la == GreenPlumParser::WITHOUT) {
          setState(2307);
          with_out_definition();
        }
        setState(2311);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::USING) {
          setState(2310);
          constraint_table_space();
        }
        break;
      }

      case GreenPlumParser::FOREIGN: {
        enterOuterAlt(_localctx, 3);
        setState(2313);
        match(GreenPlumParser::FOREIGN);
        setState(2314);
        match(GreenPlumParser::KEY);
        setState(2315);
        paren_column_list();
        setState(2316);
        match(GreenPlumParser::REFERENCES);
        setState(2317);
        qualified_name();
        setState(2319);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::LEFT_PAREN) {
          setState(2318);
          paren_column_list();
        }
        setState(2322);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::MATCH) {
          setState(2321);
          key_match();
        }
        setState(2325);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::ON) {
          setState(2324);
          key_actions();
        }
        setState(2328);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::DEFERRABLE || _la == GreenPlumParser::INITIALLY || _la == GreenPlumParser::NOT) {
          setState(2327);
          constraint_attr_spec();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Paren_columnContext ------------------------------------------------------------------

GreenPlumParser::Paren_columnContext::Paren_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Paren_columnContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Column_elemContext* GreenPlumParser::Paren_columnContext::column_elem() {
  return getRuleContext<GreenPlumParser::Column_elemContext>(0);
}

tree::TerminalNode* GreenPlumParser::Paren_columnContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Paren_columnContext::getRuleIndex() const {
  return GreenPlumParser::RuleParen_column;
}

void GreenPlumParser::Paren_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParen_column(this);
}

void GreenPlumParser::Paren_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParen_column(this);
}


antlrcpp::Any GreenPlumParser::Paren_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParen_column(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Paren_columnContext* GreenPlumParser::paren_column() {
  Paren_columnContext *_localctx = _tracker.createInstance<Paren_columnContext>(_ctx, getState());
  enterRule(_localctx, 188, GreenPlumParser::RuleParen_column);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2332);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2333);
    column_elem();
    setState(2334);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Paren_column_listContext ------------------------------------------------------------------

GreenPlumParser::Paren_column_listContext::Paren_column_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Paren_column_listContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Column_listContext* GreenPlumParser::Paren_column_listContext::column_list() {
  return getRuleContext<GreenPlumParser::Column_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Paren_column_listContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Paren_column_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleParen_column_list;
}

void GreenPlumParser::Paren_column_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParen_column_list(this);
}

void GreenPlumParser::Paren_column_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParen_column_list(this);
}


antlrcpp::Any GreenPlumParser::Paren_column_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParen_column_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::paren_column_list() {
  Paren_column_listContext *_localctx = _tracker.createInstance<Paren_column_listContext>(_ctx, getState());
  enterRule(_localctx, 190, GreenPlumParser::RuleParen_column_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2336);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2337);
    column_list();
    setState(2338);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_listContext ------------------------------------------------------------------

GreenPlumParser::Column_listContext::Column_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Column_elemContext *> GreenPlumParser::Column_listContext::column_elem() {
  return getRuleContexts<GreenPlumParser::Column_elemContext>();
}

GreenPlumParser::Column_elemContext* GreenPlumParser::Column_listContext::column_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Column_elemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Column_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Column_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Column_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleColumn_list;
}

void GreenPlumParser::Column_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_list(this);
}

void GreenPlumParser::Column_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_list(this);
}


antlrcpp::Any GreenPlumParser::Column_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitColumn_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Column_listContext* GreenPlumParser::column_list() {
  Column_listContext *_localctx = _tracker.createInstance<Column_listContext>(_ctx, getState());
  enterRule(_localctx, 192, GreenPlumParser::RuleColumn_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2340);
    column_elem();
    setState(2345);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2341);
      match(GreenPlumParser::COMMA);
      setState(2342);
      column_elem();
      setState(2347);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_elemContext ------------------------------------------------------------------

GreenPlumParser::Column_elemContext::Column_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Column_elemContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Column_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleColumn_elem;
}

void GreenPlumParser::Column_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_elem(this);
}

void GreenPlumParser::Column_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_elem(this);
}


antlrcpp::Any GreenPlumParser::Column_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitColumn_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Column_elemContext* GreenPlumParser::column_elem() {
  Column_elemContext *_localctx = _tracker.createInstance<Column_elemContext>(_ctx, getState());
  enterRule(_localctx, 194, GreenPlumParser::RuleColumn_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2348);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_matchContext ------------------------------------------------------------------

GreenPlumParser::Key_matchContext::Key_matchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Key_matchContext::MATCH() {
  return getToken(GreenPlumParser::MATCH, 0);
}

tree::TerminalNode* GreenPlumParser::Key_matchContext::FULL() {
  return getToken(GreenPlumParser::FULL, 0);
}

tree::TerminalNode* GreenPlumParser::Key_matchContext::PARTIAL() {
  return getToken(GreenPlumParser::PARTIAL, 0);
}

tree::TerminalNode* GreenPlumParser::Key_matchContext::SIMPLE() {
  return getToken(GreenPlumParser::SIMPLE, 0);
}


size_t GreenPlumParser::Key_matchContext::getRuleIndex() const {
  return GreenPlumParser::RuleKey_match;
}

void GreenPlumParser::Key_matchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_match(this);
}

void GreenPlumParser::Key_matchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_match(this);
}


antlrcpp::Any GreenPlumParser::Key_matchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKey_match(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Key_matchContext* GreenPlumParser::key_match() {
  Key_matchContext *_localctx = _tracker.createInstance<Key_matchContext>(_ctx, getState());
  enterRule(_localctx, 196, GreenPlumParser::RuleKey_match);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2350);
    match(GreenPlumParser::MATCH);
    setState(2351);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::FULL || _la == GreenPlumParser::PARTIAL || _la == GreenPlumParser::SIMPLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_actionsContext ------------------------------------------------------------------

GreenPlumParser::Key_actionsContext::Key_actionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Key_updateContext* GreenPlumParser::Key_actionsContext::key_update() {
  return getRuleContext<GreenPlumParser::Key_updateContext>(0);
}

GreenPlumParser::Key_deleteContext* GreenPlumParser::Key_actionsContext::key_delete() {
  return getRuleContext<GreenPlumParser::Key_deleteContext>(0);
}


size_t GreenPlumParser::Key_actionsContext::getRuleIndex() const {
  return GreenPlumParser::RuleKey_actions;
}

void GreenPlumParser::Key_actionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_actions(this);
}

void GreenPlumParser::Key_actionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_actions(this);
}


antlrcpp::Any GreenPlumParser::Key_actionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKey_actions(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Key_actionsContext* GreenPlumParser::key_actions() {
  Key_actionsContext *_localctx = _tracker.createInstance<Key_actionsContext>(_ctx, getState());
  enterRule(_localctx, 198, GreenPlumParser::RuleKey_actions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2361);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2353);
      key_update();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2354);
      key_delete();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2355);
      key_update();
      setState(2356);
      key_delete();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2358);
      key_delete();
      setState(2359);
      key_update();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_updateContext ------------------------------------------------------------------

GreenPlumParser::Key_updateContext::Key_updateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Key_updateContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Key_updateContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

GreenPlumParser::Key_actionContext* GreenPlumParser::Key_updateContext::key_action() {
  return getRuleContext<GreenPlumParser::Key_actionContext>(0);
}


size_t GreenPlumParser::Key_updateContext::getRuleIndex() const {
  return GreenPlumParser::RuleKey_update;
}

void GreenPlumParser::Key_updateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_update(this);
}

void GreenPlumParser::Key_updateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_update(this);
}


antlrcpp::Any GreenPlumParser::Key_updateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKey_update(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Key_updateContext* GreenPlumParser::key_update() {
  Key_updateContext *_localctx = _tracker.createInstance<Key_updateContext>(_ctx, getState());
  enterRule(_localctx, 200, GreenPlumParser::RuleKey_update);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2363);
    match(GreenPlumParser::ON);
    setState(2364);
    match(GreenPlumParser::UPDATE);
    setState(2365);
    key_action();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_deleteContext ------------------------------------------------------------------

GreenPlumParser::Key_deleteContext::Key_deleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Key_deleteContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Key_deleteContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

GreenPlumParser::Key_actionContext* GreenPlumParser::Key_deleteContext::key_action() {
  return getRuleContext<GreenPlumParser::Key_actionContext>(0);
}


size_t GreenPlumParser::Key_deleteContext::getRuleIndex() const {
  return GreenPlumParser::RuleKey_delete;
}

void GreenPlumParser::Key_deleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_delete(this);
}

void GreenPlumParser::Key_deleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_delete(this);
}


antlrcpp::Any GreenPlumParser::Key_deleteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKey_delete(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Key_deleteContext* GreenPlumParser::key_delete() {
  Key_deleteContext *_localctx = _tracker.createInstance<Key_deleteContext>(_ctx, getState());
  enterRule(_localctx, 202, GreenPlumParser::RuleKey_delete);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2367);
    match(GreenPlumParser::ON);
    setState(2368);
    match(GreenPlumParser::DELETE_P);
    setState(2369);
    key_action();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_actionContext ------------------------------------------------------------------

GreenPlumParser::Key_actionContext::Key_actionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Key_actionContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Key_actionContext::ACTION() {
  return getToken(GreenPlumParser::ACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Key_actionContext::RESTRICT() {
  return getToken(GreenPlumParser::RESTRICT, 0);
}

tree::TerminalNode* GreenPlumParser::Key_actionContext::CASCADE() {
  return getToken(GreenPlumParser::CASCADE, 0);
}

tree::TerminalNode* GreenPlumParser::Key_actionContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Key_actionContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Key_actionContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Key_actionContext::getRuleIndex() const {
  return GreenPlumParser::RuleKey_action;
}

void GreenPlumParser::Key_actionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_action(this);
}

void GreenPlumParser::Key_actionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_action(this);
}


antlrcpp::Any GreenPlumParser::Key_actionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKey_action(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Key_actionContext* GreenPlumParser::key_action() {
  Key_actionContext *_localctx = _tracker.createInstance<Key_actionContext>(_ctx, getState());
  enterRule(_localctx, 204, GreenPlumParser::RuleKey_action);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2377);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::NO: {
        enterOuterAlt(_localctx, 1);
        setState(2371);
        match(GreenPlumParser::NO);
        setState(2372);
        match(GreenPlumParser::ACTION);
        break;
      }

      case GreenPlumParser::RESTRICT: {
        enterOuterAlt(_localctx, 2);
        setState(2373);
        match(GreenPlumParser::RESTRICT);
        break;
      }

      case GreenPlumParser::CASCADE: {
        enterOuterAlt(_localctx, 3);
        setState(2374);
        match(GreenPlumParser::CASCADE);
        break;
      }

      case GreenPlumParser::SET: {
        enterOuterAlt(_localctx, 4);
        setState(2375);
        match(GreenPlumParser::SET);
        setState(2376);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::DEFAULT || _la == GreenPlumParser::NULL_P)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_inheritContext ------------------------------------------------------------------

GreenPlumParser::Opt_inheritContext::Opt_inheritContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_inheritContext::INHERITS() {
  return getToken(GreenPlumParser::INHERITS, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_inheritContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Qualified_name_listContext* GreenPlumParser::Opt_inheritContext::qualified_name_list() {
  return getRuleContext<GreenPlumParser::Qualified_name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_inheritContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Opt_inheritContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_inherit;
}

void GreenPlumParser::Opt_inheritContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_inherit(this);
}

void GreenPlumParser::Opt_inheritContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_inherit(this);
}


antlrcpp::Any GreenPlumParser::Opt_inheritContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_inherit(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_inheritContext* GreenPlumParser::opt_inherit() {
  Opt_inheritContext *_localctx = _tracker.createInstance<Opt_inheritContext>(_ctx, getState());
  enterRule(_localctx, 206, GreenPlumParser::RuleOpt_inherit);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2379);
    match(GreenPlumParser::INHERITS);
    setState(2380);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2381);
    qualified_name_list();
    setState(2382);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_with_def_oidsContext ------------------------------------------------------------------

GreenPlumParser::Opt_with_def_oidsContext::Opt_with_def_oidsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_with_def_oidsContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Opt_with_def_oidsContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_with_def_oidsContext::OIDS() {
  return getToken(GreenPlumParser::OIDS, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_with_def_oidsContext::WITHOUT() {
  return getToken(GreenPlumParser::WITHOUT, 0);
}


size_t GreenPlumParser::Opt_with_def_oidsContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_with_def_oids;
}

void GreenPlumParser::Opt_with_def_oidsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_with_def_oids(this);
}

void GreenPlumParser::Opt_with_def_oidsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_with_def_oids(this);
}


antlrcpp::Any GreenPlumParser::Opt_with_def_oidsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_with_def_oids(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_with_def_oidsContext* GreenPlumParser::opt_with_def_oids() {
  Opt_with_def_oidsContext *_localctx = _tracker.createInstance<Opt_with_def_oidsContext>(_ctx, getState());
  enterRule(_localctx, 208, GreenPlumParser::RuleOpt_with_def_oids);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2388);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2384);
      match(GreenPlumParser::WITH);
      setState(2385);
      definition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2386);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::WITH

      || _la == GreenPlumParser::WITHOUT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2387);
      match(GreenPlumParser::OIDS);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_commit_optionContext ------------------------------------------------------------------

GreenPlumParser::On_commit_optionContext::On_commit_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::On_commit_optionContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::On_commit_optionContext::COMMIT() {
  return getToken(GreenPlumParser::COMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::On_commit_optionContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::On_commit_optionContext::ROWS() {
  return getToken(GreenPlumParser::ROWS, 0);
}

tree::TerminalNode* GreenPlumParser::On_commit_optionContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

tree::TerminalNode* GreenPlumParser::On_commit_optionContext::PRESERVE() {
  return getToken(GreenPlumParser::PRESERVE, 0);
}


size_t GreenPlumParser::On_commit_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleOn_commit_option;
}

void GreenPlumParser::On_commit_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOn_commit_option(this);
}

void GreenPlumParser::On_commit_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOn_commit_option(this);
}


antlrcpp::Any GreenPlumParser::On_commit_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOn_commit_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::On_commit_optionContext* GreenPlumParser::on_commit_option() {
  On_commit_optionContext *_localctx = _tracker.createInstance<On_commit_optionContext>(_ctx, getState());
  enterRule(_localctx, 210, GreenPlumParser::RuleOn_commit_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2397);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2390);
      match(GreenPlumParser::ON);
      setState(2391);
      match(GreenPlumParser::COMMIT);
      setState(2392);
      match(GreenPlumParser::DROP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2393);
      match(GreenPlumParser::ON);
      setState(2394);
      match(GreenPlumParser::COMMIT);
      setState(2395);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::DELETE_P || _la == GreenPlumParser::PRESERVE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2396);
      match(GreenPlumParser::ROWS);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_table_spaceContext ------------------------------------------------------------------

GreenPlumParser::Opt_table_spaceContext::Opt_table_spaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_table_spaceContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Opt_table_spaceContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Opt_table_spaceContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_table_space;
}

void GreenPlumParser::Opt_table_spaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_table_space(this);
}

void GreenPlumParser::Opt_table_spaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_table_space(this);
}


antlrcpp::Any GreenPlumParser::Opt_table_spaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_table_space(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_table_spaceContext* GreenPlumParser::opt_table_space() {
  Opt_table_spaceContext *_localctx = _tracker.createInstance<Opt_table_spaceContext>(_ctx, getState());
  enterRule(_localctx, 212, GreenPlumParser::RuleOpt_table_space);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2399);
    match(GreenPlumParser::TABLESPACE);
    setState(2400);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_table_spaceContext ------------------------------------------------------------------

GreenPlumParser::Constraint_table_spaceContext::Constraint_table_spaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraint_table_spaceContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_table_spaceContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_table_spaceContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Constraint_table_spaceContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Constraint_table_spaceContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraint_table_space;
}

void GreenPlumParser::Constraint_table_spaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_table_space(this);
}

void GreenPlumParser::Constraint_table_spaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_table_space(this);
}


antlrcpp::Any GreenPlumParser::Constraint_table_spaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraint_table_space(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraint_table_spaceContext* GreenPlumParser::constraint_table_space() {
  Constraint_table_spaceContext *_localctx = _tracker.createInstance<Constraint_table_spaceContext>(_ctx, getState());
  enterRule(_localctx, 214, GreenPlumParser::RuleConstraint_table_space);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2402);
    match(GreenPlumParser::USING);
    setState(2403);
    match(GreenPlumParser::INDEX);
    setState(2404);
    match(GreenPlumParser::TABLESPACE);
    setState(2405);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Distributed_byContext ------------------------------------------------------------------

GreenPlumParser::Distributed_byContext::Distributed_byContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Distributed_byContext::DISTRIBUTED() {
  return getToken(GreenPlumParser::DISTRIBUTED, 0);
}

tree::TerminalNode* GreenPlumParser::Distributed_byContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Distributed_byContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Distributed_byContext::RANDOMLY() {
  return getToken(GreenPlumParser::RANDOMLY, 0);
}


size_t GreenPlumParser::Distributed_byContext::getRuleIndex() const {
  return GreenPlumParser::RuleDistributed_by;
}

void GreenPlumParser::Distributed_byContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDistributed_by(this);
}

void GreenPlumParser::Distributed_byContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDistributed_by(this);
}


antlrcpp::Any GreenPlumParser::Distributed_byContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDistributed_by(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Distributed_byContext* GreenPlumParser::distributed_by() {
  Distributed_byContext *_localctx = _tracker.createInstance<Distributed_byContext>(_ctx, getState());
  enterRule(_localctx, 216, GreenPlumParser::RuleDistributed_by);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2412);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2407);
      match(GreenPlumParser::DISTRIBUTED);
      setState(2408);
      match(GreenPlumParser::BY);
      setState(2409);
      paren_column_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2410);
      match(GreenPlumParser::DISTRIBUTED);
      setState(2411);
      match(GreenPlumParser::RANDOMLY);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_distributed_byContext ------------------------------------------------------------------

GreenPlumParser::Opt_distributed_byContext::Opt_distributed_byContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Distributed_byContext* GreenPlumParser::Opt_distributed_byContext::distributed_by() {
  return getRuleContext<GreenPlumParser::Distributed_byContext>(0);
}


size_t GreenPlumParser::Opt_distributed_byContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_distributed_by;
}

void GreenPlumParser::Opt_distributed_byContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_distributed_by(this);
}

void GreenPlumParser::Opt_distributed_byContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_distributed_by(this);
}


antlrcpp::Any GreenPlumParser::Opt_distributed_byContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_distributed_by(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_distributed_byContext* GreenPlumParser::opt_distributed_by() {
  Opt_distributed_byContext *_localctx = _tracker.createInstance<Opt_distributed_byContext>(_ctx, getState());
  enterRule(_localctx, 218, GreenPlumParser::RuleOpt_distributed_by);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2414);
    distributed_by();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_column_enc_listContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_column_enc_listContext::Tab_partition_column_enc_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Column_reference_storage_directiveContext *> GreenPlumParser::Tab_partition_column_enc_listContext::column_reference_storage_directive() {
  return getRuleContexts<GreenPlumParser::Column_reference_storage_directiveContext>();
}

GreenPlumParser::Column_reference_storage_directiveContext* GreenPlumParser::Tab_partition_column_enc_listContext::column_reference_storage_directive(size_t i) {
  return getRuleContext<GreenPlumParser::Column_reference_storage_directiveContext>(i);
}


size_t GreenPlumParser::Tab_partition_column_enc_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_column_enc_list;
}

void GreenPlumParser::Tab_partition_column_enc_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_column_enc_list(this);
}

void GreenPlumParser::Tab_partition_column_enc_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_column_enc_list(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_column_enc_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_column_enc_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_column_enc_listContext* GreenPlumParser::tab_partition_column_enc_list() {
  Tab_partition_column_enc_listContext *_localctx = _tracker.createInstance<Tab_partition_column_enc_listContext>(_ctx, getState());
  enterRule(_localctx, 220, GreenPlumParser::RuleTab_partition_column_enc_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2417); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2416);
      column_reference_storage_directive();
      setState(2419); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == GreenPlumParser::COLUMN

    || _la == GreenPlumParser::DEFAULT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tab_partition_storage_attrContext ------------------------------------------------------------------

GreenPlumParser::Opt_tab_partition_storage_attrContext::Opt_tab_partition_storage_attrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_storage_attrContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Opt_tab_partition_storage_attrContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_storage_attrContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Opt_tab_partition_storage_attrContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Opt_tab_partition_storage_attrContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_tab_partition_storage_attr;
}

void GreenPlumParser::Opt_tab_partition_storage_attrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tab_partition_storage_attr(this);
}

void GreenPlumParser::Opt_tab_partition_storage_attrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tab_partition_storage_attr(this);
}


antlrcpp::Any GreenPlumParser::Opt_tab_partition_storage_attrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_tab_partition_storage_attr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tab_partition_storage_attrContext* GreenPlumParser::opt_tab_partition_storage_attr() {
  Opt_tab_partition_storage_attrContext *_localctx = _tracker.createInstance<Opt_tab_partition_storage_attrContext>(_ctx, getState());
  enterRule(_localctx, 222, GreenPlumParser::RuleOpt_tab_partition_storage_attr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2429);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::WITH: {
        enterOuterAlt(_localctx, 1);
        setState(2421);
        match(GreenPlumParser::WITH);
        setState(2422);
        definition();
        setState(2425);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::TABLESPACE) {
          setState(2423);
          match(GreenPlumParser::TABLESPACE);
          setState(2424);
          name();
        }
        break;
      }

      case GreenPlumParser::TABLESPACE: {
        enterOuterAlt(_localctx, 2);
        setState(2427);
        match(GreenPlumParser::TABLESPACE);
        setState(2428);
        name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tab_partition_specContext ------------------------------------------------------------------

GreenPlumParser::Opt_tab_partition_specContext::Opt_tab_partition_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_specContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Tab_partition_elem_listContext* GreenPlumParser::Opt_tab_partition_specContext::tab_partition_elem_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_elem_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_specContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Opt_tab_partition_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_tab_partition_spec;
}

void GreenPlumParser::Opt_tab_partition_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tab_partition_spec(this);
}

void GreenPlumParser::Opt_tab_partition_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tab_partition_spec(this);
}


antlrcpp::Any GreenPlumParser::Opt_tab_partition_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_tab_partition_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tab_partition_specContext* GreenPlumParser::opt_tab_partition_spec() {
  Opt_tab_partition_specContext *_localctx = _tracker.createInstance<Opt_tab_partition_specContext>(_ctx, getState());
  enterRule(_localctx, 224, GreenPlumParser::RuleOpt_tab_partition_spec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2431);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2432);
    tab_partition_elem_list();
    setState(2433);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tab_sub_partition_specContext ------------------------------------------------------------------

GreenPlumParser::Opt_tab_sub_partition_specContext::Opt_tab_sub_partition_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_tab_sub_partition_specContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Tab_sub_partition_elem_listContext* GreenPlumParser::Opt_tab_sub_partition_specContext::tab_sub_partition_elem_list() {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_elem_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_tab_sub_partition_specContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Opt_tab_sub_partition_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_tab_sub_partition_spec;
}

void GreenPlumParser::Opt_tab_sub_partition_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tab_sub_partition_spec(this);
}

void GreenPlumParser::Opt_tab_sub_partition_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tab_sub_partition_spec(this);
}


antlrcpp::Any GreenPlumParser::Opt_tab_sub_partition_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_tab_sub_partition_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tab_sub_partition_specContext* GreenPlumParser::opt_tab_sub_partition_spec() {
  Opt_tab_sub_partition_specContext *_localctx = _tracker.createInstance<Opt_tab_sub_partition_specContext>(_ctx, getState());
  enterRule(_localctx, 226, GreenPlumParser::RuleOpt_tab_sub_partition_spec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2435);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2436);
    tab_sub_partition_elem_list();
    setState(2437);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_elem_listContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_elem_listContext::Tab_partition_elem_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Tab_partition_elemContext *> GreenPlumParser::Tab_partition_elem_listContext::tab_partition_elem() {
  return getRuleContexts<GreenPlumParser::Tab_partition_elemContext>();
}

GreenPlumParser::Tab_partition_elemContext* GreenPlumParser::Tab_partition_elem_listContext::tab_partition_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Tab_partition_elemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Tab_partition_elem_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_elem_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Tab_partition_elem_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_elem_list;
}

void GreenPlumParser::Tab_partition_elem_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_elem_list(this);
}

void GreenPlumParser::Tab_partition_elem_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_elem_list(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_elem_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_elem_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_elem_listContext* GreenPlumParser::tab_partition_elem_list() {
  Tab_partition_elem_listContext *_localctx = _tracker.createInstance<Tab_partition_elem_listContext>(_ctx, getState());
  enterRule(_localctx, 228, GreenPlumParser::RuleTab_partition_elem_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2439);
    tab_partition_elem();
    setState(2444);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2440);
      match(GreenPlumParser::COMMA);
      setState(2441);
      tab_partition_elem();
      setState(2446);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_sub_partition_elem_listContext ------------------------------------------------------------------

GreenPlumParser::Tab_sub_partition_elem_listContext::Tab_sub_partition_elem_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Tab_sub_partition_elemContext *> GreenPlumParser::Tab_sub_partition_elem_listContext::tab_sub_partition_elem() {
  return getRuleContexts<GreenPlumParser::Tab_sub_partition_elemContext>();
}

GreenPlumParser::Tab_sub_partition_elemContext* GreenPlumParser::Tab_sub_partition_elem_listContext::tab_sub_partition_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_elemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Tab_sub_partition_elem_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_elem_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Tab_sub_partition_elem_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_sub_partition_elem_list;
}

void GreenPlumParser::Tab_sub_partition_elem_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_sub_partition_elem_list(this);
}

void GreenPlumParser::Tab_sub_partition_elem_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_sub_partition_elem_list(this);
}


antlrcpp::Any GreenPlumParser::Tab_sub_partition_elem_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_sub_partition_elem_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_sub_partition_elem_listContext* GreenPlumParser::tab_sub_partition_elem_list() {
  Tab_sub_partition_elem_listContext *_localctx = _tracker.createInstance<Tab_sub_partition_elem_listContext>(_ctx, getState());
  enterRule(_localctx, 230, GreenPlumParser::RuleTab_sub_partition_elem_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2447);
    tab_sub_partition_elem();
    setState(2452);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2448);
      match(GreenPlumParser::COMMA);
      setState(2449);
      tab_sub_partition_elem();
      setState(2454);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_part_val_no_paranContext ------------------------------------------------------------------

GreenPlumParser::Tab_part_val_no_paranContext::Tab_part_val_no_paranContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_expr_constContext* GreenPlumParser::Tab_part_val_no_paranContext::a_expr_const() {
  return getRuleContext<GreenPlumParser::A_expr_constContext>(0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_val_no_paranContext::CAST() {
  return getToken(GreenPlumParser::CAST, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_val_no_paranContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Tab_part_valContext* GreenPlumParser::Tab_part_val_no_paranContext::tab_part_val() {
  return getRuleContext<GreenPlumParser::Tab_part_valContext>(0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_val_no_paranContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Tab_part_val_no_paranContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_val_no_paranContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_val_no_paranContext::MINUS_SIGN() {
  return getToken(GreenPlumParser::MINUS_SIGN, 0);
}

GreenPlumParser::Tab_part_val_no_paranContext* GreenPlumParser::Tab_part_val_no_paranContext::tab_part_val_no_paran() {
  return getRuleContext<GreenPlumParser::Tab_part_val_no_paranContext>(0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_val_no_paranContext::TYPECAST() {
  return getToken(GreenPlumParser::TYPECAST, 0);
}


size_t GreenPlumParser::Tab_part_val_no_paranContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_part_val_no_paran;
}

void GreenPlumParser::Tab_part_val_no_paranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_part_val_no_paran(this);
}

void GreenPlumParser::Tab_part_val_no_paranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_part_val_no_paran(this);
}


antlrcpp::Any GreenPlumParser::Tab_part_val_no_paranContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_part_val_no_paran(this);
  else
    return visitor->visitChildren(this);
}


GreenPlumParser::Tab_part_val_no_paranContext* GreenPlumParser::tab_part_val_no_paran() {
   return tab_part_val_no_paran(0);
}

GreenPlumParser::Tab_part_val_no_paranContext* GreenPlumParser::tab_part_val_no_paran(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::Tab_part_val_no_paranContext *_localctx = _tracker.createInstance<Tab_part_val_no_paranContext>(_ctx, parentState);
  GreenPlumParser::Tab_part_val_no_paranContext *previousContext = _localctx;
  size_t startState = 232;
  enterRecursionRule(_localctx, 232, GreenPlumParser::RuleTab_part_val_no_paran, precedence);

    

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2466);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST:
      case GreenPlumParser::BCONST:
      case GreenPlumParser::XCONST: {
        setState(2456);
        a_expr_const();
        break;
      }

      case GreenPlumParser::CAST: {
        setState(2457);
        match(GreenPlumParser::CAST);
        setState(2458);
        match(GreenPlumParser::LEFT_PAREN);
        setState(2459);
        tab_part_val();
        setState(2460);
        match(GreenPlumParser::AS);
        setState(2461);
        typename_pg();
        setState(2462);
        match(GreenPlumParser::RIGHT_PAREN);
        break;
      }

      case GreenPlumParser::MINUS_SIGN: {
        setState(2464);
        match(GreenPlumParser::MINUS_SIGN);
        setState(2465);
        tab_part_val_no_paran(1);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(2473);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Tab_part_val_no_paranContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleTab_part_val_no_paran);
        setState(2468);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(2469);
        match(GreenPlumParser::TYPECAST);
        setState(2470);
        typename_pg(); 
      }
      setState(2475);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Tab_part_valContext ------------------------------------------------------------------

GreenPlumParser::Tab_part_valContext::Tab_part_valContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Tab_part_val_no_paranContext* GreenPlumParser::Tab_part_valContext::tab_part_val_no_paran() {
  return getRuleContext<GreenPlumParser::Tab_part_val_no_paranContext>(0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_valContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_valContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_part_valContext::TYPECAST() {
  return getToken(GreenPlumParser::TYPECAST, 0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Tab_part_valContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}


size_t GreenPlumParser::Tab_part_valContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_part_val;
}

void GreenPlumParser::Tab_part_valContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_part_val(this);
}

void GreenPlumParser::Tab_part_valContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_part_val(this);
}


antlrcpp::Any GreenPlumParser::Tab_part_valContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_part_val(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_part_valContext* GreenPlumParser::tab_part_val() {
  Tab_part_valContext *_localctx = _tracker.createInstance<Tab_part_valContext>(_ctx, getState());
  enterRule(_localctx, 234, GreenPlumParser::RuleTab_part_val);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2487);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2476);
      tab_part_val_no_paran(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2477);
      match(GreenPlumParser::LEFT_PAREN);
      setState(2478);
      tab_part_val_no_paran(0);
      setState(2479);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2481);
      match(GreenPlumParser::LEFT_PAREN);
      setState(2482);
      tab_part_val_no_paran(0);
      setState(2483);
      match(GreenPlumParser::RIGHT_PAREN);
      setState(2484);
      match(GreenPlumParser::TYPECAST);
      setState(2485);
      typename_pg();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_boundary_spec_val_listContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_boundary_spec_val_listContext::Tab_partition_boundary_spec_val_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Tab_part_valContext *> GreenPlumParser::Tab_partition_boundary_spec_val_listContext::tab_part_val() {
  return getRuleContexts<GreenPlumParser::Tab_part_valContext>();
}

GreenPlumParser::Tab_part_valContext* GreenPlumParser::Tab_partition_boundary_spec_val_listContext::tab_part_val(size_t i) {
  return getRuleContext<GreenPlumParser::Tab_part_valContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Tab_partition_boundary_spec_val_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_boundary_spec_val_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Tab_partition_boundary_spec_val_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_boundary_spec_val_list;
}

void GreenPlumParser::Tab_partition_boundary_spec_val_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_boundary_spec_val_list(this);
}

void GreenPlumParser::Tab_partition_boundary_spec_val_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_boundary_spec_val_list(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_boundary_spec_val_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_boundary_spec_val_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_boundary_spec_val_listContext* GreenPlumParser::tab_partition_boundary_spec_val_list() {
  Tab_partition_boundary_spec_val_listContext *_localctx = _tracker.createInstance<Tab_partition_boundary_spec_val_listContext>(_ctx, getState());
  enterRule(_localctx, 236, GreenPlumParser::RuleTab_partition_boundary_spec_val_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2489);
    tab_part_val();
    setState(2494);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2490);
      match(GreenPlumParser::COMMA);
      setState(2491);
      tab_part_val();
      setState(2496);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tab_partition_range_inclusiveContext ------------------------------------------------------------------

GreenPlumParser::Opt_tab_partition_range_inclusiveContext::Opt_tab_partition_range_inclusiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_range_inclusiveContext::INCLUSIVE() {
  return getToken(GreenPlumParser::INCLUSIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_range_inclusiveContext::EXCLUSIVE() {
  return getToken(GreenPlumParser::EXCLUSIVE, 0);
}


size_t GreenPlumParser::Opt_tab_partition_range_inclusiveContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_tab_partition_range_inclusive;
}

void GreenPlumParser::Opt_tab_partition_range_inclusiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tab_partition_range_inclusive(this);
}

void GreenPlumParser::Opt_tab_partition_range_inclusiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tab_partition_range_inclusive(this);
}


antlrcpp::Any GreenPlumParser::Opt_tab_partition_range_inclusiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_tab_partition_range_inclusive(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tab_partition_range_inclusiveContext* GreenPlumParser::opt_tab_partition_range_inclusive() {
  Opt_tab_partition_range_inclusiveContext *_localctx = _tracker.createInstance<Opt_tab_partition_range_inclusiveContext>(_ctx, getState());
  enterRule(_localctx, 238, GreenPlumParser::RuleOpt_tab_partition_range_inclusive);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2497);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::EXCLUSIVE

    || _la == GreenPlumParser::INCLUSIVE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_boundary_spec_startContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_boundary_spec_startContext::Tab_partition_boundary_spec_startContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_partition_boundary_spec_startContext::START() {
  return getToken(GreenPlumParser::START, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_boundary_spec_startContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_boundary_spec_startContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Tab_partition_boundary_spec_val_listContext* GreenPlumParser::Tab_partition_boundary_spec_startContext::tab_partition_boundary_spec_val_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_val_listContext>(0);
}

GreenPlumParser::Opt_tab_partition_range_inclusiveContext* GreenPlumParser::Tab_partition_boundary_spec_startContext::opt_tab_partition_range_inclusive() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_range_inclusiveContext>(0);
}


size_t GreenPlumParser::Tab_partition_boundary_spec_startContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_boundary_spec_start;
}

void GreenPlumParser::Tab_partition_boundary_spec_startContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_boundary_spec_start(this);
}

void GreenPlumParser::Tab_partition_boundary_spec_startContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_boundary_spec_start(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_boundary_spec_startContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_boundary_spec_start(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_boundary_spec_startContext* GreenPlumParser::tab_partition_boundary_spec_start() {
  Tab_partition_boundary_spec_startContext *_localctx = _tracker.createInstance<Tab_partition_boundary_spec_startContext>(_ctx, getState());
  enterRule(_localctx, 240, GreenPlumParser::RuleTab_partition_boundary_spec_start);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2499);
    match(GreenPlumParser::START);
    setState(2500);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2502);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CAST)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTER)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHAR_P)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CROSS - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DEC - 64))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FALSE_P - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FLOAT_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FULL - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::ILIKE - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128))
      | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INTEGER - 193))
      | (1ULL << (GreenPlumParser::INTERVAL - 193))
      | (1ULL << (GreenPlumParser::INT_P - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::IS - 193))
      | (1ULL << (GreenPlumParser::ISNULL - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::JOIN - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEFT - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIKE - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::LOG_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NATIONAL - 193))
      | (1ULL << (GreenPlumParser::NATURAL - 193))
      | (1ULL << (GreenPlumParser::NCHAR - 193))
      | (1ULL << (GreenPlumParser::NEW - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOTNULL - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULL_P - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::NUMERIC - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OLD - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OUTER_P - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OVERLAPS - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REAL - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::RIGHT - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMILAR - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SMALLINT - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TIME - 385))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUE_P - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARCHAR - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERBOSE - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::LEFT_PAREN - 451))
      | (1ULL << (GreenPlumParser::MINUS_SIGN - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451))
      | (1ULL << (GreenPlumParser::ICONST - 451))
      | (1ULL << (GreenPlumParser::FCONST - 451))
      | (1ULL << (GreenPlumParser::BCONST - 451))
      | (1ULL << (GreenPlumParser::XCONST - 451)))) != 0)) {
      setState(2501);
      tab_partition_boundary_spec_val_list();
    }
    setState(2504);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(2506);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::EXCLUSIVE

    || _la == GreenPlumParser::INCLUSIVE) {
      setState(2505);
      opt_tab_partition_range_inclusive();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_boundary_spec_endContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_boundary_spec_endContext::Tab_partition_boundary_spec_endContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_partition_boundary_spec_endContext::END_P() {
  return getToken(GreenPlumParser::END_P, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_boundary_spec_endContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_boundary_spec_endContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Tab_partition_boundary_spec_val_listContext* GreenPlumParser::Tab_partition_boundary_spec_endContext::tab_partition_boundary_spec_val_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_val_listContext>(0);
}

GreenPlumParser::Opt_tab_partition_range_inclusiveContext* GreenPlumParser::Tab_partition_boundary_spec_endContext::opt_tab_partition_range_inclusive() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_range_inclusiveContext>(0);
}


size_t GreenPlumParser::Tab_partition_boundary_spec_endContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_boundary_spec_end;
}

void GreenPlumParser::Tab_partition_boundary_spec_endContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_boundary_spec_end(this);
}

void GreenPlumParser::Tab_partition_boundary_spec_endContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_boundary_spec_end(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_boundary_spec_endContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_boundary_spec_end(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_boundary_spec_endContext* GreenPlumParser::tab_partition_boundary_spec_end() {
  Tab_partition_boundary_spec_endContext *_localctx = _tracker.createInstance<Tab_partition_boundary_spec_endContext>(_ctx, getState());
  enterRule(_localctx, 242, GreenPlumParser::RuleTab_partition_boundary_spec_end);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2508);
    match(GreenPlumParser::END_P);
    setState(2509);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2511);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CAST)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTER)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHAR_P)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CROSS - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DEC - 64))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FALSE_P - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FLOAT_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FULL - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::ILIKE - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128))
      | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INTEGER - 193))
      | (1ULL << (GreenPlumParser::INTERVAL - 193))
      | (1ULL << (GreenPlumParser::INT_P - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::IS - 193))
      | (1ULL << (GreenPlumParser::ISNULL - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::JOIN - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEFT - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIKE - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::LOG_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NATIONAL - 193))
      | (1ULL << (GreenPlumParser::NATURAL - 193))
      | (1ULL << (GreenPlumParser::NCHAR - 193))
      | (1ULL << (GreenPlumParser::NEW - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOTNULL - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULL_P - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::NUMERIC - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OLD - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OUTER_P - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OVERLAPS - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REAL - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::RIGHT - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMILAR - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SMALLINT - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TIME - 385))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUE_P - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARCHAR - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERBOSE - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::LEFT_PAREN - 451))
      | (1ULL << (GreenPlumParser::MINUS_SIGN - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451))
      | (1ULL << (GreenPlumParser::ICONST - 451))
      | (1ULL << (GreenPlumParser::FCONST - 451))
      | (1ULL << (GreenPlumParser::BCONST - 451))
      | (1ULL << (GreenPlumParser::XCONST - 451)))) != 0)) {
      setState(2510);
      tab_partition_boundary_spec_val_list();
    }
    setState(2513);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(2515);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::EXCLUSIVE

    || _la == GreenPlumParser::INCLUSIVE) {
      setState(2514);
      opt_tab_partition_range_inclusive();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tab_partition_boundary_spec_everyContext ------------------------------------------------------------------

GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::Opt_tab_partition_boundary_spec_everyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::EVERY() {
  return getToken(GreenPlumParser::EVERY, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Tab_partition_boundary_spec_val_listContext* GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::tab_partition_boundary_spec_val_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_val_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_tab_partition_boundary_spec_every;
}

void GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tab_partition_boundary_spec_every(this);
}

void GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tab_partition_boundary_spec_every(this);
}


antlrcpp::Any GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_tab_partition_boundary_spec_every(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext* GreenPlumParser::opt_tab_partition_boundary_spec_every() {
  Opt_tab_partition_boundary_spec_everyContext *_localctx = _tracker.createInstance<Opt_tab_partition_boundary_spec_everyContext>(_ctx, getState());
  enterRule(_localctx, 244, GreenPlumParser::RuleOpt_tab_partition_boundary_spec_every);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2517);
    match(GreenPlumParser::EVERY);
    setState(2518);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2519);
    tab_partition_boundary_spec_val_list();
    setState(2520);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_boundary_specContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_boundary_specContext::Tab_partition_boundary_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Part_values_clauseContext* GreenPlumParser::Tab_partition_boundary_specContext::part_values_clause() {
  return getRuleContext<GreenPlumParser::Part_values_clauseContext>(0);
}

GreenPlumParser::Tab_partition_boundary_spec_startContext* GreenPlumParser::Tab_partition_boundary_specContext::tab_partition_boundary_spec_start() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_startContext>(0);
}

GreenPlumParser::Tab_partition_boundary_spec_endContext* GreenPlumParser::Tab_partition_boundary_specContext::tab_partition_boundary_spec_end() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_endContext>(0);
}

GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext* GreenPlumParser::Tab_partition_boundary_specContext::opt_tab_partition_boundary_spec_every() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_boundary_spec_everyContext>(0);
}


size_t GreenPlumParser::Tab_partition_boundary_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_boundary_spec;
}

void GreenPlumParser::Tab_partition_boundary_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_boundary_spec(this);
}

void GreenPlumParser::Tab_partition_boundary_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_boundary_spec(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_boundary_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_boundary_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_boundary_specContext* GreenPlumParser::tab_partition_boundary_spec() {
  Tab_partition_boundary_specContext *_localctx = _tracker.createInstance<Tab_partition_boundary_specContext>(_ctx, getState());
  enterRule(_localctx, 246, GreenPlumParser::RuleTab_partition_boundary_spec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2534);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::VALUES: {
        enterOuterAlt(_localctx, 1);
        setState(2522);
        part_values_clause();
        break;
      }

      case GreenPlumParser::START: {
        enterOuterAlt(_localctx, 2);
        setState(2523);
        tab_partition_boundary_spec_start();
        setState(2525);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::END_P) {
          setState(2524);
          tab_partition_boundary_spec_end();
        }
        setState(2528);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EVERY) {
          setState(2527);
          opt_tab_partition_boundary_spec_every();
        }
        break;
      }

      case GreenPlumParser::END_P: {
        enterOuterAlt(_localctx, 3);
        setState(2530);
        tab_partition_boundary_spec_end();
        setState(2532);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EVERY) {
          setState(2531);
          opt_tab_partition_boundary_spec_every();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Paren_part_values_singleContext ------------------------------------------------------------------

GreenPlumParser::Paren_part_values_singleContext::Paren_part_values_singleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Paren_part_values_singleContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Part_values_singleContext* GreenPlumParser::Paren_part_values_singleContext::part_values_single() {
  return getRuleContext<GreenPlumParser::Part_values_singleContext>(0);
}

tree::TerminalNode* GreenPlumParser::Paren_part_values_singleContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Paren_part_values_singleContext::getRuleIndex() const {
  return GreenPlumParser::RuleParen_part_values_single;
}

void GreenPlumParser::Paren_part_values_singleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParen_part_values_single(this);
}

void GreenPlumParser::Paren_part_values_singleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParen_part_values_single(this);
}


antlrcpp::Any GreenPlumParser::Paren_part_values_singleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParen_part_values_single(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Paren_part_values_singleContext* GreenPlumParser::paren_part_values_single() {
  Paren_part_values_singleContext *_localctx = _tracker.createInstance<Paren_part_values_singleContext>(_ctx, getState());
  enterRule(_localctx, 248, GreenPlumParser::RuleParen_part_values_single);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2536);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2537);
    part_values_single();
    setState(2538);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multi_spec_value_listContext ------------------------------------------------------------------

GreenPlumParser::Multi_spec_value_listContext::Multi_spec_value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Paren_part_values_singleContext *> GreenPlumParser::Multi_spec_value_listContext::paren_part_values_single() {
  return getRuleContexts<GreenPlumParser::Paren_part_values_singleContext>();
}

GreenPlumParser::Paren_part_values_singleContext* GreenPlumParser::Multi_spec_value_listContext::paren_part_values_single(size_t i) {
  return getRuleContext<GreenPlumParser::Paren_part_values_singleContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Multi_spec_value_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Multi_spec_value_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Multi_spec_value_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleMulti_spec_value_list;
}

void GreenPlumParser::Multi_spec_value_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMulti_spec_value_list(this);
}

void GreenPlumParser::Multi_spec_value_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMulti_spec_value_list(this);
}


antlrcpp::Any GreenPlumParser::Multi_spec_value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitMulti_spec_value_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Multi_spec_value_listContext* GreenPlumParser::multi_spec_value_list() {
  Multi_spec_value_listContext *_localctx = _tracker.createInstance<Multi_spec_value_listContext>(_ctx, getState());
  enterRule(_localctx, 250, GreenPlumParser::RuleMulti_spec_value_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2540);
    paren_part_values_single();
    setState(2545);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2541);
      match(GreenPlumParser::COMMA);
      setState(2542);
      paren_part_values_single();
      setState(2547);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_values_singleContext ------------------------------------------------------------------

GreenPlumParser::Part_values_singleContext::Part_values_singleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Tab_part_val_no_paranContext *> GreenPlumParser::Part_values_singleContext::tab_part_val_no_paran() {
  return getRuleContexts<GreenPlumParser::Tab_part_val_no_paranContext>();
}

GreenPlumParser::Tab_part_val_no_paranContext* GreenPlumParser::Part_values_singleContext::tab_part_val_no_paran(size_t i) {
  return getRuleContext<GreenPlumParser::Tab_part_val_no_paranContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Part_values_singleContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Part_values_singleContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Part_values_singleContext::getRuleIndex() const {
  return GreenPlumParser::RulePart_values_single;
}

void GreenPlumParser::Part_values_singleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPart_values_single(this);
}

void GreenPlumParser::Part_values_singleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPart_values_single(this);
}


antlrcpp::Any GreenPlumParser::Part_values_singleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPart_values_single(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Part_values_singleContext* GreenPlumParser::part_values_single() {
  Part_values_singleContext *_localctx = _tracker.createInstance<Part_values_singleContext>(_ctx, getState());
  enterRule(_localctx, 252, GreenPlumParser::RulePart_values_single);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2548);
    tab_part_val_no_paran(0);
    setState(2553);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2549);
      match(GreenPlumParser::COMMA);
      setState(2550);
      tab_part_val_no_paran(0);
      setState(2555);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_values_clauseContext ------------------------------------------------------------------

GreenPlumParser::Part_values_clauseContext::Part_values_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Part_values_clauseContext::VALUES() {
  return getToken(GreenPlumParser::VALUES, 0);
}

GreenPlumParser::Paren_part_values_singleContext* GreenPlumParser::Part_values_clauseContext::paren_part_values_single() {
  return getRuleContext<GreenPlumParser::Paren_part_values_singleContext>(0);
}

tree::TerminalNode* GreenPlumParser::Part_values_clauseContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Multi_spec_value_listContext* GreenPlumParser::Part_values_clauseContext::multi_spec_value_list() {
  return getRuleContext<GreenPlumParser::Multi_spec_value_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Part_values_clauseContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Part_values_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RulePart_values_clause;
}

void GreenPlumParser::Part_values_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPart_values_clause(this);
}

void GreenPlumParser::Part_values_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPart_values_clause(this);
}


antlrcpp::Any GreenPlumParser::Part_values_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPart_values_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Part_values_clauseContext* GreenPlumParser::part_values_clause() {
  Part_values_clauseContext *_localctx = _tracker.createInstance<Part_values_clauseContext>(_ctx, getState());
  enterRule(_localctx, 254, GreenPlumParser::RulePart_values_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2563);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2556);
      match(GreenPlumParser::VALUES);
      setState(2557);
      paren_part_values_single();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2558);
      match(GreenPlumParser::VALUES);
      setState(2559);
      match(GreenPlumParser::LEFT_PAREN);
      setState(2560);
      multi_spec_value_list();
      setState(2561);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_values_or_spec_listContext ------------------------------------------------------------------

GreenPlumParser::Part_values_or_spec_listContext::Part_values_or_spec_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Tab_partition_boundary_spec_val_listContext* GreenPlumParser::Part_values_or_spec_listContext::tab_partition_boundary_spec_val_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_spec_val_listContext>(0);
}

GreenPlumParser::Part_values_clauseContext* GreenPlumParser::Part_values_or_spec_listContext::part_values_clause() {
  return getRuleContext<GreenPlumParser::Part_values_clauseContext>(0);
}


size_t GreenPlumParser::Part_values_or_spec_listContext::getRuleIndex() const {
  return GreenPlumParser::RulePart_values_or_spec_list;
}

void GreenPlumParser::Part_values_or_spec_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPart_values_or_spec_list(this);
}

void GreenPlumParser::Part_values_or_spec_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPart_values_or_spec_list(this);
}


antlrcpp::Any GreenPlumParser::Part_values_or_spec_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPart_values_or_spec_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Part_values_or_spec_listContext* GreenPlumParser::part_values_or_spec_list() {
  Part_values_or_spec_listContext *_localctx = _tracker.createInstance<Part_values_or_spec_listContext>(_ctx, getState());
  enterRule(_localctx, 256, GreenPlumParser::RulePart_values_or_spec_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2567);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CAST:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::LEFT_PAREN:
      case GreenPlumParser::MINUS_SIGN:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST:
      case GreenPlumParser::BCONST:
      case GreenPlumParser::XCONST: {
        enterOuterAlt(_localctx, 1);
        setState(2565);
        tab_partition_boundary_spec_val_list();
        break;
      }

      case GreenPlumParser::VALUES: {
        enterOuterAlt(_localctx, 2);
        setState(2566);
        part_values_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_elemContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_elemContext::Tab_partition_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Tab_partition_name_declContext* GreenPlumParser::Tab_partition_elemContext::tab_partition_name_decl() {
  return getRuleContext<GreenPlumParser::Tab_partition_name_declContext>(0);
}

GreenPlumParser::Tab_partition_default_name_declContext* GreenPlumParser::Tab_partition_elemContext::tab_partition_default_name_decl() {
  return getRuleContext<GreenPlumParser::Tab_partition_default_name_declContext>(0);
}

GreenPlumParser::Tab_partition_boundary_specContext* GreenPlumParser::Tab_partition_elemContext::tab_partition_boundary_spec() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_specContext>(0);
}

GreenPlumParser::Opt_tab_partition_storage_attrContext* GreenPlumParser::Tab_partition_elemContext::opt_tab_partition_storage_attr() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_storage_attrContext>(0);
}

GreenPlumParser::Tab_partition_column_enc_listContext* GreenPlumParser::Tab_partition_elemContext::tab_partition_column_enc_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_column_enc_listContext>(0);
}

GreenPlumParser::Opt_tab_sub_partition_specContext* GreenPlumParser::Tab_partition_elemContext::opt_tab_sub_partition_spec() {
  return getRuleContext<GreenPlumParser::Opt_tab_sub_partition_specContext>(0);
}

GreenPlumParser::Tab_partition_elemOptionContext* GreenPlumParser::Tab_partition_elemContext::tab_partition_elemOption() {
  return getRuleContext<GreenPlumParser::Tab_partition_elemOptionContext>(0);
}

GreenPlumParser::Column_reference_storage_directiveContext* GreenPlumParser::Tab_partition_elemContext::column_reference_storage_directive() {
  return getRuleContext<GreenPlumParser::Column_reference_storage_directiveContext>(0);
}


size_t GreenPlumParser::Tab_partition_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_elem;
}

void GreenPlumParser::Tab_partition_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_elem(this);
}

void GreenPlumParser::Tab_partition_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_elem(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_elemContext* GreenPlumParser::tab_partition_elem() {
  Tab_partition_elemContext *_localctx = _tracker.createInstance<Tab_partition_elemContext>(_ctx, getState());
  enterRule(_localctx, 258, GreenPlumParser::RuleTab_partition_elem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2587);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2571);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GreenPlumParser::PARTITION: {
          setState(2569);
          tab_partition_name_decl();
          break;
        }

        case GreenPlumParser::DEFAULT: {
          setState(2570);
          tab_partition_default_name_decl();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2574);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::END_P || _la == GreenPlumParser::START

      || _la == GreenPlumParser::VALUES) {
        setState(2573);
        tab_partition_boundary_spec();
      }
      setState(2577);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TABLESPACE

      || _la == GreenPlumParser::WITH) {
        setState(2576);
        opt_tab_partition_storage_attr();
      }
      setState(2580);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN

      || _la == GreenPlumParser::DEFAULT) {
        setState(2579);
        tab_partition_column_enc_list();
      }
      setState(2583);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(2582);
        opt_tab_sub_partition_spec();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2585);
      tab_partition_elemOption();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2586);
      column_reference_storage_directive();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_sub_partition_elemContext ------------------------------------------------------------------

GreenPlumParser::Tab_sub_partition_elemContext::Tab_sub_partition_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Tab_sub_partition_name_declContext* GreenPlumParser::Tab_sub_partition_elemContext::tab_sub_partition_name_decl() {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_name_declContext>(0);
}

GreenPlumParser::Tab_sub_partition_default_name_declContext* GreenPlumParser::Tab_sub_partition_elemContext::tab_sub_partition_default_name_decl() {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_default_name_declContext>(0);
}

GreenPlumParser::Tab_partition_boundary_specContext* GreenPlumParser::Tab_sub_partition_elemContext::tab_partition_boundary_spec() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_specContext>(0);
}

GreenPlumParser::Opt_tab_partition_storage_attrContext* GreenPlumParser::Tab_sub_partition_elemContext::opt_tab_partition_storage_attr() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_storage_attrContext>(0);
}

GreenPlumParser::Tab_partition_column_enc_listContext* GreenPlumParser::Tab_sub_partition_elemContext::tab_partition_column_enc_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_column_enc_listContext>(0);
}

GreenPlumParser::Opt_tab_sub_partition_specContext* GreenPlumParser::Tab_sub_partition_elemContext::opt_tab_sub_partition_spec() {
  return getRuleContext<GreenPlumParser::Opt_tab_sub_partition_specContext>(0);
}

GreenPlumParser::Tab_partition_elemOptionContext* GreenPlumParser::Tab_sub_partition_elemContext::tab_partition_elemOption() {
  return getRuleContext<GreenPlumParser::Tab_partition_elemOptionContext>(0);
}

GreenPlumParser::Column_reference_storage_directiveContext* GreenPlumParser::Tab_sub_partition_elemContext::column_reference_storage_directive() {
  return getRuleContext<GreenPlumParser::Column_reference_storage_directiveContext>(0);
}


size_t GreenPlumParser::Tab_sub_partition_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_sub_partition_elem;
}

void GreenPlumParser::Tab_sub_partition_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_sub_partition_elem(this);
}

void GreenPlumParser::Tab_sub_partition_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_sub_partition_elem(this);
}


antlrcpp::Any GreenPlumParser::Tab_sub_partition_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_sub_partition_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_sub_partition_elemContext* GreenPlumParser::tab_sub_partition_elem() {
  Tab_sub_partition_elemContext *_localctx = _tracker.createInstance<Tab_sub_partition_elemContext>(_ctx, getState());
  enterRule(_localctx, 260, GreenPlumParser::RuleTab_sub_partition_elem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2607);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2591);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GreenPlumParser::SUBPARTITION: {
          setState(2589);
          tab_sub_partition_name_decl();
          break;
        }

        case GreenPlumParser::DEFAULT: {
          setState(2590);
          tab_sub_partition_default_name_decl();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2594);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::END_P || _la == GreenPlumParser::START

      || _la == GreenPlumParser::VALUES) {
        setState(2593);
        tab_partition_boundary_spec();
      }
      setState(2597);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TABLESPACE

      || _la == GreenPlumParser::WITH) {
        setState(2596);
        opt_tab_partition_storage_attr();
      }
      setState(2600);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN

      || _la == GreenPlumParser::DEFAULT) {
        setState(2599);
        tab_partition_column_enc_list();
      }
      setState(2603);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(2602);
        opt_tab_sub_partition_spec();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2605);
      tab_partition_elemOption();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2606);
      column_reference_storage_directive();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_elemOptionContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_elemOptionContext::Tab_partition_elemOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Tab_partition_boundary_specContext* GreenPlumParser::Tab_partition_elemOptionContext::tab_partition_boundary_spec() {
  return getRuleContext<GreenPlumParser::Tab_partition_boundary_specContext>(0);
}

GreenPlumParser::Opt_tab_partition_storage_attrContext* GreenPlumParser::Tab_partition_elemOptionContext::opt_tab_partition_storage_attr() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_storage_attrContext>(0);
}

GreenPlumParser::Tab_partition_column_enc_listContext* GreenPlumParser::Tab_partition_elemOptionContext::tab_partition_column_enc_list() {
  return getRuleContext<GreenPlumParser::Tab_partition_column_enc_listContext>(0);
}

GreenPlumParser::Opt_tab_sub_partition_specContext* GreenPlumParser::Tab_partition_elemOptionContext::opt_tab_sub_partition_spec() {
  return getRuleContext<GreenPlumParser::Opt_tab_sub_partition_specContext>(0);
}


size_t GreenPlumParser::Tab_partition_elemOptionContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_elemOption;
}

void GreenPlumParser::Tab_partition_elemOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_elemOption(this);
}

void GreenPlumParser::Tab_partition_elemOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_elemOption(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_elemOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_elemOption(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_elemOptionContext* GreenPlumParser::tab_partition_elemOption() {
  Tab_partition_elemOptionContext *_localctx = _tracker.createInstance<Tab_partition_elemOptionContext>(_ctx, getState());
  enterRule(_localctx, 262, GreenPlumParser::RuleTab_partition_elemOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2609);
    tab_partition_boundary_spec();
    setState(2611);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TABLESPACE

    || _la == GreenPlumParser::WITH) {
      setState(2610);
      opt_tab_partition_storage_attr();
    }
    setState(2614);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::COLUMN

    || _la == GreenPlumParser::DEFAULT) {
      setState(2613);
      tab_partition_column_enc_list();
    }
    setState(2617);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(2616);
      opt_tab_sub_partition_spec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_name_declContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_name_declContext::Tab_partition_name_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_partition_name_declContext::PARTITION() {
  return getToken(GreenPlumParser::PARTITION, 0);
}

GreenPlumParser::Partition_colidContext* GreenPlumParser::Tab_partition_name_declContext::partition_colid() {
  return getRuleContext<GreenPlumParser::Partition_colidContext>(0);
}


size_t GreenPlumParser::Tab_partition_name_declContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_name_decl;
}

void GreenPlumParser::Tab_partition_name_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_name_decl(this);
}

void GreenPlumParser::Tab_partition_name_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_name_decl(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_name_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_name_decl(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_name_declContext* GreenPlumParser::tab_partition_name_decl() {
  Tab_partition_name_declContext *_localctx = _tracker.createInstance<Tab_partition_name_declContext>(_ctx, getState());
  enterRule(_localctx, 264, GreenPlumParser::RuleTab_partition_name_decl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2619);
    match(GreenPlumParser::PARTITION);
    setState(2620);
    partition_colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_default_name_declContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_default_name_declContext::Tab_partition_default_name_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_partition_default_name_declContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_default_name_declContext::PARTITION() {
  return getToken(GreenPlumParser::PARTITION, 0);
}

GreenPlumParser::Partition_colidContext* GreenPlumParser::Tab_partition_default_name_declContext::partition_colid() {
  return getRuleContext<GreenPlumParser::Partition_colidContext>(0);
}


size_t GreenPlumParser::Tab_partition_default_name_declContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_default_name_decl;
}

void GreenPlumParser::Tab_partition_default_name_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_default_name_decl(this);
}

void GreenPlumParser::Tab_partition_default_name_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_default_name_decl(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_default_name_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_default_name_decl(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_default_name_declContext* GreenPlumParser::tab_partition_default_name_decl() {
  Tab_partition_default_name_declContext *_localctx = _tracker.createInstance<Tab_partition_default_name_declContext>(_ctx, getState());
  enterRule(_localctx, 266, GreenPlumParser::RuleTab_partition_default_name_decl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2622);
    match(GreenPlumParser::DEFAULT);
    setState(2623);
    match(GreenPlumParser::PARTITION);
    setState(2624);
    partition_colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_sub_partition_name_declContext ------------------------------------------------------------------

GreenPlumParser::Tab_sub_partition_name_declContext::Tab_sub_partition_name_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_name_declContext::SUBPARTITION() {
  return getToken(GreenPlumParser::SUBPARTITION, 0);
}

GreenPlumParser::Partition_colidContext* GreenPlumParser::Tab_sub_partition_name_declContext::partition_colid() {
  return getRuleContext<GreenPlumParser::Partition_colidContext>(0);
}


size_t GreenPlumParser::Tab_sub_partition_name_declContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_sub_partition_name_decl;
}

void GreenPlumParser::Tab_sub_partition_name_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_sub_partition_name_decl(this);
}

void GreenPlumParser::Tab_sub_partition_name_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_sub_partition_name_decl(this);
}


antlrcpp::Any GreenPlumParser::Tab_sub_partition_name_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_sub_partition_name_decl(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_sub_partition_name_declContext* GreenPlumParser::tab_sub_partition_name_decl() {
  Tab_sub_partition_name_declContext *_localctx = _tracker.createInstance<Tab_sub_partition_name_declContext>(_ctx, getState());
  enterRule(_localctx, 268, GreenPlumParser::RuleTab_sub_partition_name_decl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2626);
    match(GreenPlumParser::SUBPARTITION);
    setState(2627);
    partition_colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_sub_partition_default_name_declContext ------------------------------------------------------------------

GreenPlumParser::Tab_sub_partition_default_name_declContext::Tab_sub_partition_default_name_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_default_name_declContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_default_name_declContext::SUBPARTITION() {
  return getToken(GreenPlumParser::SUBPARTITION, 0);
}

GreenPlumParser::Partition_colidContext* GreenPlumParser::Tab_sub_partition_default_name_declContext::partition_colid() {
  return getRuleContext<GreenPlumParser::Partition_colidContext>(0);
}


size_t GreenPlumParser::Tab_sub_partition_default_name_declContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_sub_partition_default_name_decl;
}

void GreenPlumParser::Tab_sub_partition_default_name_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_sub_partition_default_name_decl(this);
}

void GreenPlumParser::Tab_sub_partition_default_name_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_sub_partition_default_name_decl(this);
}


antlrcpp::Any GreenPlumParser::Tab_sub_partition_default_name_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_sub_partition_default_name_decl(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_sub_partition_default_name_declContext* GreenPlumParser::tab_sub_partition_default_name_decl() {
  Tab_sub_partition_default_name_declContext *_localctx = _tracker.createInstance<Tab_sub_partition_default_name_declContext>(_ctx, getState());
  enterRule(_localctx, 270, GreenPlumParser::RuleTab_sub_partition_default_name_decl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2629);
    match(GreenPlumParser::DEFAULT);
    setState(2630);
    match(GreenPlumParser::SUBPARTITION);
    setState(2631);
    partition_colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_partition_by_typeContext ------------------------------------------------------------------

GreenPlumParser::Tab_partition_by_typeContext::Tab_partition_by_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_partition_by_typeContext::RANGE() {
  return getToken(GreenPlumParser::RANGE, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_by_typeContext::HASH() {
  return getToken(GreenPlumParser::HASH, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_partition_by_typeContext::LIST() {
  return getToken(GreenPlumParser::LIST, 0);
}


size_t GreenPlumParser::Tab_partition_by_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_partition_by_type;
}

void GreenPlumParser::Tab_partition_by_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_partition_by_type(this);
}

void GreenPlumParser::Tab_partition_by_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_partition_by_type(this);
}


antlrcpp::Any GreenPlumParser::Tab_partition_by_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_partition_by_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_partition_by_typeContext* GreenPlumParser::tab_partition_by_type() {
  Tab_partition_by_typeContext *_localctx = _tracker.createInstance<Tab_partition_by_typeContext>(_ctx, getState());
  enterRule(_localctx, 272, GreenPlumParser::RuleTab_partition_by_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2633);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::HASH

    || _la == GreenPlumParser::LIST || _la == GreenPlumParser::RANGE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tab_partition_byContext ------------------------------------------------------------------

GreenPlumParser::Opt_tab_partition_byContext::Opt_tab_partition_byContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_byContext::PARTITION() {
  return getToken(GreenPlumParser::PARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tab_partition_byContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Opt_tab_partition_byContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}

GreenPlumParser::Tab_partition_by_typeContext* GreenPlumParser::Opt_tab_partition_byContext::tab_partition_by_type() {
  return getRuleContext<GreenPlumParser::Tab_partition_by_typeContext>(0);
}

GreenPlumParser::Opt_partitions_numberContext* GreenPlumParser::Opt_tab_partition_byContext::opt_partitions_number() {
  return getRuleContext<GreenPlumParser::Opt_partitions_numberContext>(0);
}

GreenPlumParser::Tab_sub_partition_by_listContext* GreenPlumParser::Opt_tab_partition_byContext::tab_sub_partition_by_list() {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_by_listContext>(0);
}

GreenPlumParser::Opt_tab_partition_specContext* GreenPlumParser::Opt_tab_partition_byContext::opt_tab_partition_spec() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_specContext>(0);
}


size_t GreenPlumParser::Opt_tab_partition_byContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_tab_partition_by;
}

void GreenPlumParser::Opt_tab_partition_byContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tab_partition_by(this);
}

void GreenPlumParser::Opt_tab_partition_byContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tab_partition_by(this);
}


antlrcpp::Any GreenPlumParser::Opt_tab_partition_byContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_tab_partition_by(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tab_partition_byContext* GreenPlumParser::opt_tab_partition_by() {
  Opt_tab_partition_byContext *_localctx = _tracker.createInstance<Opt_tab_partition_byContext>(_ctx, getState());
  enterRule(_localctx, 274, GreenPlumParser::RuleOpt_tab_partition_by);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2635);
    match(GreenPlumParser::PARTITION);
    setState(2636);
    match(GreenPlumParser::BY);
    setState(2638);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::HASH

    || _la == GreenPlumParser::LIST || _la == GreenPlumParser::RANGE) {
      setState(2637);
      tab_partition_by_type();
    }
    setState(2640);
    paren_column_list();
    setState(2642);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PARTITIONS || _la == GreenPlumParser::SUBPARTITIONS) {
      setState(2641);
      opt_partitions_number();
    }
    setState(2645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::SUBPARTITION) {
      setState(2644);
      tab_sub_partition_by_list();
    }
    setState(2648);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(2647);
      opt_tab_partition_spec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_sub_partition_by_listContext ------------------------------------------------------------------

GreenPlumParser::Tab_sub_partition_by_listContext::Tab_sub_partition_by_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Tab_sub_partition_byContext *> GreenPlumParser::Tab_sub_partition_by_listContext::tab_sub_partition_by() {
  return getRuleContexts<GreenPlumParser::Tab_sub_partition_byContext>();
}

GreenPlumParser::Tab_sub_partition_byContext* GreenPlumParser::Tab_sub_partition_by_listContext::tab_sub_partition_by(size_t i) {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_byContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Tab_sub_partition_by_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_by_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Tab_sub_partition_by_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_sub_partition_by_list;
}

void GreenPlumParser::Tab_sub_partition_by_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_sub_partition_by_list(this);
}

void GreenPlumParser::Tab_sub_partition_by_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_sub_partition_by_list(this);
}


antlrcpp::Any GreenPlumParser::Tab_sub_partition_by_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_sub_partition_by_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_sub_partition_by_listContext* GreenPlumParser::tab_sub_partition_by_list() {
  Tab_sub_partition_by_listContext *_localctx = _tracker.createInstance<Tab_sub_partition_by_listContext>(_ctx, getState());
  enterRule(_localctx, 276, GreenPlumParser::RuleTab_sub_partition_by_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2650);
    tab_sub_partition_by();
    setState(2657);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::SUBPARTITION || _la == GreenPlumParser::COMMA) {
      setState(2652);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COMMA) {
        setState(2651);
        match(GreenPlumParser::COMMA);
      }
      setState(2654);
      tab_sub_partition_by();
      setState(2659);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_sub_partition_templateContext ------------------------------------------------------------------

GreenPlumParser::Tab_sub_partition_templateContext::Tab_sub_partition_templateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_templateContext::SUBPARTITION() {
  return getToken(GreenPlumParser::SUBPARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_templateContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_templateContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Tab_sub_partition_elem_listContext* GreenPlumParser::Tab_sub_partition_templateContext::tab_sub_partition_elem_list() {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_elem_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_templateContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Tab_sub_partition_templateContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_sub_partition_template;
}

void GreenPlumParser::Tab_sub_partition_templateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_sub_partition_template(this);
}

void GreenPlumParser::Tab_sub_partition_templateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_sub_partition_template(this);
}


antlrcpp::Any GreenPlumParser::Tab_sub_partition_templateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_sub_partition_template(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_sub_partition_templateContext* GreenPlumParser::tab_sub_partition_template() {
  Tab_sub_partition_templateContext *_localctx = _tracker.createInstance<Tab_sub_partition_templateContext>(_ctx, getState());
  enterRule(_localctx, 278, GreenPlumParser::RuleTab_sub_partition_template);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2660);
    match(GreenPlumParser::SUBPARTITION);
    setState(2661);
    match(GreenPlumParser::TEMPLATE);
    setState(2662);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2663);
    tab_sub_partition_elem_list();
    setState(2664);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tab_sub_partition_byContext ------------------------------------------------------------------

GreenPlumParser::Tab_sub_partition_byContext::Tab_sub_partition_byContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_byContext::SUBPARTITION() {
  return getToken(GreenPlumParser::SUBPARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Tab_sub_partition_byContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Tab_partition_by_typeContext* GreenPlumParser::Tab_sub_partition_byContext::tab_partition_by_type() {
  return getRuleContext<GreenPlumParser::Tab_partition_by_typeContext>(0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Tab_sub_partition_byContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}

GreenPlumParser::Opt_partitions_numberContext* GreenPlumParser::Tab_sub_partition_byContext::opt_partitions_number() {
  return getRuleContext<GreenPlumParser::Opt_partitions_numberContext>(0);
}

GreenPlumParser::Tab_sub_partition_templateContext* GreenPlumParser::Tab_sub_partition_byContext::tab_sub_partition_template() {
  return getRuleContext<GreenPlumParser::Tab_sub_partition_templateContext>(0);
}


size_t GreenPlumParser::Tab_sub_partition_byContext::getRuleIndex() const {
  return GreenPlumParser::RuleTab_sub_partition_by;
}

void GreenPlumParser::Tab_sub_partition_byContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTab_sub_partition_by(this);
}

void GreenPlumParser::Tab_sub_partition_byContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTab_sub_partition_by(this);
}


antlrcpp::Any GreenPlumParser::Tab_sub_partition_byContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTab_sub_partition_by(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Tab_sub_partition_byContext* GreenPlumParser::tab_sub_partition_by() {
  Tab_sub_partition_byContext *_localctx = _tracker.createInstance<Tab_sub_partition_byContext>(_ctx, getState());
  enterRule(_localctx, 280, GreenPlumParser::RuleTab_sub_partition_by);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2674);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2666);
      match(GreenPlumParser::SUBPARTITION);
      setState(2667);
      match(GreenPlumParser::BY);
      setState(2668);
      tab_partition_by_type();
      setState(2669);
      paren_column_list();
      setState(2671);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PARTITIONS || _la == GreenPlumParser::SUBPARTITIONS) {
        setState(2670);
        opt_partitions_number();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2673);
      tab_sub_partition_template();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_partitions_numberContext ------------------------------------------------------------------

GreenPlumParser::Opt_partitions_numberContext::Opt_partitions_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Integer_onlyContext* GreenPlumParser::Opt_partitions_numberContext::integer_only() {
  return getRuleContext<GreenPlumParser::Integer_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_partitions_numberContext::PARTITIONS() {
  return getToken(GreenPlumParser::PARTITIONS, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_partitions_numberContext::SUBPARTITIONS() {
  return getToken(GreenPlumParser::SUBPARTITIONS, 0);
}


size_t GreenPlumParser::Opt_partitions_numberContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_partitions_number;
}

void GreenPlumParser::Opt_partitions_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_partitions_number(this);
}

void GreenPlumParser::Opt_partitions_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_partitions_number(this);
}


antlrcpp::Any GreenPlumParser::Opt_partitions_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_partitions_number(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_partitions_numberContext* GreenPlumParser::opt_partitions_number() {
  Opt_partitions_numberContext *_localctx = _tracker.createInstance<Opt_partitions_numberContext>(_ctx, getState());
  enterRule(_localctx, 282, GreenPlumParser::RuleOpt_partitions_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2676);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::PARTITIONS || _la == GreenPlumParser::SUBPARTITIONS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2677);
    integer_only();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_as_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_as_stmtContext::Create_as_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_as_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_as_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Create_as_targetContext* GreenPlumParser::Create_as_stmtContext::create_as_target() {
  return getRuleContext<GreenPlumParser::Create_as_targetContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_as_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Create_as_stmtContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

GreenPlumParser::Opt_tempContext* GreenPlumParser::Create_as_stmtContext::opt_temp() {
  return getRuleContext<GreenPlumParser::Opt_tempContext>(0);
}

GreenPlumParser::Opt_with_dataContext* GreenPlumParser::Create_as_stmtContext::opt_with_data() {
  return getRuleContext<GreenPlumParser::Opt_with_dataContext>(0);
}

GreenPlumParser::Opt_distributed_byContext* GreenPlumParser::Create_as_stmtContext::opt_distributed_by() {
  return getRuleContext<GreenPlumParser::Opt_distributed_byContext>(0);
}

GreenPlumParser::Opt_tab_partition_byContext* GreenPlumParser::Create_as_stmtContext::opt_tab_partition_by() {
  return getRuleContext<GreenPlumParser::Opt_tab_partition_byContext>(0);
}


size_t GreenPlumParser::Create_as_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_as_stmt;
}

void GreenPlumParser::Create_as_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_as_stmt(this);
}

void GreenPlumParser::Create_as_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_as_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_as_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_as_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_as_stmtContext* GreenPlumParser::create_as_stmt() {
  Create_as_stmtContext *_localctx = _tracker.createInstance<Create_as_stmtContext>(_ctx, getState());
  enterRule(_localctx, 284, GreenPlumParser::RuleCreate_as_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2679);
    match(GreenPlumParser::CREATE);
    setState(2681);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GLOBAL

    || _la == GreenPlumParser::LOCAL || _la == GreenPlumParser::TEMP

    || _la == GreenPlumParser::TEMPORARY) {
      setState(2680);
      opt_temp();
    }
    setState(2683);
    match(GreenPlumParser::TABLE);
    setState(2684);
    create_as_target();
    setState(2685);
    match(GreenPlumParser::AS);
    setState(2686);
    select_stmt();
    setState(2688);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(2687);
      opt_with_data();
    }
    setState(2691);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DISTRIBUTED) {
      setState(2690);
      opt_distributed_by();
    }
    setState(2694);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PARTITION) {
      setState(2693);
      opt_tab_partition_by();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_as_targetContext ------------------------------------------------------------------

GreenPlumParser::Create_as_targetContext::Create_as_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Create_as_targetContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Opt_create_asContext* GreenPlumParser::Create_as_targetContext::opt_create_as() {
  return getRuleContext<GreenPlumParser::Opt_create_asContext>(0);
}

GreenPlumParser::Opt_with_def_oidsContext* GreenPlumParser::Create_as_targetContext::opt_with_def_oids() {
  return getRuleContext<GreenPlumParser::Opt_with_def_oidsContext>(0);
}

GreenPlumParser::On_commit_optionContext* GreenPlumParser::Create_as_targetContext::on_commit_option() {
  return getRuleContext<GreenPlumParser::On_commit_optionContext>(0);
}

GreenPlumParser::Opt_table_spaceContext* GreenPlumParser::Create_as_targetContext::opt_table_space() {
  return getRuleContext<GreenPlumParser::Opt_table_spaceContext>(0);
}


size_t GreenPlumParser::Create_as_targetContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_as_target;
}

void GreenPlumParser::Create_as_targetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_as_target(this);
}

void GreenPlumParser::Create_as_targetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_as_target(this);
}


antlrcpp::Any GreenPlumParser::Create_as_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_as_target(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_as_targetContext* GreenPlumParser::create_as_target() {
  Create_as_targetContext *_localctx = _tracker.createInstance<Create_as_targetContext>(_ctx, getState());
  enterRule(_localctx, 286, GreenPlumParser::RuleCreate_as_target);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2696);
    qualified_name();
    setState(2698);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(2697);
      opt_create_as();
    }
    setState(2701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT) {
      setState(2700);
      opt_with_def_oids();
    }
    setState(2704);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ON) {
      setState(2703);
      on_commit_option();
    }
    setState(2707);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TABLESPACE) {
      setState(2706);
      opt_table_space();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_create_asContext ------------------------------------------------------------------

GreenPlumParser::Opt_create_asContext::Opt_create_asContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_create_asContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Create_as_listContext* GreenPlumParser::Opt_create_asContext::create_as_list() {
  return getRuleContext<GreenPlumParser::Create_as_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_create_asContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Opt_create_asContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_create_as;
}

void GreenPlumParser::Opt_create_asContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_create_as(this);
}

void GreenPlumParser::Opt_create_asContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_create_as(this);
}


antlrcpp::Any GreenPlumParser::Opt_create_asContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_create_as(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_create_asContext* GreenPlumParser::opt_create_as() {
  Opt_create_asContext *_localctx = _tracker.createInstance<Opt_create_asContext>(_ctx, getState());
  enterRule(_localctx, 288, GreenPlumParser::RuleOpt_create_as);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2709);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2710);
    create_as_list();
    setState(2711);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_as_listContext ------------------------------------------------------------------

GreenPlumParser::Create_as_listContext::Create_as_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Create_as_elementContext *> GreenPlumParser::Create_as_listContext::create_as_element() {
  return getRuleContexts<GreenPlumParser::Create_as_elementContext>();
}

GreenPlumParser::Create_as_elementContext* GreenPlumParser::Create_as_listContext::create_as_element(size_t i) {
  return getRuleContext<GreenPlumParser::Create_as_elementContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Create_as_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Create_as_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Create_as_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_as_list;
}

void GreenPlumParser::Create_as_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_as_list(this);
}

void GreenPlumParser::Create_as_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_as_list(this);
}


antlrcpp::Any GreenPlumParser::Create_as_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_as_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_as_listContext* GreenPlumParser::create_as_list() {
  Create_as_listContext *_localctx = _tracker.createInstance<Create_as_listContext>(_ctx, getState());
  enterRule(_localctx, 290, GreenPlumParser::RuleCreate_as_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2713);
    create_as_element();
    setState(2718);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2714);
      match(GreenPlumParser::COMMA);
      setState(2715);
      create_as_element();
      setState(2720);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_as_elementContext ------------------------------------------------------------------

GreenPlumParser::Create_as_elementContext::Create_as_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Create_as_elementContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Create_as_elementContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_as_element;
}

void GreenPlumParser::Create_as_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_as_element(this);
}

void GreenPlumParser::Create_as_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_as_element(this);
}


antlrcpp::Any GreenPlumParser::Create_as_elementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_as_element(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_as_elementContext* GreenPlumParser::create_as_element() {
  Create_as_elementContext *_localctx = _tracker.createInstance<Create_as_elementContext>(_ctx, getState());
  enterRule(_localctx, 292, GreenPlumParser::RuleCreate_as_element);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2721);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_with_dataContext ------------------------------------------------------------------

GreenPlumParser::Opt_with_dataContext::Opt_with_dataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_with_dataContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_with_dataContext::DATA_P() {
  return getToken(GreenPlumParser::DATA_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_with_dataContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}


size_t GreenPlumParser::Opt_with_dataContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_with_data;
}

void GreenPlumParser::Opt_with_dataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_with_data(this);
}

void GreenPlumParser::Opt_with_dataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_with_data(this);
}


antlrcpp::Any GreenPlumParser::Opt_with_dataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_with_data(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_with_dataContext* GreenPlumParser::opt_with_data() {
  Opt_with_dataContext *_localctx = _tracker.createInstance<Opt_with_dataContext>(_ctx, getState());
  enterRule(_localctx, 294, GreenPlumParser::RuleOpt_with_data);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2723);
      match(GreenPlumParser::WITH);
      setState(2725);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NO) {
        setState(2724);
        match(GreenPlumParser::NO);
      }
      setState(2727);
      match(GreenPlumParser::DATA_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2728);
      match(GreenPlumParser::WITH);
      setState(2729);
      match(GreenPlumParser::NO);
      setState(2730);
      match(GreenPlumParser::DATA_P);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_external_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_external_stmtContext::Create_external_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_external_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_external_stmtContext::EXTERNAL() {
  return getToken(GreenPlumParser::EXTERNAL, 0);
}

tree::TerminalNode* GreenPlumParser::Create_external_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Create_external_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_external_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Create_external_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Ext_type_descContext* GreenPlumParser::Create_external_stmtContext::ext_type_desc() {
  return getRuleContext<GreenPlumParser::Ext_type_descContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_external_stmtContext::FORMAT() {
  return getToken(GreenPlumParser::FORMAT, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Create_external_stmtContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

GreenPlumParser::Opt_writableContext* GreenPlumParser::Create_external_stmtContext::opt_writable() {
  return getRuleContext<GreenPlumParser::Opt_writableContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_external_stmtContext::WEB() {
  return getToken(GreenPlumParser::WEB, 0);
}

GreenPlumParser::Opt_tempContext* GreenPlumParser::Create_external_stmtContext::opt_temp() {
  return getRuleContext<GreenPlumParser::Opt_tempContext>(0);
}

GreenPlumParser::Ext_table_element_listContext* GreenPlumParser::Create_external_stmtContext::ext_table_element_list() {
  return getRuleContext<GreenPlumParser::Ext_table_element_listContext>(0);
}

GreenPlumParser::Format_optContext* GreenPlumParser::Create_external_stmtContext::format_opt() {
  return getRuleContext<GreenPlumParser::Format_optContext>(0);
}

GreenPlumParser::Ext_options_optContext* GreenPlumParser::Create_external_stmtContext::ext_options_opt() {
  return getRuleContext<GreenPlumParser::Ext_options_optContext>(0);
}

GreenPlumParser::Ext_opt_encoding_listContext* GreenPlumParser::Create_external_stmtContext::ext_opt_encoding_list() {
  return getRuleContext<GreenPlumParser::Ext_opt_encoding_listContext>(0);
}

GreenPlumParser::Opt_single_row_error_handlingContext* GreenPlumParser::Create_external_stmtContext::opt_single_row_error_handling() {
  return getRuleContext<GreenPlumParser::Opt_single_row_error_handlingContext>(0);
}

GreenPlumParser::Opt_distributed_byContext* GreenPlumParser::Create_external_stmtContext::opt_distributed_by() {
  return getRuleContext<GreenPlumParser::Opt_distributed_byContext>(0);
}


size_t GreenPlumParser::Create_external_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_external_stmt;
}

void GreenPlumParser::Create_external_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_external_stmt(this);
}

void GreenPlumParser::Create_external_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_external_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_external_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_external_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_external_stmtContext* GreenPlumParser::create_external_stmt() {
  Create_external_stmtContext *_localctx = _tracker.createInstance<Create_external_stmtContext>(_ctx, getState());
  enterRule(_localctx, 296, GreenPlumParser::RuleCreate_external_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2733);
    match(GreenPlumParser::CREATE);
    setState(2735);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::READABLE || _la == GreenPlumParser::WRITABLE) {
      setState(2734);
      opt_writable();
    }
    setState(2737);
    match(GreenPlumParser::EXTERNAL);
    setState(2739);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WEB) {
      setState(2738);
      match(GreenPlumParser::WEB);
    }
    setState(2742);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GLOBAL

    || _la == GreenPlumParser::LOCAL || _la == GreenPlumParser::TEMP

    || _la == GreenPlumParser::TEMPORARY) {
      setState(2741);
      opt_temp();
    }
    setState(2744);
    match(GreenPlumParser::TABLE);
    setState(2745);
    qualified_name();
    setState(2746);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2748);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIKE - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
      setState(2747);
      ext_table_element_list();
    }
    setState(2750);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(2751);
    ext_type_desc();
    setState(2752);
    match(GreenPlumParser::FORMAT);
    setState(2753);
    sconst();
    setState(2755);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(2754);
      format_opt();
    }
    setState(2758);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::OPTIONS) {
      setState(2757);
      ext_options_opt();
    }
    setState(2761);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ENCODING) {
      setState(2760);
      ext_opt_encoding_list();
    }
    setState(2764);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LOG_P || _la == GreenPlumParser::SEGMENT) {
      setState(2763);
      opt_single_row_error_handling();
    }
    setState(2767);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DISTRIBUTED) {
      setState(2766);
      opt_distributed_by();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_writableContext ------------------------------------------------------------------

GreenPlumParser::Opt_writableContext::Opt_writableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_writableContext::WRITABLE() {
  return getToken(GreenPlumParser::WRITABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_writableContext::READABLE() {
  return getToken(GreenPlumParser::READABLE, 0);
}


size_t GreenPlumParser::Opt_writableContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_writable;
}

void GreenPlumParser::Opt_writableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_writable(this);
}

void GreenPlumParser::Opt_writableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_writable(this);
}


antlrcpp::Any GreenPlumParser::Opt_writableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_writable(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_writableContext* GreenPlumParser::opt_writable() {
  Opt_writableContext *_localctx = _tracker.createInstance<Opt_writableContext>(_ctx, getState());
  enterRule(_localctx, 298, GreenPlumParser::RuleOpt_writable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2769);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::READABLE || _la == GreenPlumParser::WRITABLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_type_descContext ------------------------------------------------------------------

GreenPlumParser::Ext_type_descContext::Ext_type_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Ext_type_descContext::LOCATION() {
  return getToken(GreenPlumParser::LOCATION, 0);
}

tree::TerminalNode* GreenPlumParser::Ext_type_descContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Cdb_string_listContext* GreenPlumParser::Ext_type_descContext::cdb_string_list() {
  return getRuleContext<GreenPlumParser::Cdb_string_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Ext_type_descContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

std::vector<GreenPlumParser::Ext_on_clause_itemContext *> GreenPlumParser::Ext_type_descContext::ext_on_clause_item() {
  return getRuleContexts<GreenPlumParser::Ext_on_clause_itemContext>();
}

GreenPlumParser::Ext_on_clause_itemContext* GreenPlumParser::Ext_type_descContext::ext_on_clause_item(size_t i) {
  return getRuleContext<GreenPlumParser::Ext_on_clause_itemContext>(i);
}

tree::TerminalNode* GreenPlumParser::Ext_type_descContext::EXECUTE() {
  return getToken(GreenPlumParser::EXECUTE, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Ext_type_descContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::Ext_type_descContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_type_desc;
}

void GreenPlumParser::Ext_type_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_type_desc(this);
}

void GreenPlumParser::Ext_type_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_type_desc(this);
}


antlrcpp::Any GreenPlumParser::Ext_type_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_type_desc(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_type_descContext* GreenPlumParser::ext_type_desc() {
  Ext_type_descContext *_localctx = _tracker.createInstance<Ext_type_descContext>(_ctx, getState());
  enterRule(_localctx, 300, GreenPlumParser::RuleExt_type_desc);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2789);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::LOCATION: {
        enterOuterAlt(_localctx, 1);
        setState(2771);
        match(GreenPlumParser::LOCATION);
        setState(2772);
        match(GreenPlumParser::LEFT_PAREN);
        setState(2773);
        cdb_string_list();
        setState(2774);
        match(GreenPlumParser::RIGHT_PAREN);
        setState(2778);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == GreenPlumParser::ON) {
          setState(2775);
          ext_on_clause_item();
          setState(2780);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case GreenPlumParser::EXECUTE: {
        enterOuterAlt(_localctx, 2);
        setState(2781);
        match(GreenPlumParser::EXECUTE);
        setState(2782);
        sconst();
        setState(2786);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == GreenPlumParser::ON) {
          setState(2783);
          ext_on_clause_item();
          setState(2788);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_on_clause_itemContext ------------------------------------------------------------------

GreenPlumParser::Ext_on_clause_itemContext::Ext_on_clause_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Ext_on_clause_itemContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Ext_on_clause_itemContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

tree::TerminalNode* GreenPlumParser::Ext_on_clause_itemContext::HOST() {
  return getToken(GreenPlumParser::HOST, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Ext_on_clause_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Ext_on_clause_itemContext::MASTER() {
  return getToken(GreenPlumParser::MASTER, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Ext_on_clause_itemContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Ext_on_clause_itemContext::SEGMENT() {
  return getToken(GreenPlumParser::SEGMENT, 0);
}


size_t GreenPlumParser::Ext_on_clause_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_on_clause_item;
}

void GreenPlumParser::Ext_on_clause_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_on_clause_item(this);
}

void GreenPlumParser::Ext_on_clause_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_on_clause_item(this);
}


antlrcpp::Any GreenPlumParser::Ext_on_clause_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_on_clause_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_on_clause_itemContext* GreenPlumParser::ext_on_clause_item() {
  Ext_on_clause_itemContext *_localctx = _tracker.createInstance<Ext_on_clause_itemContext>(_ctx, getState());
  enterRule(_localctx, 302, GreenPlumParser::RuleExt_on_clause_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2805);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2791);
      match(GreenPlumParser::ON);
      setState(2792);
      match(GreenPlumParser::ALL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2793);
      match(GreenPlumParser::ON);
      setState(2794);
      match(GreenPlumParser::HOST);
      setState(2796);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 501) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 501)) & ((1ULL << (GreenPlumParser::CHAR_STRING - 501))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 501))
        | (1ULL << (GreenPlumParser::SCONST - 501)))) != 0)) {
        setState(2795);
        sconst();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2798);
      match(GreenPlumParser::ON);
      setState(2799);
      match(GreenPlumParser::MASTER);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2800);
      match(GreenPlumParser::ON);
      setState(2802);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::SEGMENT) {
        setState(2801);
        match(GreenPlumParser::SEGMENT);
      }
      setState(2804);
      iconst();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Double_parensContext ------------------------------------------------------------------

GreenPlumParser::Double_parensContext::Double_parensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Double_parensContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Double_parensContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Double_parensContext::getRuleIndex() const {
  return GreenPlumParser::RuleDouble_parens;
}

void GreenPlumParser::Double_parensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDouble_parens(this);
}

void GreenPlumParser::Double_parensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDouble_parens(this);
}


antlrcpp::Any GreenPlumParser::Double_parensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDouble_parens(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Double_parensContext* GreenPlumParser::double_parens() {
  Double_parensContext *_localctx = _tracker.createInstance<Double_parensContext>(_ctx, getState());
  enterRule(_localctx, 304, GreenPlumParser::RuleDouble_parens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2807);
    match(GreenPlumParser::LEFT_PAREN);
    setState(2808);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Format_optContext ------------------------------------------------------------------

GreenPlumParser::Format_optContext::Format_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Format_optContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Format_opt_listContext* GreenPlumParser::Format_optContext::format_opt_list() {
  return getRuleContext<GreenPlumParser::Format_opt_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Format_optContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Format_def_listContext* GreenPlumParser::Format_optContext::format_def_list() {
  return getRuleContext<GreenPlumParser::Format_def_listContext>(0);
}

GreenPlumParser::Double_parensContext* GreenPlumParser::Format_optContext::double_parens() {
  return getRuleContext<GreenPlumParser::Double_parensContext>(0);
}


size_t GreenPlumParser::Format_optContext::getRuleIndex() const {
  return GreenPlumParser::RuleFormat_opt;
}

void GreenPlumParser::Format_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormat_opt(this);
}

void GreenPlumParser::Format_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormat_opt(this);
}


antlrcpp::Any GreenPlumParser::Format_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFormat_opt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Format_optContext* GreenPlumParser::format_opt() {
  Format_optContext *_localctx = _tracker.createInstance<Format_optContext>(_ctx, getState());
  enterRule(_localctx, 306, GreenPlumParser::RuleFormat_opt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2819);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2810);
      match(GreenPlumParser::LEFT_PAREN);
      setState(2811);
      format_opt_list();
      setState(2812);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2814);
      match(GreenPlumParser::LEFT_PAREN);
      setState(2815);
      format_def_list();
      setState(2816);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2818);
      double_parens();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Format_opt_listContext ------------------------------------------------------------------

GreenPlumParser::Format_opt_listContext::Format_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Format_opt_itemContext *> GreenPlumParser::Format_opt_listContext::format_opt_item() {
  return getRuleContexts<GreenPlumParser::Format_opt_itemContext>();
}

GreenPlumParser::Format_opt_itemContext* GreenPlumParser::Format_opt_listContext::format_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Format_opt_itemContext>(i);
}


size_t GreenPlumParser::Format_opt_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFormat_opt_list;
}

void GreenPlumParser::Format_opt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormat_opt_list(this);
}

void GreenPlumParser::Format_opt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormat_opt_list(this);
}


antlrcpp::Any GreenPlumParser::Format_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFormat_opt_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Format_opt_listContext* GreenPlumParser::format_opt_list() {
  Format_opt_listContext *_localctx = _tracker.createInstance<Format_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 308, GreenPlumParser::RuleFormat_opt_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2822); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2821);
      format_opt_item();
      setState(2824); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (GreenPlumParser::CSV - 79))
      | (1ULL << (GreenPlumParser::DELIMITER - 79))
      | (1ULL << (GreenPlumParser::ESCAPE - 79)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 146)) & ((1ULL << (GreenPlumParser::FILL - 146))
      | (1ULL << (GreenPlumParser::FORCE - 146))
      | (1ULL << (GreenPlumParser::HEADER_P - 146)))) != 0) || _la == GreenPlumParser::NULL_P

    || _la == GreenPlumParser::QUOTE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Format_def_listContext ------------------------------------------------------------------

GreenPlumParser::Format_def_listContext::Format_def_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Format_def_itemContext *> GreenPlumParser::Format_def_listContext::format_def_item() {
  return getRuleContexts<GreenPlumParser::Format_def_itemContext>();
}

GreenPlumParser::Format_def_itemContext* GreenPlumParser::Format_def_listContext::format_def_item(size_t i) {
  return getRuleContext<GreenPlumParser::Format_def_itemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Format_def_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Format_def_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Format_def_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFormat_def_list;
}

void GreenPlumParser::Format_def_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormat_def_list(this);
}

void GreenPlumParser::Format_def_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormat_def_list(this);
}


antlrcpp::Any GreenPlumParser::Format_def_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFormat_def_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Format_def_listContext* GreenPlumParser::format_def_list() {
  Format_def_listContext *_localctx = _tracker.createInstance<Format_def_listContext>(_ctx, getState());
  enterRule(_localctx, 310, GreenPlumParser::RuleFormat_def_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2826);
    format_def_item();
    setState(2831);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2827);
      match(GreenPlumParser::COMMA);
      setState(2828);
      format_def_item();
      setState(2833);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Format_def_itemContext ------------------------------------------------------------------

GreenPlumParser::Format_def_itemContext::Format_def_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Format_def_itemContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}

tree::TerminalNode* GreenPlumParser::Format_def_itemContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

GreenPlumParser::Def_argContext* GreenPlumParser::Format_def_itemContext::def_arg() {
  return getRuleContext<GreenPlumParser::Def_argContext>(0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Format_def_itemContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}


size_t GreenPlumParser::Format_def_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleFormat_def_item;
}

void GreenPlumParser::Format_def_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormat_def_item(this);
}

void GreenPlumParser::Format_def_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormat_def_item(this);
}


antlrcpp::Any GreenPlumParser::Format_def_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFormat_def_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Format_def_itemContext* GreenPlumParser::format_def_item() {
  Format_def_itemContext *_localctx = _tracker.createInstance<Format_def_itemContext>(_ctx, getState());
  enterRule(_localctx, 312, GreenPlumParser::RuleFormat_def_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2842);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2834);
      col_label();
      setState(2835);
      match(GreenPlumParser::EQUALS_OP);
      setState(2836);
      def_arg();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2838);
      col_label();
      setState(2839);
      match(GreenPlumParser::EQUALS_OP);
      setState(2840);
      paren_column_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Format_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Format_opt_itemContext::Format_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::DELIMITER() {
  return getToken(GreenPlumParser::DELIMITER, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Format_opt_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::QUOTE() {
  return getToken(GreenPlumParser::QUOTE, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::ESCAPE() {
  return getToken(GreenPlumParser::ESCAPE, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::CSV() {
  return getToken(GreenPlumParser::CSV, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::HEADER_P() {
  return getToken(GreenPlumParser::HEADER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::FORCE() {
  return getToken(GreenPlumParser::FORCE, 0);
}

GreenPlumParser::Column_listContext* GreenPlumParser::Format_opt_itemContext::column_list() {
  return getRuleContext<GreenPlumParser::Column_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::FILL() {
  return getToken(GreenPlumParser::FILL, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::MISSING() {
  return getToken(GreenPlumParser::MISSING, 0);
}

tree::TerminalNode* GreenPlumParser::Format_opt_itemContext::FIELDS() {
  return getToken(GreenPlumParser::FIELDS, 0);
}


size_t GreenPlumParser::Format_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleFormat_opt_item;
}

void GreenPlumParser::Format_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormat_opt_item(this);
}

void GreenPlumParser::Format_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormat_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Format_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFormat_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Format_opt_itemContext* GreenPlumParser::format_opt_item() {
  Format_opt_itemContext *_localctx = _tracker.createInstance<Format_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 314, GreenPlumParser::RuleFormat_opt_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2866);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::DELIMITER: {
        enterOuterAlt(_localctx, 1);
        setState(2844);
        match(GreenPlumParser::DELIMITER);
        setState(2846);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::AS) {
          setState(2845);
          match(GreenPlumParser::AS);
        }
        setState(2848);
        sconst();
        break;
      }

      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::QUOTE: {
        enterOuterAlt(_localctx, 2);
        setState(2849);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::ESCAPE || _la == GreenPlumParser::NULL_P

        || _la == GreenPlumParser::QUOTE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2851);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::AS) {
          setState(2850);
          match(GreenPlumParser::AS);
        }
        setState(2853);
        sconst();
        break;
      }

      case GreenPlumParser::CSV: {
        enterOuterAlt(_localctx, 3);
        setState(2854);
        match(GreenPlumParser::CSV);
        break;
      }

      case GreenPlumParser::HEADER_P: {
        enterOuterAlt(_localctx, 4);
        setState(2855);
        match(GreenPlumParser::HEADER_P);
        break;
      }

      case GreenPlumParser::FORCE: {
        enterOuterAlt(_localctx, 5);
        setState(2856);
        match(GreenPlumParser::FORCE);
        setState(2860);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::NOT: {
            setState(2857);
            match(GreenPlumParser::NOT);
            setState(2858);
            match(GreenPlumParser::NULL_P);
            break;
          }

          case GreenPlumParser::QUOTE: {
            setState(2859);
            match(GreenPlumParser::QUOTE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2862);
        column_list();
        break;
      }

      case GreenPlumParser::FILL: {
        enterOuterAlt(_localctx, 6);
        setState(2863);
        match(GreenPlumParser::FILL);
        setState(2864);
        match(GreenPlumParser::MISSING);
        setState(2865);
        match(GreenPlumParser::FIELDS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_options_optContext ------------------------------------------------------------------

GreenPlumParser::Ext_options_optContext::Ext_options_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Ext_options_optContext::OPTIONS() {
  return getToken(GreenPlumParser::OPTIONS, 0);
}

GreenPlumParser::Ext_optionsContext* GreenPlumParser::Ext_options_optContext::ext_options() {
  return getRuleContext<GreenPlumParser::Ext_optionsContext>(0);
}


size_t GreenPlumParser::Ext_options_optContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_options_opt;
}

void GreenPlumParser::Ext_options_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_options_opt(this);
}

void GreenPlumParser::Ext_options_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_options_opt(this);
}


antlrcpp::Any GreenPlumParser::Ext_options_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_options_opt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_options_optContext* GreenPlumParser::ext_options_opt() {
  Ext_options_optContext *_localctx = _tracker.createInstance<Ext_options_optContext>(_ctx, getState());
  enterRule(_localctx, 316, GreenPlumParser::RuleExt_options_opt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2868);
    match(GreenPlumParser::OPTIONS);
    setState(2869);
    ext_options();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_optionsContext ------------------------------------------------------------------

GreenPlumParser::Ext_optionsContext::Ext_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Ext_optionsContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Ext_options_listContext* GreenPlumParser::Ext_optionsContext::ext_options_list() {
  return getRuleContext<GreenPlumParser::Ext_options_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Ext_optionsContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Double_parensContext* GreenPlumParser::Ext_optionsContext::double_parens() {
  return getRuleContext<GreenPlumParser::Double_parensContext>(0);
}


size_t GreenPlumParser::Ext_optionsContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_options;
}

void GreenPlumParser::Ext_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_options(this);
}

void GreenPlumParser::Ext_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_options(this);
}


antlrcpp::Any GreenPlumParser::Ext_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_options(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_optionsContext* GreenPlumParser::ext_options() {
  Ext_optionsContext *_localctx = _tracker.createInstance<Ext_optionsContext>(_ctx, getState());
  enterRule(_localctx, 318, GreenPlumParser::RuleExt_options);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2876);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2871);
      match(GreenPlumParser::LEFT_PAREN);
      setState(2872);
      ext_options_list();
      setState(2873);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2875);
      double_parens();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_options_listContext ------------------------------------------------------------------

GreenPlumParser::Ext_options_listContext::Ext_options_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Ext_options_itemContext *> GreenPlumParser::Ext_options_listContext::ext_options_item() {
  return getRuleContexts<GreenPlumParser::Ext_options_itemContext>();
}

GreenPlumParser::Ext_options_itemContext* GreenPlumParser::Ext_options_listContext::ext_options_item(size_t i) {
  return getRuleContext<GreenPlumParser::Ext_options_itemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Ext_options_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Ext_options_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Ext_options_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_options_list;
}

void GreenPlumParser::Ext_options_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_options_list(this);
}

void GreenPlumParser::Ext_options_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_options_list(this);
}


antlrcpp::Any GreenPlumParser::Ext_options_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_options_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_options_listContext* GreenPlumParser::ext_options_list() {
  Ext_options_listContext *_localctx = _tracker.createInstance<Ext_options_listContext>(_ctx, getState());
  enterRule(_localctx, 320, GreenPlumParser::RuleExt_options_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2878);
    ext_options_item();
    setState(2883);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2879);
      match(GreenPlumParser::COMMA);
      setState(2880);
      ext_options_item();
      setState(2885);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_options_itemContext ------------------------------------------------------------------

GreenPlumParser::Ext_options_itemContext::Ext_options_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Ext_options_itemContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Ext_options_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::Ext_options_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_options_item;
}

void GreenPlumParser::Ext_options_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_options_item(this);
}

void GreenPlumParser::Ext_options_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_options_item(this);
}


antlrcpp::Any GreenPlumParser::Ext_options_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_options_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_options_itemContext* GreenPlumParser::ext_options_item() {
  Ext_options_itemContext *_localctx = _tracker.createInstance<Ext_options_itemContext>(_ctx, getState());
  enterRule(_localctx, 322, GreenPlumParser::RuleExt_options_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2886);
    col_label();
    setState(2887);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_table_element_listContext ------------------------------------------------------------------

GreenPlumParser::Ext_table_element_listContext::Ext_table_element_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Ext_table_elementContext *> GreenPlumParser::Ext_table_element_listContext::ext_table_element() {
  return getRuleContexts<GreenPlumParser::Ext_table_elementContext>();
}

GreenPlumParser::Ext_table_elementContext* GreenPlumParser::Ext_table_element_listContext::ext_table_element(size_t i) {
  return getRuleContext<GreenPlumParser::Ext_table_elementContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Ext_table_element_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Ext_table_element_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Ext_table_element_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_table_element_list;
}

void GreenPlumParser::Ext_table_element_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_table_element_list(this);
}

void GreenPlumParser::Ext_table_element_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_table_element_list(this);
}


antlrcpp::Any GreenPlumParser::Ext_table_element_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_table_element_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_table_element_listContext* GreenPlumParser::ext_table_element_list() {
  Ext_table_element_listContext *_localctx = _tracker.createInstance<Ext_table_element_listContext>(_ctx, getState());
  enterRule(_localctx, 324, GreenPlumParser::RuleExt_table_element_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2889);
    ext_table_element();
    setState(2894);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(2890);
      match(GreenPlumParser::COMMA);
      setState(2891);
      ext_table_element();
      setState(2896);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_table_elementContext ------------------------------------------------------------------

GreenPlumParser::Ext_table_elementContext::Ext_table_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Ext_column_defContext* GreenPlumParser::Ext_table_elementContext::ext_column_def() {
  return getRuleContext<GreenPlumParser::Ext_column_defContext>(0);
}

GreenPlumParser::Table_like_clauseContext* GreenPlumParser::Ext_table_elementContext::table_like_clause() {
  return getRuleContext<GreenPlumParser::Table_like_clauseContext>(0);
}


size_t GreenPlumParser::Ext_table_elementContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_table_element;
}

void GreenPlumParser::Ext_table_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_table_element(this);
}

void GreenPlumParser::Ext_table_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_table_element(this);
}


antlrcpp::Any GreenPlumParser::Ext_table_elementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_table_element(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_table_elementContext* GreenPlumParser::ext_table_element() {
  Ext_table_elementContext *_localctx = _tracker.createInstance<Ext_table_elementContext>(_ctx, getState());
  enterRule(_localctx, 326, GreenPlumParser::RuleExt_table_element);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2899);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(2897);
        ext_column_def();
        break;
      }

      case GreenPlumParser::LIKE: {
        enterOuterAlt(_localctx, 2);
        setState(2898);
        table_like_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_column_defContext ------------------------------------------------------------------

GreenPlumParser::Ext_column_defContext::Ext_column_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Ext_column_defContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Ext_column_defContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}


size_t GreenPlumParser::Ext_column_defContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_column_def;
}

void GreenPlumParser::Ext_column_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_column_def(this);
}

void GreenPlumParser::Ext_column_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_column_def(this);
}


antlrcpp::Any GreenPlumParser::Ext_column_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_column_def(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_column_defContext* GreenPlumParser::ext_column_def() {
  Ext_column_defContext *_localctx = _tracker.createInstance<Ext_column_defContext>(_ctx, getState());
  enterRule(_localctx, 328, GreenPlumParser::RuleExt_column_def);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2901);
    colid();
    setState(2902);
    typename_pg();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_single_row_error_handlingContext ------------------------------------------------------------------

GreenPlumParser::Opt_single_row_error_handlingContext::Opt_single_row_error_handlingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_single_row_error_handlingContext::SEGMENT() {
  return getToken(GreenPlumParser::SEGMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_single_row_error_handlingContext::REJECT_P() {
  return getToken(GreenPlumParser::REJECT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_single_row_error_handlingContext::LIMIT() {
  return getToken(GreenPlumParser::LIMIT, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Opt_single_row_error_handlingContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

GreenPlumParser::Opt_log_error_tableContext* GreenPlumParser::Opt_single_row_error_handlingContext::opt_log_error_table() {
  return getRuleContext<GreenPlumParser::Opt_log_error_tableContext>(0);
}

GreenPlumParser::Opt_sreh_limit_typeContext* GreenPlumParser::Opt_single_row_error_handlingContext::opt_sreh_limit_type() {
  return getRuleContext<GreenPlumParser::Opt_sreh_limit_typeContext>(0);
}


size_t GreenPlumParser::Opt_single_row_error_handlingContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_single_row_error_handling;
}

void GreenPlumParser::Opt_single_row_error_handlingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_single_row_error_handling(this);
}

void GreenPlumParser::Opt_single_row_error_handlingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_single_row_error_handling(this);
}


antlrcpp::Any GreenPlumParser::Opt_single_row_error_handlingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_single_row_error_handling(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_single_row_error_handlingContext* GreenPlumParser::opt_single_row_error_handling() {
  Opt_single_row_error_handlingContext *_localctx = _tracker.createInstance<Opt_single_row_error_handlingContext>(_ctx, getState());
  enterRule(_localctx, 330, GreenPlumParser::RuleOpt_single_row_error_handling);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2905);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LOG_P) {
      setState(2904);
      opt_log_error_table();
    }
    setState(2907);
    match(GreenPlumParser::SEGMENT);
    setState(2908);
    match(GreenPlumParser::REJECT_P);
    setState(2909);
    match(GreenPlumParser::LIMIT);
    setState(2910);
    iconst();
    setState(2912);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PERCENT

    || _la == GreenPlumParser::ROWS) {
      setState(2911);
      opt_sreh_limit_type();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_log_error_tableContext ------------------------------------------------------------------

GreenPlumParser::Opt_log_error_tableContext::Opt_log_error_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_log_error_tableContext::LOG_P() {
  return getToken(GreenPlumParser::LOG_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_log_error_tableContext::ERRORS() {
  return getToken(GreenPlumParser::ERRORS, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_log_error_tableContext::INTO() {
  return getToken(GreenPlumParser::INTO, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Opt_log_error_tableContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}


size_t GreenPlumParser::Opt_log_error_tableContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_log_error_table;
}

void GreenPlumParser::Opt_log_error_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_log_error_table(this);
}

void GreenPlumParser::Opt_log_error_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_log_error_table(this);
}


antlrcpp::Any GreenPlumParser::Opt_log_error_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_log_error_table(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_log_error_tableContext* GreenPlumParser::opt_log_error_table() {
  Opt_log_error_tableContext *_localctx = _tracker.createInstance<Opt_log_error_tableContext>(_ctx, getState());
  enterRule(_localctx, 332, GreenPlumParser::RuleOpt_log_error_table);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2920);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2914);
      match(GreenPlumParser::LOG_P);
      setState(2915);
      match(GreenPlumParser::ERRORS);
      setState(2916);
      match(GreenPlumParser::INTO);
      setState(2917);
      qualified_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2918);
      match(GreenPlumParser::LOG_P);
      setState(2919);
      match(GreenPlumParser::ERRORS);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_sreh_limit_typeContext ------------------------------------------------------------------

GreenPlumParser::Opt_sreh_limit_typeContext::Opt_sreh_limit_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_sreh_limit_typeContext::ROWS() {
  return getToken(GreenPlumParser::ROWS, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_sreh_limit_typeContext::PERCENT() {
  return getToken(GreenPlumParser::PERCENT, 0);
}


size_t GreenPlumParser::Opt_sreh_limit_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_sreh_limit_type;
}

void GreenPlumParser::Opt_sreh_limit_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_sreh_limit_type(this);
}

void GreenPlumParser::Opt_sreh_limit_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_sreh_limit_type(this);
}


antlrcpp::Any GreenPlumParser::Opt_sreh_limit_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_sreh_limit_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_sreh_limit_typeContext* GreenPlumParser::opt_sreh_limit_type() {
  Opt_sreh_limit_typeContext *_localctx = _tracker.createInstance<Opt_sreh_limit_typeContext>(_ctx, getState());
  enterRule(_localctx, 334, GreenPlumParser::RuleOpt_sreh_limit_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2922);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::PERCENT

    || _la == GreenPlumParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_opt_encoding_listContext ------------------------------------------------------------------

GreenPlumParser::Ext_opt_encoding_listContext::Ext_opt_encoding_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Ext_opt_encoding_itemContext *> GreenPlumParser::Ext_opt_encoding_listContext::ext_opt_encoding_item() {
  return getRuleContexts<GreenPlumParser::Ext_opt_encoding_itemContext>();
}

GreenPlumParser::Ext_opt_encoding_itemContext* GreenPlumParser::Ext_opt_encoding_listContext::ext_opt_encoding_item(size_t i) {
  return getRuleContext<GreenPlumParser::Ext_opt_encoding_itemContext>(i);
}


size_t GreenPlumParser::Ext_opt_encoding_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_opt_encoding_list;
}

void GreenPlumParser::Ext_opt_encoding_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_opt_encoding_list(this);
}

void GreenPlumParser::Ext_opt_encoding_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_opt_encoding_list(this);
}


antlrcpp::Any GreenPlumParser::Ext_opt_encoding_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_opt_encoding_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_opt_encoding_listContext* GreenPlumParser::ext_opt_encoding_list() {
  Ext_opt_encoding_listContext *_localctx = _tracker.createInstance<Ext_opt_encoding_listContext>(_ctx, getState());
  enterRule(_localctx, 336, GreenPlumParser::RuleExt_opt_encoding_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2925); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2924);
      ext_opt_encoding_item();
      setState(2927); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == GreenPlumParser::ENCODING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ext_opt_encoding_itemContext ------------------------------------------------------------------

GreenPlumParser::Ext_opt_encoding_itemContext::Ext_opt_encoding_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Ext_opt_encoding_itemContext::ENCODING() {
  return getToken(GreenPlumParser::ENCODING, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Ext_opt_encoding_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Ext_opt_encoding_itemContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Ext_opt_encoding_itemContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}


size_t GreenPlumParser::Ext_opt_encoding_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleExt_opt_encoding_item;
}

void GreenPlumParser::Ext_opt_encoding_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExt_opt_encoding_item(this);
}

void GreenPlumParser::Ext_opt_encoding_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExt_opt_encoding_item(this);
}


antlrcpp::Any GreenPlumParser::Ext_opt_encoding_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExt_opt_encoding_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ext_opt_encoding_itemContext* GreenPlumParser::ext_opt_encoding_item() {
  Ext_opt_encoding_itemContext *_localctx = _tracker.createInstance<Ext_opt_encoding_itemContext>(_ctx, getState());
  enterRule(_localctx, 338, GreenPlumParser::RuleExt_opt_encoding_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2929);
    match(GreenPlumParser::ENCODING);
    setState(2931);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::EQUALS_OP) {
      setState(2930);
      match(GreenPlumParser::EQUALS_OP);
    }
    setState(2935);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST: {
        setState(2933);
        sconst();
        break;
      }

      case GreenPlumParser::ICONST: {
        setState(2934);
        iconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_seq_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_seq_stmtContext::Create_seq_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_seq_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_seq_stmtContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Create_seq_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Opt_tempContext* GreenPlumParser::Create_seq_stmtContext::opt_temp() {
  return getRuleContext<GreenPlumParser::Opt_tempContext>(0);
}

GreenPlumParser::Opt_seq_listContext* GreenPlumParser::Create_seq_stmtContext::opt_seq_list() {
  return getRuleContext<GreenPlumParser::Opt_seq_listContext>(0);
}


size_t GreenPlumParser::Create_seq_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_seq_stmt;
}

void GreenPlumParser::Create_seq_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_seq_stmt(this);
}

void GreenPlumParser::Create_seq_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_seq_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_seq_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_seq_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_seq_stmtContext* GreenPlumParser::create_seq_stmt() {
  Create_seq_stmtContext *_localctx = _tracker.createInstance<Create_seq_stmtContext>(_ctx, getState());
  enterRule(_localctx, 340, GreenPlumParser::RuleCreate_seq_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2937);
    match(GreenPlumParser::CREATE);
    setState(2939);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GLOBAL

    || _la == GreenPlumParser::LOCAL || _la == GreenPlumParser::TEMP

    || _la == GreenPlumParser::TEMPORARY) {
      setState(2938);
      opt_temp();
    }
    setState(2941);
    match(GreenPlumParser::SEQUENCE);
    setState(2942);
    qualified_name();
    setState(2944);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CACHE

    || _la == GreenPlumParser::CYCLE || ((((_la - 183) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 183)) & ((1ULL << (GreenPlumParser::INCREMENT - 183))
      | (1ULL << (GreenPlumParser::MAXVALUE - 183))
      | (1ULL << (GreenPlumParser::MINVALUE - 183)))) != 0) || _la == GreenPlumParser::NO

    || _la == GreenPlumParser::OWNED || _la == GreenPlumParser::RESTART

    || _la == GreenPlumParser::START) {
      setState(2943);
      opt_seq_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_seq_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_seq_stmtContext::Alter_seq_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_seq_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_seq_stmtContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Alter_seq_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Opt_seq_listContext* GreenPlumParser::Alter_seq_stmtContext::opt_seq_list() {
  return getRuleContext<GreenPlumParser::Opt_seq_listContext>(0);
}


size_t GreenPlumParser::Alter_seq_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_seq_stmt;
}

void GreenPlumParser::Alter_seq_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_seq_stmt(this);
}

void GreenPlumParser::Alter_seq_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_seq_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_seq_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_seq_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_seq_stmtContext* GreenPlumParser::alter_seq_stmt() {
  Alter_seq_stmtContext *_localctx = _tracker.createInstance<Alter_seq_stmtContext>(_ctx, getState());
  enterRule(_localctx, 342, GreenPlumParser::RuleAlter_seq_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2946);
    match(GreenPlumParser::ALTER);
    setState(2947);
    match(GreenPlumParser::SEQUENCE);
    setState(2948);
    qualified_name();
    setState(2950);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CACHE

    || _la == GreenPlumParser::CYCLE || ((((_la - 183) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 183)) & ((1ULL << (GreenPlumParser::INCREMENT - 183))
      | (1ULL << (GreenPlumParser::MAXVALUE - 183))
      | (1ULL << (GreenPlumParser::MINVALUE - 183)))) != 0) || _la == GreenPlumParser::NO

    || _la == GreenPlumParser::OWNED || _la == GreenPlumParser::RESTART

    || _la == GreenPlumParser::START) {
      setState(2949);
      opt_seq_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_seq_listContext ------------------------------------------------------------------

GreenPlumParser::Opt_seq_listContext::Opt_seq_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Opt_seq_elemContext *> GreenPlumParser::Opt_seq_listContext::opt_seq_elem() {
  return getRuleContexts<GreenPlumParser::Opt_seq_elemContext>();
}

GreenPlumParser::Opt_seq_elemContext* GreenPlumParser::Opt_seq_listContext::opt_seq_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Opt_seq_elemContext>(i);
}


size_t GreenPlumParser::Opt_seq_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_seq_list;
}

void GreenPlumParser::Opt_seq_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_seq_list(this);
}

void GreenPlumParser::Opt_seq_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_seq_list(this);
}


antlrcpp::Any GreenPlumParser::Opt_seq_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_seq_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_seq_listContext* GreenPlumParser::opt_seq_list() {
  Opt_seq_listContext *_localctx = _tracker.createInstance<Opt_seq_listContext>(_ctx, getState());
  enterRule(_localctx, 344, GreenPlumParser::RuleOpt_seq_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2953); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2952);
      opt_seq_elem();
      setState(2955); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == GreenPlumParser::CACHE

    || _la == GreenPlumParser::CYCLE || ((((_la - 183) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 183)) & ((1ULL << (GreenPlumParser::INCREMENT - 183))
      | (1ULL << (GreenPlumParser::MAXVALUE - 183))
      | (1ULL << (GreenPlumParser::MINVALUE - 183)))) != 0) || _la == GreenPlumParser::NO

    || _la == GreenPlumParser::OWNED || _la == GreenPlumParser::RESTART

    || _la == GreenPlumParser::START);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_seq_elemContext ------------------------------------------------------------------

GreenPlumParser::Opt_seq_elemContext::Opt_seq_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::CACHE() {
  return getToken(GreenPlumParser::CACHE, 0);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::Opt_seq_elemContext::numberic_only() {
  return getRuleContext<GreenPlumParser::Numberic_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::CYCLE() {
  return getToken(GreenPlumParser::CYCLE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::INCREMENT() {
  return getToken(GreenPlumParser::INCREMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::MAXVALUE() {
  return getToken(GreenPlumParser::MAXVALUE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::MINVALUE() {
  return getToken(GreenPlumParser::MINVALUE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::OWNED() {
  return getToken(GreenPlumParser::OWNED, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Opt_seq_elemContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::START() {
  return getToken(GreenPlumParser::START, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_seq_elemContext::RESTART() {
  return getToken(GreenPlumParser::RESTART, 0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Opt_seq_elemContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}


size_t GreenPlumParser::Opt_seq_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_seq_elem;
}

void GreenPlumParser::Opt_seq_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_seq_elem(this);
}

void GreenPlumParser::Opt_seq_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_seq_elem(this);
}


antlrcpp::Any GreenPlumParser::Opt_seq_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_seq_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_seq_elemContext* GreenPlumParser::opt_seq_elem() {
  Opt_seq_elemContext *_localctx = _tracker.createInstance<Opt_seq_elemContext>(_ctx, getState());
  enterRule(_localctx, 346, GreenPlumParser::RuleOpt_seq_elem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2982);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2957);
      match(GreenPlumParser::CACHE);
      setState(2958);
      numberic_only();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2960);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NO) {
        setState(2959);
        match(GreenPlumParser::NO);
      }
      setState(2962);
      match(GreenPlumParser::CYCLE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2963);
      match(GreenPlumParser::NO);
      setState(2964);
      match(GreenPlumParser::CYCLE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2965);
      match(GreenPlumParser::INCREMENT);
      setState(2967);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::BY) {
        setState(2966);
        match(GreenPlumParser::BY);
      }
      setState(2969);
      numberic_only();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2970);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::MAXVALUE

      || _la == GreenPlumParser::MINVALUE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2971);
      numberic_only();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2972);
      match(GreenPlumParser::NO);
      setState(2973);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::MAXVALUE

      || _la == GreenPlumParser::MINVALUE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2974);
      match(GreenPlumParser::OWNED);
      setState(2975);
      match(GreenPlumParser::BY);
      setState(2976);
      any_name();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2977);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::RESTART

      || _la == GreenPlumParser::START)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2979);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::WITH) {
        setState(2978);
        opt_with();
      }
      setState(2981);
      numberic_only();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Numberic_onlyContext ------------------------------------------------------------------

GreenPlumParser::Numberic_onlyContext::Numberic_onlyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Float_onlyContext* GreenPlumParser::Numberic_onlyContext::float_only() {
  return getRuleContext<GreenPlumParser::Float_onlyContext>(0);
}

GreenPlumParser::Integer_onlyContext* GreenPlumParser::Numberic_onlyContext::integer_only() {
  return getRuleContext<GreenPlumParser::Integer_onlyContext>(0);
}


size_t GreenPlumParser::Numberic_onlyContext::getRuleIndex() const {
  return GreenPlumParser::RuleNumberic_only;
}

void GreenPlumParser::Numberic_onlyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberic_only(this);
}

void GreenPlumParser::Numberic_onlyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberic_only(this);
}


antlrcpp::Any GreenPlumParser::Numberic_onlyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitNumberic_only(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::numberic_only() {
  Numberic_onlyContext *_localctx = _tracker.createInstance<Numberic_onlyContext>(_ctx, getState());
  enterRule(_localctx, 348, GreenPlumParser::RuleNumberic_only);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2986);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2984);
      float_only();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2985);
      integer_only();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Float_onlyContext ------------------------------------------------------------------

GreenPlumParser::Float_onlyContext::Float_onlyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Float_onlyContext::FCONST() {
  return getToken(GreenPlumParser::FCONST, 0);
}

tree::TerminalNode* GreenPlumParser::Float_onlyContext::MINUS_SIGN() {
  return getToken(GreenPlumParser::MINUS_SIGN, 0);
}


size_t GreenPlumParser::Float_onlyContext::getRuleIndex() const {
  return GreenPlumParser::RuleFloat_only;
}

void GreenPlumParser::Float_onlyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloat_only(this);
}

void GreenPlumParser::Float_onlyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloat_only(this);
}


antlrcpp::Any GreenPlumParser::Float_onlyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFloat_only(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Float_onlyContext* GreenPlumParser::float_only() {
  Float_onlyContext *_localctx = _tracker.createInstance<Float_onlyContext>(_ctx, getState());
  enterRule(_localctx, 350, GreenPlumParser::RuleFloat_only);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2989);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::MINUS_SIGN) {
      setState(2988);
      match(GreenPlumParser::MINUS_SIGN);
    }
    setState(2991);
    match(GreenPlumParser::FCONST);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_onlyContext ------------------------------------------------------------------

GreenPlumParser::Integer_onlyContext::Integer_onlyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Signed_iconstContext* GreenPlumParser::Integer_onlyContext::signed_iconst() {
  return getRuleContext<GreenPlumParser::Signed_iconstContext>(0);
}


size_t GreenPlumParser::Integer_onlyContext::getRuleIndex() const {
  return GreenPlumParser::RuleInteger_only;
}

void GreenPlumParser::Integer_onlyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger_only(this);
}

void GreenPlumParser::Integer_onlyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger_only(this);
}


antlrcpp::Any GreenPlumParser::Integer_onlyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitInteger_only(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Integer_onlyContext* GreenPlumParser::integer_only() {
  Integer_onlyContext *_localctx = _tracker.createInstance<Integer_onlyContext>(_ctx, getState());
  enterRule(_localctx, 352, GreenPlumParser::RuleInteger_only);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2993);
    signed_iconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_p_lang_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_p_lang_stmtContext::Create_p_lang_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_p_lang_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_p_lang_stmtContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

GreenPlumParser::Colid_or_sconstContext* GreenPlumParser::Create_p_lang_stmtContext::colid_or_sconst() {
  return getRuleContext<GreenPlumParser::Colid_or_sconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_p_lang_stmtContext::TRUSTED() {
  return getToken(GreenPlumParser::TRUSTED, 0);
}

tree::TerminalNode* GreenPlumParser::Create_p_lang_stmtContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

GreenPlumParser::Create_p_lang_stmtOptionContext* GreenPlumParser::Create_p_lang_stmtContext::create_p_lang_stmtOption() {
  return getRuleContext<GreenPlumParser::Create_p_lang_stmtOptionContext>(0);
}


size_t GreenPlumParser::Create_p_lang_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_p_lang_stmt;
}

void GreenPlumParser::Create_p_lang_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_p_lang_stmt(this);
}

void GreenPlumParser::Create_p_lang_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_p_lang_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_p_lang_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_p_lang_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_p_lang_stmtContext* GreenPlumParser::create_p_lang_stmt() {
  Create_p_lang_stmtContext *_localctx = _tracker.createInstance<Create_p_lang_stmtContext>(_ctx, getState());
  enterRule(_localctx, 354, GreenPlumParser::RuleCreate_p_lang_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2995);
    match(GreenPlumParser::CREATE);
    setState(2997);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TRUSTED) {
      setState(2996);
      match(GreenPlumParser::TRUSTED);
    }
    setState(3000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PROCEDURAL) {
      setState(2999);
      match(GreenPlumParser::PROCEDURAL);
    }
    setState(3002);
    match(GreenPlumParser::LANGUAGE);
    setState(3003);
    colid_or_sconst();
    setState(3005);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::HANDLER) {
      setState(3004);
      create_p_lang_stmtOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_p_lang_stmtOptionContext ------------------------------------------------------------------

GreenPlumParser::Create_p_lang_stmtOptionContext::Create_p_lang_stmtOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_p_lang_stmtOptionContext::HANDLER() {
  return getToken(GreenPlumParser::HANDLER, 0);
}

GreenPlumParser::Handler_nameContext* GreenPlumParser::Create_p_lang_stmtOptionContext::handler_name() {
  return getRuleContext<GreenPlumParser::Handler_nameContext>(0);
}

GreenPlumParser::Opt_inline_handlerContext* GreenPlumParser::Create_p_lang_stmtOptionContext::opt_inline_handler() {
  return getRuleContext<GreenPlumParser::Opt_inline_handlerContext>(0);
}

GreenPlumParser::Opt_validatorContext* GreenPlumParser::Create_p_lang_stmtOptionContext::opt_validator() {
  return getRuleContext<GreenPlumParser::Opt_validatorContext>(0);
}


size_t GreenPlumParser::Create_p_lang_stmtOptionContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_p_lang_stmtOption;
}

void GreenPlumParser::Create_p_lang_stmtOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_p_lang_stmtOption(this);
}

void GreenPlumParser::Create_p_lang_stmtOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_p_lang_stmtOption(this);
}


antlrcpp::Any GreenPlumParser::Create_p_lang_stmtOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_p_lang_stmtOption(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_p_lang_stmtOptionContext* GreenPlumParser::create_p_lang_stmtOption() {
  Create_p_lang_stmtOptionContext *_localctx = _tracker.createInstance<Create_p_lang_stmtOptionContext>(_ctx, getState());
  enterRule(_localctx, 356, GreenPlumParser::RuleCreate_p_lang_stmtOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3007);
    match(GreenPlumParser::HANDLER);
    setState(3008);
    handler_name();
    setState(3010);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::INLINE_P) {
      setState(3009);
      opt_inline_handler();
    }
    setState(3013);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::NO || _la == GreenPlumParser::VALIDATOR) {
      setState(3012);
      opt_validator();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Handler_nameContext ------------------------------------------------------------------

GreenPlumParser::Handler_nameContext::Handler_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::NameContext* GreenPlumParser::Handler_nameContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::AttrsContext* GreenPlumParser::Handler_nameContext::attrs() {
  return getRuleContext<GreenPlumParser::AttrsContext>(0);
}


size_t GreenPlumParser::Handler_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleHandler_name;
}

void GreenPlumParser::Handler_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandler_name(this);
}

void GreenPlumParser::Handler_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandler_name(this);
}


antlrcpp::Any GreenPlumParser::Handler_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitHandler_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Handler_nameContext* GreenPlumParser::handler_name() {
  Handler_nameContext *_localctx = _tracker.createInstance<Handler_nameContext>(_ctx, getState());
  enterRule(_localctx, 358, GreenPlumParser::RuleHandler_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3019);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3015);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3016);
      name();
      setState(3017);
      attrs();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_inline_handlerContext ------------------------------------------------------------------

GreenPlumParser::Opt_inline_handlerContext::Opt_inline_handlerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_inline_handlerContext::INLINE_P() {
  return getToken(GreenPlumParser::INLINE_P, 0);
}

GreenPlumParser::Handler_nameContext* GreenPlumParser::Opt_inline_handlerContext::handler_name() {
  return getRuleContext<GreenPlumParser::Handler_nameContext>(0);
}


size_t GreenPlumParser::Opt_inline_handlerContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_inline_handler;
}

void GreenPlumParser::Opt_inline_handlerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_inline_handler(this);
}

void GreenPlumParser::Opt_inline_handlerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_inline_handler(this);
}


antlrcpp::Any GreenPlumParser::Opt_inline_handlerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_inline_handler(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_inline_handlerContext* GreenPlumParser::opt_inline_handler() {
  Opt_inline_handlerContext *_localctx = _tracker.createInstance<Opt_inline_handlerContext>(_ctx, getState());
  enterRule(_localctx, 360, GreenPlumParser::RuleOpt_inline_handler);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3021);
    match(GreenPlumParser::INLINE_P);
    setState(3022);
    handler_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Validator_clauseContext ------------------------------------------------------------------

GreenPlumParser::Validator_clauseContext::Validator_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Validator_clauseContext::VALIDATOR() {
  return getToken(GreenPlumParser::VALIDATOR, 0);
}

GreenPlumParser::Handler_nameContext* GreenPlumParser::Validator_clauseContext::handler_name() {
  return getRuleContext<GreenPlumParser::Handler_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Validator_clauseContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}


size_t GreenPlumParser::Validator_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleValidator_clause;
}

void GreenPlumParser::Validator_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValidator_clause(this);
}

void GreenPlumParser::Validator_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValidator_clause(this);
}


antlrcpp::Any GreenPlumParser::Validator_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitValidator_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Validator_clauseContext* GreenPlumParser::validator_clause() {
  Validator_clauseContext *_localctx = _tracker.createInstance<Validator_clauseContext>(_ctx, getState());
  enterRule(_localctx, 362, GreenPlumParser::RuleValidator_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3028);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::VALIDATOR: {
        enterOuterAlt(_localctx, 1);
        setState(3024);
        match(GreenPlumParser::VALIDATOR);
        setState(3025);
        handler_name();
        break;
      }

      case GreenPlumParser::NO: {
        enterOuterAlt(_localctx, 2);
        setState(3026);
        match(GreenPlumParser::NO);
        setState(3027);
        match(GreenPlumParser::VALIDATOR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_validatorContext ------------------------------------------------------------------

GreenPlumParser::Opt_validatorContext::Opt_validatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Validator_clauseContext* GreenPlumParser::Opt_validatorContext::validator_clause() {
  return getRuleContext<GreenPlumParser::Validator_clauseContext>(0);
}


size_t GreenPlumParser::Opt_validatorContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_validator;
}

void GreenPlumParser::Opt_validatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_validator(this);
}

void GreenPlumParser::Opt_validatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_validator(this);
}


antlrcpp::Any GreenPlumParser::Opt_validatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_validator(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_validatorContext* GreenPlumParser::opt_validator() {
  Opt_validatorContext *_localctx = _tracker.createInstance<Opt_validatorContext>(_ctx, getState());
  enterRule(_localctx, 364, GreenPlumParser::RuleOpt_validator);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3030);
    validator_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_p_lang_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_p_lang_stmtContext::Drop_p_lang_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_p_lang_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_p_lang_stmtContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

GreenPlumParser::Colid_or_sconstContext* GreenPlumParser::Drop_p_lang_stmtContext::colid_or_sconst() {
  return getRuleContext<GreenPlumParser::Colid_or_sconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_p_lang_stmtContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_p_lang_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_p_lang_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_p_lang_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_p_lang_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_p_lang_stmt;
}

void GreenPlumParser::Drop_p_lang_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_p_lang_stmt(this);
}

void GreenPlumParser::Drop_p_lang_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_p_lang_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_p_lang_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_p_lang_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_p_lang_stmtContext* GreenPlumParser::drop_p_lang_stmt() {
  Drop_p_lang_stmtContext *_localctx = _tracker.createInstance<Drop_p_lang_stmtContext>(_ctx, getState());
  enterRule(_localctx, 366, GreenPlumParser::RuleDrop_p_lang_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3032);
    match(GreenPlumParser::DROP);
    setState(3034);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PROCEDURAL) {
      setState(3033);
      match(GreenPlumParser::PROCEDURAL);
    }
    setState(3036);
    match(GreenPlumParser::LANGUAGE);
    setState(3039);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
    case 1: {
      setState(3037);
      match(GreenPlumParser::IF_P);
      setState(3038);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(3041);
    colid_or_sconst();
    setState(3043);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3042);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_file_space_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_file_space_stmtContext::Create_file_space_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_file_space_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_file_space_stmtContext::FILESPACE() {
  return getToken(GreenPlumParser::FILESPACE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Create_file_space_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_file_space_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::File_space_seg_listContext* GreenPlumParser::Create_file_space_stmtContext::file_space_seg_list() {
  return getRuleContext<GreenPlumParser::File_space_seg_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_file_space_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Opt_ownerContext* GreenPlumParser::Create_file_space_stmtContext::opt_owner() {
  return getRuleContext<GreenPlumParser::Opt_ownerContext>(0);
}


size_t GreenPlumParser::Create_file_space_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_file_space_stmt;
}

void GreenPlumParser::Create_file_space_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_file_space_stmt(this);
}

void GreenPlumParser::Create_file_space_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_file_space_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_file_space_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_file_space_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_file_space_stmtContext* GreenPlumParser::create_file_space_stmt() {
  Create_file_space_stmtContext *_localctx = _tracker.createInstance<Create_file_space_stmtContext>(_ctx, getState());
  enterRule(_localctx, 368, GreenPlumParser::RuleCreate_file_space_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3045);
    match(GreenPlumParser::CREATE);
    setState(3046);
    match(GreenPlumParser::FILESPACE);
    setState(3047);
    name();
    setState(3049);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::OWNER) {
      setState(3048);
      opt_owner();
    }
    setState(3051);
    match(GreenPlumParser::LEFT_PAREN);
    setState(3052);
    file_space_seg_list();
    setState(3053);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_space_seg_listContext ------------------------------------------------------------------

GreenPlumParser::File_space_seg_listContext::File_space_seg_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::File_space_segContext *> GreenPlumParser::File_space_seg_listContext::file_space_seg() {
  return getRuleContexts<GreenPlumParser::File_space_segContext>();
}

GreenPlumParser::File_space_segContext* GreenPlumParser::File_space_seg_listContext::file_space_seg(size_t i) {
  return getRuleContext<GreenPlumParser::File_space_segContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::File_space_seg_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::File_space_seg_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::File_space_seg_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFile_space_seg_list;
}

void GreenPlumParser::File_space_seg_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_space_seg_list(this);
}

void GreenPlumParser::File_space_seg_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_space_seg_list(this);
}


antlrcpp::Any GreenPlumParser::File_space_seg_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFile_space_seg_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::File_space_seg_listContext* GreenPlumParser::file_space_seg_list() {
  File_space_seg_listContext *_localctx = _tracker.createInstance<File_space_seg_listContext>(_ctx, getState());
  enterRule(_localctx, 370, GreenPlumParser::RuleFile_space_seg_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3055);
    file_space_seg();
    setState(3060);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3056);
      match(GreenPlumParser::COMMA);
      setState(3057);
      file_space_seg();
      setState(3062);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_space_segContext ------------------------------------------------------------------

GreenPlumParser::File_space_segContext::File_space_segContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IconstContext* GreenPlumParser::File_space_segContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::File_space_segContext::SEMICOLON() {
  return getToken(GreenPlumParser::SEMICOLON, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::File_space_segContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::File_space_segContext::getRuleIndex() const {
  return GreenPlumParser::RuleFile_space_seg;
}

void GreenPlumParser::File_space_segContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_space_seg(this);
}

void GreenPlumParser::File_space_segContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_space_seg(this);
}


antlrcpp::Any GreenPlumParser::File_space_segContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFile_space_seg(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::File_space_segContext* GreenPlumParser::file_space_seg() {
  File_space_segContext *_localctx = _tracker.createInstance<File_space_segContext>(_ctx, getState());
  enterRule(_localctx, 372, GreenPlumParser::RuleFile_space_seg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3063);
    iconst();
    setState(3064);
    match(GreenPlumParser::SEMICOLON);
    setState(3065);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_ownerContext ------------------------------------------------------------------

GreenPlumParser::Opt_ownerContext::Opt_ownerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_ownerContext::OWNER() {
  return getToken(GreenPlumParser::OWNER, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Opt_ownerContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Opt_ownerContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_owner;
}

void GreenPlumParser::Opt_ownerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_owner(this);
}

void GreenPlumParser::Opt_ownerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_owner(this);
}


antlrcpp::Any GreenPlumParser::Opt_ownerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_owner(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_ownerContext* GreenPlumParser::opt_owner() {
  Opt_ownerContext *_localctx = _tracker.createInstance<Opt_ownerContext>(_ctx, getState());
  enterRule(_localctx, 374, GreenPlumParser::RuleOpt_owner);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3067);
    match(GreenPlumParser::OWNER);
    setState(3068);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_space_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_table_space_stmtContext::Create_table_space_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_table_space_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_table_space_stmtContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

std::vector<GreenPlumParser::NameContext *> GreenPlumParser::Create_table_space_stmtContext::name() {
  return getRuleContexts<GreenPlumParser::NameContext>();
}

GreenPlumParser::NameContext* GreenPlumParser::Create_table_space_stmtContext::name(size_t i) {
  return getRuleContext<GreenPlumParser::NameContext>(i);
}

tree::TerminalNode* GreenPlumParser::Create_table_space_stmtContext::FILESPACE() {
  return getToken(GreenPlumParser::FILESPACE, 0);
}

GreenPlumParser::Opt_ownerContext* GreenPlumParser::Create_table_space_stmtContext::opt_owner() {
  return getRuleContext<GreenPlumParser::Opt_ownerContext>(0);
}


size_t GreenPlumParser::Create_table_space_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_table_space_stmt;
}

void GreenPlumParser::Create_table_space_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_space_stmt(this);
}

void GreenPlumParser::Create_table_space_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_space_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_table_space_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_table_space_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_table_space_stmtContext* GreenPlumParser::create_table_space_stmt() {
  Create_table_space_stmtContext *_localctx = _tracker.createInstance<Create_table_space_stmtContext>(_ctx, getState());
  enterRule(_localctx, 376, GreenPlumParser::RuleCreate_table_space_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3070);
    match(GreenPlumParser::CREATE);
    setState(3071);
    match(GreenPlumParser::TABLESPACE);
    setState(3072);
    name();
    setState(3074);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::OWNER) {
      setState(3073);
      opt_owner();
    }
    setState(3076);
    match(GreenPlumParser::FILESPACE);
    setState(3077);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_extension_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_extension_stmtContext::Create_extension_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_extension_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_extension_stmtContext::EXTENSION() {
  return getToken(GreenPlumParser::EXTENSION, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Create_extension_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_extension_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Create_extension_stmtContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Create_extension_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Create_extension_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

GreenPlumParser::Create_extension_opt_listContext* GreenPlumParser::Create_extension_stmtContext::create_extension_opt_list() {
  return getRuleContext<GreenPlumParser::Create_extension_opt_listContext>(0);
}


size_t GreenPlumParser::Create_extension_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_extension_stmt;
}

void GreenPlumParser::Create_extension_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_extension_stmt(this);
}

void GreenPlumParser::Create_extension_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_extension_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_extension_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_extension_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_extension_stmtContext* GreenPlumParser::create_extension_stmt() {
  Create_extension_stmtContext *_localctx = _tracker.createInstance<Create_extension_stmtContext>(_ctx, getState());
  enterRule(_localctx, 378, GreenPlumParser::RuleCreate_extension_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3079);
    match(GreenPlumParser::CREATE);
    setState(3080);
    match(GreenPlumParser::EXTENSION);
    setState(3084);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
    case 1: {
      setState(3081);
      match(GreenPlumParser::IF_P);
      setState(3082);
      match(GreenPlumParser::NOT);
      setState(3083);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(3086);
    name();
    setState(3088);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(3087);
      opt_with();
    }
    setState(3091);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::FROM || _la == GreenPlumParser::SCHEMA || _la == GreenPlumParser::VERSION_P) {
      setState(3090);
      create_extension_opt_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_extension_opt_listContext ------------------------------------------------------------------

GreenPlumParser::Create_extension_opt_listContext::Create_extension_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Create_extension_opt_itemContext *> GreenPlumParser::Create_extension_opt_listContext::create_extension_opt_item() {
  return getRuleContexts<GreenPlumParser::Create_extension_opt_itemContext>();
}

GreenPlumParser::Create_extension_opt_itemContext* GreenPlumParser::Create_extension_opt_listContext::create_extension_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Create_extension_opt_itemContext>(i);
}


size_t GreenPlumParser::Create_extension_opt_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_extension_opt_list;
}

void GreenPlumParser::Create_extension_opt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_extension_opt_list(this);
}

void GreenPlumParser::Create_extension_opt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_extension_opt_list(this);
}


antlrcpp::Any GreenPlumParser::Create_extension_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_extension_opt_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_extension_opt_listContext* GreenPlumParser::create_extension_opt_list() {
  Create_extension_opt_listContext *_localctx = _tracker.createInstance<Create_extension_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 380, GreenPlumParser::RuleCreate_extension_opt_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3094); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(3093);
      create_extension_opt_item();
      setState(3096); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == GreenPlumParser::FROM || _la == GreenPlumParser::SCHEMA || _la == GreenPlumParser::VERSION_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_extension_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Create_extension_opt_itemContext::Create_extension_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_extension_opt_itemContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Create_extension_opt_itemContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_extension_opt_itemContext::VERSION_P() {
  return getToken(GreenPlumParser::VERSION_P, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Create_extension_opt_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_extension_opt_itemContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}


size_t GreenPlumParser::Create_extension_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_extension_opt_item;
}

void GreenPlumParser::Create_extension_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_extension_opt_item(this);
}

void GreenPlumParser::Create_extension_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_extension_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Create_extension_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_extension_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_extension_opt_itemContext* GreenPlumParser::create_extension_opt_item() {
  Create_extension_opt_itemContext *_localctx = _tracker.createInstance<Create_extension_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 382, GreenPlumParser::RuleCreate_extension_opt_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3104);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::SCHEMA: {
        enterOuterAlt(_localctx, 1);
        setState(3098);
        match(GreenPlumParser::SCHEMA);
        setState(3099);
        name();
        break;
      }

      case GreenPlumParser::VERSION_P: {
        enterOuterAlt(_localctx, 2);
        setState(3100);
        match(GreenPlumParser::VERSION_P);
        setState(3101);
        sconst();
        break;
      }

      case GreenPlumParser::FROM: {
        enterOuterAlt(_localctx, 3);
        setState(3102);
        match(GreenPlumParser::FROM);
        setState(3103);
        sconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_extension_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_extension_stmtContext::Alter_extension_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_extension_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_stmtContext::EXTENSION() {
  return getToken(GreenPlumParser::EXTENSION, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_extension_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_stmtContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

GreenPlumParser::Alter_extension_opt_listContext* GreenPlumParser::Alter_extension_stmtContext::alter_extension_opt_list() {
  return getRuleContext<GreenPlumParser::Alter_extension_opt_listContext>(0);
}


size_t GreenPlumParser::Alter_extension_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_extension_stmt;
}

void GreenPlumParser::Alter_extension_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_extension_stmt(this);
}

void GreenPlumParser::Alter_extension_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_extension_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_extension_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_extension_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_extension_stmtContext* GreenPlumParser::alter_extension_stmt() {
  Alter_extension_stmtContext *_localctx = _tracker.createInstance<Alter_extension_stmtContext>(_ctx, getState());
  enterRule(_localctx, 384, GreenPlumParser::RuleAlter_extension_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3106);
    match(GreenPlumParser::ALTER);
    setState(3107);
    match(GreenPlumParser::EXTENSION);
    setState(3108);
    name();
    setState(3109);
    match(GreenPlumParser::UPDATE);
    setState(3111);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TO) {
      setState(3110);
      alter_extension_opt_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_extension_opt_listContext ------------------------------------------------------------------

GreenPlumParser::Alter_extension_opt_listContext::Alter_extension_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Alter_extension_opt_itemContext *> GreenPlumParser::Alter_extension_opt_listContext::alter_extension_opt_item() {
  return getRuleContexts<GreenPlumParser::Alter_extension_opt_itemContext>();
}

GreenPlumParser::Alter_extension_opt_itemContext* GreenPlumParser::Alter_extension_opt_listContext::alter_extension_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Alter_extension_opt_itemContext>(i);
}


size_t GreenPlumParser::Alter_extension_opt_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_extension_opt_list;
}

void GreenPlumParser::Alter_extension_opt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_extension_opt_list(this);
}

void GreenPlumParser::Alter_extension_opt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_extension_opt_list(this);
}


antlrcpp::Any GreenPlumParser::Alter_extension_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_extension_opt_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_extension_opt_listContext* GreenPlumParser::alter_extension_opt_list() {
  Alter_extension_opt_listContext *_localctx = _tracker.createInstance<Alter_extension_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 386, GreenPlumParser::RuleAlter_extension_opt_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3114); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(3113);
      alter_extension_opt_item();
      setState(3116); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == GreenPlumParser::TO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_extension_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Alter_extension_opt_itemContext::Alter_extension_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_extension_opt_itemContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Alter_extension_opt_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::Alter_extension_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_extension_opt_item;
}

void GreenPlumParser::Alter_extension_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_extension_opt_item(this);
}

void GreenPlumParser::Alter_extension_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_extension_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Alter_extension_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_extension_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_extension_opt_itemContext* GreenPlumParser::alter_extension_opt_item() {
  Alter_extension_opt_itemContext *_localctx = _tracker.createInstance<Alter_extension_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 388, GreenPlumParser::RuleAlter_extension_opt_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3118);
    match(GreenPlumParser::TO);
    setState(3119);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_extension_content_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_extension_content_stmtContext::Alter_extension_content_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtContext::EXTENSION() {
  return getToken(GreenPlumParser::EXTENSION, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_extension_content_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::Add_dropContext* GreenPlumParser::Alter_extension_content_stmtContext::add_drop() {
  return getRuleContext<GreenPlumParser::Add_dropContext>(0);
}

GreenPlumParser::Alter_extension_content_stmtOptionContext* GreenPlumParser::Alter_extension_content_stmtContext::alter_extension_content_stmtOption() {
  return getRuleContext<GreenPlumParser::Alter_extension_content_stmtOptionContext>(0);
}


size_t GreenPlumParser::Alter_extension_content_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_extension_content_stmt;
}

void GreenPlumParser::Alter_extension_content_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_extension_content_stmt(this);
}

void GreenPlumParser::Alter_extension_content_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_extension_content_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_extension_content_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_extension_content_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_extension_content_stmtContext* GreenPlumParser::alter_extension_content_stmt() {
  Alter_extension_content_stmtContext *_localctx = _tracker.createInstance<Alter_extension_content_stmtContext>(_ctx, getState());
  enterRule(_localctx, 390, GreenPlumParser::RuleAlter_extension_content_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3121);
    match(GreenPlumParser::ALTER);
    setState(3122);
    match(GreenPlumParser::EXTENSION);
    setState(3123);
    name();
    setState(3124);
    add_drop();
    setState(3125);
    alter_extension_content_stmtOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_extension_content_stmtOptionContext ------------------------------------------------------------------

GreenPlumParser::Alter_extension_content_stmtOptionContext::Alter_extension_content_stmtOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::aggr_args() {
  return getRuleContext<GreenPlumParser::Aggr_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::CAST() {
  return getToken(GreenPlumParser::CAST, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

std::vector<GreenPlumParser::Typename_pgContext *> GreenPlumParser::Alter_extension_content_stmtOptionContext::typename_pg() {
  return getRuleContexts<GreenPlumParser::Typename_pgContext>();
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::typename_pg(size_t i) {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(i);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::function_with_argtypes() {
  return getRuleContext<GreenPlumParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

GreenPlumParser::Oper_argtypesContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::oper_argtypes() {
  return getRuleContext<GreenPlumParser::Oper_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Alter_extension_content_stmtOptionContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::PARSER() {
  return getToken(GreenPlumParser::PARSER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::VIEW() {
  return getToken(GreenPlumParser::VIEW, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_extension_content_stmtOptionContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}


size_t GreenPlumParser::Alter_extension_content_stmtOptionContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_extension_content_stmtOption;
}

void GreenPlumParser::Alter_extension_content_stmtOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_extension_content_stmtOption(this);
}

void GreenPlumParser::Alter_extension_content_stmtOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_extension_content_stmtOption(this);
}


antlrcpp::Any GreenPlumParser::Alter_extension_content_stmtOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_extension_content_stmtOption(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_extension_content_stmtOptionContext* GreenPlumParser::alter_extension_content_stmtOption() {
  Alter_extension_content_stmtOptionContext *_localctx = _tracker.createInstance<Alter_extension_content_stmtOptionContext>(_ctx, getState());
  enterRule(_localctx, 392, GreenPlumParser::RuleAlter_extension_content_stmtOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3191);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3127);
      match(GreenPlumParser::AGGREGATE);
      setState(3128);
      func_name();
      setState(3129);
      aggr_args();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3131);
      match(GreenPlumParser::CAST);
      setState(3132);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3133);
      typename_pg();
      setState(3134);
      match(GreenPlumParser::AS);
      setState(3135);
      typename_pg();
      setState(3136);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3138);
      match(GreenPlumParser::CONVERSION_P);
      setState(3139);
      any_name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3140);
      match(GreenPlumParser::DOMAIN_P);
      setState(3141);
      any_name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3142);
      match(GreenPlumParser::FUNCTION);
      setState(3143);
      function_with_argtypes();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3145);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PROCEDURAL) {
        setState(3144);
        match(GreenPlumParser::PROCEDURAL);
      }
      setState(3147);
      match(GreenPlumParser::LANGUAGE);
      setState(3148);
      name();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3149);
      match(GreenPlumParser::OPERATOR);
      setState(3150);
      any_operator();
      setState(3151);
      oper_argtypes();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3153);
      match(GreenPlumParser::OPERATOR);
      setState(3154);
      match(GreenPlumParser::CLASS);
      setState(3155);
      any_name();
      setState(3156);
      match(GreenPlumParser::USING);
      setState(3157);
      access_method();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3159);
      match(GreenPlumParser::OPERATOR);
      setState(3160);
      match(GreenPlumParser::FAMILY);
      setState(3161);
      any_name();
      setState(3162);
      match(GreenPlumParser::USING);
      setState(3163);
      access_method();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3165);
      match(GreenPlumParser::SCHEMA);
      setState(3166);
      name();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3167);
      match(GreenPlumParser::TABLE);
      setState(3168);
      any_name();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3169);
      match(GreenPlumParser::TEXT_P);
      setState(3170);
      match(GreenPlumParser::SEARCH);
      setState(3171);
      match(GreenPlumParser::PARSER);
      setState(3172);
      any_name();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3173);
      match(GreenPlumParser::TEXT_P);
      setState(3174);
      match(GreenPlumParser::SEARCH);
      setState(3175);
      match(GreenPlumParser::DICTIONARY);
      setState(3176);
      any_name();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3177);
      match(GreenPlumParser::TEXT_P);
      setState(3178);
      match(GreenPlumParser::SEARCH);
      setState(3179);
      match(GreenPlumParser::TEMPLATE);
      setState(3180);
      any_name();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3181);
      match(GreenPlumParser::TEXT_P);
      setState(3182);
      match(GreenPlumParser::SEARCH);
      setState(3183);
      match(GreenPlumParser::CONFIGURATION);
      setState(3184);
      any_name();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(3185);
      match(GreenPlumParser::SEQUENCE);
      setState(3186);
      any_name();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(3187);
      match(GreenPlumParser::VIEW);
      setState(3188);
      any_name();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(3189);
      match(GreenPlumParser::TYPE_P);
      setState(3190);
      any_name();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_trig_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_trig_stmtContext::Create_trig_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Create_trig_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::Trigger_action_timeContext* GreenPlumParser::Create_trig_stmtContext::trigger_action_time() {
  return getRuleContext<GreenPlumParser::Trigger_action_timeContext>(0);
}

GreenPlumParser::Trigger_eventsContext* GreenPlumParser::Create_trig_stmtContext::trigger_events() {
  return getRuleContext<GreenPlumParser::Trigger_eventsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Create_trig_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::EXECUTE() {
  return getToken(GreenPlumParser::EXECUTE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::PROCEDURE() {
  return getToken(GreenPlumParser::PROCEDURE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Create_trig_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Trigger_for_specContext* GreenPlumParser::Create_trig_stmtContext::trigger_for_spec() {
  return getRuleContext<GreenPlumParser::Trigger_for_specContext>(0);
}

GreenPlumParser::Trigger_func_argsContext* GreenPlumParser::Create_trig_stmtContext::trigger_func_args() {
  return getRuleContext<GreenPlumParser::Trigger_func_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::CONSTRAINT() {
  return getToken(GreenPlumParser::CONSTRAINT, 0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::AFTER() {
  return getToken(GreenPlumParser::AFTER, 0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::EACH() {
  return getToken(GreenPlumParser::EACH, 0);
}

tree::TerminalNode* GreenPlumParser::Create_trig_stmtContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

GreenPlumParser::Opt_constr_from_tableContext* GreenPlumParser::Create_trig_stmtContext::opt_constr_from_table() {
  return getRuleContext<GreenPlumParser::Opt_constr_from_tableContext>(0);
}

GreenPlumParser::Constraint_attr_specContext* GreenPlumParser::Create_trig_stmtContext::constraint_attr_spec() {
  return getRuleContext<GreenPlumParser::Constraint_attr_specContext>(0);
}


size_t GreenPlumParser::Create_trig_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_trig_stmt;
}

void GreenPlumParser::Create_trig_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_trig_stmt(this);
}

void GreenPlumParser::Create_trig_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_trig_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_trig_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_trig_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_trig_stmtContext* GreenPlumParser::create_trig_stmt() {
  Create_trig_stmtContext *_localctx = _tracker.createInstance<Create_trig_stmtContext>(_ctx, getState());
  enterRule(_localctx, 394, GreenPlumParser::RuleCreate_trig_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3238);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3193);
      match(GreenPlumParser::CREATE);
      setState(3194);
      match(GreenPlumParser::TRIGGER);
      setState(3195);
      name();
      setState(3196);
      trigger_action_time();
      setState(3197);
      trigger_events();
      setState(3198);
      match(GreenPlumParser::ON);
      setState(3199);
      qualified_name();
      setState(3201);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::FOR) {
        setState(3200);
        trigger_for_spec();
      }
      setState(3203);
      match(GreenPlumParser::EXECUTE);
      setState(3204);
      match(GreenPlumParser::PROCEDURE);
      setState(3205);
      func_name();
      setState(3206);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3208);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451))
        | (1ULL << (GreenPlumParser::ICONST - 451))
        | (1ULL << (GreenPlumParser::FCONST - 451))
        | (1ULL << (GreenPlumParser::BCONST - 451))
        | (1ULL << (GreenPlumParser::XCONST - 451)))) != 0)) {
        setState(3207);
        trigger_func_args();
      }
      setState(3210);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3212);
      match(GreenPlumParser::CREATE);
      setState(3213);
      match(GreenPlumParser::CONSTRAINT);
      setState(3214);
      match(GreenPlumParser::TRIGGER);
      setState(3215);
      name();
      setState(3216);
      match(GreenPlumParser::AFTER);
      setState(3217);
      trigger_events();
      setState(3218);
      match(GreenPlumParser::ON);
      setState(3219);
      qualified_name();
      setState(3221);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::FROM) {
        setState(3220);
        opt_constr_from_table();
      }
      setState(3224);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::DEFERRABLE || _la == GreenPlumParser::INITIALLY || _la == GreenPlumParser::NOT) {
        setState(3223);
        constraint_attr_spec();
      }
      setState(3226);
      match(GreenPlumParser::FOR);
      setState(3227);
      match(GreenPlumParser::EACH);
      setState(3228);
      match(GreenPlumParser::ROW);
      setState(3229);
      match(GreenPlumParser::EXECUTE);
      setState(3230);
      match(GreenPlumParser::PROCEDURE);
      setState(3231);
      func_name();
      setState(3232);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3234);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451))
        | (1ULL << (GreenPlumParser::ICONST - 451))
        | (1ULL << (GreenPlumParser::FCONST - 451))
        | (1ULL << (GreenPlumParser::BCONST - 451))
        | (1ULL << (GreenPlumParser::XCONST - 451)))) != 0)) {
        setState(3233);
        trigger_func_args();
      }
      setState(3236);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_action_timeContext ------------------------------------------------------------------

GreenPlumParser::Trigger_action_timeContext::Trigger_action_timeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Trigger_action_timeContext::BEFORE() {
  return getToken(GreenPlumParser::BEFORE, 0);
}

tree::TerminalNode* GreenPlumParser::Trigger_action_timeContext::AFTER() {
  return getToken(GreenPlumParser::AFTER, 0);
}


size_t GreenPlumParser::Trigger_action_timeContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrigger_action_time;
}

void GreenPlumParser::Trigger_action_timeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_action_time(this);
}

void GreenPlumParser::Trigger_action_timeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_action_time(this);
}


antlrcpp::Any GreenPlumParser::Trigger_action_timeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_action_time(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trigger_action_timeContext* GreenPlumParser::trigger_action_time() {
  Trigger_action_timeContext *_localctx = _tracker.createInstance<Trigger_action_timeContext>(_ctx, getState());
  enterRule(_localctx, 396, GreenPlumParser::RuleTrigger_action_time);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3240);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::AFTER

    || _la == GreenPlumParser::BEFORE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_eventsContext ------------------------------------------------------------------

GreenPlumParser::Trigger_eventsContext::Trigger_eventsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Trigger_one_eventContext *> GreenPlumParser::Trigger_eventsContext::trigger_one_event() {
  return getRuleContexts<GreenPlumParser::Trigger_one_eventContext>();
}

GreenPlumParser::Trigger_one_eventContext* GreenPlumParser::Trigger_eventsContext::trigger_one_event(size_t i) {
  return getRuleContext<GreenPlumParser::Trigger_one_eventContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Trigger_eventsContext::OR() {
  return getTokens(GreenPlumParser::OR);
}

tree::TerminalNode* GreenPlumParser::Trigger_eventsContext::OR(size_t i) {
  return getToken(GreenPlumParser::OR, i);
}


size_t GreenPlumParser::Trigger_eventsContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrigger_events;
}

void GreenPlumParser::Trigger_eventsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_events(this);
}

void GreenPlumParser::Trigger_eventsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_events(this);
}


antlrcpp::Any GreenPlumParser::Trigger_eventsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_events(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trigger_eventsContext* GreenPlumParser::trigger_events() {
  Trigger_eventsContext *_localctx = _tracker.createInstance<Trigger_eventsContext>(_ctx, getState());
  enterRule(_localctx, 398, GreenPlumParser::RuleTrigger_events);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3242);
    trigger_one_event();
    setState(3247);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::OR) {
      setState(3243);
      match(GreenPlumParser::OR);
      setState(3244);
      trigger_one_event();
      setState(3249);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_one_eventContext ------------------------------------------------------------------

GreenPlumParser::Trigger_one_eventContext::Trigger_one_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Trigger_one_eventContext::INSERT() {
  return getToken(GreenPlumParser::INSERT, 0);
}

tree::TerminalNode* GreenPlumParser::Trigger_one_eventContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Trigger_one_eventContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}


size_t GreenPlumParser::Trigger_one_eventContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrigger_one_event;
}

void GreenPlumParser::Trigger_one_eventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_one_event(this);
}

void GreenPlumParser::Trigger_one_eventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_one_event(this);
}


antlrcpp::Any GreenPlumParser::Trigger_one_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_one_event(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trigger_one_eventContext* GreenPlumParser::trigger_one_event() {
  Trigger_one_eventContext *_localctx = _tracker.createInstance<Trigger_one_eventContext>(_ctx, getState());
  enterRule(_localctx, 400, GreenPlumParser::RuleTrigger_one_event);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3250);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::DELETE_P || _la == GreenPlumParser::INSERT || _la == GreenPlumParser::UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_for_specContext ------------------------------------------------------------------

GreenPlumParser::Trigger_for_specContext::Trigger_for_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Trigger_for_specContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

GreenPlumParser::Trigger_for_typeContext* GreenPlumParser::Trigger_for_specContext::trigger_for_type() {
  return getRuleContext<GreenPlumParser::Trigger_for_typeContext>(0);
}

tree::TerminalNode* GreenPlumParser::Trigger_for_specContext::EACH() {
  return getToken(GreenPlumParser::EACH, 0);
}


size_t GreenPlumParser::Trigger_for_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrigger_for_spec;
}

void GreenPlumParser::Trigger_for_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_for_spec(this);
}

void GreenPlumParser::Trigger_for_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_for_spec(this);
}


antlrcpp::Any GreenPlumParser::Trigger_for_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_for_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trigger_for_specContext* GreenPlumParser::trigger_for_spec() {
  Trigger_for_specContext *_localctx = _tracker.createInstance<Trigger_for_specContext>(_ctx, getState());
  enterRule(_localctx, 402, GreenPlumParser::RuleTrigger_for_spec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3252);
    match(GreenPlumParser::FOR);
    setState(3254);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::EACH) {
      setState(3253);
      match(GreenPlumParser::EACH);
    }
    setState(3256);
    trigger_for_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_for_typeContext ------------------------------------------------------------------

GreenPlumParser::Trigger_for_typeContext::Trigger_for_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Trigger_for_typeContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

tree::TerminalNode* GreenPlumParser::Trigger_for_typeContext::STATEMENT() {
  return getToken(GreenPlumParser::STATEMENT, 0);
}


size_t GreenPlumParser::Trigger_for_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrigger_for_type;
}

void GreenPlumParser::Trigger_for_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_for_type(this);
}

void GreenPlumParser::Trigger_for_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_for_type(this);
}


antlrcpp::Any GreenPlumParser::Trigger_for_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_for_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trigger_for_typeContext* GreenPlumParser::trigger_for_type() {
  Trigger_for_typeContext *_localctx = _tracker.createInstance<Trigger_for_typeContext>(_ctx, getState());
  enterRule(_localctx, 404, GreenPlumParser::RuleTrigger_for_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3258);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::ROW

    || _la == GreenPlumParser::STATEMENT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_func_argsContext ------------------------------------------------------------------

GreenPlumParser::Trigger_func_argsContext::Trigger_func_argsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Trigger_func_argContext *> GreenPlumParser::Trigger_func_argsContext::trigger_func_arg() {
  return getRuleContexts<GreenPlumParser::Trigger_func_argContext>();
}

GreenPlumParser::Trigger_func_argContext* GreenPlumParser::Trigger_func_argsContext::trigger_func_arg(size_t i) {
  return getRuleContext<GreenPlumParser::Trigger_func_argContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Trigger_func_argsContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Trigger_func_argsContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Trigger_func_argsContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrigger_func_args;
}

void GreenPlumParser::Trigger_func_argsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_func_args(this);
}

void GreenPlumParser::Trigger_func_argsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_func_args(this);
}


antlrcpp::Any GreenPlumParser::Trigger_func_argsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_func_args(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trigger_func_argsContext* GreenPlumParser::trigger_func_args() {
  Trigger_func_argsContext *_localctx = _tracker.createInstance<Trigger_func_argsContext>(_ctx, getState());
  enterRule(_localctx, 406, GreenPlumParser::RuleTrigger_func_args);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3260);
    trigger_func_arg();
    setState(3265);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3261);
      match(GreenPlumParser::COMMA);
      setState(3262);
      trigger_func_arg();
      setState(3267);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_func_argContext ------------------------------------------------------------------

GreenPlumParser::Trigger_func_argContext::Trigger_func_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Trigger_func_argContext::ICONST() {
  return getToken(GreenPlumParser::ICONST, 0);
}

tree::TerminalNode* GreenPlumParser::Trigger_func_argContext::FCONST() {
  return getToken(GreenPlumParser::FCONST, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Trigger_func_argContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Trigger_func_argContext::BCONST() {
  return getToken(GreenPlumParser::BCONST, 0);
}

tree::TerminalNode* GreenPlumParser::Trigger_func_argContext::XCONST() {
  return getToken(GreenPlumParser::XCONST, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Trigger_func_argContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Trigger_func_argContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrigger_func_arg;
}

void GreenPlumParser::Trigger_func_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_func_arg(this);
}

void GreenPlumParser::Trigger_func_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_func_arg(this);
}


antlrcpp::Any GreenPlumParser::Trigger_func_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_func_arg(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trigger_func_argContext* GreenPlumParser::trigger_func_arg() {
  Trigger_func_argContext *_localctx = _tracker.createInstance<Trigger_func_argContext>(_ctx, getState());
  enterRule(_localctx, 408, GreenPlumParser::RuleTrigger_func_arg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3274);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 287, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3268);
      match(GreenPlumParser::ICONST);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3269);
      match(GreenPlumParser::FCONST);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3270);
      sconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3271);
      match(GreenPlumParser::BCONST);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3272);
      match(GreenPlumParser::XCONST);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3273);
      colid();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_constr_from_tableContext ------------------------------------------------------------------

GreenPlumParser::Opt_constr_from_tableContext::Opt_constr_from_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_constr_from_tableContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Opt_constr_from_tableContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}


size_t GreenPlumParser::Opt_constr_from_tableContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_constr_from_table;
}

void GreenPlumParser::Opt_constr_from_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_constr_from_table(this);
}

void GreenPlumParser::Opt_constr_from_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_constr_from_table(this);
}


antlrcpp::Any GreenPlumParser::Opt_constr_from_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_constr_from_table(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_constr_from_tableContext* GreenPlumParser::opt_constr_from_table() {
  Opt_constr_from_tableContext *_localctx = _tracker.createInstance<Opt_constr_from_tableContext>(_ctx, getState());
  enterRule(_localctx, 410, GreenPlumParser::RuleOpt_constr_from_table);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3276);
    match(GreenPlumParser::FROM);
    setState(3277);
    qualified_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_attr_specContext ------------------------------------------------------------------

GreenPlumParser::Constraint_attr_specContext::Constraint_attr_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Constraint_deferrability_specContext* GreenPlumParser::Constraint_attr_specContext::constraint_deferrability_spec() {
  return getRuleContext<GreenPlumParser::Constraint_deferrability_specContext>(0);
}

GreenPlumParser::Constraint_time_specContext* GreenPlumParser::Constraint_attr_specContext::constraint_time_spec() {
  return getRuleContext<GreenPlumParser::Constraint_time_specContext>(0);
}


size_t GreenPlumParser::Constraint_attr_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraint_attr_spec;
}

void GreenPlumParser::Constraint_attr_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_attr_spec(this);
}

void GreenPlumParser::Constraint_attr_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_attr_spec(this);
}


antlrcpp::Any GreenPlumParser::Constraint_attr_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraint_attr_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraint_attr_specContext* GreenPlumParser::constraint_attr_spec() {
  Constraint_attr_specContext *_localctx = _tracker.createInstance<Constraint_attr_specContext>(_ctx, getState());
  enterRule(_localctx, 412, GreenPlumParser::RuleConstraint_attr_spec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3287);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::DEFERRABLE:
      case GreenPlumParser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(3279);
        constraint_deferrability_spec();
        setState(3281);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::INITIALLY) {
          setState(3280);
          constraint_time_spec();
        }
        break;
      }

      case GreenPlumParser::INITIALLY: {
        enterOuterAlt(_localctx, 2);
        setState(3283);
        constraint_time_spec();
        setState(3285);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::DEFERRABLE || _la == GreenPlumParser::NOT) {
          setState(3284);
          constraint_deferrability_spec();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_deferrability_specContext ------------------------------------------------------------------

GreenPlumParser::Constraint_deferrability_specContext::Constraint_deferrability_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraint_deferrability_specContext::DEFERRABLE() {
  return getToken(GreenPlumParser::DEFERRABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_deferrability_specContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}


size_t GreenPlumParser::Constraint_deferrability_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraint_deferrability_spec;
}

void GreenPlumParser::Constraint_deferrability_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_deferrability_spec(this);
}

void GreenPlumParser::Constraint_deferrability_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_deferrability_spec(this);
}


antlrcpp::Any GreenPlumParser::Constraint_deferrability_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraint_deferrability_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraint_deferrability_specContext* GreenPlumParser::constraint_deferrability_spec() {
  Constraint_deferrability_specContext *_localctx = _tracker.createInstance<Constraint_deferrability_specContext>(_ctx, getState());
  enterRule(_localctx, 414, GreenPlumParser::RuleConstraint_deferrability_spec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3290);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::NOT) {
      setState(3289);
      match(GreenPlumParser::NOT);
    }
    setState(3292);
    match(GreenPlumParser::DEFERRABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraint_time_specContext ------------------------------------------------------------------

GreenPlumParser::Constraint_time_specContext::Constraint_time_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Constraint_time_specContext::INITIALLY() {
  return getToken(GreenPlumParser::INITIALLY, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_time_specContext::IMMEDIATE() {
  return getToken(GreenPlumParser::IMMEDIATE, 0);
}

tree::TerminalNode* GreenPlumParser::Constraint_time_specContext::DEFERRED() {
  return getToken(GreenPlumParser::DEFERRED, 0);
}


size_t GreenPlumParser::Constraint_time_specContext::getRuleIndex() const {
  return GreenPlumParser::RuleConstraint_time_spec;
}

void GreenPlumParser::Constraint_time_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint_time_spec(this);
}

void GreenPlumParser::Constraint_time_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint_time_spec(this);
}


antlrcpp::Any GreenPlumParser::Constraint_time_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConstraint_time_spec(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Constraint_time_specContext* GreenPlumParser::constraint_time_spec() {
  Constraint_time_specContext *_localctx = _tracker.createInstance<Constraint_time_specContext>(_ctx, getState());
  enterRule(_localctx, 416, GreenPlumParser::RuleConstraint_time_spec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3294);
    match(GreenPlumParser::INITIALLY);
    setState(3295);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::DEFERRED || _la == GreenPlumParser::IMMEDIATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_trig_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_trig_stmtContext::Drop_trig_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_trig_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_trig_stmtContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Drop_trig_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_trig_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Drop_trig_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_trig_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_trig_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_trig_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}


size_t GreenPlumParser::Drop_trig_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_trig_stmt;
}

void GreenPlumParser::Drop_trig_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_trig_stmt(this);
}

void GreenPlumParser::Drop_trig_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_trig_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_trig_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_trig_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_trig_stmtContext* GreenPlumParser::drop_trig_stmt() {
  Drop_trig_stmtContext *_localctx = _tracker.createInstance<Drop_trig_stmtContext>(_ctx, getState());
  enterRule(_localctx, 418, GreenPlumParser::RuleDrop_trig_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3315);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3297);
      match(GreenPlumParser::DROP);
      setState(3298);
      match(GreenPlumParser::TRIGGER);
      setState(3299);
      name();
      setState(3300);
      match(GreenPlumParser::ON);
      setState(3301);
      qualified_name();
      setState(3303);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(3302);
        opt_drop_behavior();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3305);
      match(GreenPlumParser::DROP);
      setState(3306);
      match(GreenPlumParser::TRIGGER);
      setState(3307);
      match(GreenPlumParser::IF_P);
      setState(3308);
      match(GreenPlumParser::EXISTS);
      setState(3309);
      name();
      setState(3310);
      match(GreenPlumParser::ON);
      setState(3311);
      qualified_name();
      setState(3313);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(3312);
        opt_drop_behavior();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_assert_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_assert_stmtContext::Create_assert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_assert_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_assert_stmtContext::ASSERTION() {
  return getToken(GreenPlumParser::ASSERTION, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Create_assert_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_assert_stmtContext::CHECK() {
  return getToken(GreenPlumParser::CHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Create_assert_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Create_assert_stmtContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_assert_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Constraint_attr_specContext* GreenPlumParser::Create_assert_stmtContext::constraint_attr_spec() {
  return getRuleContext<GreenPlumParser::Constraint_attr_specContext>(0);
}


size_t GreenPlumParser::Create_assert_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_assert_stmt;
}

void GreenPlumParser::Create_assert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_assert_stmt(this);
}

void GreenPlumParser::Create_assert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_assert_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_assert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_assert_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_assert_stmtContext* GreenPlumParser::create_assert_stmt() {
  Create_assert_stmtContext *_localctx = _tracker.createInstance<Create_assert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 420, GreenPlumParser::RuleCreate_assert_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3317);
    match(GreenPlumParser::CREATE);
    setState(3318);
    match(GreenPlumParser::ASSERTION);
    setState(3319);
    name();
    setState(3320);
    match(GreenPlumParser::CHECK);
    setState(3321);
    match(GreenPlumParser::LEFT_PAREN);
    setState(3322);
    a_expr();
    setState(3323);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(3325);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DEFERRABLE || _la == GreenPlumParser::INITIALLY || _la == GreenPlumParser::NOT) {
      setState(3324);
      constraint_attr_spec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_assert_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_assert_stmtContext::Drop_assert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_assert_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_assert_stmtContext::ASSERTION() {
  return getToken(GreenPlumParser::ASSERTION, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Drop_assert_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_assert_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_assert_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_assert_stmt;
}

void GreenPlumParser::Drop_assert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_assert_stmt(this);
}

void GreenPlumParser::Drop_assert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_assert_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_assert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_assert_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_assert_stmtContext* GreenPlumParser::drop_assert_stmt() {
  Drop_assert_stmtContext *_localctx = _tracker.createInstance<Drop_assert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 422, GreenPlumParser::RuleDrop_assert_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3327);
    match(GreenPlumParser::DROP);
    setState(3328);
    match(GreenPlumParser::ASSERTION);
    setState(3329);
    name();
    setState(3331);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3330);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Define_stmtContext ------------------------------------------------------------------

GreenPlumParser::Define_stmtContext::Define_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Define_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::Define_stmtContext::aggr_args() {
  return getRuleContext<GreenPlumParser::Aggr_argsContext>(0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Define_stmtContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}

GreenPlumParser::Old_aggr_definitionContext* GreenPlumParser::Define_stmtContext::old_aggr_definition() {
  return getRuleContext<GreenPlumParser::Old_aggr_definitionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::ORDERED() {
  return getToken(GreenPlumParser::ORDERED, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Define_stmtContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Define_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Table_func_element_listContext* GreenPlumParser::Define_stmtContext::table_func_element_list() {
  return getRuleContext<GreenPlumParser::Table_func_element_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::PROTOCOL() {
  return getToken(GreenPlumParser::PROTOCOL, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Define_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::TRUSTED() {
  return getToken(GreenPlumParser::TRUSTED, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::ENUM_P() {
  return getToken(GreenPlumParser::ENUM_P, 0);
}

GreenPlumParser::Enum_val_listContext* GreenPlumParser::Define_stmtContext::enum_val_list() {
  return getRuleContext<GreenPlumParser::Enum_val_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::PARSER() {
  return getToken(GreenPlumParser::PARSER, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Define_stmtContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}


size_t GreenPlumParser::Define_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDefine_stmt;
}

void GreenPlumParser::Define_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefine_stmt(this);
}

void GreenPlumParser::Define_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefine_stmt(this);
}


antlrcpp::Any GreenPlumParser::Define_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDefine_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Define_stmtContext* GreenPlumParser::define_stmt() {
  Define_stmtContext *_localctx = _tracker.createInstance<Define_stmtContext>(_ctx, getState());
  enterRule(_localctx, 424, GreenPlumParser::RuleDefine_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3392);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3333);
      match(GreenPlumParser::CREATE);
      setState(3335);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ORDERED) {
        setState(3334);
        match(GreenPlumParser::ORDERED);
      }
      setState(3337);
      match(GreenPlumParser::AGGREGATE);
      setState(3338);
      func_name();
      setState(3343);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
      case 1: {
        setState(3339);
        aggr_args();
        setState(3340);
        definition();
        break;
      }

      case 2: {
        setState(3342);
        old_aggr_definition();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3345);
      match(GreenPlumParser::CREATE);
      setState(3346);
      match(GreenPlumParser::OPERATOR);
      setState(3347);
      any_operator();
      setState(3348);
      definition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3350);
      match(GreenPlumParser::CREATE);
      setState(3351);
      match(GreenPlumParser::TYPE_P);
      setState(3352);
      any_name();
      setState(3353);
      definition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3355);
      match(GreenPlumParser::CREATE);
      setState(3356);
      match(GreenPlumParser::TYPE_P);
      setState(3357);
      any_name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3358);
      match(GreenPlumParser::CREATE);
      setState(3359);
      match(GreenPlumParser::TYPE_P);
      setState(3360);
      any_name();
      setState(3361);
      match(GreenPlumParser::AS);
      setState(3362);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3363);
      table_func_element_list();
      setState(3364);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3366);
      match(GreenPlumParser::CREATE);
      setState(3368);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TRUSTED) {
        setState(3367);
        match(GreenPlumParser::TRUSTED);
      }
      setState(3370);
      match(GreenPlumParser::PROTOCOL);
      setState(3371);
      name();
      setState(3372);
      definition();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3374);
      match(GreenPlumParser::CREATE);
      setState(3375);
      match(GreenPlumParser::TYPE_P);
      setState(3376);
      any_name();
      setState(3377);
      match(GreenPlumParser::AS);
      setState(3378);
      match(GreenPlumParser::ENUM_P);
      setState(3379);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3381);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 501) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 501)) & ((1ULL << (GreenPlumParser::CHAR_STRING - 501))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 501))
        | (1ULL << (GreenPlumParser::SCONST - 501)))) != 0)) {
        setState(3380);
        enum_val_list();
      }
      setState(3383);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3385);
      match(GreenPlumParser::CREATE);
      setState(3386);
      match(GreenPlumParser::TEXT_P);
      setState(3387);
      match(GreenPlumParser::SEARCH);
      setState(3388);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CONFIGURATION

      || _la == GreenPlumParser::DICTIONARY || _la == GreenPlumParser::PARSER || _la == GreenPlumParser::TEMPLATE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3389);
      any_name();
      setState(3390);
      definition();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinitionContext ------------------------------------------------------------------

GreenPlumParser::DefinitionContext::DefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::DefinitionContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Def_listContext* GreenPlumParser::DefinitionContext::def_list() {
  return getRuleContext<GreenPlumParser::Def_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::DefinitionContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::DefinitionContext::getRuleIndex() const {
  return GreenPlumParser::RuleDefinition;
}

void GreenPlumParser::DefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinition(this);
}

void GreenPlumParser::DefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinition(this);
}


antlrcpp::Any GreenPlumParser::DefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDefinition(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::definition() {
  DefinitionContext *_localctx = _tracker.createInstance<DefinitionContext>(_ctx, getState());
  enterRule(_localctx, 426, GreenPlumParser::RuleDefinition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3394);
    match(GreenPlumParser::LEFT_PAREN);
    setState(3395);
    def_list();
    setState(3396);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_listContext ------------------------------------------------------------------

GreenPlumParser::Def_listContext::Def_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Def_elemContext *> GreenPlumParser::Def_listContext::def_elem() {
  return getRuleContexts<GreenPlumParser::Def_elemContext>();
}

GreenPlumParser::Def_elemContext* GreenPlumParser::Def_listContext::def_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Def_elemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Def_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Def_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Def_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleDef_list;
}

void GreenPlumParser::Def_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDef_list(this);
}

void GreenPlumParser::Def_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDef_list(this);
}


antlrcpp::Any GreenPlumParser::Def_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDef_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Def_listContext* GreenPlumParser::def_list() {
  Def_listContext *_localctx = _tracker.createInstance<Def_listContext>(_ctx, getState());
  enterRule(_localctx, 428, GreenPlumParser::RuleDef_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3398);
    def_elem();
    setState(3403);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3399);
      match(GreenPlumParser::COMMA);
      setState(3400);
      def_elem();
      setState(3405);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_elemContext ------------------------------------------------------------------

GreenPlumParser::Def_elemContext::Def_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Def_elemContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}

tree::TerminalNode* GreenPlumParser::Def_elemContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

GreenPlumParser::Def_argContext* GreenPlumParser::Def_elemContext::def_arg() {
  return getRuleContext<GreenPlumParser::Def_argContext>(0);
}


size_t GreenPlumParser::Def_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleDef_elem;
}

void GreenPlumParser::Def_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDef_elem(this);
}

void GreenPlumParser::Def_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDef_elem(this);
}


antlrcpp::Any GreenPlumParser::Def_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDef_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Def_elemContext* GreenPlumParser::def_elem() {
  Def_elemContext *_localctx = _tracker.createInstance<Def_elemContext>(_ctx, getState());
  enterRule(_localctx, 430, GreenPlumParser::RuleDef_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3411);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3406);
      col_label();
      setState(3407);
      match(GreenPlumParser::EQUALS_OP);
      setState(3408);
      def_arg();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3410);
      col_label();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_argContext ------------------------------------------------------------------

GreenPlumParser::Def_argContext::Def_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Func_typeContext* GreenPlumParser::Def_argContext::func_type() {
  return getRuleContext<GreenPlumParser::Func_typeContext>(0);
}

tree::TerminalNode* GreenPlumParser::Def_argContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

GreenPlumParser::Reserved_keywordContext* GreenPlumParser::Def_argContext::reserved_keyword() {
  return getRuleContext<GreenPlumParser::Reserved_keywordContext>(0);
}

GreenPlumParser::Qual_all_OpContext* GreenPlumParser::Def_argContext::qual_all_Op() {
  return getRuleContext<GreenPlumParser::Qual_all_OpContext>(0);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::Def_argContext::numberic_only() {
  return getRuleContext<GreenPlumParser::Numberic_onlyContext>(0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Def_argContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Def_argContext::NONE() {
  return getToken(GreenPlumParser::NONE, 0);
}


size_t GreenPlumParser::Def_argContext::getRuleIndex() const {
  return GreenPlumParser::RuleDef_arg;
}

void GreenPlumParser::Def_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDef_arg(this);
}

void GreenPlumParser::Def_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDef_arg(this);
}


antlrcpp::Any GreenPlumParser::Def_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDef_arg(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Def_argContext* GreenPlumParser::def_arg() {
  Def_argContext *_localctx = _tracker.createInstance<Def_argContext>(_ctx, getState());
  enterRule(_localctx, 432, GreenPlumParser::RuleDef_arg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3420);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3413);
      func_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3414);
      match(GreenPlumParser::ROW);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3415);
      reserved_keyword();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3416);
      qual_all_Op();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3417);
      numberic_only();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3418);
      sconst();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3419);
      match(GreenPlumParser::NONE);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggr_argsContext ------------------------------------------------------------------

GreenPlumParser::Aggr_argsContext::Aggr_argsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Paren_type_listContext* GreenPlumParser::Aggr_argsContext::paren_type_list() {
  return getRuleContext<GreenPlumParser::Paren_type_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Aggr_argsContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Aggr_argsContext::ASTERISK() {
  return getToken(GreenPlumParser::ASTERISK, 0);
}

tree::TerminalNode* GreenPlumParser::Aggr_argsContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Aggr_argsContext::getRuleIndex() const {
  return GreenPlumParser::RuleAggr_args;
}

void GreenPlumParser::Aggr_argsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggr_args(this);
}

void GreenPlumParser::Aggr_argsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggr_args(this);
}


antlrcpp::Any GreenPlumParser::Aggr_argsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAggr_args(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::aggr_args() {
  Aggr_argsContext *_localctx = _tracker.createInstance<Aggr_argsContext>(_ctx, getState());
  enterRule(_localctx, 434, GreenPlumParser::RuleAggr_args);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3426);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3422);
      paren_type_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3423);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3424);
      match(GreenPlumParser::ASTERISK);
      setState(3425);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Old_aggr_definitionContext ------------------------------------------------------------------

GreenPlumParser::Old_aggr_definitionContext::Old_aggr_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Old_aggr_definitionContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Old_aggr_listContext* GreenPlumParser::Old_aggr_definitionContext::old_aggr_list() {
  return getRuleContext<GreenPlumParser::Old_aggr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Old_aggr_definitionContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Old_aggr_definitionContext::getRuleIndex() const {
  return GreenPlumParser::RuleOld_aggr_definition;
}

void GreenPlumParser::Old_aggr_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOld_aggr_definition(this);
}

void GreenPlumParser::Old_aggr_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOld_aggr_definition(this);
}


antlrcpp::Any GreenPlumParser::Old_aggr_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOld_aggr_definition(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Old_aggr_definitionContext* GreenPlumParser::old_aggr_definition() {
  Old_aggr_definitionContext *_localctx = _tracker.createInstance<Old_aggr_definitionContext>(_ctx, getState());
  enterRule(_localctx, 436, GreenPlumParser::RuleOld_aggr_definition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3428);
    match(GreenPlumParser::LEFT_PAREN);
    setState(3429);
    old_aggr_list();
    setState(3430);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Old_aggr_listContext ------------------------------------------------------------------

GreenPlumParser::Old_aggr_listContext::Old_aggr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Old_aggr_elemContext *> GreenPlumParser::Old_aggr_listContext::old_aggr_elem() {
  return getRuleContexts<GreenPlumParser::Old_aggr_elemContext>();
}

GreenPlumParser::Old_aggr_elemContext* GreenPlumParser::Old_aggr_listContext::old_aggr_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Old_aggr_elemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Old_aggr_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Old_aggr_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Old_aggr_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleOld_aggr_list;
}

void GreenPlumParser::Old_aggr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOld_aggr_list(this);
}

void GreenPlumParser::Old_aggr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOld_aggr_list(this);
}


antlrcpp::Any GreenPlumParser::Old_aggr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOld_aggr_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Old_aggr_listContext* GreenPlumParser::old_aggr_list() {
  Old_aggr_listContext *_localctx = _tracker.createInstance<Old_aggr_listContext>(_ctx, getState());
  enterRule(_localctx, 438, GreenPlumParser::RuleOld_aggr_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3432);
    old_aggr_elem();
    setState(3437);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3433);
      match(GreenPlumParser::COMMA);
      setState(3434);
      old_aggr_elem();
      setState(3439);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Old_aggr_elemContext ------------------------------------------------------------------

GreenPlumParser::Old_aggr_elemContext::Old_aggr_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IdentifierContext* GreenPlumParser::Old_aggr_elemContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}

tree::TerminalNode* GreenPlumParser::Old_aggr_elemContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

GreenPlumParser::Def_argContext* GreenPlumParser::Old_aggr_elemContext::def_arg() {
  return getRuleContext<GreenPlumParser::Def_argContext>(0);
}


size_t GreenPlumParser::Old_aggr_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleOld_aggr_elem;
}

void GreenPlumParser::Old_aggr_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOld_aggr_elem(this);
}

void GreenPlumParser::Old_aggr_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOld_aggr_elem(this);
}


antlrcpp::Any GreenPlumParser::Old_aggr_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOld_aggr_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Old_aggr_elemContext* GreenPlumParser::old_aggr_elem() {
  Old_aggr_elemContext *_localctx = _tracker.createInstance<Old_aggr_elemContext>(_ctx, getState());
  enterRule(_localctx, 440, GreenPlumParser::RuleOld_aggr_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3440);
    identifier();
    setState(3441);
    match(GreenPlumParser::EQUALS_OP);
    setState(3442);
    def_arg();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_val_listContext ------------------------------------------------------------------

GreenPlumParser::Enum_val_listContext::Enum_val_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::SconstContext *> GreenPlumParser::Enum_val_listContext::sconst() {
  return getRuleContexts<GreenPlumParser::SconstContext>();
}

GreenPlumParser::SconstContext* GreenPlumParser::Enum_val_listContext::sconst(size_t i) {
  return getRuleContext<GreenPlumParser::SconstContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Enum_val_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Enum_val_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Enum_val_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleEnum_val_list;
}

void GreenPlumParser::Enum_val_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnum_val_list(this);
}

void GreenPlumParser::Enum_val_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnum_val_list(this);
}


antlrcpp::Any GreenPlumParser::Enum_val_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitEnum_val_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Enum_val_listContext* GreenPlumParser::enum_val_list() {
  Enum_val_listContext *_localctx = _tracker.createInstance<Enum_val_listContext>(_ctx, getState());
  enterRule(_localctx, 442, GreenPlumParser::RuleEnum_val_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3444);
    sconst();
    setState(3449);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3445);
      match(GreenPlumParser::COMMA);
      setState(3446);
      sconst();
      setState(3451);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_op_class_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_op_class_stmtContext::Create_op_class_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Create_op_class_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Create_op_class_stmtContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Create_op_class_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Opclass_item_listContext* GreenPlumParser::Create_op_class_stmtContext::opclass_item_list() {
  return getRuleContext<GreenPlumParser::Opclass_item_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_op_class_stmtContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

GreenPlumParser::Opt_opfamilyContext* GreenPlumParser::Create_op_class_stmtContext::opt_opfamily() {
  return getRuleContext<GreenPlumParser::Opt_opfamilyContext>(0);
}


size_t GreenPlumParser::Create_op_class_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_op_class_stmt;
}

void GreenPlumParser::Create_op_class_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_op_class_stmt(this);
}

void GreenPlumParser::Create_op_class_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_op_class_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_op_class_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_op_class_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_op_class_stmtContext* GreenPlumParser::create_op_class_stmt() {
  Create_op_class_stmtContext *_localctx = _tracker.createInstance<Create_op_class_stmtContext>(_ctx, getState());
  enterRule(_localctx, 444, GreenPlumParser::RuleCreate_op_class_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3452);
    match(GreenPlumParser::CREATE);
    setState(3453);
    match(GreenPlumParser::OPERATOR);
    setState(3454);
    match(GreenPlumParser::CLASS);
    setState(3455);
    any_name();
    setState(3457);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DEFAULT) {
      setState(3456);
      match(GreenPlumParser::DEFAULT);
    }
    setState(3459);
    match(GreenPlumParser::FOR);
    setState(3460);
    match(GreenPlumParser::TYPE_P);
    setState(3461);
    typename_pg();
    setState(3462);
    match(GreenPlumParser::USING);
    setState(3463);
    access_method();
    setState(3465);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::FAMILY) {
      setState(3464);
      opt_opfamily();
    }
    setState(3467);
    match(GreenPlumParser::AS);
    setState(3468);
    opclass_item_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_item_listContext ------------------------------------------------------------------

GreenPlumParser::Opclass_item_listContext::Opclass_item_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Opclass_itemContext *> GreenPlumParser::Opclass_item_listContext::opclass_item() {
  return getRuleContexts<GreenPlumParser::Opclass_itemContext>();
}

GreenPlumParser::Opclass_itemContext* GreenPlumParser::Opclass_item_listContext::opclass_item(size_t i) {
  return getRuleContext<GreenPlumParser::Opclass_itemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Opclass_item_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Opclass_item_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Opclass_item_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpclass_item_list;
}

void GreenPlumParser::Opclass_item_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpclass_item_list(this);
}

void GreenPlumParser::Opclass_item_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpclass_item_list(this);
}


antlrcpp::Any GreenPlumParser::Opclass_item_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_item_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opclass_item_listContext* GreenPlumParser::opclass_item_list() {
  Opclass_item_listContext *_localctx = _tracker.createInstance<Opclass_item_listContext>(_ctx, getState());
  enterRule(_localctx, 446, GreenPlumParser::RuleOpclass_item_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3470);
    opclass_item();
    setState(3475);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3471);
      match(GreenPlumParser::COMMA);
      setState(3472);
      opclass_item();
      setState(3477);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_itemContext ------------------------------------------------------------------

GreenPlumParser::Opclass_itemContext::Opclass_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opclass_itemContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Opclass_itemContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Opclass_itemContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

GreenPlumParser::Oper_argtypesContext* GreenPlumParser::Opclass_itemContext::oper_argtypes() {
  return getRuleContext<GreenPlumParser::Oper_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opclass_itemContext::RECHECK() {
  return getToken(GreenPlumParser::RECHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Opclass_itemContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Opclass_itemContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Func_argsContext* GreenPlumParser::Opclass_itemContext::func_args() {
  return getRuleContext<GreenPlumParser::Func_argsContext>(0);
}

GreenPlumParser::Paren_type_listContext* GreenPlumParser::Opclass_itemContext::paren_type_list() {
  return getRuleContext<GreenPlumParser::Paren_type_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opclass_itemContext::STORAGE() {
  return getToken(GreenPlumParser::STORAGE, 0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Opclass_itemContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}


size_t GreenPlumParser::Opclass_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpclass_item;
}

void GreenPlumParser::Opclass_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpclass_item(this);
}

void GreenPlumParser::Opclass_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpclass_item(this);
}


antlrcpp::Any GreenPlumParser::Opclass_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opclass_itemContext* GreenPlumParser::opclass_item() {
  Opclass_itemContext *_localctx = _tracker.createInstance<Opclass_itemContext>(_ctx, getState());
  enterRule(_localctx, 448, GreenPlumParser::RuleOpclass_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3500);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3478);
      match(GreenPlumParser::OPERATOR);
      setState(3479);
      iconst();
      setState(3480);
      any_operator();
      setState(3482);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(3481);
        oper_argtypes();
      }
      setState(3485);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::RECHECK) {
        setState(3484);
        match(GreenPlumParser::RECHECK);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3487);
      match(GreenPlumParser::FUNCTION);
      setState(3488);
      iconst();
      setState(3489);
      func_name();
      setState(3490);
      func_args();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3492);
      match(GreenPlumParser::FUNCTION);
      setState(3493);
      iconst();
      setState(3494);
      paren_type_list();
      setState(3495);
      func_name();
      setState(3496);
      func_args();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3498);
      match(GreenPlumParser::STORAGE);
      setState(3499);
      typename_pg();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_opfamilyContext ------------------------------------------------------------------

GreenPlumParser::Opt_opfamilyContext::Opt_opfamilyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_opfamilyContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Opt_opfamilyContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}


size_t GreenPlumParser::Opt_opfamilyContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_opfamily;
}

void GreenPlumParser::Opt_opfamilyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_opfamily(this);
}

void GreenPlumParser::Opt_opfamilyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_opfamily(this);
}


antlrcpp::Any GreenPlumParser::Opt_opfamilyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_opfamily(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_opfamilyContext* GreenPlumParser::opt_opfamily() {
  Opt_opfamilyContext *_localctx = _tracker.createInstance<Opt_opfamilyContext>(_ctx, getState());
  enterRule(_localctx, 450, GreenPlumParser::RuleOpt_opfamily);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3502);
    match(GreenPlumParser::FAMILY);
    setState(3503);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_op_family_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_op_family_stmtContext::Create_op_family_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_op_family_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_op_family_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Create_op_family_stmtContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Create_op_family_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_op_family_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Create_op_family_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}


size_t GreenPlumParser::Create_op_family_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_op_family_stmt;
}

void GreenPlumParser::Create_op_family_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_op_family_stmt(this);
}

void GreenPlumParser::Create_op_family_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_op_family_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_op_family_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_op_family_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_op_family_stmtContext* GreenPlumParser::create_op_family_stmt() {
  Create_op_family_stmtContext *_localctx = _tracker.createInstance<Create_op_family_stmtContext>(_ctx, getState());
  enterRule(_localctx, 452, GreenPlumParser::RuleCreate_op_family_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3505);
    match(GreenPlumParser::CREATE);
    setState(3506);
    match(GreenPlumParser::OPERATOR);
    setState(3507);
    match(GreenPlumParser::FAMILY);
    setState(3508);
    any_name();
    setState(3509);
    match(GreenPlumParser::USING);
    setState(3510);
    access_method();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_op_family_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_op_family_stmtContext::Alter_op_family_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_op_family_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_op_family_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_op_family_stmtContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_op_family_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_op_family_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Alter_op_family_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_op_family_stmtContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

GreenPlumParser::Opclass_item_listContext* GreenPlumParser::Alter_op_family_stmtContext::opclass_item_list() {
  return getRuleContext<GreenPlumParser::Opclass_item_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_op_family_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

GreenPlumParser::Opclass_drop_listContext* GreenPlumParser::Alter_op_family_stmtContext::opclass_drop_list() {
  return getRuleContext<GreenPlumParser::Opclass_drop_listContext>(0);
}


size_t GreenPlumParser::Alter_op_family_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_op_family_stmt;
}

void GreenPlumParser::Alter_op_family_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_op_family_stmt(this);
}

void GreenPlumParser::Alter_op_family_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_op_family_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_op_family_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_op_family_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_op_family_stmtContext* GreenPlumParser::alter_op_family_stmt() {
  Alter_op_family_stmtContext *_localctx = _tracker.createInstance<Alter_op_family_stmtContext>(_ctx, getState());
  enterRule(_localctx, 454, GreenPlumParser::RuleAlter_op_family_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3530);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3512);
      match(GreenPlumParser::ALTER);
      setState(3513);
      match(GreenPlumParser::OPERATOR);
      setState(3514);
      match(GreenPlumParser::FAMILY);
      setState(3515);
      any_name();
      setState(3516);
      match(GreenPlumParser::USING);
      setState(3517);
      access_method();
      setState(3518);
      match(GreenPlumParser::ADD_P);
      setState(3519);
      opclass_item_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3521);
      match(GreenPlumParser::ALTER);
      setState(3522);
      match(GreenPlumParser::OPERATOR);
      setState(3523);
      match(GreenPlumParser::FAMILY);
      setState(3524);
      any_name();
      setState(3525);
      match(GreenPlumParser::USING);
      setState(3526);
      access_method();
      setState(3527);
      match(GreenPlumParser::DROP);
      setState(3528);
      opclass_drop_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_drop_listContext ------------------------------------------------------------------

GreenPlumParser::Opclass_drop_listContext::Opclass_drop_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Opclass_dropContext *> GreenPlumParser::Opclass_drop_listContext::opclass_drop() {
  return getRuleContexts<GreenPlumParser::Opclass_dropContext>();
}

GreenPlumParser::Opclass_dropContext* GreenPlumParser::Opclass_drop_listContext::opclass_drop(size_t i) {
  return getRuleContext<GreenPlumParser::Opclass_dropContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Opclass_drop_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Opclass_drop_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Opclass_drop_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpclass_drop_list;
}

void GreenPlumParser::Opclass_drop_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpclass_drop_list(this);
}

void GreenPlumParser::Opclass_drop_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpclass_drop_list(this);
}


antlrcpp::Any GreenPlumParser::Opclass_drop_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_drop_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opclass_drop_listContext* GreenPlumParser::opclass_drop_list() {
  Opclass_drop_listContext *_localctx = _tracker.createInstance<Opclass_drop_listContext>(_ctx, getState());
  enterRule(_localctx, 456, GreenPlumParser::RuleOpclass_drop_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3532);
    opclass_drop();
    setState(3537);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3533);
      match(GreenPlumParser::COMMA);
      setState(3534);
      opclass_drop();
      setState(3539);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_dropContext ------------------------------------------------------------------

GreenPlumParser::Opclass_dropContext::Opclass_dropContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IconstContext* GreenPlumParser::Opclass_dropContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

GreenPlumParser::Paren_type_listContext* GreenPlumParser::Opclass_dropContext::paren_type_list() {
  return getRuleContext<GreenPlumParser::Paren_type_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opclass_dropContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Opclass_dropContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}


size_t GreenPlumParser::Opclass_dropContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpclass_drop;
}

void GreenPlumParser::Opclass_dropContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpclass_drop(this);
}

void GreenPlumParser::Opclass_dropContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpclass_drop(this);
}


antlrcpp::Any GreenPlumParser::Opclass_dropContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_drop(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opclass_dropContext* GreenPlumParser::opclass_drop() {
  Opclass_dropContext *_localctx = _tracker.createInstance<Opclass_dropContext>(_ctx, getState());
  enterRule(_localctx, 458, GreenPlumParser::RuleOpclass_drop);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3540);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::FUNCTION || _la == GreenPlumParser::OPERATOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3541);
    iconst();
    setState(3542);
    paren_type_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_op_class_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_op_class_stmtContext::Drop_op_class_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_op_class_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_class_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_class_stmtContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Drop_op_class_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_class_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Drop_op_class_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_class_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_class_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_op_class_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_op_class_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_op_class_stmt;
}

void GreenPlumParser::Drop_op_class_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_op_class_stmt(this);
}

void GreenPlumParser::Drop_op_class_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_op_class_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_op_class_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_op_class_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_op_class_stmtContext* GreenPlumParser::drop_op_class_stmt() {
  Drop_op_class_stmtContext *_localctx = _tracker.createInstance<Drop_op_class_stmtContext>(_ctx, getState());
  enterRule(_localctx, 460, GreenPlumParser::RuleDrop_op_class_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3544);
    match(GreenPlumParser::DROP);
    setState(3545);
    match(GreenPlumParser::OPERATOR);
    setState(3546);
    match(GreenPlumParser::CLASS);
    setState(3549);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
    case 1: {
      setState(3547);
      match(GreenPlumParser::IF_P);
      setState(3548);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(3551);
    any_name();
    setState(3552);
    match(GreenPlumParser::USING);
    setState(3553);
    access_method();
    setState(3555);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3554);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_op_family_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_op_family_stmtContext::Drop_op_family_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_op_family_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_family_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_family_stmtContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Drop_op_family_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_family_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Drop_op_family_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_family_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_op_family_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_op_family_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_op_family_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_op_family_stmt;
}

void GreenPlumParser::Drop_op_family_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_op_family_stmt(this);
}

void GreenPlumParser::Drop_op_family_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_op_family_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_op_family_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_op_family_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_op_family_stmtContext* GreenPlumParser::drop_op_family_stmt() {
  Drop_op_family_stmtContext *_localctx = _tracker.createInstance<Drop_op_family_stmtContext>(_ctx, getState());
  enterRule(_localctx, 462, GreenPlumParser::RuleDrop_op_family_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3557);
    match(GreenPlumParser::DROP);
    setState(3558);
    match(GreenPlumParser::OPERATOR);
    setState(3559);
    match(GreenPlumParser::FAMILY);
    setState(3562);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
    case 1: {
      setState(3560);
      match(GreenPlumParser::IF_P);
      setState(3561);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(3564);
    any_name();
    setState(3565);
    match(GreenPlumParser::USING);
    setState(3566);
    access_method();
    setState(3568);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3567);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_owned_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_owned_stmtContext::Drop_owned_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_owned_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_owned_stmtContext::OWNED() {
  return getToken(GreenPlumParser::OWNED, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_owned_stmtContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Drop_owned_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_owned_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_owned_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_owned_stmt;
}

void GreenPlumParser::Drop_owned_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_owned_stmt(this);
}

void GreenPlumParser::Drop_owned_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_owned_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_owned_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_owned_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_owned_stmtContext* GreenPlumParser::drop_owned_stmt() {
  Drop_owned_stmtContext *_localctx = _tracker.createInstance<Drop_owned_stmtContext>(_ctx, getState());
  enterRule(_localctx, 464, GreenPlumParser::RuleDrop_owned_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3570);
    match(GreenPlumParser::DROP);
    setState(3571);
    match(GreenPlumParser::OWNED);
    setState(3572);
    match(GreenPlumParser::BY);
    setState(3573);
    name_list();
    setState(3575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3574);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reassign_owned_stmtContext ------------------------------------------------------------------

GreenPlumParser::Reassign_owned_stmtContext::Reassign_owned_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Reassign_owned_stmtContext::REASSIGN() {
  return getToken(GreenPlumParser::REASSIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Reassign_owned_stmtContext::OWNED() {
  return getToken(GreenPlumParser::OWNED, 0);
}

tree::TerminalNode* GreenPlumParser::Reassign_owned_stmtContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Reassign_owned_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Reassign_owned_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Reassign_owned_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Reassign_owned_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleReassign_owned_stmt;
}

void GreenPlumParser::Reassign_owned_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReassign_owned_stmt(this);
}

void GreenPlumParser::Reassign_owned_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReassign_owned_stmt(this);
}


antlrcpp::Any GreenPlumParser::Reassign_owned_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitReassign_owned_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Reassign_owned_stmtContext* GreenPlumParser::reassign_owned_stmt() {
  Reassign_owned_stmtContext *_localctx = _tracker.createInstance<Reassign_owned_stmtContext>(_ctx, getState());
  enterRule(_localctx, 466, GreenPlumParser::RuleReassign_owned_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3577);
    match(GreenPlumParser::REASSIGN);
    setState(3578);
    match(GreenPlumParser::OWNED);
    setState(3579);
    match(GreenPlumParser::BY);
    setState(3580);
    name_list();
    setState(3581);
    match(GreenPlumParser::TO);
    setState(3582);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_stmtContext::Drop_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

GreenPlumParser::Drop_typeContext* GreenPlumParser::Drop_stmtContext::drop_type() {
  return getRuleContext<GreenPlumParser::Drop_typeContext>(0);
}

GreenPlumParser::Any_name_listContext* GreenPlumParser::Drop_stmtContext::any_name_list() {
  return getRuleContext<GreenPlumParser::Any_name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_stmt;
}

void GreenPlumParser::Drop_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_stmt(this);
}

void GreenPlumParser::Drop_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_stmtContext* GreenPlumParser::drop_stmt() {
  Drop_stmtContext *_localctx = _tracker.createInstance<Drop_stmtContext>(_ctx, getState());
  enterRule(_localctx, 468, GreenPlumParser::RuleDrop_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3584);
    match(GreenPlumParser::DROP);
    setState(3585);
    drop_type();
    setState(3588);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
    case 1: {
      setState(3586);
      match(GreenPlumParser::IF_P);
      setState(3587);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(3590);
    any_name_list();
    setState(3592);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3591);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_typeContext ------------------------------------------------------------------

GreenPlumParser::Drop_typeContext::Drop_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::EXTERNAL() {
  return getToken(GreenPlumParser::EXTERNAL, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::WEB() {
  return getToken(GreenPlumParser::WEB, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::VIEW() {
  return getToken(GreenPlumParser::VIEW, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::EXTENSION() {
  return getToken(GreenPlumParser::EXTENSION, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::PARSER() {
  return getToken(GreenPlumParser::PARSER, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::FILESPACE() {
  return getToken(GreenPlumParser::FILESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_typeContext::PROTOCOL() {
  return getToken(GreenPlumParser::PROTOCOL, 0);
}


size_t GreenPlumParser::Drop_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_type;
}

void GreenPlumParser::Drop_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_type(this);
}

void GreenPlumParser::Drop_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_type(this);
}


antlrcpp::Any GreenPlumParser::Drop_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_typeContext* GreenPlumParser::drop_type() {
  Drop_typeContext *_localctx = _tracker.createInstance<Drop_typeContext>(_ctx, getState());
  enterRule(_localctx, 470, GreenPlumParser::RuleDrop_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3614);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::TABLE: {
        enterOuterAlt(_localctx, 1);
        setState(3594);
        match(GreenPlumParser::TABLE);
        break;
      }

      case GreenPlumParser::EXTERNAL: {
        enterOuterAlt(_localctx, 2);
        setState(3595);
        match(GreenPlumParser::EXTERNAL);
        setState(3597);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::WEB) {
          setState(3596);
          match(GreenPlumParser::WEB);
        }
        setState(3599);
        match(GreenPlumParser::TABLE);
        break;
      }

      case GreenPlumParser::SEQUENCE: {
        enterOuterAlt(_localctx, 3);
        setState(3600);
        match(GreenPlumParser::SEQUENCE);
        break;
      }

      case GreenPlumParser::VIEW: {
        enterOuterAlt(_localctx, 4);
        setState(3601);
        match(GreenPlumParser::VIEW);
        break;
      }

      case GreenPlumParser::INDEX: {
        enterOuterAlt(_localctx, 5);
        setState(3602);
        match(GreenPlumParser::INDEX);
        break;
      }

      case GreenPlumParser::TYPE_P: {
        enterOuterAlt(_localctx, 6);
        setState(3603);
        match(GreenPlumParser::TYPE_P);
        break;
      }

      case GreenPlumParser::DOMAIN_P: {
        enterOuterAlt(_localctx, 7);
        setState(3604);
        match(GreenPlumParser::DOMAIN_P);
        break;
      }

      case GreenPlumParser::CONVERSION_P: {
        enterOuterAlt(_localctx, 8);
        setState(3605);
        match(GreenPlumParser::CONVERSION_P);
        break;
      }

      case GreenPlumParser::SCHEMA: {
        enterOuterAlt(_localctx, 9);
        setState(3606);
        match(GreenPlumParser::SCHEMA);
        break;
      }

      case GreenPlumParser::EXTENSION: {
        enterOuterAlt(_localctx, 10);
        setState(3607);
        match(GreenPlumParser::EXTENSION);
        break;
      }

      case GreenPlumParser::TEXT_P: {
        enterOuterAlt(_localctx, 11);
        setState(3608);
        match(GreenPlumParser::TEXT_P);
        setState(3609);
        match(GreenPlumParser::SEARCH);
        setState(3610);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::CONFIGURATION

        || _la == GreenPlumParser::DICTIONARY || _la == GreenPlumParser::PARSER || _la == GreenPlumParser::TEMPLATE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case GreenPlumParser::FILESPACE: {
        enterOuterAlt(_localctx, 12);
        setState(3611);
        match(GreenPlumParser::FILESPACE);
        break;
      }

      case GreenPlumParser::TABLESPACE: {
        enterOuterAlt(_localctx, 13);
        setState(3612);
        match(GreenPlumParser::TABLESPACE);
        break;
      }

      case GreenPlumParser::PROTOCOL: {
        enterOuterAlt(_localctx, 14);
        setState(3613);
        match(GreenPlumParser::PROTOCOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_name_listContext ------------------------------------------------------------------

GreenPlumParser::Any_name_listContext::Any_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Any_nameContext *> GreenPlumParser::Any_name_listContext::any_name() {
  return getRuleContexts<GreenPlumParser::Any_nameContext>();
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Any_name_listContext::any_name(size_t i) {
  return getRuleContext<GreenPlumParser::Any_nameContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Any_name_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Any_name_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Any_name_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleAny_name_list;
}

void GreenPlumParser::Any_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAny_name_list(this);
}

void GreenPlumParser::Any_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAny_name_list(this);
}


antlrcpp::Any GreenPlumParser::Any_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAny_name_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Any_name_listContext* GreenPlumParser::any_name_list() {
  Any_name_listContext *_localctx = _tracker.createInstance<Any_name_listContext>(_ctx, getState());
  enterRule(_localctx, 472, GreenPlumParser::RuleAny_name_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3616);
    any_name();
    setState(3621);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3617);
      match(GreenPlumParser::COMMA);
      setState(3618);
      any_name();
      setState(3623);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_nameContext ------------------------------------------------------------------

GreenPlumParser::Any_nameContext::Any_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Any_nameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::AttrsContext* GreenPlumParser::Any_nameContext::attrs() {
  return getRuleContext<GreenPlumParser::AttrsContext>(0);
}


size_t GreenPlumParser::Any_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleAny_name;
}

void GreenPlumParser::Any_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAny_name(this);
}

void GreenPlumParser::Any_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAny_name(this);
}


antlrcpp::Any GreenPlumParser::Any_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAny_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::any_name() {
  Any_nameContext *_localctx = _tracker.createInstance<Any_nameContext>(_ctx, getState());
  enterRule(_localctx, 474, GreenPlumParser::RuleAny_name);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3624);
    colid();
    setState(3626);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PERIOD) {
      setState(3625);
      attrs();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttrsContext ------------------------------------------------------------------

GreenPlumParser::AttrsContext::AttrsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> GreenPlumParser::AttrsContext::PERIOD() {
  return getTokens(GreenPlumParser::PERIOD);
}

tree::TerminalNode* GreenPlumParser::AttrsContext::PERIOD(size_t i) {
  return getToken(GreenPlumParser::PERIOD, i);
}

std::vector<GreenPlumParser::Attr_nameContext *> GreenPlumParser::AttrsContext::attr_name() {
  return getRuleContexts<GreenPlumParser::Attr_nameContext>();
}

GreenPlumParser::Attr_nameContext* GreenPlumParser::AttrsContext::attr_name(size_t i) {
  return getRuleContext<GreenPlumParser::Attr_nameContext>(i);
}


size_t GreenPlumParser::AttrsContext::getRuleIndex() const {
  return GreenPlumParser::RuleAttrs;
}

void GreenPlumParser::AttrsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttrs(this);
}

void GreenPlumParser::AttrsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttrs(this);
}


antlrcpp::Any GreenPlumParser::AttrsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAttrs(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::AttrsContext* GreenPlumParser::attrs() {
  AttrsContext *_localctx = _tracker.createInstance<AttrsContext>(_ctx, getState());
  enterRule(_localctx, 476, GreenPlumParser::RuleAttrs);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3630); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(3628);
              match(GreenPlumParser::PERIOD);
              setState(3629);
              attr_name();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(3632); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Truncate_stmtContext ------------------------------------------------------------------

GreenPlumParser::Truncate_stmtContext::Truncate_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Truncate_stmtContext::TRUNCATE() {
  return getToken(GreenPlumParser::TRUNCATE, 0);
}

GreenPlumParser::Qualified_name_listContext* GreenPlumParser::Truncate_stmtContext::qualified_name_list() {
  return getRuleContext<GreenPlumParser::Qualified_name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Truncate_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Truncate_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Truncate_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleTruncate_stmt;
}

void GreenPlumParser::Truncate_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncate_stmt(this);
}

void GreenPlumParser::Truncate_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncate_stmt(this);
}


antlrcpp::Any GreenPlumParser::Truncate_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTruncate_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Truncate_stmtContext* GreenPlumParser::truncate_stmt() {
  Truncate_stmtContext *_localctx = _tracker.createInstance<Truncate_stmtContext>(_ctx, getState());
  enterRule(_localctx, 478, GreenPlumParser::RuleTruncate_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3634);
    match(GreenPlumParser::TRUNCATE);
    setState(3636);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TABLE) {
      setState(3635);
      match(GreenPlumParser::TABLE);
    }
    setState(3638);
    qualified_name_list();
    setState(3640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3639);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comment_stmtContext ------------------------------------------------------------------

GreenPlumParser::Comment_stmtContext::Comment_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Comment_stmtContext::COMMENT() {
  return getToken(GreenPlumParser::COMMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Comment_stmtOptionContext* GreenPlumParser::Comment_stmtContext::comment_stmtOption() {
  return getRuleContext<GreenPlumParser::Comment_stmtOptionContext>(0);
}


size_t GreenPlumParser::Comment_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleComment_stmt;
}

void GreenPlumParser::Comment_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComment_stmt(this);
}

void GreenPlumParser::Comment_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComment_stmt(this);
}


antlrcpp::Any GreenPlumParser::Comment_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitComment_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Comment_stmtContext* GreenPlumParser::comment_stmt() {
  Comment_stmtContext *_localctx = _tracker.createInstance<Comment_stmtContext>(_ctx, getState());
  enterRule(_localctx, 480, GreenPlumParser::RuleComment_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3642);
    match(GreenPlumParser::COMMENT);
    setState(3643);
    match(GreenPlumParser::ON);
    setState(3644);
    comment_stmtOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comment_stmtOptionContext ------------------------------------------------------------------

GreenPlumParser::Comment_stmtOptionContext::Comment_stmtOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Comment_optionContext* GreenPlumParser::Comment_stmtOptionContext::comment_option() {
  return getRuleContext<GreenPlumParser::Comment_optionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_stmtOptionContext::IS() {
  return getToken(GreenPlumParser::IS, 0);
}

GreenPlumParser::Comment_textContext* GreenPlumParser::Comment_stmtOptionContext::comment_text() {
  return getRuleContext<GreenPlumParser::Comment_textContext>(0);
}


size_t GreenPlumParser::Comment_stmtOptionContext::getRuleIndex() const {
  return GreenPlumParser::RuleComment_stmtOption;
}

void GreenPlumParser::Comment_stmtOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComment_stmtOption(this);
}

void GreenPlumParser::Comment_stmtOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComment_stmtOption(this);
}


antlrcpp::Any GreenPlumParser::Comment_stmtOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitComment_stmtOption(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Comment_stmtOptionContext* GreenPlumParser::comment_stmtOption() {
  Comment_stmtOptionContext *_localctx = _tracker.createInstance<Comment_stmtOptionContext>(_ctx, getState());
  enterRule(_localctx, 482, GreenPlumParser::RuleComment_stmtOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3646);
    comment_option();
    setState(3647);
    match(GreenPlumParser::IS);
    setState(3648);
    comment_text();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comment_optionContext ------------------------------------------------------------------

GreenPlumParser::Comment_optionContext::Comment_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Comment_typeContext* GreenPlumParser::Comment_optionContext::comment_type() {
  return getRuleContext<GreenPlumParser::Comment_typeContext>(0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Comment_optionContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Comment_optionContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::Comment_optionContext::aggr_args() {
  return getRuleContext<GreenPlumParser::Aggr_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Func_argsContext* GreenPlumParser::Comment_optionContext::func_args() {
  return getRuleContext<GreenPlumParser::Func_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Comment_optionContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

GreenPlumParser::Oper_argtypesContext* GreenPlumParser::Comment_optionContext::oper_argtypes() {
  return getRuleContext<GreenPlumParser::Oper_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::CONSTRAINT() {
  return getToken(GreenPlumParser::CONSTRAINT, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Comment_optionContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::RULE() {
  return getToken(GreenPlumParser::RULE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Comment_optionContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::LARGE_P() {
  return getToken(GreenPlumParser::LARGE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::OBJECT_P() {
  return getToken(GreenPlumParser::OBJECT_P, 0);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::Comment_optionContext::numberic_only() {
  return getRuleContext<GreenPlumParser::Numberic_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::CAST() {
  return getToken(GreenPlumParser::CAST, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

std::vector<GreenPlumParser::Typename_pgContext *> GreenPlumParser::Comment_optionContext::typename_pg() {
  return getRuleContexts<GreenPlumParser::Typename_pgContext>();
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Comment_optionContext::typename_pg(size_t i) {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(i);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::PARSER() {
  return getToken(GreenPlumParser::PARSER, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_optionContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}


size_t GreenPlumParser::Comment_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleComment_option;
}

void GreenPlumParser::Comment_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComment_option(this);
}

void GreenPlumParser::Comment_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComment_option(this);
}


antlrcpp::Any GreenPlumParser::Comment_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitComment_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Comment_optionContext* GreenPlumParser::comment_option() {
  Comment_optionContext *_localctx = _tracker.createInstance<Comment_optionContext>(_ctx, getState());
  enterRule(_localctx, 484, GreenPlumParser::RuleComment_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3702);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3650);
      comment_type();
      setState(3651);
      any_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3653);
      match(GreenPlumParser::AGGREGATE);
      setState(3654);
      func_name();
      setState(3655);
      aggr_args();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3657);
      match(GreenPlumParser::FUNCTION);
      setState(3658);
      func_name();
      setState(3659);
      func_args();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3661);
      match(GreenPlumParser::OPERATOR);
      setState(3662);
      any_operator();
      setState(3663);
      oper_argtypes();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3665);
      match(GreenPlumParser::CONSTRAINT);
      setState(3666);
      name();
      setState(3667);
      match(GreenPlumParser::ON);
      setState(3668);
      any_name();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3670);
      match(GreenPlumParser::RULE);
      setState(3671);
      name();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3672);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::RULE

      || _la == GreenPlumParser::TRIGGER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3673);
      name();
      setState(3674);
      match(GreenPlumParser::ON);
      setState(3675);
      any_name();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3677);
      match(GreenPlumParser::OPERATOR);
      setState(3678);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CLASS || _la == GreenPlumParser::FAMILY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3679);
      any_name();
      setState(3680);
      match(GreenPlumParser::USING);
      setState(3681);
      access_method();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3683);
      match(GreenPlumParser::LARGE_P);
      setState(3684);
      match(GreenPlumParser::OBJECT_P);
      setState(3685);
      numberic_only();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3686);
      match(GreenPlumParser::CAST);
      setState(3687);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3688);
      typename_pg();
      setState(3689);
      match(GreenPlumParser::AS);
      setState(3690);
      typename_pg();
      setState(3691);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3694);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PROCEDURAL) {
        setState(3693);
        match(GreenPlumParser::PROCEDURAL);
      }
      setState(3696);
      match(GreenPlumParser::LANGUAGE);
      setState(3697);
      any_name();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3698);
      match(GreenPlumParser::TEXT_P);
      setState(3699);
      match(GreenPlumParser::SEARCH);
      setState(3700);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CONFIGURATION

      || _la == GreenPlumParser::DICTIONARY || _la == GreenPlumParser::PARSER || _la == GreenPlumParser::TEMPLATE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3701);
      any_name();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comment_typeContext ------------------------------------------------------------------

GreenPlumParser::Comment_typeContext::Comment_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::COLUMN() {
  return getToken(GreenPlumParser::COLUMN, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::VIEW() {
  return getToken(GreenPlumParser::VIEW, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::EXTENSION() {
  return getToken(GreenPlumParser::EXTENSION, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::FILESPACE() {
  return getToken(GreenPlumParser::FILESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Comment_typeContext::QUEUE() {
  return getToken(GreenPlumParser::QUEUE, 0);
}


size_t GreenPlumParser::Comment_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleComment_type;
}

void GreenPlumParser::Comment_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComment_type(this);
}

void GreenPlumParser::Comment_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComment_type(this);
}


antlrcpp::Any GreenPlumParser::Comment_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitComment_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Comment_typeContext* GreenPlumParser::comment_type() {
  Comment_typeContext *_localctx = _tracker.createInstance<Comment_typeContext>(_ctx, getState());
  enterRule(_localctx, 486, GreenPlumParser::RuleComment_type);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3720);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::COLUMN: {
        enterOuterAlt(_localctx, 1);
        setState(3704);
        match(GreenPlumParser::COLUMN);
        break;
      }

      case GreenPlumParser::DATABASE: {
        enterOuterAlt(_localctx, 2);
        setState(3705);
        match(GreenPlumParser::DATABASE);
        break;
      }

      case GreenPlumParser::SCHEMA: {
        enterOuterAlt(_localctx, 3);
        setState(3706);
        match(GreenPlumParser::SCHEMA);
        break;
      }

      case GreenPlumParser::INDEX: {
        enterOuterAlt(_localctx, 4);
        setState(3707);
        match(GreenPlumParser::INDEX);
        break;
      }

      case GreenPlumParser::SEQUENCE: {
        enterOuterAlt(_localctx, 5);
        setState(3708);
        match(GreenPlumParser::SEQUENCE);
        break;
      }

      case GreenPlumParser::TABLE: {
        enterOuterAlt(_localctx, 6);
        setState(3709);
        match(GreenPlumParser::TABLE);
        break;
      }

      case GreenPlumParser::DOMAIN_P: {
        enterOuterAlt(_localctx, 7);
        setState(3710);
        match(GreenPlumParser::DOMAIN_P);
        break;
      }

      case GreenPlumParser::TYPE_P: {
        enterOuterAlt(_localctx, 8);
        setState(3711);
        match(GreenPlumParser::TYPE_P);
        break;
      }

      case GreenPlumParser::VIEW: {
        enterOuterAlt(_localctx, 9);
        setState(3712);
        match(GreenPlumParser::VIEW);
        break;
      }

      case GreenPlumParser::CONVERSION_P: {
        enterOuterAlt(_localctx, 10);
        setState(3713);
        match(GreenPlumParser::CONVERSION_P);
        break;
      }

      case GreenPlumParser::TABLESPACE: {
        enterOuterAlt(_localctx, 11);
        setState(3714);
        match(GreenPlumParser::TABLESPACE);
        break;
      }

      case GreenPlumParser::EXTENSION: {
        enterOuterAlt(_localctx, 12);
        setState(3715);
        match(GreenPlumParser::EXTENSION);
        break;
      }

      case GreenPlumParser::ROLE: {
        enterOuterAlt(_localctx, 13);
        setState(3716);
        match(GreenPlumParser::ROLE);
        break;
      }

      case GreenPlumParser::FILESPACE: {
        enterOuterAlt(_localctx, 14);
        setState(3717);
        match(GreenPlumParser::FILESPACE);
        break;
      }

      case GreenPlumParser::RESOURCE: {
        enterOuterAlt(_localctx, 15);
        setState(3718);
        match(GreenPlumParser::RESOURCE);
        setState(3719);
        match(GreenPlumParser::QUEUE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comment_textContext ------------------------------------------------------------------

GreenPlumParser::Comment_textContext::Comment_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::SconstContext* GreenPlumParser::Comment_textContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Comment_textContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}


size_t GreenPlumParser::Comment_textContext::getRuleIndex() const {
  return GreenPlumParser::RuleComment_text;
}

void GreenPlumParser::Comment_textContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComment_text(this);
}

void GreenPlumParser::Comment_textContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComment_text(this);
}


antlrcpp::Any GreenPlumParser::Comment_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitComment_text(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Comment_textContext* GreenPlumParser::comment_text() {
  Comment_textContext *_localctx = _tracker.createInstance<Comment_textContext>(_ctx, getState());
  enterRule(_localctx, 488, GreenPlumParser::RuleComment_text);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3724);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(3722);
        sconst();
        break;
      }

      case GreenPlumParser::NULL_P: {
        enterOuterAlt(_localctx, 2);
        setState(3723);
        match(GreenPlumParser::NULL_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_stmtContext ------------------------------------------------------------------

GreenPlumParser::Fetch_stmtContext::Fetch_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Fetch_stmtContext::FETCH() {
  return getToken(GreenPlumParser::FETCH, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Fetch_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Fetch_stmtContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_stmtContext::IN_P() {
  return getToken(GreenPlumParser::IN_P, 0);
}

GreenPlumParser::Fetch_directionContext* GreenPlumParser::Fetch_stmtContext::fetch_direction() {
  return getRuleContext<GreenPlumParser::Fetch_directionContext>(0);
}


size_t GreenPlumParser::Fetch_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleFetch_stmt;
}

void GreenPlumParser::Fetch_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFetch_stmt(this);
}

void GreenPlumParser::Fetch_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFetch_stmt(this);
}


antlrcpp::Any GreenPlumParser::Fetch_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFetch_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Fetch_stmtContext* GreenPlumParser::fetch_stmt() {
  Fetch_stmtContext *_localctx = _tracker.createInstance<Fetch_stmtContext>(_ctx, getState());
  enterRule(_localctx, 490, GreenPlumParser::RuleFetch_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3726);
    match(GreenPlumParser::FETCH);
    setState(3731);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
    case 1: {
      setState(3728);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ALL)
        | (1ULL << GreenPlumParser::BACKWARD))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 148)) & ((1ULL << (GreenPlumParser::FIRST_P - 148))
        | (1ULL << (GreenPlumParser::FORWARD - 148))
        | (1ULL << (GreenPlumParser::LAST_P - 148)))) != 0) || _la == GreenPlumParser::NEXT

      || _la == GreenPlumParser::PRIOR || _la == GreenPlumParser::RELATIVE_P || ((((_la - 475) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 475)) & ((1ULL << (GreenPlumParser::PLUS_SIGN - 475))
        | (1ULL << (GreenPlumParser::MINUS_SIGN - 475))
        | (1ULL << (GreenPlumParser::ICONST - 475)))) != 0)) {
        setState(3727);
        fetch_direction();
      }
      setState(3730);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::FROM

      || _la == GreenPlumParser::IN_P)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(3733);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_directionContext ------------------------------------------------------------------

GreenPlumParser::Fetch_directionContext::Fetch_directionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::NEXT() {
  return getToken(GreenPlumParser::NEXT, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::PRIOR() {
  return getToken(GreenPlumParser::PRIOR, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::FIRST_P() {
  return getToken(GreenPlumParser::FIRST_P, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::LAST_P() {
  return getToken(GreenPlumParser::LAST_P, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::ABSOLUTE_P() {
  return getToken(GreenPlumParser::ABSOLUTE_P, 0);
}

GreenPlumParser::Signed_iconstContext* GreenPlumParser::Fetch_directionContext::signed_iconst() {
  return getRuleContext<GreenPlumParser::Signed_iconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::RELATIVE_P() {
  return getToken(GreenPlumParser::RELATIVE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::FORWARD() {
  return getToken(GreenPlumParser::FORWARD, 0);
}

tree::TerminalNode* GreenPlumParser::Fetch_directionContext::BACKWARD() {
  return getToken(GreenPlumParser::BACKWARD, 0);
}


size_t GreenPlumParser::Fetch_directionContext::getRuleIndex() const {
  return GreenPlumParser::RuleFetch_direction;
}

void GreenPlumParser::Fetch_directionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFetch_direction(this);
}

void GreenPlumParser::Fetch_directionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFetch_direction(this);
}


antlrcpp::Any GreenPlumParser::Fetch_directionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFetch_direction(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Fetch_directionContext* GreenPlumParser::fetch_direction() {
  Fetch_directionContext *_localctx = _tracker.createInstance<Fetch_directionContext>(_ctx, getState());
  enterRule(_localctx, 492, GreenPlumParser::RuleFetch_direction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3755);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3735);
      match(GreenPlumParser::NEXT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3736);
      match(GreenPlumParser::PRIOR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3737);
      match(GreenPlumParser::FIRST_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3738);
      match(GreenPlumParser::LAST_P);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3739);
      match(GreenPlumParser::ABSOLUTE_P);
      setState(3740);
      signed_iconst();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3741);
      match(GreenPlumParser::RELATIVE_P);
      setState(3742);
      signed_iconst();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3743);
      signed_iconst();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3744);
      match(GreenPlumParser::ALL);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3745);
      match(GreenPlumParser::FORWARD);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3746);
      match(GreenPlumParser::FORWARD);
      setState(3747);
      signed_iconst();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3748);
      match(GreenPlumParser::FORWARD);
      setState(3749);
      match(GreenPlumParser::ALL);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3750);
      match(GreenPlumParser::BACKWARD);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3751);
      match(GreenPlumParser::BACKWARD);
      setState(3752);
      signed_iconst();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3753);
      match(GreenPlumParser::BACKWARD);
      setState(3754);
      match(GreenPlumParser::ALL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grant_stmtContext ------------------------------------------------------------------

GreenPlumParser::Grant_stmtContext::Grant_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Grant_stmtContext::GRANT() {
  return getToken(GreenPlumParser::GRANT, 0);
}

GreenPlumParser::PrivilegesContext* GreenPlumParser::Grant_stmtContext::privileges() {
  return getRuleContext<GreenPlumParser::PrivilegesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Grant_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Privilege_targetContext* GreenPlumParser::Grant_stmtContext::privilege_target() {
  return getRuleContext<GreenPlumParser::Privilege_targetContext>(0);
}

tree::TerminalNode* GreenPlumParser::Grant_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::Grantee_listContext* GreenPlumParser::Grant_stmtContext::grantee_list() {
  return getRuleContext<GreenPlumParser::Grantee_listContext>(0);
}

GreenPlumParser::Opt_grant_grant_optionContext* GreenPlumParser::Grant_stmtContext::opt_grant_grant_option() {
  return getRuleContext<GreenPlumParser::Opt_grant_grant_optionContext>(0);
}


size_t GreenPlumParser::Grant_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleGrant_stmt;
}

void GreenPlumParser::Grant_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrant_stmt(this);
}

void GreenPlumParser::Grant_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrant_stmt(this);
}


antlrcpp::Any GreenPlumParser::Grant_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGrant_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Grant_stmtContext* GreenPlumParser::grant_stmt() {
  Grant_stmtContext *_localctx = _tracker.createInstance<Grant_stmtContext>(_ctx, getState());
  enterRule(_localctx, 494, GreenPlumParser::RuleGrant_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3757);
    match(GreenPlumParser::GRANT);
    setState(3758);
    privileges();
    setState(3759);
    match(GreenPlumParser::ON);
    setState(3760);
    privilege_target();
    setState(3761);
    match(GreenPlumParser::TO);
    setState(3762);
    grantee_list();
    setState(3764);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(3763);
      opt_grant_grant_option();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Revoke_stmtContext ------------------------------------------------------------------

GreenPlumParser::Revoke_stmtContext::Revoke_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Revoke_stmtContext::REVOKE() {
  return getToken(GreenPlumParser::REVOKE, 0);
}

GreenPlumParser::PrivilegesContext* GreenPlumParser::Revoke_stmtContext::privileges() {
  return getRuleContext<GreenPlumParser::PrivilegesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Revoke_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Privilege_targetContext* GreenPlumParser::Revoke_stmtContext::privilege_target() {
  return getRuleContext<GreenPlumParser::Privilege_targetContext>(0);
}

tree::TerminalNode* GreenPlumParser::Revoke_stmtContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::Grantee_listContext* GreenPlumParser::Revoke_stmtContext::grantee_list() {
  return getRuleContext<GreenPlumParser::Grantee_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Revoke_stmtContext::GRANT() {
  return getToken(GreenPlumParser::GRANT, 0);
}

tree::TerminalNode* GreenPlumParser::Revoke_stmtContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}

tree::TerminalNode* GreenPlumParser::Revoke_stmtContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Revoke_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Revoke_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRevoke_stmt;
}

void GreenPlumParser::Revoke_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevoke_stmt(this);
}

void GreenPlumParser::Revoke_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevoke_stmt(this);
}


antlrcpp::Any GreenPlumParser::Revoke_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRevoke_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Revoke_stmtContext* GreenPlumParser::revoke_stmt() {
  Revoke_stmtContext *_localctx = _tracker.createInstance<Revoke_stmtContext>(_ctx, getState());
  enterRule(_localctx, 496, GreenPlumParser::RuleRevoke_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3766);
    match(GreenPlumParser::REVOKE);
    setState(3770);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GRANT) {
      setState(3767);
      match(GreenPlumParser::GRANT);
      setState(3768);
      match(GreenPlumParser::OPTION);
      setState(3769);
      match(GreenPlumParser::FOR);
    }
    setState(3772);
    privileges();
    setState(3773);
    match(GreenPlumParser::ON);
    setState(3774);
    privilege_target();
    setState(3775);
    match(GreenPlumParser::FROM);
    setState(3776);
    grantee_list();
    setState(3778);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3777);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegesContext ------------------------------------------------------------------

GreenPlumParser::PrivilegesContext::PrivilegesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Privilege_listContext* GreenPlumParser::PrivilegesContext::privilege_list() {
  return getRuleContext<GreenPlumParser::Privilege_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::PrivilegesContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegesContext::PRIVILEGES() {
  return getToken(GreenPlumParser::PRIVILEGES, 0);
}


size_t GreenPlumParser::PrivilegesContext::getRuleIndex() const {
  return GreenPlumParser::RulePrivileges;
}

void GreenPlumParser::PrivilegesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivileges(this);
}

void GreenPlumParser::PrivilegesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivileges(this);
}


antlrcpp::Any GreenPlumParser::PrivilegesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPrivileges(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::PrivilegesContext* GreenPlumParser::privileges() {
  PrivilegesContext *_localctx = _tracker.createInstance<PrivilegesContext>(_ctx, getState());
  enterRule(_localctx, 498, GreenPlumParser::RulePrivileges);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3785);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CONNECT:
      case GreenPlumParser::CREATE:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::REFERENCES:
      case GreenPlumParser::SELECT:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::USAGE: {
        enterOuterAlt(_localctx, 1);
        setState(3780);
        privilege_list();
        break;
      }

      case GreenPlumParser::ALL: {
        enterOuterAlt(_localctx, 2);
        setState(3781);
        match(GreenPlumParser::ALL);
        setState(3783);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::PRIVILEGES) {
          setState(3782);
          match(GreenPlumParser::PRIVILEGES);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Privilege_listContext ------------------------------------------------------------------

GreenPlumParser::Privilege_listContext::Privilege_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::PrivilegeContext *> GreenPlumParser::Privilege_listContext::privilege() {
  return getRuleContexts<GreenPlumParser::PrivilegeContext>();
}

GreenPlumParser::PrivilegeContext* GreenPlumParser::Privilege_listContext::privilege(size_t i) {
  return getRuleContext<GreenPlumParser::PrivilegeContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Privilege_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Privilege_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Privilege_listContext::getRuleIndex() const {
  return GreenPlumParser::RulePrivilege_list;
}

void GreenPlumParser::Privilege_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilege_list(this);
}

void GreenPlumParser::Privilege_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilege_list(this);
}


antlrcpp::Any GreenPlumParser::Privilege_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Privilege_listContext* GreenPlumParser::privilege_list() {
  Privilege_listContext *_localctx = _tracker.createInstance<Privilege_listContext>(_ctx, getState());
  enterRule(_localctx, 500, GreenPlumParser::RulePrivilege_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3787);
    privilege();
    setState(3792);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3788);
      match(GreenPlumParser::COMMA);
      setState(3789);
      privilege();
      setState(3794);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeContext ------------------------------------------------------------------

GreenPlumParser::PrivilegeContext::PrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::SELECT() {
  return getToken(GreenPlumParser::SELECT, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::INSERT() {
  return getToken(GreenPlumParser::INSERT, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::REFERENCES() {
  return getToken(GreenPlumParser::REFERENCES, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::TRUNCATE() {
  return getToken(GreenPlumParser::TRUNCATE, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::USAGE() {
  return getToken(GreenPlumParser::USAGE, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::CONNECT() {
  return getToken(GreenPlumParser::CONNECT, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::TEMPORARY() {
  return getToken(GreenPlumParser::TEMPORARY, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::TEMP() {
  return getToken(GreenPlumParser::TEMP, 0);
}

tree::TerminalNode* GreenPlumParser::PrivilegeContext::EXECUTE() {
  return getToken(GreenPlumParser::EXECUTE, 0);
}


size_t GreenPlumParser::PrivilegeContext::getRuleIndex() const {
  return GreenPlumParser::RulePrivilege;
}

void GreenPlumParser::PrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilege(this);
}

void GreenPlumParser::PrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilege(this);
}


antlrcpp::Any GreenPlumParser::PrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::PrivilegeContext* GreenPlumParser::privilege() {
  PrivilegeContext *_localctx = _tracker.createInstance<PrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 502, GreenPlumParser::RulePrivilege);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3795);
    _la = _input->LA(1);
    if (!(((((_la - 61) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 61)) & ((1ULL << (GreenPlumParser::CONNECT - 61))
      | (1ULL << (GreenPlumParser::CREATE - 61))
      | (1ULL << (GreenPlumParser::DELETE_P - 61)))) != 0) || _la == GreenPlumParser::EXECUTE

    || _la == GreenPlumParser::INSERT || _la == GreenPlumParser::REFERENCES

    || _la == GreenPlumParser::SELECT || ((((_la - 400) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 400)) & ((1ULL << (GreenPlumParser::TEMP - 400))
      | (1ULL << (GreenPlumParser::TEMPORARY - 400))
      | (1ULL << (GreenPlumParser::TRIGGER - 400))
      | (1ULL << (GreenPlumParser::TRUNCATE - 400))
      | (1ULL << (GreenPlumParser::UPDATE - 400))
      | (1ULL << (GreenPlumParser::USAGE - 400)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Privilege_targetContext ------------------------------------------------------------------

GreenPlumParser::Privilege_targetContext::Privilege_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Qualified_name_listContext* GreenPlumParser::Privilege_targetContext::qualified_name_list() {
  return getRuleContext<GreenPlumParser::Qualified_name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Function_with_argtypes_listContext* GreenPlumParser::Privilege_targetContext::function_with_argtypes_list() {
  return getRuleContext<GreenPlumParser::Function_with_argtypes_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Privilege_targetContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Privilege_targetContext::PROTOCOL() {
  return getToken(GreenPlumParser::PROTOCOL, 0);
}


size_t GreenPlumParser::Privilege_targetContext::getRuleIndex() const {
  return GreenPlumParser::RulePrivilege_target;
}

void GreenPlumParser::Privilege_targetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilege_target(this);
}

void GreenPlumParser::Privilege_targetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilege_target(this);
}


antlrcpp::Any GreenPlumParser::Privilege_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege_target(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Privilege_targetContext* GreenPlumParser::privilege_target() {
  Privilege_targetContext *_localctx = _tracker.createInstance<Privilege_targetContext>(_ctx, getState());
  enterRule(_localctx, 504, GreenPlumParser::RulePrivilege_target);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3816);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3797);
      qualified_name_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3799);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TABLE) {
        setState(3798);
        match(GreenPlumParser::TABLE);
      }
      setState(3801);
      qualified_name_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3802);
      match(GreenPlumParser::SEQUENCE);
      setState(3803);
      qualified_name_list();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3804);
      match(GreenPlumParser::FUNCTION);
      setState(3805);
      function_with_argtypes_list();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3806);
      match(GreenPlumParser::DATABASE);
      setState(3807);
      name_list();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3808);
      match(GreenPlumParser::LANGUAGE);
      setState(3809);
      name_list();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3810);
      match(GreenPlumParser::SCHEMA);
      setState(3811);
      name_list();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3812);
      match(GreenPlumParser::TABLESPACE);
      setState(3813);
      name_list();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3814);
      match(GreenPlumParser::PROTOCOL);
      setState(3815);
      name_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grantee_listContext ------------------------------------------------------------------

GreenPlumParser::Grantee_listContext::Grantee_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::GranteeContext *> GreenPlumParser::Grantee_listContext::grantee() {
  return getRuleContexts<GreenPlumParser::GranteeContext>();
}

GreenPlumParser::GranteeContext* GreenPlumParser::Grantee_listContext::grantee(size_t i) {
  return getRuleContext<GreenPlumParser::GranteeContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Grantee_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Grantee_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Grantee_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleGrantee_list;
}

void GreenPlumParser::Grantee_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantee_list(this);
}

void GreenPlumParser::Grantee_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantee_list(this);
}


antlrcpp::Any GreenPlumParser::Grantee_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGrantee_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Grantee_listContext* GreenPlumParser::grantee_list() {
  Grantee_listContext *_localctx = _tracker.createInstance<Grantee_listContext>(_ctx, getState());
  enterRule(_localctx, 506, GreenPlumParser::RuleGrantee_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3818);
    grantee();
    setState(3823);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3819);
      match(GreenPlumParser::COMMA);
      setState(3820);
      grantee();
      setState(3825);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GranteeContext ------------------------------------------------------------------

GreenPlumParser::GranteeContext::GranteeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Role_idContext* GreenPlumParser::GranteeContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

tree::TerminalNode* GreenPlumParser::GranteeContext::PUBLIC() {
  return getToken(GreenPlumParser::PUBLIC, 0);
}


size_t GreenPlumParser::GranteeContext::getRuleIndex() const {
  return GreenPlumParser::RuleGrantee;
}

void GreenPlumParser::GranteeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantee(this);
}

void GreenPlumParser::GranteeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantee(this);
}


antlrcpp::Any GreenPlumParser::GranteeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGrantee(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::GranteeContext* GreenPlumParser::grantee() {
  GranteeContext *_localctx = _tracker.createInstance<GranteeContext>(_ctx, getState());
  enterRule(_localctx, 508, GreenPlumParser::RuleGrantee);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3828);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3826);
      role_id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3827);
      match(GreenPlumParser::PUBLIC);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_grant_grant_optionContext ------------------------------------------------------------------

GreenPlumParser::Opt_grant_grant_optionContext::Opt_grant_grant_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_grant_grant_optionContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_grant_grant_optionContext::GRANT() {
  return getToken(GreenPlumParser::GRANT, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_grant_grant_optionContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}


size_t GreenPlumParser::Opt_grant_grant_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_grant_grant_option;
}

void GreenPlumParser::Opt_grant_grant_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_grant_grant_option(this);
}

void GreenPlumParser::Opt_grant_grant_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_grant_grant_option(this);
}


antlrcpp::Any GreenPlumParser::Opt_grant_grant_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_grant_grant_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_grant_grant_optionContext* GreenPlumParser::opt_grant_grant_option() {
  Opt_grant_grant_optionContext *_localctx = _tracker.createInstance<Opt_grant_grant_optionContext>(_ctx, getState());
  enterRule(_localctx, 510, GreenPlumParser::RuleOpt_grant_grant_option);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3830);
    match(GreenPlumParser::WITH);
    setState(3831);
    match(GreenPlumParser::GRANT);
    setState(3832);
    match(GreenPlumParser::OPTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_with_argtypes_listContext ------------------------------------------------------------------

GreenPlumParser::Function_with_argtypes_listContext::Function_with_argtypes_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Function_with_argtypesContext *> GreenPlumParser::Function_with_argtypes_listContext::function_with_argtypes() {
  return getRuleContexts<GreenPlumParser::Function_with_argtypesContext>();
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::Function_with_argtypes_listContext::function_with_argtypes(size_t i) {
  return getRuleContext<GreenPlumParser::Function_with_argtypesContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Function_with_argtypes_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Function_with_argtypes_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Function_with_argtypes_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunction_with_argtypes_list;
}

void GreenPlumParser::Function_with_argtypes_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_with_argtypes_list(this);
}

void GreenPlumParser::Function_with_argtypes_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_with_argtypes_list(this);
}


antlrcpp::Any GreenPlumParser::Function_with_argtypes_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunction_with_argtypes_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Function_with_argtypes_listContext* GreenPlumParser::function_with_argtypes_list() {
  Function_with_argtypes_listContext *_localctx = _tracker.createInstance<Function_with_argtypes_listContext>(_ctx, getState());
  enterRule(_localctx, 512, GreenPlumParser::RuleFunction_with_argtypes_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3834);
    function_with_argtypes();
    setState(3839);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3835);
      match(GreenPlumParser::COMMA);
      setState(3836);
      function_with_argtypes();
      setState(3841);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_with_argtypesContext ------------------------------------------------------------------

GreenPlumParser::Function_with_argtypesContext::Function_with_argtypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Function_with_argtypesContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Func_argsContext* GreenPlumParser::Function_with_argtypesContext::func_args() {
  return getRuleContext<GreenPlumParser::Func_argsContext>(0);
}


size_t GreenPlumParser::Function_with_argtypesContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunction_with_argtypes;
}

void GreenPlumParser::Function_with_argtypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_with_argtypes(this);
}

void GreenPlumParser::Function_with_argtypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_with_argtypes(this);
}


antlrcpp::Any GreenPlumParser::Function_with_argtypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunction_with_argtypes(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::function_with_argtypes() {
  Function_with_argtypesContext *_localctx = _tracker.createInstance<Function_with_argtypesContext>(_ctx, getState());
  enterRule(_localctx, 514, GreenPlumParser::RuleFunction_with_argtypes);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3842);
    func_name();
    setState(3843);
    func_args();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grant_role_stmtContext ------------------------------------------------------------------

GreenPlumParser::Grant_role_stmtContext::Grant_role_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Grant_role_stmtContext::GRANT() {
  return getToken(GreenPlumParser::GRANT, 0);
}

GreenPlumParser::Privilege_listContext* GreenPlumParser::Grant_role_stmtContext::privilege_list() {
  return getRuleContext<GreenPlumParser::Privilege_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Grant_role_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Grant_role_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

GreenPlumParser::Opt_grant_admin_optionContext* GreenPlumParser::Grant_role_stmtContext::opt_grant_admin_option() {
  return getRuleContext<GreenPlumParser::Opt_grant_admin_optionContext>(0);
}

GreenPlumParser::Opt_granted_byContext* GreenPlumParser::Grant_role_stmtContext::opt_granted_by() {
  return getRuleContext<GreenPlumParser::Opt_granted_byContext>(0);
}


size_t GreenPlumParser::Grant_role_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleGrant_role_stmt;
}

void GreenPlumParser::Grant_role_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrant_role_stmt(this);
}

void GreenPlumParser::Grant_role_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrant_role_stmt(this);
}


antlrcpp::Any GreenPlumParser::Grant_role_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGrant_role_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Grant_role_stmtContext* GreenPlumParser::grant_role_stmt() {
  Grant_role_stmtContext *_localctx = _tracker.createInstance<Grant_role_stmtContext>(_ctx, getState());
  enterRule(_localctx, 516, GreenPlumParser::RuleGrant_role_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3845);
    match(GreenPlumParser::GRANT);
    setState(3846);
    privilege_list();
    setState(3847);
    match(GreenPlumParser::TO);
    setState(3848);
    name_list();
    setState(3850);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(3849);
      opt_grant_admin_option();
    }
    setState(3853);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GRANTED) {
      setState(3852);
      opt_granted_by();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Revoke_role_stmtContext ------------------------------------------------------------------

GreenPlumParser::Revoke_role_stmtContext::Revoke_role_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Revoke_role_stmtContext::REVOKE() {
  return getToken(GreenPlumParser::REVOKE, 0);
}

GreenPlumParser::Privilege_listContext* GreenPlumParser::Revoke_role_stmtContext::privilege_list() {
  return getRuleContext<GreenPlumParser::Privilege_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Revoke_role_stmtContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Revoke_role_stmtContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Revoke_role_stmtContext::ADMIN() {
  return getToken(GreenPlumParser::ADMIN, 0);
}

tree::TerminalNode* GreenPlumParser::Revoke_role_stmtContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}

tree::TerminalNode* GreenPlumParser::Revoke_role_stmtContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

GreenPlumParser::Opt_granted_byContext* GreenPlumParser::Revoke_role_stmtContext::opt_granted_by() {
  return getRuleContext<GreenPlumParser::Opt_granted_byContext>(0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Revoke_role_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Revoke_role_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRevoke_role_stmt;
}

void GreenPlumParser::Revoke_role_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevoke_role_stmt(this);
}

void GreenPlumParser::Revoke_role_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevoke_role_stmt(this);
}


antlrcpp::Any GreenPlumParser::Revoke_role_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRevoke_role_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Revoke_role_stmtContext* GreenPlumParser::revoke_role_stmt() {
  Revoke_role_stmtContext *_localctx = _tracker.createInstance<Revoke_role_stmtContext>(_ctx, getState());
  enterRule(_localctx, 518, GreenPlumParser::RuleRevoke_role_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3855);
    match(GreenPlumParser::REVOKE);
    setState(3859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ADMIN) {
      setState(3856);
      match(GreenPlumParser::ADMIN);
      setState(3857);
      match(GreenPlumParser::OPTION);
      setState(3858);
      match(GreenPlumParser::FOR);
    }
    setState(3861);
    privilege_list();
    setState(3862);
    match(GreenPlumParser::FROM);
    setState(3863);
    name_list();
    setState(3865);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GRANTED) {
      setState(3864);
      opt_granted_by();
    }
    setState(3868);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(3867);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_grant_admin_optionContext ------------------------------------------------------------------

GreenPlumParser::Opt_grant_admin_optionContext::Opt_grant_admin_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_grant_admin_optionContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_grant_admin_optionContext::ADMIN() {
  return getToken(GreenPlumParser::ADMIN, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_grant_admin_optionContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}


size_t GreenPlumParser::Opt_grant_admin_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_grant_admin_option;
}

void GreenPlumParser::Opt_grant_admin_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_grant_admin_option(this);
}

void GreenPlumParser::Opt_grant_admin_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_grant_admin_option(this);
}


antlrcpp::Any GreenPlumParser::Opt_grant_admin_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_grant_admin_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_grant_admin_optionContext* GreenPlumParser::opt_grant_admin_option() {
  Opt_grant_admin_optionContext *_localctx = _tracker.createInstance<Opt_grant_admin_optionContext>(_ctx, getState());
  enterRule(_localctx, 520, GreenPlumParser::RuleOpt_grant_admin_option);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3870);
    match(GreenPlumParser::WITH);
    setState(3871);
    match(GreenPlumParser::ADMIN);
    setState(3872);
    match(GreenPlumParser::OPTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_granted_byContext ------------------------------------------------------------------

GreenPlumParser::Opt_granted_byContext::Opt_granted_byContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_granted_byContext::GRANTED() {
  return getToken(GreenPlumParser::GRANTED, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_granted_byContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Opt_granted_byContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}


size_t GreenPlumParser::Opt_granted_byContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_granted_by;
}

void GreenPlumParser::Opt_granted_byContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_granted_by(this);
}

void GreenPlumParser::Opt_granted_byContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_granted_by(this);
}


antlrcpp::Any GreenPlumParser::Opt_granted_byContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_granted_by(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_granted_byContext* GreenPlumParser::opt_granted_by() {
  Opt_granted_byContext *_localctx = _tracker.createInstance<Opt_granted_byContext>(_ctx, getState());
  enterRule(_localctx, 522, GreenPlumParser::RuleOpt_granted_by);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3874);
    match(GreenPlumParser::GRANTED);
    setState(3875);
    match(GreenPlumParser::BY);
    setState(3876);
    role_id();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_stmtContext ------------------------------------------------------------------

GreenPlumParser::Index_stmtContext::Index_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Index_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Index_stmtContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

GreenPlumParser::Index_nameContext* GreenPlumParser::Index_stmtContext::index_name() {
  return getRuleContext<GreenPlumParser::Index_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Index_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Index_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Index_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Index_paramsContext* GreenPlumParser::Index_stmtContext::index_params() {
  return getRuleContext<GreenPlumParser::Index_paramsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Index_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Index_stmtContext::UNIQUE() {
  return getToken(GreenPlumParser::UNIQUE, 0);
}

tree::TerminalNode* GreenPlumParser::Index_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Index_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::Index_stmtContext::with_out_definition() {
  return getRuleContext<GreenPlumParser::With_out_definitionContext>(0);
}

GreenPlumParser::Opt_table_spaceContext* GreenPlumParser::Index_stmtContext::opt_table_space() {
  return getRuleContext<GreenPlumParser::Opt_table_spaceContext>(0);
}

GreenPlumParser::Where_clauseContext* GreenPlumParser::Index_stmtContext::where_clause() {
  return getRuleContext<GreenPlumParser::Where_clauseContext>(0);
}


size_t GreenPlumParser::Index_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleIndex_stmt;
}

void GreenPlumParser::Index_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_stmt(this);
}

void GreenPlumParser::Index_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_stmt(this);
}


antlrcpp::Any GreenPlumParser::Index_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIndex_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Index_stmtContext* GreenPlumParser::index_stmt() {
  Index_stmtContext *_localctx = _tracker.createInstance<Index_stmtContext>(_ctx, getState());
  enterRule(_localctx, 524, GreenPlumParser::RuleIndex_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3878);
    match(GreenPlumParser::CREATE);
    setState(3880);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::UNIQUE) {
      setState(3879);
      match(GreenPlumParser::UNIQUE);
    }
    setState(3882);
    match(GreenPlumParser::INDEX);
    setState(3883);
    index_name();
    setState(3884);
    match(GreenPlumParser::ON);
    setState(3885);
    qualified_name();
    setState(3888);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::USING) {
      setState(3886);
      match(GreenPlumParser::USING);
      setState(3887);
      access_method();
    }
    setState(3890);
    match(GreenPlumParser::LEFT_PAREN);
    setState(3891);
    index_params();
    setState(3892);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(3894);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT) {
      setState(3893);
      with_out_definition();
    }
    setState(3897);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TABLESPACE) {
      setState(3896);
      opt_table_space();
    }
    setState(3900);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WHERE) {
      setState(3899);
      where_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_paramsContext ------------------------------------------------------------------

GreenPlumParser::Index_paramsContext::Index_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Index_elemContext *> GreenPlumParser::Index_paramsContext::index_elem() {
  return getRuleContexts<GreenPlumParser::Index_elemContext>();
}

GreenPlumParser::Index_elemContext* GreenPlumParser::Index_paramsContext::index_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Index_elemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Index_paramsContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Index_paramsContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Index_paramsContext::getRuleIndex() const {
  return GreenPlumParser::RuleIndex_params;
}

void GreenPlumParser::Index_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_params(this);
}

void GreenPlumParser::Index_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_params(this);
}


antlrcpp::Any GreenPlumParser::Index_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIndex_params(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Index_paramsContext* GreenPlumParser::index_params() {
  Index_paramsContext *_localctx = _tracker.createInstance<Index_paramsContext>(_ctx, getState());
  enterRule(_localctx, 526, GreenPlumParser::RuleIndex_params);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3902);
    index_elem();
    setState(3907);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3903);
      match(GreenPlumParser::COMMA);
      setState(3904);
      index_elem();
      setState(3909);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_elemContext ------------------------------------------------------------------

GreenPlumParser::Index_elemContext::Index_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Index_elemContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::Opt_classContext* GreenPlumParser::Index_elemContext::opt_class() {
  return getRuleContext<GreenPlumParser::Opt_classContext>(0);
}

GreenPlumParser::Opt_asc_descContext* GreenPlumParser::Index_elemContext::opt_asc_desc() {
  return getRuleContext<GreenPlumParser::Opt_asc_descContext>(0);
}

GreenPlumParser::Opt_nulls_orderContext* GreenPlumParser::Index_elemContext::opt_nulls_order() {
  return getRuleContext<GreenPlumParser::Opt_nulls_orderContext>(0);
}

GreenPlumParser::Func_exprContext* GreenPlumParser::Index_elemContext::func_expr() {
  return getRuleContext<GreenPlumParser::Func_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Index_elemContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Index_elemContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Index_elemContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Index_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleIndex_elem;
}

void GreenPlumParser::Index_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_elem(this);
}

void GreenPlumParser::Index_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_elem(this);
}


antlrcpp::Any GreenPlumParser::Index_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIndex_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Index_elemContext* GreenPlumParser::index_elem() {
  Index_elemContext *_localctx = _tracker.createInstance<Index_elemContext>(_ctx, getState());
  enterRule(_localctx, 528, GreenPlumParser::RuleIndex_elem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3942);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3910);
      colid();
      setState(3912);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::USING - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
        setState(3911);
        opt_class();
      }
      setState(3915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ASC || _la == GreenPlumParser::DESC) {
        setState(3914);
        opt_asc_desc();
      }
      setState(3918);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NULLS_FIRST

      || _la == GreenPlumParser::NULLS_LAST) {
        setState(3917);
        opt_nulls_order();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3920);
      func_expr();
      setState(3922);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::USING - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
        setState(3921);
        opt_class();
      }
      setState(3925);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ASC || _la == GreenPlumParser::DESC) {
        setState(3924);
        opt_asc_desc();
      }
      setState(3928);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NULLS_FIRST

      || _la == GreenPlumParser::NULLS_LAST) {
        setState(3927);
        opt_nulls_order();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3930);
      match(GreenPlumParser::LEFT_PAREN);
      setState(3931);
      a_expr();
      setState(3932);
      match(GreenPlumParser::RIGHT_PAREN);
      setState(3934);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::USING - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
        setState(3933);
        opt_class();
      }
      setState(3937);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ASC || _la == GreenPlumParser::DESC) {
        setState(3936);
        opt_asc_desc();
      }
      setState(3940);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NULLS_FIRST

      || _la == GreenPlumParser::NULLS_LAST) {
        setState(3939);
        opt_nulls_order();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_classContext ------------------------------------------------------------------

GreenPlumParser::Opt_classContext::Opt_classContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Opt_classContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_classContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}


size_t GreenPlumParser::Opt_classContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_class;
}

void GreenPlumParser::Opt_classContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_class(this);
}

void GreenPlumParser::Opt_classContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_class(this);
}


antlrcpp::Any GreenPlumParser::Opt_classContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_class(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_classContext* GreenPlumParser::opt_class() {
  Opt_classContext *_localctx = _tracker.createInstance<Opt_classContext>(_ctx, getState());
  enterRule(_localctx, 530, GreenPlumParser::RuleOpt_class);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3945);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::USING) {
      setState(3944);
      match(GreenPlumParser::USING);
    }
    setState(3947);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_asc_descContext ------------------------------------------------------------------

GreenPlumParser::Opt_asc_descContext::Opt_asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_asc_descContext::ASC() {
  return getToken(GreenPlumParser::ASC, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_asc_descContext::DESC() {
  return getToken(GreenPlumParser::DESC, 0);
}


size_t GreenPlumParser::Opt_asc_descContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_asc_desc;
}

void GreenPlumParser::Opt_asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_asc_desc(this);
}

void GreenPlumParser::Opt_asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_asc_desc(this);
}


antlrcpp::Any GreenPlumParser::Opt_asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_asc_desc(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_asc_descContext* GreenPlumParser::opt_asc_desc() {
  Opt_asc_descContext *_localctx = _tracker.createInstance<Opt_asc_descContext>(_ctx, getState());
  enterRule(_localctx, 532, GreenPlumParser::RuleOpt_asc_desc);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3949);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::ASC || _la == GreenPlumParser::DESC)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_nulls_orderContext ------------------------------------------------------------------

GreenPlumParser::Opt_nulls_orderContext::Opt_nulls_orderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_nulls_orderContext::NULLS_FIRST() {
  return getToken(GreenPlumParser::NULLS_FIRST, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_nulls_orderContext::NULLS_LAST() {
  return getToken(GreenPlumParser::NULLS_LAST, 0);
}


size_t GreenPlumParser::Opt_nulls_orderContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_nulls_order;
}

void GreenPlumParser::Opt_nulls_orderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_nulls_order(this);
}

void GreenPlumParser::Opt_nulls_orderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_nulls_order(this);
}


antlrcpp::Any GreenPlumParser::Opt_nulls_orderContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_nulls_order(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_nulls_orderContext* GreenPlumParser::opt_nulls_order() {
  Opt_nulls_orderContext *_localctx = _tracker.createInstance<Opt_nulls_orderContext>(_ctx, getState());
  enterRule(_localctx, 534, GreenPlumParser::RuleOpt_nulls_order);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3951);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::NULLS_FIRST

    || _la == GreenPlumParser::NULLS_LAST)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_function_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_function_stmtContext::Create_function_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_function_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_function_stmtContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Create_function_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Func_args_with_defaultsContext* GreenPlumParser::Create_function_stmtContext::func_args_with_defaults() {
  return getRuleContext<GreenPlumParser::Func_args_with_defaultsContext>(0);
}

GreenPlumParser::Createfunc_opt_listContext* GreenPlumParser::Create_function_stmtContext::createfunc_opt_list() {
  return getRuleContext<GreenPlumParser::Createfunc_opt_listContext>(0);
}

GreenPlumParser::Opt_or_replaceContext* GreenPlumParser::Create_function_stmtContext::opt_or_replace() {
  return getRuleContext<GreenPlumParser::Opt_or_replaceContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_function_stmtContext::RETURNS() {
  return getToken(GreenPlumParser::RETURNS, 0);
}

GreenPlumParser::Func_returnContext* GreenPlumParser::Create_function_stmtContext::func_return() {
  return getRuleContext<GreenPlumParser::Func_returnContext>(0);
}

std::vector<GreenPlumParser::With_out_definitionContext *> GreenPlumParser::Create_function_stmtContext::with_out_definition() {
  return getRuleContexts<GreenPlumParser::With_out_definitionContext>();
}

GreenPlumParser::With_out_definitionContext* GreenPlumParser::Create_function_stmtContext::with_out_definition(size_t i) {
  return getRuleContext<GreenPlumParser::With_out_definitionContext>(i);
}

tree::TerminalNode* GreenPlumParser::Create_function_stmtContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}


size_t GreenPlumParser::Create_function_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_function_stmt;
}

void GreenPlumParser::Create_function_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_function_stmt(this);
}

void GreenPlumParser::Create_function_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_function_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_function_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_function_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_function_stmtContext* GreenPlumParser::create_function_stmt() {
  Create_function_stmtContext *_localctx = _tracker.createInstance<Create_function_stmtContext>(_ctx, getState());
  enterRule(_localctx, 536, GreenPlumParser::RuleCreate_function_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3953);
    match(GreenPlumParser::CREATE);
    setState(3955);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::OR) {
      setState(3954);
      opt_or_replace();
    }
    setState(3957);
    match(GreenPlumParser::FUNCTION);
    setState(3958);
    func_name();
    setState(3959);
    func_args_with_defaults();
    setState(3962);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
    case 1: {
      setState(3960);
      match(GreenPlumParser::RETURNS);
      setState(3961);
      func_return();
      break;
    }

    }
    setState(3964);
    createfunc_opt_list();
    setState(3969);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT) {
      setState(3965);
      with_out_definition();

      setState(3966);
      match(GreenPlumParser::COMMA);
      setState(3967);
      with_out_definition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_or_replaceContext ------------------------------------------------------------------

GreenPlumParser::Opt_or_replaceContext::Opt_or_replaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_or_replaceContext::OR() {
  return getToken(GreenPlumParser::OR, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_or_replaceContext::REPLACE() {
  return getToken(GreenPlumParser::REPLACE, 0);
}


size_t GreenPlumParser::Opt_or_replaceContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_or_replace;
}

void GreenPlumParser::Opt_or_replaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_or_replace(this);
}

void GreenPlumParser::Opt_or_replaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_or_replace(this);
}


antlrcpp::Any GreenPlumParser::Opt_or_replaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_or_replace(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_or_replaceContext* GreenPlumParser::opt_or_replace() {
  Opt_or_replaceContext *_localctx = _tracker.createInstance<Opt_or_replaceContext>(_ctx, getState());
  enterRule(_localctx, 538, GreenPlumParser::RuleOpt_or_replace);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3971);
    match(GreenPlumParser::OR);
    setState(3972);
    match(GreenPlumParser::REPLACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_argsContext ------------------------------------------------------------------

GreenPlumParser::Func_argsContext::Func_argsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Func_argsContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Func_argsContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Func_args_listContext* GreenPlumParser::Func_argsContext::func_args_list() {
  return getRuleContext<GreenPlumParser::Func_args_listContext>(0);
}


size_t GreenPlumParser::Func_argsContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_args;
}

void GreenPlumParser::Func_argsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_args(this);
}

void GreenPlumParser::Func_argsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_args(this);
}


antlrcpp::Any GreenPlumParser::Func_argsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_argsContext* GreenPlumParser::func_args() {
  Func_argsContext *_localctx = _tracker.createInstance<Func_argsContext>(_ctx, getState());
  enterRule(_localctx, 540, GreenPlumParser::RuleFunc_args);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3974);
    match(GreenPlumParser::LEFT_PAREN);
    setState(3976);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTER)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHAR_P)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CROSS - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DEC - 64))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FLOAT_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FULL - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::ILIKE - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128))
      | (1ULL << (GreenPlumParser::INNER_P - 128))
      | (1ULL << (GreenPlumParser::INOUT - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (GreenPlumParser::IN_P - 192))
      | (1ULL << (GreenPlumParser::INPUT_P - 192))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 192))
      | (1ULL << (GreenPlumParser::INSERT - 192))
      | (1ULL << (GreenPlumParser::INSTEAD - 192))
      | (1ULL << (GreenPlumParser::INTEGER - 192))
      | (1ULL << (GreenPlumParser::INTERVAL - 192))
      | (1ULL << (GreenPlumParser::INT_P - 192))
      | (1ULL << (GreenPlumParser::INVOKER - 192))
      | (1ULL << (GreenPlumParser::IS - 192))
      | (1ULL << (GreenPlumParser::ISNULL - 192))
      | (1ULL << (GreenPlumParser::ISOLATION - 192))
      | (1ULL << (GreenPlumParser::JOIN - 192))
      | (1ULL << (GreenPlumParser::KEY - 192))
      | (1ULL << (GreenPlumParser::LANGUAGE - 192))
      | (1ULL << (GreenPlumParser::LARGE_P - 192))
      | (1ULL << (GreenPlumParser::LAST_P - 192))
      | (1ULL << (GreenPlumParser::LEFT - 192))
      | (1ULL << (GreenPlumParser::LEVEL - 192))
      | (1ULL << (GreenPlumParser::LIKE - 192))
      | (1ULL << (GreenPlumParser::LIST - 192))
      | (1ULL << (GreenPlumParser::LISTEN - 192))
      | (1ULL << (GreenPlumParser::LOAD - 192))
      | (1ULL << (GreenPlumParser::LOCAL - 192))
      | (1ULL << (GreenPlumParser::LOCATION - 192))
      | (1ULL << (GreenPlumParser::LOCK_P - 192))
      | (1ULL << (GreenPlumParser::LOGIN_P - 192))
      | (1ULL << (GreenPlumParser::LOG_P - 192))
      | (1ULL << (GreenPlumParser::MAPPING - 192))
      | (1ULL << (GreenPlumParser::MASTER - 192))
      | (1ULL << (GreenPlumParser::MATCH - 192))
      | (1ULL << (GreenPlumParser::MAXVALUE - 192))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 192))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 192))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 192))
      | (1ULL << (GreenPlumParser::MERGE - 192))
      | (1ULL << (GreenPlumParser::MINUTE_P - 192))
      | (1ULL << (GreenPlumParser::MINVALUE - 192))
      | (1ULL << (GreenPlumParser::MISSING - 192))
      | (1ULL << (GreenPlumParser::MODE - 192))
      | (1ULL << (GreenPlumParser::MODIFIES - 192))
      | (1ULL << (GreenPlumParser::MODIFY - 192))
      | (1ULL << (GreenPlumParser::MONTH_P - 192))
      | (1ULL << (GreenPlumParser::MOVE - 192))
      | (1ULL << (GreenPlumParser::NAME_P - 192))
      | (1ULL << (GreenPlumParser::NAMES - 192))
      | (1ULL << (GreenPlumParser::NATIONAL - 192))
      | (1ULL << (GreenPlumParser::NATURAL - 192))
      | (1ULL << (GreenPlumParser::NCHAR - 192))
      | (1ULL << (GreenPlumParser::NEXT - 192))
      | (1ULL << (GreenPlumParser::NO - 192))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 192))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 192))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 192)))) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & ((1ULL << (GreenPlumParser::NOCREATEUSER - 256))
      | (1ULL << (GreenPlumParser::NOINHERIT - 256))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 256))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 256))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 256))
      | (1ULL << (GreenPlumParser::NOTHING - 256))
      | (1ULL << (GreenPlumParser::NOTIFY - 256))
      | (1ULL << (GreenPlumParser::NOTNULL - 256))
      | (1ULL << (GreenPlumParser::NOWAIT - 256))
      | (1ULL << (GreenPlumParser::NULLS_P - 256))
      | (1ULL << (GreenPlumParser::NUMERIC - 256))
      | (1ULL << (GreenPlumParser::OBJECT_P - 256))
      | (1ULL << (GreenPlumParser::OF - 256))
      | (1ULL << (GreenPlumParser::OIDS - 256))
      | (1ULL << (GreenPlumParser::OPERATOR - 256))
      | (1ULL << (GreenPlumParser::OPTION - 256))
      | (1ULL << (GreenPlumParser::OPTIONS - 256))
      | (1ULL << (GreenPlumParser::ORDERED - 256))
      | (1ULL << (GreenPlumParser::OTHERS - 256))
      | (1ULL << (GreenPlumParser::OUTER_P - 256))
      | (1ULL << (GreenPlumParser::OUT_P - 256))
      | (1ULL << (GreenPlumParser::OVER - 256))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 256))
      | (1ULL << (GreenPlumParser::OVERLAPS - 256))
      | (1ULL << (GreenPlumParser::OWNED - 256))
      | (1ULL << (GreenPlumParser::OWNER - 256))
      | (1ULL << (GreenPlumParser::PARSER - 256))
      | (1ULL << (GreenPlumParser::PARTIAL - 256))
      | (1ULL << (GreenPlumParser::PARTITIONS - 256))
      | (1ULL << (GreenPlumParser::PASSING - 256))
      | (1ULL << (GreenPlumParser::PASSWORD - 256))
      | (1ULL << (GreenPlumParser::PERCENT - 256))
      | (1ULL << (GreenPlumParser::PLANS - 256))
      | (1ULL << (GreenPlumParser::PREPARE - 256))
      | (1ULL << (GreenPlumParser::PREPARED - 256))
      | (1ULL << (GreenPlumParser::PRESERVE - 256))
      | (1ULL << (GreenPlumParser::PRIOR - 256))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 256))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 256))
      | (1ULL << (GreenPlumParser::PROCEDURE - 256))
      | (1ULL << (GreenPlumParser::PROGRAM - 256))
      | (1ULL << (GreenPlumParser::PROTOCOL - 256)))) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & ((1ULL << (GreenPlumParser::PUBLIC - 320))
      | (1ULL << (GreenPlumParser::QUEUE - 320))
      | (1ULL << (GreenPlumParser::QUOTE - 320))
      | (1ULL << (GreenPlumParser::RANDOMLY - 320))
      | (1ULL << (GreenPlumParser::READ - 320))
      | (1ULL << (GreenPlumParser::READABLE - 320))
      | (1ULL << (GreenPlumParser::READS - 320))
      | (1ULL << (GreenPlumParser::REAL - 320))
      | (1ULL << (GreenPlumParser::REASSIGN - 320))
      | (1ULL << (GreenPlumParser::RECHECK - 320))
      | (1ULL << (GreenPlumParser::RECURSIVE - 320))
      | (1ULL << (GreenPlumParser::REF - 320))
      | (1ULL << (GreenPlumParser::REINDEX - 320))
      | (1ULL << (GreenPlumParser::REJECT_P - 320))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 320))
      | (1ULL << (GreenPlumParser::RELEASE - 320))
      | (1ULL << (GreenPlumParser::RENAME - 320))
      | (1ULL << (GreenPlumParser::REPEATABLE - 320))
      | (1ULL << (GreenPlumParser::REPLACE - 320))
      | (1ULL << (GreenPlumParser::REPLICA - 320))
      | (1ULL << (GreenPlumParser::RESET - 320))
      | (1ULL << (GreenPlumParser::RESOURCE - 320))
      | (1ULL << (GreenPlumParser::RESTART - 320))
      | (1ULL << (GreenPlumParser::RESTRICT - 320))
      | (1ULL << (GreenPlumParser::RETURNS - 320))
      | (1ULL << (GreenPlumParser::REVOKE - 320))
      | (1ULL << (GreenPlumParser::RIGHT - 320))
      | (1ULL << (GreenPlumParser::ROLE - 320))
      | (1ULL << (GreenPlumParser::ROLLBACK - 320))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 320))
      | (1ULL << (GreenPlumParser::RULE - 320))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 320))
      | (1ULL << (GreenPlumParser::SCHEMA - 320))
      | (1ULL << (GreenPlumParser::SCROLL - 320))
      | (1ULL << (GreenPlumParser::SEARCH - 320))
      | (1ULL << (GreenPlumParser::SECOND_P - 320))
      | (1ULL << (GreenPlumParser::SECURITY - 320))
      | (1ULL << (GreenPlumParser::SEGMENT - 320))
      | (1ULL << (GreenPlumParser::SEQUENCE - 320))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 320))
      | (1ULL << (GreenPlumParser::SESSION - 320))
      | (1ULL << (GreenPlumParser::SET - 320))
      | (1ULL << (GreenPlumParser::SETOF - 320))
      | (1ULL << (GreenPlumParser::SHARE - 320))
      | (1ULL << (GreenPlumParser::SHOW - 320))
      | (1ULL << (GreenPlumParser::SIMILAR - 320))
      | (1ULL << (GreenPlumParser::SIMPLE - 320))
      | (1ULL << (GreenPlumParser::SMALLINT - 320))
      | (1ULL << (GreenPlumParser::SPLIT - 320))
      | (1ULL << (GreenPlumParser::SQL - 320))
      | (1ULL << (GreenPlumParser::STABLE - 320))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 320))
      | (1ULL << (GreenPlumParser::START - 320)))) != 0) || ((((_la - 384) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 384)) & ((1ULL << (GreenPlumParser::STATEMENT - 384))
      | (1ULL << (GreenPlumParser::STATISTICS - 384))
      | (1ULL << (GreenPlumParser::STDIN - 384))
      | (1ULL << (GreenPlumParser::STDOUT - 384))
      | (1ULL << (GreenPlumParser::STORAGE - 384))
      | (1ULL << (GreenPlumParser::STRICT_P - 384))
      | (1ULL << (GreenPlumParser::STRIP_P - 384))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 384))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 384))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 384))
      | (1ULL << (GreenPlumParser::SYSID - 384))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 384))
      | (1ULL << (GreenPlumParser::TABLE - 384))
      | (1ULL << (GreenPlumParser::TABLESPACE - 384))
      | (1ULL << (GreenPlumParser::TEMP - 384))
      | (1ULL << (GreenPlumParser::TEMPLATE - 384))
      | (1ULL << (GreenPlumParser::TEMPORARY - 384))
      | (1ULL << (GreenPlumParser::TEXT_P - 384))
      | (1ULL << (GreenPlumParser::THRESHOLD - 384))
      | (1ULL << (GreenPlumParser::TIES - 384))
      | (1ULL << (GreenPlumParser::TIME - 384))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 384))
      | (1ULL << (GreenPlumParser::TRANSACTION - 384))
      | (1ULL << (GreenPlumParser::TRIGGER - 384))
      | (1ULL << (GreenPlumParser::TRUNCATE - 384))
      | (1ULL << (GreenPlumParser::TRUSTED - 384))
      | (1ULL << (GreenPlumParser::TYPE_P - 384))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 384))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 384))
      | (1ULL << (GreenPlumParser::UNKNOWN - 384))
      | (1ULL << (GreenPlumParser::UNLISTEN - 384))
      | (1ULL << (GreenPlumParser::UNTIL - 384))
      | (1ULL << (GreenPlumParser::UPDATE - 384))
      | (1ULL << (GreenPlumParser::VACUUM - 384))
      | (1ULL << (GreenPlumParser::VALID - 384))
      | (1ULL << (GreenPlumParser::VALIDATION - 384))
      | (1ULL << (GreenPlumParser::VALIDATOR - 384))
      | (1ULL << (GreenPlumParser::VALUE_P - 384))
      | (1ULL << (GreenPlumParser::VARCHAR - 384))
      | (1ULL << (GreenPlumParser::VARIADIC - 384))
      | (1ULL << (GreenPlumParser::VARYING - 384))
      | (1ULL << (GreenPlumParser::VERBOSE - 384))
      | (1ULL << (GreenPlumParser::VERSION_P - 384))
      | (1ULL << (GreenPlumParser::VIEW - 384))
      | (1ULL << (GreenPlumParser::VOLATILE - 384))
      | (1ULL << (GreenPlumParser::WEB - 384)))) != 0) || ((((_la - 448) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 448)) & ((1ULL << (GreenPlumParser::WHITESPACE_P - 448))
      | (1ULL << (GreenPlumParser::WITHIN - 448))
      | (1ULL << (GreenPlumParser::WITHOUT - 448))
      | (1ULL << (GreenPlumParser::WORK - 448))
      | (1ULL << (GreenPlumParser::WRITABLE - 448))
      | (1ULL << (GreenPlumParser::WRITE - 448))
      | (1ULL << (GreenPlumParser::XML_P - 448))
      | (1ULL << (GreenPlumParser::YEAR_P - 448))
      | (1ULL << (GreenPlumParser::YES_P - 448))
      | (1ULL << (GreenPlumParser::ZONE - 448))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 448))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 448)))) != 0)) {
      setState(3975);
      func_args_list();
    }
    setState(3978);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_args_listContext ------------------------------------------------------------------

GreenPlumParser::Func_args_listContext::Func_args_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Func_argContext *> GreenPlumParser::Func_args_listContext::func_arg() {
  return getRuleContexts<GreenPlumParser::Func_argContext>();
}

GreenPlumParser::Func_argContext* GreenPlumParser::Func_args_listContext::func_arg(size_t i) {
  return getRuleContext<GreenPlumParser::Func_argContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Func_args_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Func_args_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Func_args_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_args_list;
}

void GreenPlumParser::Func_args_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_args_list(this);
}

void GreenPlumParser::Func_args_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_args_list(this);
}


antlrcpp::Any GreenPlumParser::Func_args_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_args_listContext* GreenPlumParser::func_args_list() {
  Func_args_listContext *_localctx = _tracker.createInstance<Func_args_listContext>(_ctx, getState());
  enterRule(_localctx, 542, GreenPlumParser::RuleFunc_args_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3980);
    func_arg();
    setState(3985);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3981);
      match(GreenPlumParser::COMMA);
      setState(3982);
      func_arg();
      setState(3987);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_args_with_defaultsContext ------------------------------------------------------------------

GreenPlumParser::Func_args_with_defaultsContext::Func_args_with_defaultsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Func_args_with_defaultsContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Func_args_with_defaultsContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Func_args_with_defaults_listContext* GreenPlumParser::Func_args_with_defaultsContext::func_args_with_defaults_list() {
  return getRuleContext<GreenPlumParser::Func_args_with_defaults_listContext>(0);
}


size_t GreenPlumParser::Func_args_with_defaultsContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_args_with_defaults;
}

void GreenPlumParser::Func_args_with_defaultsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_args_with_defaults(this);
}

void GreenPlumParser::Func_args_with_defaultsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_args_with_defaults(this);
}


antlrcpp::Any GreenPlumParser::Func_args_with_defaultsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args_with_defaults(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_args_with_defaultsContext* GreenPlumParser::func_args_with_defaults() {
  Func_args_with_defaultsContext *_localctx = _tracker.createInstance<Func_args_with_defaultsContext>(_ctx, getState());
  enterRule(_localctx, 544, GreenPlumParser::RuleFunc_args_with_defaults);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3988);
    match(GreenPlumParser::LEFT_PAREN);
    setState(3990);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTER)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHAR_P)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CROSS - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DEC - 64))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FLOAT_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FULL - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::ILIKE - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128))
      | (1ULL << (GreenPlumParser::INNER_P - 128))
      | (1ULL << (GreenPlumParser::INOUT - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (GreenPlumParser::IN_P - 192))
      | (1ULL << (GreenPlumParser::INPUT_P - 192))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 192))
      | (1ULL << (GreenPlumParser::INSERT - 192))
      | (1ULL << (GreenPlumParser::INSTEAD - 192))
      | (1ULL << (GreenPlumParser::INTEGER - 192))
      | (1ULL << (GreenPlumParser::INTERVAL - 192))
      | (1ULL << (GreenPlumParser::INT_P - 192))
      | (1ULL << (GreenPlumParser::INVOKER - 192))
      | (1ULL << (GreenPlumParser::IS - 192))
      | (1ULL << (GreenPlumParser::ISNULL - 192))
      | (1ULL << (GreenPlumParser::ISOLATION - 192))
      | (1ULL << (GreenPlumParser::JOIN - 192))
      | (1ULL << (GreenPlumParser::KEY - 192))
      | (1ULL << (GreenPlumParser::LANGUAGE - 192))
      | (1ULL << (GreenPlumParser::LARGE_P - 192))
      | (1ULL << (GreenPlumParser::LAST_P - 192))
      | (1ULL << (GreenPlumParser::LEFT - 192))
      | (1ULL << (GreenPlumParser::LEVEL - 192))
      | (1ULL << (GreenPlumParser::LIKE - 192))
      | (1ULL << (GreenPlumParser::LIST - 192))
      | (1ULL << (GreenPlumParser::LISTEN - 192))
      | (1ULL << (GreenPlumParser::LOAD - 192))
      | (1ULL << (GreenPlumParser::LOCAL - 192))
      | (1ULL << (GreenPlumParser::LOCATION - 192))
      | (1ULL << (GreenPlumParser::LOCK_P - 192))
      | (1ULL << (GreenPlumParser::LOGIN_P - 192))
      | (1ULL << (GreenPlumParser::LOG_P - 192))
      | (1ULL << (GreenPlumParser::MAPPING - 192))
      | (1ULL << (GreenPlumParser::MASTER - 192))
      | (1ULL << (GreenPlumParser::MATCH - 192))
      | (1ULL << (GreenPlumParser::MAXVALUE - 192))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 192))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 192))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 192))
      | (1ULL << (GreenPlumParser::MERGE - 192))
      | (1ULL << (GreenPlumParser::MINUTE_P - 192))
      | (1ULL << (GreenPlumParser::MINVALUE - 192))
      | (1ULL << (GreenPlumParser::MISSING - 192))
      | (1ULL << (GreenPlumParser::MODE - 192))
      | (1ULL << (GreenPlumParser::MODIFIES - 192))
      | (1ULL << (GreenPlumParser::MODIFY - 192))
      | (1ULL << (GreenPlumParser::MONTH_P - 192))
      | (1ULL << (GreenPlumParser::MOVE - 192))
      | (1ULL << (GreenPlumParser::NAME_P - 192))
      | (1ULL << (GreenPlumParser::NAMES - 192))
      | (1ULL << (GreenPlumParser::NATIONAL - 192))
      | (1ULL << (GreenPlumParser::NATURAL - 192))
      | (1ULL << (GreenPlumParser::NCHAR - 192))
      | (1ULL << (GreenPlumParser::NEXT - 192))
      | (1ULL << (GreenPlumParser::NO - 192))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 192))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 192))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 192)))) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & ((1ULL << (GreenPlumParser::NOCREATEUSER - 256))
      | (1ULL << (GreenPlumParser::NOINHERIT - 256))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 256))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 256))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 256))
      | (1ULL << (GreenPlumParser::NOTHING - 256))
      | (1ULL << (GreenPlumParser::NOTIFY - 256))
      | (1ULL << (GreenPlumParser::NOTNULL - 256))
      | (1ULL << (GreenPlumParser::NOWAIT - 256))
      | (1ULL << (GreenPlumParser::NULLS_P - 256))
      | (1ULL << (GreenPlumParser::NUMERIC - 256))
      | (1ULL << (GreenPlumParser::OBJECT_P - 256))
      | (1ULL << (GreenPlumParser::OF - 256))
      | (1ULL << (GreenPlumParser::OIDS - 256))
      | (1ULL << (GreenPlumParser::OPERATOR - 256))
      | (1ULL << (GreenPlumParser::OPTION - 256))
      | (1ULL << (GreenPlumParser::OPTIONS - 256))
      | (1ULL << (GreenPlumParser::ORDERED - 256))
      | (1ULL << (GreenPlumParser::OTHERS - 256))
      | (1ULL << (GreenPlumParser::OUTER_P - 256))
      | (1ULL << (GreenPlumParser::OUT_P - 256))
      | (1ULL << (GreenPlumParser::OVER - 256))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 256))
      | (1ULL << (GreenPlumParser::OVERLAPS - 256))
      | (1ULL << (GreenPlumParser::OWNED - 256))
      | (1ULL << (GreenPlumParser::OWNER - 256))
      | (1ULL << (GreenPlumParser::PARSER - 256))
      | (1ULL << (GreenPlumParser::PARTIAL - 256))
      | (1ULL << (GreenPlumParser::PARTITIONS - 256))
      | (1ULL << (GreenPlumParser::PASSING - 256))
      | (1ULL << (GreenPlumParser::PASSWORD - 256))
      | (1ULL << (GreenPlumParser::PERCENT - 256))
      | (1ULL << (GreenPlumParser::PLANS - 256))
      | (1ULL << (GreenPlumParser::PREPARE - 256))
      | (1ULL << (GreenPlumParser::PREPARED - 256))
      | (1ULL << (GreenPlumParser::PRESERVE - 256))
      | (1ULL << (GreenPlumParser::PRIOR - 256))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 256))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 256))
      | (1ULL << (GreenPlumParser::PROCEDURE - 256))
      | (1ULL << (GreenPlumParser::PROGRAM - 256))
      | (1ULL << (GreenPlumParser::PROTOCOL - 256)))) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & ((1ULL << (GreenPlumParser::PUBLIC - 320))
      | (1ULL << (GreenPlumParser::QUEUE - 320))
      | (1ULL << (GreenPlumParser::QUOTE - 320))
      | (1ULL << (GreenPlumParser::RANDOMLY - 320))
      | (1ULL << (GreenPlumParser::READ - 320))
      | (1ULL << (GreenPlumParser::READABLE - 320))
      | (1ULL << (GreenPlumParser::READS - 320))
      | (1ULL << (GreenPlumParser::REAL - 320))
      | (1ULL << (GreenPlumParser::REASSIGN - 320))
      | (1ULL << (GreenPlumParser::RECHECK - 320))
      | (1ULL << (GreenPlumParser::RECURSIVE - 320))
      | (1ULL << (GreenPlumParser::REF - 320))
      | (1ULL << (GreenPlumParser::REINDEX - 320))
      | (1ULL << (GreenPlumParser::REJECT_P - 320))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 320))
      | (1ULL << (GreenPlumParser::RELEASE - 320))
      | (1ULL << (GreenPlumParser::RENAME - 320))
      | (1ULL << (GreenPlumParser::REPEATABLE - 320))
      | (1ULL << (GreenPlumParser::REPLACE - 320))
      | (1ULL << (GreenPlumParser::REPLICA - 320))
      | (1ULL << (GreenPlumParser::RESET - 320))
      | (1ULL << (GreenPlumParser::RESOURCE - 320))
      | (1ULL << (GreenPlumParser::RESTART - 320))
      | (1ULL << (GreenPlumParser::RESTRICT - 320))
      | (1ULL << (GreenPlumParser::RETURNS - 320))
      | (1ULL << (GreenPlumParser::REVOKE - 320))
      | (1ULL << (GreenPlumParser::RIGHT - 320))
      | (1ULL << (GreenPlumParser::ROLE - 320))
      | (1ULL << (GreenPlumParser::ROLLBACK - 320))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 320))
      | (1ULL << (GreenPlumParser::RULE - 320))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 320))
      | (1ULL << (GreenPlumParser::SCHEMA - 320))
      | (1ULL << (GreenPlumParser::SCROLL - 320))
      | (1ULL << (GreenPlumParser::SEARCH - 320))
      | (1ULL << (GreenPlumParser::SECOND_P - 320))
      | (1ULL << (GreenPlumParser::SECURITY - 320))
      | (1ULL << (GreenPlumParser::SEGMENT - 320))
      | (1ULL << (GreenPlumParser::SEQUENCE - 320))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 320))
      | (1ULL << (GreenPlumParser::SESSION - 320))
      | (1ULL << (GreenPlumParser::SET - 320))
      | (1ULL << (GreenPlumParser::SETOF - 320))
      | (1ULL << (GreenPlumParser::SHARE - 320))
      | (1ULL << (GreenPlumParser::SHOW - 320))
      | (1ULL << (GreenPlumParser::SIMILAR - 320))
      | (1ULL << (GreenPlumParser::SIMPLE - 320))
      | (1ULL << (GreenPlumParser::SMALLINT - 320))
      | (1ULL << (GreenPlumParser::SPLIT - 320))
      | (1ULL << (GreenPlumParser::SQL - 320))
      | (1ULL << (GreenPlumParser::STABLE - 320))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 320))
      | (1ULL << (GreenPlumParser::START - 320)))) != 0) || ((((_la - 384) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 384)) & ((1ULL << (GreenPlumParser::STATEMENT - 384))
      | (1ULL << (GreenPlumParser::STATISTICS - 384))
      | (1ULL << (GreenPlumParser::STDIN - 384))
      | (1ULL << (GreenPlumParser::STDOUT - 384))
      | (1ULL << (GreenPlumParser::STORAGE - 384))
      | (1ULL << (GreenPlumParser::STRICT_P - 384))
      | (1ULL << (GreenPlumParser::STRIP_P - 384))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 384))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 384))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 384))
      | (1ULL << (GreenPlumParser::SYSID - 384))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 384))
      | (1ULL << (GreenPlumParser::TABLE - 384))
      | (1ULL << (GreenPlumParser::TABLESPACE - 384))
      | (1ULL << (GreenPlumParser::TEMP - 384))
      | (1ULL << (GreenPlumParser::TEMPLATE - 384))
      | (1ULL << (GreenPlumParser::TEMPORARY - 384))
      | (1ULL << (GreenPlumParser::TEXT_P - 384))
      | (1ULL << (GreenPlumParser::THRESHOLD - 384))
      | (1ULL << (GreenPlumParser::TIES - 384))
      | (1ULL << (GreenPlumParser::TIME - 384))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 384))
      | (1ULL << (GreenPlumParser::TRANSACTION - 384))
      | (1ULL << (GreenPlumParser::TRIGGER - 384))
      | (1ULL << (GreenPlumParser::TRUNCATE - 384))
      | (1ULL << (GreenPlumParser::TRUSTED - 384))
      | (1ULL << (GreenPlumParser::TYPE_P - 384))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 384))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 384))
      | (1ULL << (GreenPlumParser::UNKNOWN - 384))
      | (1ULL << (GreenPlumParser::UNLISTEN - 384))
      | (1ULL << (GreenPlumParser::UNTIL - 384))
      | (1ULL << (GreenPlumParser::UPDATE - 384))
      | (1ULL << (GreenPlumParser::VACUUM - 384))
      | (1ULL << (GreenPlumParser::VALID - 384))
      | (1ULL << (GreenPlumParser::VALIDATION - 384))
      | (1ULL << (GreenPlumParser::VALIDATOR - 384))
      | (1ULL << (GreenPlumParser::VALUE_P - 384))
      | (1ULL << (GreenPlumParser::VARCHAR - 384))
      | (1ULL << (GreenPlumParser::VARIADIC - 384))
      | (1ULL << (GreenPlumParser::VARYING - 384))
      | (1ULL << (GreenPlumParser::VERBOSE - 384))
      | (1ULL << (GreenPlumParser::VERSION_P - 384))
      | (1ULL << (GreenPlumParser::VIEW - 384))
      | (1ULL << (GreenPlumParser::VOLATILE - 384))
      | (1ULL << (GreenPlumParser::WEB - 384)))) != 0) || ((((_la - 448) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 448)) & ((1ULL << (GreenPlumParser::WHITESPACE_P - 448))
      | (1ULL << (GreenPlumParser::WITHIN - 448))
      | (1ULL << (GreenPlumParser::WITHOUT - 448))
      | (1ULL << (GreenPlumParser::WORK - 448))
      | (1ULL << (GreenPlumParser::WRITABLE - 448))
      | (1ULL << (GreenPlumParser::WRITE - 448))
      | (1ULL << (GreenPlumParser::XML_P - 448))
      | (1ULL << (GreenPlumParser::YEAR_P - 448))
      | (1ULL << (GreenPlumParser::YES_P - 448))
      | (1ULL << (GreenPlumParser::ZONE - 448))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 448))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 448)))) != 0)) {
      setState(3989);
      func_args_with_defaults_list();
    }
    setState(3992);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_args_with_defaults_listContext ------------------------------------------------------------------

GreenPlumParser::Func_args_with_defaults_listContext::Func_args_with_defaults_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Func_arg_with_defaultContext *> GreenPlumParser::Func_args_with_defaults_listContext::func_arg_with_default() {
  return getRuleContexts<GreenPlumParser::Func_arg_with_defaultContext>();
}

GreenPlumParser::Func_arg_with_defaultContext* GreenPlumParser::Func_args_with_defaults_listContext::func_arg_with_default(size_t i) {
  return getRuleContext<GreenPlumParser::Func_arg_with_defaultContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Func_args_with_defaults_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Func_args_with_defaults_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Func_args_with_defaults_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_args_with_defaults_list;
}

void GreenPlumParser::Func_args_with_defaults_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_args_with_defaults_list(this);
}

void GreenPlumParser::Func_args_with_defaults_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_args_with_defaults_list(this);
}


antlrcpp::Any GreenPlumParser::Func_args_with_defaults_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args_with_defaults_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_args_with_defaults_listContext* GreenPlumParser::func_args_with_defaults_list() {
  Func_args_with_defaults_listContext *_localctx = _tracker.createInstance<Func_args_with_defaults_listContext>(_ctx, getState());
  enterRule(_localctx, 546, GreenPlumParser::RuleFunc_args_with_defaults_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3994);
    func_arg_with_default();
    setState(3999);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(3995);
      match(GreenPlumParser::COMMA);
      setState(3996);
      func_arg_with_default();
      setState(4001);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_argContext ------------------------------------------------------------------

GreenPlumParser::Func_argContext::Func_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Func_typeContext* GreenPlumParser::Func_argContext::func_type() {
  return getRuleContext<GreenPlumParser::Func_typeContext>(0);
}

GreenPlumParser::Arg_classContext* GreenPlumParser::Func_argContext::arg_class() {
  return getRuleContext<GreenPlumParser::Arg_classContext>(0);
}

GreenPlumParser::Param_nameContext* GreenPlumParser::Func_argContext::param_name() {
  return getRuleContext<GreenPlumParser::Param_nameContext>(0);
}


size_t GreenPlumParser::Func_argContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_arg;
}

void GreenPlumParser::Func_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_arg(this);
}

void GreenPlumParser::Func_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_arg(this);
}


antlrcpp::Any GreenPlumParser::Func_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_arg(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_argContext* GreenPlumParser::func_arg() {
  Func_argContext *_localctx = _tracker.createInstance<Func_argContext>(_ctx, getState());
  enterRule(_localctx, 548, GreenPlumParser::RuleFunc_arg);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4003);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::INOUT

    || _la == GreenPlumParser::IN_P || _la == GreenPlumParser::OUT_P || _la == GreenPlumParser::VARIADIC) {
      setState(4002);
      arg_class();
    }
    setState(4006);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx)) {
    case 1: {
      setState(4005);
      param_name();
      break;
    }

    }
    setState(4008);
    func_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_arg_with_defaultContext ------------------------------------------------------------------

GreenPlumParser::Func_arg_with_defaultContext::Func_arg_with_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Func_argContext* GreenPlumParser::Func_arg_with_defaultContext::func_arg() {
  return getRuleContext<GreenPlumParser::Func_argContext>(0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Func_arg_with_defaultContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_arg_with_defaultContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Func_arg_with_defaultContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}


size_t GreenPlumParser::Func_arg_with_defaultContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_arg_with_default;
}

void GreenPlumParser::Func_arg_with_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_arg_with_default(this);
}

void GreenPlumParser::Func_arg_with_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_arg_with_default(this);
}


antlrcpp::Any GreenPlumParser::Func_arg_with_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_arg_with_default(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_arg_with_defaultContext* GreenPlumParser::func_arg_with_default() {
  Func_arg_with_defaultContext *_localctx = _tracker.createInstance<Func_arg_with_defaultContext>(_ctx, getState());
  enterRule(_localctx, 550, GreenPlumParser::RuleFunc_arg_with_default);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4010);
    func_arg();
    setState(4013);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DEFAULT || _la == GreenPlumParser::EQUALS_OP) {
      setState(4011);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::DEFAULT || _la == GreenPlumParser::EQUALS_OP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4012);
      a_expr();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Arg_classContext ------------------------------------------------------------------

GreenPlumParser::Arg_classContext::Arg_classContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Arg_classContext::IN_P() {
  return getToken(GreenPlumParser::IN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Arg_classContext::OUT_P() {
  return getToken(GreenPlumParser::OUT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Arg_classContext::INOUT() {
  return getToken(GreenPlumParser::INOUT, 0);
}

tree::TerminalNode* GreenPlumParser::Arg_classContext::VARIADIC() {
  return getToken(GreenPlumParser::VARIADIC, 0);
}


size_t GreenPlumParser::Arg_classContext::getRuleIndex() const {
  return GreenPlumParser::RuleArg_class;
}

void GreenPlumParser::Arg_classContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArg_class(this);
}

void GreenPlumParser::Arg_classContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArg_class(this);
}


antlrcpp::Any GreenPlumParser::Arg_classContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitArg_class(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Arg_classContext* GreenPlumParser::arg_class() {
  Arg_classContext *_localctx = _tracker.createInstance<Arg_classContext>(_ctx, getState());
  enterRule(_localctx, 552, GreenPlumParser::RuleArg_class);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4015);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::INOUT

    || _la == GreenPlumParser::IN_P || _la == GreenPlumParser::OUT_P || _la == GreenPlumParser::VARIADIC)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Param_nameContext ------------------------------------------------------------------

GreenPlumParser::Param_nameContext::Param_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Type_function_nameContext* GreenPlumParser::Param_nameContext::type_function_name() {
  return getRuleContext<GreenPlumParser::Type_function_nameContext>(0);
}


size_t GreenPlumParser::Param_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleParam_name;
}

void GreenPlumParser::Param_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParam_name(this);
}

void GreenPlumParser::Param_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParam_name(this);
}


antlrcpp::Any GreenPlumParser::Param_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParam_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Param_nameContext* GreenPlumParser::param_name() {
  Param_nameContext *_localctx = _tracker.createInstance<Param_nameContext>(_ctx, getState());
  enterRule(_localctx, 554, GreenPlumParser::RuleParam_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4017);
    type_function_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_returnContext ------------------------------------------------------------------

GreenPlumParser::Func_returnContext::Func_returnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Func_typeContext* GreenPlumParser::Func_returnContext::func_type() {
  return getRuleContext<GreenPlumParser::Func_typeContext>(0);
}


size_t GreenPlumParser::Func_returnContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_return;
}

void GreenPlumParser::Func_returnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_return(this);
}

void GreenPlumParser::Func_returnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_return(this);
}


antlrcpp::Any GreenPlumParser::Func_returnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_return(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_returnContext* GreenPlumParser::func_return() {
  Func_returnContext *_localctx = _tracker.createInstance<Func_returnContext>(_ctx, getState());
  enterRule(_localctx, 556, GreenPlumParser::RuleFunc_return);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4019);
    func_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_typeContext ------------------------------------------------------------------

GreenPlumParser::Func_typeContext::Func_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Func_typeContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_typeContext::SETOF() {
  return getToken(GreenPlumParser::SETOF, 0);
}

tree::TerminalNode* GreenPlumParser::Func_typeContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Func_typeContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Func_typeContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Func_type_table_option_listContext* GreenPlumParser::Func_typeContext::func_type_table_option_list() {
  return getRuleContext<GreenPlumParser::Func_type_table_option_listContext>(0);
}


size_t GreenPlumParser::Func_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_type;
}

void GreenPlumParser::Func_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_type(this);
}

void GreenPlumParser::Func_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_type(this);
}


antlrcpp::Any GreenPlumParser::Func_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_typeContext* GreenPlumParser::func_type() {
  Func_typeContext *_localctx = _tracker.createInstance<Func_typeContext>(_ctx, getState());
  enterRule(_localctx, 558, GreenPlumParser::RuleFunc_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4031);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SETOF:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID: {
        enterOuterAlt(_localctx, 1);
        setState(4022);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
        case 1: {
          setState(4021);
          match(GreenPlumParser::SETOF);
          break;
        }

        }
        setState(4024);
        typename_pg();
        break;
      }

      case GreenPlumParser::TABLE: {
        enterOuterAlt(_localctx, 2);
        setState(4025);
        match(GreenPlumParser::TABLE);
        setState(4026);
        match(GreenPlumParser::LEFT_PAREN);
        setState(4028);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
          | (1ULL << GreenPlumParser::ABSOLUTE_P)
          | (1ULL << GreenPlumParser::ACCESS)
          | (1ULL << GreenPlumParser::ACTION)
          | (1ULL << GreenPlumParser::ACTIVE)
          | (1ULL << GreenPlumParser::ADD_P)
          | (1ULL << GreenPlumParser::ADMIN)
          | (1ULL << GreenPlumParser::AFTER)
          | (1ULL << GreenPlumParser::AGGREGATE)
          | (1ULL << GreenPlumParser::ALSO)
          | (1ULL << GreenPlumParser::ALTER)
          | (1ULL << GreenPlumParser::ALWAYS)
          | (1ULL << GreenPlumParser::ASSERTION)
          | (1ULL << GreenPlumParser::ASSIGNMENT)
          | (1ULL << GreenPlumParser::AT)
          | (1ULL << GreenPlumParser::AUTHORIZATION)
          | (1ULL << GreenPlumParser::BACKWARD)
          | (1ULL << GreenPlumParser::BEFORE)
          | (1ULL << GreenPlumParser::BEGIN_P)
          | (1ULL << GreenPlumParser::BINARY)
          | (1ULL << GreenPlumParser::BY)
          | (1ULL << GreenPlumParser::CACHE)
          | (1ULL << GreenPlumParser::CALLED)
          | (1ULL << GreenPlumParser::CASCADE)
          | (1ULL << GreenPlumParser::CASCADED)
          | (1ULL << GreenPlumParser::CHAIN)
          | (1ULL << GreenPlumParser::CHARACTERISTICS)
          | (1ULL << GreenPlumParser::CHECKPOINT)
          | (1ULL << GreenPlumParser::CLASS)
          | (1ULL << GreenPlumParser::CLOSE)
          | (1ULL << GreenPlumParser::CLUSTER)
          | (1ULL << GreenPlumParser::COMMENT)
          | (1ULL << GreenPlumParser::COMMIT)
          | (1ULL << GreenPlumParser::COMMITTED)
          | (1ULL << GreenPlumParser::CONCURRENCY)
          | (1ULL << GreenPlumParser::CONCURRENTLY)
          | (1ULL << GreenPlumParser::CONFIGURATION)
          | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
          | (1ULL << (GreenPlumParser::CONTAINS - 64))
          | (1ULL << (GreenPlumParser::CONTENT_P - 64))
          | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
          | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
          | (1ULL << (GreenPlumParser::COPY - 64))
          | (1ULL << (GreenPlumParser::COST - 64))
          | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
          | (1ULL << (GreenPlumParser::CPUSET - 64))
          | (1ULL << (GreenPlumParser::CREATEDB - 64))
          | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
          | (1ULL << (GreenPlumParser::CREATEROLE - 64))
          | (1ULL << (GreenPlumParser::CREATEUSER - 64))
          | (1ULL << (GreenPlumParser::CROSS - 64))
          | (1ULL << (GreenPlumParser::CSV - 64))
          | (1ULL << (GreenPlumParser::CURRENT_P - 64))
          | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
          | (1ULL << (GreenPlumParser::CURSOR - 64))
          | (1ULL << (GreenPlumParser::CYCLE - 64))
          | (1ULL << (GreenPlumParser::DATABASE - 64))
          | (1ULL << (GreenPlumParser::DATA_P - 64))
          | (1ULL << (GreenPlumParser::DAY_P - 64))
          | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
          | (1ULL << (GreenPlumParser::DECLARE - 64))
          | (1ULL << (GreenPlumParser::DEFAULTS - 64))
          | (1ULL << (GreenPlumParser::DEFERRED - 64))
          | (1ULL << (GreenPlumParser::DEFINER - 64))
          | (1ULL << (GreenPlumParser::DELETE_P - 64))
          | (1ULL << (GreenPlumParser::DELIMITER - 64))
          | (1ULL << (GreenPlumParser::DELIMITERS - 64))
          | (1ULL << (GreenPlumParser::DENY - 64))
          | (1ULL << (GreenPlumParser::DICTIONARY - 64))
          | (1ULL << (GreenPlumParser::DISABLE_P - 64))
          | (1ULL << (GreenPlumParser::DISCARD - 64))
          | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
          | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
          | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
          | (1ULL << (GreenPlumParser::DROP - 64))
          | (1ULL << (GreenPlumParser::DXL - 64))
          | (1ULL << (GreenPlumParser::EACH - 64))
          | (1ULL << (GreenPlumParser::ENABLE_P - 64))
          | (1ULL << (GreenPlumParser::ENCODING - 64))
          | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
          | (1ULL << (GreenPlumParser::ENUM_P - 64))
          | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
          | (1ULL << (GreenPlumParser::EVERY - 128))
          | (1ULL << (GreenPlumParser::EXCHANGE - 128))
          | (1ULL << (GreenPlumParser::EXCLUDING - 128))
          | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
          | (1ULL << (GreenPlumParser::EXECUTE - 128))
          | (1ULL << (GreenPlumParser::EXPLAIN - 128))
          | (1ULL << (GreenPlumParser::EXTENSION - 128))
          | (1ULL << (GreenPlumParser::EXTERNAL - 128))
          | (1ULL << (GreenPlumParser::FAMILY - 128))
          | (1ULL << (GreenPlumParser::FIELDS - 128))
          | (1ULL << (GreenPlumParser::FILESPACE - 128))
          | (1ULL << (GreenPlumParser::FILL - 128))
          | (1ULL << (GreenPlumParser::FIRST_P - 128))
          | (1ULL << (GreenPlumParser::FORCE - 128))
          | (1ULL << (GreenPlumParser::FORMAT - 128))
          | (1ULL << (GreenPlumParser::FORWARD - 128))
          | (1ULL << (GreenPlumParser::FREEZE - 128))
          | (1ULL << (GreenPlumParser::FULL - 128))
          | (1ULL << (GreenPlumParser::FUNCTION - 128))
          | (1ULL << (GreenPlumParser::GLOBAL - 128))
          | (1ULL << (GreenPlumParser::GRANTED - 128))
          | (1ULL << (GreenPlumParser::HANDLER - 128))
          | (1ULL << (GreenPlumParser::HASH - 128))
          | (1ULL << (GreenPlumParser::HEADER_P - 128))
          | (1ULL << (GreenPlumParser::HOLD - 128))
          | (1ULL << (GreenPlumParser::HOST - 128))
          | (1ULL << (GreenPlumParser::HOUR_P - 128))
          | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
          | (1ULL << (GreenPlumParser::IF_P - 128))
          | (1ULL << (GreenPlumParser::IGNORE_P - 128))
          | (1ULL << (GreenPlumParser::ILIKE - 128))
          | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
          | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
          | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
          | (1ULL << (GreenPlumParser::INCLUDING - 128))
          | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
          | (1ULL << (GreenPlumParser::INCREMENT - 128))
          | (1ULL << (GreenPlumParser::INDEX - 128))
          | (1ULL << (GreenPlumParser::INDEXES - 128))
          | (1ULL << (GreenPlumParser::INHERIT - 128))
          | (1ULL << (GreenPlumParser::INHERITS - 128))
          | (1ULL << (GreenPlumParser::INLINE_P - 128))
          | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
          | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
          | (1ULL << (GreenPlumParser::INSERT - 193))
          | (1ULL << (GreenPlumParser::INSTEAD - 193))
          | (1ULL << (GreenPlumParser::INVOKER - 193))
          | (1ULL << (GreenPlumParser::IS - 193))
          | (1ULL << (GreenPlumParser::ISNULL - 193))
          | (1ULL << (GreenPlumParser::ISOLATION - 193))
          | (1ULL << (GreenPlumParser::JOIN - 193))
          | (1ULL << (GreenPlumParser::KEY - 193))
          | (1ULL << (GreenPlumParser::LANGUAGE - 193))
          | (1ULL << (GreenPlumParser::LARGE_P - 193))
          | (1ULL << (GreenPlumParser::LAST_P - 193))
          | (1ULL << (GreenPlumParser::LEFT - 193))
          | (1ULL << (GreenPlumParser::LEVEL - 193))
          | (1ULL << (GreenPlumParser::LIKE - 193))
          | (1ULL << (GreenPlumParser::LIST - 193))
          | (1ULL << (GreenPlumParser::LISTEN - 193))
          | (1ULL << (GreenPlumParser::LOAD - 193))
          | (1ULL << (GreenPlumParser::LOCAL - 193))
          | (1ULL << (GreenPlumParser::LOCATION - 193))
          | (1ULL << (GreenPlumParser::LOCK_P - 193))
          | (1ULL << (GreenPlumParser::LOGIN_P - 193))
          | (1ULL << (GreenPlumParser::LOG_P - 193))
          | (1ULL << (GreenPlumParser::MAPPING - 193))
          | (1ULL << (GreenPlumParser::MASTER - 193))
          | (1ULL << (GreenPlumParser::MATCH - 193))
          | (1ULL << (GreenPlumParser::MAXVALUE - 193))
          | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
          | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
          | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
          | (1ULL << (GreenPlumParser::MERGE - 193))
          | (1ULL << (GreenPlumParser::MINUTE_P - 193))
          | (1ULL << (GreenPlumParser::MINVALUE - 193))
          | (1ULL << (GreenPlumParser::MISSING - 193))
          | (1ULL << (GreenPlumParser::MODE - 193))
          | (1ULL << (GreenPlumParser::MODIFIES - 193))
          | (1ULL << (GreenPlumParser::MODIFY - 193))
          | (1ULL << (GreenPlumParser::MONTH_P - 193))
          | (1ULL << (GreenPlumParser::MOVE - 193))
          | (1ULL << (GreenPlumParser::NAME_P - 193))
          | (1ULL << (GreenPlumParser::NAMES - 193))
          | (1ULL << (GreenPlumParser::NATURAL - 193))
          | (1ULL << (GreenPlumParser::NEXT - 193))
          | (1ULL << (GreenPlumParser::NO - 193))
          | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
          | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
          | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
          | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
          | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
          | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
          | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
          | (1ULL << (GreenPlumParser::NOTHING - 257))
          | (1ULL << (GreenPlumParser::NOTIFY - 257))
          | (1ULL << (GreenPlumParser::NOTNULL - 257))
          | (1ULL << (GreenPlumParser::NOWAIT - 257))
          | (1ULL << (GreenPlumParser::NULLS_P - 257))
          | (1ULL << (GreenPlumParser::OBJECT_P - 257))
          | (1ULL << (GreenPlumParser::OF - 257))
          | (1ULL << (GreenPlumParser::OIDS - 257))
          | (1ULL << (GreenPlumParser::OPERATOR - 257))
          | (1ULL << (GreenPlumParser::OPTION - 257))
          | (1ULL << (GreenPlumParser::OPTIONS - 257))
          | (1ULL << (GreenPlumParser::ORDERED - 257))
          | (1ULL << (GreenPlumParser::OTHERS - 257))
          | (1ULL << (GreenPlumParser::OUTER_P - 257))
          | (1ULL << (GreenPlumParser::OVER - 257))
          | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
          | (1ULL << (GreenPlumParser::OVERLAPS - 257))
          | (1ULL << (GreenPlumParser::OWNED - 257))
          | (1ULL << (GreenPlumParser::OWNER - 257))
          | (1ULL << (GreenPlumParser::PARSER - 257))
          | (1ULL << (GreenPlumParser::PARTIAL - 257))
          | (1ULL << (GreenPlumParser::PARTITIONS - 257))
          | (1ULL << (GreenPlumParser::PASSING - 257))
          | (1ULL << (GreenPlumParser::PASSWORD - 257))
          | (1ULL << (GreenPlumParser::PERCENT - 257))
          | (1ULL << (GreenPlumParser::PLANS - 257))
          | (1ULL << (GreenPlumParser::PREPARE - 257))
          | (1ULL << (GreenPlumParser::PREPARED - 257))
          | (1ULL << (GreenPlumParser::PRESERVE - 257))
          | (1ULL << (GreenPlumParser::PRIOR - 257))
          | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
          | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
          | (1ULL << (GreenPlumParser::PROCEDURE - 257))
          | (1ULL << (GreenPlumParser::PROGRAM - 257))
          | (1ULL << (GreenPlumParser::PROTOCOL - 257))
          | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
          | (1ULL << (GreenPlumParser::QUOTE - 321))
          | (1ULL << (GreenPlumParser::RANDOMLY - 321))
          | (1ULL << (GreenPlumParser::READ - 321))
          | (1ULL << (GreenPlumParser::READABLE - 321))
          | (1ULL << (GreenPlumParser::READS - 321))
          | (1ULL << (GreenPlumParser::REASSIGN - 321))
          | (1ULL << (GreenPlumParser::RECHECK - 321))
          | (1ULL << (GreenPlumParser::RECURSIVE - 321))
          | (1ULL << (GreenPlumParser::REF - 321))
          | (1ULL << (GreenPlumParser::REINDEX - 321))
          | (1ULL << (GreenPlumParser::REJECT_P - 321))
          | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
          | (1ULL << (GreenPlumParser::RELEASE - 321))
          | (1ULL << (GreenPlumParser::RENAME - 321))
          | (1ULL << (GreenPlumParser::REPEATABLE - 321))
          | (1ULL << (GreenPlumParser::REPLACE - 321))
          | (1ULL << (GreenPlumParser::REPLICA - 321))
          | (1ULL << (GreenPlumParser::RESET - 321))
          | (1ULL << (GreenPlumParser::RESOURCE - 321))
          | (1ULL << (GreenPlumParser::RESTART - 321))
          | (1ULL << (GreenPlumParser::RESTRICT - 321))
          | (1ULL << (GreenPlumParser::RETURNS - 321))
          | (1ULL << (GreenPlumParser::REVOKE - 321))
          | (1ULL << (GreenPlumParser::RIGHT - 321))
          | (1ULL << (GreenPlumParser::ROLE - 321))
          | (1ULL << (GreenPlumParser::ROLLBACK - 321))
          | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
          | (1ULL << (GreenPlumParser::RULE - 321))
          | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
          | (1ULL << (GreenPlumParser::SCHEMA - 321))
          | (1ULL << (GreenPlumParser::SCROLL - 321))
          | (1ULL << (GreenPlumParser::SEARCH - 321))
          | (1ULL << (GreenPlumParser::SECOND_P - 321))
          | (1ULL << (GreenPlumParser::SECURITY - 321))
          | (1ULL << (GreenPlumParser::SEGMENT - 321))
          | (1ULL << (GreenPlumParser::SEQUENCE - 321))
          | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
          | (1ULL << (GreenPlumParser::SESSION - 321))
          | (1ULL << (GreenPlumParser::SET - 321))
          | (1ULL << (GreenPlumParser::SHARE - 321))
          | (1ULL << (GreenPlumParser::SHOW - 321))
          | (1ULL << (GreenPlumParser::SIMILAR - 321))
          | (1ULL << (GreenPlumParser::SIMPLE - 321))
          | (1ULL << (GreenPlumParser::SPLIT - 321))
          | (1ULL << (GreenPlumParser::SQL - 321))
          | (1ULL << (GreenPlumParser::STABLE - 321))
          | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
          | (1ULL << (GreenPlumParser::START - 321))
          | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
          | (1ULL << (GreenPlumParser::STDIN - 385))
          | (1ULL << (GreenPlumParser::STDOUT - 385))
          | (1ULL << (GreenPlumParser::STORAGE - 385))
          | (1ULL << (GreenPlumParser::STRICT_P - 385))
          | (1ULL << (GreenPlumParser::STRIP_P - 385))
          | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
          | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
          | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
          | (1ULL << (GreenPlumParser::SYSID - 385))
          | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
          | (1ULL << (GreenPlumParser::TABLESPACE - 385))
          | (1ULL << (GreenPlumParser::TEMP - 385))
          | (1ULL << (GreenPlumParser::TEMPLATE - 385))
          | (1ULL << (GreenPlumParser::TEMPORARY - 385))
          | (1ULL << (GreenPlumParser::TEXT_P - 385))
          | (1ULL << (GreenPlumParser::THRESHOLD - 385))
          | (1ULL << (GreenPlumParser::TIES - 385))
          | (1ULL << (GreenPlumParser::TRANSACTION - 385))
          | (1ULL << (GreenPlumParser::TRIGGER - 385))
          | (1ULL << (GreenPlumParser::TRUNCATE - 385))
          | (1ULL << (GreenPlumParser::TRUSTED - 385))
          | (1ULL << (GreenPlumParser::TYPE_P - 385))
          | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
          | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
          | (1ULL << (GreenPlumParser::UNKNOWN - 385))
          | (1ULL << (GreenPlumParser::UNLISTEN - 385))
          | (1ULL << (GreenPlumParser::UNTIL - 385))
          | (1ULL << (GreenPlumParser::UPDATE - 385))
          | (1ULL << (GreenPlumParser::VACUUM - 385))
          | (1ULL << (GreenPlumParser::VALID - 385))
          | (1ULL << (GreenPlumParser::VALIDATION - 385))
          | (1ULL << (GreenPlumParser::VALIDATOR - 385))
          | (1ULL << (GreenPlumParser::VALUE_P - 385))
          | (1ULL << (GreenPlumParser::VARYING - 385))
          | (1ULL << (GreenPlumParser::VERBOSE - 385))
          | (1ULL << (GreenPlumParser::VERSION_P - 385))
          | (1ULL << (GreenPlumParser::VIEW - 385))
          | (1ULL << (GreenPlumParser::VOLATILE - 385))
          | (1ULL << (GreenPlumParser::WEB - 385))
          | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
          | (1ULL << (GreenPlumParser::WITHOUT - 451))
          | (1ULL << (GreenPlumParser::WORK - 451))
          | (1ULL << (GreenPlumParser::WRITABLE - 451))
          | (1ULL << (GreenPlumParser::WRITE - 451))
          | (1ULL << (GreenPlumParser::XML_P - 451))
          | (1ULL << (GreenPlumParser::YEAR_P - 451))
          | (1ULL << (GreenPlumParser::YES_P - 451))
          | (1ULL << (GreenPlumParser::ZONE - 451))
          | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
          | (1ULL << (GreenPlumParser::REGULAR_ID - 451)))) != 0)) {
          setState(4027);
          func_type_table_option_list();
        }
        setState(4030);
        match(GreenPlumParser::RIGHT_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_type_table_option_listContext ------------------------------------------------------------------

GreenPlumParser::Func_type_table_option_listContext::Func_type_table_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Func_type_table_optionContext *> GreenPlumParser::Func_type_table_option_listContext::func_type_table_option() {
  return getRuleContexts<GreenPlumParser::Func_type_table_optionContext>();
}

GreenPlumParser::Func_type_table_optionContext* GreenPlumParser::Func_type_table_option_listContext::func_type_table_option(size_t i) {
  return getRuleContext<GreenPlumParser::Func_type_table_optionContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Func_type_table_option_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Func_type_table_option_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Func_type_table_option_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_type_table_option_list;
}

void GreenPlumParser::Func_type_table_option_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_type_table_option_list(this);
}

void GreenPlumParser::Func_type_table_option_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_type_table_option_list(this);
}


antlrcpp::Any GreenPlumParser::Func_type_table_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_type_table_option_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_type_table_option_listContext* GreenPlumParser::func_type_table_option_list() {
  Func_type_table_option_listContext *_localctx = _tracker.createInstance<Func_type_table_option_listContext>(_ctx, getState());
  enterRule(_localctx, 560, GreenPlumParser::RuleFunc_type_table_option_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4033);
    func_type_table_option();
    setState(4038);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(4034);
      match(GreenPlumParser::COMMA);
      setState(4035);
      func_type_table_option();
      setState(4040);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_type_table_optionContext ------------------------------------------------------------------

GreenPlumParser::Func_type_table_optionContext::Func_type_table_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Type_function_nameContext* GreenPlumParser::Func_type_table_optionContext::type_function_name() {
  return getRuleContext<GreenPlumParser::Type_function_nameContext>(0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Func_type_table_optionContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_type_table_optionContext::LIKE() {
  return getToken(GreenPlumParser::LIKE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Func_type_table_optionContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}


size_t GreenPlumParser::Func_type_table_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_type_table_option;
}

void GreenPlumParser::Func_type_table_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_type_table_option(this);
}

void GreenPlumParser::Func_type_table_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_type_table_option(this);
}


antlrcpp::Any GreenPlumParser::Func_type_table_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_type_table_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_type_table_optionContext* GreenPlumParser::func_type_table_option() {
  Func_type_table_optionContext *_localctx = _tracker.createInstance<Func_type_table_optionContext>(_ctx, getState());
  enterRule(_localctx, 562, GreenPlumParser::RuleFunc_type_table_option);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4046);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4041);
      type_function_name();
      setState(4042);
      typename_pg();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4044);
      match(GreenPlumParser::LIKE);
      setState(4045);
      name();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createfunc_opt_listContext ------------------------------------------------------------------

GreenPlumParser::Createfunc_opt_listContext::Createfunc_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Createfunc_opt_itemContext *> GreenPlumParser::Createfunc_opt_listContext::createfunc_opt_item() {
  return getRuleContexts<GreenPlumParser::Createfunc_opt_itemContext>();
}

GreenPlumParser::Createfunc_opt_itemContext* GreenPlumParser::Createfunc_opt_listContext::createfunc_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Createfunc_opt_itemContext>(i);
}


size_t GreenPlumParser::Createfunc_opt_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreatefunc_opt_list;
}

void GreenPlumParser::Createfunc_opt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreatefunc_opt_list(this);
}

void GreenPlumParser::Createfunc_opt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreatefunc_opt_list(this);
}


antlrcpp::Any GreenPlumParser::Createfunc_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreatefunc_opt_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Createfunc_opt_listContext* GreenPlumParser::createfunc_opt_list() {
  Createfunc_opt_listContext *_localctx = _tracker.createInstance<Createfunc_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 564, GreenPlumParser::RuleCreatefunc_opt_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4049); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(4048);
      createfunc_opt_item();
      setState(4051); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 19) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 19)) & ((1ULL << (GreenPlumParser::AS - 19))
      | (1ULL << (GreenPlumParser::CALLED - 19))
      | (1ULL << (GreenPlumParser::CONTAINS - 19))
      | (1ULL << (GreenPlumParser::COST - 19)))) != 0) || _la == GreenPlumParser::EXTERNAL

    || _la == GreenPlumParser::IMMUTABLE || ((((_la - 208) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 208)) & ((1ULL << (GreenPlumParser::LANGUAGE - 208))
      | (1ULL << (GreenPlumParser::MODIFIES - 208))
      | (1ULL << (GreenPlumParser::NO - 208)))) != 0) || ((((_la - 327) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 327)) & ((1ULL << (GreenPlumParser::READS - 327))
      | (1ULL << (GreenPlumParser::RESET - 327))
      | (1ULL << (GreenPlumParser::RETURNS - 327))
      | (1ULL << (GreenPlumParser::ROWS - 327))
      | (1ULL << (GreenPlumParser::SECURITY - 327))
      | (1ULL << (GreenPlumParser::SET - 327))
      | (1ULL << (GreenPlumParser::STABLE - 327))
      | (1ULL << (GreenPlumParser::STRICT_P - 327)))) != 0) || _la == GreenPlumParser::VOLATILE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_func_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Common_func_opt_itemContext::Common_func_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::CALLED() {
  return getToken(GreenPlumParser::CALLED, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Common_func_opt_itemContext::NULL_P() {
  return getTokens(GreenPlumParser::NULL_P);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::NULL_P(size_t i) {
  return getToken(GreenPlumParser::NULL_P, i);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::INPUT_P() {
  return getToken(GreenPlumParser::INPUT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::RETURNS() {
  return getToken(GreenPlumParser::RETURNS, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::STRICT_P() {
  return getToken(GreenPlumParser::STRICT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::IMMUTABLE() {
  return getToken(GreenPlumParser::IMMUTABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::STABLE() {
  return getToken(GreenPlumParser::STABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::VOLATILE() {
  return getToken(GreenPlumParser::VOLATILE, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::SECURITY() {
  return getToken(GreenPlumParser::SECURITY, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::DEFINER() {
  return getToken(GreenPlumParser::DEFINER, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::INVOKER() {
  return getToken(GreenPlumParser::INVOKER, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::EXTERNAL() {
  return getToken(GreenPlumParser::EXTERNAL, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::COST() {
  return getToken(GreenPlumParser::COST, 0);
}

GreenPlumParser::Numberic_onlyContext* GreenPlumParser::Common_func_opt_itemContext::numberic_only() {
  return getRuleContext<GreenPlumParser::Numberic_onlyContext>(0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::ROWS() {
  return getToken(GreenPlumParser::ROWS, 0);
}

GreenPlumParser::Set_reset_clauseContext* GreenPlumParser::Common_func_opt_itemContext::set_reset_clause() {
  return getRuleContext<GreenPlumParser::Set_reset_clauseContext>(0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::SQL() {
  return getToken(GreenPlumParser::SQL, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::CONTAINS() {
  return getToken(GreenPlumParser::CONTAINS, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::READS() {
  return getToken(GreenPlumParser::READS, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::DATA_P() {
  return getToken(GreenPlumParser::DATA_P, 0);
}

tree::TerminalNode* GreenPlumParser::Common_func_opt_itemContext::MODIFIES() {
  return getToken(GreenPlumParser::MODIFIES, 0);
}


size_t GreenPlumParser::Common_func_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleCommon_func_opt_item;
}

void GreenPlumParser::Common_func_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_func_opt_item(this);
}

void GreenPlumParser::Common_func_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_func_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Common_func_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCommon_func_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Common_func_opt_itemContext* GreenPlumParser::common_func_opt_item() {
  Common_func_opt_itemContext *_localctx = _tracker.createInstance<Common_func_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 566, GreenPlumParser::RuleCommon_func_opt_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4086);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CALLED: {
        enterOuterAlt(_localctx, 1);
        setState(4053);
        match(GreenPlumParser::CALLED);
        setState(4054);
        match(GreenPlumParser::ON);
        setState(4055);
        match(GreenPlumParser::NULL_P);
        setState(4056);
        match(GreenPlumParser::INPUT_P);
        break;
      }

      case GreenPlumParser::RETURNS: {
        enterOuterAlt(_localctx, 2);
        setState(4057);
        match(GreenPlumParser::RETURNS);
        setState(4058);
        match(GreenPlumParser::NULL_P);
        setState(4059);
        match(GreenPlumParser::ON);
        setState(4060);
        match(GreenPlumParser::NULL_P);
        setState(4061);
        match(GreenPlumParser::INPUT_P);
        break;
      }

      case GreenPlumParser::STRICT_P: {
        enterOuterAlt(_localctx, 3);
        setState(4062);
        match(GreenPlumParser::STRICT_P);
        break;
      }

      case GreenPlumParser::IMMUTABLE: {
        enterOuterAlt(_localctx, 4);
        setState(4063);
        match(GreenPlumParser::IMMUTABLE);
        break;
      }

      case GreenPlumParser::STABLE: {
        enterOuterAlt(_localctx, 5);
        setState(4064);
        match(GreenPlumParser::STABLE);
        break;
      }

      case GreenPlumParser::VOLATILE: {
        enterOuterAlt(_localctx, 6);
        setState(4065);
        match(GreenPlumParser::VOLATILE);
        break;
      }

      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::SECURITY: {
        enterOuterAlt(_localctx, 7);
        setState(4067);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EXTERNAL) {
          setState(4066);
          match(GreenPlumParser::EXTERNAL);
        }
        setState(4069);
        match(GreenPlumParser::SECURITY);
        setState(4070);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::DEFINER || _la == GreenPlumParser::INVOKER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case GreenPlumParser::COST: {
        enterOuterAlt(_localctx, 8);
        setState(4071);
        match(GreenPlumParser::COST);
        setState(4072);
        numberic_only();
        break;
      }

      case GreenPlumParser::ROWS: {
        enterOuterAlt(_localctx, 9);
        setState(4073);
        match(GreenPlumParser::ROWS);
        setState(4074);
        numberic_only();
        break;
      }

      case GreenPlumParser::RESET:
      case GreenPlumParser::SET: {
        enterOuterAlt(_localctx, 10);
        setState(4075);
        set_reset_clause();
        break;
      }

      case GreenPlumParser::NO: {
        enterOuterAlt(_localctx, 11);
        setState(4076);
        match(GreenPlumParser::NO);
        setState(4077);
        match(GreenPlumParser::SQL);
        break;
      }

      case GreenPlumParser::CONTAINS: {
        enterOuterAlt(_localctx, 12);
        setState(4078);
        match(GreenPlumParser::CONTAINS);
        setState(4079);
        match(GreenPlumParser::SQL);
        break;
      }

      case GreenPlumParser::READS: {
        enterOuterAlt(_localctx, 13);
        setState(4080);
        match(GreenPlumParser::READS);
        setState(4081);
        match(GreenPlumParser::SQL);
        setState(4082);
        match(GreenPlumParser::DATA_P);
        break;
      }

      case GreenPlumParser::MODIFIES: {
        enterOuterAlt(_localctx, 14);
        setState(4083);
        match(GreenPlumParser::MODIFIES);
        setState(4084);
        match(GreenPlumParser::SQL);
        setState(4085);
        match(GreenPlumParser::DATA_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createfunc_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Createfunc_opt_itemContext::Createfunc_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Createfunc_opt_itemContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Func_asContext* GreenPlumParser::Createfunc_opt_itemContext::func_as() {
  return getRuleContext<GreenPlumParser::Func_asContext>(0);
}

tree::TerminalNode* GreenPlumParser::Createfunc_opt_itemContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

GreenPlumParser::Colid_or_sconstContext* GreenPlumParser::Createfunc_opt_itemContext::colid_or_sconst() {
  return getRuleContext<GreenPlumParser::Colid_or_sconstContext>(0);
}

GreenPlumParser::Common_func_opt_itemContext* GreenPlumParser::Createfunc_opt_itemContext::common_func_opt_item() {
  return getRuleContext<GreenPlumParser::Common_func_opt_itemContext>(0);
}


size_t GreenPlumParser::Createfunc_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreatefunc_opt_item;
}

void GreenPlumParser::Createfunc_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreatefunc_opt_item(this);
}

void GreenPlumParser::Createfunc_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreatefunc_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Createfunc_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreatefunc_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Createfunc_opt_itemContext* GreenPlumParser::createfunc_opt_item() {
  Createfunc_opt_itemContext *_localctx = _tracker.createInstance<Createfunc_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 568, GreenPlumParser::RuleCreatefunc_opt_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4093);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::AS: {
        enterOuterAlt(_localctx, 1);
        setState(4088);
        match(GreenPlumParser::AS);
        setState(4089);
        func_as();
        break;
      }

      case GreenPlumParser::LANGUAGE: {
        enterOuterAlt(_localctx, 2);
        setState(4090);
        match(GreenPlumParser::LANGUAGE);
        setState(4091);
        colid_or_sconst();
        break;
      }

      case GreenPlumParser::CALLED:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::COST:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::NO:
      case GreenPlumParser::READS:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::ROWS:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SET:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::VOLATILE: {
        enterOuterAlt(_localctx, 3);
        setState(4092);
        common_func_opt_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_asContext ------------------------------------------------------------------

GreenPlumParser::Func_asContext::Func_asContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::SconstContext *> GreenPlumParser::Func_asContext::sconst() {
  return getRuleContexts<GreenPlumParser::SconstContext>();
}

GreenPlumParser::SconstContext* GreenPlumParser::Func_asContext::sconst(size_t i) {
  return getRuleContext<GreenPlumParser::SconstContext>(i);
}

tree::TerminalNode* GreenPlumParser::Func_asContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}


size_t GreenPlumParser::Func_asContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_as;
}

void GreenPlumParser::Func_asContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_as(this);
}

void GreenPlumParser::Func_asContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_as(this);
}


antlrcpp::Any GreenPlumParser::Func_asContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_as(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_asContext* GreenPlumParser::func_as() {
  Func_asContext *_localctx = _tracker.createInstance<Func_asContext>(_ctx, getState());
  enterRule(_localctx, 570, GreenPlumParser::RuleFunc_as);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4095);
    sconst();
    setState(4098);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::COMMA) {
      setState(4096);
      match(GreenPlumParser::COMMA);
      setState(4097);
      sconst();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_func_columnContext ------------------------------------------------------------------

GreenPlumParser::Table_func_columnContext::Table_func_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Param_nameContext* GreenPlumParser::Table_func_columnContext::param_name() {
  return getRuleContext<GreenPlumParser::Param_nameContext>(0);
}

GreenPlumParser::Func_typeContext* GreenPlumParser::Table_func_columnContext::func_type() {
  return getRuleContext<GreenPlumParser::Func_typeContext>(0);
}


size_t GreenPlumParser::Table_func_columnContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_func_column;
}

void GreenPlumParser::Table_func_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_func_column(this);
}

void GreenPlumParser::Table_func_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_func_column(this);
}


antlrcpp::Any GreenPlumParser::Table_func_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_func_column(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_func_columnContext* GreenPlumParser::table_func_column() {
  Table_func_columnContext *_localctx = _tracker.createInstance<Table_func_columnContext>(_ctx, getState());
  enterRule(_localctx, 572, GreenPlumParser::RuleTable_func_column);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4100);
    param_name();
    setState(4101);
    func_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_func_column_listContext ------------------------------------------------------------------

GreenPlumParser::Table_func_column_listContext::Table_func_column_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Table_func_columnContext *> GreenPlumParser::Table_func_column_listContext::table_func_column() {
  return getRuleContexts<GreenPlumParser::Table_func_columnContext>();
}

GreenPlumParser::Table_func_columnContext* GreenPlumParser::Table_func_column_listContext::table_func_column(size_t i) {
  return getRuleContext<GreenPlumParser::Table_func_columnContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Table_func_column_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Table_func_column_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Table_func_column_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_func_column_list;
}

void GreenPlumParser::Table_func_column_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_func_column_list(this);
}

void GreenPlumParser::Table_func_column_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_func_column_list(this);
}


antlrcpp::Any GreenPlumParser::Table_func_column_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_func_column_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_func_column_listContext* GreenPlumParser::table_func_column_list() {
  Table_func_column_listContext *_localctx = _tracker.createInstance<Table_func_column_listContext>(_ctx, getState());
  enterRule(_localctx, 574, GreenPlumParser::RuleTable_func_column_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4103);
    table_func_column();
    setState(4108);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(4104);
      match(GreenPlumParser::COMMA);
      setState(4105);
      table_func_column();
      setState(4110);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_function_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_function_stmtContext::Alter_function_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_function_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_function_stmtContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::Alter_function_stmtContext::function_with_argtypes() {
  return getRuleContext<GreenPlumParser::Function_with_argtypesContext>(0);
}

GreenPlumParser::Alterfunc_opt_listContext* GreenPlumParser::Alter_function_stmtContext::alterfunc_opt_list() {
  return getRuleContext<GreenPlumParser::Alterfunc_opt_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_function_stmtContext::RESTRICT() {
  return getToken(GreenPlumParser::RESTRICT, 0);
}


size_t GreenPlumParser::Alter_function_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_function_stmt;
}

void GreenPlumParser::Alter_function_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_function_stmt(this);
}

void GreenPlumParser::Alter_function_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_function_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_function_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_function_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_function_stmtContext* GreenPlumParser::alter_function_stmt() {
  Alter_function_stmtContext *_localctx = _tracker.createInstance<Alter_function_stmtContext>(_ctx, getState());
  enterRule(_localctx, 576, GreenPlumParser::RuleAlter_function_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4111);
    match(GreenPlumParser::ALTER);
    setState(4112);
    match(GreenPlumParser::FUNCTION);
    setState(4113);
    function_with_argtypes();
    setState(4114);
    alterfunc_opt_list();
    setState(4116);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::RESTRICT) {
      setState(4115);
      match(GreenPlumParser::RESTRICT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alterfunc_opt_listContext ------------------------------------------------------------------

GreenPlumParser::Alterfunc_opt_listContext::Alterfunc_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Common_func_opt_itemContext *> GreenPlumParser::Alterfunc_opt_listContext::common_func_opt_item() {
  return getRuleContexts<GreenPlumParser::Common_func_opt_itemContext>();
}

GreenPlumParser::Common_func_opt_itemContext* GreenPlumParser::Alterfunc_opt_listContext::common_func_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Common_func_opt_itemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Alterfunc_opt_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Alterfunc_opt_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}

tree::TerminalNode* GreenPlumParser::Alterfunc_opt_listContext::RENAME() {
  return getToken(GreenPlumParser::RENAME, 0);
}

tree::TerminalNode* GreenPlumParser::Alterfunc_opt_listContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alterfunc_opt_listContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alterfunc_opt_listContext::OWNER() {
  return getToken(GreenPlumParser::OWNER, 0);
}

tree::TerminalNode* GreenPlumParser::Alterfunc_opt_listContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alterfunc_opt_listContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}


size_t GreenPlumParser::Alterfunc_opt_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlterfunc_opt_list;
}

void GreenPlumParser::Alterfunc_opt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterfunc_opt_list(this);
}

void GreenPlumParser::Alterfunc_opt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterfunc_opt_list(this);
}


antlrcpp::Any GreenPlumParser::Alterfunc_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlterfunc_opt_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alterfunc_opt_listContext* GreenPlumParser::alterfunc_opt_list() {
  Alterfunc_opt_listContext *_localctx = _tracker.createInstance<Alterfunc_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 578, GreenPlumParser::RuleAlterfunc_opt_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4135);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4118);
      common_func_opt_item();
      setState(4123);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GreenPlumParser::COMMA) {
        setState(4119);
        match(GreenPlumParser::COMMA);
        setState(4120);
        common_func_opt_item();
        setState(4125);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4126);
      match(GreenPlumParser::RENAME);
      setState(4127);
      match(GreenPlumParser::TO);
      setState(4128);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4129);
      match(GreenPlumParser::OWNER);
      setState(4130);
      match(GreenPlumParser::TO);
      setState(4131);
      name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4132);
      match(GreenPlumParser::SET);
      setState(4133);
      match(GreenPlumParser::SCHEMA);
      setState(4134);
      name();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remove_func_stmtContext ------------------------------------------------------------------

GreenPlumParser::Remove_func_stmtContext::Remove_func_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Remove_func_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Remove_func_stmtContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Remove_func_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Func_argsContext* GreenPlumParser::Remove_func_stmtContext::func_args() {
  return getRuleContext<GreenPlumParser::Func_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Remove_func_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Remove_func_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Remove_func_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Remove_func_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRemove_func_stmt;
}

void GreenPlumParser::Remove_func_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemove_func_stmt(this);
}

void GreenPlumParser::Remove_func_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemove_func_stmt(this);
}


antlrcpp::Any GreenPlumParser::Remove_func_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRemove_func_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Remove_func_stmtContext* GreenPlumParser::remove_func_stmt() {
  Remove_func_stmtContext *_localctx = _tracker.createInstance<Remove_func_stmtContext>(_ctx, getState());
  enterRule(_localctx, 580, GreenPlumParser::RuleRemove_func_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4137);
    match(GreenPlumParser::DROP);
    setState(4138);
    match(GreenPlumParser::FUNCTION);
    setState(4141);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 394, _ctx)) {
    case 1: {
      setState(4139);
      match(GreenPlumParser::IF_P);
      setState(4140);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(4143);
    func_name();
    setState(4144);
    func_args();
    setState(4146);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(4145);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remove_aggr_stmtContext ------------------------------------------------------------------

GreenPlumParser::Remove_aggr_stmtContext::Remove_aggr_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Remove_aggr_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Remove_aggr_stmtContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Remove_aggr_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::Remove_aggr_stmtContext::aggr_args() {
  return getRuleContext<GreenPlumParser::Aggr_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Remove_aggr_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Remove_aggr_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Remove_aggr_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Remove_aggr_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRemove_aggr_stmt;
}

void GreenPlumParser::Remove_aggr_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemove_aggr_stmt(this);
}

void GreenPlumParser::Remove_aggr_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemove_aggr_stmt(this);
}


antlrcpp::Any GreenPlumParser::Remove_aggr_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRemove_aggr_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Remove_aggr_stmtContext* GreenPlumParser::remove_aggr_stmt() {
  Remove_aggr_stmtContext *_localctx = _tracker.createInstance<Remove_aggr_stmtContext>(_ctx, getState());
  enterRule(_localctx, 582, GreenPlumParser::RuleRemove_aggr_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4148);
    match(GreenPlumParser::DROP);
    setState(4149);
    match(GreenPlumParser::AGGREGATE);
    setState(4152);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx)) {
    case 1: {
      setState(4150);
      match(GreenPlumParser::IF_P);
      setState(4151);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(4154);
    func_name();
    setState(4155);
    aggr_args();
    setState(4157);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(4156);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remove_oper_stmtContext ------------------------------------------------------------------

GreenPlumParser::Remove_oper_stmtContext::Remove_oper_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Remove_oper_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Remove_oper_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Remove_oper_stmtContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

GreenPlumParser::Oper_argtypesContext* GreenPlumParser::Remove_oper_stmtContext::oper_argtypes() {
  return getRuleContext<GreenPlumParser::Oper_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Remove_oper_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Remove_oper_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Remove_oper_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Remove_oper_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRemove_oper_stmt;
}

void GreenPlumParser::Remove_oper_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemove_oper_stmt(this);
}

void GreenPlumParser::Remove_oper_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemove_oper_stmt(this);
}


antlrcpp::Any GreenPlumParser::Remove_oper_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRemove_oper_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Remove_oper_stmtContext* GreenPlumParser::remove_oper_stmt() {
  Remove_oper_stmtContext *_localctx = _tracker.createInstance<Remove_oper_stmtContext>(_ctx, getState());
  enterRule(_localctx, 584, GreenPlumParser::RuleRemove_oper_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4159);
    match(GreenPlumParser::DROP);
    setState(4160);
    match(GreenPlumParser::OPERATOR);
    setState(4163);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx)) {
    case 1: {
      setState(4161);
      match(GreenPlumParser::IF_P);
      setState(4162);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(4165);
    any_operator();
    setState(4166);
    oper_argtypes();
    setState(4168);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(4167);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Oper_argtypesContext ------------------------------------------------------------------

GreenPlumParser::Oper_argtypesContext::Oper_argtypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Oper_argtypesContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

std::vector<GreenPlumParser::Typename_pgContext *> GreenPlumParser::Oper_argtypesContext::typename_pg() {
  return getRuleContexts<GreenPlumParser::Typename_pgContext>();
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Oper_argtypesContext::typename_pg(size_t i) {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(i);
}

tree::TerminalNode* GreenPlumParser::Oper_argtypesContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Oper_argtypesContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}

tree::TerminalNode* GreenPlumParser::Oper_argtypesContext::NONE() {
  return getToken(GreenPlumParser::NONE, 0);
}


size_t GreenPlumParser::Oper_argtypesContext::getRuleIndex() const {
  return GreenPlumParser::RuleOper_argtypes;
}

void GreenPlumParser::Oper_argtypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOper_argtypes(this);
}

void GreenPlumParser::Oper_argtypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOper_argtypes(this);
}


antlrcpp::Any GreenPlumParser::Oper_argtypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOper_argtypes(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Oper_argtypesContext* GreenPlumParser::oper_argtypes() {
  Oper_argtypesContext *_localctx = _tracker.createInstance<Oper_argtypesContext>(_ctx, getState());
  enterRule(_localctx, 586, GreenPlumParser::RuleOper_argtypes);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4190);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4170);
      match(GreenPlumParser::LEFT_PAREN);
      setState(4171);
      typename_pg();
      setState(4174);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COMMA) {
        setState(4172);
        match(GreenPlumParser::COMMA);
        setState(4173);
        typename_pg();
      }
      setState(4176);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4178);
      match(GreenPlumParser::LEFT_PAREN);
      setState(4179);
      match(GreenPlumParser::NONE);
      setState(4180);
      match(GreenPlumParser::COMMA);
      setState(4181);
      typename_pg();
      setState(4182);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4184);
      match(GreenPlumParser::LEFT_PAREN);
      setState(4185);
      typename_pg();
      setState(4186);
      match(GreenPlumParser::COMMA);
      setState(4187);
      match(GreenPlumParser::NONE);
      setState(4188);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_operatorContext ------------------------------------------------------------------

GreenPlumParser::Any_operatorContext::Any_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::All_OpContext* GreenPlumParser::Any_operatorContext::all_Op() {
  return getRuleContext<GreenPlumParser::All_OpContext>(0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Any_operatorContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Any_operatorContext::PERIOD() {
  return getToken(GreenPlumParser::PERIOD, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Any_operatorContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}


size_t GreenPlumParser::Any_operatorContext::getRuleIndex() const {
  return GreenPlumParser::RuleAny_operator;
}

void GreenPlumParser::Any_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAny_operator(this);
}

void GreenPlumParser::Any_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAny_operator(this);
}


antlrcpp::Any GreenPlumParser::Any_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAny_operator(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::any_operator() {
  Any_operatorContext *_localctx = _tracker.createInstance<Any_operatorContext>(_ctx, getState());
  enterRule(_localctx, 588, GreenPlumParser::RuleAny_operator);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4197);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::OP_CHARS: {
        enterOuterAlt(_localctx, 1);
        setState(4192);
        all_Op();
        break;
      }

      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 2);
        setState(4193);
        colid();
        setState(4194);
        match(GreenPlumParser::PERIOD);
        setState(4195);
        any_operator();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Do_stmtContext ------------------------------------------------------------------

GreenPlumParser::Do_stmtContext::Do_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Do_stmtContext::DO() {
  return getToken(GreenPlumParser::DO, 0);
}

std::vector<GreenPlumParser::Dostmt_opt_itemContext *> GreenPlumParser::Do_stmtContext::dostmt_opt_item() {
  return getRuleContexts<GreenPlumParser::Dostmt_opt_itemContext>();
}

GreenPlumParser::Dostmt_opt_itemContext* GreenPlumParser::Do_stmtContext::dostmt_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Dostmt_opt_itemContext>(i);
}


size_t GreenPlumParser::Do_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDo_stmt;
}

void GreenPlumParser::Do_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDo_stmt(this);
}

void GreenPlumParser::Do_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDo_stmt(this);
}


antlrcpp::Any GreenPlumParser::Do_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDo_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Do_stmtContext* GreenPlumParser::do_stmt() {
  Do_stmtContext *_localctx = _tracker.createInstance<Do_stmtContext>(_ctx, getState());
  enterRule(_localctx, 590, GreenPlumParser::RuleDo_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4199);
    match(GreenPlumParser::DO);
    setState(4201); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(4200);
      dostmt_opt_item();
      setState(4203); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dostmt_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Dostmt_opt_itemContext::Dostmt_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Colid_or_sconstContext* GreenPlumParser::Dostmt_opt_itemContext::colid_or_sconst() {
  return getRuleContext<GreenPlumParser::Colid_or_sconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Dostmt_opt_itemContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}


size_t GreenPlumParser::Dostmt_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleDostmt_opt_item;
}

void GreenPlumParser::Dostmt_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDostmt_opt_item(this);
}

void GreenPlumParser::Dostmt_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDostmt_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Dostmt_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDostmt_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Dostmt_opt_itemContext* GreenPlumParser::dostmt_opt_item() {
  Dostmt_opt_itemContext *_localctx = _tracker.createInstance<Dostmt_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 592, GreenPlumParser::RuleDostmt_opt_item);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4206);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx)) {
    case 1: {
      setState(4205);
      match(GreenPlumParser::LANGUAGE);
      break;
    }

    }
    setState(4208);
    colid_or_sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_cast_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_cast_stmtContext::Create_cast_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_cast_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_cast_stmtContext::CAST() {
  return getToken(GreenPlumParser::CAST, 0);
}

tree::TerminalNode* GreenPlumParser::Create_cast_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

std::vector<GreenPlumParser::Typename_pgContext *> GreenPlumParser::Create_cast_stmtContext::typename_pg() {
  return getRuleContexts<GreenPlumParser::Typename_pgContext>();
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Create_cast_stmtContext::typename_pg(size_t i) {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(i);
}

tree::TerminalNode* GreenPlumParser::Create_cast_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Create_cast_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Create_cast_stmtContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Create_cast_stmtContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::Create_cast_stmtContext::function_with_argtypes() {
  return getRuleContext<GreenPlumParser::Function_with_argtypesContext>(0);
}

GreenPlumParser::Cast_contextContext* GreenPlumParser::Create_cast_stmtContext::cast_context() {
  return getRuleContext<GreenPlumParser::Cast_contextContext>(0);
}


size_t GreenPlumParser::Create_cast_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_cast_stmt;
}

void GreenPlumParser::Create_cast_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_cast_stmt(this);
}

void GreenPlumParser::Create_cast_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_cast_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_cast_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_cast_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_cast_stmtContext* GreenPlumParser::create_cast_stmt() {
  Create_cast_stmtContext *_localctx = _tracker.createInstance<Create_cast_stmtContext>(_ctx, getState());
  enterRule(_localctx, 594, GreenPlumParser::RuleCreate_cast_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4210);
    match(GreenPlumParser::CREATE);
    setState(4211);
    match(GreenPlumParser::CAST);
    setState(4212);
    match(GreenPlumParser::LEFT_PAREN);
    setState(4213);
    typename_pg();
    setState(4214);
    match(GreenPlumParser::AS);
    setState(4215);
    typename_pg();
    setState(4216);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(4217);
    match(GreenPlumParser::WITH);
    setState(4218);
    match(GreenPlumParser::FUNCTION);
    setState(4220);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CROSS - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FULL - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::ILIKE - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128))
      | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::IS - 193))
      | (1ULL << (GreenPlumParser::ISNULL - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::JOIN - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEFT - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIKE - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::LOG_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NATURAL - 193))
      | (1ULL << (GreenPlumParser::NEW - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOTNULL - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OLD - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OUTER_P - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OVERLAPS - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::RIGHT - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMILAR - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERBOSE - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
      setState(4219);
      function_with_argtypes();
    }
    setState(4223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::AS) {
      setState(4222);
      cast_context();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cast_contextContext ------------------------------------------------------------------

GreenPlumParser::Cast_contextContext::Cast_contextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Cast_contextContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Cast_contextContext::IMPLICIT_P() {
  return getToken(GreenPlumParser::IMPLICIT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Cast_contextContext::ASSIGNMENT() {
  return getToken(GreenPlumParser::ASSIGNMENT, 0);
}


size_t GreenPlumParser::Cast_contextContext::getRuleIndex() const {
  return GreenPlumParser::RuleCast_context;
}

void GreenPlumParser::Cast_contextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCast_context(this);
}

void GreenPlumParser::Cast_contextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCast_context(this);
}


antlrcpp::Any GreenPlumParser::Cast_contextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCast_context(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cast_contextContext* GreenPlumParser::cast_context() {
  Cast_contextContext *_localctx = _tracker.createInstance<Cast_contextContext>(_ctx, getState());
  enterRule(_localctx, 596, GreenPlumParser::RuleCast_context);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4229);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4225);
      match(GreenPlumParser::AS);
      setState(4226);
      match(GreenPlumParser::IMPLICIT_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4227);
      match(GreenPlumParser::AS);
      setState(4228);
      match(GreenPlumParser::ASSIGNMENT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_cast_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_cast_stmtContext::Drop_cast_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_cast_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_cast_stmtContext::CAST() {
  return getToken(GreenPlumParser::CAST, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_cast_stmtContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

std::vector<GreenPlumParser::Typename_pgContext *> GreenPlumParser::Drop_cast_stmtContext::typename_pg() {
  return getRuleContexts<GreenPlumParser::Typename_pgContext>();
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Drop_cast_stmtContext::typename_pg(size_t i) {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(i);
}

tree::TerminalNode* GreenPlumParser::Drop_cast_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_cast_stmtContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_cast_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_cast_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_cast_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_cast_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_cast_stmt;
}

void GreenPlumParser::Drop_cast_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_cast_stmt(this);
}

void GreenPlumParser::Drop_cast_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_cast_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_cast_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_cast_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_cast_stmtContext* GreenPlumParser::drop_cast_stmt() {
  Drop_cast_stmtContext *_localctx = _tracker.createInstance<Drop_cast_stmtContext>(_ctx, getState());
  enterRule(_localctx, 598, GreenPlumParser::RuleDrop_cast_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4231);
    match(GreenPlumParser::DROP);
    setState(4232);
    match(GreenPlumParser::CAST);
    setState(4235);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::IF_P) {
      setState(4233);
      match(GreenPlumParser::IF_P);
      setState(4234);
      match(GreenPlumParser::EXISTS);
    }
    setState(4237);
    match(GreenPlumParser::LEFT_PAREN);
    setState(4238);
    typename_pg();
    setState(4239);
    match(GreenPlumParser::AS);
    setState(4240);
    typename_pg();
    setState(4241);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(4243);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(4242);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reindex_stmtContext ------------------------------------------------------------------

GreenPlumParser::Reindex_stmtContext::Reindex_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Reindex_stmtContext::REINDEX() {
  return getToken(GreenPlumParser::REINDEX, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Reindex_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Reindex_stmtContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Reindex_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Reindex_stmtContext::SYSTEM_P() {
  return getToken(GreenPlumParser::SYSTEM_P, 0);
}

tree::TerminalNode* GreenPlumParser::Reindex_stmtContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

tree::TerminalNode* GreenPlumParser::Reindex_stmtContext::FORCE() {
  return getToken(GreenPlumParser::FORCE, 0);
}


size_t GreenPlumParser::Reindex_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleReindex_stmt;
}

void GreenPlumParser::Reindex_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReindex_stmt(this);
}

void GreenPlumParser::Reindex_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReindex_stmt(this);
}


antlrcpp::Any GreenPlumParser::Reindex_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitReindex_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Reindex_stmtContext* GreenPlumParser::reindex_stmt() {
  Reindex_stmtContext *_localctx = _tracker.createInstance<Reindex_stmtContext>(_ctx, getState());
  enterRule(_localctx, 600, GreenPlumParser::RuleReindex_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4245);
    match(GreenPlumParser::REINDEX);
    setState(4246);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::DATABASE || _la == GreenPlumParser::INDEX || _la == GreenPlumParser::SYSTEM_P

    || _la == GreenPlumParser::TABLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4247);
    qualified_name();
    setState(4249);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::FORCE) {
      setState(4248);
      match(GreenPlumParser::FORCE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_type_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_type_stmtContext::Alter_type_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_type_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_type_stmtContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

GreenPlumParser::Simple_typenameContext* GreenPlumParser::Alter_type_stmtContext::simple_typename() {
  return getRuleContext<GreenPlumParser::Simple_typenameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_type_stmtContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_type_stmtContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_type_stmtContext::ENCODING() {
  return getToken(GreenPlumParser::ENCODING, 0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Alter_type_stmtContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}


size_t GreenPlumParser::Alter_type_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_type_stmt;
}

void GreenPlumParser::Alter_type_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_type_stmt(this);
}

void GreenPlumParser::Alter_type_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_type_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_type_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_type_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_type_stmtContext* GreenPlumParser::alter_type_stmt() {
  Alter_type_stmtContext *_localctx = _tracker.createInstance<Alter_type_stmtContext>(_ctx, getState());
  enterRule(_localctx, 602, GreenPlumParser::RuleAlter_type_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4251);
    match(GreenPlumParser::ALTER);
    setState(4252);
    match(GreenPlumParser::TYPE_P);
    setState(4253);
    simple_typename();
    setState(4254);
    match(GreenPlumParser::SET);
    setState(4255);
    match(GreenPlumParser::DEFAULT);
    setState(4256);
    match(GreenPlumParser::ENCODING);
    setState(4257);
    definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rename_stmtContext ------------------------------------------------------------------

GreenPlumParser::Rename_stmtContext::Rename_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Rename_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::Rename_stmtContext::aggr_args() {
  return getRuleContext<GreenPlumParser::Aggr_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::RENAME() {
  return getToken(GreenPlumParser::RENAME, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

std::vector<GreenPlumParser::NameContext *> GreenPlumParser::Rename_stmtContext::name() {
  return getRuleContexts<GreenPlumParser::NameContext>();
}

GreenPlumParser::NameContext* GreenPlumParser::Rename_stmtContext::name(size_t i) {
  return getRuleContext<GreenPlumParser::NameContext>(i);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Rename_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

std::vector<GreenPlumParser::Database_nameContext *> GreenPlumParser::Rename_stmtContext::database_name() {
  return getRuleContexts<GreenPlumParser::Database_nameContext>();
}

GreenPlumParser::Database_nameContext* GreenPlumParser::Rename_stmtContext::database_name(size_t i) {
  return getRuleContext<GreenPlumParser::Database_nameContext>(i);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::FILESPACE() {
  return getToken(GreenPlumParser::FILESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::Rename_stmtContext::function_with_argtypes() {
  return getRuleContext<GreenPlumParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

std::vector<GreenPlumParser::Role_idContext *> GreenPlumParser::Rename_stmtContext::role_id() {
  return getRuleContexts<GreenPlumParser::Role_idContext>();
}

GreenPlumParser::Role_idContext* GreenPlumParser::Rename_stmtContext::role_id(size_t i) {
  return getRuleContext<GreenPlumParser::Role_idContext>(i);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Rename_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

GreenPlumParser::Relation_exprContext* GreenPlumParser::Rename_stmtContext::relation_expr() {
  return getRuleContext<GreenPlumParser::Relation_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::VIEW() {
  return getToken(GreenPlumParser::VIEW, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

GreenPlumParser::Opt_columnContext* GreenPlumParser::Rename_stmtContext::opt_column() {
  return getRuleContext<GreenPlumParser::Opt_columnContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::PARSER() {
  return getToken(GreenPlumParser::PARSER, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}

tree::TerminalNode* GreenPlumParser::Rename_stmtContext::PROTOCOL() {
  return getToken(GreenPlumParser::PROTOCOL, 0);
}


size_t GreenPlumParser::Rename_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRename_stmt;
}

void GreenPlumParser::Rename_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRename_stmt(this);
}

void GreenPlumParser::Rename_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRename_stmt(this);
}


antlrcpp::Any GreenPlumParser::Rename_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRename_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Rename_stmtContext* GreenPlumParser::rename_stmt() {
  Rename_stmtContext *_localctx = _tracker.createInstance<Rename_stmtContext>(_ctx, getState());
  enterRule(_localctx, 604, GreenPlumParser::RuleRename_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4386);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4259);
      match(GreenPlumParser::ALTER);
      setState(4260);
      match(GreenPlumParser::AGGREGATE);
      setState(4261);
      func_name();
      setState(4262);
      aggr_args();
      setState(4263);
      match(GreenPlumParser::RENAME);
      setState(4264);
      match(GreenPlumParser::TO);
      setState(4265);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4267);
      match(GreenPlumParser::ALTER);
      setState(4268);
      match(GreenPlumParser::CONVERSION_P);
      setState(4269);
      any_name();
      setState(4270);
      match(GreenPlumParser::RENAME);
      setState(4271);
      match(GreenPlumParser::TO);
      setState(4272);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4274);
      match(GreenPlumParser::ALTER);
      setState(4275);
      match(GreenPlumParser::DATABASE);
      setState(4276);
      database_name();
      setState(4277);
      match(GreenPlumParser::RENAME);
      setState(4278);
      match(GreenPlumParser::TO);
      setState(4279);
      database_name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4281);
      match(GreenPlumParser::ALTER);
      setState(4282);
      match(GreenPlumParser::FILESPACE);
      setState(4283);
      name();
      setState(4284);
      match(GreenPlumParser::RENAME);
      setState(4285);
      match(GreenPlumParser::TO);
      setState(4286);
      name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4288);
      match(GreenPlumParser::ALTER);
      setState(4289);
      match(GreenPlumParser::FUNCTION);
      setState(4290);
      function_with_argtypes();
      setState(4291);
      match(GreenPlumParser::RENAME);
      setState(4292);
      match(GreenPlumParser::TO);
      setState(4293);
      name();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4295);
      match(GreenPlumParser::ALTER);
      setState(4296);
      match(GreenPlumParser::GROUP_P);
      setState(4297);
      role_id();
      setState(4298);
      match(GreenPlumParser::RENAME);
      setState(4299);
      match(GreenPlumParser::TO);
      setState(4300);
      role_id();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4302);
      match(GreenPlumParser::ALTER);
      setState(4304);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PROCEDURAL) {
        setState(4303);
        match(GreenPlumParser::PROCEDURAL);
      }
      setState(4306);
      match(GreenPlumParser::LANGUAGE);
      setState(4307);
      name();
      setState(4308);
      match(GreenPlumParser::RENAME);
      setState(4309);
      match(GreenPlumParser::TO);
      setState(4310);
      name();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4312);
      match(GreenPlumParser::ALTER);
      setState(4313);
      match(GreenPlumParser::OPERATOR);
      setState(4314);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CLASS || _la == GreenPlumParser::FAMILY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4315);
      any_name();
      setState(4316);
      match(GreenPlumParser::USING);
      setState(4317);
      access_method();
      setState(4318);
      match(GreenPlumParser::RENAME);
      setState(4319);
      match(GreenPlumParser::TO);
      setState(4320);
      name();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4322);
      match(GreenPlumParser::ALTER);
      setState(4323);
      match(GreenPlumParser::SCHEMA);
      setState(4324);
      name();
      setState(4325);
      match(GreenPlumParser::RENAME);
      setState(4326);
      match(GreenPlumParser::TO);
      setState(4327);
      name();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4329);
      match(GreenPlumParser::ALTER);
      setState(4330);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::INDEX || _la == GreenPlumParser::SEQUENCE

      || _la == GreenPlumParser::TABLE || _la == GreenPlumParser::VIEW)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4331);
      relation_expr();
      setState(4332);
      match(GreenPlumParser::RENAME);
      setState(4333);
      match(GreenPlumParser::TO);
      setState(4334);
      name();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4336);
      match(GreenPlumParser::ALTER);
      setState(4337);
      match(GreenPlumParser::TABLE);
      setState(4338);
      relation_expr();
      setState(4339);
      match(GreenPlumParser::RENAME);
      setState(4341);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COLUMN) {
        setState(4340);
        opt_column();
      }
      setState(4343);
      name();
      setState(4344);
      match(GreenPlumParser::TO);
      setState(4345);
      name();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4347);
      match(GreenPlumParser::ALTER);
      setState(4348);
      match(GreenPlumParser::TRIGGER);
      setState(4349);
      name();
      setState(4350);
      match(GreenPlumParser::ON);
      setState(4351);
      relation_expr();
      setState(4352);
      match(GreenPlumParser::RENAME);
      setState(4353);
      match(GreenPlumParser::TO);
      setState(4354);
      name();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(4356);
      match(GreenPlumParser::ALTER);
      setState(4357);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::ROLE || _la == GreenPlumParser::USER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4358);
      role_id();
      setState(4359);
      match(GreenPlumParser::RENAME);
      setState(4360);
      match(GreenPlumParser::TO);
      setState(4361);
      role_id();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(4363);
      match(GreenPlumParser::ALTER);
      setState(4364);
      match(GreenPlumParser::TABLESPACE);
      setState(4365);
      name();
      setState(4366);
      match(GreenPlumParser::RENAME);
      setState(4367);
      match(GreenPlumParser::TO);
      setState(4368);
      name();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(4370);
      match(GreenPlumParser::ALTER);
      setState(4371);
      match(GreenPlumParser::TEXT_P);
      setState(4372);
      match(GreenPlumParser::SEARCH);
      setState(4373);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CONFIGURATION

      || _la == GreenPlumParser::DICTIONARY || _la == GreenPlumParser::PARSER || _la == GreenPlumParser::TEMPLATE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4374);
      any_name();
      setState(4375);
      match(GreenPlumParser::RENAME);
      setState(4376);
      match(GreenPlumParser::TO);
      setState(4377);
      name();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(4379);
      match(GreenPlumParser::ALTER);
      setState(4380);
      match(GreenPlumParser::PROTOCOL);
      setState(4381);
      name();
      setState(4382);
      match(GreenPlumParser::RENAME);
      setState(4383);
      match(GreenPlumParser::TO);
      setState(4384);
      name();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_columnContext ------------------------------------------------------------------

GreenPlumParser::Opt_columnContext::Opt_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_columnContext::COLUMN() {
  return getToken(GreenPlumParser::COLUMN, 0);
}


size_t GreenPlumParser::Opt_columnContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_column;
}

void GreenPlumParser::Opt_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_column(this);
}

void GreenPlumParser::Opt_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_column(this);
}


antlrcpp::Any GreenPlumParser::Opt_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_column(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_columnContext* GreenPlumParser::opt_column() {
  Opt_columnContext *_localctx = _tracker.createInstance<Opt_columnContext>(_ctx, getState());
  enterRule(_localctx, 606, GreenPlumParser::RuleOpt_column);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4388);
    match(GreenPlumParser::COLUMN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_object_schema_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_object_schema_stmtContext::Alter_object_schema_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Alter_object_schema_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::Alter_object_schema_stmtContext::aggr_args() {
  return getRuleContext<GreenPlumParser::Aggr_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_object_schema_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_object_schema_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::EXTENSION() {
  return getToken(GreenPlumParser::EXTENSION, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::Alter_object_schema_stmtContext::function_with_argtypes() {
  return getRuleContext<GreenPlumParser::Function_with_argtypesContext>(0);
}

GreenPlumParser::Relation_exprContext* GreenPlumParser::Alter_object_schema_stmtContext::relation_expr() {
  return getRuleContext<GreenPlumParser::Relation_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_object_schema_stmtContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

GreenPlumParser::Simple_typenameContext* GreenPlumParser::Alter_object_schema_stmtContext::simple_typename() {
  return getRuleContext<GreenPlumParser::Simple_typenameContext>(0);
}


size_t GreenPlumParser::Alter_object_schema_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_object_schema_stmt;
}

void GreenPlumParser::Alter_object_schema_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_object_schema_stmt(this);
}

void GreenPlumParser::Alter_object_schema_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_object_schema_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_object_schema_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_object_schema_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_object_schema_stmtContext* GreenPlumParser::alter_object_schema_stmt() {
  Alter_object_schema_stmtContext *_localctx = _tracker.createInstance<Alter_object_schema_stmtContext>(_ctx, getState());
  enterRule(_localctx, 608, GreenPlumParser::RuleAlter_object_schema_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4426);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4390);
      match(GreenPlumParser::ALTER);
      setState(4391);
      match(GreenPlumParser::AGGREGATE);
      setState(4392);
      func_name();
      setState(4393);
      aggr_args();
      setState(4394);
      match(GreenPlumParser::SET);
      setState(4395);
      match(GreenPlumParser::SCHEMA);
      setState(4396);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4398);
      match(GreenPlumParser::ALTER);
      setState(4399);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::DOMAIN_P

      || _la == GreenPlumParser::EXTENSION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4400);
      any_name();
      setState(4401);
      match(GreenPlumParser::SET);
      setState(4402);
      match(GreenPlumParser::SCHEMA);
      setState(4403);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4405);
      match(GreenPlumParser::ALTER);
      setState(4406);
      match(GreenPlumParser::FUNCTION);
      setState(4407);
      function_with_argtypes();
      setState(4408);
      match(GreenPlumParser::SET);
      setState(4409);
      match(GreenPlumParser::SCHEMA);
      setState(4410);
      name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4412);
      match(GreenPlumParser::ALTER);
      setState(4413);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::SEQUENCE

      || _la == GreenPlumParser::TABLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4414);
      relation_expr();
      setState(4415);
      match(GreenPlumParser::SET);
      setState(4416);
      match(GreenPlumParser::SCHEMA);
      setState(4417);
      name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4419);
      match(GreenPlumParser::ALTER);
      setState(4420);
      match(GreenPlumParser::TYPE_P);
      setState(4421);
      simple_typename();
      setState(4422);
      match(GreenPlumParser::SET);
      setState(4423);
      match(GreenPlumParser::SCHEMA);
      setState(4424);
      name();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_owner_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_owner_stmtContext::Alter_owner_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Alter_owner_stmtContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Aggr_argsContext* GreenPlumParser::Alter_owner_stmtContext::aggr_args() {
  return getRuleContext<GreenPlumParser::Aggr_argsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::OWNER() {
  return getToken(GreenPlumParser::OWNER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::Role_idContext* GreenPlumParser::Alter_owner_stmtContext::role_id() {
  return getRuleContext<GreenPlumParser::Role_idContext>(0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_owner_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_owner_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::FILESPACE() {
  return getToken(GreenPlumParser::FILESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::PROTOCOL() {
  return getToken(GreenPlumParser::PROTOCOL, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

GreenPlumParser::Function_with_argtypesContext* GreenPlumParser::Alter_owner_stmtContext::function_with_argtypes() {
  return getRuleContext<GreenPlumParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Alter_owner_stmtContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

GreenPlumParser::Oper_argtypesContext* GreenPlumParser::Alter_owner_stmtContext::oper_argtypes() {
  return getRuleContext<GreenPlumParser::Oper_argtypesContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::Alter_owner_stmtContext::access_method() {
  return getRuleContext<GreenPlumParser::Access_methodContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

GreenPlumParser::Simple_typenameContext* GreenPlumParser::Alter_owner_stmtContext::simple_typename() {
  return getRuleContext<GreenPlumParser::Simple_typenameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_owner_stmtContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}


size_t GreenPlumParser::Alter_owner_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_owner_stmt;
}

void GreenPlumParser::Alter_owner_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_owner_stmt(this);
}

void GreenPlumParser::Alter_owner_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_owner_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_owner_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_owner_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_owner_stmtContext* GreenPlumParser::alter_owner_stmt() {
  Alter_owner_stmtContext *_localctx = _tracker.createInstance<Alter_owner_stmtContext>(_ctx, getState());
  enterRule(_localctx, 610, GreenPlumParser::RuleAlter_owner_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4501);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4428);
      match(GreenPlumParser::ALTER);
      setState(4429);
      match(GreenPlumParser::AGGREGATE);
      setState(4430);
      func_name();
      setState(4431);
      aggr_args();
      setState(4432);
      match(GreenPlumParser::OWNER);
      setState(4433);
      match(GreenPlumParser::TO);
      setState(4434);
      role_id();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4436);
      match(GreenPlumParser::ALTER);
      setState(4437);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CONVERSION_P

      || _la == GreenPlumParser::DOMAIN_P)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4438);
      any_name();
      setState(4439);
      match(GreenPlumParser::OWNER);
      setState(4440);
      match(GreenPlumParser::TO);
      setState(4441);
      role_id();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4443);
      match(GreenPlumParser::ALTER);
      setState(4444);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::DATABASE

      || _la == GreenPlumParser::FILESPACE || _la == GreenPlumParser::PROTOCOL

      || _la == GreenPlumParser::SCHEMA || _la == GreenPlumParser::TABLESPACE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4445);
      name();
      setState(4446);
      match(GreenPlumParser::OWNER);
      setState(4447);
      match(GreenPlumParser::TO);
      setState(4448);
      role_id();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4450);
      match(GreenPlumParser::ALTER);
      setState(4451);
      match(GreenPlumParser::FUNCTION);
      setState(4452);
      function_with_argtypes();
      setState(4453);
      match(GreenPlumParser::OWNER);
      setState(4454);
      match(GreenPlumParser::TO);
      setState(4455);
      role_id();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4457);
      match(GreenPlumParser::ALTER);
      setState(4459);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PROCEDURAL) {
        setState(4458);
        match(GreenPlumParser::PROCEDURAL);
      }
      setState(4461);
      match(GreenPlumParser::LANGUAGE);
      setState(4462);
      name();
      setState(4463);
      match(GreenPlumParser::OWNER);
      setState(4464);
      match(GreenPlumParser::TO);
      setState(4465);
      role_id();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4467);
      match(GreenPlumParser::ALTER);
      setState(4468);
      match(GreenPlumParser::OPERATOR);
      setState(4469);
      any_operator();
      setState(4470);
      oper_argtypes();
      setState(4471);
      match(GreenPlumParser::OWNER);
      setState(4472);
      match(GreenPlumParser::TO);
      setState(4473);
      role_id();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4475);
      match(GreenPlumParser::ALTER);
      setState(4476);
      match(GreenPlumParser::OPERATOR);
      setState(4477);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CLASS || _la == GreenPlumParser::FAMILY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4478);
      any_name();
      setState(4479);
      match(GreenPlumParser::USING);
      setState(4480);
      access_method();
      setState(4481);
      match(GreenPlumParser::OWNER);
      setState(4482);
      match(GreenPlumParser::TO);
      setState(4483);
      role_id();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4485);
      match(GreenPlumParser::ALTER);
      setState(4486);
      match(GreenPlumParser::TYPE_P);
      setState(4487);
      simple_typename();
      setState(4488);
      match(GreenPlumParser::OWNER);
      setState(4489);
      match(GreenPlumParser::TO);
      setState(4490);
      role_id();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4492);
      match(GreenPlumParser::ALTER);
      setState(4493);
      match(GreenPlumParser::TEXT_P);
      setState(4494);
      match(GreenPlumParser::SEARCH);
      setState(4495);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CONFIGURATION

      || _la == GreenPlumParser::DICTIONARY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4496);
      any_name();
      setState(4497);
      match(GreenPlumParser::OWNER);
      setState(4498);
      match(GreenPlumParser::TO);
      setState(4499);
      role_id();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_stmtContext ------------------------------------------------------------------

GreenPlumParser::Rule_stmtContext::Rule_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Rule_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Rule_stmtContext::RULE() {
  return getToken(GreenPlumParser::RULE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Rule_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rule_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Rule_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::EventContext* GreenPlumParser::Rule_stmtContext::event() {
  return getRuleContext<GreenPlumParser::EventContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rule_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Rule_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rule_stmtContext::DO() {
  return getToken(GreenPlumParser::DO, 0);
}

GreenPlumParser::Rule_action_listContext* GreenPlumParser::Rule_stmtContext::rule_action_list() {
  return getRuleContext<GreenPlumParser::Rule_action_listContext>(0);
}

GreenPlumParser::Opt_or_replaceContext* GreenPlumParser::Rule_stmtContext::opt_or_replace() {
  return getRuleContext<GreenPlumParser::Opt_or_replaceContext>(0);
}

GreenPlumParser::Where_clauseContext* GreenPlumParser::Rule_stmtContext::where_clause() {
  return getRuleContext<GreenPlumParser::Where_clauseContext>(0);
}

GreenPlumParser::Opt_insteadContext* GreenPlumParser::Rule_stmtContext::opt_instead() {
  return getRuleContext<GreenPlumParser::Opt_insteadContext>(0);
}


size_t GreenPlumParser::Rule_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRule_stmt;
}

void GreenPlumParser::Rule_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_stmt(this);
}

void GreenPlumParser::Rule_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_stmt(this);
}


antlrcpp::Any GreenPlumParser::Rule_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRule_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Rule_stmtContext* GreenPlumParser::rule_stmt() {
  Rule_stmtContext *_localctx = _tracker.createInstance<Rule_stmtContext>(_ctx, getState());
  enterRule(_localctx, 612, GreenPlumParser::RuleRule_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4503);
    match(GreenPlumParser::CREATE);
    setState(4505);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::OR) {
      setState(4504);
      opt_or_replace();
    }
    setState(4507);
    match(GreenPlumParser::RULE);
    setState(4508);
    name();
    setState(4509);
    match(GreenPlumParser::AS);
    setState(4510);
    match(GreenPlumParser::ON);
    setState(4511);
    event();
    setState(4512);
    match(GreenPlumParser::TO);
    setState(4513);
    qualified_name();
    setState(4515);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WHERE) {
      setState(4514);
      where_clause();
    }
    setState(4517);
    match(GreenPlumParser::DO);
    setState(4519);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ALSO || _la == GreenPlumParser::INSTEAD) {
      setState(4518);
      opt_instead();
    }
    setState(4521);
    rule_action_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_action_listContext ------------------------------------------------------------------

GreenPlumParser::Rule_action_listContext::Rule_action_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Rule_action_listContext::NOTHING() {
  return getToken(GreenPlumParser::NOTHING, 0);
}

GreenPlumParser::Rule_action_stmtContext* GreenPlumParser::Rule_action_listContext::rule_action_stmt() {
  return getRuleContext<GreenPlumParser::Rule_action_stmtContext>(0);
}

tree::TerminalNode* GreenPlumParser::Rule_action_listContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Rule_action_listContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Rule_action_multiContext* GreenPlumParser::Rule_action_listContext::rule_action_multi() {
  return getRuleContext<GreenPlumParser::Rule_action_multiContext>(0);
}


size_t GreenPlumParser::Rule_action_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleRule_action_list;
}

void GreenPlumParser::Rule_action_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_action_list(this);
}

void GreenPlumParser::Rule_action_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_action_list(this);
}


antlrcpp::Any GreenPlumParser::Rule_action_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRule_action_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Rule_action_listContext* GreenPlumParser::rule_action_list() {
  Rule_action_listContext *_localctx = _tracker.createInstance<Rule_action_listContext>(_ctx, getState());
  enterRule(_localctx, 614, GreenPlumParser::RuleRule_action_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4530);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4523);
      match(GreenPlumParser::NOTHING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4524);
      rule_action_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4525);
      match(GreenPlumParser::LEFT_PAREN);
      setState(4527);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::DELETE_P || _la == GreenPlumParser::INSERT || _la == GreenPlumParser::NOTIFY || _la == GreenPlumParser::SELECT

      || _la == GreenPlumParser::UPDATE || ((((_la - 437) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 437)) & ((1ULL << (GreenPlumParser::VALUES - 437))
        | (1ULL << (GreenPlumParser::WITH - 437))
        | (1ULL << (GreenPlumParser::LEFT_PAREN - 437)))) != 0)) {
        setState(4526);
        rule_action_multi();
      }
      setState(4529);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_action_multiContext ------------------------------------------------------------------

GreenPlumParser::Rule_action_multiContext::Rule_action_multiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Rule_action_stmtContext *> GreenPlumParser::Rule_action_multiContext::rule_action_stmt() {
  return getRuleContexts<GreenPlumParser::Rule_action_stmtContext>();
}

GreenPlumParser::Rule_action_stmtContext* GreenPlumParser::Rule_action_multiContext::rule_action_stmt(size_t i) {
  return getRuleContext<GreenPlumParser::Rule_action_stmtContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Rule_action_multiContext::SEMICOLON() {
  return getTokens(GreenPlumParser::SEMICOLON);
}

tree::TerminalNode* GreenPlumParser::Rule_action_multiContext::SEMICOLON(size_t i) {
  return getToken(GreenPlumParser::SEMICOLON, i);
}


size_t GreenPlumParser::Rule_action_multiContext::getRuleIndex() const {
  return GreenPlumParser::RuleRule_action_multi;
}

void GreenPlumParser::Rule_action_multiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_action_multi(this);
}

void GreenPlumParser::Rule_action_multiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_action_multi(this);
}


antlrcpp::Any GreenPlumParser::Rule_action_multiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRule_action_multi(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Rule_action_multiContext* GreenPlumParser::rule_action_multi() {
  Rule_action_multiContext *_localctx = _tracker.createInstance<Rule_action_multiContext>(_ctx, getState());
  enterRule(_localctx, 616, GreenPlumParser::RuleRule_action_multi);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4532);
    rule_action_stmt();
    setState(4537);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::SEMICOLON) {
      setState(4533);
      match(GreenPlumParser::SEMICOLON);
      setState(4534);
      rule_action_stmt();
      setState(4539);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rule_action_stmtContext ------------------------------------------------------------------

GreenPlumParser::Rule_action_stmtContext::Rule_action_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Rule_action_stmtContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

GreenPlumParser::Insert_stmtContext* GreenPlumParser::Rule_action_stmtContext::insert_stmt() {
  return getRuleContext<GreenPlumParser::Insert_stmtContext>(0);
}

GreenPlumParser::Update_stmtContext* GreenPlumParser::Rule_action_stmtContext::update_stmt() {
  return getRuleContext<GreenPlumParser::Update_stmtContext>(0);
}

GreenPlumParser::Delete_stmtContext* GreenPlumParser::Rule_action_stmtContext::delete_stmt() {
  return getRuleContext<GreenPlumParser::Delete_stmtContext>(0);
}

GreenPlumParser::Notify_stmtContext* GreenPlumParser::Rule_action_stmtContext::notify_stmt() {
  return getRuleContext<GreenPlumParser::Notify_stmtContext>(0);
}


size_t GreenPlumParser::Rule_action_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleRule_action_stmt;
}

void GreenPlumParser::Rule_action_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRule_action_stmt(this);
}

void GreenPlumParser::Rule_action_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRule_action_stmt(this);
}


antlrcpp::Any GreenPlumParser::Rule_action_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRule_action_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Rule_action_stmtContext* GreenPlumParser::rule_action_stmt() {
  Rule_action_stmtContext *_localctx = _tracker.createInstance<Rule_action_stmtContext>(_ctx, getState());
  enterRule(_localctx, 618, GreenPlumParser::RuleRule_action_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4545);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::SELECT:
      case GreenPlumParser::VALUES:
      case GreenPlumParser::WITH:
      case GreenPlumParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(4540);
        select_stmt();
        break;
      }

      case GreenPlumParser::INSERT: {
        enterOuterAlt(_localctx, 2);
        setState(4541);
        insert_stmt();
        break;
      }

      case GreenPlumParser::UPDATE: {
        enterOuterAlt(_localctx, 3);
        setState(4542);
        update_stmt();
        break;
      }

      case GreenPlumParser::DELETE_P: {
        enterOuterAlt(_localctx, 4);
        setState(4543);
        delete_stmt();
        break;
      }

      case GreenPlumParser::NOTIFY: {
        enterOuterAlt(_localctx, 5);
        setState(4544);
        notify_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventContext ------------------------------------------------------------------

GreenPlumParser::EventContext::EventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::EventContext::SELECT() {
  return getToken(GreenPlumParser::SELECT, 0);
}

tree::TerminalNode* GreenPlumParser::EventContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

tree::TerminalNode* GreenPlumParser::EventContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

tree::TerminalNode* GreenPlumParser::EventContext::INSERT() {
  return getToken(GreenPlumParser::INSERT, 0);
}


size_t GreenPlumParser::EventContext::getRuleIndex() const {
  return GreenPlumParser::RuleEvent;
}

void GreenPlumParser::EventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvent(this);
}

void GreenPlumParser::EventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvent(this);
}


antlrcpp::Any GreenPlumParser::EventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitEvent(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::EventContext* GreenPlumParser::event() {
  EventContext *_localctx = _tracker.createInstance<EventContext>(_ctx, getState());
  enterRule(_localctx, 620, GreenPlumParser::RuleEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4547);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::DELETE_P || _la == GreenPlumParser::INSERT || _la == GreenPlumParser::SELECT

    || _la == GreenPlumParser::UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_insteadContext ------------------------------------------------------------------

GreenPlumParser::Opt_insteadContext::Opt_insteadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_insteadContext::INSTEAD() {
  return getToken(GreenPlumParser::INSTEAD, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_insteadContext::ALSO() {
  return getToken(GreenPlumParser::ALSO, 0);
}


size_t GreenPlumParser::Opt_insteadContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_instead;
}

void GreenPlumParser::Opt_insteadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_instead(this);
}

void GreenPlumParser::Opt_insteadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_instead(this);
}


antlrcpp::Any GreenPlumParser::Opt_insteadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_instead(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_insteadContext* GreenPlumParser::opt_instead() {
  Opt_insteadContext *_localctx = _tracker.createInstance<Opt_insteadContext>(_ctx, getState());
  enterRule(_localctx, 622, GreenPlumParser::RuleOpt_instead);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4549);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::ALSO || _la == GreenPlumParser::INSTEAD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_rule_stmtContext ------------------------------------------------------------------

GreenPlumParser::Drop_rule_stmtContext::Drop_rule_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Drop_rule_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_rule_stmtContext::RULE() {
  return getToken(GreenPlumParser::RULE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Drop_rule_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_rule_stmtContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Drop_rule_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Drop_rule_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Drop_rule_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Drop_rule_stmtContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Drop_rule_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDrop_rule_stmt;
}

void GreenPlumParser::Drop_rule_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_rule_stmt(this);
}

void GreenPlumParser::Drop_rule_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_rule_stmt(this);
}


antlrcpp::Any GreenPlumParser::Drop_rule_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDrop_rule_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Drop_rule_stmtContext* GreenPlumParser::drop_rule_stmt() {
  Drop_rule_stmtContext *_localctx = _tracker.createInstance<Drop_rule_stmtContext>(_ctx, getState());
  enterRule(_localctx, 624, GreenPlumParser::RuleDrop_rule_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4551);
    match(GreenPlumParser::DROP);
    setState(4552);
    match(GreenPlumParser::RULE);
    setState(4555);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx)) {
    case 1: {
      setState(4553);
      match(GreenPlumParser::IF_P);
      setState(4554);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(4557);
    name();
    setState(4558);
    match(GreenPlumParser::ON);
    setState(4559);
    qualified_name();
    setState(4561);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
      setState(4560);
      opt_drop_behavior();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Notify_stmtContext ------------------------------------------------------------------

GreenPlumParser::Notify_stmtContext::Notify_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Notify_stmtContext::NOTIFY() {
  return getToken(GreenPlumParser::NOTIFY, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Notify_stmtContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Notify_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleNotify_stmt;
}

void GreenPlumParser::Notify_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotify_stmt(this);
}

void GreenPlumParser::Notify_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotify_stmt(this);
}


antlrcpp::Any GreenPlumParser::Notify_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitNotify_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Notify_stmtContext* GreenPlumParser::notify_stmt() {
  Notify_stmtContext *_localctx = _tracker.createInstance<Notify_stmtContext>(_ctx, getState());
  enterRule(_localctx, 626, GreenPlumParser::RuleNotify_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4563);
    match(GreenPlumParser::NOTIFY);
    setState(4564);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Listen_stmtContext ------------------------------------------------------------------

GreenPlumParser::Listen_stmtContext::Listen_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Listen_stmtContext::LISTEN() {
  return getToken(GreenPlumParser::LISTEN, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Listen_stmtContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Listen_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleListen_stmt;
}

void GreenPlumParser::Listen_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListen_stmt(this);
}

void GreenPlumParser::Listen_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListen_stmt(this);
}


antlrcpp::Any GreenPlumParser::Listen_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitListen_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Listen_stmtContext* GreenPlumParser::listen_stmt() {
  Listen_stmtContext *_localctx = _tracker.createInstance<Listen_stmtContext>(_ctx, getState());
  enterRule(_localctx, 628, GreenPlumParser::RuleListen_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4566);
    match(GreenPlumParser::LISTEN);
    setState(4567);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unlisten_stmtContext ------------------------------------------------------------------

GreenPlumParser::Unlisten_stmtContext::Unlisten_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Unlisten_stmtContext::UNLISTEN() {
  return getToken(GreenPlumParser::UNLISTEN, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Unlisten_stmtContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Unlisten_stmtContext::ASTERISK() {
  return getToken(GreenPlumParser::ASTERISK, 0);
}


size_t GreenPlumParser::Unlisten_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleUnlisten_stmt;
}

void GreenPlumParser::Unlisten_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlisten_stmt(this);
}

void GreenPlumParser::Unlisten_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlisten_stmt(this);
}


antlrcpp::Any GreenPlumParser::Unlisten_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitUnlisten_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Unlisten_stmtContext* GreenPlumParser::unlisten_stmt() {
  Unlisten_stmtContext *_localctx = _tracker.createInstance<Unlisten_stmtContext>(_ctx, getState());
  enterRule(_localctx, 630, GreenPlumParser::RuleUnlisten_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4573);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4569);
      match(GreenPlumParser::UNLISTEN);
      setState(4570);
      colid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4571);
      match(GreenPlumParser::UNLISTEN);
      setState(4572);
      match(GreenPlumParser::ASTERISK);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_stmtContext ------------------------------------------------------------------

GreenPlumParser::Transaction_stmtContext::Transaction_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::ABORT_P() {
  return getToken(GreenPlumParser::ABORT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::COMMIT() {
  return getToken(GreenPlumParser::COMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::END_P() {
  return getToken(GreenPlumParser::END_P, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::ROLLBACK() {
  return getToken(GreenPlumParser::ROLLBACK, 0);
}

GreenPlumParser::Opt_transactionContext* GreenPlumParser::Transaction_stmtContext::opt_transaction() {
  return getRuleContext<GreenPlumParser::Opt_transactionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::BEGIN_P() {
  return getToken(GreenPlumParser::BEGIN_P, 0);
}

GreenPlumParser::Transaction_mode_listContext* GreenPlumParser::Transaction_stmtContext::transaction_mode_list() {
  return getRuleContext<GreenPlumParser::Transaction_mode_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::START() {
  return getToken(GreenPlumParser::START, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::TRANSACTION() {
  return getToken(GreenPlumParser::TRANSACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::SAVEPOINT() {
  return getToken(GreenPlumParser::SAVEPOINT, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Transaction_stmtContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::RELEASE() {
  return getToken(GreenPlumParser::RELEASE, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::PREPARE() {
  return getToken(GreenPlumParser::PREPARE, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Transaction_stmtContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Transaction_stmtContext::PREPARED() {
  return getToken(GreenPlumParser::PREPARED, 0);
}


size_t GreenPlumParser::Transaction_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleTransaction_stmt;
}

void GreenPlumParser::Transaction_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_stmt(this);
}

void GreenPlumParser::Transaction_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_stmt(this);
}


antlrcpp::Any GreenPlumParser::Transaction_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Transaction_stmtContext* GreenPlumParser::transaction_stmt() {
  Transaction_stmtContext *_localctx = _tracker.createInstance<Transaction_stmtContext>(_ctx, getState());
  enterRule(_localctx, 632, GreenPlumParser::RuleTransaction_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4613);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4575);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::ABORT_P

      || _la == GreenPlumParser::COMMIT || _la == GreenPlumParser::END_P || _la == GreenPlumParser::ROLLBACK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4577);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TRANSACTION

      || _la == GreenPlumParser::WORK) {
        setState(4576);
        opt_transaction();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4579);
      match(GreenPlumParser::BEGIN_P);
      setState(4581);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TRANSACTION

      || _la == GreenPlumParser::WORK) {
        setState(4580);
        opt_transaction();
      }
      setState(4584);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ISOLATION || _la == GreenPlumParser::READ) {
        setState(4583);
        transaction_mode_list();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4586);
      match(GreenPlumParser::START);
      setState(4587);
      match(GreenPlumParser::TRANSACTION);
      setState(4589);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ISOLATION || _la == GreenPlumParser::READ) {
        setState(4588);
        transaction_mode_list();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4591);
      match(GreenPlumParser::SAVEPOINT);
      setState(4592);
      colid();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4593);
      match(GreenPlumParser::RELEASE);
      setState(4595);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx)) {
      case 1: {
        setState(4594);
        match(GreenPlumParser::SAVEPOINT);
        break;
      }

      }
      setState(4597);
      colid();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4598);
      match(GreenPlumParser::ROLLBACK);
      setState(4600);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::TRANSACTION

      || _la == GreenPlumParser::WORK) {
        setState(4599);
        opt_transaction();
      }
      setState(4602);
      match(GreenPlumParser::TO);
      setState(4604);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx)) {
      case 1: {
        setState(4603);
        match(GreenPlumParser::SAVEPOINT);
        break;
      }

      }
      setState(4606);
      colid();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4607);
      match(GreenPlumParser::PREPARE);
      setState(4608);
      match(GreenPlumParser::TRANSACTION);
      setState(4609);
      sconst();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4610);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::COMMIT || _la == GreenPlumParser::ROLLBACK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4611);
      match(GreenPlumParser::PREPARED);
      setState(4612);
      sconst();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_transactionContext ------------------------------------------------------------------

GreenPlumParser::Opt_transactionContext::Opt_transactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_transactionContext::WORK() {
  return getToken(GreenPlumParser::WORK, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_transactionContext::TRANSACTION() {
  return getToken(GreenPlumParser::TRANSACTION, 0);
}


size_t GreenPlumParser::Opt_transactionContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_transaction;
}

void GreenPlumParser::Opt_transactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_transaction(this);
}

void GreenPlumParser::Opt_transactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_transaction(this);
}


antlrcpp::Any GreenPlumParser::Opt_transactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_transaction(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_transactionContext* GreenPlumParser::opt_transaction() {
  Opt_transactionContext *_localctx = _tracker.createInstance<Opt_transactionContext>(_ctx, getState());
  enterRule(_localctx, 634, GreenPlumParser::RuleOpt_transaction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4615);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::TRANSACTION

    || _la == GreenPlumParser::WORK)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_mode_itemContext ------------------------------------------------------------------

GreenPlumParser::Transaction_mode_itemContext::Transaction_mode_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Transaction_mode_itemContext::ISOLATION() {
  return getToken(GreenPlumParser::ISOLATION, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_mode_itemContext::LEVEL() {
  return getToken(GreenPlumParser::LEVEL, 0);
}

GreenPlumParser::Iso_levelContext* GreenPlumParser::Transaction_mode_itemContext::iso_level() {
  return getRuleContext<GreenPlumParser::Iso_levelContext>(0);
}

tree::TerminalNode* GreenPlumParser::Transaction_mode_itemContext::READ() {
  return getToken(GreenPlumParser::READ, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_mode_itemContext::ONLY() {
  return getToken(GreenPlumParser::ONLY, 0);
}

tree::TerminalNode* GreenPlumParser::Transaction_mode_itemContext::WRITE() {
  return getToken(GreenPlumParser::WRITE, 0);
}


size_t GreenPlumParser::Transaction_mode_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleTransaction_mode_item;
}

void GreenPlumParser::Transaction_mode_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_mode_item(this);
}

void GreenPlumParser::Transaction_mode_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_mode_item(this);
}


antlrcpp::Any GreenPlumParser::Transaction_mode_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_mode_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Transaction_mode_itemContext* GreenPlumParser::transaction_mode_item() {
  Transaction_mode_itemContext *_localctx = _tracker.createInstance<Transaction_mode_itemContext>(_ctx, getState());
  enterRule(_localctx, 636, GreenPlumParser::RuleTransaction_mode_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4622);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ISOLATION: {
        enterOuterAlt(_localctx, 1);
        setState(4617);
        match(GreenPlumParser::ISOLATION);
        setState(4618);
        match(GreenPlumParser::LEVEL);
        setState(4619);
        iso_level();
        break;
      }

      case GreenPlumParser::READ: {
        enterOuterAlt(_localctx, 2);
        setState(4620);
        match(GreenPlumParser::READ);
        setState(4621);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::ONLY || _la == GreenPlumParser::WRITE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_mode_listContext ------------------------------------------------------------------

GreenPlumParser::Transaction_mode_listContext::Transaction_mode_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Transaction_mode_itemContext *> GreenPlumParser::Transaction_mode_listContext::transaction_mode_item() {
  return getRuleContexts<GreenPlumParser::Transaction_mode_itemContext>();
}

GreenPlumParser::Transaction_mode_itemContext* GreenPlumParser::Transaction_mode_listContext::transaction_mode_item(size_t i) {
  return getRuleContext<GreenPlumParser::Transaction_mode_itemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Transaction_mode_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Transaction_mode_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Transaction_mode_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTransaction_mode_list;
}

void GreenPlumParser::Transaction_mode_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_mode_list(this);
}

void GreenPlumParser::Transaction_mode_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_mode_list(this);
}


antlrcpp::Any GreenPlumParser::Transaction_mode_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_mode_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Transaction_mode_listContext* GreenPlumParser::transaction_mode_list() {
  Transaction_mode_listContext *_localctx = _tracker.createInstance<Transaction_mode_listContext>(_ctx, getState());
  enterRule(_localctx, 638, GreenPlumParser::RuleTransaction_mode_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(4637);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4624);
      transaction_mode_item();
      setState(4629);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(4625);
          match(GreenPlumParser::COMMA);
          setState(4626);
          transaction_mode_item(); 
        }
        setState(4631);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4633); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(4632);
        transaction_mode_item();
        setState(4635); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GreenPlumParser::ISOLATION || _la == GreenPlumParser::READ);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_stmtContext ------------------------------------------------------------------

GreenPlumParser::View_stmtContext::View_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::View_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::View_stmtContext::VIEW() {
  return getToken(GreenPlumParser::VIEW, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::View_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::View_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::View_stmtContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

tree::TerminalNode* GreenPlumParser::View_stmtContext::OR() {
  return getToken(GreenPlumParser::OR, 0);
}

tree::TerminalNode* GreenPlumParser::View_stmtContext::REPLACE() {
  return getToken(GreenPlumParser::REPLACE, 0);
}

GreenPlumParser::Opt_tempContext* GreenPlumParser::View_stmtContext::opt_temp() {
  return getRuleContext<GreenPlumParser::Opt_tempContext>(0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::View_stmtContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}

GreenPlumParser::Opt_check_optionContext* GreenPlumParser::View_stmtContext::opt_check_option() {
  return getRuleContext<GreenPlumParser::Opt_check_optionContext>(0);
}


size_t GreenPlumParser::View_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleView_stmt;
}

void GreenPlumParser::View_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_stmt(this);
}

void GreenPlumParser::View_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_stmt(this);
}


antlrcpp::Any GreenPlumParser::View_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitView_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::View_stmtContext* GreenPlumParser::view_stmt() {
  View_stmtContext *_localctx = _tracker.createInstance<View_stmtContext>(_ctx, getState());
  enterRule(_localctx, 640, GreenPlumParser::RuleView_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4639);
    match(GreenPlumParser::CREATE);
    setState(4642);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::OR) {
      setState(4640);
      match(GreenPlumParser::OR);
      setState(4641);
      match(GreenPlumParser::REPLACE);
    }
    setState(4645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::GLOBAL

    || _la == GreenPlumParser::LOCAL || _la == GreenPlumParser::TEMP

    || _la == GreenPlumParser::TEMPORARY) {
      setState(4644);
      opt_temp();
    }
    setState(4647);
    match(GreenPlumParser::VIEW);
    setState(4648);
    qualified_name();
    setState(4650);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(4649);
      paren_column_list();
    }
    setState(4652);
    match(GreenPlumParser::AS);
    setState(4653);
    select_stmt();
    setState(4655);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADED

    || _la == GreenPlumParser::CHECK || _la == GreenPlumParser::LOCAL) {
      setState(4654);
      opt_check_option();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_check_optionContext ------------------------------------------------------------------

GreenPlumParser::Opt_check_optionContext::Opt_check_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_check_optionContext::CHECK() {
  return getToken(GreenPlumParser::CHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_check_optionContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_check_optionContext::LOCAL() {
  return getToken(GreenPlumParser::LOCAL, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_check_optionContext::CASCADED() {
  return getToken(GreenPlumParser::CASCADED, 0);
}


size_t GreenPlumParser::Opt_check_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_check_option;
}

void GreenPlumParser::Opt_check_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_check_option(this);
}

void GreenPlumParser::Opt_check_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_check_option(this);
}


antlrcpp::Any GreenPlumParser::Opt_check_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_check_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_check_optionContext* GreenPlumParser::opt_check_option() {
  Opt_check_optionContext *_localctx = _tracker.createInstance<Opt_check_optionContext>(_ctx, getState());
  enterRule(_localctx, 642, GreenPlumParser::RuleOpt_check_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4658);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CASCADED || _la == GreenPlumParser::LOCAL) {
      setState(4657);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CASCADED || _la == GreenPlumParser::LOCAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(4660);
    match(GreenPlumParser::CHECK);
    setState(4661);
    match(GreenPlumParser::OPTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Load_stmtContext ------------------------------------------------------------------

GreenPlumParser::Load_stmtContext::Load_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Load_stmtContext::LOAD() {
  return getToken(GreenPlumParser::LOAD, 0);
}

GreenPlumParser::File_nameContext* GreenPlumParser::Load_stmtContext::file_name() {
  return getRuleContext<GreenPlumParser::File_nameContext>(0);
}


size_t GreenPlumParser::Load_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleLoad_stmt;
}

void GreenPlumParser::Load_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoad_stmt(this);
}

void GreenPlumParser::Load_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoad_stmt(this);
}


antlrcpp::Any GreenPlumParser::Load_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitLoad_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Load_stmtContext* GreenPlumParser::load_stmt() {
  Load_stmtContext *_localctx = _tracker.createInstance<Load_stmtContext>(_ctx, getState());
  enterRule(_localctx, 644, GreenPlumParser::RuleLoad_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4663);
    match(GreenPlumParser::LOAD);
    setState(4664);
    file_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createdb_stmtContext ------------------------------------------------------------------

GreenPlumParser::Createdb_stmtContext::Createdb_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Createdb_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Createdb_stmtContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

GreenPlumParser::Database_nameContext* GreenPlumParser::Createdb_stmtContext::database_name() {
  return getRuleContext<GreenPlumParser::Database_nameContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Createdb_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Createdb_opt_itemContext *> GreenPlumParser::Createdb_stmtContext::createdb_opt_item() {
  return getRuleContexts<GreenPlumParser::Createdb_opt_itemContext>();
}

GreenPlumParser::Createdb_opt_itemContext* GreenPlumParser::Createdb_stmtContext::createdb_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Createdb_opt_itemContext>(i);
}


size_t GreenPlumParser::Createdb_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreatedb_stmt;
}

void GreenPlumParser::Createdb_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreatedb_stmt(this);
}

void GreenPlumParser::Createdb_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreatedb_stmt(this);
}


antlrcpp::Any GreenPlumParser::Createdb_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreatedb_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Createdb_stmtContext* GreenPlumParser::createdb_stmt() {
  Createdb_stmtContext *_localctx = _tracker.createInstance<Createdb_stmtContext>(_ctx, getState());
  enterRule(_localctx, 646, GreenPlumParser::RuleCreatedb_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4666);
    match(GreenPlumParser::CREATE);
    setState(4667);
    match(GreenPlumParser::DATABASE);
    setState(4668);
    database_name();
    setState(4670);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(4669);
      opt_with();
    }
    setState(4675);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::CONNECTION

    || _la == GreenPlumParser::ENCODING || _la == GreenPlumParser::LOCATION || _la == GreenPlumParser::OWNER || _la == GreenPlumParser::TABLESPACE

    || _la == GreenPlumParser::TEMPLATE) {
      setState(4672);
      createdb_opt_item();
      setState(4677);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createdb_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Createdb_opt_itemContext::Createdb_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Createdb_opt_itemContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::LOCATION() {
  return getToken(GreenPlumParser::LOCATION, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::Createdb_opt_itemContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::ENCODING() {
  return getToken(GreenPlumParser::ENCODING, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Createdb_opt_itemContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::CONNECTION() {
  return getToken(GreenPlumParser::CONNECTION, 0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::LIMIT() {
  return getToken(GreenPlumParser::LIMIT, 0);
}

GreenPlumParser::Signed_iconstContext* GreenPlumParser::Createdb_opt_itemContext::signed_iconst() {
  return getRuleContext<GreenPlumParser::Signed_iconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Createdb_opt_itemContext::OWNER() {
  return getToken(GreenPlumParser::OWNER, 0);
}


size_t GreenPlumParser::Createdb_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreatedb_opt_item;
}

void GreenPlumParser::Createdb_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreatedb_opt_item(this);
}

void GreenPlumParser::Createdb_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreatedb_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Createdb_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreatedb_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Createdb_opt_itemContext* GreenPlumParser::createdb_opt_item() {
  Createdb_opt_itemContext *_localctx = _tracker.createInstance<Createdb_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 648, GreenPlumParser::RuleCreatedb_opt_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4725);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::TABLESPACE: {
        enterOuterAlt(_localctx, 1);
        setState(4678);
        match(GreenPlumParser::TABLESPACE);
        setState(4680);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EQUALS_OP) {
          setState(4679);
          match(GreenPlumParser::EQUALS_OP);
        }
        setState(4684);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::ABORT_P:
          case GreenPlumParser::ABSOLUTE_P:
          case GreenPlumParser::ACCESS:
          case GreenPlumParser::ACTION:
          case GreenPlumParser::ACTIVE:
          case GreenPlumParser::ADD_P:
          case GreenPlumParser::ADMIN:
          case GreenPlumParser::AFTER:
          case GreenPlumParser::AGGREGATE:
          case GreenPlumParser::ALSO:
          case GreenPlumParser::ALTER:
          case GreenPlumParser::ALWAYS:
          case GreenPlumParser::ASSERTION:
          case GreenPlumParser::ASSIGNMENT:
          case GreenPlumParser::AT:
          case GreenPlumParser::BACKWARD:
          case GreenPlumParser::BEFORE:
          case GreenPlumParser::BEGIN_P:
          case GreenPlumParser::BY:
          case GreenPlumParser::CACHE:
          case GreenPlumParser::CALLED:
          case GreenPlumParser::CASCADE:
          case GreenPlumParser::CASCADED:
          case GreenPlumParser::CHAIN:
          case GreenPlumParser::CHARACTERISTICS:
          case GreenPlumParser::CHECKPOINT:
          case GreenPlumParser::CLASS:
          case GreenPlumParser::CLOSE:
          case GreenPlumParser::CLUSTER:
          case GreenPlumParser::COMMENT:
          case GreenPlumParser::COMMIT:
          case GreenPlumParser::COMMITTED:
          case GreenPlumParser::CONCURRENCY:
          case GreenPlumParser::CONCURRENTLY:
          case GreenPlumParser::CONFIGURATION:
          case GreenPlumParser::CONNECTION:
          case GreenPlumParser::CONSTRAINTS:
          case GreenPlumParser::CONTAINS:
          case GreenPlumParser::CONTENT_P:
          case GreenPlumParser::CONTINUE_P:
          case GreenPlumParser::CONVERSION_P:
          case GreenPlumParser::COPY:
          case GreenPlumParser::COST:
          case GreenPlumParser::CPU_RATE_LIMIT:
          case GreenPlumParser::CPUSET:
          case GreenPlumParser::CREATEDB:
          case GreenPlumParser::CREATEEXTTABLE:
          case GreenPlumParser::CREATEROLE:
          case GreenPlumParser::CREATEUSER:
          case GreenPlumParser::CSV:
          case GreenPlumParser::CURRENT_P:
          case GreenPlumParser::CURSOR:
          case GreenPlumParser::CYCLE:
          case GreenPlumParser::DATABASE:
          case GreenPlumParser::DATA_P:
          case GreenPlumParser::DAY_P:
          case GreenPlumParser::DEALLOCATE:
          case GreenPlumParser::DECLARE:
          case GreenPlumParser::DEFAULTS:
          case GreenPlumParser::DEFERRED:
          case GreenPlumParser::DEFINER:
          case GreenPlumParser::DELETE_P:
          case GreenPlumParser::DELIMITER:
          case GreenPlumParser::DELIMITERS:
          case GreenPlumParser::DENY:
          case GreenPlumParser::DICTIONARY:
          case GreenPlumParser::DISABLE_P:
          case GreenPlumParser::DISCARD:
          case GreenPlumParser::DOCUMENT_P:
          case GreenPlumParser::DOMAIN_P:
          case GreenPlumParser::DOUBLE_P:
          case GreenPlumParser::DROP:
          case GreenPlumParser::DXL:
          case GreenPlumParser::EACH:
          case GreenPlumParser::ENABLE_P:
          case GreenPlumParser::ENCODING:
          case GreenPlumParser::ENCRYPTED:
          case GreenPlumParser::ENUM_P:
          case GreenPlumParser::ERRORS:
          case GreenPlumParser::ESCAPE:
          case GreenPlumParser::EVERY:
          case GreenPlumParser::EXCHANGE:
          case GreenPlumParser::EXCLUDING:
          case GreenPlumParser::EXCLUSIVE:
          case GreenPlumParser::EXECUTE:
          case GreenPlumParser::EXPLAIN:
          case GreenPlumParser::EXTENSION:
          case GreenPlumParser::EXTERNAL:
          case GreenPlumParser::FAMILY:
          case GreenPlumParser::FIELDS:
          case GreenPlumParser::FILESPACE:
          case GreenPlumParser::FILL:
          case GreenPlumParser::FIRST_P:
          case GreenPlumParser::FORCE:
          case GreenPlumParser::FORMAT:
          case GreenPlumParser::FORWARD:
          case GreenPlumParser::FUNCTION:
          case GreenPlumParser::GLOBAL:
          case GreenPlumParser::GRANTED:
          case GreenPlumParser::HANDLER:
          case GreenPlumParser::HASH:
          case GreenPlumParser::HEADER_P:
          case GreenPlumParser::HOLD:
          case GreenPlumParser::HOST:
          case GreenPlumParser::HOUR_P:
          case GreenPlumParser::IDENTITY_P:
          case GreenPlumParser::IF_P:
          case GreenPlumParser::IGNORE_P:
          case GreenPlumParser::IMMEDIATE:
          case GreenPlumParser::IMMUTABLE:
          case GreenPlumParser::IMPLICIT_P:
          case GreenPlumParser::INCLUDING:
          case GreenPlumParser::INCLUSIVE:
          case GreenPlumParser::INCREMENT:
          case GreenPlumParser::INDEX:
          case GreenPlumParser::INDEXES:
          case GreenPlumParser::INHERIT:
          case GreenPlumParser::INHERITS:
          case GreenPlumParser::INLINE_P:
          case GreenPlumParser::INPUT_P:
          case GreenPlumParser::INSENSITIVE:
          case GreenPlumParser::INSERT:
          case GreenPlumParser::INSTEAD:
          case GreenPlumParser::INVOKER:
          case GreenPlumParser::ISOLATION:
          case GreenPlumParser::KEY:
          case GreenPlumParser::LANGUAGE:
          case GreenPlumParser::LARGE_P:
          case GreenPlumParser::LAST_P:
          case GreenPlumParser::LEVEL:
          case GreenPlumParser::LIST:
          case GreenPlumParser::LISTEN:
          case GreenPlumParser::LOAD:
          case GreenPlumParser::LOCAL:
          case GreenPlumParser::LOCATION:
          case GreenPlumParser::LOCK_P:
          case GreenPlumParser::LOGIN_P:
          case GreenPlumParser::MAPPING:
          case GreenPlumParser::MASTER:
          case GreenPlumParser::MATCH:
          case GreenPlumParser::MAXVALUE:
          case GreenPlumParser::MEMORY_LIMIT:
          case GreenPlumParser::MEMORY_SHARED_QUOTA:
          case GreenPlumParser::MEMORY_SPILL_RATIO:
          case GreenPlumParser::MERGE:
          case GreenPlumParser::MINUTE_P:
          case GreenPlumParser::MINVALUE:
          case GreenPlumParser::MISSING:
          case GreenPlumParser::MODE:
          case GreenPlumParser::MODIFIES:
          case GreenPlumParser::MODIFY:
          case GreenPlumParser::MONTH_P:
          case GreenPlumParser::MOVE:
          case GreenPlumParser::NAME_P:
          case GreenPlumParser::NAMES:
          case GreenPlumParser::NEXT:
          case GreenPlumParser::NO:
          case GreenPlumParser::NOCREATEDB:
          case GreenPlumParser::NOCREATEEXTTABLE:
          case GreenPlumParser::NOCREATEROLE:
          case GreenPlumParser::NOCREATEUSER:
          case GreenPlumParser::NOINHERIT:
          case GreenPlumParser::NOLOGIN_P:
          case GreenPlumParser::NOOVERCOMMIT:
          case GreenPlumParser::NOSUPERUSER:
          case GreenPlumParser::NOTHING:
          case GreenPlumParser::NOTIFY:
          case GreenPlumParser::NOWAIT:
          case GreenPlumParser::NULLS_P:
          case GreenPlumParser::OBJECT_P:
          case GreenPlumParser::OF:
          case GreenPlumParser::OIDS:
          case GreenPlumParser::OPERATOR:
          case GreenPlumParser::OPTION:
          case GreenPlumParser::OPTIONS:
          case GreenPlumParser::ORDERED:
          case GreenPlumParser::OTHERS:
          case GreenPlumParser::OVER:
          case GreenPlumParser::OVERCOMMIT:
          case GreenPlumParser::OWNED:
          case GreenPlumParser::OWNER:
          case GreenPlumParser::PARSER:
          case GreenPlumParser::PARTIAL:
          case GreenPlumParser::PARTITIONS:
          case GreenPlumParser::PASSING:
          case GreenPlumParser::PASSWORD:
          case GreenPlumParser::PERCENT:
          case GreenPlumParser::PLANS:
          case GreenPlumParser::PREPARE:
          case GreenPlumParser::PREPARED:
          case GreenPlumParser::PRESERVE:
          case GreenPlumParser::PRIOR:
          case GreenPlumParser::PRIVILEGES:
          case GreenPlumParser::PROCEDURAL:
          case GreenPlumParser::PROCEDURE:
          case GreenPlumParser::PROGRAM:
          case GreenPlumParser::PROTOCOL:
          case GreenPlumParser::PUBLIC:
          case GreenPlumParser::QUEUE:
          case GreenPlumParser::QUOTE:
          case GreenPlumParser::RANDOMLY:
          case GreenPlumParser::READ:
          case GreenPlumParser::READABLE:
          case GreenPlumParser::READS:
          case GreenPlumParser::REASSIGN:
          case GreenPlumParser::RECHECK:
          case GreenPlumParser::RECURSIVE:
          case GreenPlumParser::REF:
          case GreenPlumParser::REINDEX:
          case GreenPlumParser::REJECT_P:
          case GreenPlumParser::RELATIVE_P:
          case GreenPlumParser::RELEASE:
          case GreenPlumParser::RENAME:
          case GreenPlumParser::REPEATABLE:
          case GreenPlumParser::REPLACE:
          case GreenPlumParser::REPLICA:
          case GreenPlumParser::RESET:
          case GreenPlumParser::RESOURCE:
          case GreenPlumParser::RESTART:
          case GreenPlumParser::RESTRICT:
          case GreenPlumParser::RETURNS:
          case GreenPlumParser::REVOKE:
          case GreenPlumParser::ROLE:
          case GreenPlumParser::ROLLBACK:
          case GreenPlumParser::ROOTPARTITION:
          case GreenPlumParser::RULE:
          case GreenPlumParser::SAVEPOINT:
          case GreenPlumParser::SCHEMA:
          case GreenPlumParser::SCROLL:
          case GreenPlumParser::SEARCH:
          case GreenPlumParser::SECOND_P:
          case GreenPlumParser::SECURITY:
          case GreenPlumParser::SEGMENT:
          case GreenPlumParser::SEQUENCE:
          case GreenPlumParser::SERIALIZABLE:
          case GreenPlumParser::SESSION:
          case GreenPlumParser::SET:
          case GreenPlumParser::SHARE:
          case GreenPlumParser::SHOW:
          case GreenPlumParser::SIMPLE:
          case GreenPlumParser::SPLIT:
          case GreenPlumParser::SQL:
          case GreenPlumParser::STABLE:
          case GreenPlumParser::STANDALONE_P:
          case GreenPlumParser::START:
          case GreenPlumParser::STATEMENT:
          case GreenPlumParser::STATISTICS:
          case GreenPlumParser::STDIN:
          case GreenPlumParser::STDOUT:
          case GreenPlumParser::STORAGE:
          case GreenPlumParser::STRICT_P:
          case GreenPlumParser::STRIP_P:
          case GreenPlumParser::SUBPARTITION:
          case GreenPlumParser::SUBPARTITIONS:
          case GreenPlumParser::SUPERUSER_P:
          case GreenPlumParser::SYSID:
          case GreenPlumParser::SYSTEM_P:
          case GreenPlumParser::TABLESPACE:
          case GreenPlumParser::TEMP:
          case GreenPlumParser::TEMPLATE:
          case GreenPlumParser::TEMPORARY:
          case GreenPlumParser::TEXT_P:
          case GreenPlumParser::THRESHOLD:
          case GreenPlumParser::TIES:
          case GreenPlumParser::TRANSACTION:
          case GreenPlumParser::TRIGGER:
          case GreenPlumParser::TRUNCATE:
          case GreenPlumParser::TRUSTED:
          case GreenPlumParser::TYPE_P:
          case GreenPlumParser::UNCOMMITTED:
          case GreenPlumParser::UNENCRYPTED:
          case GreenPlumParser::UNKNOWN:
          case GreenPlumParser::UNLISTEN:
          case GreenPlumParser::UNTIL:
          case GreenPlumParser::UPDATE:
          case GreenPlumParser::VACUUM:
          case GreenPlumParser::VALID:
          case GreenPlumParser::VALIDATION:
          case GreenPlumParser::VALIDATOR:
          case GreenPlumParser::VALUE_P:
          case GreenPlumParser::VARYING:
          case GreenPlumParser::VERSION_P:
          case GreenPlumParser::VIEW:
          case GreenPlumParser::VOLATILE:
          case GreenPlumParser::WEB:
          case GreenPlumParser::WHITESPACE_P:
          case GreenPlumParser::WITHIN:
          case GreenPlumParser::WITHOUT:
          case GreenPlumParser::WORK:
          case GreenPlumParser::WRITABLE:
          case GreenPlumParser::WRITE:
          case GreenPlumParser::XML_P:
          case GreenPlumParser::YEAR_P:
          case GreenPlumParser::YES_P:
          case GreenPlumParser::ZONE:
          case GreenPlumParser::COLON:
          case GreenPlumParser::CHAR_STRING:
          case GreenPlumParser::REGULAR_ID:
          case GreenPlumParser::SCONST: {
            setState(4682);
            name();
            break;
          }

          case GreenPlumParser::DEFAULT: {
            setState(4683);
            match(GreenPlumParser::DEFAULT);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case GreenPlumParser::LOCATION: {
        enterOuterAlt(_localctx, 2);
        setState(4686);
        match(GreenPlumParser::LOCATION);
        setState(4688);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EQUALS_OP) {
          setState(4687);
          match(GreenPlumParser::EQUALS_OP);
        }
        setState(4692);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::CHAR_STRING:
          case GreenPlumParser::DELIMITED_STR:
          case GreenPlumParser::SCONST: {
            setState(4690);
            sconst();
            break;
          }

          case GreenPlumParser::DEFAULT: {
            setState(4691);
            match(GreenPlumParser::DEFAULT);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case GreenPlumParser::TEMPLATE: {
        enterOuterAlt(_localctx, 3);
        setState(4694);
        match(GreenPlumParser::TEMPLATE);
        setState(4696);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EQUALS_OP) {
          setState(4695);
          match(GreenPlumParser::EQUALS_OP);
        }
        setState(4700);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::ABORT_P:
          case GreenPlumParser::ABSOLUTE_P:
          case GreenPlumParser::ACCESS:
          case GreenPlumParser::ACTION:
          case GreenPlumParser::ACTIVE:
          case GreenPlumParser::ADD_P:
          case GreenPlumParser::ADMIN:
          case GreenPlumParser::AFTER:
          case GreenPlumParser::AGGREGATE:
          case GreenPlumParser::ALSO:
          case GreenPlumParser::ALTER:
          case GreenPlumParser::ALWAYS:
          case GreenPlumParser::ASSERTION:
          case GreenPlumParser::ASSIGNMENT:
          case GreenPlumParser::AT:
          case GreenPlumParser::BACKWARD:
          case GreenPlumParser::BEFORE:
          case GreenPlumParser::BEGIN_P:
          case GreenPlumParser::BY:
          case GreenPlumParser::CACHE:
          case GreenPlumParser::CALLED:
          case GreenPlumParser::CASCADE:
          case GreenPlumParser::CASCADED:
          case GreenPlumParser::CHAIN:
          case GreenPlumParser::CHARACTERISTICS:
          case GreenPlumParser::CHECKPOINT:
          case GreenPlumParser::CLASS:
          case GreenPlumParser::CLOSE:
          case GreenPlumParser::CLUSTER:
          case GreenPlumParser::COMMENT:
          case GreenPlumParser::COMMIT:
          case GreenPlumParser::COMMITTED:
          case GreenPlumParser::CONCURRENCY:
          case GreenPlumParser::CONCURRENTLY:
          case GreenPlumParser::CONFIGURATION:
          case GreenPlumParser::CONNECTION:
          case GreenPlumParser::CONSTRAINTS:
          case GreenPlumParser::CONTAINS:
          case GreenPlumParser::CONTENT_P:
          case GreenPlumParser::CONTINUE_P:
          case GreenPlumParser::CONVERSION_P:
          case GreenPlumParser::COPY:
          case GreenPlumParser::COST:
          case GreenPlumParser::CPU_RATE_LIMIT:
          case GreenPlumParser::CPUSET:
          case GreenPlumParser::CREATEDB:
          case GreenPlumParser::CREATEEXTTABLE:
          case GreenPlumParser::CREATEROLE:
          case GreenPlumParser::CREATEUSER:
          case GreenPlumParser::CSV:
          case GreenPlumParser::CURRENT_P:
          case GreenPlumParser::CURSOR:
          case GreenPlumParser::CYCLE:
          case GreenPlumParser::DATABASE:
          case GreenPlumParser::DATA_P:
          case GreenPlumParser::DAY_P:
          case GreenPlumParser::DEALLOCATE:
          case GreenPlumParser::DECLARE:
          case GreenPlumParser::DEFAULTS:
          case GreenPlumParser::DEFERRED:
          case GreenPlumParser::DEFINER:
          case GreenPlumParser::DELETE_P:
          case GreenPlumParser::DELIMITER:
          case GreenPlumParser::DELIMITERS:
          case GreenPlumParser::DENY:
          case GreenPlumParser::DICTIONARY:
          case GreenPlumParser::DISABLE_P:
          case GreenPlumParser::DISCARD:
          case GreenPlumParser::DOCUMENT_P:
          case GreenPlumParser::DOMAIN_P:
          case GreenPlumParser::DOUBLE_P:
          case GreenPlumParser::DROP:
          case GreenPlumParser::DXL:
          case GreenPlumParser::EACH:
          case GreenPlumParser::ENABLE_P:
          case GreenPlumParser::ENCODING:
          case GreenPlumParser::ENCRYPTED:
          case GreenPlumParser::ENUM_P:
          case GreenPlumParser::ERRORS:
          case GreenPlumParser::ESCAPE:
          case GreenPlumParser::EVERY:
          case GreenPlumParser::EXCHANGE:
          case GreenPlumParser::EXCLUDING:
          case GreenPlumParser::EXCLUSIVE:
          case GreenPlumParser::EXECUTE:
          case GreenPlumParser::EXPLAIN:
          case GreenPlumParser::EXTENSION:
          case GreenPlumParser::EXTERNAL:
          case GreenPlumParser::FAMILY:
          case GreenPlumParser::FIELDS:
          case GreenPlumParser::FILESPACE:
          case GreenPlumParser::FILL:
          case GreenPlumParser::FIRST_P:
          case GreenPlumParser::FORCE:
          case GreenPlumParser::FORMAT:
          case GreenPlumParser::FORWARD:
          case GreenPlumParser::FUNCTION:
          case GreenPlumParser::GLOBAL:
          case GreenPlumParser::GRANTED:
          case GreenPlumParser::HANDLER:
          case GreenPlumParser::HASH:
          case GreenPlumParser::HEADER_P:
          case GreenPlumParser::HOLD:
          case GreenPlumParser::HOST:
          case GreenPlumParser::HOUR_P:
          case GreenPlumParser::IDENTITY_P:
          case GreenPlumParser::IF_P:
          case GreenPlumParser::IGNORE_P:
          case GreenPlumParser::IMMEDIATE:
          case GreenPlumParser::IMMUTABLE:
          case GreenPlumParser::IMPLICIT_P:
          case GreenPlumParser::INCLUDING:
          case GreenPlumParser::INCLUSIVE:
          case GreenPlumParser::INCREMENT:
          case GreenPlumParser::INDEX:
          case GreenPlumParser::INDEXES:
          case GreenPlumParser::INHERIT:
          case GreenPlumParser::INHERITS:
          case GreenPlumParser::INLINE_P:
          case GreenPlumParser::INPUT_P:
          case GreenPlumParser::INSENSITIVE:
          case GreenPlumParser::INSERT:
          case GreenPlumParser::INSTEAD:
          case GreenPlumParser::INVOKER:
          case GreenPlumParser::ISOLATION:
          case GreenPlumParser::KEY:
          case GreenPlumParser::LANGUAGE:
          case GreenPlumParser::LARGE_P:
          case GreenPlumParser::LAST_P:
          case GreenPlumParser::LEVEL:
          case GreenPlumParser::LIST:
          case GreenPlumParser::LISTEN:
          case GreenPlumParser::LOAD:
          case GreenPlumParser::LOCAL:
          case GreenPlumParser::LOCATION:
          case GreenPlumParser::LOCK_P:
          case GreenPlumParser::LOGIN_P:
          case GreenPlumParser::MAPPING:
          case GreenPlumParser::MASTER:
          case GreenPlumParser::MATCH:
          case GreenPlumParser::MAXVALUE:
          case GreenPlumParser::MEMORY_LIMIT:
          case GreenPlumParser::MEMORY_SHARED_QUOTA:
          case GreenPlumParser::MEMORY_SPILL_RATIO:
          case GreenPlumParser::MERGE:
          case GreenPlumParser::MINUTE_P:
          case GreenPlumParser::MINVALUE:
          case GreenPlumParser::MISSING:
          case GreenPlumParser::MODE:
          case GreenPlumParser::MODIFIES:
          case GreenPlumParser::MODIFY:
          case GreenPlumParser::MONTH_P:
          case GreenPlumParser::MOVE:
          case GreenPlumParser::NAME_P:
          case GreenPlumParser::NAMES:
          case GreenPlumParser::NEXT:
          case GreenPlumParser::NO:
          case GreenPlumParser::NOCREATEDB:
          case GreenPlumParser::NOCREATEEXTTABLE:
          case GreenPlumParser::NOCREATEROLE:
          case GreenPlumParser::NOCREATEUSER:
          case GreenPlumParser::NOINHERIT:
          case GreenPlumParser::NOLOGIN_P:
          case GreenPlumParser::NOOVERCOMMIT:
          case GreenPlumParser::NOSUPERUSER:
          case GreenPlumParser::NOTHING:
          case GreenPlumParser::NOTIFY:
          case GreenPlumParser::NOWAIT:
          case GreenPlumParser::NULLS_P:
          case GreenPlumParser::OBJECT_P:
          case GreenPlumParser::OF:
          case GreenPlumParser::OIDS:
          case GreenPlumParser::OPERATOR:
          case GreenPlumParser::OPTION:
          case GreenPlumParser::OPTIONS:
          case GreenPlumParser::ORDERED:
          case GreenPlumParser::OTHERS:
          case GreenPlumParser::OVER:
          case GreenPlumParser::OVERCOMMIT:
          case GreenPlumParser::OWNED:
          case GreenPlumParser::OWNER:
          case GreenPlumParser::PARSER:
          case GreenPlumParser::PARTIAL:
          case GreenPlumParser::PARTITIONS:
          case GreenPlumParser::PASSING:
          case GreenPlumParser::PASSWORD:
          case GreenPlumParser::PERCENT:
          case GreenPlumParser::PLANS:
          case GreenPlumParser::PREPARE:
          case GreenPlumParser::PREPARED:
          case GreenPlumParser::PRESERVE:
          case GreenPlumParser::PRIOR:
          case GreenPlumParser::PRIVILEGES:
          case GreenPlumParser::PROCEDURAL:
          case GreenPlumParser::PROCEDURE:
          case GreenPlumParser::PROGRAM:
          case GreenPlumParser::PROTOCOL:
          case GreenPlumParser::PUBLIC:
          case GreenPlumParser::QUEUE:
          case GreenPlumParser::QUOTE:
          case GreenPlumParser::RANDOMLY:
          case GreenPlumParser::READ:
          case GreenPlumParser::READABLE:
          case GreenPlumParser::READS:
          case GreenPlumParser::REASSIGN:
          case GreenPlumParser::RECHECK:
          case GreenPlumParser::RECURSIVE:
          case GreenPlumParser::REF:
          case GreenPlumParser::REINDEX:
          case GreenPlumParser::REJECT_P:
          case GreenPlumParser::RELATIVE_P:
          case GreenPlumParser::RELEASE:
          case GreenPlumParser::RENAME:
          case GreenPlumParser::REPEATABLE:
          case GreenPlumParser::REPLACE:
          case GreenPlumParser::REPLICA:
          case GreenPlumParser::RESET:
          case GreenPlumParser::RESOURCE:
          case GreenPlumParser::RESTART:
          case GreenPlumParser::RESTRICT:
          case GreenPlumParser::RETURNS:
          case GreenPlumParser::REVOKE:
          case GreenPlumParser::ROLE:
          case GreenPlumParser::ROLLBACK:
          case GreenPlumParser::ROOTPARTITION:
          case GreenPlumParser::RULE:
          case GreenPlumParser::SAVEPOINT:
          case GreenPlumParser::SCHEMA:
          case GreenPlumParser::SCROLL:
          case GreenPlumParser::SEARCH:
          case GreenPlumParser::SECOND_P:
          case GreenPlumParser::SECURITY:
          case GreenPlumParser::SEGMENT:
          case GreenPlumParser::SEQUENCE:
          case GreenPlumParser::SERIALIZABLE:
          case GreenPlumParser::SESSION:
          case GreenPlumParser::SET:
          case GreenPlumParser::SHARE:
          case GreenPlumParser::SHOW:
          case GreenPlumParser::SIMPLE:
          case GreenPlumParser::SPLIT:
          case GreenPlumParser::SQL:
          case GreenPlumParser::STABLE:
          case GreenPlumParser::STANDALONE_P:
          case GreenPlumParser::START:
          case GreenPlumParser::STATEMENT:
          case GreenPlumParser::STATISTICS:
          case GreenPlumParser::STDIN:
          case GreenPlumParser::STDOUT:
          case GreenPlumParser::STORAGE:
          case GreenPlumParser::STRICT_P:
          case GreenPlumParser::STRIP_P:
          case GreenPlumParser::SUBPARTITION:
          case GreenPlumParser::SUBPARTITIONS:
          case GreenPlumParser::SUPERUSER_P:
          case GreenPlumParser::SYSID:
          case GreenPlumParser::SYSTEM_P:
          case GreenPlumParser::TABLESPACE:
          case GreenPlumParser::TEMP:
          case GreenPlumParser::TEMPLATE:
          case GreenPlumParser::TEMPORARY:
          case GreenPlumParser::TEXT_P:
          case GreenPlumParser::THRESHOLD:
          case GreenPlumParser::TIES:
          case GreenPlumParser::TRANSACTION:
          case GreenPlumParser::TRIGGER:
          case GreenPlumParser::TRUNCATE:
          case GreenPlumParser::TRUSTED:
          case GreenPlumParser::TYPE_P:
          case GreenPlumParser::UNCOMMITTED:
          case GreenPlumParser::UNENCRYPTED:
          case GreenPlumParser::UNKNOWN:
          case GreenPlumParser::UNLISTEN:
          case GreenPlumParser::UNTIL:
          case GreenPlumParser::UPDATE:
          case GreenPlumParser::VACUUM:
          case GreenPlumParser::VALID:
          case GreenPlumParser::VALIDATION:
          case GreenPlumParser::VALIDATOR:
          case GreenPlumParser::VALUE_P:
          case GreenPlumParser::VARYING:
          case GreenPlumParser::VERSION_P:
          case GreenPlumParser::VIEW:
          case GreenPlumParser::VOLATILE:
          case GreenPlumParser::WEB:
          case GreenPlumParser::WHITESPACE_P:
          case GreenPlumParser::WITHIN:
          case GreenPlumParser::WITHOUT:
          case GreenPlumParser::WORK:
          case GreenPlumParser::WRITABLE:
          case GreenPlumParser::WRITE:
          case GreenPlumParser::XML_P:
          case GreenPlumParser::YEAR_P:
          case GreenPlumParser::YES_P:
          case GreenPlumParser::ZONE:
          case GreenPlumParser::COLON:
          case GreenPlumParser::CHAR_STRING:
          case GreenPlumParser::REGULAR_ID:
          case GreenPlumParser::SCONST: {
            setState(4698);
            name();
            break;
          }

          case GreenPlumParser::DEFAULT: {
            setState(4699);
            match(GreenPlumParser::DEFAULT);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case GreenPlumParser::ENCODING: {
        enterOuterAlt(_localctx, 4);
        setState(4702);
        match(GreenPlumParser::ENCODING);
        setState(4704);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EQUALS_OP) {
          setState(4703);
          match(GreenPlumParser::EQUALS_OP);
        }
        setState(4709);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::CHAR_STRING:
          case GreenPlumParser::DELIMITED_STR:
          case GreenPlumParser::SCONST: {
            setState(4706);
            sconst();
            break;
          }

          case GreenPlumParser::ICONST: {
            setState(4707);
            iconst();
            break;
          }

          case GreenPlumParser::DEFAULT: {
            setState(4708);
            match(GreenPlumParser::DEFAULT);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case GreenPlumParser::CONNECTION: {
        enterOuterAlt(_localctx, 5);
        setState(4711);
        match(GreenPlumParser::CONNECTION);
        setState(4712);
        match(GreenPlumParser::LIMIT);
        setState(4714);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EQUALS_OP) {
          setState(4713);
          match(GreenPlumParser::EQUALS_OP);
        }
        setState(4716);
        signed_iconst();
        break;
      }

      case GreenPlumParser::OWNER: {
        enterOuterAlt(_localctx, 6);
        setState(4717);
        match(GreenPlumParser::OWNER);
        setState(4719);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EQUALS_OP) {
          setState(4718);
          match(GreenPlumParser::EQUALS_OP);
        }
        setState(4723);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::ABORT_P:
          case GreenPlumParser::ABSOLUTE_P:
          case GreenPlumParser::ACCESS:
          case GreenPlumParser::ACTION:
          case GreenPlumParser::ACTIVE:
          case GreenPlumParser::ADD_P:
          case GreenPlumParser::ADMIN:
          case GreenPlumParser::AFTER:
          case GreenPlumParser::AGGREGATE:
          case GreenPlumParser::ALSO:
          case GreenPlumParser::ALTER:
          case GreenPlumParser::ALWAYS:
          case GreenPlumParser::ASSERTION:
          case GreenPlumParser::ASSIGNMENT:
          case GreenPlumParser::AT:
          case GreenPlumParser::BACKWARD:
          case GreenPlumParser::BEFORE:
          case GreenPlumParser::BEGIN_P:
          case GreenPlumParser::BY:
          case GreenPlumParser::CACHE:
          case GreenPlumParser::CALLED:
          case GreenPlumParser::CASCADE:
          case GreenPlumParser::CASCADED:
          case GreenPlumParser::CHAIN:
          case GreenPlumParser::CHARACTERISTICS:
          case GreenPlumParser::CHECKPOINT:
          case GreenPlumParser::CLASS:
          case GreenPlumParser::CLOSE:
          case GreenPlumParser::CLUSTER:
          case GreenPlumParser::COMMENT:
          case GreenPlumParser::COMMIT:
          case GreenPlumParser::COMMITTED:
          case GreenPlumParser::CONCURRENCY:
          case GreenPlumParser::CONCURRENTLY:
          case GreenPlumParser::CONFIGURATION:
          case GreenPlumParser::CONNECTION:
          case GreenPlumParser::CONSTRAINTS:
          case GreenPlumParser::CONTAINS:
          case GreenPlumParser::CONTENT_P:
          case GreenPlumParser::CONTINUE_P:
          case GreenPlumParser::CONVERSION_P:
          case GreenPlumParser::COPY:
          case GreenPlumParser::COST:
          case GreenPlumParser::CPU_RATE_LIMIT:
          case GreenPlumParser::CPUSET:
          case GreenPlumParser::CREATEDB:
          case GreenPlumParser::CREATEEXTTABLE:
          case GreenPlumParser::CREATEROLE:
          case GreenPlumParser::CREATEUSER:
          case GreenPlumParser::CSV:
          case GreenPlumParser::CURRENT_P:
          case GreenPlumParser::CURSOR:
          case GreenPlumParser::CYCLE:
          case GreenPlumParser::DATABASE:
          case GreenPlumParser::DATA_P:
          case GreenPlumParser::DAY_P:
          case GreenPlumParser::DEALLOCATE:
          case GreenPlumParser::DECLARE:
          case GreenPlumParser::DEFAULTS:
          case GreenPlumParser::DEFERRED:
          case GreenPlumParser::DEFINER:
          case GreenPlumParser::DELETE_P:
          case GreenPlumParser::DELIMITER:
          case GreenPlumParser::DELIMITERS:
          case GreenPlumParser::DENY:
          case GreenPlumParser::DICTIONARY:
          case GreenPlumParser::DISABLE_P:
          case GreenPlumParser::DISCARD:
          case GreenPlumParser::DOCUMENT_P:
          case GreenPlumParser::DOMAIN_P:
          case GreenPlumParser::DOUBLE_P:
          case GreenPlumParser::DROP:
          case GreenPlumParser::DXL:
          case GreenPlumParser::EACH:
          case GreenPlumParser::ENABLE_P:
          case GreenPlumParser::ENCODING:
          case GreenPlumParser::ENCRYPTED:
          case GreenPlumParser::ENUM_P:
          case GreenPlumParser::ERRORS:
          case GreenPlumParser::ESCAPE:
          case GreenPlumParser::EVERY:
          case GreenPlumParser::EXCHANGE:
          case GreenPlumParser::EXCLUDING:
          case GreenPlumParser::EXCLUSIVE:
          case GreenPlumParser::EXECUTE:
          case GreenPlumParser::EXPLAIN:
          case GreenPlumParser::EXTENSION:
          case GreenPlumParser::EXTERNAL:
          case GreenPlumParser::FAMILY:
          case GreenPlumParser::FIELDS:
          case GreenPlumParser::FILESPACE:
          case GreenPlumParser::FILL:
          case GreenPlumParser::FIRST_P:
          case GreenPlumParser::FORCE:
          case GreenPlumParser::FORMAT:
          case GreenPlumParser::FORWARD:
          case GreenPlumParser::FUNCTION:
          case GreenPlumParser::GLOBAL:
          case GreenPlumParser::GRANTED:
          case GreenPlumParser::HANDLER:
          case GreenPlumParser::HASH:
          case GreenPlumParser::HEADER_P:
          case GreenPlumParser::HOLD:
          case GreenPlumParser::HOST:
          case GreenPlumParser::HOUR_P:
          case GreenPlumParser::IDENTITY_P:
          case GreenPlumParser::IF_P:
          case GreenPlumParser::IGNORE_P:
          case GreenPlumParser::IMMEDIATE:
          case GreenPlumParser::IMMUTABLE:
          case GreenPlumParser::IMPLICIT_P:
          case GreenPlumParser::INCLUDING:
          case GreenPlumParser::INCLUSIVE:
          case GreenPlumParser::INCREMENT:
          case GreenPlumParser::INDEX:
          case GreenPlumParser::INDEXES:
          case GreenPlumParser::INHERIT:
          case GreenPlumParser::INHERITS:
          case GreenPlumParser::INLINE_P:
          case GreenPlumParser::INPUT_P:
          case GreenPlumParser::INSENSITIVE:
          case GreenPlumParser::INSERT:
          case GreenPlumParser::INSTEAD:
          case GreenPlumParser::INVOKER:
          case GreenPlumParser::ISOLATION:
          case GreenPlumParser::KEY:
          case GreenPlumParser::LANGUAGE:
          case GreenPlumParser::LARGE_P:
          case GreenPlumParser::LAST_P:
          case GreenPlumParser::LEVEL:
          case GreenPlumParser::LIST:
          case GreenPlumParser::LISTEN:
          case GreenPlumParser::LOAD:
          case GreenPlumParser::LOCAL:
          case GreenPlumParser::LOCATION:
          case GreenPlumParser::LOCK_P:
          case GreenPlumParser::LOGIN_P:
          case GreenPlumParser::MAPPING:
          case GreenPlumParser::MASTER:
          case GreenPlumParser::MATCH:
          case GreenPlumParser::MAXVALUE:
          case GreenPlumParser::MEMORY_LIMIT:
          case GreenPlumParser::MEMORY_SHARED_QUOTA:
          case GreenPlumParser::MEMORY_SPILL_RATIO:
          case GreenPlumParser::MERGE:
          case GreenPlumParser::MINUTE_P:
          case GreenPlumParser::MINVALUE:
          case GreenPlumParser::MISSING:
          case GreenPlumParser::MODE:
          case GreenPlumParser::MODIFIES:
          case GreenPlumParser::MODIFY:
          case GreenPlumParser::MONTH_P:
          case GreenPlumParser::MOVE:
          case GreenPlumParser::NAME_P:
          case GreenPlumParser::NAMES:
          case GreenPlumParser::NEXT:
          case GreenPlumParser::NO:
          case GreenPlumParser::NOCREATEDB:
          case GreenPlumParser::NOCREATEEXTTABLE:
          case GreenPlumParser::NOCREATEROLE:
          case GreenPlumParser::NOCREATEUSER:
          case GreenPlumParser::NOINHERIT:
          case GreenPlumParser::NOLOGIN_P:
          case GreenPlumParser::NOOVERCOMMIT:
          case GreenPlumParser::NOSUPERUSER:
          case GreenPlumParser::NOTHING:
          case GreenPlumParser::NOTIFY:
          case GreenPlumParser::NOWAIT:
          case GreenPlumParser::NULLS_P:
          case GreenPlumParser::OBJECT_P:
          case GreenPlumParser::OF:
          case GreenPlumParser::OIDS:
          case GreenPlumParser::OPERATOR:
          case GreenPlumParser::OPTION:
          case GreenPlumParser::OPTIONS:
          case GreenPlumParser::ORDERED:
          case GreenPlumParser::OTHERS:
          case GreenPlumParser::OVER:
          case GreenPlumParser::OVERCOMMIT:
          case GreenPlumParser::OWNED:
          case GreenPlumParser::OWNER:
          case GreenPlumParser::PARSER:
          case GreenPlumParser::PARTIAL:
          case GreenPlumParser::PARTITIONS:
          case GreenPlumParser::PASSING:
          case GreenPlumParser::PASSWORD:
          case GreenPlumParser::PERCENT:
          case GreenPlumParser::PLANS:
          case GreenPlumParser::PREPARE:
          case GreenPlumParser::PREPARED:
          case GreenPlumParser::PRESERVE:
          case GreenPlumParser::PRIOR:
          case GreenPlumParser::PRIVILEGES:
          case GreenPlumParser::PROCEDURAL:
          case GreenPlumParser::PROCEDURE:
          case GreenPlumParser::PROGRAM:
          case GreenPlumParser::PROTOCOL:
          case GreenPlumParser::PUBLIC:
          case GreenPlumParser::QUEUE:
          case GreenPlumParser::QUOTE:
          case GreenPlumParser::RANDOMLY:
          case GreenPlumParser::READ:
          case GreenPlumParser::READABLE:
          case GreenPlumParser::READS:
          case GreenPlumParser::REASSIGN:
          case GreenPlumParser::RECHECK:
          case GreenPlumParser::RECURSIVE:
          case GreenPlumParser::REF:
          case GreenPlumParser::REINDEX:
          case GreenPlumParser::REJECT_P:
          case GreenPlumParser::RELATIVE_P:
          case GreenPlumParser::RELEASE:
          case GreenPlumParser::RENAME:
          case GreenPlumParser::REPEATABLE:
          case GreenPlumParser::REPLACE:
          case GreenPlumParser::REPLICA:
          case GreenPlumParser::RESET:
          case GreenPlumParser::RESOURCE:
          case GreenPlumParser::RESTART:
          case GreenPlumParser::RESTRICT:
          case GreenPlumParser::RETURNS:
          case GreenPlumParser::REVOKE:
          case GreenPlumParser::ROLE:
          case GreenPlumParser::ROLLBACK:
          case GreenPlumParser::ROOTPARTITION:
          case GreenPlumParser::RULE:
          case GreenPlumParser::SAVEPOINT:
          case GreenPlumParser::SCHEMA:
          case GreenPlumParser::SCROLL:
          case GreenPlumParser::SEARCH:
          case GreenPlumParser::SECOND_P:
          case GreenPlumParser::SECURITY:
          case GreenPlumParser::SEGMENT:
          case GreenPlumParser::SEQUENCE:
          case GreenPlumParser::SERIALIZABLE:
          case GreenPlumParser::SESSION:
          case GreenPlumParser::SET:
          case GreenPlumParser::SHARE:
          case GreenPlumParser::SHOW:
          case GreenPlumParser::SIMPLE:
          case GreenPlumParser::SPLIT:
          case GreenPlumParser::SQL:
          case GreenPlumParser::STABLE:
          case GreenPlumParser::STANDALONE_P:
          case GreenPlumParser::START:
          case GreenPlumParser::STATEMENT:
          case GreenPlumParser::STATISTICS:
          case GreenPlumParser::STDIN:
          case GreenPlumParser::STDOUT:
          case GreenPlumParser::STORAGE:
          case GreenPlumParser::STRICT_P:
          case GreenPlumParser::STRIP_P:
          case GreenPlumParser::SUBPARTITION:
          case GreenPlumParser::SUBPARTITIONS:
          case GreenPlumParser::SUPERUSER_P:
          case GreenPlumParser::SYSID:
          case GreenPlumParser::SYSTEM_P:
          case GreenPlumParser::TABLESPACE:
          case GreenPlumParser::TEMP:
          case GreenPlumParser::TEMPLATE:
          case GreenPlumParser::TEMPORARY:
          case GreenPlumParser::TEXT_P:
          case GreenPlumParser::THRESHOLD:
          case GreenPlumParser::TIES:
          case GreenPlumParser::TRANSACTION:
          case GreenPlumParser::TRIGGER:
          case GreenPlumParser::TRUNCATE:
          case GreenPlumParser::TRUSTED:
          case GreenPlumParser::TYPE_P:
          case GreenPlumParser::UNCOMMITTED:
          case GreenPlumParser::UNENCRYPTED:
          case GreenPlumParser::UNKNOWN:
          case GreenPlumParser::UNLISTEN:
          case GreenPlumParser::UNTIL:
          case GreenPlumParser::UPDATE:
          case GreenPlumParser::VACUUM:
          case GreenPlumParser::VALID:
          case GreenPlumParser::VALIDATION:
          case GreenPlumParser::VALIDATOR:
          case GreenPlumParser::VALUE_P:
          case GreenPlumParser::VARYING:
          case GreenPlumParser::VERSION_P:
          case GreenPlumParser::VIEW:
          case GreenPlumParser::VOLATILE:
          case GreenPlumParser::WEB:
          case GreenPlumParser::WHITESPACE_P:
          case GreenPlumParser::WITHIN:
          case GreenPlumParser::WITHOUT:
          case GreenPlumParser::WORK:
          case GreenPlumParser::WRITABLE:
          case GreenPlumParser::WRITE:
          case GreenPlumParser::XML_P:
          case GreenPlumParser::YEAR_P:
          case GreenPlumParser::YES_P:
          case GreenPlumParser::ZONE:
          case GreenPlumParser::COLON:
          case GreenPlumParser::CHAR_STRING:
          case GreenPlumParser::REGULAR_ID:
          case GreenPlumParser::SCONST: {
            setState(4721);
            name();
            break;
          }

          case GreenPlumParser::DEFAULT: {
            setState(4722);
            match(GreenPlumParser::DEFAULT);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_database_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_database_stmtContext::Alter_database_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_database_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_database_stmtContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

GreenPlumParser::Database_nameContext* GreenPlumParser::Alter_database_stmtContext::database_name() {
  return getRuleContext<GreenPlumParser::Database_nameContext>(0);
}

GreenPlumParser::Opt_withContext* GreenPlumParser::Alter_database_stmtContext::opt_with() {
  return getRuleContext<GreenPlumParser::Opt_withContext>(0);
}

std::vector<GreenPlumParser::Alterdb_opt_itemContext *> GreenPlumParser::Alter_database_stmtContext::alterdb_opt_item() {
  return getRuleContexts<GreenPlumParser::Alterdb_opt_itemContext>();
}

GreenPlumParser::Alterdb_opt_itemContext* GreenPlumParser::Alter_database_stmtContext::alterdb_opt_item(size_t i) {
  return getRuleContext<GreenPlumParser::Alterdb_opt_itemContext>(i);
}


size_t GreenPlumParser::Alter_database_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_database_stmt;
}

void GreenPlumParser::Alter_database_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_database_stmt(this);
}

void GreenPlumParser::Alter_database_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_database_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_database_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_database_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_database_stmtContext* GreenPlumParser::alter_database_stmt() {
  Alter_database_stmtContext *_localctx = _tracker.createInstance<Alter_database_stmtContext>(_ctx, getState());
  enterRule(_localctx, 650, GreenPlumParser::RuleAlter_database_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4727);
    match(GreenPlumParser::ALTER);
    setState(4728);
    match(GreenPlumParser::DATABASE);
    setState(4729);
    database_name();
    setState(4731);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(4730);
      opt_with();
    }
    setState(4736);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::CONNECTION) {
      setState(4733);
      alterdb_opt_item();
      setState(4738);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_database_set_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_database_set_stmtContext::Alter_database_set_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_database_set_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_database_set_stmtContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

GreenPlumParser::Database_nameContext* GreenPlumParser::Alter_database_set_stmtContext::database_name() {
  return getRuleContext<GreenPlumParser::Database_nameContext>(0);
}

GreenPlumParser::Set_reset_clauseContext* GreenPlumParser::Alter_database_set_stmtContext::set_reset_clause() {
  return getRuleContext<GreenPlumParser::Set_reset_clauseContext>(0);
}


size_t GreenPlumParser::Alter_database_set_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_database_set_stmt;
}

void GreenPlumParser::Alter_database_set_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_database_set_stmt(this);
}

void GreenPlumParser::Alter_database_set_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_database_set_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_database_set_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_database_set_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_database_set_stmtContext* GreenPlumParser::alter_database_set_stmt() {
  Alter_database_set_stmtContext *_localctx = _tracker.createInstance<Alter_database_set_stmtContext>(_ctx, getState());
  enterRule(_localctx, 652, GreenPlumParser::RuleAlter_database_set_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4739);
    match(GreenPlumParser::ALTER);
    setState(4740);
    match(GreenPlumParser::DATABASE);
    setState(4741);
    database_name();
    setState(4742);
    set_reset_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alterdb_opt_itemContext ------------------------------------------------------------------

GreenPlumParser::Alterdb_opt_itemContext::Alterdb_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alterdb_opt_itemContext::CONNECTION() {
  return getToken(GreenPlumParser::CONNECTION, 0);
}

tree::TerminalNode* GreenPlumParser::Alterdb_opt_itemContext::LIMIT() {
  return getToken(GreenPlumParser::LIMIT, 0);
}

GreenPlumParser::Signed_iconstContext* GreenPlumParser::Alterdb_opt_itemContext::signed_iconst() {
  return getRuleContext<GreenPlumParser::Signed_iconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alterdb_opt_itemContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}


size_t GreenPlumParser::Alterdb_opt_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlterdb_opt_item;
}

void GreenPlumParser::Alterdb_opt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterdb_opt_item(this);
}

void GreenPlumParser::Alterdb_opt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterdb_opt_item(this);
}


antlrcpp::Any GreenPlumParser::Alterdb_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlterdb_opt_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alterdb_opt_itemContext* GreenPlumParser::alterdb_opt_item() {
  Alterdb_opt_itemContext *_localctx = _tracker.createInstance<Alterdb_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 654, GreenPlumParser::RuleAlterdb_opt_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4744);
    match(GreenPlumParser::CONNECTION);
    setState(4745);
    match(GreenPlumParser::LIMIT);
    setState(4747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::EQUALS_OP) {
      setState(4746);
      match(GreenPlumParser::EQUALS_OP);
    }
    setState(4749);
    signed_iconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dropdb_stmtContext ------------------------------------------------------------------

GreenPlumParser::Dropdb_stmtContext::Dropdb_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Dropdb_stmtContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Dropdb_stmtContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

GreenPlumParser::Database_nameContext* GreenPlumParser::Dropdb_stmtContext::database_name() {
  return getRuleContext<GreenPlumParser::Database_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Dropdb_stmtContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Dropdb_stmtContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}


size_t GreenPlumParser::Dropdb_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDropdb_stmt;
}

void GreenPlumParser::Dropdb_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropdb_stmt(this);
}

void GreenPlumParser::Dropdb_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropdb_stmt(this);
}


antlrcpp::Any GreenPlumParser::Dropdb_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDropdb_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Dropdb_stmtContext* GreenPlumParser::dropdb_stmt() {
  Dropdb_stmtContext *_localctx = _tracker.createInstance<Dropdb_stmtContext>(_ctx, getState());
  enterRule(_localctx, 656, GreenPlumParser::RuleDropdb_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4751);
    match(GreenPlumParser::DROP);
    setState(4752);
    match(GreenPlumParser::DATABASE);
    setState(4755);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
    case 1: {
      setState(4753);
      match(GreenPlumParser::IF_P);
      setState(4754);
      match(GreenPlumParser::EXISTS);
      break;
    }

    }
    setState(4757);
    database_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_domain_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_domain_stmtContext::Create_domain_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_domain_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_domain_stmtContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Create_domain_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Create_domain_stmtContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

tree::TerminalNode* GreenPlumParser::Create_domain_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

std::vector<GreenPlumParser::Col_constraintContext *> GreenPlumParser::Create_domain_stmtContext::col_constraint() {
  return getRuleContexts<GreenPlumParser::Col_constraintContext>();
}

GreenPlumParser::Col_constraintContext* GreenPlumParser::Create_domain_stmtContext::col_constraint(size_t i) {
  return getRuleContext<GreenPlumParser::Col_constraintContext>(i);
}


size_t GreenPlumParser::Create_domain_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_domain_stmt;
}

void GreenPlumParser::Create_domain_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_domain_stmt(this);
}

void GreenPlumParser::Create_domain_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_domain_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_domain_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_domain_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_domain_stmtContext* GreenPlumParser::create_domain_stmt() {
  Create_domain_stmtContext *_localctx = _tracker.createInstance<Create_domain_stmtContext>(_ctx, getState());
  enterRule(_localctx, 658, GreenPlumParser::RuleCreate_domain_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4759);
    match(GreenPlumParser::CREATE);
    setState(4760);
    match(GreenPlumParser::DOMAIN_P);
    setState(4761);
    any_name();
    setState(4763);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::AS) {
      setState(4762);
      match(GreenPlumParser::AS);
    }
    setState(4765);
    typename_pg();
    setState(4769);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 46) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 46)) & ((1ULL << (GreenPlumParser::CHECK - 46))
      | (1ULL << (GreenPlumParser::CONSTRAINT - 46))
      | (1ULL << (GreenPlumParser::DEFAULT - 46))
      | (1ULL << (GreenPlumParser::DEFERRABLE - 46)))) != 0) || _la == GreenPlumParser::INITIALLY || ((((_la - 262) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 262)) & ((1ULL << (GreenPlumParser::NOT - 262))
      | (1ULL << (GreenPlumParser::NULL_P - 262))
      | (1ULL << (GreenPlumParser::PRIMARY - 262)))) != 0) || _la == GreenPlumParser::REFERENCES || _la == GreenPlumParser::UNIQUE) {
      setState(4766);
      col_constraint();
      setState(4771);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_domain_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_domain_stmtContext::Alter_domain_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_domain_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_domain_stmtContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_domain_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

GreenPlumParser::Alter_domain_optionContext* GreenPlumParser::Alter_domain_stmtContext::alter_domain_option() {
  return getRuleContext<GreenPlumParser::Alter_domain_optionContext>(0);
}


size_t GreenPlumParser::Alter_domain_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_domain_stmt;
}

void GreenPlumParser::Alter_domain_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_domain_stmt(this);
}

void GreenPlumParser::Alter_domain_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_domain_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_domain_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_domain_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_domain_stmtContext* GreenPlumParser::alter_domain_stmt() {
  Alter_domain_stmtContext *_localctx = _tracker.createInstance<Alter_domain_stmtContext>(_ctx, getState());
  enterRule(_localctx, 660, GreenPlumParser::RuleAlter_domain_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4772);
    match(GreenPlumParser::ALTER);
    setState(4773);
    match(GreenPlumParser::DOMAIN_P);
    setState(4774);
    any_name();
    setState(4775);
    alter_domain_option();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_domain_optionContext ------------------------------------------------------------------

GreenPlumParser::Alter_domain_optionContext::Alter_domain_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Alter_column_defaultContext* GreenPlumParser::Alter_domain_optionContext::alter_column_default() {
  return getRuleContext<GreenPlumParser::Alter_column_defaultContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_domain_optionContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_domain_optionContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_domain_optionContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_domain_optionContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_domain_optionContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

GreenPlumParser::Table_constraintContext* GreenPlumParser::Alter_domain_optionContext::table_constraint() {
  return getRuleContext<GreenPlumParser::Table_constraintContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_domain_optionContext::CONSTRAINT() {
  return getToken(GreenPlumParser::CONSTRAINT, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Alter_domain_optionContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

GreenPlumParser::Opt_drop_behaviorContext* GreenPlumParser::Alter_domain_optionContext::opt_drop_behavior() {
  return getRuleContext<GreenPlumParser::Opt_drop_behaviorContext>(0);
}


size_t GreenPlumParser::Alter_domain_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_domain_option;
}

void GreenPlumParser::Alter_domain_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_domain_option(this);
}

void GreenPlumParser::Alter_domain_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_domain_option(this);
}


antlrcpp::Any GreenPlumParser::Alter_domain_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_domain_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_domain_optionContext* GreenPlumParser::alter_domain_option() {
  Alter_domain_optionContext *_localctx = _tracker.createInstance<Alter_domain_optionContext>(_ctx, getState());
  enterRule(_localctx, 662, GreenPlumParser::RuleAlter_domain_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4789);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 465, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4777);
      alter_column_default();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4778);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::DROP || _la == GreenPlumParser::SET)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4779);
      match(GreenPlumParser::NOT);
      setState(4780);
      match(GreenPlumParser::NULL_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4781);
      match(GreenPlumParser::ADD_P);
      setState(4782);
      table_constraint();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4783);
      match(GreenPlumParser::DROP);
      setState(4784);
      match(GreenPlumParser::CONSTRAINT);
      setState(4785);
      name();
      setState(4787);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::CASCADE || _la == GreenPlumParser::RESTRICT) {
        setState(4786);
        opt_drop_behavior();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_tsdictionary_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_tsdictionary_stmtContext::Alter_tsdictionary_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_tsdictionary_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_tsdictionary_stmtContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_tsdictionary_stmtContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_tsdictionary_stmtContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_tsdictionary_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

GreenPlumParser::DefinitionContext* GreenPlumParser::Alter_tsdictionary_stmtContext::definition() {
  return getRuleContext<GreenPlumParser::DefinitionContext>(0);
}


size_t GreenPlumParser::Alter_tsdictionary_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_tsdictionary_stmt;
}

void GreenPlumParser::Alter_tsdictionary_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_tsdictionary_stmt(this);
}

void GreenPlumParser::Alter_tsdictionary_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_tsdictionary_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_tsdictionary_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_tsdictionary_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_tsdictionary_stmtContext* GreenPlumParser::alter_tsdictionary_stmt() {
  Alter_tsdictionary_stmtContext *_localctx = _tracker.createInstance<Alter_tsdictionary_stmtContext>(_ctx, getState());
  enterRule(_localctx, 664, GreenPlumParser::RuleAlter_tsdictionary_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4791);
    match(GreenPlumParser::ALTER);
    setState(4792);
    match(GreenPlumParser::TEXT_P);
    setState(4793);
    match(GreenPlumParser::SEARCH);
    setState(4794);
    match(GreenPlumParser::DICTIONARY);
    setState(4795);
    any_name();
    setState(4796);
    definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_tsconfiguration_stmtContext ------------------------------------------------------------------

GreenPlumParser::Alter_tsconfiguration_stmtContext::Alter_tsconfiguration_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_tsconfiguration_stmtContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_tsconfiguration_stmtContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_tsconfiguration_stmtContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_tsconfiguration_stmtContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_tsconfiguration_stmtContext::any_name() {
  return getRuleContext<GreenPlumParser::Any_nameContext>(0);
}

GreenPlumParser::Alter_txt_search_conf_optionContext* GreenPlumParser::Alter_tsconfiguration_stmtContext::alter_txt_search_conf_option() {
  return getRuleContext<GreenPlumParser::Alter_txt_search_conf_optionContext>(0);
}


size_t GreenPlumParser::Alter_tsconfiguration_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_tsconfiguration_stmt;
}

void GreenPlumParser::Alter_tsconfiguration_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_tsconfiguration_stmt(this);
}

void GreenPlumParser::Alter_tsconfiguration_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_tsconfiguration_stmt(this);
}


antlrcpp::Any GreenPlumParser::Alter_tsconfiguration_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_tsconfiguration_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_tsconfiguration_stmtContext* GreenPlumParser::alter_tsconfiguration_stmt() {
  Alter_tsconfiguration_stmtContext *_localctx = _tracker.createInstance<Alter_tsconfiguration_stmtContext>(_ctx, getState());
  enterRule(_localctx, 666, GreenPlumParser::RuleAlter_tsconfiguration_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4798);
    match(GreenPlumParser::ALTER);
    setState(4799);
    match(GreenPlumParser::TEXT_P);
    setState(4800);
    match(GreenPlumParser::SEARCH);
    setState(4801);
    match(GreenPlumParser::CONFIGURATION);
    setState(4802);
    any_name();
    setState(4803);
    alter_txt_search_conf_option();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_txt_search_conf_optionContext ------------------------------------------------------------------

GreenPlumParser::Alter_txt_search_conf_optionContext::Alter_txt_search_conf_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::MAPPING() {
  return getToken(GreenPlumParser::MAPPING, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Alter_txt_search_conf_optionContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

GreenPlumParser::Any_name_listContext* GreenPlumParser::Alter_txt_search_conf_optionContext::any_name_list() {
  return getRuleContext<GreenPlumParser::Any_name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::REPLACE() {
  return getToken(GreenPlumParser::REPLACE, 0);
}

std::vector<GreenPlumParser::Any_nameContext *> GreenPlumParser::Alter_txt_search_conf_optionContext::any_name() {
  return getRuleContexts<GreenPlumParser::Any_nameContext>();
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Alter_txt_search_conf_optionContext::any_name(size_t i) {
  return getRuleContext<GreenPlumParser::Any_nameContext>(i);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Alter_txt_search_conf_optionContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}


size_t GreenPlumParser::Alter_txt_search_conf_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleAlter_txt_search_conf_option;
}

void GreenPlumParser::Alter_txt_search_conf_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_txt_search_conf_option(this);
}

void GreenPlumParser::Alter_txt_search_conf_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_txt_search_conf_option(this);
}


antlrcpp::Any GreenPlumParser::Alter_txt_search_conf_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAlter_txt_search_conf_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Alter_txt_search_conf_optionContext* GreenPlumParser::alter_txt_search_conf_option() {
  Alter_txt_search_conf_optionContext *_localctx = _tracker.createInstance<Alter_txt_search_conf_optionContext>(_ctx, getState());
  enterRule(_localctx, 668, GreenPlumParser::RuleAlter_txt_search_conf_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4831);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 468, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4805);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::ADD_P

      || _la == GreenPlumParser::ALTER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4806);
      match(GreenPlumParser::MAPPING);
      setState(4807);
      match(GreenPlumParser::FOR);
      setState(4808);
      name_list();
      setState(4809);
      match(GreenPlumParser::WITH);
      setState(4810);
      any_name_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4812);
      match(GreenPlumParser::ALTER);
      setState(4813);
      match(GreenPlumParser::MAPPING);
      setState(4816);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::FOR) {
        setState(4814);
        match(GreenPlumParser::FOR);
        setState(4815);
        name_list();
      }
      setState(4818);
      match(GreenPlumParser::REPLACE);
      setState(4819);
      any_name();
      setState(4820);
      match(GreenPlumParser::WITH);
      setState(4821);
      any_name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4823);
      match(GreenPlumParser::DROP);
      setState(4824);
      match(GreenPlumParser::MAPPING);
      setState(4827);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::IF_P) {
        setState(4825);
        match(GreenPlumParser::IF_P);
        setState(4826);
        match(GreenPlumParser::EXISTS);
      }
      setState(4829);
      match(GreenPlumParser::FOR);
      setState(4830);
      name_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_conversion_stmtContext ------------------------------------------------------------------

GreenPlumParser::Create_conversion_stmtContext::Create_conversion_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Create_conversion_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Create_conversion_stmtContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

std::vector<GreenPlumParser::Any_nameContext *> GreenPlumParser::Create_conversion_stmtContext::any_name() {
  return getRuleContexts<GreenPlumParser::Any_nameContext>();
}

GreenPlumParser::Any_nameContext* GreenPlumParser::Create_conversion_stmtContext::any_name(size_t i) {
  return getRuleContext<GreenPlumParser::Any_nameContext>(i);
}

tree::TerminalNode* GreenPlumParser::Create_conversion_stmtContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

std::vector<GreenPlumParser::SconstContext *> GreenPlumParser::Create_conversion_stmtContext::sconst() {
  return getRuleContexts<GreenPlumParser::SconstContext>();
}

GreenPlumParser::SconstContext* GreenPlumParser::Create_conversion_stmtContext::sconst(size_t i) {
  return getRuleContext<GreenPlumParser::SconstContext>(i);
}

tree::TerminalNode* GreenPlumParser::Create_conversion_stmtContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

tree::TerminalNode* GreenPlumParser::Create_conversion_stmtContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

tree::TerminalNode* GreenPlumParser::Create_conversion_stmtContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Create_conversion_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCreate_conversion_stmt;
}

void GreenPlumParser::Create_conversion_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_conversion_stmt(this);
}

void GreenPlumParser::Create_conversion_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_conversion_stmt(this);
}


antlrcpp::Any GreenPlumParser::Create_conversion_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCreate_conversion_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Create_conversion_stmtContext* GreenPlumParser::create_conversion_stmt() {
  Create_conversion_stmtContext *_localctx = _tracker.createInstance<Create_conversion_stmtContext>(_ctx, getState());
  enterRule(_localctx, 670, GreenPlumParser::RuleCreate_conversion_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4833);
    match(GreenPlumParser::CREATE);
    setState(4835);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DEFAULT) {
      setState(4834);
      match(GreenPlumParser::DEFAULT);
    }
    setState(4837);
    match(GreenPlumParser::CONVERSION_P);
    setState(4838);
    any_name();
    setState(4839);
    match(GreenPlumParser::FOR);
    setState(4840);
    sconst();
    setState(4841);
    match(GreenPlumParser::TO);
    setState(4842);
    sconst();
    setState(4843);
    match(GreenPlumParser::FROM);
    setState(4844);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cluster_stmtContext ------------------------------------------------------------------

GreenPlumParser::Cluster_stmtContext::Cluster_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Cluster_stmtContext::CLUSTER() {
  return getToken(GreenPlumParser::CLUSTER, 0);
}

GreenPlumParser::Cluster_optionContext* GreenPlumParser::Cluster_stmtContext::cluster_option() {
  return getRuleContext<GreenPlumParser::Cluster_optionContext>(0);
}


size_t GreenPlumParser::Cluster_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleCluster_stmt;
}

void GreenPlumParser::Cluster_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCluster_stmt(this);
}

void GreenPlumParser::Cluster_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCluster_stmt(this);
}


antlrcpp::Any GreenPlumParser::Cluster_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCluster_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cluster_stmtContext* GreenPlumParser::cluster_stmt() {
  Cluster_stmtContext *_localctx = _tracker.createInstance<Cluster_stmtContext>(_ctx, getState());
  enterRule(_localctx, 672, GreenPlumParser::RuleCluster_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4846);
    match(GreenPlumParser::CLUSTER);
    setState(4848);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NEW - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OLD - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
      setState(4847);
      cluster_option();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cluster_optionContext ------------------------------------------------------------------

GreenPlumParser::Cluster_optionContext::Cluster_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Cluster_optionContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Cluster_optionContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Index_nameContext* GreenPlumParser::Cluster_optionContext::index_name() {
  return getRuleContext<GreenPlumParser::Index_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Cluster_optionContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}


size_t GreenPlumParser::Cluster_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleCluster_option;
}

void GreenPlumParser::Cluster_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCluster_option(this);
}

void GreenPlumParser::Cluster_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCluster_option(this);
}


antlrcpp::Any GreenPlumParser::Cluster_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCluster_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cluster_optionContext* GreenPlumParser::cluster_option() {
  Cluster_optionContext *_localctx = _tracker.createInstance<Cluster_optionContext>(_ctx, getState());
  enterRule(_localctx, 674, GreenPlumParser::RuleCluster_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4859);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 472, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4850);
      qualified_name();
      setState(4853);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::USING) {
        setState(4851);
        match(GreenPlumParser::USING);
        setState(4852);
        index_name();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4855);
      index_name();
      setState(4856);
      match(GreenPlumParser::ON);
      setState(4857);
      qualified_name();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vacuum_stmtContext ------------------------------------------------------------------

GreenPlumParser::Vacuum_stmtContext::Vacuum_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Vacuum_stmtContext::VACUUM() {
  return getToken(GreenPlumParser::VACUUM, 0);
}

tree::TerminalNode* GreenPlumParser::Vacuum_stmtContext::FULL() {
  return getToken(GreenPlumParser::FULL, 0);
}

tree::TerminalNode* GreenPlumParser::Vacuum_stmtContext::FREEZE() {
  return getToken(GreenPlumParser::FREEZE, 0);
}

tree::TerminalNode* GreenPlumParser::Vacuum_stmtContext::VERBOSE() {
  return getToken(GreenPlumParser::VERBOSE, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Vacuum_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Analyze_stmtContext* GreenPlumParser::Vacuum_stmtContext::analyze_stmt() {
  return getRuleContext<GreenPlumParser::Analyze_stmtContext>(0);
}


size_t GreenPlumParser::Vacuum_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleVacuum_stmt;
}

void GreenPlumParser::Vacuum_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVacuum_stmt(this);
}

void GreenPlumParser::Vacuum_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVacuum_stmt(this);
}


antlrcpp::Any GreenPlumParser::Vacuum_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitVacuum_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Vacuum_stmtContext* GreenPlumParser::vacuum_stmt() {
  Vacuum_stmtContext *_localctx = _tracker.createInstance<Vacuum_stmtContext>(_ctx, getState());
  enterRule(_localctx, 676, GreenPlumParser::RuleVacuum_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4885);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4861);
      match(GreenPlumParser::VACUUM);
      setState(4863);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::FULL) {
        setState(4862);
        match(GreenPlumParser::FULL);
      }
      setState(4866);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::FREEZE) {
        setState(4865);
        match(GreenPlumParser::FREEZE);
      }
      setState(4869);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::VERBOSE) {
        setState(4868);
        match(GreenPlumParser::VERBOSE);
      }
      setState(4872);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEW - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OLD - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
        setState(4871);
        qualified_name();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4874);
      match(GreenPlumParser::VACUUM);
      setState(4876);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::FULL) {
        setState(4875);
        match(GreenPlumParser::FULL);
      }
      setState(4879);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::FREEZE) {
        setState(4878);
        match(GreenPlumParser::FREEZE);
      }
      setState(4882);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::VERBOSE) {
        setState(4881);
        match(GreenPlumParser::VERBOSE);
      }
      setState(4884);
      analyze_stmt();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analyze_stmtContext ------------------------------------------------------------------

GreenPlumParser::Analyze_stmtContext::Analyze_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Analyze_keywordContext* GreenPlumParser::Analyze_stmtContext::analyze_keyword() {
  return getRuleContext<GreenPlumParser::Analyze_keywordContext>(0);
}

tree::TerminalNode* GreenPlumParser::Analyze_stmtContext::VERBOSE() {
  return getToken(GreenPlumParser::VERBOSE, 0);
}

tree::TerminalNode* GreenPlumParser::Analyze_stmtContext::ROOTPARTITION() {
  return getToken(GreenPlumParser::ROOTPARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Analyze_stmtContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Analyze_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::Analyze_stmtContext::paren_name_list() {
  return getRuleContext<GreenPlumParser::Paren_name_listContext>(0);
}


size_t GreenPlumParser::Analyze_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleAnalyze_stmt;
}

void GreenPlumParser::Analyze_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalyze_stmt(this);
}

void GreenPlumParser::Analyze_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalyze_stmt(this);
}


antlrcpp::Any GreenPlumParser::Analyze_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAnalyze_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Analyze_stmtContext* GreenPlumParser::analyze_stmt() {
  Analyze_stmtContext *_localctx = _tracker.createInstance<Analyze_stmtContext>(_ctx, getState());
  enterRule(_localctx, 678, GreenPlumParser::RuleAnalyze_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4908);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 487, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4887);
      analyze_keyword();
      setState(4889);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::VERBOSE) {
        setState(4888);
        match(GreenPlumParser::VERBOSE);
      }
      setState(4893);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ROOTPARTITION) {
        setState(4891);
        match(GreenPlumParser::ROOTPARTITION);
        setState(4892);
        match(GreenPlumParser::ALL);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4895);
      analyze_keyword();
      setState(4897);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::VERBOSE) {
        setState(4896);
        match(GreenPlumParser::VERBOSE);
      }
      setState(4900);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx)) {
      case 1: {
        setState(4899);
        match(GreenPlumParser::ROOTPARTITION);
        break;
      }

      }
      setState(4906);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEW - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OLD - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
        setState(4902);
        qualified_name();
        setState(4904);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::LEFT_PAREN) {
          setState(4903);
          paren_name_list();
        }
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analyze_keywordContext ------------------------------------------------------------------

GreenPlumParser::Analyze_keywordContext::Analyze_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Analyze_keywordContext::ANALYZE() {
  return getToken(GreenPlumParser::ANALYZE, 0);
}

tree::TerminalNode* GreenPlumParser::Analyze_keywordContext::ANALYSE() {
  return getToken(GreenPlumParser::ANALYSE, 0);
}


size_t GreenPlumParser::Analyze_keywordContext::getRuleIndex() const {
  return GreenPlumParser::RuleAnalyze_keyword;
}

void GreenPlumParser::Analyze_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalyze_keyword(this);
}

void GreenPlumParser::Analyze_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalyze_keyword(this);
}


antlrcpp::Any GreenPlumParser::Analyze_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAnalyze_keyword(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Analyze_keywordContext* GreenPlumParser::analyze_keyword() {
  Analyze_keywordContext *_localctx = _tracker.createInstance<Analyze_keywordContext>(_ctx, getState());
  enterRule(_localctx, 680, GreenPlumParser::RuleAnalyze_keyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4910);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::ANALYSE

    || _la == GreenPlumParser::ANALYZE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Paren_name_listContext ------------------------------------------------------------------

GreenPlumParser::Paren_name_listContext::Paren_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Paren_name_listContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Paren_name_listContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Paren_name_listContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Paren_name_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleParen_name_list;
}

void GreenPlumParser::Paren_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParen_name_list(this);
}

void GreenPlumParser::Paren_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParen_name_list(this);
}


antlrcpp::Any GreenPlumParser::Paren_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParen_name_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::paren_name_list() {
  Paren_name_listContext *_localctx = _tracker.createInstance<Paren_name_listContext>(_ctx, getState());
  enterRule(_localctx, 682, GreenPlumParser::RuleParen_name_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4912);
    match(GreenPlumParser::LEFT_PAREN);
    setState(4913);
    name_list();
    setState(4914);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explain_stmtContext ------------------------------------------------------------------

GreenPlumParser::Explain_stmtContext::Explain_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Explain_stmtContext::EXPLAIN() {
  return getToken(GreenPlumParser::EXPLAIN, 0);
}

GreenPlumParser::Explainable_stmtContext* GreenPlumParser::Explain_stmtContext::explainable_stmt() {
  return getRuleContext<GreenPlumParser::Explainable_stmtContext>(0);
}

GreenPlumParser::Analyze_keywordContext* GreenPlumParser::Explain_stmtContext::analyze_keyword() {
  return getRuleContext<GreenPlumParser::Analyze_keywordContext>(0);
}

tree::TerminalNode* GreenPlumParser::Explain_stmtContext::VERBOSE() {
  return getToken(GreenPlumParser::VERBOSE, 0);
}

tree::TerminalNode* GreenPlumParser::Explain_stmtContext::DXL() {
  return getToken(GreenPlumParser::DXL, 0);
}

tree::TerminalNode* GreenPlumParser::Explain_stmtContext::FORCE() {
  return getToken(GreenPlumParser::FORCE, 0);
}


size_t GreenPlumParser::Explain_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleExplain_stmt;
}

void GreenPlumParser::Explain_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplain_stmt(this);
}

void GreenPlumParser::Explain_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplain_stmt(this);
}


antlrcpp::Any GreenPlumParser::Explain_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExplain_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Explain_stmtContext* GreenPlumParser::explain_stmt() {
  Explain_stmtContext *_localctx = _tracker.createInstance<Explain_stmtContext>(_ctx, getState());
  enterRule(_localctx, 684, GreenPlumParser::RuleExplain_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4916);
    match(GreenPlumParser::EXPLAIN);
    setState(4918);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ANALYSE

    || _la == GreenPlumParser::ANALYZE) {
      setState(4917);
      analyze_keyword();
    }
    setState(4921);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::VERBOSE) {
      setState(4920);
      match(GreenPlumParser::VERBOSE);
    }
    setState(4924);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::DXL) {
      setState(4923);
      match(GreenPlumParser::DXL);
    }
    setState(4927);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::FORCE) {
      setState(4926);
      match(GreenPlumParser::FORCE);
    }
    setState(4929);
    explainable_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explainable_stmtContext ------------------------------------------------------------------

GreenPlumParser::Explainable_stmtContext::Explainable_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Explainable_stmtContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

GreenPlumParser::Insert_stmtContext* GreenPlumParser::Explainable_stmtContext::insert_stmt() {
  return getRuleContext<GreenPlumParser::Insert_stmtContext>(0);
}

GreenPlumParser::Update_stmtContext* GreenPlumParser::Explainable_stmtContext::update_stmt() {
  return getRuleContext<GreenPlumParser::Update_stmtContext>(0);
}

GreenPlumParser::Delete_stmtContext* GreenPlumParser::Explainable_stmtContext::delete_stmt() {
  return getRuleContext<GreenPlumParser::Delete_stmtContext>(0);
}

GreenPlumParser::Declare_cursor_stmtContext* GreenPlumParser::Explainable_stmtContext::declare_cursor_stmt() {
  return getRuleContext<GreenPlumParser::Declare_cursor_stmtContext>(0);
}

GreenPlumParser::Execute_stmtContext* GreenPlumParser::Explainable_stmtContext::execute_stmt() {
  return getRuleContext<GreenPlumParser::Execute_stmtContext>(0);
}

GreenPlumParser::Create_as_stmtContext* GreenPlumParser::Explainable_stmtContext::create_as_stmt() {
  return getRuleContext<GreenPlumParser::Create_as_stmtContext>(0);
}

GreenPlumParser::Create_stmtContext* GreenPlumParser::Explainable_stmtContext::create_stmt() {
  return getRuleContext<GreenPlumParser::Create_stmtContext>(0);
}


size_t GreenPlumParser::Explainable_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleExplainable_stmt;
}

void GreenPlumParser::Explainable_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainable_stmt(this);
}

void GreenPlumParser::Explainable_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainable_stmt(this);
}


antlrcpp::Any GreenPlumParser::Explainable_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExplainable_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Explainable_stmtContext* GreenPlumParser::explainable_stmt() {
  Explainable_stmtContext *_localctx = _tracker.createInstance<Explainable_stmtContext>(_ctx, getState());
  enterRule(_localctx, 686, GreenPlumParser::RuleExplainable_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4939);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 492, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4931);
      select_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4932);
      insert_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4933);
      update_stmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4934);
      delete_stmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4935);
      declare_cursor_stmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4936);
      execute_stmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4937);
      create_as_stmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4938);
      create_stmt();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prepare_stmtContext ------------------------------------------------------------------

GreenPlumParser::Prepare_stmtContext::Prepare_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Prepare_stmtContext::PREPARE() {
  return getToken(GreenPlumParser::PREPARE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Prepare_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Prepare_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Preparable_stmtContext* GreenPlumParser::Prepare_stmtContext::preparable_stmt() {
  return getRuleContext<GreenPlumParser::Preparable_stmtContext>(0);
}

GreenPlumParser::Paren_type_listContext* GreenPlumParser::Prepare_stmtContext::paren_type_list() {
  return getRuleContext<GreenPlumParser::Paren_type_listContext>(0);
}


size_t GreenPlumParser::Prepare_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RulePrepare_stmt;
}

void GreenPlumParser::Prepare_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrepare_stmt(this);
}

void GreenPlumParser::Prepare_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrepare_stmt(this);
}


antlrcpp::Any GreenPlumParser::Prepare_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPrepare_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Prepare_stmtContext* GreenPlumParser::prepare_stmt() {
  Prepare_stmtContext *_localctx = _tracker.createInstance<Prepare_stmtContext>(_ctx, getState());
  enterRule(_localctx, 688, GreenPlumParser::RulePrepare_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4941);
    match(GreenPlumParser::PREPARE);
    setState(4942);
    name();
    setState(4944);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(4943);
      paren_type_list();
    }
    setState(4946);
    match(GreenPlumParser::AS);
    setState(4947);
    preparable_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Paren_type_listContext ------------------------------------------------------------------

GreenPlumParser::Paren_type_listContext::Paren_type_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Paren_type_listContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Type_listContext* GreenPlumParser::Paren_type_listContext::type_list() {
  return getRuleContext<GreenPlumParser::Type_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Paren_type_listContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Paren_type_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleParen_type_list;
}

void GreenPlumParser::Paren_type_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParen_type_list(this);
}

void GreenPlumParser::Paren_type_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParen_type_list(this);
}


antlrcpp::Any GreenPlumParser::Paren_type_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParen_type_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Paren_type_listContext* GreenPlumParser::paren_type_list() {
  Paren_type_listContext *_localctx = _tracker.createInstance<Paren_type_listContext>(_ctx, getState());
  enterRule(_localctx, 690, GreenPlumParser::RuleParen_type_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4949);
    match(GreenPlumParser::LEFT_PAREN);
    setState(4950);
    type_list();
    setState(4951);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Preparable_stmtContext ------------------------------------------------------------------

GreenPlumParser::Preparable_stmtContext::Preparable_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Preparable_stmtContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

GreenPlumParser::Insert_stmtContext* GreenPlumParser::Preparable_stmtContext::insert_stmt() {
  return getRuleContext<GreenPlumParser::Insert_stmtContext>(0);
}

GreenPlumParser::Update_stmtContext* GreenPlumParser::Preparable_stmtContext::update_stmt() {
  return getRuleContext<GreenPlumParser::Update_stmtContext>(0);
}

GreenPlumParser::Delete_stmtContext* GreenPlumParser::Preparable_stmtContext::delete_stmt() {
  return getRuleContext<GreenPlumParser::Delete_stmtContext>(0);
}


size_t GreenPlumParser::Preparable_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RulePreparable_stmt;
}

void GreenPlumParser::Preparable_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreparable_stmt(this);
}

void GreenPlumParser::Preparable_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreparable_stmt(this);
}


antlrcpp::Any GreenPlumParser::Preparable_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPreparable_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Preparable_stmtContext* GreenPlumParser::preparable_stmt() {
  Preparable_stmtContext *_localctx = _tracker.createInstance<Preparable_stmtContext>(_ctx, getState());
  enterRule(_localctx, 692, GreenPlumParser::RulePreparable_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4957);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::SELECT:
      case GreenPlumParser::VALUES:
      case GreenPlumParser::WITH:
      case GreenPlumParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(4953);
        select_stmt();
        break;
      }

      case GreenPlumParser::INSERT: {
        enterOuterAlt(_localctx, 2);
        setState(4954);
        insert_stmt();
        break;
      }

      case GreenPlumParser::UPDATE: {
        enterOuterAlt(_localctx, 3);
        setState(4955);
        update_stmt();
        break;
      }

      case GreenPlumParser::DELETE_P: {
        enterOuterAlt(_localctx, 4);
        setState(4956);
        delete_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_stmtContext ------------------------------------------------------------------

GreenPlumParser::Execute_stmtContext::Execute_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Execute_stmtContext::EXECUTE() {
  return getToken(GreenPlumParser::EXECUTE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Execute_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Execute_stmtContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Execute_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Create_as_targetContext* GreenPlumParser::Execute_stmtContext::create_as_target() {
  return getRuleContext<GreenPlumParser::Create_as_targetContext>(0);
}

tree::TerminalNode* GreenPlumParser::Execute_stmtContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Execute_stmtContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

GreenPlumParser::Opt_tempContext* GreenPlumParser::Execute_stmtContext::opt_temp() {
  return getRuleContext<GreenPlumParser::Opt_tempContext>(0);
}


size_t GreenPlumParser::Execute_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleExecute_stmt;
}

void GreenPlumParser::Execute_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute_stmt(this);
}

void GreenPlumParser::Execute_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute_stmt(this);
}


antlrcpp::Any GreenPlumParser::Execute_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExecute_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Execute_stmtContext* GreenPlumParser::execute_stmt() {
  Execute_stmtContext *_localctx = _tracker.createInstance<Execute_stmtContext>(_ctx, getState());
  enterRule(_localctx, 694, GreenPlumParser::RuleExecute_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4967);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::CREATE) {
      setState(4959);
      match(GreenPlumParser::CREATE);
      setState(4961);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::GLOBAL

      || _la == GreenPlumParser::LOCAL || _la == GreenPlumParser::TEMP

      || _la == GreenPlumParser::TEMPORARY) {
        setState(4960);
        opt_temp();
      }
      setState(4963);
      match(GreenPlumParser::TABLE);
      setState(4964);
      create_as_target();
      setState(4965);
      match(GreenPlumParser::AS);
    }
    setState(4969);
    match(GreenPlumParser::EXECUTE);
    setState(4970);
    name();
    setState(4972);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(4971);
      paren_expr_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Deallocate_stmtContext ------------------------------------------------------------------

GreenPlumParser::Deallocate_stmtContext::Deallocate_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Deallocate_stmtContext::DEALLOCATE() {
  return getToken(GreenPlumParser::DEALLOCATE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Deallocate_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Deallocate_stmtContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

tree::TerminalNode* GreenPlumParser::Deallocate_stmtContext::PREPARE() {
  return getToken(GreenPlumParser::PREPARE, 0);
}


size_t GreenPlumParser::Deallocate_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDeallocate_stmt;
}

void GreenPlumParser::Deallocate_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeallocate_stmt(this);
}

void GreenPlumParser::Deallocate_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeallocate_stmt(this);
}


antlrcpp::Any GreenPlumParser::Deallocate_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDeallocate_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Deallocate_stmtContext* GreenPlumParser::deallocate_stmt() {
  Deallocate_stmtContext *_localctx = _tracker.createInstance<Deallocate_stmtContext>(_ctx, getState());
  enterRule(_localctx, 696, GreenPlumParser::RuleDeallocate_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4974);
    match(GreenPlumParser::DEALLOCATE);
    setState(4976);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 498, _ctx)) {
    case 1: {
      setState(4975);
      match(GreenPlumParser::PREPARE);
      break;
    }

    }
    setState(4980);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        setState(4978);
        name();
        break;
      }

      case GreenPlumParser::ALL: {
        setState(4979);
        match(GreenPlumParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cdb_string_listContext ------------------------------------------------------------------

GreenPlumParser::Cdb_string_listContext::Cdb_string_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Cdb_stringContext *> GreenPlumParser::Cdb_string_listContext::cdb_string() {
  return getRuleContexts<GreenPlumParser::Cdb_stringContext>();
}

GreenPlumParser::Cdb_stringContext* GreenPlumParser::Cdb_string_listContext::cdb_string(size_t i) {
  return getRuleContext<GreenPlumParser::Cdb_stringContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Cdb_string_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Cdb_string_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Cdb_string_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleCdb_string_list;
}

void GreenPlumParser::Cdb_string_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCdb_string_list(this);
}

void GreenPlumParser::Cdb_string_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCdb_string_list(this);
}


antlrcpp::Any GreenPlumParser::Cdb_string_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCdb_string_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cdb_string_listContext* GreenPlumParser::cdb_string_list() {
  Cdb_string_listContext *_localctx = _tracker.createInstance<Cdb_string_listContext>(_ctx, getState());
  enterRule(_localctx, 698, GreenPlumParser::RuleCdb_string_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4982);
    cdb_string();
    setState(4987);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(4983);
      match(GreenPlumParser::COMMA);
      setState(4984);
      cdb_string();
      setState(4989);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cdb_stringContext ------------------------------------------------------------------

GreenPlumParser::Cdb_stringContext::Cdb_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::SconstContext* GreenPlumParser::Cdb_stringContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::Cdb_stringContext::getRuleIndex() const {
  return GreenPlumParser::RuleCdb_string;
}

void GreenPlumParser::Cdb_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCdb_string(this);
}

void GreenPlumParser::Cdb_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCdb_string(this);
}


antlrcpp::Any GreenPlumParser::Cdb_stringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCdb_string(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cdb_stringContext* GreenPlumParser::cdb_string() {
  Cdb_stringContext *_localctx = _tracker.createInstance<Cdb_stringContext>(_ctx, getState());
  enterRule(_localctx, 700, GreenPlumParser::RuleCdb_string);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4990);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmtContext ------------------------------------------------------------------

GreenPlumParser::Insert_stmtContext::Insert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Insert_stmtContext::INSERT() {
  return getToken(GreenPlumParser::INSERT, 0);
}

tree::TerminalNode* GreenPlumParser::Insert_stmtContext::INTO() {
  return getToken(GreenPlumParser::INTO, 0);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Insert_stmtContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

GreenPlumParser::Insert_restContext* GreenPlumParser::Insert_stmtContext::insert_rest() {
  return getRuleContext<GreenPlumParser::Insert_restContext>(0);
}

GreenPlumParser::Paren_column_listContext* GreenPlumParser::Insert_stmtContext::paren_column_list() {
  return getRuleContext<GreenPlumParser::Paren_column_listContext>(0);
}

GreenPlumParser::Returning_clauseContext* GreenPlumParser::Insert_stmtContext::returning_clause() {
  return getRuleContext<GreenPlumParser::Returning_clauseContext>(0);
}


size_t GreenPlumParser::Insert_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleInsert_stmt;
}

void GreenPlumParser::Insert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt(this);
}

void GreenPlumParser::Insert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt(this);
}


antlrcpp::Any GreenPlumParser::Insert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Insert_stmtContext* GreenPlumParser::insert_stmt() {
  Insert_stmtContext *_localctx = _tracker.createInstance<Insert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 702, GreenPlumParser::RuleInsert_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4992);
    match(GreenPlumParser::INSERT);
    setState(4993);
    match(GreenPlumParser::INTO);
    setState(4994);
    qualified_name();
    setState(4996);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 501, _ctx)) {
    case 1: {
      setState(4995);
      paren_column_list();
      break;
    }

    }
    setState(4998);
    insert_rest();
    setState(5000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::RETURNING) {
      setState(4999);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_restContext ------------------------------------------------------------------

GreenPlumParser::Insert_restContext::Insert_restContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Insert_restContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

tree::TerminalNode* GreenPlumParser::Insert_restContext::VALUES() {
  return getToken(GreenPlumParser::VALUES, 0);
}

tree::TerminalNode* GreenPlumParser::Insert_restContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Insert_column_listContext* GreenPlumParser::Insert_restContext::insert_column_list() {
  return getRuleContext<GreenPlumParser::Insert_column_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Insert_restContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Insert_restContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Insert_restContext::getRuleIndex() const {
  return GreenPlumParser::RuleInsert_rest;
}

void GreenPlumParser::Insert_restContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_rest(this);
}

void GreenPlumParser::Insert_restContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_rest(this);
}


antlrcpp::Any GreenPlumParser::Insert_restContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitInsert_rest(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Insert_restContext* GreenPlumParser::insert_rest() {
  Insert_restContext *_localctx = _tracker.createInstance<Insert_restContext>(_ctx, getState());
  enterRule(_localctx, 704, GreenPlumParser::RuleInsert_rest);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5010);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 503, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5002);
      select_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5003);
      match(GreenPlumParser::VALUES);
      setState(5004);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5005);
      insert_column_list();
      setState(5006);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5008);
      match(GreenPlumParser::DEFAULT);
      setState(5009);
      match(GreenPlumParser::VALUES);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_listContext ------------------------------------------------------------------

GreenPlumParser::Insert_column_listContext::Insert_column_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Insert_column_itemContext *> GreenPlumParser::Insert_column_listContext::insert_column_item() {
  return getRuleContexts<GreenPlumParser::Insert_column_itemContext>();
}

GreenPlumParser::Insert_column_itemContext* GreenPlumParser::Insert_column_listContext::insert_column_item(size_t i) {
  return getRuleContext<GreenPlumParser::Insert_column_itemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Insert_column_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Insert_column_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Insert_column_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleInsert_column_list;
}

void GreenPlumParser::Insert_column_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_column_list(this);
}

void GreenPlumParser::Insert_column_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_column_list(this);
}


antlrcpp::Any GreenPlumParser::Insert_column_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitInsert_column_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Insert_column_listContext* GreenPlumParser::insert_column_list() {
  Insert_column_listContext *_localctx = _tracker.createInstance<Insert_column_listContext>(_ctx, getState());
  enterRule(_localctx, 706, GreenPlumParser::RuleInsert_column_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5012);
    insert_column_item();
    setState(5017);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(5013);
      match(GreenPlumParser::COMMA);
      setState(5014);
      insert_column_item();
      setState(5019);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_itemContext ------------------------------------------------------------------

GreenPlumParser::Insert_column_itemContext::Insert_column_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Insert_column_itemContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::IndirectionContext* GreenPlumParser::Insert_column_itemContext::indirection() {
  return getRuleContext<GreenPlumParser::IndirectionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Insert_column_itemContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Insert_column_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleInsert_column_item;
}

void GreenPlumParser::Insert_column_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_column_item(this);
}

void GreenPlumParser::Insert_column_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_column_item(this);
}


antlrcpp::Any GreenPlumParser::Insert_column_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitInsert_column_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Insert_column_itemContext* GreenPlumParser::insert_column_item() {
  Insert_column_itemContext *_localctx = _tracker.createInstance<Insert_column_itemContext>(_ctx, getState());
  enterRule(_localctx, 708, GreenPlumParser::RuleInsert_column_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5025);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(5020);
        colid();
        setState(5022);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::PERIOD

        || _la == GreenPlumParser::LEFT_BRACKET) {
          setState(5021);
          indirection();
        }
        break;
      }

      case GreenPlumParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(5024);
        match(GreenPlumParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Returning_clauseContext ------------------------------------------------------------------

GreenPlumParser::Returning_clauseContext::Returning_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Returning_clauseContext::RETURNING() {
  return getToken(GreenPlumParser::RETURNING, 0);
}

GreenPlumParser::Target_listContext* GreenPlumParser::Returning_clauseContext::target_list() {
  return getRuleContext<GreenPlumParser::Target_listContext>(0);
}


size_t GreenPlumParser::Returning_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleReturning_clause;
}

void GreenPlumParser::Returning_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturning_clause(this);
}

void GreenPlumParser::Returning_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturning_clause(this);
}


antlrcpp::Any GreenPlumParser::Returning_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitReturning_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Returning_clauseContext* GreenPlumParser::returning_clause() {
  Returning_clauseContext *_localctx = _tracker.createInstance<Returning_clauseContext>(_ctx, getState());
  enterRule(_localctx, 710, GreenPlumParser::RuleReturning_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5027);
    match(GreenPlumParser::RETURNING);
    setState(5028);
    target_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

GreenPlumParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Delete_stmtContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Delete_stmtContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::Relation_expr_opt_aliasContext* GreenPlumParser::Delete_stmtContext::relation_expr_opt_alias() {
  return getRuleContext<GreenPlumParser::Relation_expr_opt_aliasContext>(0);
}

tree::TerminalNode* GreenPlumParser::Delete_stmtContext::ONLY() {
  return getToken(GreenPlumParser::ONLY, 0);
}

tree::TerminalNode* GreenPlumParser::Delete_stmtContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::From_listContext* GreenPlumParser::Delete_stmtContext::from_list() {
  return getRuleContext<GreenPlumParser::From_listContext>(0);
}

GreenPlumParser::Where_or_current_clauseContext* GreenPlumParser::Delete_stmtContext::where_or_current_clause() {
  return getRuleContext<GreenPlumParser::Where_or_current_clauseContext>(0);
}

GreenPlumParser::Returning_clauseContext* GreenPlumParser::Delete_stmtContext::returning_clause() {
  return getRuleContext<GreenPlumParser::Returning_clauseContext>(0);
}


size_t GreenPlumParser::Delete_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDelete_stmt;
}

void GreenPlumParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void GreenPlumParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


antlrcpp::Any GreenPlumParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Delete_stmtContext* GreenPlumParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 712, GreenPlumParser::RuleDelete_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5030);
    match(GreenPlumParser::DELETE_P);
    setState(5031);
    match(GreenPlumParser::FROM);
    setState(5033);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
    case 1: {
      setState(5032);
      match(GreenPlumParser::ONLY);
      break;
    }

    }
    setState(5035);
    relation_expr_opt_alias();
    setState(5038);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::USING) {
      setState(5036);
      match(GreenPlumParser::USING);
      setState(5037);
      from_list();
    }
    setState(5041);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WHERE) {
      setState(5040);
      where_or_current_clause();
    }
    setState(5044);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::RETURNING) {
      setState(5043);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lock_stmtContext ------------------------------------------------------------------

GreenPlumParser::Lock_stmtContext::Lock_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Lock_stmtContext::LOCK_P() {
  return getToken(GreenPlumParser::LOCK_P, 0);
}

GreenPlumParser::Qualified_name_listContext* GreenPlumParser::Lock_stmtContext::qualified_name_list() {
  return getRuleContext<GreenPlumParser::Qualified_name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Lock_stmtContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Opt_lockContext* GreenPlumParser::Lock_stmtContext::opt_lock() {
  return getRuleContext<GreenPlumParser::Opt_lockContext>(0);
}

tree::TerminalNode* GreenPlumParser::Lock_stmtContext::NOWAIT() {
  return getToken(GreenPlumParser::NOWAIT, 0);
}


size_t GreenPlumParser::Lock_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleLock_stmt;
}

void GreenPlumParser::Lock_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLock_stmt(this);
}

void GreenPlumParser::Lock_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLock_stmt(this);
}


antlrcpp::Any GreenPlumParser::Lock_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitLock_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Lock_stmtContext* GreenPlumParser::lock_stmt() {
  Lock_stmtContext *_localctx = _tracker.createInstance<Lock_stmtContext>(_ctx, getState());
  enterRule(_localctx, 714, GreenPlumParser::RuleLock_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5046);
    match(GreenPlumParser::LOCK_P);
    setState(5048);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TABLE) {
      setState(5047);
      match(GreenPlumParser::TABLE);
    }
    setState(5050);
    qualified_name_list();
    setState(5052);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::IN_P) {
      setState(5051);
      opt_lock();
    }
    setState(5055);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::NOWAIT) {
      setState(5054);
      match(GreenPlumParser::NOWAIT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_lockContext ------------------------------------------------------------------

GreenPlumParser::Opt_lockContext::Opt_lockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_lockContext::IN_P() {
  return getToken(GreenPlumParser::IN_P, 0);
}

GreenPlumParser::Lock_typeContext* GreenPlumParser::Opt_lockContext::lock_type() {
  return getRuleContext<GreenPlumParser::Lock_typeContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_lockContext::MODE() {
  return getToken(GreenPlumParser::MODE, 0);
}


size_t GreenPlumParser::Opt_lockContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_lock;
}

void GreenPlumParser::Opt_lockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_lock(this);
}

void GreenPlumParser::Opt_lockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_lock(this);
}


antlrcpp::Any GreenPlumParser::Opt_lockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_lock(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_lockContext* GreenPlumParser::opt_lock() {
  Opt_lockContext *_localctx = _tracker.createInstance<Opt_lockContext>(_ctx, getState());
  enterRule(_localctx, 716, GreenPlumParser::RuleOpt_lock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5057);
    match(GreenPlumParser::IN_P);
    setState(5058);
    lock_type();
    setState(5059);
    match(GreenPlumParser::MODE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lock_typeContext ------------------------------------------------------------------

GreenPlumParser::Lock_typeContext::Lock_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Lock_typeContext::SHARE() {
  return getToken(GreenPlumParser::SHARE, 0);
}

tree::TerminalNode* GreenPlumParser::Lock_typeContext::ACCESS() {
  return getToken(GreenPlumParser::ACCESS, 0);
}

tree::TerminalNode* GreenPlumParser::Lock_typeContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

tree::TerminalNode* GreenPlumParser::Lock_typeContext::EXCLUSIVE() {
  return getToken(GreenPlumParser::EXCLUSIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Lock_typeContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}


size_t GreenPlumParser::Lock_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleLock_type;
}

void GreenPlumParser::Lock_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLock_type(this);
}

void GreenPlumParser::Lock_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLock_type(this);
}


antlrcpp::Any GreenPlumParser::Lock_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitLock_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Lock_typeContext* GreenPlumParser::lock_type() {
  Lock_typeContext *_localctx = _tracker.createInstance<Lock_typeContext>(_ctx, getState());
  enterRule(_localctx, 718, GreenPlumParser::RuleLock_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5072);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5062);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ACCESS || _la == GreenPlumParser::ROW) {
        setState(5061);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::ACCESS || _la == GreenPlumParser::ROW)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(5064);
      match(GreenPlumParser::SHARE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5069);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GreenPlumParser::ROW: {
          setState(5065);
          match(GreenPlumParser::ROW);
          break;
        }

        case GreenPlumParser::SHARE: {
          setState(5066);
          match(GreenPlumParser::SHARE);
          setState(5067);
          _la = _input->LA(1);
          if (!(_la == GreenPlumParser::ROW || _la == GreenPlumParser::UPDATE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case GreenPlumParser::ACCESS: {
          setState(5068);
          match(GreenPlumParser::ACCESS);
          break;
        }

        case GreenPlumParser::EXCLUSIVE: {
          break;
        }

      default:
        break;
      }
      setState(5071);
      match(GreenPlumParser::EXCLUSIVE);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmtContext ------------------------------------------------------------------

GreenPlumParser::Update_stmtContext::Update_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Update_stmtContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

GreenPlumParser::Relation_expr_opt_aliasContext* GreenPlumParser::Update_stmtContext::relation_expr_opt_alias() {
  return getRuleContext<GreenPlumParser::Relation_expr_opt_aliasContext>(0);
}

tree::TerminalNode* GreenPlumParser::Update_stmtContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

GreenPlumParser::Set_clause_listContext* GreenPlumParser::Update_stmtContext::set_clause_list() {
  return getRuleContext<GreenPlumParser::Set_clause_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Update_stmtContext::ONLY() {
  return getToken(GreenPlumParser::ONLY, 0);
}

GreenPlumParser::From_clauseContext* GreenPlumParser::Update_stmtContext::from_clause() {
  return getRuleContext<GreenPlumParser::From_clauseContext>(0);
}

GreenPlumParser::Where_or_current_clauseContext* GreenPlumParser::Update_stmtContext::where_or_current_clause() {
  return getRuleContext<GreenPlumParser::Where_or_current_clauseContext>(0);
}

GreenPlumParser::Returning_clauseContext* GreenPlumParser::Update_stmtContext::returning_clause() {
  return getRuleContext<GreenPlumParser::Returning_clauseContext>(0);
}


size_t GreenPlumParser::Update_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleUpdate_stmt;
}

void GreenPlumParser::Update_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt(this);
}

void GreenPlumParser::Update_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt(this);
}


antlrcpp::Any GreenPlumParser::Update_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Update_stmtContext* GreenPlumParser::update_stmt() {
  Update_stmtContext *_localctx = _tracker.createInstance<Update_stmtContext>(_ctx, getState());
  enterRule(_localctx, 720, GreenPlumParser::RuleUpdate_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5074);
    match(GreenPlumParser::UPDATE);
    setState(5076);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx)) {
    case 1: {
      setState(5075);
      match(GreenPlumParser::ONLY);
      break;
    }

    }
    setState(5078);
    relation_expr_opt_alias();
    setState(5079);
    match(GreenPlumParser::SET);
    setState(5080);
    set_clause_list();
    setState(5082);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::FROM) {
      setState(5081);
      from_clause();
    }
    setState(5085);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WHERE) {
      setState(5084);
      where_or_current_clause();
    }
    setState(5088);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::RETURNING) {
      setState(5087);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_clause_listContext ------------------------------------------------------------------

GreenPlumParser::Set_clause_listContext::Set_clause_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Set_clauseContext *> GreenPlumParser::Set_clause_listContext::set_clause() {
  return getRuleContexts<GreenPlumParser::Set_clauseContext>();
}

GreenPlumParser::Set_clauseContext* GreenPlumParser::Set_clause_listContext::set_clause(size_t i) {
  return getRuleContext<GreenPlumParser::Set_clauseContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Set_clause_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Set_clause_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Set_clause_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleSet_clause_list;
}

void GreenPlumParser::Set_clause_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_clause_list(this);
}

void GreenPlumParser::Set_clause_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_clause_list(this);
}


antlrcpp::Any GreenPlumParser::Set_clause_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSet_clause_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Set_clause_listContext* GreenPlumParser::set_clause_list() {
  Set_clause_listContext *_localctx = _tracker.createInstance<Set_clause_listContext>(_ctx, getState());
  enterRule(_localctx, 722, GreenPlumParser::RuleSet_clause_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5090);
    set_clause();
    setState(5095);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(5091);
      match(GreenPlumParser::COMMA);
      setState(5092);
      set_clause();
      setState(5097);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_clauseContext ------------------------------------------------------------------

GreenPlumParser::Set_clauseContext::Set_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Single_set_clauseContext* GreenPlumParser::Set_clauseContext::single_set_clause() {
  return getRuleContext<GreenPlumParser::Single_set_clauseContext>(0);
}

GreenPlumParser::Multiple_set_clauseContext* GreenPlumParser::Set_clauseContext::multiple_set_clause() {
  return getRuleContext<GreenPlumParser::Multiple_set_clauseContext>(0);
}


size_t GreenPlumParser::Set_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleSet_clause;
}

void GreenPlumParser::Set_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_clause(this);
}

void GreenPlumParser::Set_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_clause(this);
}


antlrcpp::Any GreenPlumParser::Set_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSet_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Set_clauseContext* GreenPlumParser::set_clause() {
  Set_clauseContext *_localctx = _tracker.createInstance<Set_clauseContext>(_ctx, getState());
  enterRule(_localctx, 724, GreenPlumParser::RuleSet_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5100);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 1);
        setState(5098);
        single_set_clause();
        break;
      }

      case GreenPlumParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(5099);
        multiple_set_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Single_set_clauseContext ------------------------------------------------------------------

GreenPlumParser::Single_set_clauseContext::Single_set_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Set_targetContext* GreenPlumParser::Single_set_clauseContext::set_target() {
  return getRuleContext<GreenPlumParser::Set_targetContext>(0);
}

tree::TerminalNode* GreenPlumParser::Single_set_clauseContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

GreenPlumParser::Ctext_exprContext* GreenPlumParser::Single_set_clauseContext::ctext_expr() {
  return getRuleContext<GreenPlumParser::Ctext_exprContext>(0);
}


size_t GreenPlumParser::Single_set_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleSingle_set_clause;
}

void GreenPlumParser::Single_set_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_set_clause(this);
}

void GreenPlumParser::Single_set_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_set_clause(this);
}


antlrcpp::Any GreenPlumParser::Single_set_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSingle_set_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Single_set_clauseContext* GreenPlumParser::single_set_clause() {
  Single_set_clauseContext *_localctx = _tracker.createInstance<Single_set_clauseContext>(_ctx, getState());
  enterRule(_localctx, 726, GreenPlumParser::RuleSingle_set_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5102);
    set_target();
    setState(5103);
    match(GreenPlumParser::EQUALS_OP);
    setState(5104);
    ctext_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multiple_set_clauseContext ------------------------------------------------------------------

GreenPlumParser::Multiple_set_clauseContext::Multiple_set_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Multiple_set_clauseContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Set_target_listContext* GreenPlumParser::Multiple_set_clauseContext::set_target_list() {
  return getRuleContext<GreenPlumParser::Set_target_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Multiple_set_clauseContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Multiple_set_clauseContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

GreenPlumParser::Ctext_rowContext* GreenPlumParser::Multiple_set_clauseContext::ctext_row() {
  return getRuleContext<GreenPlumParser::Ctext_rowContext>(0);
}


size_t GreenPlumParser::Multiple_set_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleMultiple_set_clause;
}

void GreenPlumParser::Multiple_set_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiple_set_clause(this);
}

void GreenPlumParser::Multiple_set_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiple_set_clause(this);
}


antlrcpp::Any GreenPlumParser::Multiple_set_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitMultiple_set_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Multiple_set_clauseContext* GreenPlumParser::multiple_set_clause() {
  Multiple_set_clauseContext *_localctx = _tracker.createInstance<Multiple_set_clauseContext>(_ctx, getState());
  enterRule(_localctx, 728, GreenPlumParser::RuleMultiple_set_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5106);
    match(GreenPlumParser::LEFT_PAREN);
    setState(5107);
    set_target_list();
    setState(5108);
    match(GreenPlumParser::RIGHT_PAREN);
    setState(5109);
    match(GreenPlumParser::EQUALS_OP);
    setState(5110);
    ctext_row();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_targetContext ------------------------------------------------------------------

GreenPlumParser::Set_targetContext::Set_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Set_targetContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::IndirectionContext* GreenPlumParser::Set_targetContext::indirection() {
  return getRuleContext<GreenPlumParser::IndirectionContext>(0);
}


size_t GreenPlumParser::Set_targetContext::getRuleIndex() const {
  return GreenPlumParser::RuleSet_target;
}

void GreenPlumParser::Set_targetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_target(this);
}

void GreenPlumParser::Set_targetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_target(this);
}


antlrcpp::Any GreenPlumParser::Set_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSet_target(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Set_targetContext* GreenPlumParser::set_target() {
  Set_targetContext *_localctx = _tracker.createInstance<Set_targetContext>(_ctx, getState());
  enterRule(_localctx, 730, GreenPlumParser::RuleSet_target);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5112);
    colid();
    setState(5114);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PERIOD

    || _la == GreenPlumParser::LEFT_BRACKET) {
      setState(5113);
      indirection();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_target_listContext ------------------------------------------------------------------

GreenPlumParser::Set_target_listContext::Set_target_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Set_targetContext *> GreenPlumParser::Set_target_listContext::set_target() {
  return getRuleContexts<GreenPlumParser::Set_targetContext>();
}

GreenPlumParser::Set_targetContext* GreenPlumParser::Set_target_listContext::set_target(size_t i) {
  return getRuleContext<GreenPlumParser::Set_targetContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Set_target_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Set_target_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Set_target_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleSet_target_list;
}

void GreenPlumParser::Set_target_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_target_list(this);
}

void GreenPlumParser::Set_target_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_target_list(this);
}


antlrcpp::Any GreenPlumParser::Set_target_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSet_target_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Set_target_listContext* GreenPlumParser::set_target_list() {
  Set_target_listContext *_localctx = _tracker.createInstance<Set_target_listContext>(_ctx, getState());
  enterRule(_localctx, 732, GreenPlumParser::RuleSet_target_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5116);
    set_target();
    setState(5121);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(5117);
      match(GreenPlumParser::COMMA);
      setState(5118);
      set_target();
      setState(5123);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_cursor_stmtContext ------------------------------------------------------------------

GreenPlumParser::Declare_cursor_stmtContext::Declare_cursor_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Declare_cursor_stmtContext::DECLARE() {
  return getToken(GreenPlumParser::DECLARE, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Declare_cursor_stmtContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Declare_cursor_stmtContext::CURSOR() {
  return getToken(GreenPlumParser::CURSOR, 0);
}

tree::TerminalNode* GreenPlumParser::Declare_cursor_stmtContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Declare_cursor_stmtContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

std::vector<GreenPlumParser::Cursor_optionContext *> GreenPlumParser::Declare_cursor_stmtContext::cursor_option() {
  return getRuleContexts<GreenPlumParser::Cursor_optionContext>();
}

GreenPlumParser::Cursor_optionContext* GreenPlumParser::Declare_cursor_stmtContext::cursor_option(size_t i) {
  return getRuleContext<GreenPlumParser::Cursor_optionContext>(i);
}

GreenPlumParser::Opt_holdContext* GreenPlumParser::Declare_cursor_stmtContext::opt_hold() {
  return getRuleContext<GreenPlumParser::Opt_holdContext>(0);
}


size_t GreenPlumParser::Declare_cursor_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleDeclare_cursor_stmt;
}

void GreenPlumParser::Declare_cursor_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_cursor_stmt(this);
}

void GreenPlumParser::Declare_cursor_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_cursor_stmt(this);
}


antlrcpp::Any GreenPlumParser::Declare_cursor_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDeclare_cursor_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Declare_cursor_stmtContext* GreenPlumParser::declare_cursor_stmt() {
  Declare_cursor_stmtContext *_localctx = _tracker.createInstance<Declare_cursor_stmtContext>(_ctx, getState());
  enterRule(_localctx, 734, GreenPlumParser::RuleDeclare_cursor_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5124);
    match(GreenPlumParser::DECLARE);
    setState(5125);
    name();
    setState(5129);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::BINARY || _la == GreenPlumParser::INSENSITIVE

    || _la == GreenPlumParser::NO || _la == GreenPlumParser::SCROLL) {
      setState(5126);
      cursor_option();
      setState(5131);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5132);
    match(GreenPlumParser::CURSOR);
    setState(5134);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT) {
      setState(5133);
      opt_hold();
    }
    setState(5136);
    match(GreenPlumParser::FOR);
    setState(5137);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_optionContext ------------------------------------------------------------------

GreenPlumParser::Cursor_optionContext::Cursor_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Cursor_optionContext::SCROLL() {
  return getToken(GreenPlumParser::SCROLL, 0);
}

tree::TerminalNode* GreenPlumParser::Cursor_optionContext::BINARY() {
  return getToken(GreenPlumParser::BINARY, 0);
}

tree::TerminalNode* GreenPlumParser::Cursor_optionContext::INSENSITIVE() {
  return getToken(GreenPlumParser::INSENSITIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Cursor_optionContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}


size_t GreenPlumParser::Cursor_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleCursor_option;
}

void GreenPlumParser::Cursor_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_option(this);
}

void GreenPlumParser::Cursor_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_option(this);
}


antlrcpp::Any GreenPlumParser::Cursor_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCursor_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cursor_optionContext* GreenPlumParser::cursor_option() {
  Cursor_optionContext *_localctx = _tracker.createInstance<Cursor_optionContext>(_ctx, getState());
  enterRule(_localctx, 736, GreenPlumParser::RuleCursor_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5145);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::NO:
      case GreenPlumParser::SCROLL: {
        setState(5140);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::NO) {
          setState(5139);
          match(GreenPlumParser::NO);
        }
        setState(5142);
        match(GreenPlumParser::SCROLL);
        break;
      }

      case GreenPlumParser::BINARY: {
        setState(5143);
        match(GreenPlumParser::BINARY);
        break;
      }

      case GreenPlumParser::INSENSITIVE: {
        setState(5144);
        match(GreenPlumParser::INSENSITIVE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_holdContext ------------------------------------------------------------------

GreenPlumParser::Opt_holdContext::Opt_holdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_holdContext::HOLD() {
  return getToken(GreenPlumParser::HOLD, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_holdContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_holdContext::WITHOUT() {
  return getToken(GreenPlumParser::WITHOUT, 0);
}


size_t GreenPlumParser::Opt_holdContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_hold;
}

void GreenPlumParser::Opt_holdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_hold(this);
}

void GreenPlumParser::Opt_holdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_hold(this);
}


antlrcpp::Any GreenPlumParser::Opt_holdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_hold(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_holdContext* GreenPlumParser::opt_hold() {
  Opt_holdContext *_localctx = _tracker.createInstance<Opt_holdContext>(_ctx, getState());
  enterRule(_localctx, 738, GreenPlumParser::RuleOpt_hold);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5147);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5148);
    match(GreenPlumParser::HOLD);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_stmtContext ------------------------------------------------------------------

GreenPlumParser::Select_stmtContext::Select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Subquery_basic_elementsContext* GreenPlumParser::Select_stmtContext::subquery_basic_elements() {
  return getRuleContext<GreenPlumParser::Subquery_basic_elementsContext>(0);
}

std::vector<GreenPlumParser::Subquery_operation_partContext *> GreenPlumParser::Select_stmtContext::subquery_operation_part() {
  return getRuleContexts<GreenPlumParser::Subquery_operation_partContext>();
}

GreenPlumParser::Subquery_operation_partContext* GreenPlumParser::Select_stmtContext::subquery_operation_part(size_t i) {
  return getRuleContext<GreenPlumParser::Subquery_operation_partContext>(i);
}


size_t GreenPlumParser::Select_stmtContext::getRuleIndex() const {
  return GreenPlumParser::RuleSelect_stmt;
}

void GreenPlumParser::Select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_stmt(this);
}

void GreenPlumParser::Select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_stmt(this);
}


antlrcpp::Any GreenPlumParser::Select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSelect_stmt(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::select_stmt() {
  Select_stmtContext *_localctx = _tracker.createInstance<Select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 740, GreenPlumParser::RuleSelect_stmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5150);
    subquery_basic_elements();
    setState(5154);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5151);
        subquery_operation_part(); 
      }
      setState(5156);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subquery_basic_elementsContext ------------------------------------------------------------------

GreenPlumParser::Subquery_basic_elementsContext::Subquery_basic_elementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Select_no_parensContext* GreenPlumParser::Subquery_basic_elementsContext::select_no_parens() {
  return getRuleContext<GreenPlumParser::Select_no_parensContext>(0);
}

GreenPlumParser::Select_with_parensContext* GreenPlumParser::Subquery_basic_elementsContext::select_with_parens() {
  return getRuleContext<GreenPlumParser::Select_with_parensContext>(0);
}


size_t GreenPlumParser::Subquery_basic_elementsContext::getRuleIndex() const {
  return GreenPlumParser::RuleSubquery_basic_elements;
}

void GreenPlumParser::Subquery_basic_elementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery_basic_elements(this);
}

void GreenPlumParser::Subquery_basic_elementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery_basic_elements(this);
}


antlrcpp::Any GreenPlumParser::Subquery_basic_elementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSubquery_basic_elements(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Subquery_basic_elementsContext* GreenPlumParser::subquery_basic_elements() {
  Subquery_basic_elementsContext *_localctx = _tracker.createInstance<Subquery_basic_elementsContext>(_ctx, getState());
  enterRule(_localctx, 742, GreenPlumParser::RuleSubquery_basic_elements);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5159);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::SELECT:
      case GreenPlumParser::VALUES:
      case GreenPlumParser::WITH: {
        enterOuterAlt(_localctx, 1);
        setState(5157);
        select_no_parens();
        break;
      }

      case GreenPlumParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(5158);
        select_with_parens();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subquery_operation_partContext ------------------------------------------------------------------

GreenPlumParser::Subquery_operation_partContext::Subquery_operation_partContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Subquery_basic_elementsContext* GreenPlumParser::Subquery_operation_partContext::subquery_basic_elements() {
  return getRuleContext<GreenPlumParser::Subquery_basic_elementsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Subquery_operation_partContext::UNION() {
  return getToken(GreenPlumParser::UNION, 0);
}

tree::TerminalNode* GreenPlumParser::Subquery_operation_partContext::INTERSECT() {
  return getToken(GreenPlumParser::INTERSECT, 0);
}

tree::TerminalNode* GreenPlumParser::Subquery_operation_partContext::EXCEPT() {
  return getToken(GreenPlumParser::EXCEPT, 0);
}

tree::TerminalNode* GreenPlumParser::Subquery_operation_partContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}


size_t GreenPlumParser::Subquery_operation_partContext::getRuleIndex() const {
  return GreenPlumParser::RuleSubquery_operation_part;
}

void GreenPlumParser::Subquery_operation_partContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery_operation_part(this);
}

void GreenPlumParser::Subquery_operation_partContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery_operation_part(this);
}


antlrcpp::Any GreenPlumParser::Subquery_operation_partContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSubquery_operation_part(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Subquery_operation_partContext* GreenPlumParser::subquery_operation_part() {
  Subquery_operation_partContext *_localctx = _tracker.createInstance<Subquery_operation_partContext>(_ctx, getState());
  enterRule(_localctx, 744, GreenPlumParser::RuleSubquery_operation_part);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5161);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::EXCEPT || _la == GreenPlumParser::INTERSECT || _la == GreenPlumParser::UNION)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5163);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ALL) {
      setState(5162);
      match(GreenPlumParser::ALL);
    }
    setState(5165);
    subquery_basic_elements();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_with_parensContext ------------------------------------------------------------------

GreenPlumParser::Select_with_parensContext::Select_with_parensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Select_with_parensContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Select_with_parensContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

tree::TerminalNode* GreenPlumParser::Select_with_parensContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Select_with_parensContext::getRuleIndex() const {
  return GreenPlumParser::RuleSelect_with_parens;
}

void GreenPlumParser::Select_with_parensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_with_parens(this);
}

void GreenPlumParser::Select_with_parensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_with_parens(this);
}


antlrcpp::Any GreenPlumParser::Select_with_parensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSelect_with_parens(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Select_with_parensContext* GreenPlumParser::select_with_parens() {
  Select_with_parensContext *_localctx = _tracker.createInstance<Select_with_parensContext>(_ctx, getState());
  enterRule(_localctx, 746, GreenPlumParser::RuleSelect_with_parens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5167);
    match(GreenPlumParser::LEFT_PAREN);
    setState(5168);
    select_stmt();
    setState(5169);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_no_parensContext ------------------------------------------------------------------

GreenPlumParser::Select_no_parensContext::Select_no_parensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Simple_selectContext* GreenPlumParser::Select_no_parensContext::simple_select() {
  return getRuleContext<GreenPlumParser::Simple_selectContext>(0);
}

GreenPlumParser::With_clauseContext* GreenPlumParser::Select_no_parensContext::with_clause() {
  return getRuleContext<GreenPlumParser::With_clauseContext>(0);
}

GreenPlumParser::Sort_clauseContext* GreenPlumParser::Select_no_parensContext::sort_clause() {
  return getRuleContext<GreenPlumParser::Sort_clauseContext>(0);
}

GreenPlumParser::Select_limitContext* GreenPlumParser::Select_no_parensContext::select_limit() {
  return getRuleContext<GreenPlumParser::Select_limitContext>(0);
}

GreenPlumParser::For_locking_clauseContext* GreenPlumParser::Select_no_parensContext::for_locking_clause() {
  return getRuleContext<GreenPlumParser::For_locking_clauseContext>(0);
}


size_t GreenPlumParser::Select_no_parensContext::getRuleIndex() const {
  return GreenPlumParser::RuleSelect_no_parens;
}

void GreenPlumParser::Select_no_parensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_no_parens(this);
}

void GreenPlumParser::Select_no_parensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_no_parens(this);
}


antlrcpp::Any GreenPlumParser::Select_no_parensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSelect_no_parens(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Select_no_parensContext* GreenPlumParser::select_no_parens() {
  Select_no_parensContext *_localctx = _tracker.createInstance<Select_no_parensContext>(_ctx, getState());
  enterRule(_localctx, 748, GreenPlumParser::RuleSelect_no_parens);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5172);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::WITH) {
      setState(5171);
      with_clause();
    }
    setState(5174);
    simple_select();
    setState(5176);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 533, _ctx)) {
    case 1: {
      setState(5175);
      sort_clause();
      break;
    }

    }
    setState(5179);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 534, _ctx)) {
    case 1: {
      setState(5178);
      select_limit();
      break;
    }

    }
    setState(5182);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 535, _ctx)) {
    case 1: {
      setState(5181);
      for_locking_clause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_selectContext ------------------------------------------------------------------

GreenPlumParser::Simple_selectContext::Simple_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Simple_selectContext::SELECT() {
  return getToken(GreenPlumParser::SELECT, 0);
}

GreenPlumParser::Target_listContext* GreenPlumParser::Simple_selectContext::target_list() {
  return getRuleContext<GreenPlumParser::Target_listContext>(0);
}

GreenPlumParser::Opt_distinctContext* GreenPlumParser::Simple_selectContext::opt_distinct() {
  return getRuleContext<GreenPlumParser::Opt_distinctContext>(0);
}

GreenPlumParser::Into_clauseContext* GreenPlumParser::Simple_selectContext::into_clause() {
  return getRuleContext<GreenPlumParser::Into_clauseContext>(0);
}

GreenPlumParser::From_clauseContext* GreenPlumParser::Simple_selectContext::from_clause() {
  return getRuleContext<GreenPlumParser::From_clauseContext>(0);
}

GreenPlumParser::Where_clauseContext* GreenPlumParser::Simple_selectContext::where_clause() {
  return getRuleContext<GreenPlumParser::Where_clauseContext>(0);
}

GreenPlumParser::Group_clauseContext* GreenPlumParser::Simple_selectContext::group_clause() {
  return getRuleContext<GreenPlumParser::Group_clauseContext>(0);
}

GreenPlumParser::Having_clauseContext* GreenPlumParser::Simple_selectContext::having_clause() {
  return getRuleContext<GreenPlumParser::Having_clauseContext>(0);
}

GreenPlumParser::Window_clauseContext* GreenPlumParser::Simple_selectContext::window_clause() {
  return getRuleContext<GreenPlumParser::Window_clauseContext>(0);
}

GreenPlumParser::Values_clauseContext* GreenPlumParser::Simple_selectContext::values_clause() {
  return getRuleContext<GreenPlumParser::Values_clauseContext>(0);
}


size_t GreenPlumParser::Simple_selectContext::getRuleIndex() const {
  return GreenPlumParser::RuleSimple_select;
}

void GreenPlumParser::Simple_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_select(this);
}

void GreenPlumParser::Simple_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_select(this);
}


antlrcpp::Any GreenPlumParser::Simple_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSimple_select(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Simple_selectContext* GreenPlumParser::simple_select() {
  Simple_selectContext *_localctx = _tracker.createInstance<Simple_selectContext>(_ctx, getState());
  enterRule(_localctx, 750, GreenPlumParser::RuleSimple_select);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5208);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::SELECT: {
        enterOuterAlt(_localctx, 1);
        setState(5184);
        match(GreenPlumParser::SELECT);
        setState(5186);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::ALL || _la == GreenPlumParser::DISTINCT) {
          setState(5185);
          opt_distinct();
        }
        setState(5188);
        target_list();
        setState(5190);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 537, _ctx)) {
        case 1: {
          setState(5189);
          into_clause();
          break;
        }

        }
        setState(5193);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 538, _ctx)) {
        case 1: {
          setState(5192);
          from_clause();
          break;
        }

        }
        setState(5196);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 539, _ctx)) {
        case 1: {
          setState(5195);
          where_clause();
          break;
        }

        }
        setState(5199);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 540, _ctx)) {
        case 1: {
          setState(5198);
          group_clause();
          break;
        }

        }
        setState(5202);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 541, _ctx)) {
        case 1: {
          setState(5201);
          having_clause();
          break;
        }

        }
        setState(5205);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 542, _ctx)) {
        case 1: {
          setState(5204);
          window_clause();
          break;
        }

        }
        break;
      }

      case GreenPlumParser::VALUES: {
        enterOuterAlt(_localctx, 2);
        setState(5207);
        values_clause(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_clauseContext ------------------------------------------------------------------

GreenPlumParser::With_clauseContext::With_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::With_clauseContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

GreenPlumParser::Cte_listContext* GreenPlumParser::With_clauseContext::cte_list() {
  return getRuleContext<GreenPlumParser::Cte_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::With_clauseContext::RECURSIVE() {
  return getToken(GreenPlumParser::RECURSIVE, 0);
}


size_t GreenPlumParser::With_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleWith_clause;
}

void GreenPlumParser::With_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_clause(this);
}

void GreenPlumParser::With_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_clause(this);
}


antlrcpp::Any GreenPlumParser::With_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWith_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::With_clauseContext* GreenPlumParser::with_clause() {
  With_clauseContext *_localctx = _tracker.createInstance<With_clauseContext>(_ctx, getState());
  enterRule(_localctx, 752, GreenPlumParser::RuleWith_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5210);
    match(GreenPlumParser::WITH);
    setState(5212);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 544, _ctx)) {
    case 1: {
      setState(5211);
      match(GreenPlumParser::RECURSIVE);
      break;
    }

    }
    setState(5214);
    cte_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_listContext ------------------------------------------------------------------

GreenPlumParser::Cte_listContext::Cte_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Common_table_exprContext *> GreenPlumParser::Cte_listContext::common_table_expr() {
  return getRuleContexts<GreenPlumParser::Common_table_exprContext>();
}

GreenPlumParser::Common_table_exprContext* GreenPlumParser::Cte_listContext::common_table_expr(size_t i) {
  return getRuleContext<GreenPlumParser::Common_table_exprContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Cte_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Cte_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Cte_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleCte_list;
}

void GreenPlumParser::Cte_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_list(this);
}

void GreenPlumParser::Cte_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_list(this);
}


antlrcpp::Any GreenPlumParser::Cte_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCte_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cte_listContext* GreenPlumParser::cte_list() {
  Cte_listContext *_localctx = _tracker.createInstance<Cte_listContext>(_ctx, getState());
  enterRule(_localctx, 754, GreenPlumParser::RuleCte_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5216);
    common_table_expr();
    setState(5221);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(5217);
      match(GreenPlumParser::COMMA);
      setState(5218);
      common_table_expr();
      setState(5223);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_exprContext ------------------------------------------------------------------

GreenPlumParser::Common_table_exprContext::Common_table_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Cte_nameContext* GreenPlumParser::Common_table_exprContext::cte_name() {
  return getRuleContext<GreenPlumParser::Cte_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Common_table_exprContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Select_with_parensContext* GreenPlumParser::Common_table_exprContext::select_with_parens() {
  return getRuleContext<GreenPlumParser::Select_with_parensContext>(0);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::Common_table_exprContext::paren_name_list() {
  return getRuleContext<GreenPlumParser::Paren_name_listContext>(0);
}


size_t GreenPlumParser::Common_table_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleCommon_table_expr;
}

void GreenPlumParser::Common_table_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_expr(this);
}

void GreenPlumParser::Common_table_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_expr(this);
}


antlrcpp::Any GreenPlumParser::Common_table_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCommon_table_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Common_table_exprContext* GreenPlumParser::common_table_expr() {
  Common_table_exprContext *_localctx = _tracker.createInstance<Common_table_exprContext>(_ctx, getState());
  enterRule(_localctx, 756, GreenPlumParser::RuleCommon_table_expr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5224);
    cte_name();
    setState(5226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::LEFT_PAREN) {
      setState(5225);
      paren_name_list();
    }
    setState(5228);
    match(GreenPlumParser::AS);
    setState(5229);
    select_with_parens();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Into_clauseContext ------------------------------------------------------------------

GreenPlumParser::Into_clauseContext::Into_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Into_clauseContext::INTO() {
  return getToken(GreenPlumParser::INTO, 0);
}

GreenPlumParser::Opt_tempTableNameContext* GreenPlumParser::Into_clauseContext::opt_tempTableName() {
  return getRuleContext<GreenPlumParser::Opt_tempTableNameContext>(0);
}


size_t GreenPlumParser::Into_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleInto_clause;
}

void GreenPlumParser::Into_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInto_clause(this);
}

void GreenPlumParser::Into_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInto_clause(this);
}


antlrcpp::Any GreenPlumParser::Into_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitInto_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Into_clauseContext* GreenPlumParser::into_clause() {
  Into_clauseContext *_localctx = _tracker.createInstance<Into_clauseContext>(_ctx, getState());
  enterRule(_localctx, 758, GreenPlumParser::RuleInto_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5231);
    match(GreenPlumParser::INTO);
    setState(5233);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 547, _ctx)) {
    case 1: {
      setState(5232);
      opt_tempTableName();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_tempTableNameContext ------------------------------------------------------------------

GreenPlumParser::Opt_tempTableNameContext::Opt_tempTableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Opt_tempTableNameContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempTableNameContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempTableNameContext::TEMPORARY() {
  return getToken(GreenPlumParser::TEMPORARY, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempTableNameContext::TEMP() {
  return getToken(GreenPlumParser::TEMP, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempTableNameContext::LOCAL() {
  return getToken(GreenPlumParser::LOCAL, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_tempTableNameContext::GLOBAL() {
  return getToken(GreenPlumParser::GLOBAL, 0);
}


size_t GreenPlumParser::Opt_tempTableNameContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_tempTableName;
}

void GreenPlumParser::Opt_tempTableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_tempTableName(this);
}

void GreenPlumParser::Opt_tempTableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_tempTableName(this);
}


antlrcpp::Any GreenPlumParser::Opt_tempTableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_tempTableName(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_tempTableNameContext* GreenPlumParser::opt_tempTableName() {
  Opt_tempTableNameContext *_localctx = _tracker.createInstance<Opt_tempTableNameContext>(_ctx, getState());
  enterRule(_localctx, 760, GreenPlumParser::RuleOpt_tempTableName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5239);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 549, _ctx)) {
    case 1: {
      setState(5236);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::GLOBAL

      || _la == GreenPlumParser::LOCAL) {
        setState(5235);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::GLOBAL

        || _la == GreenPlumParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(5238);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::TEMP

      || _la == GreenPlumParser::TEMPORARY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(5242);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::TABLE) {
      setState(5241);
      match(GreenPlumParser::TABLE);
    }
    setState(5244);
    qualified_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_distinctContext ------------------------------------------------------------------

GreenPlumParser::Opt_distinctContext::Opt_distinctContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_distinctContext::DISTINCT() {
  return getToken(GreenPlumParser::DISTINCT, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_distinctContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Opt_distinctContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_distinctContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}


size_t GreenPlumParser::Opt_distinctContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_distinct;
}

void GreenPlumParser::Opt_distinctContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_distinct(this);
}

void GreenPlumParser::Opt_distinctContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_distinct(this);
}


antlrcpp::Any GreenPlumParser::Opt_distinctContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_distinct(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_distinctContext* GreenPlumParser::opt_distinct() {
  Opt_distinctContext *_localctx = _tracker.createInstance<Opt_distinctContext>(_ctx, getState());
  enterRule(_localctx, 762, GreenPlumParser::RuleOpt_distinct);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5252);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::DISTINCT: {
        enterOuterAlt(_localctx, 1);
        setState(5246);
        match(GreenPlumParser::DISTINCT);
        setState(5249);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::ON) {
          setState(5247);
          match(GreenPlumParser::ON);
          setState(5248);
          paren_expr_list();
        }
        break;
      }

      case GreenPlumParser::ALL: {
        enterOuterAlt(_localctx, 2);
        setState(5251);
        match(GreenPlumParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sort_clauseContext ------------------------------------------------------------------

GreenPlumParser::Sort_clauseContext::Sort_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Sort_clauseContext::ORDER() {
  return getToken(GreenPlumParser::ORDER, 0);
}

tree::TerminalNode* GreenPlumParser::Sort_clauseContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Sortby_listContext* GreenPlumParser::Sort_clauseContext::sortby_list() {
  return getRuleContext<GreenPlumParser::Sortby_listContext>(0);
}


size_t GreenPlumParser::Sort_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleSort_clause;
}

void GreenPlumParser::Sort_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSort_clause(this);
}

void GreenPlumParser::Sort_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSort_clause(this);
}


antlrcpp::Any GreenPlumParser::Sort_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSort_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Sort_clauseContext* GreenPlumParser::sort_clause() {
  Sort_clauseContext *_localctx = _tracker.createInstance<Sort_clauseContext>(_ctx, getState());
  enterRule(_localctx, 764, GreenPlumParser::RuleSort_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5254);
    match(GreenPlumParser::ORDER);
    setState(5255);
    match(GreenPlumParser::BY);
    setState(5256);
    sortby_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sortby_listContext ------------------------------------------------------------------

GreenPlumParser::Sortby_listContext::Sortby_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::SortbyContext *> GreenPlumParser::Sortby_listContext::sortby() {
  return getRuleContexts<GreenPlumParser::SortbyContext>();
}

GreenPlumParser::SortbyContext* GreenPlumParser::Sortby_listContext::sortby(size_t i) {
  return getRuleContext<GreenPlumParser::SortbyContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Sortby_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Sortby_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Sortby_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleSortby_list;
}

void GreenPlumParser::Sortby_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSortby_list(this);
}

void GreenPlumParser::Sortby_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSortby_list(this);
}


antlrcpp::Any GreenPlumParser::Sortby_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSortby_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Sortby_listContext* GreenPlumParser::sortby_list() {
  Sortby_listContext *_localctx = _tracker.createInstance<Sortby_listContext>(_ctx, getState());
  enterRule(_localctx, 766, GreenPlumParser::RuleSortby_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5258);
    sortby();
    setState(5263);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 553, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5259);
        match(GreenPlumParser::COMMA);
        setState(5260);
        sortby(); 
      }
      setState(5265);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 553, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortbyContext ------------------------------------------------------------------

GreenPlumParser::SortbyContext::SortbyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::SortbyContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::SortbyContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Qual_all_OpContext* GreenPlumParser::SortbyContext::qual_all_Op() {
  return getRuleContext<GreenPlumParser::Qual_all_OpContext>(0);
}

GreenPlumParser::Opt_nulls_orderContext* GreenPlumParser::SortbyContext::opt_nulls_order() {
  return getRuleContext<GreenPlumParser::Opt_nulls_orderContext>(0);
}

GreenPlumParser::Opt_asc_descContext* GreenPlumParser::SortbyContext::opt_asc_desc() {
  return getRuleContext<GreenPlumParser::Opt_asc_descContext>(0);
}


size_t GreenPlumParser::SortbyContext::getRuleIndex() const {
  return GreenPlumParser::RuleSortby;
}

void GreenPlumParser::SortbyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSortby(this);
}

void GreenPlumParser::SortbyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSortby(this);
}


antlrcpp::Any GreenPlumParser::SortbyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSortby(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::SortbyContext* GreenPlumParser::sortby() {
  SortbyContext *_localctx = _tracker.createInstance<SortbyContext>(_ctx, getState());
  enterRule(_localctx, 768, GreenPlumParser::RuleSortby);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5279);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 557, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5266);
      a_expr();
      setState(5267);
      match(GreenPlumParser::USING);
      setState(5268);
      qual_all_Op();
      setState(5270);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 554, _ctx)) {
      case 1: {
        setState(5269);
        opt_nulls_order();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5272);
      a_expr();
      setState(5274);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 555, _ctx)) {
      case 1: {
        setState(5273);
        opt_asc_desc();
        break;
      }

      }
      setState(5277);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 556, _ctx)) {
      case 1: {
        setState(5276);
        opt_nulls_order();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_limitContext ------------------------------------------------------------------

GreenPlumParser::Select_limitContext::Select_limitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Select_limitContext::LIMIT() {
  return getToken(GreenPlumParser::LIMIT, 0);
}

GreenPlumParser::Select_limit_valueContext* GreenPlumParser::Select_limitContext::select_limit_value() {
  return getRuleContext<GreenPlumParser::Select_limit_valueContext>(0);
}

tree::TerminalNode* GreenPlumParser::Select_limitContext::OFFSET() {
  return getToken(GreenPlumParser::OFFSET, 0);
}

GreenPlumParser::Select_offset_valueContext* GreenPlumParser::Select_limitContext::select_offset_value() {
  return getRuleContext<GreenPlumParser::Select_offset_valueContext>(0);
}

tree::TerminalNode* GreenPlumParser::Select_limitContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}

GreenPlumParser::Select_offset_value2Context* GreenPlumParser::Select_limitContext::select_offset_value2() {
  return getRuleContext<GreenPlumParser::Select_offset_value2Context>(0);
}

std::vector<GreenPlumParser::Row_or_rowsContext *> GreenPlumParser::Select_limitContext::row_or_rows() {
  return getRuleContexts<GreenPlumParser::Row_or_rowsContext>();
}

GreenPlumParser::Row_or_rowsContext* GreenPlumParser::Select_limitContext::row_or_rows(size_t i) {
  return getRuleContext<GreenPlumParser::Row_or_rowsContext>(i);
}

tree::TerminalNode* GreenPlumParser::Select_limitContext::FETCH() {
  return getToken(GreenPlumParser::FETCH, 0);
}

GreenPlumParser::First_or_nextContext* GreenPlumParser::Select_limitContext::first_or_next() {
  return getRuleContext<GreenPlumParser::First_or_nextContext>(0);
}

tree::TerminalNode* GreenPlumParser::Select_limitContext::ONLY() {
  return getToken(GreenPlumParser::ONLY, 0);
}

GreenPlumParser::Opt_select_fetch_first_valueContext* GreenPlumParser::Select_limitContext::opt_select_fetch_first_value() {
  return getRuleContext<GreenPlumParser::Opt_select_fetch_first_valueContext>(0);
}


size_t GreenPlumParser::Select_limitContext::getRuleIndex() const {
  return GreenPlumParser::RuleSelect_limit;
}

void GreenPlumParser::Select_limitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_limit(this);
}

void GreenPlumParser::Select_limitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_limit(this);
}


antlrcpp::Any GreenPlumParser::Select_limitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSelect_limit(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Select_limitContext* GreenPlumParser::select_limit() {
  Select_limitContext *_localctx = _tracker.createInstance<Select_limitContext>(_ctx, getState());
  enterRule(_localctx, 770, GreenPlumParser::RuleSelect_limit);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5323);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 560, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5281);
      match(GreenPlumParser::LIMIT);
      setState(5282);
      select_limit_value();
      setState(5283);
      match(GreenPlumParser::OFFSET);
      setState(5284);
      select_offset_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5286);
      match(GreenPlumParser::OFFSET);
      setState(5287);
      select_offset_value();
      setState(5288);
      match(GreenPlumParser::LIMIT);
      setState(5289);
      select_limit_value();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5291);
      match(GreenPlumParser::LIMIT);
      setState(5292);
      select_limit_value();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5293);
      match(GreenPlumParser::OFFSET);
      setState(5294);
      select_offset_value();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5295);
      match(GreenPlumParser::LIMIT);
      setState(5296);
      select_limit_value();
      setState(5297);
      match(GreenPlumParser::COMMA);
      setState(5298);
      select_offset_value();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5300);
      match(GreenPlumParser::OFFSET);
      setState(5301);
      select_offset_value2();
      setState(5302);
      row_or_rows();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5304);
      match(GreenPlumParser::FETCH);
      setState(5305);
      first_or_next();
      setState(5307);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 471) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 471)) & ((1ULL << (GreenPlumParser::LEFT_PAREN - 471))
        | (1ULL << (GreenPlumParser::PLUS_SIGN - 471))
        | (1ULL << (GreenPlumParser::MINUS_SIGN - 471))
        | (1ULL << (GreenPlumParser::ICONST - 471)))) != 0)) {
        setState(5306);
        opt_select_fetch_first_value();
      }
      setState(5309);
      row_or_rows();
      setState(5310);
      match(GreenPlumParser::ONLY);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5312);
      match(GreenPlumParser::OFFSET);
      setState(5313);
      select_offset_value2();
      setState(5314);
      row_or_rows();
      setState(5315);
      match(GreenPlumParser::FETCH);
      setState(5316);
      first_or_next();
      setState(5318);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 471) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 471)) & ((1ULL << (GreenPlumParser::LEFT_PAREN - 471))
        | (1ULL << (GreenPlumParser::PLUS_SIGN - 471))
        | (1ULL << (GreenPlumParser::MINUS_SIGN - 471))
        | (1ULL << (GreenPlumParser::ICONST - 471)))) != 0)) {
        setState(5317);
        opt_select_fetch_first_value();
      }
      setState(5320);
      row_or_rows();
      setState(5321);
      match(GreenPlumParser::ONLY);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_limit_valueContext ------------------------------------------------------------------

GreenPlumParser::Select_limit_valueContext::Select_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Select_limit_valueContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Select_limit_valueContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}


size_t GreenPlumParser::Select_limit_valueContext::getRuleIndex() const {
  return GreenPlumParser::RuleSelect_limit_value;
}

void GreenPlumParser::Select_limit_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_limit_value(this);
}

void GreenPlumParser::Select_limit_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_limit_value(this);
}


antlrcpp::Any GreenPlumParser::Select_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSelect_limit_value(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Select_limit_valueContext* GreenPlumParser::select_limit_value() {
  Select_limit_valueContext *_localctx = _tracker.createInstance<Select_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 772, GreenPlumParser::RuleSelect_limit_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5327);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ARRAY:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CASE:
      case GreenPlumParser::CAST:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_CATALOG:
      case GreenPlumParser::CURRENT_DATE:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_ROLE:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURRENT_TIME:
      case GreenPlumParser::CURRENT_TIMESTAMP:
      case GreenPlumParser::CURRENT_USER:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DECODE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCALTIME:
      case GreenPlumParser::LOCALTIMESTAMP:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEDIAN:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOT:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PERCENTILE_CONT:
      case GreenPlumParser::PERCENTILE_DISC:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SESSION_USER:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLE:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNIQUE:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::USER:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XMLCONCAT:
      case GreenPlumParser::XMLELEMENT:
      case GreenPlumParser::XMLEXISTS:
      case GreenPlumParser::XMLFOREST:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::XMLPARSE:
      case GreenPlumParser::XMLPI:
      case GreenPlumParser::XMLROOT:
      case GreenPlumParser::XMLSERIALIZE:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::LEFT_PAREN:
      case GreenPlumParser::PLUS_SIGN:
      case GreenPlumParser::MINUS_SIGN:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST:
      case GreenPlumParser::BCONST:
      case GreenPlumParser::XCONST:
      case GreenPlumParser::PARAM: {
        enterOuterAlt(_localctx, 1);
        setState(5325);
        a_expr();
        break;
      }

      case GreenPlumParser::ALL: {
        enterOuterAlt(_localctx, 2);
        setState(5326);
        match(GreenPlumParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_select_fetch_first_valueContext ------------------------------------------------------------------

GreenPlumParser::Opt_select_fetch_first_valueContext::Opt_select_fetch_first_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Signed_iconstContext* GreenPlumParser::Opt_select_fetch_first_valueContext::signed_iconst() {
  return getRuleContext<GreenPlumParser::Signed_iconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_select_fetch_first_valueContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Opt_select_fetch_first_valueContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Opt_select_fetch_first_valueContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Opt_select_fetch_first_valueContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_select_fetch_first_value;
}

void GreenPlumParser::Opt_select_fetch_first_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_select_fetch_first_value(this);
}

void GreenPlumParser::Opt_select_fetch_first_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_select_fetch_first_value(this);
}


antlrcpp::Any GreenPlumParser::Opt_select_fetch_first_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_select_fetch_first_value(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_select_fetch_first_valueContext* GreenPlumParser::opt_select_fetch_first_value() {
  Opt_select_fetch_first_valueContext *_localctx = _tracker.createInstance<Opt_select_fetch_first_valueContext>(_ctx, getState());
  enterRule(_localctx, 774, GreenPlumParser::RuleOpt_select_fetch_first_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5334);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::PLUS_SIGN:
      case GreenPlumParser::MINUS_SIGN:
      case GreenPlumParser::ICONST: {
        enterOuterAlt(_localctx, 1);
        setState(5329);
        signed_iconst();
        break;
      }

      case GreenPlumParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(5330);
        match(GreenPlumParser::LEFT_PAREN);
        setState(5331);
        a_expr();
        setState(5332);
        match(GreenPlumParser::RIGHT_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_offset_valueContext ------------------------------------------------------------------

GreenPlumParser::Select_offset_valueContext::Select_offset_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Select_offset_valueContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Select_offset_valueContext::getRuleIndex() const {
  return GreenPlumParser::RuleSelect_offset_value;
}

void GreenPlumParser::Select_offset_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_offset_value(this);
}

void GreenPlumParser::Select_offset_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_offset_value(this);
}


antlrcpp::Any GreenPlumParser::Select_offset_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSelect_offset_value(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Select_offset_valueContext* GreenPlumParser::select_offset_value() {
  Select_offset_valueContext *_localctx = _tracker.createInstance<Select_offset_valueContext>(_ctx, getState());
  enterRule(_localctx, 776, GreenPlumParser::RuleSelect_offset_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5336);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_offset_value2Context ------------------------------------------------------------------

GreenPlumParser::Select_offset_value2Context::Select_offset_value2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::C_exprContext* GreenPlumParser::Select_offset_value2Context::c_expr() {
  return getRuleContext<GreenPlumParser::C_exprContext>(0);
}


size_t GreenPlumParser::Select_offset_value2Context::getRuleIndex() const {
  return GreenPlumParser::RuleSelect_offset_value2;
}

void GreenPlumParser::Select_offset_value2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_offset_value2(this);
}

void GreenPlumParser::Select_offset_value2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_offset_value2(this);
}


antlrcpp::Any GreenPlumParser::Select_offset_value2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSelect_offset_value2(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Select_offset_value2Context* GreenPlumParser::select_offset_value2() {
  Select_offset_value2Context *_localctx = _tracker.createInstance<Select_offset_value2Context>(_ctx, getState());
  enterRule(_localctx, 778, GreenPlumParser::RuleSelect_offset_value2);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5338);
    c_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Row_or_rowsContext ------------------------------------------------------------------

GreenPlumParser::Row_or_rowsContext::Row_or_rowsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Row_or_rowsContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

tree::TerminalNode* GreenPlumParser::Row_or_rowsContext::ROWS() {
  return getToken(GreenPlumParser::ROWS, 0);
}


size_t GreenPlumParser::Row_or_rowsContext::getRuleIndex() const {
  return GreenPlumParser::RuleRow_or_rows;
}

void GreenPlumParser::Row_or_rowsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRow_or_rows(this);
}

void GreenPlumParser::Row_or_rowsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRow_or_rows(this);
}


antlrcpp::Any GreenPlumParser::Row_or_rowsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRow_or_rows(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Row_or_rowsContext* GreenPlumParser::row_or_rows() {
  Row_or_rowsContext *_localctx = _tracker.createInstance<Row_or_rowsContext>(_ctx, getState());
  enterRule(_localctx, 780, GreenPlumParser::RuleRow_or_rows);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5340);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::ROW

    || _la == GreenPlumParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- First_or_nextContext ------------------------------------------------------------------

GreenPlumParser::First_or_nextContext::First_or_nextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::First_or_nextContext::FIRST_P() {
  return getToken(GreenPlumParser::FIRST_P, 0);
}

tree::TerminalNode* GreenPlumParser::First_or_nextContext::NEXT() {
  return getToken(GreenPlumParser::NEXT, 0);
}


size_t GreenPlumParser::First_or_nextContext::getRuleIndex() const {
  return GreenPlumParser::RuleFirst_or_next;
}

void GreenPlumParser::First_or_nextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFirst_or_next(this);
}

void GreenPlumParser::First_or_nextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFirst_or_next(this);
}


antlrcpp::Any GreenPlumParser::First_or_nextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFirst_or_next(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::First_or_nextContext* GreenPlumParser::first_or_next() {
  First_or_nextContext *_localctx = _tracker.createInstance<First_or_nextContext>(_ctx, getState());
  enterRule(_localctx, 782, GreenPlumParser::RuleFirst_or_next);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5342);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::FIRST_P || _la == GreenPlumParser::NEXT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_clauseContext ------------------------------------------------------------------

GreenPlumParser::Group_clauseContext::Group_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Group_clauseContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

tree::TerminalNode* GreenPlumParser::Group_clauseContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Group_elem_listContext* GreenPlumParser::Group_clauseContext::group_elem_list() {
  return getRuleContext<GreenPlumParser::Group_elem_listContext>(0);
}


size_t GreenPlumParser::Group_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleGroup_clause;
}

void GreenPlumParser::Group_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_clause(this);
}

void GreenPlumParser::Group_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_clause(this);
}


antlrcpp::Any GreenPlumParser::Group_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGroup_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Group_clauseContext* GreenPlumParser::group_clause() {
  Group_clauseContext *_localctx = _tracker.createInstance<Group_clauseContext>(_ctx, getState());
  enterRule(_localctx, 784, GreenPlumParser::RuleGroup_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5344);
    match(GreenPlumParser::GROUP_P);
    setState(5345);
    match(GreenPlumParser::BY);
    setState(5346);
    group_elem_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_elem_listContext ------------------------------------------------------------------

GreenPlumParser::Group_elem_listContext::Group_elem_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Group_elemContext *> GreenPlumParser::Group_elem_listContext::group_elem() {
  return getRuleContexts<GreenPlumParser::Group_elemContext>();
}

GreenPlumParser::Group_elemContext* GreenPlumParser::Group_elem_listContext::group_elem(size_t i) {
  return getRuleContext<GreenPlumParser::Group_elemContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Group_elem_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Group_elem_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Group_elem_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleGroup_elem_list;
}

void GreenPlumParser::Group_elem_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_elem_list(this);
}

void GreenPlumParser::Group_elem_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_elem_list(this);
}


antlrcpp::Any GreenPlumParser::Group_elem_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGroup_elem_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Group_elem_listContext* GreenPlumParser::group_elem_list() {
  Group_elem_listContext *_localctx = _tracker.createInstance<Group_elem_listContext>(_ctx, getState());
  enterRule(_localctx, 786, GreenPlumParser::RuleGroup_elem_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5348);
    group_elem();
    setState(5353);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 563, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5349);
        match(GreenPlumParser::COMMA);
        setState(5350);
        group_elem(); 
      }
      setState(5355);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 563, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_elemContext ------------------------------------------------------------------

GreenPlumParser::Group_elemContext::Group_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Group_elemContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Group_elemContext::ROLLUP() {
  return getToken(GreenPlumParser::ROLLUP, 0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Group_elemContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Group_elemContext::CUBE() {
  return getToken(GreenPlumParser::CUBE, 0);
}

tree::TerminalNode* GreenPlumParser::Group_elemContext::GROUPING() {
  return getToken(GreenPlumParser::GROUPING, 0);
}

tree::TerminalNode* GreenPlumParser::Group_elemContext::SETS() {
  return getToken(GreenPlumParser::SETS, 0);
}

tree::TerminalNode* GreenPlumParser::Group_elemContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Group_elem_listContext* GreenPlumParser::Group_elemContext::group_elem_list() {
  return getRuleContext<GreenPlumParser::Group_elem_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Group_elemContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Double_parensContext* GreenPlumParser::Group_elemContext::double_parens() {
  return getRuleContext<GreenPlumParser::Double_parensContext>(0);
}


size_t GreenPlumParser::Group_elemContext::getRuleIndex() const {
  return GreenPlumParser::RuleGroup_elem;
}

void GreenPlumParser::Group_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_elem(this);
}

void GreenPlumParser::Group_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_elem(this);
}


antlrcpp::Any GreenPlumParser::Group_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGroup_elem(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Group_elemContext* GreenPlumParser::group_elem() {
  Group_elemContext *_localctx = _tracker.createInstance<Group_elemContext>(_ctx, getState());
  enterRule(_localctx, 788, GreenPlumParser::RuleGroup_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5368);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 564, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5356);
      a_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5357);
      match(GreenPlumParser::ROLLUP);
      setState(5358);
      paren_expr_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5359);
      match(GreenPlumParser::CUBE);
      setState(5360);
      paren_expr_list();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5361);
      match(GreenPlumParser::GROUPING);
      setState(5362);
      match(GreenPlumParser::SETS);
      setState(5363);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5364);
      group_elem_list();
      setState(5365);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5367);
      double_parens();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Having_clauseContext ------------------------------------------------------------------

GreenPlumParser::Having_clauseContext::Having_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Having_clauseContext::HAVING() {
  return getToken(GreenPlumParser::HAVING, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Having_clauseContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Having_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleHaving_clause;
}

void GreenPlumParser::Having_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHaving_clause(this);
}

void GreenPlumParser::Having_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHaving_clause(this);
}


antlrcpp::Any GreenPlumParser::Having_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitHaving_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Having_clauseContext* GreenPlumParser::having_clause() {
  Having_clauseContext *_localctx = _tracker.createInstance<Having_clauseContext>(_ctx, getState());
  enterRule(_localctx, 790, GreenPlumParser::RuleHaving_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5370);
    match(GreenPlumParser::HAVING);
    setState(5371);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_locking_clauseContext ------------------------------------------------------------------

GreenPlumParser::For_locking_clauseContext::For_locking_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::For_locking_itemContext *> GreenPlumParser::For_locking_clauseContext::for_locking_item() {
  return getRuleContexts<GreenPlumParser::For_locking_itemContext>();
}

GreenPlumParser::For_locking_itemContext* GreenPlumParser::For_locking_clauseContext::for_locking_item(size_t i) {
  return getRuleContext<GreenPlumParser::For_locking_itemContext>(i);
}

tree::TerminalNode* GreenPlumParser::For_locking_clauseContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

tree::TerminalNode* GreenPlumParser::For_locking_clauseContext::READ() {
  return getToken(GreenPlumParser::READ, 0);
}

tree::TerminalNode* GreenPlumParser::For_locking_clauseContext::ONLY() {
  return getToken(GreenPlumParser::ONLY, 0);
}


size_t GreenPlumParser::For_locking_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleFor_locking_clause;
}

void GreenPlumParser::For_locking_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_locking_clause(this);
}

void GreenPlumParser::For_locking_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_locking_clause(this);
}


antlrcpp::Any GreenPlumParser::For_locking_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFor_locking_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::For_locking_clauseContext* GreenPlumParser::for_locking_clause() {
  For_locking_clauseContext *_localctx = _tracker.createInstance<For_locking_clauseContext>(_ctx, getState());
  enterRule(_localctx, 792, GreenPlumParser::RuleFor_locking_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(5381);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 566, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5374); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(5373);
                for_locking_item();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(5376); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 565, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5378);
      match(GreenPlumParser::FOR);
      setState(5379);
      match(GreenPlumParser::READ);
      setState(5380);
      match(GreenPlumParser::ONLY);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_locking_itemContext ------------------------------------------------------------------

GreenPlumParser::For_locking_itemContext::For_locking_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::For_locking_itemContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

tree::TerminalNode* GreenPlumParser::For_locking_itemContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

tree::TerminalNode* GreenPlumParser::For_locking_itemContext::SHARE() {
  return getToken(GreenPlumParser::SHARE, 0);
}

GreenPlumParser::Locked_rels_listContext* GreenPlumParser::For_locking_itemContext::locked_rels_list() {
  return getRuleContext<GreenPlumParser::Locked_rels_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::For_locking_itemContext::NOWAIT() {
  return getToken(GreenPlumParser::NOWAIT, 0);
}


size_t GreenPlumParser::For_locking_itemContext::getRuleIndex() const {
  return GreenPlumParser::RuleFor_locking_item;
}

void GreenPlumParser::For_locking_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_locking_item(this);
}

void GreenPlumParser::For_locking_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_locking_item(this);
}


antlrcpp::Any GreenPlumParser::For_locking_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFor_locking_item(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::For_locking_itemContext* GreenPlumParser::for_locking_item() {
  For_locking_itemContext *_localctx = _tracker.createInstance<For_locking_itemContext>(_ctx, getState());
  enterRule(_localctx, 794, GreenPlumParser::RuleFor_locking_item);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5383);
    match(GreenPlumParser::FOR);
    setState(5384);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::SHARE

    || _la == GreenPlumParser::UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5386);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 567, _ctx)) {
    case 1: {
      setState(5385);
      locked_rels_list();
      break;
    }

    }
    setState(5389);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 568, _ctx)) {
    case 1: {
      setState(5388);
      match(GreenPlumParser::NOWAIT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Locked_rels_listContext ------------------------------------------------------------------

GreenPlumParser::Locked_rels_listContext::Locked_rels_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Locked_rels_listContext::OF() {
  return getToken(GreenPlumParser::OF, 0);
}

GreenPlumParser::Name_listContext* GreenPlumParser::Locked_rels_listContext::name_list() {
  return getRuleContext<GreenPlumParser::Name_listContext>(0);
}


size_t GreenPlumParser::Locked_rels_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleLocked_rels_list;
}

void GreenPlumParser::Locked_rels_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocked_rels_list(this);
}

void GreenPlumParser::Locked_rels_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocked_rels_list(this);
}


antlrcpp::Any GreenPlumParser::Locked_rels_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitLocked_rels_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Locked_rels_listContext* GreenPlumParser::locked_rels_list() {
  Locked_rels_listContext *_localctx = _tracker.createInstance<Locked_rels_listContext>(_ctx, getState());
  enterRule(_localctx, 796, GreenPlumParser::RuleLocked_rels_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5391);
    match(GreenPlumParser::OF);
    setState(5392);
    name_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Values_clauseContext ------------------------------------------------------------------

GreenPlumParser::Values_clauseContext::Values_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Values_clauseContext::VALUES() {
  return getToken(GreenPlumParser::VALUES, 0);
}

GreenPlumParser::Ctext_rowContext* GreenPlumParser::Values_clauseContext::ctext_row() {
  return getRuleContext<GreenPlumParser::Ctext_rowContext>(0);
}

GreenPlumParser::Values_clauseContext* GreenPlumParser::Values_clauseContext::values_clause() {
  return getRuleContext<GreenPlumParser::Values_clauseContext>(0);
}

tree::TerminalNode* GreenPlumParser::Values_clauseContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}


size_t GreenPlumParser::Values_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleValues_clause;
}

void GreenPlumParser::Values_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues_clause(this);
}

void GreenPlumParser::Values_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues_clause(this);
}


antlrcpp::Any GreenPlumParser::Values_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitValues_clause(this);
  else
    return visitor->visitChildren(this);
}


GreenPlumParser::Values_clauseContext* GreenPlumParser::values_clause() {
   return values_clause(0);
}

GreenPlumParser::Values_clauseContext* GreenPlumParser::values_clause(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::Values_clauseContext *_localctx = _tracker.createInstance<Values_clauseContext>(_ctx, parentState);
  GreenPlumParser::Values_clauseContext *previousContext = _localctx;
  size_t startState = 798;
  enterRecursionRule(_localctx, 798, GreenPlumParser::RuleValues_clause, precedence);

    

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5395);
    match(GreenPlumParser::VALUES);
    setState(5396);
    ctext_row();
    _ctx->stop = _input->LT(-1);
    setState(5403);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 569, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Values_clauseContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleValues_clause);
        setState(5398);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(5399);
        match(GreenPlumParser::COMMA);
        setState(5400);
        ctext_row(); 
      }
      setState(5405);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 569, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- From_clauseContext ------------------------------------------------------------------

GreenPlumParser::From_clauseContext::From_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::From_clauseContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::From_listContext* GreenPlumParser::From_clauseContext::from_list() {
  return getRuleContext<GreenPlumParser::From_listContext>(0);
}


size_t GreenPlumParser::From_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleFrom_clause;
}

void GreenPlumParser::From_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_clause(this);
}

void GreenPlumParser::From_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_clause(this);
}


antlrcpp::Any GreenPlumParser::From_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFrom_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::From_clauseContext* GreenPlumParser::from_clause() {
  From_clauseContext *_localctx = _tracker.createInstance<From_clauseContext>(_ctx, getState());
  enterRule(_localctx, 800, GreenPlumParser::RuleFrom_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5406);
    match(GreenPlumParser::FROM);
    setState(5407);
    from_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_listContext ------------------------------------------------------------------

GreenPlumParser::From_listContext::From_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Table_refContext *> GreenPlumParser::From_listContext::table_ref() {
  return getRuleContexts<GreenPlumParser::Table_refContext>();
}

GreenPlumParser::Table_refContext* GreenPlumParser::From_listContext::table_ref(size_t i) {
  return getRuleContext<GreenPlumParser::Table_refContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::From_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::From_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::From_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleFrom_list;
}

void GreenPlumParser::From_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_list(this);
}

void GreenPlumParser::From_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_list(this);
}


antlrcpp::Any GreenPlumParser::From_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFrom_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::From_listContext* GreenPlumParser::from_list() {
  From_listContext *_localctx = _tracker.createInstance<From_listContext>(_ctx, getState());
  enterRule(_localctx, 802, GreenPlumParser::RuleFrom_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5409);
    table_ref(0);
    setState(5414);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 570, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5410);
        match(GreenPlumParser::COMMA);
        setState(5411);
        table_ref(0); 
      }
      setState(5416);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 570, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_refContext ------------------------------------------------------------------

GreenPlumParser::Table_refContext::Table_refContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t GreenPlumParser::Table_refContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_ref;
}

void GreenPlumParser::Table_refContext::copyFrom(Table_refContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Table_ref_subqueryContext ------------------------------------------------------------------

GreenPlumParser::Select_with_parensContext* GreenPlumParser::Table_ref_subqueryContext::select_with_parens() {
  return getRuleContext<GreenPlumParser::Select_with_parensContext>(0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Table_ref_subqueryContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_subqueryContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::Table_ref_subqueryContext::paren_name_list() {
  return getRuleContext<GreenPlumParser::Paren_name_listContext>(0);
}

GreenPlumParser::Table_ref_subqueryContext::Table_ref_subqueryContext(Table_refContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Table_ref_subqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_ref_subquery(this);
}
void GreenPlumParser::Table_ref_subqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_ref_subquery(this);
}

antlrcpp::Any GreenPlumParser::Table_ref_subqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_ref_subquery(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_ref_parensContext ------------------------------------------------------------------

tree::TerminalNode* GreenPlumParser::Table_ref_parensContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Table_refContext* GreenPlumParser::Table_ref_parensContext::table_ref() {
  return getRuleContext<GreenPlumParser::Table_refContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_parensContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Table_ref_parensContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_parensContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::Table_ref_parensContext::paren_name_list() {
  return getRuleContext<GreenPlumParser::Paren_name_listContext>(0);
}

GreenPlumParser::Table_ref_parensContext::Table_ref_parensContext(Table_refContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Table_ref_parensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_ref_parens(this);
}
void GreenPlumParser::Table_ref_parensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_ref_parens(this);
}

antlrcpp::Any GreenPlumParser::Table_ref_parensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_ref_parens(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_ref_normalContext ------------------------------------------------------------------

GreenPlumParser::Relation_exprContext* GreenPlumParser::Table_ref_normalContext::relation_expr() {
  return getRuleContext<GreenPlumParser::Relation_exprContext>(0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Table_ref_normalContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_normalContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::Table_ref_normalContext::paren_name_list() {
  return getRuleContext<GreenPlumParser::Paren_name_listContext>(0);
}

GreenPlumParser::Table_ref_normalContext::Table_ref_normalContext(Table_refContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Table_ref_normalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_ref_normal(this);
}
void GreenPlumParser::Table_ref_normalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_ref_normal(this);
}

antlrcpp::Any GreenPlumParser::Table_ref_normalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_ref_normal(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_ref_func2Context ------------------------------------------------------------------

GreenPlumParser::Func_tableContext* GreenPlumParser::Table_ref_func2Context::func_table() {
  return getRuleContext<GreenPlumParser::Func_tableContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_func2Context::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Table_func_element_listContext* GreenPlumParser::Table_ref_func2Context::table_func_element_list() {
  return getRuleContext<GreenPlumParser::Table_func_element_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_func2Context::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_func2Context::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Table_ref_func2Context::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::Table_ref_func2Context::Table_ref_func2Context(Table_refContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Table_ref_func2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_ref_func2(this);
}
void GreenPlumParser::Table_ref_func2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_ref_func2(this);
}

antlrcpp::Any GreenPlumParser::Table_ref_func2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_ref_func2(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_ref_func1Context ------------------------------------------------------------------

GreenPlumParser::Func_tableContext* GreenPlumParser::Table_ref_func1Context::func_table() {
  return getRuleContext<GreenPlumParser::Func_tableContext>(0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Table_ref_func1Context::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_func1Context::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::Table_ref_func1Context::paren_name_list() {
  return getRuleContext<GreenPlumParser::Paren_name_listContext>(0);
}

GreenPlumParser::Table_ref_func1Context::Table_ref_func1Context(Table_refContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Table_ref_func1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_ref_func1(this);
}
void GreenPlumParser::Table_ref_func1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_ref_func1(this);
}

antlrcpp::Any GreenPlumParser::Table_ref_func1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_ref_func1(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Table_ref_joinableContext ------------------------------------------------------------------

std::vector<GreenPlumParser::Table_refContext *> GreenPlumParser::Table_ref_joinableContext::table_ref() {
  return getRuleContexts<GreenPlumParser::Table_refContext>();
}

GreenPlumParser::Table_refContext* GreenPlumParser::Table_ref_joinableContext::table_ref(size_t i) {
  return getRuleContext<GreenPlumParser::Table_refContext>(i);
}

tree::TerminalNode* GreenPlumParser::Table_ref_joinableContext::JOIN() {
  return getToken(GreenPlumParser::JOIN, 0);
}

tree::TerminalNode* GreenPlumParser::Table_ref_joinableContext::NATURAL() {
  return getToken(GreenPlumParser::NATURAL, 0);
}

GreenPlumParser::Join_typeContext* GreenPlumParser::Table_ref_joinableContext::join_type() {
  return getRuleContext<GreenPlumParser::Join_typeContext>(0);
}

GreenPlumParser::Join_qualContext* GreenPlumParser::Table_ref_joinableContext::join_qual() {
  return getRuleContext<GreenPlumParser::Join_qualContext>(0);
}

GreenPlumParser::Table_ref_joinableContext::Table_ref_joinableContext(Table_refContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Table_ref_joinableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_ref_joinable(this);
}
void GreenPlumParser::Table_ref_joinableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_ref_joinable(this);
}

antlrcpp::Any GreenPlumParser::Table_ref_joinableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_ref_joinable(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_refContext* GreenPlumParser::table_ref() {
   return table_ref(0);
}

GreenPlumParser::Table_refContext* GreenPlumParser::table_ref(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::Table_refContext *_localctx = _tracker.createInstance<Table_refContext>(_ctx, parentState);
  GreenPlumParser::Table_refContext *previousContext = _localctx;
  size_t startState = 804;
  enterRecursionRule(_localctx, 804, GreenPlumParser::RuleTable_ref, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5471);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 585, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<Table_ref_normalContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(5418);
      relation_expr();
      setState(5426);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 573, _ctx)) {
      case 1: {
        setState(5420);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::AS) {
          setState(5419);
          match(GreenPlumParser::AS);
        }
        setState(5422);
        colid();
        setState(5424);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 572, _ctx)) {
        case 1: {
          setState(5423);
          paren_name_list();
          break;
        }

        }
        break;
      }

      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<Table_ref_func1Context>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5428);
      func_table();
      setState(5436);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 576, _ctx)) {
      case 1: {
        setState(5430);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::AS) {
          setState(5429);
          match(GreenPlumParser::AS);
        }
        setState(5432);
        colid();
        setState(5434);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 575, _ctx)) {
        case 1: {
          setState(5433);
          paren_name_list();
          break;
        }

        }
        break;
      }

      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<Table_ref_func2Context>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5438);
      func_table();
      setState(5440);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::AS) {
        setState(5439);
        match(GreenPlumParser::AS);
      }
      setState(5443);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
        setState(5442);
        colid();
      }
      setState(5445);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5446);
      table_func_element_list();
      setState(5447);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<Table_ref_subqueryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5449);
      select_with_parens();
      setState(5457);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 581, _ctx)) {
      case 1: {
        setState(5451);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::AS) {
          setState(5450);
          match(GreenPlumParser::AS);
        }
        setState(5453);
        colid();
        setState(5455);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 580, _ctx)) {
        case 1: {
          setState(5454);
          paren_name_list();
          break;
        }

        }
        break;
      }

      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<Table_ref_parensContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5459);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5460);
      table_ref(0);
      setState(5461);
      match(GreenPlumParser::RIGHT_PAREN);
      setState(5469);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 584, _ctx)) {
      case 1: {
        setState(5463);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::AS) {
          setState(5462);
          match(GreenPlumParser::AS);
        }
        setState(5465);
        colid();
        setState(5467);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 583, _ctx)) {
        case 1: {
          setState(5466);
          paren_name_list();
          break;
        }

        }
        break;
      }

      }
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5487);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 589, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<Table_ref_joinableContext>(_tracker.createInstance<Table_refContext>(parentContext, parentState));
        _localctx = newContext;
        pushNewRecursionContext(newContext, startState, RuleTable_ref);
        setState(5473);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(5475);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::NATURAL) {
          setState(5474);
          match(GreenPlumParser::NATURAL);
        }
        setState(5478);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::CROSS || ((((_la - 158) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 158)) & ((1ULL << (GreenPlumParser::FULL - 158))
          | (1ULL << (GreenPlumParser::INNER_P - 158))
          | (1ULL << (GreenPlumParser::LEFT - 158)))) != 0) || _la == GreenPlumParser::RIGHT) {
          setState(5477);
          join_type();
        }
        setState(5480);
        match(GreenPlumParser::JOIN);
        setState(5481);
        table_ref(0);
        setState(5483);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 588, _ctx)) {
        case 1: {
          setState(5482);
          join_qual();
          break;
        }

        } 
      }
      setState(5489);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 589, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Join_typeContext ------------------------------------------------------------------

GreenPlumParser::Join_typeContext::Join_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Join_typeContext::FULL() {
  return getToken(GreenPlumParser::FULL, 0);
}

tree::TerminalNode* GreenPlumParser::Join_typeContext::LEFT() {
  return getToken(GreenPlumParser::LEFT, 0);
}

tree::TerminalNode* GreenPlumParser::Join_typeContext::RIGHT() {
  return getToken(GreenPlumParser::RIGHT, 0);
}

tree::TerminalNode* GreenPlumParser::Join_typeContext::OUTER_P() {
  return getToken(GreenPlumParser::OUTER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Join_typeContext::INNER_P() {
  return getToken(GreenPlumParser::INNER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Join_typeContext::CROSS() {
  return getToken(GreenPlumParser::CROSS, 0);
}


size_t GreenPlumParser::Join_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleJoin_type;
}

void GreenPlumParser::Join_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_type(this);
}

void GreenPlumParser::Join_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_type(this);
}


antlrcpp::Any GreenPlumParser::Join_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitJoin_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Join_typeContext* GreenPlumParser::join_type() {
  Join_typeContext *_localctx = _tracker.createInstance<Join_typeContext>(_ctx, getState());
  enterRule(_localctx, 806, GreenPlumParser::RuleJoin_type);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5496);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::FULL:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::RIGHT: {
        enterOuterAlt(_localctx, 1);
        setState(5490);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::FULL

        || _la == GreenPlumParser::LEFT || _la == GreenPlumParser::RIGHT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5492);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::OUTER_P) {
          setState(5491);
          match(GreenPlumParser::OUTER_P);
        }
        break;
      }

      case GreenPlumParser::INNER_P: {
        enterOuterAlt(_localctx, 2);
        setState(5494);
        match(GreenPlumParser::INNER_P);
        break;
      }

      case GreenPlumParser::CROSS: {
        enterOuterAlt(_localctx, 3);
        setState(5495);
        match(GreenPlumParser::CROSS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_qualContext ------------------------------------------------------------------

GreenPlumParser::Join_qualContext::Join_qualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Join_qualContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

GreenPlumParser::Paren_name_listContext* GreenPlumParser::Join_qualContext::paren_name_list() {
  return getRuleContext<GreenPlumParser::Paren_name_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Join_qualContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Join_qualContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Join_qualContext::getRuleIndex() const {
  return GreenPlumParser::RuleJoin_qual;
}

void GreenPlumParser::Join_qualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_qual(this);
}

void GreenPlumParser::Join_qualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_qual(this);
}


antlrcpp::Any GreenPlumParser::Join_qualContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitJoin_qual(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Join_qualContext* GreenPlumParser::join_qual() {
  Join_qualContext *_localctx = _tracker.createInstance<Join_qualContext>(_ctx, getState());
  enterRule(_localctx, 808, GreenPlumParser::RuleJoin_qual);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5502);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::USING: {
        enterOuterAlt(_localctx, 1);
        setState(5498);
        match(GreenPlumParser::USING);
        setState(5499);
        paren_name_list();
        break;
      }

      case GreenPlumParser::ON: {
        enterOuterAlt(_localctx, 2);
        setState(5500);
        match(GreenPlumParser::ON);
        setState(5501);
        a_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_exprContext ------------------------------------------------------------------

GreenPlumParser::Relation_exprContext::Relation_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Relation_exprContext::qualified_name() {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Relation_exprContext::ASTERISK() {
  return getToken(GreenPlumParser::ASTERISK, 0);
}

tree::TerminalNode* GreenPlumParser::Relation_exprContext::ONLY() {
  return getToken(GreenPlumParser::ONLY, 0);
}

tree::TerminalNode* GreenPlumParser::Relation_exprContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Relation_exprContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Relation_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleRelation_expr;
}

void GreenPlumParser::Relation_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelation_expr(this);
}

void GreenPlumParser::Relation_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelation_expr(this);
}


antlrcpp::Any GreenPlumParser::Relation_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRelation_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Relation_exprContext* GreenPlumParser::relation_expr() {
  Relation_exprContext *_localctx = _tracker.createInstance<Relation_exprContext>(_ctx, getState());
  enterRule(_localctx, 810, GreenPlumParser::RuleRelation_expr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5515);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 594, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5504);
      qualified_name();
      setState(5506);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 593, _ctx)) {
      case 1: {
        setState(5505);
        match(GreenPlumParser::ASTERISK);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5508);
      match(GreenPlumParser::ONLY);
      setState(5509);
      qualified_name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5510);
      match(GreenPlumParser::ONLY);
      setState(5511);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5512);
      qualified_name();
      setState(5513);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_expr_opt_aliasContext ------------------------------------------------------------------

GreenPlumParser::Relation_expr_opt_aliasContext::Relation_expr_opt_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Relation_exprContext* GreenPlumParser::Relation_expr_opt_aliasContext::relation_expr() {
  return getRuleContext<GreenPlumParser::Relation_exprContext>(0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Relation_expr_opt_aliasContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Relation_expr_opt_aliasContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}


size_t GreenPlumParser::Relation_expr_opt_aliasContext::getRuleIndex() const {
  return GreenPlumParser::RuleRelation_expr_opt_alias;
}

void GreenPlumParser::Relation_expr_opt_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelation_expr_opt_alias(this);
}

void GreenPlumParser::Relation_expr_opt_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelation_expr_opt_alias(this);
}


antlrcpp::Any GreenPlumParser::Relation_expr_opt_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRelation_expr_opt_alias(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Relation_expr_opt_aliasContext* GreenPlumParser::relation_expr_opt_alias() {
  Relation_expr_opt_aliasContext *_localctx = _tracker.createInstance<Relation_expr_opt_aliasContext>(_ctx, getState());
  enterRule(_localctx, 812, GreenPlumParser::RuleRelation_expr_opt_alias);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5517);
    relation_expr();
    setState(5522);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 596, _ctx)) {
    case 1: {
      setState(5519);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::AS) {
        setState(5518);
        match(GreenPlumParser::AS);
      }
      setState(5521);
      colid();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_tableContext ------------------------------------------------------------------

GreenPlumParser::Func_tableContext::Func_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Func_exprContext* GreenPlumParser::Func_tableContext::func_expr() {
  return getRuleContext<GreenPlumParser::Func_exprContext>(0);
}


size_t GreenPlumParser::Func_tableContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_table;
}

void GreenPlumParser::Func_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_table(this);
}

void GreenPlumParser::Func_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_table(this);
}


antlrcpp::Any GreenPlumParser::Func_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_table(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_tableContext* GreenPlumParser::func_table() {
  Func_tableContext *_localctx = _tracker.createInstance<Func_tableContext>(_ctx, getState());
  enterRule(_localctx, 814, GreenPlumParser::RuleFunc_table);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5524);
    func_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_clauseContext ------------------------------------------------------------------

GreenPlumParser::Where_clauseContext::Where_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Where_clauseContext::WHERE() {
  return getToken(GreenPlumParser::WHERE, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Where_clauseContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Where_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleWhere_clause;
}

void GreenPlumParser::Where_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_clause(this);
}

void GreenPlumParser::Where_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_clause(this);
}


antlrcpp::Any GreenPlumParser::Where_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWhere_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Where_clauseContext* GreenPlumParser::where_clause() {
  Where_clauseContext *_localctx = _tracker.createInstance<Where_clauseContext>(_ctx, getState());
  enterRule(_localctx, 816, GreenPlumParser::RuleWhere_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5526);
    match(GreenPlumParser::WHERE);
    setState(5527);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_or_current_clauseContext ------------------------------------------------------------------

GreenPlumParser::Where_or_current_clauseContext::Where_or_current_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Where_or_current_clauseContext::WHERE() {
  return getToken(GreenPlumParser::WHERE, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Where_or_current_clauseContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Where_or_current_clauseContext::CURRENT_P() {
  return getToken(GreenPlumParser::CURRENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Where_or_current_clauseContext::OF() {
  return getToken(GreenPlumParser::OF, 0);
}

GreenPlumParser::NameContext* GreenPlumParser::Where_or_current_clauseContext::name() {
  return getRuleContext<GreenPlumParser::NameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Where_or_current_clauseContext::PARAM() {
  return getToken(GreenPlumParser::PARAM, 0);
}


size_t GreenPlumParser::Where_or_current_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleWhere_or_current_clause;
}

void GreenPlumParser::Where_or_current_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_or_current_clause(this);
}

void GreenPlumParser::Where_or_current_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_or_current_clause(this);
}


antlrcpp::Any GreenPlumParser::Where_or_current_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWhere_or_current_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Where_or_current_clauseContext* GreenPlumParser::where_or_current_clause() {
  Where_or_current_clauseContext *_localctx = _tracker.createInstance<Where_or_current_clauseContext>(_ctx, getState());
  enterRule(_localctx, 818, GreenPlumParser::RuleWhere_or_current_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5538);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 598, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5529);
      match(GreenPlumParser::WHERE);
      setState(5530);
      a_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5531);
      match(GreenPlumParser::WHERE);
      setState(5532);
      match(GreenPlumParser::CURRENT_P);
      setState(5533);
      match(GreenPlumParser::OF);
      setState(5536);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GreenPlumParser::ABORT_P:
        case GreenPlumParser::ABSOLUTE_P:
        case GreenPlumParser::ACCESS:
        case GreenPlumParser::ACTION:
        case GreenPlumParser::ACTIVE:
        case GreenPlumParser::ADD_P:
        case GreenPlumParser::ADMIN:
        case GreenPlumParser::AFTER:
        case GreenPlumParser::AGGREGATE:
        case GreenPlumParser::ALSO:
        case GreenPlumParser::ALTER:
        case GreenPlumParser::ALWAYS:
        case GreenPlumParser::ASSERTION:
        case GreenPlumParser::ASSIGNMENT:
        case GreenPlumParser::AT:
        case GreenPlumParser::BACKWARD:
        case GreenPlumParser::BEFORE:
        case GreenPlumParser::BEGIN_P:
        case GreenPlumParser::BY:
        case GreenPlumParser::CACHE:
        case GreenPlumParser::CALLED:
        case GreenPlumParser::CASCADE:
        case GreenPlumParser::CASCADED:
        case GreenPlumParser::CHAIN:
        case GreenPlumParser::CHARACTERISTICS:
        case GreenPlumParser::CHECKPOINT:
        case GreenPlumParser::CLASS:
        case GreenPlumParser::CLOSE:
        case GreenPlumParser::CLUSTER:
        case GreenPlumParser::COMMENT:
        case GreenPlumParser::COMMIT:
        case GreenPlumParser::COMMITTED:
        case GreenPlumParser::CONCURRENCY:
        case GreenPlumParser::CONCURRENTLY:
        case GreenPlumParser::CONFIGURATION:
        case GreenPlumParser::CONNECTION:
        case GreenPlumParser::CONSTRAINTS:
        case GreenPlumParser::CONTAINS:
        case GreenPlumParser::CONTENT_P:
        case GreenPlumParser::CONTINUE_P:
        case GreenPlumParser::CONVERSION_P:
        case GreenPlumParser::COPY:
        case GreenPlumParser::COST:
        case GreenPlumParser::CPU_RATE_LIMIT:
        case GreenPlumParser::CPUSET:
        case GreenPlumParser::CREATEDB:
        case GreenPlumParser::CREATEEXTTABLE:
        case GreenPlumParser::CREATEROLE:
        case GreenPlumParser::CREATEUSER:
        case GreenPlumParser::CSV:
        case GreenPlumParser::CURRENT_P:
        case GreenPlumParser::CURSOR:
        case GreenPlumParser::CYCLE:
        case GreenPlumParser::DATABASE:
        case GreenPlumParser::DATA_P:
        case GreenPlumParser::DAY_P:
        case GreenPlumParser::DEALLOCATE:
        case GreenPlumParser::DECLARE:
        case GreenPlumParser::DEFAULTS:
        case GreenPlumParser::DEFERRED:
        case GreenPlumParser::DEFINER:
        case GreenPlumParser::DELETE_P:
        case GreenPlumParser::DELIMITER:
        case GreenPlumParser::DELIMITERS:
        case GreenPlumParser::DENY:
        case GreenPlumParser::DICTIONARY:
        case GreenPlumParser::DISABLE_P:
        case GreenPlumParser::DISCARD:
        case GreenPlumParser::DOCUMENT_P:
        case GreenPlumParser::DOMAIN_P:
        case GreenPlumParser::DOUBLE_P:
        case GreenPlumParser::DROP:
        case GreenPlumParser::DXL:
        case GreenPlumParser::EACH:
        case GreenPlumParser::ENABLE_P:
        case GreenPlumParser::ENCODING:
        case GreenPlumParser::ENCRYPTED:
        case GreenPlumParser::ENUM_P:
        case GreenPlumParser::ERRORS:
        case GreenPlumParser::ESCAPE:
        case GreenPlumParser::EVERY:
        case GreenPlumParser::EXCHANGE:
        case GreenPlumParser::EXCLUDING:
        case GreenPlumParser::EXCLUSIVE:
        case GreenPlumParser::EXECUTE:
        case GreenPlumParser::EXPLAIN:
        case GreenPlumParser::EXTENSION:
        case GreenPlumParser::EXTERNAL:
        case GreenPlumParser::FAMILY:
        case GreenPlumParser::FIELDS:
        case GreenPlumParser::FILESPACE:
        case GreenPlumParser::FILL:
        case GreenPlumParser::FIRST_P:
        case GreenPlumParser::FORCE:
        case GreenPlumParser::FORMAT:
        case GreenPlumParser::FORWARD:
        case GreenPlumParser::FUNCTION:
        case GreenPlumParser::GLOBAL:
        case GreenPlumParser::GRANTED:
        case GreenPlumParser::HANDLER:
        case GreenPlumParser::HASH:
        case GreenPlumParser::HEADER_P:
        case GreenPlumParser::HOLD:
        case GreenPlumParser::HOST:
        case GreenPlumParser::HOUR_P:
        case GreenPlumParser::IDENTITY_P:
        case GreenPlumParser::IF_P:
        case GreenPlumParser::IGNORE_P:
        case GreenPlumParser::IMMEDIATE:
        case GreenPlumParser::IMMUTABLE:
        case GreenPlumParser::IMPLICIT_P:
        case GreenPlumParser::INCLUDING:
        case GreenPlumParser::INCLUSIVE:
        case GreenPlumParser::INCREMENT:
        case GreenPlumParser::INDEX:
        case GreenPlumParser::INDEXES:
        case GreenPlumParser::INHERIT:
        case GreenPlumParser::INHERITS:
        case GreenPlumParser::INLINE_P:
        case GreenPlumParser::INPUT_P:
        case GreenPlumParser::INSENSITIVE:
        case GreenPlumParser::INSERT:
        case GreenPlumParser::INSTEAD:
        case GreenPlumParser::INVOKER:
        case GreenPlumParser::ISOLATION:
        case GreenPlumParser::KEY:
        case GreenPlumParser::LANGUAGE:
        case GreenPlumParser::LARGE_P:
        case GreenPlumParser::LAST_P:
        case GreenPlumParser::LEVEL:
        case GreenPlumParser::LIST:
        case GreenPlumParser::LISTEN:
        case GreenPlumParser::LOAD:
        case GreenPlumParser::LOCAL:
        case GreenPlumParser::LOCATION:
        case GreenPlumParser::LOCK_P:
        case GreenPlumParser::LOGIN_P:
        case GreenPlumParser::MAPPING:
        case GreenPlumParser::MASTER:
        case GreenPlumParser::MATCH:
        case GreenPlumParser::MAXVALUE:
        case GreenPlumParser::MEMORY_LIMIT:
        case GreenPlumParser::MEMORY_SHARED_QUOTA:
        case GreenPlumParser::MEMORY_SPILL_RATIO:
        case GreenPlumParser::MERGE:
        case GreenPlumParser::MINUTE_P:
        case GreenPlumParser::MINVALUE:
        case GreenPlumParser::MISSING:
        case GreenPlumParser::MODE:
        case GreenPlumParser::MODIFIES:
        case GreenPlumParser::MODIFY:
        case GreenPlumParser::MONTH_P:
        case GreenPlumParser::MOVE:
        case GreenPlumParser::NAME_P:
        case GreenPlumParser::NAMES:
        case GreenPlumParser::NEXT:
        case GreenPlumParser::NO:
        case GreenPlumParser::NOCREATEDB:
        case GreenPlumParser::NOCREATEEXTTABLE:
        case GreenPlumParser::NOCREATEROLE:
        case GreenPlumParser::NOCREATEUSER:
        case GreenPlumParser::NOINHERIT:
        case GreenPlumParser::NOLOGIN_P:
        case GreenPlumParser::NOOVERCOMMIT:
        case GreenPlumParser::NOSUPERUSER:
        case GreenPlumParser::NOTHING:
        case GreenPlumParser::NOTIFY:
        case GreenPlumParser::NOWAIT:
        case GreenPlumParser::NULLS_P:
        case GreenPlumParser::OBJECT_P:
        case GreenPlumParser::OF:
        case GreenPlumParser::OIDS:
        case GreenPlumParser::OPERATOR:
        case GreenPlumParser::OPTION:
        case GreenPlumParser::OPTIONS:
        case GreenPlumParser::ORDERED:
        case GreenPlumParser::OTHERS:
        case GreenPlumParser::OVER:
        case GreenPlumParser::OVERCOMMIT:
        case GreenPlumParser::OWNED:
        case GreenPlumParser::OWNER:
        case GreenPlumParser::PARSER:
        case GreenPlumParser::PARTIAL:
        case GreenPlumParser::PARTITIONS:
        case GreenPlumParser::PASSING:
        case GreenPlumParser::PASSWORD:
        case GreenPlumParser::PERCENT:
        case GreenPlumParser::PLANS:
        case GreenPlumParser::PREPARE:
        case GreenPlumParser::PREPARED:
        case GreenPlumParser::PRESERVE:
        case GreenPlumParser::PRIOR:
        case GreenPlumParser::PRIVILEGES:
        case GreenPlumParser::PROCEDURAL:
        case GreenPlumParser::PROCEDURE:
        case GreenPlumParser::PROGRAM:
        case GreenPlumParser::PROTOCOL:
        case GreenPlumParser::PUBLIC:
        case GreenPlumParser::QUEUE:
        case GreenPlumParser::QUOTE:
        case GreenPlumParser::RANDOMLY:
        case GreenPlumParser::READ:
        case GreenPlumParser::READABLE:
        case GreenPlumParser::READS:
        case GreenPlumParser::REASSIGN:
        case GreenPlumParser::RECHECK:
        case GreenPlumParser::RECURSIVE:
        case GreenPlumParser::REF:
        case GreenPlumParser::REINDEX:
        case GreenPlumParser::REJECT_P:
        case GreenPlumParser::RELATIVE_P:
        case GreenPlumParser::RELEASE:
        case GreenPlumParser::RENAME:
        case GreenPlumParser::REPEATABLE:
        case GreenPlumParser::REPLACE:
        case GreenPlumParser::REPLICA:
        case GreenPlumParser::RESET:
        case GreenPlumParser::RESOURCE:
        case GreenPlumParser::RESTART:
        case GreenPlumParser::RESTRICT:
        case GreenPlumParser::RETURNS:
        case GreenPlumParser::REVOKE:
        case GreenPlumParser::ROLE:
        case GreenPlumParser::ROLLBACK:
        case GreenPlumParser::ROOTPARTITION:
        case GreenPlumParser::RULE:
        case GreenPlumParser::SAVEPOINT:
        case GreenPlumParser::SCHEMA:
        case GreenPlumParser::SCROLL:
        case GreenPlumParser::SEARCH:
        case GreenPlumParser::SECOND_P:
        case GreenPlumParser::SECURITY:
        case GreenPlumParser::SEGMENT:
        case GreenPlumParser::SEQUENCE:
        case GreenPlumParser::SERIALIZABLE:
        case GreenPlumParser::SESSION:
        case GreenPlumParser::SET:
        case GreenPlumParser::SHARE:
        case GreenPlumParser::SHOW:
        case GreenPlumParser::SIMPLE:
        case GreenPlumParser::SPLIT:
        case GreenPlumParser::SQL:
        case GreenPlumParser::STABLE:
        case GreenPlumParser::STANDALONE_P:
        case GreenPlumParser::START:
        case GreenPlumParser::STATEMENT:
        case GreenPlumParser::STATISTICS:
        case GreenPlumParser::STDIN:
        case GreenPlumParser::STDOUT:
        case GreenPlumParser::STORAGE:
        case GreenPlumParser::STRICT_P:
        case GreenPlumParser::STRIP_P:
        case GreenPlumParser::SUBPARTITION:
        case GreenPlumParser::SUBPARTITIONS:
        case GreenPlumParser::SUPERUSER_P:
        case GreenPlumParser::SYSID:
        case GreenPlumParser::SYSTEM_P:
        case GreenPlumParser::TABLESPACE:
        case GreenPlumParser::TEMP:
        case GreenPlumParser::TEMPLATE:
        case GreenPlumParser::TEMPORARY:
        case GreenPlumParser::TEXT_P:
        case GreenPlumParser::THRESHOLD:
        case GreenPlumParser::TIES:
        case GreenPlumParser::TRANSACTION:
        case GreenPlumParser::TRIGGER:
        case GreenPlumParser::TRUNCATE:
        case GreenPlumParser::TRUSTED:
        case GreenPlumParser::TYPE_P:
        case GreenPlumParser::UNCOMMITTED:
        case GreenPlumParser::UNENCRYPTED:
        case GreenPlumParser::UNKNOWN:
        case GreenPlumParser::UNLISTEN:
        case GreenPlumParser::UNTIL:
        case GreenPlumParser::UPDATE:
        case GreenPlumParser::VACUUM:
        case GreenPlumParser::VALID:
        case GreenPlumParser::VALIDATION:
        case GreenPlumParser::VALIDATOR:
        case GreenPlumParser::VALUE_P:
        case GreenPlumParser::VARYING:
        case GreenPlumParser::VERSION_P:
        case GreenPlumParser::VIEW:
        case GreenPlumParser::VOLATILE:
        case GreenPlumParser::WEB:
        case GreenPlumParser::WHITESPACE_P:
        case GreenPlumParser::WITHIN:
        case GreenPlumParser::WITHOUT:
        case GreenPlumParser::WORK:
        case GreenPlumParser::WRITABLE:
        case GreenPlumParser::WRITE:
        case GreenPlumParser::XML_P:
        case GreenPlumParser::YEAR_P:
        case GreenPlumParser::YES_P:
        case GreenPlumParser::ZONE:
        case GreenPlumParser::COLON:
        case GreenPlumParser::CHAR_STRING:
        case GreenPlumParser::REGULAR_ID:
        case GreenPlumParser::SCONST: {
          setState(5534);
          name();
          break;
        }

        case GreenPlumParser::PARAM: {
          setState(5535);
          match(GreenPlumParser::PARAM);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_func_element_listContext ------------------------------------------------------------------

GreenPlumParser::Table_func_element_listContext::Table_func_element_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Table_func_elementContext *> GreenPlumParser::Table_func_element_listContext::table_func_element() {
  return getRuleContexts<GreenPlumParser::Table_func_elementContext>();
}

GreenPlumParser::Table_func_elementContext* GreenPlumParser::Table_func_element_listContext::table_func_element(size_t i) {
  return getRuleContext<GreenPlumParser::Table_func_elementContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Table_func_element_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Table_func_element_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Table_func_element_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_func_element_list;
}

void GreenPlumParser::Table_func_element_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_func_element_list(this);
}

void GreenPlumParser::Table_func_element_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_func_element_list(this);
}


antlrcpp::Any GreenPlumParser::Table_func_element_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_func_element_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_func_element_listContext* GreenPlumParser::table_func_element_list() {
  Table_func_element_listContext *_localctx = _tracker.createInstance<Table_func_element_listContext>(_ctx, getState());
  enterRule(_localctx, 820, GreenPlumParser::RuleTable_func_element_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5540);
    table_func_element();
    setState(5545);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(5541);
      match(GreenPlumParser::COMMA);
      setState(5542);
      table_func_element();
      setState(5547);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_func_elementContext ------------------------------------------------------------------

GreenPlumParser::Table_func_elementContext::Table_func_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Table_func_elementContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Table_func_elementContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}


size_t GreenPlumParser::Table_func_elementContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_func_element;
}

void GreenPlumParser::Table_func_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_func_element(this);
}

void GreenPlumParser::Table_func_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_func_element(this);
}


antlrcpp::Any GreenPlumParser::Table_func_elementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_func_element(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_func_elementContext* GreenPlumParser::table_func_element() {
  Table_func_elementContext *_localctx = _tracker.createInstance<Table_func_elementContext>(_ctx, getState());
  enterRule(_localctx, 822, GreenPlumParser::RuleTable_func_element);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5548);
    colid();
    setState(5549);
    typename_pg();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Typename_pgContext ------------------------------------------------------------------

GreenPlumParser::Typename_pgContext::Typename_pgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Simple_typenameContext* GreenPlumParser::Typename_pgContext::simple_typename() {
  return getRuleContext<GreenPlumParser::Simple_typenameContext>(0);
}

std::vector<GreenPlumParser::Opt_array_boundsContext *> GreenPlumParser::Typename_pgContext::opt_array_bounds() {
  return getRuleContexts<GreenPlumParser::Opt_array_boundsContext>();
}

GreenPlumParser::Opt_array_boundsContext* GreenPlumParser::Typename_pgContext::opt_array_bounds(size_t i) {
  return getRuleContext<GreenPlumParser::Opt_array_boundsContext>(i);
}

tree::TerminalNode* GreenPlumParser::Typename_pgContext::SETOF() {
  return getToken(GreenPlumParser::SETOF, 0);
}

tree::TerminalNode* GreenPlumParser::Typename_pgContext::ARRAY() {
  return getToken(GreenPlumParser::ARRAY, 0);
}

tree::TerminalNode* GreenPlumParser::Typename_pgContext::LEFT_BRACKET() {
  return getToken(GreenPlumParser::LEFT_BRACKET, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Typename_pgContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Typename_pgContext::RIGHT_BRACKET() {
  return getToken(GreenPlumParser::RIGHT_BRACKET, 0);
}


size_t GreenPlumParser::Typename_pgContext::getRuleIndex() const {
  return GreenPlumParser::RuleTypename_pg;
}

void GreenPlumParser::Typename_pgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypename_pg(this);
}

void GreenPlumParser::Typename_pgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypename_pg(this);
}


antlrcpp::Any GreenPlumParser::Typename_pgContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTypename_pg(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::typename_pg() {
  Typename_pgContext *_localctx = _tracker.createInstance<Typename_pgContext>(_ctx, getState());
  enterRule(_localctx, 824, GreenPlumParser::RuleTypename_pg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(5579);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 602, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5551);
      simple_typename();
      setState(5555);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 600, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(5552);
          opt_array_bounds(); 
        }
        setState(5557);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 600, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5558);
      match(GreenPlumParser::SETOF);
      setState(5559);
      simple_typename();
      setState(5563);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 601, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(5560);
          opt_array_bounds(); 
        }
        setState(5565);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 601, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5566);
      simple_typename();
      setState(5567);
      match(GreenPlumParser::ARRAY);
      setState(5568);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(5569);
      iconst();
      setState(5570);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5572);
      match(GreenPlumParser::SETOF);
      setState(5573);
      simple_typename();
      setState(5574);
      match(GreenPlumParser::ARRAY);
      setState(5575);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(5576);
      iconst();
      setState(5577);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_array_boundsContext ------------------------------------------------------------------

GreenPlumParser::Opt_array_boundsContext::Opt_array_boundsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_array_boundsContext::LEFT_BRACKET() {
  return getToken(GreenPlumParser::LEFT_BRACKET, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_array_boundsContext::RIGHT_BRACKET() {
  return getToken(GreenPlumParser::RIGHT_BRACKET, 0);
}

GreenPlumParser::IconstContext* GreenPlumParser::Opt_array_boundsContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}


size_t GreenPlumParser::Opt_array_boundsContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_array_bounds;
}

void GreenPlumParser::Opt_array_boundsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_array_bounds(this);
}

void GreenPlumParser::Opt_array_boundsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_array_bounds(this);
}


antlrcpp::Any GreenPlumParser::Opt_array_boundsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_array_bounds(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_array_boundsContext* GreenPlumParser::opt_array_bounds() {
  Opt_array_boundsContext *_localctx = _tracker.createInstance<Opt_array_boundsContext>(_ctx, getState());
  enterRule(_localctx, 826, GreenPlumParser::RuleOpt_array_bounds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5587);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 603, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5581);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(5582);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5583);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(5584);
      iconst();
      setState(5585);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_typenameContext ------------------------------------------------------------------

GreenPlumParser::Simple_typenameContext::Simple_typenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Generic_typeContext* GreenPlumParser::Simple_typenameContext::generic_type() {
  return getRuleContext<GreenPlumParser::Generic_typeContext>(0);
}

GreenPlumParser::NumericContext* GreenPlumParser::Simple_typenameContext::numeric() {
  return getRuleContext<GreenPlumParser::NumericContext>(0);
}

GreenPlumParser::BitContext* GreenPlumParser::Simple_typenameContext::bit() {
  return getRuleContext<GreenPlumParser::BitContext>(0);
}

GreenPlumParser::Multi_characterContext* GreenPlumParser::Simple_typenameContext::multi_character() {
  return getRuleContext<GreenPlumParser::Multi_characterContext>(0);
}

GreenPlumParser::Const_datatimeContext* GreenPlumParser::Simple_typenameContext::const_datatime() {
  return getRuleContext<GreenPlumParser::Const_datatimeContext>(0);
}

GreenPlumParser::Const_intervalContext* GreenPlumParser::Simple_typenameContext::const_interval() {
  return getRuleContext<GreenPlumParser::Const_intervalContext>(0);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::Simple_typenameContext::paren_iconst() {
  return getRuleContext<GreenPlumParser::Paren_iconstContext>(0);
}

GreenPlumParser::Opt_intervalContext* GreenPlumParser::Simple_typenameContext::opt_interval() {
  return getRuleContext<GreenPlumParser::Opt_intervalContext>(0);
}


size_t GreenPlumParser::Simple_typenameContext::getRuleIndex() const {
  return GreenPlumParser::RuleSimple_typename;
}

void GreenPlumParser::Simple_typenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_typename(this);
}

void GreenPlumParser::Simple_typenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_typename(this);
}


antlrcpp::Any GreenPlumParser::Simple_typenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSimple_typename(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Simple_typenameContext* GreenPlumParser::simple_typename() {
  Simple_typenameContext *_localctx = _tracker.createInstance<Simple_typenameContext>(_ctx, getState());
  enterRule(_localctx, 828, GreenPlumParser::RuleSimple_typename);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5601);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 606, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5589);
      generic_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5590);
      numeric();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5591);
      bit();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5592);
      multi_character();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5593);
      const_datatime();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5594);
      const_interval();
      setState(5596);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 604, _ctx)) {
      case 1: {
        setState(5595);
        paren_iconst();
        break;
      }

      }
      setState(5599);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 605, _ctx)) {
      case 1: {
        setState(5598);
        opt_interval();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_typenameContext ------------------------------------------------------------------

GreenPlumParser::Const_typenameContext::Const_typenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::NumericContext* GreenPlumParser::Const_typenameContext::numeric() {
  return getRuleContext<GreenPlumParser::NumericContext>(0);
}

GreenPlumParser::Const_bitContext* GreenPlumParser::Const_typenameContext::const_bit() {
  return getRuleContext<GreenPlumParser::Const_bitContext>(0);
}

GreenPlumParser::Const_characterContext* GreenPlumParser::Const_typenameContext::const_character() {
  return getRuleContext<GreenPlumParser::Const_characterContext>(0);
}

GreenPlumParser::Const_datatimeContext* GreenPlumParser::Const_typenameContext::const_datatime() {
  return getRuleContext<GreenPlumParser::Const_datatimeContext>(0);
}


size_t GreenPlumParser::Const_typenameContext::getRuleIndex() const {
  return GreenPlumParser::RuleConst_typename;
}

void GreenPlumParser::Const_typenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_typename(this);
}

void GreenPlumParser::Const_typenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_typename(this);
}


antlrcpp::Any GreenPlumParser::Const_typenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConst_typename(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Const_typenameContext* GreenPlumParser::const_typename() {
  Const_typenameContext *_localctx = _tracker.createInstance<Const_typenameContext>(_ctx, getState());
  enterRule(_localctx, 830, GreenPlumParser::RuleConst_typename);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5607);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::REAL:
      case GreenPlumParser::SMALLINT: {
        enterOuterAlt(_localctx, 1);
        setState(5603);
        numeric();
        break;
      }

      case GreenPlumParser::BIT: {
        enterOuterAlt(_localctx, 2);
        setState(5604);
        const_bit();
        break;
      }

      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::VARCHAR: {
        enterOuterAlt(_localctx, 3);
        setState(5605);
        const_character();
        break;
      }

      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP: {
        enterOuterAlt(_localctx, 4);
        setState(5606);
        const_datatime();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_typeContext ------------------------------------------------------------------

GreenPlumParser::Generic_typeContext::Generic_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Type_function_nameContext* GreenPlumParser::Generic_typeContext::type_function_name() {
  return getRuleContext<GreenPlumParser::Type_function_nameContext>(0);
}

GreenPlumParser::AttrsContext* GreenPlumParser::Generic_typeContext::attrs() {
  return getRuleContext<GreenPlumParser::AttrsContext>(0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Generic_typeContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}


size_t GreenPlumParser::Generic_typeContext::getRuleIndex() const {
  return GreenPlumParser::RuleGeneric_type;
}

void GreenPlumParser::Generic_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneric_type(this);
}

void GreenPlumParser::Generic_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneric_type(this);
}


antlrcpp::Any GreenPlumParser::Generic_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitGeneric_type(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Generic_typeContext* GreenPlumParser::generic_type() {
  Generic_typeContext *_localctx = _tracker.createInstance<Generic_typeContext>(_ctx, getState());
  enterRule(_localctx, 832, GreenPlumParser::RuleGeneric_type);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5609);
    type_function_name();
    setState(5611);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 608, _ctx)) {
    case 1: {
      setState(5610);
      attrs();
      break;
    }

    }
    setState(5614);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 609, _ctx)) {
    case 1: {
      setState(5613);
      paren_expr_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericContext ------------------------------------------------------------------

GreenPlumParser::NumericContext::NumericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::NumericContext::INT_P() {
  return getToken(GreenPlumParser::INT_P, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::INTEGER() {
  return getToken(GreenPlumParser::INTEGER, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::SMALLINT() {
  return getToken(GreenPlumParser::SMALLINT, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::BIGINT() {
  return getToken(GreenPlumParser::BIGINT, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::REAL() {
  return getToken(GreenPlumParser::REAL, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::FLOAT_P() {
  return getToken(GreenPlumParser::FLOAT_P, 0);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::NumericContext::paren_iconst() {
  return getRuleContext<GreenPlumParser::Paren_iconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::DOUBLE_P() {
  return getToken(GreenPlumParser::DOUBLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::PRECISION() {
  return getToken(GreenPlumParser::PRECISION, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::DECIMAL_P() {
  return getToken(GreenPlumParser::DECIMAL_P, 0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::NumericContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::DEC() {
  return getToken(GreenPlumParser::DEC, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::NUMERIC() {
  return getToken(GreenPlumParser::NUMERIC, 0);
}

tree::TerminalNode* GreenPlumParser::NumericContext::BOOLEAN_P() {
  return getToken(GreenPlumParser::BOOLEAN_P, 0);
}


size_t GreenPlumParser::NumericContext::getRuleIndex() const {
  return GreenPlumParser::RuleNumeric;
}

void GreenPlumParser::NumericContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumeric(this);
}

void GreenPlumParser::NumericContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumeric(this);
}


antlrcpp::Any GreenPlumParser::NumericContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitNumeric(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::NumericContext* GreenPlumParser::numeric() {
  NumericContext *_localctx = _tracker.createInstance<NumericContext>(_ctx, getState());
  enterRule(_localctx, 834, GreenPlumParser::RuleNumeric);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5640);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::INT_P: {
        enterOuterAlt(_localctx, 1);
        setState(5616);
        match(GreenPlumParser::INT_P);
        break;
      }

      case GreenPlumParser::INTEGER: {
        enterOuterAlt(_localctx, 2);
        setState(5617);
        match(GreenPlumParser::INTEGER);
        break;
      }

      case GreenPlumParser::SMALLINT: {
        enterOuterAlt(_localctx, 3);
        setState(5618);
        match(GreenPlumParser::SMALLINT);
        break;
      }

      case GreenPlumParser::BIGINT: {
        enterOuterAlt(_localctx, 4);
        setState(5619);
        match(GreenPlumParser::BIGINT);
        break;
      }

      case GreenPlumParser::REAL: {
        enterOuterAlt(_localctx, 5);
        setState(5620);
        match(GreenPlumParser::REAL);
        break;
      }

      case GreenPlumParser::FLOAT_P: {
        enterOuterAlt(_localctx, 6);
        setState(5621);
        match(GreenPlumParser::FLOAT_P);
        setState(5623);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 610, _ctx)) {
        case 1: {
          setState(5622);
          paren_iconst();
          break;
        }

        }
        break;
      }

      case GreenPlumParser::DOUBLE_P: {
        enterOuterAlt(_localctx, 7);
        setState(5625);
        match(GreenPlumParser::DOUBLE_P);
        setState(5626);
        match(GreenPlumParser::PRECISION);
        break;
      }

      case GreenPlumParser::DECIMAL_P: {
        enterOuterAlt(_localctx, 8);
        setState(5627);
        match(GreenPlumParser::DECIMAL_P);
        setState(5629);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 611, _ctx)) {
        case 1: {
          setState(5628);
          paren_expr_list();
          break;
        }

        }
        break;
      }

      case GreenPlumParser::DEC: {
        enterOuterAlt(_localctx, 9);
        setState(5631);
        match(GreenPlumParser::DEC);
        setState(5633);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 612, _ctx)) {
        case 1: {
          setState(5632);
          paren_expr_list();
          break;
        }

        }
        break;
      }

      case GreenPlumParser::NUMERIC: {
        enterOuterAlt(_localctx, 10);
        setState(5635);
        match(GreenPlumParser::NUMERIC);
        setState(5637);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 613, _ctx)) {
        case 1: {
          setState(5636);
          paren_expr_list();
          break;
        }

        }
        break;
      }

      case GreenPlumParser::BOOLEAN_P: {
        enterOuterAlt(_localctx, 11);
        setState(5639);
        match(GreenPlumParser::BOOLEAN_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitContext ------------------------------------------------------------------

GreenPlumParser::BitContext::BitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Bit_with_lengthContext* GreenPlumParser::BitContext::bit_with_length() {
  return getRuleContext<GreenPlumParser::Bit_with_lengthContext>(0);
}

GreenPlumParser::Bit_without_lengthContext* GreenPlumParser::BitContext::bit_without_length() {
  return getRuleContext<GreenPlumParser::Bit_without_lengthContext>(0);
}


size_t GreenPlumParser::BitContext::getRuleIndex() const {
  return GreenPlumParser::RuleBit;
}

void GreenPlumParser::BitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBit(this);
}

void GreenPlumParser::BitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBit(this);
}


antlrcpp::Any GreenPlumParser::BitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitBit(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::BitContext* GreenPlumParser::bit() {
  BitContext *_localctx = _tracker.createInstance<BitContext>(_ctx, getState());
  enterRule(_localctx, 836, GreenPlumParser::RuleBit);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5644);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 615, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5642);
      bit_with_length();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5643);
      bit_without_length();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_bitContext ------------------------------------------------------------------

GreenPlumParser::Const_bitContext::Const_bitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Bit_with_lengthContext* GreenPlumParser::Const_bitContext::bit_with_length() {
  return getRuleContext<GreenPlumParser::Bit_with_lengthContext>(0);
}

GreenPlumParser::Bit_without_lengthContext* GreenPlumParser::Const_bitContext::bit_without_length() {
  return getRuleContext<GreenPlumParser::Bit_without_lengthContext>(0);
}


size_t GreenPlumParser::Const_bitContext::getRuleIndex() const {
  return GreenPlumParser::RuleConst_bit;
}

void GreenPlumParser::Const_bitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_bit(this);
}

void GreenPlumParser::Const_bitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_bit(this);
}


antlrcpp::Any GreenPlumParser::Const_bitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConst_bit(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Const_bitContext* GreenPlumParser::const_bit() {
  Const_bitContext *_localctx = _tracker.createInstance<Const_bitContext>(_ctx, getState());
  enterRule(_localctx, 838, GreenPlumParser::RuleConst_bit);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5648);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 616, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5646);
      bit_with_length();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5647);
      bit_without_length();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bit_with_lengthContext ------------------------------------------------------------------

GreenPlumParser::Bit_with_lengthContext::Bit_with_lengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Bit_with_lengthContext::BIT() {
  return getToken(GreenPlumParser::BIT, 0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Bit_with_lengthContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Bit_with_lengthContext::VARYING() {
  return getToken(GreenPlumParser::VARYING, 0);
}


size_t GreenPlumParser::Bit_with_lengthContext::getRuleIndex() const {
  return GreenPlumParser::RuleBit_with_length;
}

void GreenPlumParser::Bit_with_lengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBit_with_length(this);
}

void GreenPlumParser::Bit_with_lengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBit_with_length(this);
}


antlrcpp::Any GreenPlumParser::Bit_with_lengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitBit_with_length(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Bit_with_lengthContext* GreenPlumParser::bit_with_length() {
  Bit_with_lengthContext *_localctx = _tracker.createInstance<Bit_with_lengthContext>(_ctx, getState());
  enterRule(_localctx, 840, GreenPlumParser::RuleBit_with_length);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5650);
    match(GreenPlumParser::BIT);
    setState(5652);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::VARYING) {
      setState(5651);
      match(GreenPlumParser::VARYING);
    }
    setState(5654);
    paren_expr_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bit_without_lengthContext ------------------------------------------------------------------

GreenPlumParser::Bit_without_lengthContext::Bit_without_lengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Bit_without_lengthContext::BIT() {
  return getToken(GreenPlumParser::BIT, 0);
}

tree::TerminalNode* GreenPlumParser::Bit_without_lengthContext::VARYING() {
  return getToken(GreenPlumParser::VARYING, 0);
}


size_t GreenPlumParser::Bit_without_lengthContext::getRuleIndex() const {
  return GreenPlumParser::RuleBit_without_length;
}

void GreenPlumParser::Bit_without_lengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBit_without_length(this);
}

void GreenPlumParser::Bit_without_lengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBit_without_length(this);
}


antlrcpp::Any GreenPlumParser::Bit_without_lengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitBit_without_length(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Bit_without_lengthContext* GreenPlumParser::bit_without_length() {
  Bit_without_lengthContext *_localctx = _tracker.createInstance<Bit_without_lengthContext>(_ctx, getState());
  enterRule(_localctx, 842, GreenPlumParser::RuleBit_without_length);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5656);
    match(GreenPlumParser::BIT);
    setState(5658);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 618, _ctx)) {
    case 1: {
      setState(5657);
      match(GreenPlumParser::VARYING);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multi_characterContext ------------------------------------------------------------------

GreenPlumParser::Multi_characterContext::Multi_characterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Character_with_lengthContext* GreenPlumParser::Multi_characterContext::character_with_length() {
  return getRuleContext<GreenPlumParser::Character_with_lengthContext>(0);
}

GreenPlumParser::Character_without_lengthContext* GreenPlumParser::Multi_characterContext::character_without_length() {
  return getRuleContext<GreenPlumParser::Character_without_lengthContext>(0);
}


size_t GreenPlumParser::Multi_characterContext::getRuleIndex() const {
  return GreenPlumParser::RuleMulti_character;
}

void GreenPlumParser::Multi_characterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMulti_character(this);
}

void GreenPlumParser::Multi_characterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMulti_character(this);
}


antlrcpp::Any GreenPlumParser::Multi_characterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitMulti_character(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Multi_characterContext* GreenPlumParser::multi_character() {
  Multi_characterContext *_localctx = _tracker.createInstance<Multi_characterContext>(_ctx, getState());
  enterRule(_localctx, 844, GreenPlumParser::RuleMulti_character);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5662);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 619, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5660);
      character_with_length();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5661);
      character_without_length();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_characterContext ------------------------------------------------------------------

GreenPlumParser::Const_characterContext::Const_characterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Character_with_lengthContext* GreenPlumParser::Const_characterContext::character_with_length() {
  return getRuleContext<GreenPlumParser::Character_with_lengthContext>(0);
}

GreenPlumParser::Character_without_lengthContext* GreenPlumParser::Const_characterContext::character_without_length() {
  return getRuleContext<GreenPlumParser::Character_without_lengthContext>(0);
}


size_t GreenPlumParser::Const_characterContext::getRuleIndex() const {
  return GreenPlumParser::RuleConst_character;
}

void GreenPlumParser::Const_characterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_character(this);
}

void GreenPlumParser::Const_characterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_character(this);
}


antlrcpp::Any GreenPlumParser::Const_characterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConst_character(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Const_characterContext* GreenPlumParser::const_character() {
  Const_characterContext *_localctx = _tracker.createInstance<Const_characterContext>(_ctx, getState());
  enterRule(_localctx, 846, GreenPlumParser::RuleConst_character);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5666);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 620, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5664);
      character_with_length();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5665);
      character_without_length();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Character_with_lengthContext ------------------------------------------------------------------

GreenPlumParser::Character_with_lengthContext::Character_with_lengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::CharacterContext* GreenPlumParser::Character_with_lengthContext::character() {
  return getRuleContext<GreenPlumParser::CharacterContext>(0);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::Character_with_lengthContext::paren_iconst() {
  return getRuleContext<GreenPlumParser::Paren_iconstContext>(0);
}

GreenPlumParser::Opt_charsetContext* GreenPlumParser::Character_with_lengthContext::opt_charset() {
  return getRuleContext<GreenPlumParser::Opt_charsetContext>(0);
}


size_t GreenPlumParser::Character_with_lengthContext::getRuleIndex() const {
  return GreenPlumParser::RuleCharacter_with_length;
}

void GreenPlumParser::Character_with_lengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacter_with_length(this);
}

void GreenPlumParser::Character_with_lengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacter_with_length(this);
}


antlrcpp::Any GreenPlumParser::Character_with_lengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCharacter_with_length(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Character_with_lengthContext* GreenPlumParser::character_with_length() {
  Character_with_lengthContext *_localctx = _tracker.createInstance<Character_with_lengthContext>(_ctx, getState());
  enterRule(_localctx, 848, GreenPlumParser::RuleCharacter_with_length);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5668);
    character();
    setState(5669);
    paren_iconst();
    setState(5671);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 621, _ctx)) {
    case 1: {
      setState(5670);
      opt_charset();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Character_without_lengthContext ------------------------------------------------------------------

GreenPlumParser::Character_without_lengthContext::Character_without_lengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::CharacterContext* GreenPlumParser::Character_without_lengthContext::character() {
  return getRuleContext<GreenPlumParser::CharacterContext>(0);
}

GreenPlumParser::Opt_charsetContext* GreenPlumParser::Character_without_lengthContext::opt_charset() {
  return getRuleContext<GreenPlumParser::Opt_charsetContext>(0);
}


size_t GreenPlumParser::Character_without_lengthContext::getRuleIndex() const {
  return GreenPlumParser::RuleCharacter_without_length;
}

void GreenPlumParser::Character_without_lengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacter_without_length(this);
}

void GreenPlumParser::Character_without_lengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacter_without_length(this);
}


antlrcpp::Any GreenPlumParser::Character_without_lengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCharacter_without_length(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Character_without_lengthContext* GreenPlumParser::character_without_length() {
  Character_without_lengthContext *_localctx = _tracker.createInstance<Character_without_lengthContext>(_ctx, getState());
  enterRule(_localctx, 850, GreenPlumParser::RuleCharacter_without_length);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5673);
    character();
    setState(5675);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 622, _ctx)) {
    case 1: {
      setState(5674);
      opt_charset();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterContext ------------------------------------------------------------------

GreenPlumParser::CharacterContext::CharacterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::CharacterContext::CHARACTER() {
  return getToken(GreenPlumParser::CHARACTER, 0);
}

tree::TerminalNode* GreenPlumParser::CharacterContext::CHAR_P() {
  return getToken(GreenPlumParser::CHAR_P, 0);
}

tree::TerminalNode* GreenPlumParser::CharacterContext::NCHAR() {
  return getToken(GreenPlumParser::NCHAR, 0);
}

tree::TerminalNode* GreenPlumParser::CharacterContext::VARYING() {
  return getToken(GreenPlumParser::VARYING, 0);
}

tree::TerminalNode* GreenPlumParser::CharacterContext::VARCHAR() {
  return getToken(GreenPlumParser::VARCHAR, 0);
}

tree::TerminalNode* GreenPlumParser::CharacterContext::NATIONAL() {
  return getToken(GreenPlumParser::NATIONAL, 0);
}


size_t GreenPlumParser::CharacterContext::getRuleIndex() const {
  return GreenPlumParser::RuleCharacter;
}

void GreenPlumParser::CharacterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacter(this);
}

void GreenPlumParser::CharacterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacter(this);
}


antlrcpp::Any GreenPlumParser::CharacterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCharacter(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::CharacterContext* GreenPlumParser::character() {
  CharacterContext *_localctx = _tracker.createInstance<CharacterContext>(_ctx, getState());
  enterRule(_localctx, 852, GreenPlumParser::RuleCharacter);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5687);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::NCHAR: {
        enterOuterAlt(_localctx, 1);
        setState(5677);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::CHARACTER

        || _la == GreenPlumParser::CHAR_P || _la == GreenPlumParser::NCHAR)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5679);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 623, _ctx)) {
        case 1: {
          setState(5678);
          match(GreenPlumParser::VARYING);
          break;
        }

        }
        break;
      }

      case GreenPlumParser::VARCHAR: {
        enterOuterAlt(_localctx, 2);
        setState(5681);
        match(GreenPlumParser::VARCHAR);
        break;
      }

      case GreenPlumParser::NATIONAL: {
        enterOuterAlt(_localctx, 3);
        setState(5682);
        match(GreenPlumParser::NATIONAL);
        setState(5683);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::CHARACTER

        || _la == GreenPlumParser::CHAR_P)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5685);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 624, _ctx)) {
        case 1: {
          setState(5684);
          match(GreenPlumParser::VARYING);
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_charsetContext ------------------------------------------------------------------

GreenPlumParser::Opt_charsetContext::Opt_charsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_charsetContext::CHARACTER() {
  return getToken(GreenPlumParser::CHARACTER, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_charsetContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Opt_charsetContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Opt_charsetContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_charset;
}

void GreenPlumParser::Opt_charsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_charset(this);
}

void GreenPlumParser::Opt_charsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_charset(this);
}


antlrcpp::Any GreenPlumParser::Opt_charsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_charset(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_charsetContext* GreenPlumParser::opt_charset() {
  Opt_charsetContext *_localctx = _tracker.createInstance<Opt_charsetContext>(_ctx, getState());
  enterRule(_localctx, 854, GreenPlumParser::RuleOpt_charset);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5689);
    match(GreenPlumParser::CHARACTER);
    setState(5690);
    match(GreenPlumParser::SET);
    setState(5691);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_datatimeContext ------------------------------------------------------------------

GreenPlumParser::Const_datatimeContext::Const_datatimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Const_datatimeContext::TIMESTAMP() {
  return getToken(GreenPlumParser::TIMESTAMP, 0);
}

tree::TerminalNode* GreenPlumParser::Const_datatimeContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::Const_datatimeContext::paren_iconst() {
  return getRuleContext<GreenPlumParser::Paren_iconstContext>(0);
}

GreenPlumParser::Opt_timezoneContext* GreenPlumParser::Const_datatimeContext::opt_timezone() {
  return getRuleContext<GreenPlumParser::Opt_timezoneContext>(0);
}


size_t GreenPlumParser::Const_datatimeContext::getRuleIndex() const {
  return GreenPlumParser::RuleConst_datatime;
}

void GreenPlumParser::Const_datatimeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_datatime(this);
}

void GreenPlumParser::Const_datatimeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_datatime(this);
}


antlrcpp::Any GreenPlumParser::Const_datatimeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConst_datatime(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Const_datatimeContext* GreenPlumParser::const_datatime() {
  Const_datatimeContext *_localctx = _tracker.createInstance<Const_datatimeContext>(_ctx, getState());
  enterRule(_localctx, 856, GreenPlumParser::RuleConst_datatime);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5693);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::TIME

    || _la == GreenPlumParser::TIMESTAMP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5695);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 626, _ctx)) {
    case 1: {
      setState(5694);
      paren_iconst();
      break;
    }

    }
    setState(5698);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 627, _ctx)) {
    case 1: {
      setState(5697);
      opt_timezone();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_intervalContext ------------------------------------------------------------------

GreenPlumParser::Const_intervalContext::Const_intervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Const_intervalContext::INTERVAL() {
  return getToken(GreenPlumParser::INTERVAL, 0);
}


size_t GreenPlumParser::Const_intervalContext::getRuleIndex() const {
  return GreenPlumParser::RuleConst_interval;
}

void GreenPlumParser::Const_intervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_interval(this);
}

void GreenPlumParser::Const_intervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_interval(this);
}


antlrcpp::Any GreenPlumParser::Const_intervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConst_interval(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Const_intervalContext* GreenPlumParser::const_interval() {
  Const_intervalContext *_localctx = _tracker.createInstance<Const_intervalContext>(_ctx, getState());
  enterRule(_localctx, 858, GreenPlumParser::RuleConst_interval);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5700);
    match(GreenPlumParser::INTERVAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_timezoneContext ------------------------------------------------------------------

GreenPlumParser::Opt_timezoneContext::Opt_timezoneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_timezoneContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_timezoneContext::ZONE() {
  return getToken(GreenPlumParser::ZONE, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_timezoneContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_timezoneContext::WITHOUT() {
  return getToken(GreenPlumParser::WITHOUT, 0);
}


size_t GreenPlumParser::Opt_timezoneContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_timezone;
}

void GreenPlumParser::Opt_timezoneContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_timezone(this);
}

void GreenPlumParser::Opt_timezoneContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_timezone(this);
}


antlrcpp::Any GreenPlumParser::Opt_timezoneContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_timezone(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_timezoneContext* GreenPlumParser::opt_timezone() {
  Opt_timezoneContext *_localctx = _tracker.createInstance<Opt_timezoneContext>(_ctx, getState());
  enterRule(_localctx, 860, GreenPlumParser::RuleOpt_timezone);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5702);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::WITH

    || _la == GreenPlumParser::WITHOUT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5703);
    match(GreenPlumParser::TIME);
    setState(5704);
    match(GreenPlumParser::ZONE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_intervalContext ------------------------------------------------------------------

GreenPlumParser::Opt_intervalContext::Opt_intervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_intervalContext::YEAR_P() {
  return getToken(GreenPlumParser::YEAR_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_intervalContext::MONTH_P() {
  return getToken(GreenPlumParser::MONTH_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_intervalContext::DAY_P() {
  return getToken(GreenPlumParser::DAY_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_intervalContext::HOUR_P() {
  return getToken(GreenPlumParser::HOUR_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_intervalContext::MINUTE_P() {
  return getToken(GreenPlumParser::MINUTE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_intervalContext::SECOND_P() {
  return getToken(GreenPlumParser::SECOND_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_intervalContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}


size_t GreenPlumParser::Opt_intervalContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_interval;
}

void GreenPlumParser::Opt_intervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_interval(this);
}

void GreenPlumParser::Opt_intervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_interval(this);
}


antlrcpp::Any GreenPlumParser::Opt_intervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_interval(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_intervalContext* GreenPlumParser::opt_interval() {
  Opt_intervalContext *_localctx = _tracker.createInstance<Opt_intervalContext>(_ctx, getState());
  enterRule(_localctx, 862, GreenPlumParser::RuleOpt_interval);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5733);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 628, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5706);
      match(GreenPlumParser::YEAR_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5707);
      match(GreenPlumParser::MONTH_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5708);
      match(GreenPlumParser::DAY_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5709);
      match(GreenPlumParser::HOUR_P);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5710);
      match(GreenPlumParser::MINUTE_P);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5711);
      match(GreenPlumParser::SECOND_P);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5712);
      match(GreenPlumParser::YEAR_P);
      setState(5713);
      match(GreenPlumParser::TO);
      setState(5714);
      match(GreenPlumParser::MONTH_P);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5715);
      match(GreenPlumParser::DAY_P);
      setState(5716);
      match(GreenPlumParser::TO);
      setState(5717);
      match(GreenPlumParser::HOUR_P);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5718);
      match(GreenPlumParser::DAY_P);
      setState(5719);
      match(GreenPlumParser::TO);
      setState(5720);
      match(GreenPlumParser::MINUTE_P);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5721);
      match(GreenPlumParser::DAY_P);
      setState(5722);
      match(GreenPlumParser::TO);
      setState(5723);
      match(GreenPlumParser::SECOND_P);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5724);
      match(GreenPlumParser::HOUR_P);
      setState(5725);
      match(GreenPlumParser::TO);
      setState(5726);
      match(GreenPlumParser::MINUTE_P);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5727);
      match(GreenPlumParser::HOUR_P);
      setState(5728);
      match(GreenPlumParser::TO);
      setState(5729);
      match(GreenPlumParser::SECOND_P);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5730);
      match(GreenPlumParser::MINUTE_P);
      setState(5731);
      match(GreenPlumParser::TO);
      setState(5732);
      match(GreenPlumParser::SECOND_P);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_exprContext ------------------------------------------------------------------

GreenPlumParser::A_exprContext::A_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Logical_exprContext* GreenPlumParser::A_exprContext::logical_expr() {
  return getRuleContext<GreenPlumParser::Logical_exprContext>(0);
}


size_t GreenPlumParser::A_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleA_expr;
}

void GreenPlumParser::A_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterA_expr(this);
}

void GreenPlumParser::A_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitA_expr(this);
}


antlrcpp::Any GreenPlumParser::A_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitA_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::A_exprContext* GreenPlumParser::a_expr() {
  A_exprContext *_localctx = _tracker.createInstance<A_exprContext>(_ctx, getState());
  enterRule(_localctx, 864, GreenPlumParser::RuleA_expr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5735);
    logical_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Logical_exprContext ------------------------------------------------------------------

GreenPlumParser::Logical_exprContext::Logical_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Multiset_exprContext* GreenPlumParser::Logical_exprContext::multiset_expr() {
  return getRuleContext<GreenPlumParser::Multiset_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::IS() {
  return getToken(GreenPlumParser::IS, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::DISTINCT() {
  return getToken(GreenPlumParser::DISTINCT, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

std::vector<GreenPlumParser::Logical_exprContext *> GreenPlumParser::Logical_exprContext::logical_expr() {
  return getRuleContexts<GreenPlumParser::Logical_exprContext>();
}

GreenPlumParser::Logical_exprContext* GreenPlumParser::Logical_exprContext::logical_expr(size_t i) {
  return getRuleContext<GreenPlumParser::Logical_exprContext>(i);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::OF() {
  return getToken(GreenPlumParser::OF, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Type_listContext* GreenPlumParser::Logical_exprContext::type_list() {
  return getRuleContext<GreenPlumParser::Type_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::DOCUMENT_P() {
  return getToken(GreenPlumParser::DOCUMENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::TRUE_P() {
  return getToken(GreenPlumParser::TRUE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::FALSE_P() {
  return getToken(GreenPlumParser::FALSE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::UNKNOWN() {
  return getToken(GreenPlumParser::UNKNOWN, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::ISNULL() {
  return getToken(GreenPlumParser::ISNULL, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::NOTNULL() {
  return getToken(GreenPlumParser::NOTNULL, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::AND() {
  return getToken(GreenPlumParser::AND, 0);
}

tree::TerminalNode* GreenPlumParser::Logical_exprContext::OR() {
  return getToken(GreenPlumParser::OR, 0);
}


size_t GreenPlumParser::Logical_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleLogical_expr;
}

void GreenPlumParser::Logical_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogical_expr(this);
}

void GreenPlumParser::Logical_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogical_expr(this);
}


antlrcpp::Any GreenPlumParser::Logical_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitLogical_expr(this);
  else
    return visitor->visitChildren(this);
}


GreenPlumParser::Logical_exprContext* GreenPlumParser::logical_expr() {
   return logical_expr(0);
}

GreenPlumParser::Logical_exprContext* GreenPlumParser::logical_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::Logical_exprContext *_localctx = _tracker.createInstance<Logical_exprContext>(_ctx, parentState);
  GreenPlumParser::Logical_exprContext *previousContext = _localctx;
  size_t startState = 866;
  enterRecursionRule(_localctx, 866, GreenPlumParser::RuleLogical_expr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5765);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 632, _ctx)) {
    case 1: {
      setState(5738);
      multiset_expr();
      setState(5758);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 631, _ctx)) {
      case 1: {
        setState(5739);
        match(GreenPlumParser::IS);
        setState(5741);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::NOT) {
          setState(5740);
          match(GreenPlumParser::NOT);
        }
        setState(5756);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::NULL_P: {
            setState(5743);
            match(GreenPlumParser::NULL_P);
            break;
          }

          case GreenPlumParser::DISTINCT: {
            setState(5744);
            match(GreenPlumParser::DISTINCT);
            setState(5745);
            match(GreenPlumParser::FROM);
            setState(5746);
            logical_expr(0);
            break;
          }

          case GreenPlumParser::OF: {
            setState(5747);
            match(GreenPlumParser::OF);
            setState(5748);
            match(GreenPlumParser::LEFT_PAREN);
            setState(5749);
            type_list();
            setState(5750);
            match(GreenPlumParser::RIGHT_PAREN);
            break;
          }

          case GreenPlumParser::DOCUMENT_P: {
            setState(5752);
            match(GreenPlumParser::DOCUMENT_P);
            break;
          }

          case GreenPlumParser::TRUE_P: {
            setState(5753);
            match(GreenPlumParser::TRUE_P);
            break;
          }

          case GreenPlumParser::FALSE_P: {
            setState(5754);
            match(GreenPlumParser::FALSE_P);
            break;
          }

          case GreenPlumParser::UNKNOWN: {
            setState(5755);
            match(GreenPlumParser::UNKNOWN);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      }
      break;
    }

    case 2: {
      setState(5760);
      multiset_expr();
      setState(5761);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::ISNULL

      || _la == GreenPlumParser::NOTNULL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      setState(5763);
      match(GreenPlumParser::NOT);
      setState(5764);
      logical_expr(3);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5775);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 634, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5773);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 633, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Logical_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleLogical_expr);
          setState(5767);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5768);
          match(GreenPlumParser::AND);
          setState(5769);
          logical_expr(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Logical_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleLogical_expr);
          setState(5770);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5771);
          match(GreenPlumParser::OR);
          setState(5772);
          logical_expr(2);
          break;
        }

        } 
      }
      setState(5777);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 634, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Multiset_exprContext ------------------------------------------------------------------

GreenPlumParser::Multiset_exprContext::Multiset_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Relational_exprContext* GreenPlumParser::Multiset_exprContext::relational_expr() {
  return getRuleContext<GreenPlumParser::Relational_exprContext>(0);
}


size_t GreenPlumParser::Multiset_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleMultiset_expr;
}

void GreenPlumParser::Multiset_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiset_expr(this);
}

void GreenPlumParser::Multiset_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiset_expr(this);
}


antlrcpp::Any GreenPlumParser::Multiset_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitMultiset_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Multiset_exprContext* GreenPlumParser::multiset_expr() {
  Multiset_exprContext *_localctx = _tracker.createInstance<Multiset_exprContext>(_ctx, getState());
  enterRule(_localctx, 868, GreenPlumParser::RuleMultiset_expr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5778);
    relational_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relational_exprContext ------------------------------------------------------------------

GreenPlumParser::Relational_exprContext::Relational_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Compound_exprContext* GreenPlumParser::Relational_exprContext::compound_expr() {
  return getRuleContext<GreenPlumParser::Compound_exprContext>(0);
}

std::vector<GreenPlumParser::Relational_exprContext *> GreenPlumParser::Relational_exprContext::relational_expr() {
  return getRuleContexts<GreenPlumParser::Relational_exprContext>();
}

GreenPlumParser::Relational_exprContext* GreenPlumParser::Relational_exprContext::relational_expr(size_t i) {
  return getRuleContext<GreenPlumParser::Relational_exprContext>(i);
}

GreenPlumParser::Relational_opContext* GreenPlumParser::Relational_exprContext::relational_op() {
  return getRuleContext<GreenPlumParser::Relational_opContext>(0);
}


size_t GreenPlumParser::Relational_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleRelational_expr;
}

void GreenPlumParser::Relational_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelational_expr(this);
}

void GreenPlumParser::Relational_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelational_expr(this);
}


antlrcpp::Any GreenPlumParser::Relational_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRelational_expr(this);
  else
    return visitor->visitChildren(this);
}


GreenPlumParser::Relational_exprContext* GreenPlumParser::relational_expr() {
   return relational_expr(0);
}

GreenPlumParser::Relational_exprContext* GreenPlumParser::relational_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::Relational_exprContext *_localctx = _tracker.createInstance<Relational_exprContext>(_ctx, parentState);
  GreenPlumParser::Relational_exprContext *previousContext = _localctx;
  size_t startState = 870;
  enterRecursionRule(_localctx, 870, GreenPlumParser::RuleRelational_expr, precedence);

    

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5781);
    compound_expr();
    _ctx->stop = _input->LT(-1);
    setState(5789);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 635, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Relational_exprContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleRelational_expr);
        setState(5783);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(5784);
        relational_op();
        setState(5785);
        relational_expr(3); 
      }
      setState(5791);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 635, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Relational_opContext ------------------------------------------------------------------

GreenPlumParser::Relational_opContext::Relational_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Relational_opContext::LESS_THAN_OP() {
  return getToken(GreenPlumParser::LESS_THAN_OP, 0);
}

tree::TerminalNode* GreenPlumParser::Relational_opContext::GREATER_THAN_OP() {
  return getToken(GreenPlumParser::GREATER_THAN_OP, 0);
}

tree::TerminalNode* GreenPlumParser::Relational_opContext::EQUALS_OP() {
  return getToken(GreenPlumParser::EQUALS_OP, 0);
}

tree::TerminalNode* GreenPlumParser::Relational_opContext::NOT_EQUAL_OP() {
  return getToken(GreenPlumParser::NOT_EQUAL_OP, 0);
}


size_t GreenPlumParser::Relational_opContext::getRuleIndex() const {
  return GreenPlumParser::RuleRelational_op;
}

void GreenPlumParser::Relational_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelational_op(this);
}

void GreenPlumParser::Relational_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelational_op(this);
}


antlrcpp::Any GreenPlumParser::Relational_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRelational_op(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Relational_opContext* GreenPlumParser::relational_op() {
  Relational_opContext *_localctx = _tracker.createInstance<Relational_opContext>(_ctx, getState());
  enterRule(_localctx, 872, GreenPlumParser::RuleRelational_op);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5798);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::GREATER_THAN_OP:
      case GreenPlumParser::LESS_THAN_OP: {
        enterOuterAlt(_localctx, 1);
        setState(5792);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::GREATER_THAN_OP

        || _la == GreenPlumParser::LESS_THAN_OP)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5794);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::EQUALS_OP) {
          setState(5793);
          match(GreenPlumParser::EQUALS_OP);
        }
        break;
      }

      case GreenPlumParser::EQUALS_OP: {
        enterOuterAlt(_localctx, 2);
        setState(5796);
        match(GreenPlumParser::EQUALS_OP);
        break;
      }

      case GreenPlumParser::NOT_EQUAL_OP: {
        enterOuterAlt(_localctx, 3);
        setState(5797);
        match(GreenPlumParser::NOT_EQUAL_OP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_exprContext ------------------------------------------------------------------

GreenPlumParser::Compound_exprContext::Compound_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::ConcatenationContext *> GreenPlumParser::Compound_exprContext::concatenation() {
  return getRuleContexts<GreenPlumParser::ConcatenationContext>();
}

GreenPlumParser::ConcatenationContext* GreenPlumParser::Compound_exprContext::concatenation(size_t i) {
  return getRuleContext<GreenPlumParser::ConcatenationContext>(i);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::IN_P() {
  return getToken(GreenPlumParser::IN_P, 0);
}

GreenPlumParser::In_exprContext* GreenPlumParser::Compound_exprContext::in_expr() {
  return getRuleContext<GreenPlumParser::In_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::BETWEEN() {
  return getToken(GreenPlumParser::BETWEEN, 0);
}

GreenPlumParser::Between_elementsContext* GreenPlumParser::Compound_exprContext::between_elements() {
  return getRuleContext<GreenPlumParser::Between_elementsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::SYMMETRIC() {
  return getToken(GreenPlumParser::SYMMETRIC, 0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::LIKE() {
  return getToken(GreenPlumParser::LIKE, 0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::ILIKE() {
  return getToken(GreenPlumParser::ILIKE, 0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::SIMILAR() {
  return getToken(GreenPlumParser::SIMILAR, 0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::ESCAPE() {
  return getToken(GreenPlumParser::ESCAPE, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Compound_exprContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::ASYMMETRIC() {
  return getToken(GreenPlumParser::ASYMMETRIC, 0);
}

std::vector<GreenPlumParser::Concatenation_listContext *> GreenPlumParser::Compound_exprContext::concatenation_list() {
  return getRuleContexts<GreenPlumParser::Concatenation_listContext>();
}

GreenPlumParser::Concatenation_listContext* GreenPlumParser::Compound_exprContext::concatenation_list(size_t i) {
  return getRuleContext<GreenPlumParser::Concatenation_listContext>(i);
}

tree::TerminalNode* GreenPlumParser::Compound_exprContext::OVERLAPS() {
  return getToken(GreenPlumParser::OVERLAPS, 0);
}


size_t GreenPlumParser::Compound_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleCompound_expr;
}

void GreenPlumParser::Compound_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_expr(this);
}

void GreenPlumParser::Compound_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_expr(this);
}


antlrcpp::Any GreenPlumParser::Compound_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCompound_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Compound_exprContext* GreenPlumParser::compound_expr() {
  Compound_exprContext *_localctx = _tracker.createInstance<Compound_exprContext>(_ctx, getState());
  enterRule(_localctx, 874, GreenPlumParser::RuleCompound_expr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5833);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 645, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5800);
      concatenation(0);
      setState(5827);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 644, _ctx)) {
      case 1: {
        setState(5802);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::NOT) {
          setState(5801);
          match(GreenPlumParser::NOT);
        }
        setState(5825);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GreenPlumParser::IN_P: {
            setState(5804);
            match(GreenPlumParser::IN_P);
            setState(5805);
            in_expr();
            break;
          }

          case GreenPlumParser::BETWEEN: {
            setState(5806);
            match(GreenPlumParser::BETWEEN);
            setState(5811);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case GreenPlumParser::ABORT_P:
              case GreenPlumParser::ABSOLUTE_P:
              case GreenPlumParser::ACCESS:
              case GreenPlumParser::ACTION:
              case GreenPlumParser::ACTIVE:
              case GreenPlumParser::ADD_P:
              case GreenPlumParser::ADMIN:
              case GreenPlumParser::AFTER:
              case GreenPlumParser::AGGREGATE:
              case GreenPlumParser::ALSO:
              case GreenPlumParser::ALTER:
              case GreenPlumParser::ALWAYS:
              case GreenPlumParser::ARRAY:
              case GreenPlumParser::ASSERTION:
              case GreenPlumParser::ASSIGNMENT:
              case GreenPlumParser::ASYMMETRIC:
              case GreenPlumParser::AT:
              case GreenPlumParser::AUTHORIZATION:
              case GreenPlumParser::BACKWARD:
              case GreenPlumParser::BEFORE:
              case GreenPlumParser::BEGIN_P:
              case GreenPlumParser::BIGINT:
              case GreenPlumParser::BINARY:
              case GreenPlumParser::BIT:
              case GreenPlumParser::BOOLEAN_P:
              case GreenPlumParser::BY:
              case GreenPlumParser::CACHE:
              case GreenPlumParser::CALLED:
              case GreenPlumParser::CASCADE:
              case GreenPlumParser::CASCADED:
              case GreenPlumParser::CASE:
              case GreenPlumParser::CAST:
              case GreenPlumParser::CHAIN:
              case GreenPlumParser::CHARACTER:
              case GreenPlumParser::CHARACTERISTICS:
              case GreenPlumParser::CHAR_P:
              case GreenPlumParser::CHECKPOINT:
              case GreenPlumParser::CLASS:
              case GreenPlumParser::CLOSE:
              case GreenPlumParser::CLUSTER:
              case GreenPlumParser::COALESCE:
              case GreenPlumParser::COMMENT:
              case GreenPlumParser::COMMIT:
              case GreenPlumParser::COMMITTED:
              case GreenPlumParser::CONCURRENCY:
              case GreenPlumParser::CONCURRENTLY:
              case GreenPlumParser::CONFIGURATION:
              case GreenPlumParser::CONNECTION:
              case GreenPlumParser::CONSTRAINTS:
              case GreenPlumParser::CONTAINS:
              case GreenPlumParser::CONTENT_P:
              case GreenPlumParser::CONTINUE_P:
              case GreenPlumParser::CONVERSION_P:
              case GreenPlumParser::COPY:
              case GreenPlumParser::COST:
              case GreenPlumParser::CPU_RATE_LIMIT:
              case GreenPlumParser::CPUSET:
              case GreenPlumParser::CREATEDB:
              case GreenPlumParser::CREATEEXTTABLE:
              case GreenPlumParser::CREATEROLE:
              case GreenPlumParser::CREATEUSER:
              case GreenPlumParser::CROSS:
              case GreenPlumParser::CSV:
              case GreenPlumParser::CURRENT_CATALOG:
              case GreenPlumParser::CURRENT_DATE:
              case GreenPlumParser::CURRENT_P:
              case GreenPlumParser::CURRENT_ROLE:
              case GreenPlumParser::CURRENT_SCHEMA:
              case GreenPlumParser::CURRENT_TIME:
              case GreenPlumParser::CURRENT_TIMESTAMP:
              case GreenPlumParser::CURRENT_USER:
              case GreenPlumParser::CURSOR:
              case GreenPlumParser::CYCLE:
              case GreenPlumParser::DATABASE:
              case GreenPlumParser::DATA_P:
              case GreenPlumParser::DAY_P:
              case GreenPlumParser::DEALLOCATE:
              case GreenPlumParser::DEC:
              case GreenPlumParser::DECIMAL_P:
              case GreenPlumParser::DECLARE:
              case GreenPlumParser::DECODE:
              case GreenPlumParser::DEFAULTS:
              case GreenPlumParser::DEFERRED:
              case GreenPlumParser::DEFINER:
              case GreenPlumParser::DELETE_P:
              case GreenPlumParser::DELIMITER:
              case GreenPlumParser::DELIMITERS:
              case GreenPlumParser::DENY:
              case GreenPlumParser::DICTIONARY:
              case GreenPlumParser::DISABLE_P:
              case GreenPlumParser::DISCARD:
              case GreenPlumParser::DOCUMENT_P:
              case GreenPlumParser::DOMAIN_P:
              case GreenPlumParser::DOUBLE_P:
              case GreenPlumParser::DROP:
              case GreenPlumParser::DXL:
              case GreenPlumParser::EACH:
              case GreenPlumParser::ENABLE_P:
              case GreenPlumParser::ENCODING:
              case GreenPlumParser::ENCRYPTED:
              case GreenPlumParser::ENUM_P:
              case GreenPlumParser::ERRORS:
              case GreenPlumParser::ESCAPE:
              case GreenPlumParser::EVERY:
              case GreenPlumParser::EXCHANGE:
              case GreenPlumParser::EXCLUDING:
              case GreenPlumParser::EXCLUSIVE:
              case GreenPlumParser::EXECUTE:
              case GreenPlumParser::EXISTS:
              case GreenPlumParser::EXPLAIN:
              case GreenPlumParser::EXTENSION:
              case GreenPlumParser::EXTERNAL:
              case GreenPlumParser::EXTRACT:
              case GreenPlumParser::FALSE_P:
              case GreenPlumParser::FAMILY:
              case GreenPlumParser::FIELDS:
              case GreenPlumParser::FILESPACE:
              case GreenPlumParser::FILL:
              case GreenPlumParser::FIRST_P:
              case GreenPlumParser::FLOAT_P:
              case GreenPlumParser::FORCE:
              case GreenPlumParser::FORMAT:
              case GreenPlumParser::FORWARD:
              case GreenPlumParser::FREEZE:
              case GreenPlumParser::FULL:
              case GreenPlumParser::FUNCTION:
              case GreenPlumParser::GLOBAL:
              case GreenPlumParser::GRANTED:
              case GreenPlumParser::GREATEST:
              case GreenPlumParser::GROUP_ID:
              case GreenPlumParser::GROUPING:
              case GreenPlumParser::HANDLER:
              case GreenPlumParser::HASH:
              case GreenPlumParser::HEADER_P:
              case GreenPlumParser::HOLD:
              case GreenPlumParser::HOST:
              case GreenPlumParser::HOUR_P:
              case GreenPlumParser::IDENTITY_P:
              case GreenPlumParser::IF_P:
              case GreenPlumParser::IGNORE_P:
              case GreenPlumParser::ILIKE:
              case GreenPlumParser::IMMEDIATE:
              case GreenPlumParser::IMMUTABLE:
              case GreenPlumParser::IMPLICIT_P:
              case GreenPlumParser::INCLUDING:
              case GreenPlumParser::INCLUSIVE:
              case GreenPlumParser::INCREMENT:
              case GreenPlumParser::INDEX:
              case GreenPlumParser::INDEXES:
              case GreenPlumParser::INHERIT:
              case GreenPlumParser::INHERITS:
              case GreenPlumParser::INLINE_P:
              case GreenPlumParser::INNER_P:
              case GreenPlumParser::INPUT_P:
              case GreenPlumParser::INSENSITIVE:
              case GreenPlumParser::INSERT:
              case GreenPlumParser::INSTEAD:
              case GreenPlumParser::INTEGER:
              case GreenPlumParser::INTERVAL:
              case GreenPlumParser::INT_P:
              case GreenPlumParser::INVOKER:
              case GreenPlumParser::IS:
              case GreenPlumParser::ISNULL:
              case GreenPlumParser::ISOLATION:
              case GreenPlumParser::JOIN:
              case GreenPlumParser::KEY:
              case GreenPlumParser::LANGUAGE:
              case GreenPlumParser::LARGE_P:
              case GreenPlumParser::LAST_P:
              case GreenPlumParser::LEAST:
              case GreenPlumParser::LEFT:
              case GreenPlumParser::LEVEL:
              case GreenPlumParser::LIKE:
              case GreenPlumParser::LIST:
              case GreenPlumParser::LISTEN:
              case GreenPlumParser::LOAD:
              case GreenPlumParser::LOCAL:
              case GreenPlumParser::LOCALTIME:
              case GreenPlumParser::LOCALTIMESTAMP:
              case GreenPlumParser::LOCATION:
              case GreenPlumParser::LOCK_P:
              case GreenPlumParser::LOGIN_P:
              case GreenPlumParser::LOG_P:
              case GreenPlumParser::MAPPING:
              case GreenPlumParser::MASTER:
              case GreenPlumParser::MATCH:
              case GreenPlumParser::MAXVALUE:
              case GreenPlumParser::MEDIAN:
              case GreenPlumParser::MEMORY_LIMIT:
              case GreenPlumParser::MEMORY_SHARED_QUOTA:
              case GreenPlumParser::MEMORY_SPILL_RATIO:
              case GreenPlumParser::MERGE:
              case GreenPlumParser::MINUTE_P:
              case GreenPlumParser::MINVALUE:
              case GreenPlumParser::MISSING:
              case GreenPlumParser::MODE:
              case GreenPlumParser::MODIFIES:
              case GreenPlumParser::MODIFY:
              case GreenPlumParser::MONTH_P:
              case GreenPlumParser::MOVE:
              case GreenPlumParser::NAME_P:
              case GreenPlumParser::NAMES:
              case GreenPlumParser::NATIONAL:
              case GreenPlumParser::NATURAL:
              case GreenPlumParser::NCHAR:
              case GreenPlumParser::NEW:
              case GreenPlumParser::NEXT:
              case GreenPlumParser::NO:
              case GreenPlumParser::NOCREATEDB:
              case GreenPlumParser::NOCREATEEXTTABLE:
              case GreenPlumParser::NOCREATEROLE:
              case GreenPlumParser::NOCREATEUSER:
              case GreenPlumParser::NOINHERIT:
              case GreenPlumParser::NOLOGIN_P:
              case GreenPlumParser::NOOVERCOMMIT:
              case GreenPlumParser::NOSUPERUSER:
              case GreenPlumParser::NOTHING:
              case GreenPlumParser::NOTIFY:
              case GreenPlumParser::NOTNULL:
              case GreenPlumParser::NOWAIT:
              case GreenPlumParser::NULLIF:
              case GreenPlumParser::NULL_P:
              case GreenPlumParser::NULLS_P:
              case GreenPlumParser::NUMERIC:
              case GreenPlumParser::OBJECT_P:
              case GreenPlumParser::OF:
              case GreenPlumParser::OIDS:
              case GreenPlumParser::OLD:
              case GreenPlumParser::OPERATOR:
              case GreenPlumParser::OPTION:
              case GreenPlumParser::OPTIONS:
              case GreenPlumParser::ORDERED:
              case GreenPlumParser::OTHERS:
              case GreenPlumParser::OUTER_P:
              case GreenPlumParser::OVER:
              case GreenPlumParser::OVERCOMMIT:
              case GreenPlumParser::OVERLAPS:
              case GreenPlumParser::OVERLAY:
              case GreenPlumParser::OWNED:
              case GreenPlumParser::OWNER:
              case GreenPlumParser::PARSER:
              case GreenPlumParser::PARTIAL:
              case GreenPlumParser::PARTITIONS:
              case GreenPlumParser::PASSING:
              case GreenPlumParser::PASSWORD:
              case GreenPlumParser::PERCENT:
              case GreenPlumParser::PERCENTILE_CONT:
              case GreenPlumParser::PERCENTILE_DISC:
              case GreenPlumParser::PLANS:
              case GreenPlumParser::POSITION:
              case GreenPlumParser::PREPARE:
              case GreenPlumParser::PREPARED:
              case GreenPlumParser::PRESERVE:
              case GreenPlumParser::PRIOR:
              case GreenPlumParser::PRIVILEGES:
              case GreenPlumParser::PROCEDURAL:
              case GreenPlumParser::PROCEDURE:
              case GreenPlumParser::PROGRAM:
              case GreenPlumParser::PROTOCOL:
              case GreenPlumParser::PUBLIC:
              case GreenPlumParser::QUEUE:
              case GreenPlumParser::QUOTE:
              case GreenPlumParser::RANDOMLY:
              case GreenPlumParser::READ:
              case GreenPlumParser::READABLE:
              case GreenPlumParser::READS:
              case GreenPlumParser::REAL:
              case GreenPlumParser::REASSIGN:
              case GreenPlumParser::RECHECK:
              case GreenPlumParser::RECURSIVE:
              case GreenPlumParser::REF:
              case GreenPlumParser::REINDEX:
              case GreenPlumParser::REJECT_P:
              case GreenPlumParser::RELATIVE_P:
              case GreenPlumParser::RELEASE:
              case GreenPlumParser::RENAME:
              case GreenPlumParser::REPEATABLE:
              case GreenPlumParser::REPLACE:
              case GreenPlumParser::REPLICA:
              case GreenPlumParser::RESET:
              case GreenPlumParser::RESOURCE:
              case GreenPlumParser::RESTART:
              case GreenPlumParser::RESTRICT:
              case GreenPlumParser::RETURNS:
              case GreenPlumParser::REVOKE:
              case GreenPlumParser::RIGHT:
              case GreenPlumParser::ROLE:
              case GreenPlumParser::ROLLBACK:
              case GreenPlumParser::ROOTPARTITION:
              case GreenPlumParser::RULE:
              case GreenPlumParser::SAVEPOINT:
              case GreenPlumParser::SCHEMA:
              case GreenPlumParser::SCROLL:
              case GreenPlumParser::SEARCH:
              case GreenPlumParser::SECOND_P:
              case GreenPlumParser::SECURITY:
              case GreenPlumParser::SEGMENT:
              case GreenPlumParser::SEQUENCE:
              case GreenPlumParser::SERIALIZABLE:
              case GreenPlumParser::SESSION:
              case GreenPlumParser::SESSION_USER:
              case GreenPlumParser::SET:
              case GreenPlumParser::SHARE:
              case GreenPlumParser::SHOW:
              case GreenPlumParser::SIMILAR:
              case GreenPlumParser::SIMPLE:
              case GreenPlumParser::SMALLINT:
              case GreenPlumParser::SPLIT:
              case GreenPlumParser::SQL:
              case GreenPlumParser::STABLE:
              case GreenPlumParser::STANDALONE_P:
              case GreenPlumParser::START:
              case GreenPlumParser::STATEMENT:
              case GreenPlumParser::STATISTICS:
              case GreenPlumParser::STDIN:
              case GreenPlumParser::STDOUT:
              case GreenPlumParser::STORAGE:
              case GreenPlumParser::STRICT_P:
              case GreenPlumParser::STRIP_P:
              case GreenPlumParser::SUBPARTITION:
              case GreenPlumParser::SUBPARTITIONS:
              case GreenPlumParser::SUBSTRING:
              case GreenPlumParser::SUPERUSER_P:
              case GreenPlumParser::SYSID:
              case GreenPlumParser::SYSTEM_P:
              case GreenPlumParser::TABLE:
              case GreenPlumParser::TABLESPACE:
              case GreenPlumParser::TEMP:
              case GreenPlumParser::TEMPLATE:
              case GreenPlumParser::TEMPORARY:
              case GreenPlumParser::TEXT_P:
              case GreenPlumParser::THRESHOLD:
              case GreenPlumParser::TIES:
              case GreenPlumParser::TIME:
              case GreenPlumParser::TIMESTAMP:
              case GreenPlumParser::TRANSACTION:
              case GreenPlumParser::TREAT:
              case GreenPlumParser::TRIGGER:
              case GreenPlumParser::TRIM:
              case GreenPlumParser::TRUE_P:
              case GreenPlumParser::TRUNCATE:
              case GreenPlumParser::TRUSTED:
              case GreenPlumParser::TYPE_P:
              case GreenPlumParser::UNCOMMITTED:
              case GreenPlumParser::UNENCRYPTED:
              case GreenPlumParser::UNIQUE:
              case GreenPlumParser::UNKNOWN:
              case GreenPlumParser::UNLISTEN:
              case GreenPlumParser::UNTIL:
              case GreenPlumParser::UPDATE:
              case GreenPlumParser::USER:
              case GreenPlumParser::VACUUM:
              case GreenPlumParser::VALID:
              case GreenPlumParser::VALIDATION:
              case GreenPlumParser::VALIDATOR:
              case GreenPlumParser::VALUE_P:
              case GreenPlumParser::VARCHAR:
              case GreenPlumParser::VARYING:
              case GreenPlumParser::VERBOSE:
              case GreenPlumParser::VERSION_P:
              case GreenPlumParser::VIEW:
              case GreenPlumParser::VOLATILE:
              case GreenPlumParser::WEB:
              case GreenPlumParser::WHITESPACE_P:
              case GreenPlumParser::WITHIN:
              case GreenPlumParser::WITHOUT:
              case GreenPlumParser::WORK:
              case GreenPlumParser::WRITABLE:
              case GreenPlumParser::WRITE:
              case GreenPlumParser::XMLCONCAT:
              case GreenPlumParser::XMLELEMENT:
              case GreenPlumParser::XMLEXISTS:
              case GreenPlumParser::XMLFOREST:
              case GreenPlumParser::XML_P:
              case GreenPlumParser::XMLPARSE:
              case GreenPlumParser::XMLPI:
              case GreenPlumParser::XMLROOT:
              case GreenPlumParser::XMLSERIALIZE:
              case GreenPlumParser::YEAR_P:
              case GreenPlumParser::YES_P:
              case GreenPlumParser::ZONE:
              case GreenPlumParser::LEFT_PAREN:
              case GreenPlumParser::PLUS_SIGN:
              case GreenPlumParser::MINUS_SIGN:
              case GreenPlumParser::COLON:
              case GreenPlumParser::CHAR_STRING:
              case GreenPlumParser::REGULAR_ID:
              case GreenPlumParser::DELIMITED_STR:
              case GreenPlumParser::SCONST:
              case GreenPlumParser::ICONST:
              case GreenPlumParser::FCONST:
              case GreenPlumParser::BCONST:
              case GreenPlumParser::XCONST:
              case GreenPlumParser::PARAM: {
                setState(5808);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == GreenPlumParser::ASYMMETRIC) {
                  setState(5807);
                  match(GreenPlumParser::ASYMMETRIC);
                }
                break;
              }

              case GreenPlumParser::SYMMETRIC: {
                setState(5810);
                match(GreenPlumParser::SYMMETRIC);
                break;
              }

            default:
              throw NoViableAltException(this);
            }
            setState(5813);
            between_elements();
            break;
          }

          case GreenPlumParser::ILIKE:
          case GreenPlumParser::LIKE:
          case GreenPlumParser::SIMILAR: {
            setState(5818);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case GreenPlumParser::LIKE: {
                setState(5814);
                match(GreenPlumParser::LIKE);
                break;
              }

              case GreenPlumParser::ILIKE: {
                setState(5815);
                match(GreenPlumParser::ILIKE);
                break;
              }

              case GreenPlumParser::SIMILAR: {
                setState(5816);
                match(GreenPlumParser::SIMILAR);
                setState(5817);
                match(GreenPlumParser::TO);
                break;
              }

            default:
              throw NoViableAltException(this);
            }
            setState(5820);
            concatenation(0);
            setState(5823);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 642, _ctx)) {
            case 1: {
              setState(5821);
              match(GreenPlumParser::ESCAPE);
              setState(5822);
              a_expr();
              break;
            }

            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5829);
      concatenation_list();
      setState(5830);
      match(GreenPlumParser::OVERLAPS);
      setState(5831);
      concatenation_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Between_elementsContext ------------------------------------------------------------------

GreenPlumParser::Between_elementsContext::Between_elementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::ConcatenationContext *> GreenPlumParser::Between_elementsContext::concatenation() {
  return getRuleContexts<GreenPlumParser::ConcatenationContext>();
}

GreenPlumParser::ConcatenationContext* GreenPlumParser::Between_elementsContext::concatenation(size_t i) {
  return getRuleContext<GreenPlumParser::ConcatenationContext>(i);
}

tree::TerminalNode* GreenPlumParser::Between_elementsContext::AND() {
  return getToken(GreenPlumParser::AND, 0);
}


size_t GreenPlumParser::Between_elementsContext::getRuleIndex() const {
  return GreenPlumParser::RuleBetween_elements;
}

void GreenPlumParser::Between_elementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBetween_elements(this);
}

void GreenPlumParser::Between_elementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBetween_elements(this);
}


antlrcpp::Any GreenPlumParser::Between_elementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitBetween_elements(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Between_elementsContext* GreenPlumParser::between_elements() {
  Between_elementsContext *_localctx = _tracker.createInstance<Between_elementsContext>(_ctx, getState());
  enterRule(_localctx, 876, GreenPlumParser::RuleBetween_elements);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5835);
    concatenation(0);
    setState(5836);
    match(GreenPlumParser::AND);
    setState(5837);
    concatenation(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Concatenation_listContext ------------------------------------------------------------------

GreenPlumParser::Concatenation_listContext::Concatenation_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Concatenation_listContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

std::vector<GreenPlumParser::ConcatenationContext *> GreenPlumParser::Concatenation_listContext::concatenation() {
  return getRuleContexts<GreenPlumParser::ConcatenationContext>();
}

GreenPlumParser::ConcatenationContext* GreenPlumParser::Concatenation_listContext::concatenation(size_t i) {
  return getRuleContext<GreenPlumParser::ConcatenationContext>(i);
}

tree::TerminalNode* GreenPlumParser::Concatenation_listContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Concatenation_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Concatenation_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Concatenation_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleConcatenation_list;
}

void GreenPlumParser::Concatenation_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConcatenation_list(this);
}

void GreenPlumParser::Concatenation_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConcatenation_list(this);
}


antlrcpp::Any GreenPlumParser::Concatenation_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConcatenation_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Concatenation_listContext* GreenPlumParser::concatenation_list() {
  Concatenation_listContext *_localctx = _tracker.createInstance<Concatenation_listContext>(_ctx, getState());
  enterRule(_localctx, 878, GreenPlumParser::RuleConcatenation_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5839);
    match(GreenPlumParser::LEFT_PAREN);
    setState(5840);
    concatenation(0);
    setState(5845);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(5841);
      match(GreenPlumParser::COMMA);
      setState(5842);
      concatenation(0);
      setState(5847);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5848);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConcatenationContext ------------------------------------------------------------------

GreenPlumParser::ConcatenationContext::ConcatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Model_exprContext* GreenPlumParser::ConcatenationContext::model_expr() {
  return getRuleContext<GreenPlumParser::Model_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::AT() {
  return getToken(GreenPlumParser::AT, 0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::ZONE() {
  return getToken(GreenPlumParser::ZONE, 0);
}

std::vector<GreenPlumParser::ConcatenationContext *> GreenPlumParser::ConcatenationContext::concatenation() {
  return getRuleContexts<GreenPlumParser::ConcatenationContext>();
}

GreenPlumParser::ConcatenationContext* GreenPlumParser::ConcatenationContext::concatenation(size_t i) {
  return getRuleContext<GreenPlumParser::ConcatenationContext>(i);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::CARRET_OPERATOR_PART() {
  return getToken(GreenPlumParser::CARRET_OPERATOR_PART, 0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::ASTERISK() {
  return getToken(GreenPlumParser::ASTERISK, 0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::SOLIDUS() {
  return getToken(GreenPlumParser::SOLIDUS, 0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::PERCENT_SIGN() {
  return getToken(GreenPlumParser::PERCENT_SIGN, 0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::PLUS_SIGN() {
  return getToken(GreenPlumParser::PLUS_SIGN, 0);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::MINUS_SIGN() {
  return getToken(GreenPlumParser::MINUS_SIGN, 0);
}

std::vector<tree::TerminalNode *> GreenPlumParser::ConcatenationContext::BAR() {
  return getTokens(GreenPlumParser::BAR);
}

tree::TerminalNode* GreenPlumParser::ConcatenationContext::BAR(size_t i) {
  return getToken(GreenPlumParser::BAR, i);
}


size_t GreenPlumParser::ConcatenationContext::getRuleIndex() const {
  return GreenPlumParser::RuleConcatenation;
}

void GreenPlumParser::ConcatenationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConcatenation(this);
}

void GreenPlumParser::ConcatenationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConcatenation(this);
}


antlrcpp::Any GreenPlumParser::ConcatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitConcatenation(this);
  else
    return visitor->visitChildren(this);
}


GreenPlumParser::ConcatenationContext* GreenPlumParser::concatenation() {
   return concatenation(0);
}

GreenPlumParser::ConcatenationContext* GreenPlumParser::concatenation(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::ConcatenationContext *_localctx = _tracker.createInstance<ConcatenationContext>(_ctx, parentState);
  GreenPlumParser::ConcatenationContext *previousContext = _localctx;
  size_t startState = 880;
  enterRecursionRule(_localctx, 880, GreenPlumParser::RuleConcatenation, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5851);
    model_expr();
    setState(5856);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 647, _ctx)) {
    case 1: {
      setState(5852);
      match(GreenPlumParser::AT);
      setState(5853);
      match(GreenPlumParser::TIME);
      setState(5854);
      match(GreenPlumParser::ZONE);
      setState(5855);
      concatenation(0);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5873);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 649, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5871);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 648, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ConcatenationContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConcatenation);
          setState(5858);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(5859);
          match(GreenPlumParser::CARRET_OPERATOR_PART);
          setState(5860);
          concatenation(5);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ConcatenationContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConcatenation);
          setState(5861);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5862);
          dynamic_cast<ConcatenationContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 469) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 469)) & ((1ULL << (GreenPlumParser::PERCENT_SIGN - 469))
            | (1ULL << (GreenPlumParser::ASTERISK - 469))
            | (1ULL << (GreenPlumParser::SOLIDUS - 469)))) != 0))) {
            dynamic_cast<ConcatenationContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5863);
          concatenation(4);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ConcatenationContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConcatenation);
          setState(5864);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5865);
          dynamic_cast<ConcatenationContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == GreenPlumParser::PLUS_SIGN

          || _la == GreenPlumParser::MINUS_SIGN)) {
            dynamic_cast<ConcatenationContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5866);
          concatenation(3);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ConcatenationContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConcatenation);
          setState(5867);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5868);
          match(GreenPlumParser::BAR);
          setState(5869);
          match(GreenPlumParser::BAR);
          setState(5870);
          concatenation(2);
          break;
        }

        } 
      }
      setState(5875);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 649, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Model_exprContext ------------------------------------------------------------------

GreenPlumParser::Model_exprContext::Model_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Unary_exprContext* GreenPlumParser::Model_exprContext::unary_expr() {
  return getRuleContext<GreenPlumParser::Unary_exprContext>(0);
}


size_t GreenPlumParser::Model_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleModel_expr;
}

void GreenPlumParser::Model_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_expr(this);
}

void GreenPlumParser::Model_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_expr(this);
}


antlrcpp::Any GreenPlumParser::Model_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitModel_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Model_exprContext* GreenPlumParser::model_expr() {
  Model_exprContext *_localctx = _tracker.createInstance<Model_exprContext>(_ctx, getState());
  enterRule(_localctx, 882, GreenPlumParser::RuleModel_expr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5876);
    unary_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_exprContext ------------------------------------------------------------------

GreenPlumParser::Unary_exprContext::Unary_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::C_exprContext* GreenPlumParser::Unary_exprContext::c_expr() {
  return getRuleContext<GreenPlumParser::C_exprContext>(0);
}

GreenPlumParser::Unary_exprContext* GreenPlumParser::Unary_exprContext::unary_expr() {
  return getRuleContext<GreenPlumParser::Unary_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Unary_exprContext::MINUS_SIGN() {
  return getToken(GreenPlumParser::MINUS_SIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Unary_exprContext::PLUS_SIGN() {
  return getToken(GreenPlumParser::PLUS_SIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Unary_exprContext::TYPECAST() {
  return getToken(GreenPlumParser::TYPECAST, 0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Unary_exprContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}


size_t GreenPlumParser::Unary_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleUnary_expr;
}

void GreenPlumParser::Unary_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_expr(this);
}

void GreenPlumParser::Unary_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_expr(this);
}


antlrcpp::Any GreenPlumParser::Unary_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitUnary_expr(this);
  else
    return visitor->visitChildren(this);
}


GreenPlumParser::Unary_exprContext* GreenPlumParser::unary_expr() {
   return unary_expr(0);
}

GreenPlumParser::Unary_exprContext* GreenPlumParser::unary_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GreenPlumParser::Unary_exprContext *_localctx = _tracker.createInstance<Unary_exprContext>(_ctx, parentState);
  GreenPlumParser::Unary_exprContext *previousContext = _localctx;
  size_t startState = 884;
  enterRecursionRule(_localctx, 884, GreenPlumParser::RuleUnary_expr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5882);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ARRAY:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CASE:
      case GreenPlumParser::CAST:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_CATALOG:
      case GreenPlumParser::CURRENT_DATE:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_ROLE:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURRENT_TIME:
      case GreenPlumParser::CURRENT_TIMESTAMP:
      case GreenPlumParser::CURRENT_USER:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DECODE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCALTIME:
      case GreenPlumParser::LOCALTIMESTAMP:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEDIAN:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PERCENTILE_CONT:
      case GreenPlumParser::PERCENTILE_DISC:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SESSION_USER:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLE:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNIQUE:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::USER:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XMLCONCAT:
      case GreenPlumParser::XMLELEMENT:
      case GreenPlumParser::XMLEXISTS:
      case GreenPlumParser::XMLFOREST:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::XMLPARSE:
      case GreenPlumParser::XMLPI:
      case GreenPlumParser::XMLROOT:
      case GreenPlumParser::XMLSERIALIZE:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::LEFT_PAREN:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST:
      case GreenPlumParser::BCONST:
      case GreenPlumParser::XCONST:
      case GreenPlumParser::PARAM: {
        setState(5879);
        c_expr();
        break;
      }

      case GreenPlumParser::PLUS_SIGN:
      case GreenPlumParser::MINUS_SIGN: {
        setState(5880);
        _la = _input->LA(1);
        if (!(_la == GreenPlumParser::PLUS_SIGN

        || _la == GreenPlumParser::MINUS_SIGN)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5881);
        unary_expr(1);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(5889);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 651, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Unary_exprContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleUnary_expr);
        setState(5884);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(5885);
        match(GreenPlumParser::TYPECAST);
        setState(5886);
        typename_pg(); 
      }
      setState(5891);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 651, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- C_exprContext ------------------------------------------------------------------

GreenPlumParser::C_exprContext::C_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::C_exprContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::C_exprContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::C_exprContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::IndirectionContext* GreenPlumParser::C_exprContext::indirection() {
  return getRuleContext<GreenPlumParser::IndirectionContext>(0);
}

GreenPlumParser::Select_with_parensContext* GreenPlumParser::C_exprContext::select_with_parens() {
  return getRuleContext<GreenPlumParser::Select_with_parensContext>(0);
}

tree::TerminalNode* GreenPlumParser::C_exprContext::UNIQUE() {
  return getToken(GreenPlumParser::UNIQUE, 0);
}

tree::TerminalNode* GreenPlumParser::C_exprContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::C_exprContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

GreenPlumParser::ColumnrefContext* GreenPlumParser::C_exprContext::columnref() {
  return getRuleContext<GreenPlumParser::ColumnrefContext>(0);
}

GreenPlumParser::Func_exprContext* GreenPlumParser::C_exprContext::func_expr() {
  return getRuleContext<GreenPlumParser::Func_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::C_exprContext::OVER() {
  return getToken(GreenPlumParser::OVER, 0);
}

GreenPlumParser::Window_specificationContext* GreenPlumParser::C_exprContext::window_specification() {
  return getRuleContext<GreenPlumParser::Window_specificationContext>(0);
}

GreenPlumParser::A_expr_constContext* GreenPlumParser::C_exprContext::a_expr_const() {
  return getRuleContext<GreenPlumParser::A_expr_constContext>(0);
}

tree::TerminalNode* GreenPlumParser::C_exprContext::PARAM() {
  return getToken(GreenPlumParser::PARAM, 0);
}

GreenPlumParser::Case_exprContext* GreenPlumParser::C_exprContext::case_expr() {
  return getRuleContext<GreenPlumParser::Case_exprContext>(0);
}

GreenPlumParser::Decode_exprContext* GreenPlumParser::C_exprContext::decode_expr() {
  return getRuleContext<GreenPlumParser::Decode_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::C_exprContext::ARRAY() {
  return getToken(GreenPlumParser::ARRAY, 0);
}

GreenPlumParser::Array_exprContext* GreenPlumParser::C_exprContext::array_expr() {
  return getRuleContext<GreenPlumParser::Array_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::C_exprContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

GreenPlumParser::Table_value_select_clauseContext* GreenPlumParser::C_exprContext::table_value_select_clause() {
  return getRuleContext<GreenPlumParser::Table_value_select_clauseContext>(0);
}

GreenPlumParser::RowContext* GreenPlumParser::C_exprContext::row() {
  return getRuleContext<GreenPlumParser::RowContext>(0);
}


size_t GreenPlumParser::C_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleC_expr;
}

void GreenPlumParser::C_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterC_expr(this);
}

void GreenPlumParser::C_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitC_expr(this);
}


antlrcpp::Any GreenPlumParser::C_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitC_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::C_exprContext* GreenPlumParser::c_expr() {
  C_exprContext *_localctx = _tracker.createInstance<C_exprContext>(_ctx, getState());
  enterRule(_localctx, 886, GreenPlumParser::RuleC_expr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5928);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 657, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5892);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5893);
      a_expr();
      setState(5894);
      match(GreenPlumParser::RIGHT_PAREN);
      setState(5896);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 652, _ctx)) {
      case 1: {
        setState(5895);
        indirection();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5899);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::UNIQUE) {
        setState(5898);
        match(GreenPlumParser::UNIQUE);
      }
      setState(5901);
      select_with_parens();
      setState(5903);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 654, _ctx)) {
      case 1: {
        setState(5902);
        indirection();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5905);
      match(GreenPlumParser::EXISTS);
      setState(5906);
      select_stmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5907);
      columnref();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5908);
      func_expr();
      setState(5911);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 655, _ctx)) {
      case 1: {
        setState(5909);
        match(GreenPlumParser::OVER);
        setState(5910);
        window_specification();
        break;
      }

      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5913);
      a_expr_const();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5914);
      match(GreenPlumParser::PARAM);
      setState(5916);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 656, _ctx)) {
      case 1: {
        setState(5915);
        indirection();
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5918);
      case_expr();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5919);
      decode_expr();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5920);
      match(GreenPlumParser::ARRAY);
      setState(5921);
      array_expr();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5922);
      match(GreenPlumParser::TABLE);
      setState(5923);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5924);
      table_value_select_clause();
      setState(5925);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5927);
      row();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scatter_clauseContext ------------------------------------------------------------------

GreenPlumParser::Scatter_clauseContext::Scatter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Scatter_clauseContext::SCATTER() {
  return getToken(GreenPlumParser::SCATTER, 0);
}

tree::TerminalNode* GreenPlumParser::Scatter_clauseContext::RANDOMLY() {
  return getToken(GreenPlumParser::RANDOMLY, 0);
}

tree::TerminalNode* GreenPlumParser::Scatter_clauseContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::Scatter_clauseContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}


size_t GreenPlumParser::Scatter_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleScatter_clause;
}

void GreenPlumParser::Scatter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScatter_clause(this);
}

void GreenPlumParser::Scatter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScatter_clause(this);
}


antlrcpp::Any GreenPlumParser::Scatter_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitScatter_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Scatter_clauseContext* GreenPlumParser::scatter_clause() {
  Scatter_clauseContext *_localctx = _tracker.createInstance<Scatter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 888, GreenPlumParser::RuleScatter_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5930);
    match(GreenPlumParser::SCATTER);
    setState(5934);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::RANDOMLY: {
        setState(5931);
        match(GreenPlumParser::RANDOMLY);
        break;
      }

      case GreenPlumParser::BY: {
        setState(5932);
        match(GreenPlumParser::BY);
        setState(5933);
        expr_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_value_select_clauseContext ------------------------------------------------------------------

GreenPlumParser::Table_value_select_clauseContext::Table_value_select_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Select_stmtContext* GreenPlumParser::Table_value_select_clauseContext::select_stmt() {
  return getRuleContext<GreenPlumParser::Select_stmtContext>(0);
}

GreenPlumParser::Scatter_clauseContext* GreenPlumParser::Table_value_select_clauseContext::scatter_clause() {
  return getRuleContext<GreenPlumParser::Scatter_clauseContext>(0);
}


size_t GreenPlumParser::Table_value_select_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleTable_value_select_clause;
}

void GreenPlumParser::Table_value_select_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_value_select_clause(this);
}

void GreenPlumParser::Table_value_select_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_value_select_clause(this);
}


antlrcpp::Any GreenPlumParser::Table_value_select_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTable_value_select_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Table_value_select_clauseContext* GreenPlumParser::table_value_select_clause() {
  Table_value_select_clauseContext *_localctx = _tracker.createInstance<Table_value_select_clauseContext>(_ctx, getState());
  enterRule(_localctx, 890, GreenPlumParser::RuleTable_value_select_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5936);
    select_stmt();
    setState(5938);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::SCATTER) {
      setState(5937);
      scatter_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_funcContext ------------------------------------------------------------------

GreenPlumParser::Simple_funcContext::Simple_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Func_nameContext* GreenPlumParser::Simple_funcContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Simple_func_paramsContext* GreenPlumParser::Simple_funcContext::simple_func_params() {
  return getRuleContext<GreenPlumParser::Simple_func_paramsContext>(0);
}


size_t GreenPlumParser::Simple_funcContext::getRuleIndex() const {
  return GreenPlumParser::RuleSimple_func;
}

void GreenPlumParser::Simple_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_func(this);
}

void GreenPlumParser::Simple_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_func(this);
}


antlrcpp::Any GreenPlumParser::Simple_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSimple_func(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Simple_funcContext* GreenPlumParser::simple_func() {
  Simple_funcContext *_localctx = _tracker.createInstance<Simple_funcContext>(_ctx, getState());
  enterRule(_localctx, 892, GreenPlumParser::RuleSimple_func);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5940);
    func_name();
    setState(5941);
    simple_func_params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_func_paramsContext ------------------------------------------------------------------

GreenPlumParser::Simple_func_paramsContext::Simple_func_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Simple_func_paramsContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Simple_func_paramsContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Simple_func_paramsContext::ASTERISK() {
  return getToken(GreenPlumParser::ASTERISK, 0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Simple_func_paramsContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Simple_func_paramsContext::VARIADIC() {
  return getToken(GreenPlumParser::VARIADIC, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Simple_func_paramsContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::Simple_func_paramsContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Simple_func_paramsContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}

GreenPlumParser::Opt_distinctContext* GreenPlumParser::Simple_func_paramsContext::opt_distinct() {
  return getRuleContext<GreenPlumParser::Opt_distinctContext>(0);
}

GreenPlumParser::Sort_clauseContext* GreenPlumParser::Simple_func_paramsContext::sort_clause() {
  return getRuleContext<GreenPlumParser::Sort_clauseContext>(0);
}


size_t GreenPlumParser::Simple_func_paramsContext::getRuleIndex() const {
  return GreenPlumParser::RuleSimple_func_params;
}

void GreenPlumParser::Simple_func_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_func_params(this);
}

void GreenPlumParser::Simple_func_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_func_params(this);
}


antlrcpp::Any GreenPlumParser::Simple_func_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSimple_func_params(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Simple_func_paramsContext* GreenPlumParser::simple_func_params() {
  Simple_func_paramsContext *_localctx = _tracker.createInstance<Simple_func_paramsContext>(_ctx, getState());
  enterRule(_localctx, 894, GreenPlumParser::RuleSimple_func_params);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5971);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 663, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5943);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5945);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ASTERISK) {
        setState(5944);
        match(GreenPlumParser::ASTERISK);
      }
      setState(5947);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5948);
      paren_expr_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5949);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5950);
      match(GreenPlumParser::VARIADIC);
      setState(5951);
      a_expr();
      setState(5952);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5954);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5955);
      expr_list();
      setState(5956);
      match(GreenPlumParser::COMMA);
      setState(5957);
      match(GreenPlumParser::VARIADIC);
      setState(5958);
      a_expr();
      setState(5959);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5961);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5963);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ALL || _la == GreenPlumParser::DISTINCT) {
        setState(5962);
        opt_distinct();
      }
      setState(5965);
      expr_list();
      setState(5967);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::ORDER) {
        setState(5966);
        sort_clause();
      }
      setState(5969);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_exprContext ------------------------------------------------------------------

GreenPlumParser::Func_exprContext::Func_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Simple_funcContext* GreenPlumParser::Func_exprContext::simple_func() {
  return getRuleContext<GreenPlumParser::Simple_funcContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::FILTER() {
  return getToken(GreenPlumParser::FILTER, 0);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Func_exprContext::LEFT_PAREN() {
  return getTokens(GreenPlumParser::LEFT_PAREN);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::LEFT_PAREN(size_t i) {
  return getToken(GreenPlumParser::LEFT_PAREN, i);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::WHERE() {
  return getToken(GreenPlumParser::WHERE, 0);
}

std::vector<GreenPlumParser::A_exprContext *> GreenPlumParser::Func_exprContext::a_expr() {
  return getRuleContexts<GreenPlumParser::A_exprContext>();
}

GreenPlumParser::A_exprContext* GreenPlumParser::Func_exprContext::a_expr(size_t i) {
  return getRuleContext<GreenPlumParser::A_exprContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Func_exprContext::RIGHT_PAREN() {
  return getTokens(GreenPlumParser::RIGHT_PAREN);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::RIGHT_PAREN(size_t i) {
  return getToken(GreenPlumParser::RIGHT_PAREN, i);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CURRENT_DATE() {
  return getToken(GreenPlumParser::CURRENT_DATE, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CURRENT_TIME() {
  return getToken(GreenPlumParser::CURRENT_TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CURRENT_TIMESTAMP() {
  return getToken(GreenPlumParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::LOCALTIME() {
  return getToken(GreenPlumParser::LOCALTIME, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::LOCALTIMESTAMP() {
  return getToken(GreenPlumParser::LOCALTIMESTAMP, 0);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::Func_exprContext::paren_iconst() {
  return getRuleContext<GreenPlumParser::Paren_iconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CURRENT_ROLE() {
  return getToken(GreenPlumParser::CURRENT_ROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CURRENT_USER() {
  return getToken(GreenPlumParser::CURRENT_USER, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::SESSION_USER() {
  return getToken(GreenPlumParser::SESSION_USER, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CURRENT_CATALOG() {
  return getToken(GreenPlumParser::CURRENT_CATALOG, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CURRENT_SCHEMA() {
  return getToken(GreenPlumParser::CURRENT_SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::CAST() {
  return getToken(GreenPlumParser::CAST, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Func_exprContext::typename_pg() {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::EXTRACT() {
  return getToken(GreenPlumParser::EXTRACT, 0);
}

GreenPlumParser::Extract_listContext* GreenPlumParser::Func_exprContext::extract_list() {
  return getRuleContext<GreenPlumParser::Extract_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::OVERLAY() {
  return getToken(GreenPlumParser::OVERLAY, 0);
}

GreenPlumParser::Overlay_listContext* GreenPlumParser::Func_exprContext::overlay_list() {
  return getRuleContext<GreenPlumParser::Overlay_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::POSITION() {
  return getToken(GreenPlumParser::POSITION, 0);
}

GreenPlumParser::Position_listContext* GreenPlumParser::Func_exprContext::position_list() {
  return getRuleContext<GreenPlumParser::Position_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::SUBSTRING() {
  return getToken(GreenPlumParser::SUBSTRING, 0);
}

GreenPlumParser::Substr_listContext* GreenPlumParser::Func_exprContext::substr_list() {
  return getRuleContext<GreenPlumParser::Substr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::TREAT() {
  return getToken(GreenPlumParser::TREAT, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::TRIM() {
  return getToken(GreenPlumParser::TRIM, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::BOTH() {
  return getToken(GreenPlumParser::BOTH, 0);
}

GreenPlumParser::Trim_listContext* GreenPlumParser::Func_exprContext::trim_list() {
  return getRuleContext<GreenPlumParser::Trim_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::LEADING() {
  return getToken(GreenPlumParser::LEADING, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::TRAILING() {
  return getToken(GreenPlumParser::TRAILING, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::NULLIF() {
  return getToken(GreenPlumParser::NULLIF, 0);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Func_exprContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::COALESCE() {
  return getToken(GreenPlumParser::COALESCE, 0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::Func_exprContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::GREATEST() {
  return getToken(GreenPlumParser::GREATEST, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::LEAST() {
  return getToken(GreenPlumParser::LEAST, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::GROUPING() {
  return getToken(GreenPlumParser::GROUPING, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::GROUP_ID() {
  return getToken(GreenPlumParser::GROUP_ID, 0);
}

GreenPlumParser::Double_parensContext* GreenPlumParser::Func_exprContext::double_parens() {
  return getRuleContext<GreenPlumParser::Double_parensContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::MEDIAN() {
  return getToken(GreenPlumParser::MEDIAN, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::PERCENTILE_CONT() {
  return getToken(GreenPlumParser::PERCENTILE_CONT, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::WITHIN() {
  return getToken(GreenPlumParser::WITHIN, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::ORDER() {
  return getToken(GreenPlumParser::ORDER, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Sortby_listContext* GreenPlumParser::Func_exprContext::sortby_list() {
  return getRuleContext<GreenPlumParser::Sortby_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::PERCENTILE_DISC() {
  return getToken(GreenPlumParser::PERCENTILE_DISC, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::DECODE() {
  return getToken(GreenPlumParser::DECODE, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLCONCAT() {
  return getToken(GreenPlumParser::XMLCONCAT, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLELEMENT() {
  return getToken(GreenPlumParser::XMLELEMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::NAME_P() {
  return getToken(GreenPlumParser::NAME_P, 0);
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Func_exprContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}

GreenPlumParser::Xml_attributesContext* GreenPlumParser::Func_exprContext::xml_attributes() {
  return getRuleContext<GreenPlumParser::Xml_attributesContext>(0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::Func_exprContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLEXISTS() {
  return getToken(GreenPlumParser::XMLEXISTS, 0);
}

GreenPlumParser::C_exprContext* GreenPlumParser::Func_exprContext::c_expr() {
  return getRuleContext<GreenPlumParser::C_exprContext>(0);
}

GreenPlumParser::Xmlexists_argumentContext* GreenPlumParser::Func_exprContext::xmlexists_argument() {
  return getRuleContext<GreenPlumParser::Xmlexists_argumentContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLFOREST() {
  return getToken(GreenPlumParser::XMLFOREST, 0);
}

GreenPlumParser::Xml_attribute_listContext* GreenPlumParser::Func_exprContext::xml_attribute_list() {
  return getRuleContext<GreenPlumParser::Xml_attribute_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLPARSE() {
  return getToken(GreenPlumParser::XMLPARSE, 0);
}

GreenPlumParser::Document_or_contentContext* GreenPlumParser::Func_exprContext::document_or_content() {
  return getRuleContext<GreenPlumParser::Document_or_contentContext>(0);
}

GreenPlumParser::Xml_whitespace_optionContext* GreenPlumParser::Func_exprContext::xml_whitespace_option() {
  return getRuleContext<GreenPlumParser::Xml_whitespace_optionContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLPI() {
  return getToken(GreenPlumParser::XMLPI, 0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLROOT() {
  return getToken(GreenPlumParser::XMLROOT, 0);
}

GreenPlumParser::Xml_root_versionContext* GreenPlumParser::Func_exprContext::xml_root_version() {
  return getRuleContext<GreenPlumParser::Xml_root_versionContext>(0);
}

GreenPlumParser::Opt_xml_root_standaloneContext* GreenPlumParser::Func_exprContext::opt_xml_root_standalone() {
  return getRuleContext<GreenPlumParser::Opt_xml_root_standaloneContext>(0);
}

tree::TerminalNode* GreenPlumParser::Func_exprContext::XMLSERIALIZE() {
  return getToken(GreenPlumParser::XMLSERIALIZE, 0);
}

GreenPlumParser::Simple_typenameContext* GreenPlumParser::Func_exprContext::simple_typename() {
  return getRuleContext<GreenPlumParser::Simple_typenameContext>(0);
}


size_t GreenPlumParser::Func_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_expr;
}

void GreenPlumParser::Func_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_expr(this);
}

void GreenPlumParser::Func_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_expr(this);
}


antlrcpp::Any GreenPlumParser::Func_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_exprContext* GreenPlumParser::func_expr() {
  Func_exprContext *_localctx = _tracker.createInstance<Func_exprContext>(_ctx, getState());
  enterRule(_localctx, 896, GreenPlumParser::RuleFunc_expr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6198);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 670, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5973);
      simple_func();
      setState(5974);
      match(GreenPlumParser::FILTER);
      setState(5975);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5976);
      match(GreenPlumParser::WHERE);
      setState(5977);
      a_expr();
      setState(5978);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5980);
      simple_func();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5981);
      match(GreenPlumParser::CURRENT_DATE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5982);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::CURRENT_TIME

      || _la == GreenPlumParser::CURRENT_TIMESTAMP || _la == GreenPlumParser::LOCALTIME

      || _la == GreenPlumParser::LOCALTIMESTAMP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5984);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 664, _ctx)) {
      case 1: {
        setState(5983);
        paren_iconst();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5986);
      match(GreenPlumParser::CURRENT_ROLE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5987);
      match(GreenPlumParser::CURRENT_USER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5988);
      match(GreenPlumParser::SESSION_USER);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5989);
      match(GreenPlumParser::USER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5990);
      match(GreenPlumParser::CURRENT_CATALOG);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5991);
      match(GreenPlumParser::CURRENT_SCHEMA);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5992);
      match(GreenPlumParser::CAST);
      setState(5993);
      match(GreenPlumParser::LEFT_PAREN);
      setState(5994);
      a_expr();
      setState(5995);
      match(GreenPlumParser::AS);
      setState(5996);
      typename_pg();
      setState(5997);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5999);
      match(GreenPlumParser::EXTRACT);
      setState(6000);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6002);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::DAY_P || _la == GreenPlumParser::HOUR_P

      || _la == GreenPlumParser::MINUTE_P || _la == GreenPlumParser::MONTH_P || _la == GreenPlumParser::SECOND_P || ((((_la - 466) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 466)) & ((1ULL << (GreenPlumParser::YEAR_P - 466))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 466))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 466))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 466)))) != 0)) {
        setState(6001);
        extract_list();
      }
      setState(6004);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6005);
      match(GreenPlumParser::OVERLAY);
      setState(6006);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6007);
      overlay_list();
      setState(6008);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(6010);
      match(GreenPlumParser::POSITION);
      setState(6011);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6013);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ARRAY)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::AUTHORIZATION)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BIGINT)
        | (1ULL << GreenPlumParser::BINARY)
        | (1ULL << GreenPlumParser::BIT)
        | (1ULL << GreenPlumParser::BOOLEAN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CASE)
        | (1ULL << GreenPlumParser::CAST)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTER)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHAR_P)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COALESCE)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CROSS - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_CATALOG - 64))
        | (1ULL << (GreenPlumParser::CURRENT_DATE - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURRENT_ROLE - 64))
        | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
        | (1ULL << (GreenPlumParser::CURRENT_TIME - 64))
        | (1ULL << (GreenPlumParser::CURRENT_TIMESTAMP - 64))
        | (1ULL << (GreenPlumParser::CURRENT_USER - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DEC - 64))
        | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DECODE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXISTS - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::EXTRACT - 128))
        | (1ULL << (GreenPlumParser::FALSE_P - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FLOAT_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FREEZE - 128))
        | (1ULL << (GreenPlumParser::FULL - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::GREATEST - 128))
        | (1ULL << (GreenPlumParser::GROUP_ID - 128))
        | (1ULL << (GreenPlumParser::GROUPING - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::ILIKE - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128))
        | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INTEGER - 193))
        | (1ULL << (GreenPlumParser::INTERVAL - 193))
        | (1ULL << (GreenPlumParser::INT_P - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::IS - 193))
        | (1ULL << (GreenPlumParser::ISNULL - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::JOIN - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEAST - 193))
        | (1ULL << (GreenPlumParser::LEFT - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIKE - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCALTIME - 193))
        | (1ULL << (GreenPlumParser::LOCALTIMESTAMP - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::LOG_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEDIAN - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NATIONAL - 193))
        | (1ULL << (GreenPlumParser::NATURAL - 193))
        | (1ULL << (GreenPlumParser::NCHAR - 193))
        | (1ULL << (GreenPlumParser::NEW - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOT - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOTNULL - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLIF - 257))
        | (1ULL << (GreenPlumParser::NULL_P - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::NUMERIC - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OLD - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OUTER_P - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OVERLAPS - 257))
        | (1ULL << (GreenPlumParser::OVERLAY - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PERCENTILE_CONT - 257))
        | (1ULL << (GreenPlumParser::PERCENTILE_DISC - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::POSITION - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REAL - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::RIGHT - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SESSION_USER - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMILAR - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SMALLINT - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUBSTRING - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLE - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TIME - 385))
        | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TREAT - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRIM - 385))
        | (1ULL << (GreenPlumParser::TRUE_P - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNIQUE - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::USER - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARCHAR - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERBOSE - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XMLCONCAT - 451))
        | (1ULL << (GreenPlumParser::XMLELEMENT - 451))
        | (1ULL << (GreenPlumParser::XMLEXISTS - 451))
        | (1ULL << (GreenPlumParser::XMLFOREST - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::XMLPARSE - 451))
        | (1ULL << (GreenPlumParser::XMLPI - 451))
        | (1ULL << (GreenPlumParser::XMLROOT - 451))
        | (1ULL << (GreenPlumParser::XMLSERIALIZE - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::LEFT_PAREN - 451))
        | (1ULL << (GreenPlumParser::PLUS_SIGN - 451))
        | (1ULL << (GreenPlumParser::MINUS_SIGN - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451))
        | (1ULL << (GreenPlumParser::ICONST - 451))
        | (1ULL << (GreenPlumParser::FCONST - 451))
        | (1ULL << (GreenPlumParser::BCONST - 451))
        | (1ULL << (GreenPlumParser::XCONST - 451))
        | (1ULL << (GreenPlumParser::PARAM - 451)))) != 0)) {
        setState(6012);
        position_list();
      }
      setState(6015);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(6016);
      match(GreenPlumParser::SUBSTRING);
      setState(6017);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6019);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ARRAY)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::AUTHORIZATION)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BIGINT)
        | (1ULL << GreenPlumParser::BINARY)
        | (1ULL << GreenPlumParser::BIT)
        | (1ULL << GreenPlumParser::BOOLEAN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CASE)
        | (1ULL << GreenPlumParser::CAST)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTER)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHAR_P)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COALESCE)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CROSS - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_CATALOG - 64))
        | (1ULL << (GreenPlumParser::CURRENT_DATE - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURRENT_ROLE - 64))
        | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
        | (1ULL << (GreenPlumParser::CURRENT_TIME - 64))
        | (1ULL << (GreenPlumParser::CURRENT_TIMESTAMP - 64))
        | (1ULL << (GreenPlumParser::CURRENT_USER - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DEC - 64))
        | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DECODE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXISTS - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::EXTRACT - 128))
        | (1ULL << (GreenPlumParser::FALSE_P - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FLOAT_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FREEZE - 128))
        | (1ULL << (GreenPlumParser::FULL - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::GREATEST - 128))
        | (1ULL << (GreenPlumParser::GROUP_ID - 128))
        | (1ULL << (GreenPlumParser::GROUPING - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::ILIKE - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128))
        | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INTEGER - 193))
        | (1ULL << (GreenPlumParser::INTERVAL - 193))
        | (1ULL << (GreenPlumParser::INT_P - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::IS - 193))
        | (1ULL << (GreenPlumParser::ISNULL - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::JOIN - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEAST - 193))
        | (1ULL << (GreenPlumParser::LEFT - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIKE - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCALTIME - 193))
        | (1ULL << (GreenPlumParser::LOCALTIMESTAMP - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::LOG_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEDIAN - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NATIONAL - 193))
        | (1ULL << (GreenPlumParser::NATURAL - 193))
        | (1ULL << (GreenPlumParser::NCHAR - 193))
        | (1ULL << (GreenPlumParser::NEW - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOT - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOTNULL - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLIF - 257))
        | (1ULL << (GreenPlumParser::NULL_P - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::NUMERIC - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OLD - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OUTER_P - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OVERLAPS - 257))
        | (1ULL << (GreenPlumParser::OVERLAY - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PERCENTILE_CONT - 257))
        | (1ULL << (GreenPlumParser::PERCENTILE_DISC - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::POSITION - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REAL - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::RIGHT - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SESSION_USER - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMILAR - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SMALLINT - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUBSTRING - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLE - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TIME - 385))
        | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TREAT - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRIM - 385))
        | (1ULL << (GreenPlumParser::TRUE_P - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNIQUE - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::USER - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARCHAR - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERBOSE - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XMLCONCAT - 451))
        | (1ULL << (GreenPlumParser::XMLELEMENT - 451))
        | (1ULL << (GreenPlumParser::XMLEXISTS - 451))
        | (1ULL << (GreenPlumParser::XMLFOREST - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::XMLPARSE - 451))
        | (1ULL << (GreenPlumParser::XMLPI - 451))
        | (1ULL << (GreenPlumParser::XMLROOT - 451))
        | (1ULL << (GreenPlumParser::XMLSERIALIZE - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::LEFT_PAREN - 451))
        | (1ULL << (GreenPlumParser::PLUS_SIGN - 451))
        | (1ULL << (GreenPlumParser::MINUS_SIGN - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451))
        | (1ULL << (GreenPlumParser::ICONST - 451))
        | (1ULL << (GreenPlumParser::FCONST - 451))
        | (1ULL << (GreenPlumParser::BCONST - 451))
        | (1ULL << (GreenPlumParser::XCONST - 451))
        | (1ULL << (GreenPlumParser::PARAM - 451)))) != 0)) {
        setState(6018);
        substr_list();
      }
      setState(6021);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(6022);
      match(GreenPlumParser::TREAT);
      setState(6023);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6024);
      a_expr();
      setState(6025);
      match(GreenPlumParser::AS);
      setState(6026);
      typename_pg();
      setState(6027);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(6029);
      match(GreenPlumParser::TRIM);
      setState(6030);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6031);
      match(GreenPlumParser::BOTH);
      setState(6032);
      trim_list();
      setState(6033);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(6035);
      match(GreenPlumParser::TRIM);
      setState(6036);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6037);
      match(GreenPlumParser::LEADING);
      setState(6038);
      trim_list();
      setState(6039);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(6041);
      match(GreenPlumParser::TRIM);
      setState(6042);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6043);
      match(GreenPlumParser::TRAILING);
      setState(6044);
      trim_list();
      setState(6045);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(6047);
      match(GreenPlumParser::TRIM);
      setState(6048);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6049);
      trim_list();
      setState(6050);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(6052);
      match(GreenPlumParser::NULLIF);
      setState(6053);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6054);
      a_expr();
      setState(6055);
      match(GreenPlumParser::COMMA);
      setState(6056);
      a_expr();
      setState(6057);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(6059);
      match(GreenPlumParser::COALESCE);
      setState(6060);
      paren_expr_list();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(6061);
      match(GreenPlumParser::GREATEST);
      setState(6062);
      paren_expr_list();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(6063);
      match(GreenPlumParser::LEAST);
      setState(6064);
      paren_expr_list();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(6065);
      match(GreenPlumParser::GROUPING);
      setState(6066);
      paren_expr_list();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(6067);
      match(GreenPlumParser::GROUP_ID);
      setState(6068);
      double_parens();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(6069);
      match(GreenPlumParser::MEDIAN);
      setState(6070);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6071);
      a_expr();
      setState(6072);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(6074);
      match(GreenPlumParser::PERCENTILE_CONT);
      setState(6075);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6076);
      a_expr();
      setState(6077);
      match(GreenPlumParser::RIGHT_PAREN);
      setState(6078);
      match(GreenPlumParser::WITHIN);
      setState(6079);
      match(GreenPlumParser::GROUP_P);
      setState(6080);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6081);
      match(GreenPlumParser::ORDER);
      setState(6082);
      match(GreenPlumParser::BY);
      setState(6083);
      sortby_list();
      setState(6084);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(6086);
      match(GreenPlumParser::PERCENTILE_DISC);
      setState(6087);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6088);
      a_expr();
      setState(6089);
      match(GreenPlumParser::RIGHT_PAREN);
      setState(6090);
      match(GreenPlumParser::WITHIN);
      setState(6091);
      match(GreenPlumParser::GROUP_P);
      setState(6092);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6093);
      match(GreenPlumParser::ORDER);
      setState(6094);
      match(GreenPlumParser::BY);
      setState(6095);
      sortby_list();
      setState(6096);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(6098);
      match(GreenPlumParser::DECODE);
      setState(6099);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6100);
      a_expr();
      setState(6101);
      match(GreenPlumParser::COMMA);
      setState(6102);
      a_expr();
      setState(6103);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(6105);
      match(GreenPlumParser::XMLCONCAT);
      setState(6106);
      paren_expr_list();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(6107);
      match(GreenPlumParser::XMLELEMENT);
      setState(6108);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6109);
      match(GreenPlumParser::NAME_P);
      setState(6110);
      col_label();
      setState(6111);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(6113);
      match(GreenPlumParser::XMLELEMENT);
      setState(6114);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6115);
      match(GreenPlumParser::NAME_P);
      setState(6116);
      col_label();
      setState(6117);
      match(GreenPlumParser::COMMA);
      setState(6118);
      xml_attributes();
      setState(6119);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(6121);
      match(GreenPlumParser::XMLELEMENT);
      setState(6122);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6123);
      match(GreenPlumParser::NAME_P);
      setState(6124);
      col_label();
      setState(6125);
      match(GreenPlumParser::COMMA);
      setState(6126);
      expr_list();
      setState(6127);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(6129);
      match(GreenPlumParser::XMLELEMENT);
      setState(6130);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6131);
      match(GreenPlumParser::NAME_P);
      setState(6132);
      col_label();
      setState(6133);
      match(GreenPlumParser::COMMA);
      setState(6134);
      xml_attributes();
      setState(6135);
      match(GreenPlumParser::COMMA);
      setState(6136);
      expr_list();
      setState(6137);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(6139);
      match(GreenPlumParser::XMLEXISTS);
      setState(6140);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6141);
      c_expr();
      setState(6142);
      xmlexists_argument();
      setState(6143);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(6145);
      match(GreenPlumParser::XMLEXISTS);
      setState(6146);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6147);
      a_expr();
      setState(6148);
      match(GreenPlumParser::COMMA);
      setState(6149);
      a_expr();
      setState(6150);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(6152);
      match(GreenPlumParser::XMLFOREST);
      setState(6153);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6154);
      xml_attribute_list();
      setState(6155);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(6157);
      match(GreenPlumParser::XMLPARSE);
      setState(6158);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6159);
      document_or_content();
      setState(6160);
      a_expr();
      setState(6162);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PRESERVE || _la == GreenPlumParser::STRIP_P) {
        setState(6161);
        xml_whitespace_option();
      }
      setState(6164);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(6166);
      match(GreenPlumParser::XMLPI);
      setState(6167);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6168);
      match(GreenPlumParser::NAME_P);
      setState(6169);
      col_label();
      setState(6170);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(6172);
      match(GreenPlumParser::XMLPI);
      setState(6173);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6174);
      match(GreenPlumParser::NAME_P);
      setState(6175);
      col_label();
      setState(6176);
      match(GreenPlumParser::COMMA);
      setState(6177);
      a_expr();
      setState(6178);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(6180);
      match(GreenPlumParser::XMLROOT);
      setState(6181);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6182);
      a_expr();
      setState(6183);
      match(GreenPlumParser::COMMA);
      setState(6184);
      xml_root_version();
      setState(6186);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::COMMA) {
        setState(6185);
        opt_xml_root_standalone();
      }
      setState(6188);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(6190);
      match(GreenPlumParser::XMLSERIALIZE);
      setState(6191);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6192);
      document_or_content();
      setState(6193);
      a_expr();
      setState(6194);
      match(GreenPlumParser::AS);
      setState(6195);
      simple_typename();
      setState(6196);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_root_versionContext ------------------------------------------------------------------

GreenPlumParser::Xml_root_versionContext::Xml_root_versionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Xml_root_versionContext::VERSION_P() {
  return getToken(GreenPlumParser::VERSION_P, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Xml_root_versionContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Xml_root_versionContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Xml_root_versionContext::VALUE_P() {
  return getToken(GreenPlumParser::VALUE_P, 0);
}


size_t GreenPlumParser::Xml_root_versionContext::getRuleIndex() const {
  return GreenPlumParser::RuleXml_root_version;
}

void GreenPlumParser::Xml_root_versionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_root_version(this);
}

void GreenPlumParser::Xml_root_versionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_root_version(this);
}


antlrcpp::Any GreenPlumParser::Xml_root_versionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitXml_root_version(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Xml_root_versionContext* GreenPlumParser::xml_root_version() {
  Xml_root_versionContext *_localctx = _tracker.createInstance<Xml_root_versionContext>(_ctx, getState());
  enterRule(_localctx, 898, GreenPlumParser::RuleXml_root_version);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6205);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 671, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6200);
      match(GreenPlumParser::VERSION_P);
      setState(6201);
      a_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6202);
      match(GreenPlumParser::VERSION_P);
      setState(6203);
      match(GreenPlumParser::NO);
      setState(6204);
      match(GreenPlumParser::VALUE_P);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_xml_root_standaloneContext ------------------------------------------------------------------

GreenPlumParser::Opt_xml_root_standaloneContext::Opt_xml_root_standaloneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_xml_root_standaloneContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_xml_root_standaloneContext::STANDALONE_P() {
  return getToken(GreenPlumParser::STANDALONE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_xml_root_standaloneContext::YES_P() {
  return getToken(GreenPlumParser::YES_P, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_xml_root_standaloneContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_xml_root_standaloneContext::VALUE_P() {
  return getToken(GreenPlumParser::VALUE_P, 0);
}


size_t GreenPlumParser::Opt_xml_root_standaloneContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_xml_root_standalone;
}

void GreenPlumParser::Opt_xml_root_standaloneContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_xml_root_standalone(this);
}

void GreenPlumParser::Opt_xml_root_standaloneContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_xml_root_standalone(this);
}


antlrcpp::Any GreenPlumParser::Opt_xml_root_standaloneContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_xml_root_standalone(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_xml_root_standaloneContext* GreenPlumParser::opt_xml_root_standalone() {
  Opt_xml_root_standaloneContext *_localctx = _tracker.createInstance<Opt_xml_root_standaloneContext>(_ctx, getState());
  enterRule(_localctx, 900, GreenPlumParser::RuleOpt_xml_root_standalone);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6207);
    match(GreenPlumParser::COMMA);
    setState(6208);
    match(GreenPlumParser::STANDALONE_P);
    setState(6214);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::YES_P: {
        setState(6209);
        match(GreenPlumParser::YES_P);
        break;
      }

      case GreenPlumParser::NO: {
        setState(6210);
        match(GreenPlumParser::NO);
        setState(6212);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::VALUE_P) {
          setState(6211);
          match(GreenPlumParser::VALUE_P);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_attributesContext ------------------------------------------------------------------

GreenPlumParser::Xml_attributesContext::Xml_attributesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Xml_attributesContext::XMLATTRIBUTES() {
  return getToken(GreenPlumParser::XMLATTRIBUTES, 0);
}

tree::TerminalNode* GreenPlumParser::Xml_attributesContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Xml_attribute_listContext* GreenPlumParser::Xml_attributesContext::xml_attribute_list() {
  return getRuleContext<GreenPlumParser::Xml_attribute_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Xml_attributesContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Xml_attributesContext::getRuleIndex() const {
  return GreenPlumParser::RuleXml_attributes;
}

void GreenPlumParser::Xml_attributesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_attributes(this);
}

void GreenPlumParser::Xml_attributesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_attributes(this);
}


antlrcpp::Any GreenPlumParser::Xml_attributesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitXml_attributes(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Xml_attributesContext* GreenPlumParser::xml_attributes() {
  Xml_attributesContext *_localctx = _tracker.createInstance<Xml_attributesContext>(_ctx, getState());
  enterRule(_localctx, 902, GreenPlumParser::RuleXml_attributes);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6216);
    match(GreenPlumParser::XMLATTRIBUTES);
    setState(6217);
    match(GreenPlumParser::LEFT_PAREN);
    setState(6218);
    xml_attribute_list();
    setState(6219);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_attribute_listContext ------------------------------------------------------------------

GreenPlumParser::Xml_attribute_listContext::Xml_attribute_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Xml_attribute_elContext *> GreenPlumParser::Xml_attribute_listContext::xml_attribute_el() {
  return getRuleContexts<GreenPlumParser::Xml_attribute_elContext>();
}

GreenPlumParser::Xml_attribute_elContext* GreenPlumParser::Xml_attribute_listContext::xml_attribute_el(size_t i) {
  return getRuleContext<GreenPlumParser::Xml_attribute_elContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Xml_attribute_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Xml_attribute_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Xml_attribute_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleXml_attribute_list;
}

void GreenPlumParser::Xml_attribute_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_attribute_list(this);
}

void GreenPlumParser::Xml_attribute_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_attribute_list(this);
}


antlrcpp::Any GreenPlumParser::Xml_attribute_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitXml_attribute_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Xml_attribute_listContext* GreenPlumParser::xml_attribute_list() {
  Xml_attribute_listContext *_localctx = _tracker.createInstance<Xml_attribute_listContext>(_ctx, getState());
  enterRule(_localctx, 904, GreenPlumParser::RuleXml_attribute_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6221);
    xml_attribute_el();
    setState(6226);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(6222);
      match(GreenPlumParser::COMMA);
      setState(6223);
      xml_attribute_el();
      setState(6228);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_attribute_elContext ------------------------------------------------------------------

GreenPlumParser::Xml_attribute_elContext::Xml_attribute_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Xml_attribute_elContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Xml_attribute_elContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Xml_attribute_elContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}


size_t GreenPlumParser::Xml_attribute_elContext::getRuleIndex() const {
  return GreenPlumParser::RuleXml_attribute_el;
}

void GreenPlumParser::Xml_attribute_elContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_attribute_el(this);
}

void GreenPlumParser::Xml_attribute_elContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_attribute_el(this);
}


antlrcpp::Any GreenPlumParser::Xml_attribute_elContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitXml_attribute_el(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Xml_attribute_elContext* GreenPlumParser::xml_attribute_el() {
  Xml_attribute_elContext *_localctx = _tracker.createInstance<Xml_attribute_elContext>(_ctx, getState());
  enterRule(_localctx, 906, GreenPlumParser::RuleXml_attribute_el);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6235);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 676, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6229);
      a_expr();
      setState(6232);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::AS) {
        setState(6230);
        match(GreenPlumParser::AS);
        setState(6231);
        col_label();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6234);
      a_expr();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Document_or_contentContext ------------------------------------------------------------------

GreenPlumParser::Document_or_contentContext::Document_or_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Document_or_contentContext::DOCUMENT_P() {
  return getToken(GreenPlumParser::DOCUMENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Document_or_contentContext::CONTENT_P() {
  return getToken(GreenPlumParser::CONTENT_P, 0);
}


size_t GreenPlumParser::Document_or_contentContext::getRuleIndex() const {
  return GreenPlumParser::RuleDocument_or_content;
}

void GreenPlumParser::Document_or_contentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDocument_or_content(this);
}

void GreenPlumParser::Document_or_contentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDocument_or_content(this);
}


antlrcpp::Any GreenPlumParser::Document_or_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDocument_or_content(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Document_or_contentContext* GreenPlumParser::document_or_content() {
  Document_or_contentContext *_localctx = _tracker.createInstance<Document_or_contentContext>(_ctx, getState());
  enterRule(_localctx, 908, GreenPlumParser::RuleDocument_or_content);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6237);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::CONTENT_P

    || _la == GreenPlumParser::DOCUMENT_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_whitespace_optionContext ------------------------------------------------------------------

GreenPlumParser::Xml_whitespace_optionContext::Xml_whitespace_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Xml_whitespace_optionContext::WHITESPACE_P() {
  return getToken(GreenPlumParser::WHITESPACE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Xml_whitespace_optionContext::PRESERVE() {
  return getToken(GreenPlumParser::PRESERVE, 0);
}

tree::TerminalNode* GreenPlumParser::Xml_whitespace_optionContext::STRIP_P() {
  return getToken(GreenPlumParser::STRIP_P, 0);
}


size_t GreenPlumParser::Xml_whitespace_optionContext::getRuleIndex() const {
  return GreenPlumParser::RuleXml_whitespace_option;
}

void GreenPlumParser::Xml_whitespace_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXml_whitespace_option(this);
}

void GreenPlumParser::Xml_whitespace_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXml_whitespace_option(this);
}


antlrcpp::Any GreenPlumParser::Xml_whitespace_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitXml_whitespace_option(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Xml_whitespace_optionContext* GreenPlumParser::xml_whitespace_option() {
  Xml_whitespace_optionContext *_localctx = _tracker.createInstance<Xml_whitespace_optionContext>(_ctx, getState());
  enterRule(_localctx, 910, GreenPlumParser::RuleXml_whitespace_option);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6239);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::PRESERVE || _la == GreenPlumParser::STRIP_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6240);
    match(GreenPlumParser::WHITESPACE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xmlexists_argumentContext ------------------------------------------------------------------

GreenPlumParser::Xmlexists_argumentContext::Xmlexists_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Xmlexists_argumentContext::PASSING() {
  return getToken(GreenPlumParser::PASSING, 0);
}

GreenPlumParser::C_exprContext* GreenPlumParser::Xmlexists_argumentContext::c_expr() {
  return getRuleContext<GreenPlumParser::C_exprContext>(0);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Xmlexists_argumentContext::BY() {
  return getTokens(GreenPlumParser::BY);
}

tree::TerminalNode* GreenPlumParser::Xmlexists_argumentContext::BY(size_t i) {
  return getToken(GreenPlumParser::BY, i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Xmlexists_argumentContext::REF() {
  return getTokens(GreenPlumParser::REF);
}

tree::TerminalNode* GreenPlumParser::Xmlexists_argumentContext::REF(size_t i) {
  return getToken(GreenPlumParser::REF, i);
}


size_t GreenPlumParser::Xmlexists_argumentContext::getRuleIndex() const {
  return GreenPlumParser::RuleXmlexists_argument;
}

void GreenPlumParser::Xmlexists_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXmlexists_argument(this);
}

void GreenPlumParser::Xmlexists_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXmlexists_argument(this);
}


antlrcpp::Any GreenPlumParser::Xmlexists_argumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitXmlexists_argument(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Xmlexists_argumentContext* GreenPlumParser::xmlexists_argument() {
  Xmlexists_argumentContext *_localctx = _tracker.createInstance<Xmlexists_argumentContext>(_ctx, getState());
  enterRule(_localctx, 912, GreenPlumParser::RuleXmlexists_argument);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6256);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 679, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6242);
      match(GreenPlumParser::PASSING);
      setState(6243);
      c_expr();
      setState(6246);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::BY) {
        setState(6244);
        match(GreenPlumParser::BY);
        setState(6245);
        match(GreenPlumParser::REF);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6248);
      match(GreenPlumParser::PASSING);
      setState(6249);
      match(GreenPlumParser::BY);
      setState(6250);
      match(GreenPlumParser::REF);
      setState(6251);
      c_expr();
      setState(6254);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::BY) {
        setState(6252);
        match(GreenPlumParser::BY);
        setState(6253);
        match(GreenPlumParser::REF);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_clauseContext ------------------------------------------------------------------

GreenPlumParser::Window_clauseContext::Window_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Window_clauseContext::WINDOW() {
  return getToken(GreenPlumParser::WINDOW, 0);
}

GreenPlumParser::Window_definition_listContext* GreenPlumParser::Window_clauseContext::window_definition_list() {
  return getRuleContext<GreenPlumParser::Window_definition_listContext>(0);
}


size_t GreenPlumParser::Window_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_clause;
}

void GreenPlumParser::Window_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_clause(this);
}

void GreenPlumParser::Window_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_clause(this);
}


antlrcpp::Any GreenPlumParser::Window_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_clauseContext* GreenPlumParser::window_clause() {
  Window_clauseContext *_localctx = _tracker.createInstance<Window_clauseContext>(_ctx, getState());
  enterRule(_localctx, 914, GreenPlumParser::RuleWindow_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6258);
    match(GreenPlumParser::WINDOW);
    setState(6259);
    window_definition_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_definition_listContext ------------------------------------------------------------------

GreenPlumParser::Window_definition_listContext::Window_definition_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Window_definitionContext *> GreenPlumParser::Window_definition_listContext::window_definition() {
  return getRuleContexts<GreenPlumParser::Window_definitionContext>();
}

GreenPlumParser::Window_definitionContext* GreenPlumParser::Window_definition_listContext::window_definition(size_t i) {
  return getRuleContext<GreenPlumParser::Window_definitionContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Window_definition_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Window_definition_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Window_definition_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_definition_list;
}

void GreenPlumParser::Window_definition_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_definition_list(this);
}

void GreenPlumParser::Window_definition_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_definition_list(this);
}


antlrcpp::Any GreenPlumParser::Window_definition_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_definition_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_definition_listContext* GreenPlumParser::window_definition_list() {
  Window_definition_listContext *_localctx = _tracker.createInstance<Window_definition_listContext>(_ctx, getState());
  enterRule(_localctx, 916, GreenPlumParser::RuleWindow_definition_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6261);
    window_definition();
    setState(6266);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 680, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6262);
        match(GreenPlumParser::COMMA);
        setState(6263);
        window_definition(); 
      }
      setState(6268);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 680, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_definitionContext ------------------------------------------------------------------

GreenPlumParser::Window_definitionContext::Window_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Window_definitionContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

tree::TerminalNode* GreenPlumParser::Window_definitionContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Window_specificationContext* GreenPlumParser::Window_definitionContext::window_specification() {
  return getRuleContext<GreenPlumParser::Window_specificationContext>(0);
}


size_t GreenPlumParser::Window_definitionContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_definition;
}

void GreenPlumParser::Window_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_definition(this);
}

void GreenPlumParser::Window_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_definition(this);
}


antlrcpp::Any GreenPlumParser::Window_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_definition(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_definitionContext* GreenPlumParser::window_definition() {
  Window_definitionContext *_localctx = _tracker.createInstance<Window_definitionContext>(_ctx, getState());
  enterRule(_localctx, 918, GreenPlumParser::RuleWindow_definition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6269);
    colid();
    setState(6270);
    match(GreenPlumParser::AS);
    setState(6271);
    window_specification();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_specificationContext ------------------------------------------------------------------

GreenPlumParser::Window_specificationContext::Window_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Window_specificationContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Window_specificationContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Window_specificationContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}

GreenPlumParser::Opt_partition_clauseContext* GreenPlumParser::Window_specificationContext::opt_partition_clause() {
  return getRuleContext<GreenPlumParser::Opt_partition_clauseContext>(0);
}

GreenPlumParser::Sort_clauseContext* GreenPlumParser::Window_specificationContext::sort_clause() {
  return getRuleContext<GreenPlumParser::Sort_clauseContext>(0);
}

GreenPlumParser::Window_frame_clauseContext* GreenPlumParser::Window_specificationContext::window_frame_clause() {
  return getRuleContext<GreenPlumParser::Window_frame_clauseContext>(0);
}


size_t GreenPlumParser::Window_specificationContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_specification;
}

void GreenPlumParser::Window_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_specification(this);
}

void GreenPlumParser::Window_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_specification(this);
}


antlrcpp::Any GreenPlumParser::Window_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_specification(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_specificationContext* GreenPlumParser::window_specification() {
  Window_specificationContext *_localctx = _tracker.createInstance<Window_specificationContext>(_ctx, getState());
  enterRule(_localctx, 920, GreenPlumParser::RuleWindow_specification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6273);
    match(GreenPlumParser::LEFT_PAREN);
    setState(6275);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451)))) != 0)) {
      setState(6274);
      colid();
    }
    setState(6278);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PARTITION) {
      setState(6277);
      opt_partition_clause();
    }
    setState(6281);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ORDER) {
      setState(6280);
      sort_clause();
    }
    setState(6284);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::RANGE

    || _la == GreenPlumParser::ROWS) {
      setState(6283);
      window_frame_clause();
    }
    setState(6286);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_partition_clauseContext ------------------------------------------------------------------

GreenPlumParser::Opt_partition_clauseContext::Opt_partition_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Opt_partition_clauseContext::PARTITION() {
  return getToken(GreenPlumParser::PARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Opt_partition_clauseContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

GreenPlumParser::Sortby_listContext* GreenPlumParser::Opt_partition_clauseContext::sortby_list() {
  return getRuleContext<GreenPlumParser::Sortby_listContext>(0);
}


size_t GreenPlumParser::Opt_partition_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleOpt_partition_clause;
}

void GreenPlumParser::Opt_partition_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpt_partition_clause(this);
}

void GreenPlumParser::Opt_partition_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpt_partition_clause(this);
}


antlrcpp::Any GreenPlumParser::Opt_partition_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOpt_partition_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Opt_partition_clauseContext* GreenPlumParser::opt_partition_clause() {
  Opt_partition_clauseContext *_localctx = _tracker.createInstance<Opt_partition_clauseContext>(_ctx, getState());
  enterRule(_localctx, 922, GreenPlumParser::RuleOpt_partition_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6288);
    match(GreenPlumParser::PARTITION);
    setState(6289);
    match(GreenPlumParser::BY);
    setState(6290);
    sortby_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_clauseContext ------------------------------------------------------------------

GreenPlumParser::Window_frame_clauseContext::Window_frame_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Window_frame_unitsContext* GreenPlumParser::Window_frame_clauseContext::window_frame_units() {
  return getRuleContext<GreenPlumParser::Window_frame_unitsContext>(0);
}

GreenPlumParser::Window_frame_extentContext* GreenPlumParser::Window_frame_clauseContext::window_frame_extent() {
  return getRuleContext<GreenPlumParser::Window_frame_extentContext>(0);
}

GreenPlumParser::Window_frame_exclusionContext* GreenPlumParser::Window_frame_clauseContext::window_frame_exclusion() {
  return getRuleContext<GreenPlumParser::Window_frame_exclusionContext>(0);
}


size_t GreenPlumParser::Window_frame_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_frame_clause;
}

void GreenPlumParser::Window_frame_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_clause(this);
}

void GreenPlumParser::Window_frame_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_clause(this);
}


antlrcpp::Any GreenPlumParser::Window_frame_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_frame_clauseContext* GreenPlumParser::window_frame_clause() {
  Window_frame_clauseContext *_localctx = _tracker.createInstance<Window_frame_clauseContext>(_ctx, getState());
  enterRule(_localctx, 924, GreenPlumParser::RuleWindow_frame_clause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6292);
    window_frame_units();
    setState(6293);
    window_frame_extent();
    setState(6295);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::EXCLUDE) {
      setState(6294);
      window_frame_exclusion();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_unitsContext ------------------------------------------------------------------

GreenPlumParser::Window_frame_unitsContext::Window_frame_unitsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Window_frame_unitsContext::ROWS() {
  return getToken(GreenPlumParser::ROWS, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_unitsContext::RANGE() {
  return getToken(GreenPlumParser::RANGE, 0);
}


size_t GreenPlumParser::Window_frame_unitsContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_frame_units;
}

void GreenPlumParser::Window_frame_unitsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_units(this);
}

void GreenPlumParser::Window_frame_unitsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_units(this);
}


antlrcpp::Any GreenPlumParser::Window_frame_unitsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_units(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_frame_unitsContext* GreenPlumParser::window_frame_units() {
  Window_frame_unitsContext *_localctx = _tracker.createInstance<Window_frame_unitsContext>(_ctx, getState());
  enterRule(_localctx, 926, GreenPlumParser::RuleWindow_frame_units);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6297);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::RANGE

    || _la == GreenPlumParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_extentContext ------------------------------------------------------------------

GreenPlumParser::Window_frame_extentContext::Window_frame_extentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Window_frame_startContext* GreenPlumParser::Window_frame_extentContext::window_frame_start() {
  return getRuleContext<GreenPlumParser::Window_frame_startContext>(0);
}

GreenPlumParser::Window_frame_betweenContext* GreenPlumParser::Window_frame_extentContext::window_frame_between() {
  return getRuleContext<GreenPlumParser::Window_frame_betweenContext>(0);
}


size_t GreenPlumParser::Window_frame_extentContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_frame_extent;
}

void GreenPlumParser::Window_frame_extentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_extent(this);
}

void GreenPlumParser::Window_frame_extentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_extent(this);
}


antlrcpp::Any GreenPlumParser::Window_frame_extentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_extent(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_frame_extentContext* GreenPlumParser::window_frame_extent() {
  Window_frame_extentContext *_localctx = _tracker.createInstance<Window_frame_extentContext>(_ctx, getState());
  enterRule(_localctx, 928, GreenPlumParser::RuleWindow_frame_extent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6301);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ARRAY:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CASE:
      case GreenPlumParser::CAST:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_CATALOG:
      case GreenPlumParser::CURRENT_DATE:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_ROLE:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURRENT_TIME:
      case GreenPlumParser::CURRENT_TIMESTAMP:
      case GreenPlumParser::CURRENT_USER:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DECODE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCALTIME:
      case GreenPlumParser::LOCALTIMESTAMP:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEDIAN:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOT:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PERCENTILE_CONT:
      case GreenPlumParser::PERCENTILE_DISC:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SESSION_USER:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLE:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNBOUNDED:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNIQUE:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::USER:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XMLCONCAT:
      case GreenPlumParser::XMLELEMENT:
      case GreenPlumParser::XMLEXISTS:
      case GreenPlumParser::XMLFOREST:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::XMLPARSE:
      case GreenPlumParser::XMLPI:
      case GreenPlumParser::XMLROOT:
      case GreenPlumParser::XMLSERIALIZE:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::LEFT_PAREN:
      case GreenPlumParser::PLUS_SIGN:
      case GreenPlumParser::MINUS_SIGN:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST:
      case GreenPlumParser::BCONST:
      case GreenPlumParser::XCONST:
      case GreenPlumParser::PARAM: {
        enterOuterAlt(_localctx, 1);
        setState(6299);
        window_frame_start();
        break;
      }

      case GreenPlumParser::BETWEEN: {
        enterOuterAlt(_localctx, 2);
        setState(6300);
        window_frame_between();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_startContext ------------------------------------------------------------------

GreenPlumParser::Window_frame_startContext::Window_frame_startContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Window_frame_startContext::UNBOUNDED() {
  return getToken(GreenPlumParser::UNBOUNDED, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_startContext::PRECEDING() {
  return getToken(GreenPlumParser::PRECEDING, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Window_frame_startContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_startContext::CURRENT_P() {
  return getToken(GreenPlumParser::CURRENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_startContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}


size_t GreenPlumParser::Window_frame_startContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_frame_start;
}

void GreenPlumParser::Window_frame_startContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_start(this);
}

void GreenPlumParser::Window_frame_startContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_start(this);
}


antlrcpp::Any GreenPlumParser::Window_frame_startContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_start(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_frame_startContext* GreenPlumParser::window_frame_start() {
  Window_frame_startContext *_localctx = _tracker.createInstance<Window_frame_startContext>(_ctx, getState());
  enterRule(_localctx, 930, GreenPlumParser::RuleWindow_frame_start);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6310);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 687, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6303);
      match(GreenPlumParser::UNBOUNDED);
      setState(6304);
      match(GreenPlumParser::PRECEDING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6305);
      a_expr();
      setState(6306);
      match(GreenPlumParser::PRECEDING);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6308);
      match(GreenPlumParser::CURRENT_P);
      setState(6309);
      match(GreenPlumParser::ROW);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_betweenContext ------------------------------------------------------------------

GreenPlumParser::Window_frame_betweenContext::Window_frame_betweenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Window_frame_betweenContext::BETWEEN() {
  return getToken(GreenPlumParser::BETWEEN, 0);
}

std::vector<GreenPlumParser::Window_frame_boundContext *> GreenPlumParser::Window_frame_betweenContext::window_frame_bound() {
  return getRuleContexts<GreenPlumParser::Window_frame_boundContext>();
}

GreenPlumParser::Window_frame_boundContext* GreenPlumParser::Window_frame_betweenContext::window_frame_bound(size_t i) {
  return getRuleContext<GreenPlumParser::Window_frame_boundContext>(i);
}

tree::TerminalNode* GreenPlumParser::Window_frame_betweenContext::AND() {
  return getToken(GreenPlumParser::AND, 0);
}


size_t GreenPlumParser::Window_frame_betweenContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_frame_between;
}

void GreenPlumParser::Window_frame_betweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_between(this);
}

void GreenPlumParser::Window_frame_betweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_between(this);
}


antlrcpp::Any GreenPlumParser::Window_frame_betweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_between(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_frame_betweenContext* GreenPlumParser::window_frame_between() {
  Window_frame_betweenContext *_localctx = _tracker.createInstance<Window_frame_betweenContext>(_ctx, getState());
  enterRule(_localctx, 932, GreenPlumParser::RuleWindow_frame_between);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6312);
    match(GreenPlumParser::BETWEEN);
    setState(6313);
    window_frame_bound();
    setState(6314);
    match(GreenPlumParser::AND);
    setState(6315);
    window_frame_bound();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_boundContext ------------------------------------------------------------------

GreenPlumParser::Window_frame_boundContext::Window_frame_boundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Window_frame_startContext* GreenPlumParser::Window_frame_boundContext::window_frame_start() {
  return getRuleContext<GreenPlumParser::Window_frame_startContext>(0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_boundContext::UNBOUNDED() {
  return getToken(GreenPlumParser::UNBOUNDED, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_boundContext::FOLLOWING() {
  return getToken(GreenPlumParser::FOLLOWING, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Window_frame_boundContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Window_frame_boundContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_frame_bound;
}

void GreenPlumParser::Window_frame_boundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_bound(this);
}

void GreenPlumParser::Window_frame_boundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_bound(this);
}


antlrcpp::Any GreenPlumParser::Window_frame_boundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_bound(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_frame_boundContext* GreenPlumParser::window_frame_bound() {
  Window_frame_boundContext *_localctx = _tracker.createInstance<Window_frame_boundContext>(_ctx, getState());
  enterRule(_localctx, 934, GreenPlumParser::RuleWindow_frame_bound);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6323);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 688, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6317);
      window_frame_start();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6318);
      match(GreenPlumParser::UNBOUNDED);
      setState(6319);
      match(GreenPlumParser::FOLLOWING);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6320);
      a_expr();
      setState(6321);
      match(GreenPlumParser::FOLLOWING);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_frame_exclusionContext ------------------------------------------------------------------

GreenPlumParser::Window_frame_exclusionContext::Window_frame_exclusionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Window_frame_exclusionContext::EXCLUDE() {
  return getToken(GreenPlumParser::EXCLUDE, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_exclusionContext::CURRENT_P() {
  return getToken(GreenPlumParser::CURRENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_exclusionContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_exclusionContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_exclusionContext::TIES() {
  return getToken(GreenPlumParser::TIES, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_exclusionContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Window_frame_exclusionContext::OTHERS() {
  return getToken(GreenPlumParser::OTHERS, 0);
}


size_t GreenPlumParser::Window_frame_exclusionContext::getRuleIndex() const {
  return GreenPlumParser::RuleWindow_frame_exclusion;
}

void GreenPlumParser::Window_frame_exclusionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_frame_exclusion(this);
}

void GreenPlumParser::Window_frame_exclusionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_frame_exclusion(this);
}


antlrcpp::Any GreenPlumParser::Window_frame_exclusionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWindow_frame_exclusion(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Window_frame_exclusionContext* GreenPlumParser::window_frame_exclusion() {
  Window_frame_exclusionContext *_localctx = _tracker.createInstance<Window_frame_exclusionContext>(_ctx, getState());
  enterRule(_localctx, 936, GreenPlumParser::RuleWindow_frame_exclusion);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6335);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 689, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6325);
      match(GreenPlumParser::EXCLUDE);
      setState(6326);
      match(GreenPlumParser::CURRENT_P);
      setState(6327);
      match(GreenPlumParser::ROW);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6328);
      match(GreenPlumParser::EXCLUDE);
      setState(6329);
      match(GreenPlumParser::GROUP_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6330);
      match(GreenPlumParser::EXCLUDE);
      setState(6331);
      match(GreenPlumParser::TIES);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6332);
      match(GreenPlumParser::EXCLUDE);
      setState(6333);
      match(GreenPlumParser::NO);
      setState(6334);
      match(GreenPlumParser::OTHERS);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowContext ------------------------------------------------------------------

GreenPlumParser::RowContext::RowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::RowContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::RowContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::RowContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}


size_t GreenPlumParser::RowContext::getRuleIndex() const {
  return GreenPlumParser::RuleRow;
}

void GreenPlumParser::RowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRow(this);
}

void GreenPlumParser::RowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRow(this);
}


antlrcpp::Any GreenPlumParser::RowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRow(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::RowContext* GreenPlumParser::row() {
  RowContext *_localctx = _tracker.createInstance<RowContext>(_ctx, getState());
  enterRule(_localctx, 938, GreenPlumParser::RuleRow);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6337);
    match(GreenPlumParser::LEFT_PAREN);
    setState(6339);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ARRAY)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CASE)
      | (1ULL << GreenPlumParser::CAST)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTER)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHAR_P)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COALESCE)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CROSS - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_CATALOG - 64))
      | (1ULL << (GreenPlumParser::CURRENT_DATE - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURRENT_ROLE - 64))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
      | (1ULL << (GreenPlumParser::CURRENT_TIME - 64))
      | (1ULL << (GreenPlumParser::CURRENT_TIMESTAMP - 64))
      | (1ULL << (GreenPlumParser::CURRENT_USER - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DEC - 64))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DECODE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXISTS - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::EXTRACT - 128))
      | (1ULL << (GreenPlumParser::FALSE_P - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FLOAT_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FULL - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::GREATEST - 128))
      | (1ULL << (GreenPlumParser::GROUP_ID - 128))
      | (1ULL << (GreenPlumParser::GROUPING - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::ILIKE - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128))
      | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INTEGER - 193))
      | (1ULL << (GreenPlumParser::INTERVAL - 193))
      | (1ULL << (GreenPlumParser::INT_P - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::IS - 193))
      | (1ULL << (GreenPlumParser::ISNULL - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::JOIN - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEAST - 193))
      | (1ULL << (GreenPlumParser::LEFT - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIKE - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCALTIME - 193))
      | (1ULL << (GreenPlumParser::LOCALTIMESTAMP - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::LOG_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEDIAN - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NATIONAL - 193))
      | (1ULL << (GreenPlumParser::NATURAL - 193))
      | (1ULL << (GreenPlumParser::NCHAR - 193))
      | (1ULL << (GreenPlumParser::NEW - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOT - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOTNULL - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLIF - 257))
      | (1ULL << (GreenPlumParser::NULL_P - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::NUMERIC - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OLD - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OUTER_P - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OVERLAPS - 257))
      | (1ULL << (GreenPlumParser::OVERLAY - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PERCENTILE_CONT - 257))
      | (1ULL << (GreenPlumParser::PERCENTILE_DISC - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::POSITION - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REAL - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::RIGHT - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SESSION_USER - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMILAR - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SMALLINT - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUBSTRING - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLE - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TIME - 385))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TREAT - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRIM - 385))
      | (1ULL << (GreenPlumParser::TRUE_P - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNIQUE - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::USER - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARCHAR - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERBOSE - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XMLCONCAT - 451))
      | (1ULL << (GreenPlumParser::XMLELEMENT - 451))
      | (1ULL << (GreenPlumParser::XMLEXISTS - 451))
      | (1ULL << (GreenPlumParser::XMLFOREST - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::XMLPARSE - 451))
      | (1ULL << (GreenPlumParser::XMLPI - 451))
      | (1ULL << (GreenPlumParser::XMLROOT - 451))
      | (1ULL << (GreenPlumParser::XMLSERIALIZE - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::LEFT_PAREN - 451))
      | (1ULL << (GreenPlumParser::PLUS_SIGN - 451))
      | (1ULL << (GreenPlumParser::MINUS_SIGN - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451))
      | (1ULL << (GreenPlumParser::ICONST - 451))
      | (1ULL << (GreenPlumParser::FCONST - 451))
      | (1ULL << (GreenPlumParser::BCONST - 451))
      | (1ULL << (GreenPlumParser::XCONST - 451))
      | (1ULL << (GreenPlumParser::PARAM - 451)))) != 0)) {
      setState(6338);
      expr_list();
    }
    setState(6341);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_signsContext ------------------------------------------------------------------

GreenPlumParser::Op_signsContext::Op_signsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> GreenPlumParser::Op_signsContext::OP_CHARS() {
  return getTokens(GreenPlumParser::OP_CHARS);
}

tree::TerminalNode* GreenPlumParser::Op_signsContext::OP_CHARS(size_t i) {
  return getToken(GreenPlumParser::OP_CHARS, i);
}


size_t GreenPlumParser::Op_signsContext::getRuleIndex() const {
  return GreenPlumParser::RuleOp_signs;
}

void GreenPlumParser::Op_signsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_signs(this);
}

void GreenPlumParser::Op_signsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_signs(this);
}


antlrcpp::Any GreenPlumParser::Op_signsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOp_signs(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Op_signsContext* GreenPlumParser::op_signs() {
  Op_signsContext *_localctx = _tracker.createInstance<Op_signsContext>(_ctx, getState());
  enterRule(_localctx, 940, GreenPlumParser::RuleOp_signs);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6344); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(6343);
              match(GreenPlumParser::OP_CHARS);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(6346); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 691, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_OpContext ------------------------------------------------------------------

GreenPlumParser::All_OpContext::All_OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Op_signsContext* GreenPlumParser::All_OpContext::op_signs() {
  return getRuleContext<GreenPlumParser::Op_signsContext>(0);
}


size_t GreenPlumParser::All_OpContext::getRuleIndex() const {
  return GreenPlumParser::RuleAll_Op;
}

void GreenPlumParser::All_OpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAll_Op(this);
}

void GreenPlumParser::All_OpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAll_Op(this);
}


antlrcpp::Any GreenPlumParser::All_OpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAll_Op(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::All_OpContext* GreenPlumParser::all_Op() {
  All_OpContext *_localctx = _tracker.createInstance<All_OpContext>(_ctx, getState());
  enterRule(_localctx, 942, GreenPlumParser::RuleAll_Op);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6348);
    op_signs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qual_OpContext ------------------------------------------------------------------

GreenPlumParser::Qual_OpContext::Qual_OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Op_signsContext* GreenPlumParser::Qual_OpContext::op_signs() {
  return getRuleContext<GreenPlumParser::Op_signsContext>(0);
}

tree::TerminalNode* GreenPlumParser::Qual_OpContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Qual_OpContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Qual_OpContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

tree::TerminalNode* GreenPlumParser::Qual_OpContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Qual_OpContext::getRuleIndex() const {
  return GreenPlumParser::RuleQual_Op;
}

void GreenPlumParser::Qual_OpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQual_Op(this);
}

void GreenPlumParser::Qual_OpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQual_Op(this);
}


antlrcpp::Any GreenPlumParser::Qual_OpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitQual_Op(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Qual_OpContext* GreenPlumParser::qual_Op() {
  Qual_OpContext *_localctx = _tracker.createInstance<Qual_OpContext>(_ctx, getState());
  enterRule(_localctx, 944, GreenPlumParser::RuleQual_Op);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6356);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::OP_CHARS: {
        enterOuterAlt(_localctx, 1);
        setState(6350);
        op_signs();
        break;
      }

      case GreenPlumParser::OPERATOR: {
        enterOuterAlt(_localctx, 2);
        setState(6351);
        match(GreenPlumParser::OPERATOR);
        setState(6352);
        match(GreenPlumParser::LEFT_PAREN);
        setState(6353);
        any_operator();
        setState(6354);
        match(GreenPlumParser::RIGHT_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qual_all_OpContext ------------------------------------------------------------------

GreenPlumParser::Qual_all_OpContext::Qual_all_OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::All_OpContext* GreenPlumParser::Qual_all_OpContext::all_Op() {
  return getRuleContext<GreenPlumParser::All_OpContext>(0);
}

tree::TerminalNode* GreenPlumParser::Qual_all_OpContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Qual_all_OpContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Qual_all_OpContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

tree::TerminalNode* GreenPlumParser::Qual_all_OpContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Qual_all_OpContext::getRuleIndex() const {
  return GreenPlumParser::RuleQual_all_Op;
}

void GreenPlumParser::Qual_all_OpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQual_all_Op(this);
}

void GreenPlumParser::Qual_all_OpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQual_all_Op(this);
}


antlrcpp::Any GreenPlumParser::Qual_all_OpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitQual_all_Op(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Qual_all_OpContext* GreenPlumParser::qual_all_Op() {
  Qual_all_OpContext *_localctx = _tracker.createInstance<Qual_all_OpContext>(_ctx, getState());
  enterRule(_localctx, 946, GreenPlumParser::RuleQual_all_Op);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6364);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::OP_CHARS: {
        enterOuterAlt(_localctx, 1);
        setState(6358);
        all_Op();
        break;
      }

      case GreenPlumParser::OPERATOR: {
        enterOuterAlt(_localctx, 2);
        setState(6359);
        match(GreenPlumParser::OPERATOR);
        setState(6360);
        match(GreenPlumParser::LEFT_PAREN);
        setState(6361);
        any_operator();
        setState(6362);
        match(GreenPlumParser::RIGHT_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subquery_OpContext ------------------------------------------------------------------

GreenPlumParser::Subquery_OpContext::Subquery_OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::All_OpContext* GreenPlumParser::Subquery_OpContext::all_Op() {
  return getRuleContext<GreenPlumParser::All_OpContext>(0);
}

tree::TerminalNode* GreenPlumParser::Subquery_OpContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Subquery_OpContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Any_operatorContext* GreenPlumParser::Subquery_OpContext::any_operator() {
  return getRuleContext<GreenPlumParser::Any_operatorContext>(0);
}

tree::TerminalNode* GreenPlumParser::Subquery_OpContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GreenPlumParser::Subquery_OpContext::LIKE() {
  return getToken(GreenPlumParser::LIKE, 0);
}

tree::TerminalNode* GreenPlumParser::Subquery_OpContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Subquery_OpContext::ILIKE() {
  return getToken(GreenPlumParser::ILIKE, 0);
}


size_t GreenPlumParser::Subquery_OpContext::getRuleIndex() const {
  return GreenPlumParser::RuleSubquery_Op;
}

void GreenPlumParser::Subquery_OpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery_Op(this);
}

void GreenPlumParser::Subquery_OpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery_Op(this);
}


antlrcpp::Any GreenPlumParser::Subquery_OpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSubquery_Op(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Subquery_OpContext* GreenPlumParser::subquery_Op() {
  Subquery_OpContext *_localctx = _tracker.createInstance<Subquery_OpContext>(_ctx, getState());
  enterRule(_localctx, 948, GreenPlumParser::RuleSubquery_Op);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6380);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 696, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6366);
      all_Op();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6367);
      match(GreenPlumParser::OPERATOR);
      setState(6368);
      match(GreenPlumParser::LEFT_PAREN);
      setState(6369);
      any_operator();
      setState(6370);
      match(GreenPlumParser::RIGHT_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6373);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NOT) {
        setState(6372);
        match(GreenPlumParser::NOT);
      }
      setState(6375);
      match(GreenPlumParser::LIKE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6377);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::NOT) {
        setState(6376);
        match(GreenPlumParser::NOT);
      }
      setState(6379);
      match(GreenPlumParser::ILIKE);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Paren_expr_listContext ------------------------------------------------------------------

GreenPlumParser::Paren_expr_listContext::Paren_expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Paren_expr_listContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::Paren_expr_listContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Paren_expr_listContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Paren_expr_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleParen_expr_list;
}

void GreenPlumParser::Paren_expr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParen_expr_list(this);
}

void GreenPlumParser::Paren_expr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParen_expr_list(this);
}


antlrcpp::Any GreenPlumParser::Paren_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitParen_expr_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::paren_expr_list() {
  Paren_expr_listContext *_localctx = _tracker.createInstance<Paren_expr_listContext>(_ctx, getState());
  enterRule(_localctx, 950, GreenPlumParser::RuleParen_expr_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6382);
    match(GreenPlumParser::LEFT_PAREN);
    setState(6383);
    expr_list();
    setState(6384);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_listContext ------------------------------------------------------------------

GreenPlumParser::Expr_listContext::Expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::A_exprContext *> GreenPlumParser::Expr_listContext::a_expr() {
  return getRuleContexts<GreenPlumParser::A_exprContext>();
}

GreenPlumParser::A_exprContext* GreenPlumParser::Expr_listContext::a_expr(size_t i) {
  return getRuleContext<GreenPlumParser::A_exprContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Expr_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Expr_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Expr_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleExpr_list;
}

void GreenPlumParser::Expr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_list(this);
}

void GreenPlumParser::Expr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_list(this);
}


antlrcpp::Any GreenPlumParser::Expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExpr_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::expr_list() {
  Expr_listContext *_localctx = _tracker.createInstance<Expr_listContext>(_ctx, getState());
  enterRule(_localctx, 952, GreenPlumParser::RuleExpr_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6386);
    a_expr();
    setState(6391);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 697, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6387);
        match(GreenPlumParser::COMMA);
        setState(6388);
        a_expr(); 
      }
      setState(6393);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 697, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_listContext ------------------------------------------------------------------

GreenPlumParser::Type_listContext::Type_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Typename_pgContext *> GreenPlumParser::Type_listContext::typename_pg() {
  return getRuleContexts<GreenPlumParser::Typename_pgContext>();
}

GreenPlumParser::Typename_pgContext* GreenPlumParser::Type_listContext::typename_pg(size_t i) {
  return getRuleContext<GreenPlumParser::Typename_pgContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Type_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Type_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Type_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleType_list;
}

void GreenPlumParser::Type_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_list(this);
}

void GreenPlumParser::Type_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_list(this);
}


antlrcpp::Any GreenPlumParser::Type_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitType_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Type_listContext* GreenPlumParser::type_list() {
  Type_listContext *_localctx = _tracker.createInstance<Type_listContext>(_ctx, getState());
  enterRule(_localctx, 954, GreenPlumParser::RuleType_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6394);
    typename_pg();
    setState(6399);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(6395);
      match(GreenPlumParser::COMMA);
      setState(6396);
      typename_pg();
      setState(6401);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_exprContext ------------------------------------------------------------------

GreenPlumParser::Array_exprContext::Array_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Array_exprContext::LEFT_BRACKET() {
  return getToken(GreenPlumParser::LEFT_BRACKET, 0);
}

tree::TerminalNode* GreenPlumParser::Array_exprContext::RIGHT_BRACKET() {
  return getToken(GreenPlumParser::RIGHT_BRACKET, 0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::Array_exprContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}

GreenPlumParser::Array_expr_listContext* GreenPlumParser::Array_exprContext::array_expr_list() {
  return getRuleContext<GreenPlumParser::Array_expr_listContext>(0);
}


size_t GreenPlumParser::Array_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleArray_expr;
}

void GreenPlumParser::Array_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr(this);
}

void GreenPlumParser::Array_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr(this);
}


antlrcpp::Any GreenPlumParser::Array_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitArray_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Array_exprContext* GreenPlumParser::array_expr() {
  Array_exprContext *_localctx = _tracker.createInstance<Array_exprContext>(_ctx, getState());
  enterRule(_localctx, 956, GreenPlumParser::RuleArray_expr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6411);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 700, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6402);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(6404);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
        | (1ULL << GreenPlumParser::ABSOLUTE_P)
        | (1ULL << GreenPlumParser::ACCESS)
        | (1ULL << GreenPlumParser::ACTION)
        | (1ULL << GreenPlumParser::ACTIVE)
        | (1ULL << GreenPlumParser::ADD_P)
        | (1ULL << GreenPlumParser::ADMIN)
        | (1ULL << GreenPlumParser::AFTER)
        | (1ULL << GreenPlumParser::AGGREGATE)
        | (1ULL << GreenPlumParser::ALSO)
        | (1ULL << GreenPlumParser::ALTER)
        | (1ULL << GreenPlumParser::ALWAYS)
        | (1ULL << GreenPlumParser::ARRAY)
        | (1ULL << GreenPlumParser::ASSERTION)
        | (1ULL << GreenPlumParser::ASSIGNMENT)
        | (1ULL << GreenPlumParser::AT)
        | (1ULL << GreenPlumParser::AUTHORIZATION)
        | (1ULL << GreenPlumParser::BACKWARD)
        | (1ULL << GreenPlumParser::BEFORE)
        | (1ULL << GreenPlumParser::BEGIN_P)
        | (1ULL << GreenPlumParser::BIGINT)
        | (1ULL << GreenPlumParser::BINARY)
        | (1ULL << GreenPlumParser::BIT)
        | (1ULL << GreenPlumParser::BOOLEAN_P)
        | (1ULL << GreenPlumParser::BY)
        | (1ULL << GreenPlumParser::CACHE)
        | (1ULL << GreenPlumParser::CALLED)
        | (1ULL << GreenPlumParser::CASCADE)
        | (1ULL << GreenPlumParser::CASCADED)
        | (1ULL << GreenPlumParser::CASE)
        | (1ULL << GreenPlumParser::CAST)
        | (1ULL << GreenPlumParser::CHAIN)
        | (1ULL << GreenPlumParser::CHARACTER)
        | (1ULL << GreenPlumParser::CHARACTERISTICS)
        | (1ULL << GreenPlumParser::CHAR_P)
        | (1ULL << GreenPlumParser::CHECKPOINT)
        | (1ULL << GreenPlumParser::CLASS)
        | (1ULL << GreenPlumParser::CLOSE)
        | (1ULL << GreenPlumParser::CLUSTER)
        | (1ULL << GreenPlumParser::COALESCE)
        | (1ULL << GreenPlumParser::COMMENT)
        | (1ULL << GreenPlumParser::COMMIT)
        | (1ULL << GreenPlumParser::COMMITTED)
        | (1ULL << GreenPlumParser::CONCURRENCY)
        | (1ULL << GreenPlumParser::CONCURRENTLY)
        | (1ULL << GreenPlumParser::CONFIGURATION)
        | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
        | (1ULL << (GreenPlumParser::CONTAINS - 64))
        | (1ULL << (GreenPlumParser::CONTENT_P - 64))
        | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
        | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
        | (1ULL << (GreenPlumParser::COPY - 64))
        | (1ULL << (GreenPlumParser::COST - 64))
        | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
        | (1ULL << (GreenPlumParser::CPUSET - 64))
        | (1ULL << (GreenPlumParser::CREATEDB - 64))
        | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
        | (1ULL << (GreenPlumParser::CREATEROLE - 64))
        | (1ULL << (GreenPlumParser::CREATEUSER - 64))
        | (1ULL << (GreenPlumParser::CROSS - 64))
        | (1ULL << (GreenPlumParser::CSV - 64))
        | (1ULL << (GreenPlumParser::CURRENT_CATALOG - 64))
        | (1ULL << (GreenPlumParser::CURRENT_DATE - 64))
        | (1ULL << (GreenPlumParser::CURRENT_P - 64))
        | (1ULL << (GreenPlumParser::CURRENT_ROLE - 64))
        | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
        | (1ULL << (GreenPlumParser::CURRENT_TIME - 64))
        | (1ULL << (GreenPlumParser::CURRENT_TIMESTAMP - 64))
        | (1ULL << (GreenPlumParser::CURRENT_USER - 64))
        | (1ULL << (GreenPlumParser::CURSOR - 64))
        | (1ULL << (GreenPlumParser::CYCLE - 64))
        | (1ULL << (GreenPlumParser::DATABASE - 64))
        | (1ULL << (GreenPlumParser::DATA_P - 64))
        | (1ULL << (GreenPlumParser::DAY_P - 64))
        | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
        | (1ULL << (GreenPlumParser::DEC - 64))
        | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
        | (1ULL << (GreenPlumParser::DECLARE - 64))
        | (1ULL << (GreenPlumParser::DECODE - 64))
        | (1ULL << (GreenPlumParser::DEFAULTS - 64))
        | (1ULL << (GreenPlumParser::DEFERRED - 64))
        | (1ULL << (GreenPlumParser::DEFINER - 64))
        | (1ULL << (GreenPlumParser::DELETE_P - 64))
        | (1ULL << (GreenPlumParser::DELIMITER - 64))
        | (1ULL << (GreenPlumParser::DELIMITERS - 64))
        | (1ULL << (GreenPlumParser::DENY - 64))
        | (1ULL << (GreenPlumParser::DICTIONARY - 64))
        | (1ULL << (GreenPlumParser::DISABLE_P - 64))
        | (1ULL << (GreenPlumParser::DISCARD - 64))
        | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
        | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
        | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
        | (1ULL << (GreenPlumParser::DROP - 64))
        | (1ULL << (GreenPlumParser::DXL - 64))
        | (1ULL << (GreenPlumParser::EACH - 64))
        | (1ULL << (GreenPlumParser::ENABLE_P - 64))
        | (1ULL << (GreenPlumParser::ENCODING - 64))
        | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
        | (1ULL << (GreenPlumParser::ENUM_P - 64))
        | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
        | (1ULL << (GreenPlumParser::EVERY - 128))
        | (1ULL << (GreenPlumParser::EXCHANGE - 128))
        | (1ULL << (GreenPlumParser::EXCLUDING - 128))
        | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::EXECUTE - 128))
        | (1ULL << (GreenPlumParser::EXISTS - 128))
        | (1ULL << (GreenPlumParser::EXPLAIN - 128))
        | (1ULL << (GreenPlumParser::EXTENSION - 128))
        | (1ULL << (GreenPlumParser::EXTERNAL - 128))
        | (1ULL << (GreenPlumParser::EXTRACT - 128))
        | (1ULL << (GreenPlumParser::FALSE_P - 128))
        | (1ULL << (GreenPlumParser::FAMILY - 128))
        | (1ULL << (GreenPlumParser::FIELDS - 128))
        | (1ULL << (GreenPlumParser::FILESPACE - 128))
        | (1ULL << (GreenPlumParser::FILL - 128))
        | (1ULL << (GreenPlumParser::FIRST_P - 128))
        | (1ULL << (GreenPlumParser::FLOAT_P - 128))
        | (1ULL << (GreenPlumParser::FORCE - 128))
        | (1ULL << (GreenPlumParser::FORMAT - 128))
        | (1ULL << (GreenPlumParser::FORWARD - 128))
        | (1ULL << (GreenPlumParser::FREEZE - 128))
        | (1ULL << (GreenPlumParser::FULL - 128))
        | (1ULL << (GreenPlumParser::FUNCTION - 128))
        | (1ULL << (GreenPlumParser::GLOBAL - 128))
        | (1ULL << (GreenPlumParser::GRANTED - 128))
        | (1ULL << (GreenPlumParser::GREATEST - 128))
        | (1ULL << (GreenPlumParser::GROUP_ID - 128))
        | (1ULL << (GreenPlumParser::GROUPING - 128))
        | (1ULL << (GreenPlumParser::HANDLER - 128))
        | (1ULL << (GreenPlumParser::HASH - 128))
        | (1ULL << (GreenPlumParser::HEADER_P - 128))
        | (1ULL << (GreenPlumParser::HOLD - 128))
        | (1ULL << (GreenPlumParser::HOST - 128))
        | (1ULL << (GreenPlumParser::HOUR_P - 128))
        | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
        | (1ULL << (GreenPlumParser::IF_P - 128))
        | (1ULL << (GreenPlumParser::IGNORE_P - 128))
        | (1ULL << (GreenPlumParser::ILIKE - 128))
        | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
        | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
        | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
        | (1ULL << (GreenPlumParser::INCLUDING - 128))
        | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
        | (1ULL << (GreenPlumParser::INCREMENT - 128))
        | (1ULL << (GreenPlumParser::INDEX - 128))
        | (1ULL << (GreenPlumParser::INDEXES - 128))
        | (1ULL << (GreenPlumParser::INHERIT - 128))
        | (1ULL << (GreenPlumParser::INHERITS - 128))
        | (1ULL << (GreenPlumParser::INLINE_P - 128))
        | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
        | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
        | (1ULL << (GreenPlumParser::INSERT - 193))
        | (1ULL << (GreenPlumParser::INSTEAD - 193))
        | (1ULL << (GreenPlumParser::INTEGER - 193))
        | (1ULL << (GreenPlumParser::INTERVAL - 193))
        | (1ULL << (GreenPlumParser::INT_P - 193))
        | (1ULL << (GreenPlumParser::INVOKER - 193))
        | (1ULL << (GreenPlumParser::IS - 193))
        | (1ULL << (GreenPlumParser::ISNULL - 193))
        | (1ULL << (GreenPlumParser::ISOLATION - 193))
        | (1ULL << (GreenPlumParser::JOIN - 193))
        | (1ULL << (GreenPlumParser::KEY - 193))
        | (1ULL << (GreenPlumParser::LANGUAGE - 193))
        | (1ULL << (GreenPlumParser::LARGE_P - 193))
        | (1ULL << (GreenPlumParser::LAST_P - 193))
        | (1ULL << (GreenPlumParser::LEAST - 193))
        | (1ULL << (GreenPlumParser::LEFT - 193))
        | (1ULL << (GreenPlumParser::LEVEL - 193))
        | (1ULL << (GreenPlumParser::LIKE - 193))
        | (1ULL << (GreenPlumParser::LIST - 193))
        | (1ULL << (GreenPlumParser::LISTEN - 193))
        | (1ULL << (GreenPlumParser::LOAD - 193))
        | (1ULL << (GreenPlumParser::LOCAL - 193))
        | (1ULL << (GreenPlumParser::LOCALTIME - 193))
        | (1ULL << (GreenPlumParser::LOCALTIMESTAMP - 193))
        | (1ULL << (GreenPlumParser::LOCATION - 193))
        | (1ULL << (GreenPlumParser::LOCK_P - 193))
        | (1ULL << (GreenPlumParser::LOGIN_P - 193))
        | (1ULL << (GreenPlumParser::LOG_P - 193))
        | (1ULL << (GreenPlumParser::MAPPING - 193))
        | (1ULL << (GreenPlumParser::MASTER - 193))
        | (1ULL << (GreenPlumParser::MATCH - 193))
        | (1ULL << (GreenPlumParser::MAXVALUE - 193))
        | (1ULL << (GreenPlumParser::MEDIAN - 193))
        | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
        | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
        | (1ULL << (GreenPlumParser::MERGE - 193))
        | (1ULL << (GreenPlumParser::MINUTE_P - 193))
        | (1ULL << (GreenPlumParser::MINVALUE - 193))
        | (1ULL << (GreenPlumParser::MISSING - 193))
        | (1ULL << (GreenPlumParser::MODE - 193))
        | (1ULL << (GreenPlumParser::MODIFIES - 193))
        | (1ULL << (GreenPlumParser::MODIFY - 193))
        | (1ULL << (GreenPlumParser::MONTH_P - 193))
        | (1ULL << (GreenPlumParser::MOVE - 193))
        | (1ULL << (GreenPlumParser::NAME_P - 193))
        | (1ULL << (GreenPlumParser::NAMES - 193))
        | (1ULL << (GreenPlumParser::NATIONAL - 193))
        | (1ULL << (GreenPlumParser::NATURAL - 193))
        | (1ULL << (GreenPlumParser::NCHAR - 193))
        | (1ULL << (GreenPlumParser::NEW - 193))
        | (1ULL << (GreenPlumParser::NEXT - 193))
        | (1ULL << (GreenPlumParser::NO - 193))
        | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
        | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
        | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
        | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
        | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
        | (1ULL << (GreenPlumParser::NOT - 257))
        | (1ULL << (GreenPlumParser::NOTHING - 257))
        | (1ULL << (GreenPlumParser::NOTIFY - 257))
        | (1ULL << (GreenPlumParser::NOTNULL - 257))
        | (1ULL << (GreenPlumParser::NOWAIT - 257))
        | (1ULL << (GreenPlumParser::NULLIF - 257))
        | (1ULL << (GreenPlumParser::NULL_P - 257))
        | (1ULL << (GreenPlumParser::NULLS_P - 257))
        | (1ULL << (GreenPlumParser::NUMERIC - 257))
        | (1ULL << (GreenPlumParser::OBJECT_P - 257))
        | (1ULL << (GreenPlumParser::OF - 257))
        | (1ULL << (GreenPlumParser::OIDS - 257))
        | (1ULL << (GreenPlumParser::OLD - 257))
        | (1ULL << (GreenPlumParser::OPERATOR - 257))
        | (1ULL << (GreenPlumParser::OPTION - 257))
        | (1ULL << (GreenPlumParser::OPTIONS - 257))
        | (1ULL << (GreenPlumParser::ORDERED - 257))
        | (1ULL << (GreenPlumParser::OTHERS - 257))
        | (1ULL << (GreenPlumParser::OUTER_P - 257))
        | (1ULL << (GreenPlumParser::OVER - 257))
        | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
        | (1ULL << (GreenPlumParser::OVERLAPS - 257))
        | (1ULL << (GreenPlumParser::OVERLAY - 257))
        | (1ULL << (GreenPlumParser::OWNED - 257))
        | (1ULL << (GreenPlumParser::OWNER - 257))
        | (1ULL << (GreenPlumParser::PARSER - 257))
        | (1ULL << (GreenPlumParser::PARTIAL - 257))
        | (1ULL << (GreenPlumParser::PARTITIONS - 257))
        | (1ULL << (GreenPlumParser::PASSING - 257))
        | (1ULL << (GreenPlumParser::PASSWORD - 257))
        | (1ULL << (GreenPlumParser::PERCENT - 257))
        | (1ULL << (GreenPlumParser::PERCENTILE_CONT - 257))
        | (1ULL << (GreenPlumParser::PERCENTILE_DISC - 257))
        | (1ULL << (GreenPlumParser::PLANS - 257))
        | (1ULL << (GreenPlumParser::POSITION - 257))
        | (1ULL << (GreenPlumParser::PREPARE - 257))
        | (1ULL << (GreenPlumParser::PREPARED - 257))
        | (1ULL << (GreenPlumParser::PRESERVE - 257))
        | (1ULL << (GreenPlumParser::PRIOR - 257))
        | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
        | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
        | (1ULL << (GreenPlumParser::PROCEDURE - 257))
        | (1ULL << (GreenPlumParser::PROGRAM - 257))
        | (1ULL << (GreenPlumParser::PROTOCOL - 257))
        | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
        | (1ULL << (GreenPlumParser::QUOTE - 321))
        | (1ULL << (GreenPlumParser::RANDOMLY - 321))
        | (1ULL << (GreenPlumParser::READ - 321))
        | (1ULL << (GreenPlumParser::READABLE - 321))
        | (1ULL << (GreenPlumParser::READS - 321))
        | (1ULL << (GreenPlumParser::REAL - 321))
        | (1ULL << (GreenPlumParser::REASSIGN - 321))
        | (1ULL << (GreenPlumParser::RECHECK - 321))
        | (1ULL << (GreenPlumParser::RECURSIVE - 321))
        | (1ULL << (GreenPlumParser::REF - 321))
        | (1ULL << (GreenPlumParser::REINDEX - 321))
        | (1ULL << (GreenPlumParser::REJECT_P - 321))
        | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
        | (1ULL << (GreenPlumParser::RELEASE - 321))
        | (1ULL << (GreenPlumParser::RENAME - 321))
        | (1ULL << (GreenPlumParser::REPEATABLE - 321))
        | (1ULL << (GreenPlumParser::REPLACE - 321))
        | (1ULL << (GreenPlumParser::REPLICA - 321))
        | (1ULL << (GreenPlumParser::RESET - 321))
        | (1ULL << (GreenPlumParser::RESOURCE - 321))
        | (1ULL << (GreenPlumParser::RESTART - 321))
        | (1ULL << (GreenPlumParser::RESTRICT - 321))
        | (1ULL << (GreenPlumParser::RETURNS - 321))
        | (1ULL << (GreenPlumParser::REVOKE - 321))
        | (1ULL << (GreenPlumParser::RIGHT - 321))
        | (1ULL << (GreenPlumParser::ROLE - 321))
        | (1ULL << (GreenPlumParser::ROLLBACK - 321))
        | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
        | (1ULL << (GreenPlumParser::RULE - 321))
        | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
        | (1ULL << (GreenPlumParser::SCHEMA - 321))
        | (1ULL << (GreenPlumParser::SCROLL - 321))
        | (1ULL << (GreenPlumParser::SEARCH - 321))
        | (1ULL << (GreenPlumParser::SECOND_P - 321))
        | (1ULL << (GreenPlumParser::SECURITY - 321))
        | (1ULL << (GreenPlumParser::SEGMENT - 321))
        | (1ULL << (GreenPlumParser::SEQUENCE - 321))
        | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
        | (1ULL << (GreenPlumParser::SESSION - 321))
        | (1ULL << (GreenPlumParser::SESSION_USER - 321))
        | (1ULL << (GreenPlumParser::SET - 321))
        | (1ULL << (GreenPlumParser::SHARE - 321))
        | (1ULL << (GreenPlumParser::SHOW - 321))
        | (1ULL << (GreenPlumParser::SIMILAR - 321))
        | (1ULL << (GreenPlumParser::SIMPLE - 321))
        | (1ULL << (GreenPlumParser::SMALLINT - 321))
        | (1ULL << (GreenPlumParser::SPLIT - 321))
        | (1ULL << (GreenPlumParser::SQL - 321))
        | (1ULL << (GreenPlumParser::STABLE - 321))
        | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
        | (1ULL << (GreenPlumParser::START - 321))
        | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
        | (1ULL << (GreenPlumParser::STDIN - 385))
        | (1ULL << (GreenPlumParser::STDOUT - 385))
        | (1ULL << (GreenPlumParser::STORAGE - 385))
        | (1ULL << (GreenPlumParser::STRICT_P - 385))
        | (1ULL << (GreenPlumParser::STRIP_P - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
        | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
        | (1ULL << (GreenPlumParser::SUBSTRING - 385))
        | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
        | (1ULL << (GreenPlumParser::SYSID - 385))
        | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
        | (1ULL << (GreenPlumParser::TABLE - 385))
        | (1ULL << (GreenPlumParser::TABLESPACE - 385))
        | (1ULL << (GreenPlumParser::TEMP - 385))
        | (1ULL << (GreenPlumParser::TEMPLATE - 385))
        | (1ULL << (GreenPlumParser::TEMPORARY - 385))
        | (1ULL << (GreenPlumParser::TEXT_P - 385))
        | (1ULL << (GreenPlumParser::THRESHOLD - 385))
        | (1ULL << (GreenPlumParser::TIES - 385))
        | (1ULL << (GreenPlumParser::TIME - 385))
        | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
        | (1ULL << (GreenPlumParser::TRANSACTION - 385))
        | (1ULL << (GreenPlumParser::TREAT - 385))
        | (1ULL << (GreenPlumParser::TRIGGER - 385))
        | (1ULL << (GreenPlumParser::TRIM - 385))
        | (1ULL << (GreenPlumParser::TRUE_P - 385))
        | (1ULL << (GreenPlumParser::TRUNCATE - 385))
        | (1ULL << (GreenPlumParser::TRUSTED - 385))
        | (1ULL << (GreenPlumParser::TYPE_P - 385))
        | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
        | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
        | (1ULL << (GreenPlumParser::UNIQUE - 385))
        | (1ULL << (GreenPlumParser::UNKNOWN - 385))
        | (1ULL << (GreenPlumParser::UNLISTEN - 385))
        | (1ULL << (GreenPlumParser::UNTIL - 385))
        | (1ULL << (GreenPlumParser::UPDATE - 385))
        | (1ULL << (GreenPlumParser::USER - 385))
        | (1ULL << (GreenPlumParser::VACUUM - 385))
        | (1ULL << (GreenPlumParser::VALID - 385))
        | (1ULL << (GreenPlumParser::VALIDATION - 385))
        | (1ULL << (GreenPlumParser::VALIDATOR - 385))
        | (1ULL << (GreenPlumParser::VALUE_P - 385))
        | (1ULL << (GreenPlumParser::VARCHAR - 385))
        | (1ULL << (GreenPlumParser::VARYING - 385))
        | (1ULL << (GreenPlumParser::VERBOSE - 385))
        | (1ULL << (GreenPlumParser::VERSION_P - 385))
        | (1ULL << (GreenPlumParser::VIEW - 385))
        | (1ULL << (GreenPlumParser::VOLATILE - 385))
        | (1ULL << (GreenPlumParser::WEB - 385))
        | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
        | (1ULL << (GreenPlumParser::WITHOUT - 451))
        | (1ULL << (GreenPlumParser::WORK - 451))
        | (1ULL << (GreenPlumParser::WRITABLE - 451))
        | (1ULL << (GreenPlumParser::WRITE - 451))
        | (1ULL << (GreenPlumParser::XMLCONCAT - 451))
        | (1ULL << (GreenPlumParser::XMLELEMENT - 451))
        | (1ULL << (GreenPlumParser::XMLEXISTS - 451))
        | (1ULL << (GreenPlumParser::XMLFOREST - 451))
        | (1ULL << (GreenPlumParser::XML_P - 451))
        | (1ULL << (GreenPlumParser::XMLPARSE - 451))
        | (1ULL << (GreenPlumParser::XMLPI - 451))
        | (1ULL << (GreenPlumParser::XMLROOT - 451))
        | (1ULL << (GreenPlumParser::XMLSERIALIZE - 451))
        | (1ULL << (GreenPlumParser::YEAR_P - 451))
        | (1ULL << (GreenPlumParser::YES_P - 451))
        | (1ULL << (GreenPlumParser::ZONE - 451))
        | (1ULL << (GreenPlumParser::LEFT_PAREN - 451))
        | (1ULL << (GreenPlumParser::PLUS_SIGN - 451))
        | (1ULL << (GreenPlumParser::MINUS_SIGN - 451))
        | (1ULL << (GreenPlumParser::COLON - 451))
        | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
        | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
        | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
        | (1ULL << (GreenPlumParser::SCONST - 451))
        | (1ULL << (GreenPlumParser::ICONST - 451))
        | (1ULL << (GreenPlumParser::FCONST - 451))
        | (1ULL << (GreenPlumParser::BCONST - 451))
        | (1ULL << (GreenPlumParser::XCONST - 451))
        | (1ULL << (GreenPlumParser::PARAM - 451)))) != 0)) {
        setState(6403);
        expr_list();
      }
      setState(6406);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6407);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(6408);
      array_expr_list();
      setState(6409);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_expr_listContext ------------------------------------------------------------------

GreenPlumParser::Array_expr_listContext::Array_expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Array_exprContext *> GreenPlumParser::Array_expr_listContext::array_expr() {
  return getRuleContexts<GreenPlumParser::Array_exprContext>();
}

GreenPlumParser::Array_exprContext* GreenPlumParser::Array_expr_listContext::array_expr(size_t i) {
  return getRuleContext<GreenPlumParser::Array_exprContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Array_expr_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Array_expr_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Array_expr_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleArray_expr_list;
}

void GreenPlumParser::Array_expr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_list(this);
}

void GreenPlumParser::Array_expr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_list(this);
}


antlrcpp::Any GreenPlumParser::Array_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitArray_expr_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Array_expr_listContext* GreenPlumParser::array_expr_list() {
  Array_expr_listContext *_localctx = _tracker.createInstance<Array_expr_listContext>(_ctx, getState());
  enterRule(_localctx, 958, GreenPlumParser::RuleArray_expr_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6413);
    array_expr();
    setState(6418);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(6414);
      match(GreenPlumParser::COMMA);
      setState(6415);
      array_expr();
      setState(6420);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extract_listContext ------------------------------------------------------------------

GreenPlumParser::Extract_listContext::Extract_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Extract_argContext* GreenPlumParser::Extract_listContext::extract_arg() {
  return getRuleContext<GreenPlumParser::Extract_argContext>(0);
}

tree::TerminalNode* GreenPlumParser::Extract_listContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Extract_listContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Extract_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleExtract_list;
}

void GreenPlumParser::Extract_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtract_list(this);
}

void GreenPlumParser::Extract_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtract_list(this);
}


antlrcpp::Any GreenPlumParser::Extract_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExtract_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Extract_listContext* GreenPlumParser::extract_list() {
  Extract_listContext *_localctx = _tracker.createInstance<Extract_listContext>(_ctx, getState());
  enterRule(_localctx, 960, GreenPlumParser::RuleExtract_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6421);
    extract_arg();
    setState(6422);
    match(GreenPlumParser::FROM);
    setState(6423);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extract_argContext ------------------------------------------------------------------

GreenPlumParser::Extract_argContext::Extract_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IdentifierContext* GreenPlumParser::Extract_argContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}

tree::TerminalNode* GreenPlumParser::Extract_argContext::YEAR_P() {
  return getToken(GreenPlumParser::YEAR_P, 0);
}

tree::TerminalNode* GreenPlumParser::Extract_argContext::MONTH_P() {
  return getToken(GreenPlumParser::MONTH_P, 0);
}

tree::TerminalNode* GreenPlumParser::Extract_argContext::DAY_P() {
  return getToken(GreenPlumParser::DAY_P, 0);
}

tree::TerminalNode* GreenPlumParser::Extract_argContext::HOUR_P() {
  return getToken(GreenPlumParser::HOUR_P, 0);
}

tree::TerminalNode* GreenPlumParser::Extract_argContext::MINUTE_P() {
  return getToken(GreenPlumParser::MINUTE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Extract_argContext::SECOND_P() {
  return getToken(GreenPlumParser::SECOND_P, 0);
}

tree::TerminalNode* GreenPlumParser::Extract_argContext::DELIMITED_STR() {
  return getToken(GreenPlumParser::DELIMITED_STR, 0);
}


size_t GreenPlumParser::Extract_argContext::getRuleIndex() const {
  return GreenPlumParser::RuleExtract_arg;
}

void GreenPlumParser::Extract_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtract_arg(this);
}

void GreenPlumParser::Extract_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtract_arg(this);
}


antlrcpp::Any GreenPlumParser::Extract_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitExtract_arg(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Extract_argContext* GreenPlumParser::extract_arg() {
  Extract_argContext *_localctx = _tracker.createInstance<Extract_argContext>(_ctx, getState());
  enterRule(_localctx, 962, GreenPlumParser::RuleExtract_arg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6433);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID: {
        enterOuterAlt(_localctx, 1);
        setState(6425);
        identifier();
        break;
      }

      case GreenPlumParser::YEAR_P: {
        enterOuterAlt(_localctx, 2);
        setState(6426);
        match(GreenPlumParser::YEAR_P);
        break;
      }

      case GreenPlumParser::MONTH_P: {
        enterOuterAlt(_localctx, 3);
        setState(6427);
        match(GreenPlumParser::MONTH_P);
        break;
      }

      case GreenPlumParser::DAY_P: {
        enterOuterAlt(_localctx, 4);
        setState(6428);
        match(GreenPlumParser::DAY_P);
        break;
      }

      case GreenPlumParser::HOUR_P: {
        enterOuterAlt(_localctx, 5);
        setState(6429);
        match(GreenPlumParser::HOUR_P);
        break;
      }

      case GreenPlumParser::MINUTE_P: {
        enterOuterAlt(_localctx, 6);
        setState(6430);
        match(GreenPlumParser::MINUTE_P);
        break;
      }

      case GreenPlumParser::SECOND_P: {
        enterOuterAlt(_localctx, 7);
        setState(6431);
        match(GreenPlumParser::SECOND_P);
        break;
      }

      case GreenPlumParser::DELIMITED_STR: {
        enterOuterAlt(_localctx, 8);
        setState(6432);
        match(GreenPlumParser::DELIMITED_STR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Overlay_listContext ------------------------------------------------------------------

GreenPlumParser::Overlay_listContext::Overlay_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Overlay_listContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

GreenPlumParser::Overlay_placingContext* GreenPlumParser::Overlay_listContext::overlay_placing() {
  return getRuleContext<GreenPlumParser::Overlay_placingContext>(0);
}

GreenPlumParser::Substr_fromContext* GreenPlumParser::Overlay_listContext::substr_from() {
  return getRuleContext<GreenPlumParser::Substr_fromContext>(0);
}

GreenPlumParser::Substr_forContext* GreenPlumParser::Overlay_listContext::substr_for() {
  return getRuleContext<GreenPlumParser::Substr_forContext>(0);
}


size_t GreenPlumParser::Overlay_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleOverlay_list;
}

void GreenPlumParser::Overlay_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverlay_list(this);
}

void GreenPlumParser::Overlay_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverlay_list(this);
}


antlrcpp::Any GreenPlumParser::Overlay_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOverlay_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Overlay_listContext* GreenPlumParser::overlay_list() {
  Overlay_listContext *_localctx = _tracker.createInstance<Overlay_listContext>(_ctx, getState());
  enterRule(_localctx, 964, GreenPlumParser::RuleOverlay_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6435);
    a_expr();
    setState(6436);
    overlay_placing();
    setState(6437);
    substr_from();
    setState(6439);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::FOR) {
      setState(6438);
      substr_for();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Overlay_placingContext ------------------------------------------------------------------

GreenPlumParser::Overlay_placingContext::Overlay_placingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Overlay_placingContext::PLACING() {
  return getToken(GreenPlumParser::PLACING, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Overlay_placingContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Overlay_placingContext::getRuleIndex() const {
  return GreenPlumParser::RuleOverlay_placing;
}

void GreenPlumParser::Overlay_placingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverlay_placing(this);
}

void GreenPlumParser::Overlay_placingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverlay_placing(this);
}


antlrcpp::Any GreenPlumParser::Overlay_placingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitOverlay_placing(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Overlay_placingContext* GreenPlumParser::overlay_placing() {
  Overlay_placingContext *_localctx = _tracker.createInstance<Overlay_placingContext>(_ctx, getState());
  enterRule(_localctx, 966, GreenPlumParser::RuleOverlay_placing);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6441);
    match(GreenPlumParser::PLACING);
    setState(6442);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Position_listContext ------------------------------------------------------------------

GreenPlumParser::Position_listContext::Position_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::A_exprContext *> GreenPlumParser::Position_listContext::a_expr() {
  return getRuleContexts<GreenPlumParser::A_exprContext>();
}

GreenPlumParser::A_exprContext* GreenPlumParser::Position_listContext::a_expr(size_t i) {
  return getRuleContext<GreenPlumParser::A_exprContext>(i);
}

tree::TerminalNode* GreenPlumParser::Position_listContext::IN_P() {
  return getToken(GreenPlumParser::IN_P, 0);
}


size_t GreenPlumParser::Position_listContext::getRuleIndex() const {
  return GreenPlumParser::RulePosition_list;
}

void GreenPlumParser::Position_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPosition_list(this);
}

void GreenPlumParser::Position_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPosition_list(this);
}


antlrcpp::Any GreenPlumParser::Position_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPosition_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Position_listContext* GreenPlumParser::position_list() {
  Position_listContext *_localctx = _tracker.createInstance<Position_listContext>(_ctx, getState());
  enterRule(_localctx, 968, GreenPlumParser::RulePosition_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6444);
    a_expr();
    setState(6445);
    match(GreenPlumParser::IN_P);
    setState(6446);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Substr_listContext ------------------------------------------------------------------

GreenPlumParser::Substr_listContext::Substr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Substr_listContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

GreenPlumParser::Substr_fromContext* GreenPlumParser::Substr_listContext::substr_from() {
  return getRuleContext<GreenPlumParser::Substr_fromContext>(0);
}

GreenPlumParser::Substr_forContext* GreenPlumParser::Substr_listContext::substr_for() {
  return getRuleContext<GreenPlumParser::Substr_forContext>(0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::Substr_listContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}


size_t GreenPlumParser::Substr_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleSubstr_list;
}

void GreenPlumParser::Substr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstr_list(this);
}

void GreenPlumParser::Substr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstr_list(this);
}


antlrcpp::Any GreenPlumParser::Substr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSubstr_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Substr_listContext* GreenPlumParser::substr_list() {
  Substr_listContext *_localctx = _tracker.createInstance<Substr_listContext>(_ctx, getState());
  enterRule(_localctx, 970, GreenPlumParser::RuleSubstr_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6463);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 704, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6448);
      a_expr();
      setState(6449);
      substr_from();
      setState(6450);
      substr_for();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6452);
      a_expr();
      setState(6453);
      substr_for();
      setState(6454);
      substr_from();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6456);
      a_expr();
      setState(6457);
      substr_from();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6459);
      a_expr();
      setState(6460);
      substr_for();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6462);
      expr_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Substr_fromContext ------------------------------------------------------------------

GreenPlumParser::Substr_fromContext::Substr_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Substr_fromContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Substr_fromContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Substr_fromContext::getRuleIndex() const {
  return GreenPlumParser::RuleSubstr_from;
}

void GreenPlumParser::Substr_fromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstr_from(this);
}

void GreenPlumParser::Substr_fromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstr_from(this);
}


antlrcpp::Any GreenPlumParser::Substr_fromContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSubstr_from(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Substr_fromContext* GreenPlumParser::substr_from() {
  Substr_fromContext *_localctx = _tracker.createInstance<Substr_fromContext>(_ctx, getState());
  enterRule(_localctx, 972, GreenPlumParser::RuleSubstr_from);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6465);
    match(GreenPlumParser::FROM);
    setState(6466);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Substr_forContext ------------------------------------------------------------------

GreenPlumParser::Substr_forContext::Substr_forContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Substr_forContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Substr_forContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Substr_forContext::getRuleIndex() const {
  return GreenPlumParser::RuleSubstr_for;
}

void GreenPlumParser::Substr_forContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstr_for(this);
}

void GreenPlumParser::Substr_forContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstr_for(this);
}


antlrcpp::Any GreenPlumParser::Substr_forContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSubstr_for(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Substr_forContext* GreenPlumParser::substr_for() {
  Substr_forContext *_localctx = _tracker.createInstance<Substr_forContext>(_ctx, getState());
  enterRule(_localctx, 974, GreenPlumParser::RuleSubstr_for);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6468);
    match(GreenPlumParser::FOR);
    setState(6469);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trim_listContext ------------------------------------------------------------------

GreenPlumParser::Trim_listContext::Trim_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Trim_listContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Trim_listContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

GreenPlumParser::Expr_listContext* GreenPlumParser::Trim_listContext::expr_list() {
  return getRuleContext<GreenPlumParser::Expr_listContext>(0);
}


size_t GreenPlumParser::Trim_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTrim_list;
}

void GreenPlumParser::Trim_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrim_list(this);
}

void GreenPlumParser::Trim_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrim_list(this);
}


antlrcpp::Any GreenPlumParser::Trim_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTrim_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Trim_listContext* GreenPlumParser::trim_list() {
  Trim_listContext *_localctx = _tracker.createInstance<Trim_listContext>(_ctx, getState());
  enterRule(_localctx, 976, GreenPlumParser::RuleTrim_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6478);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 705, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6471);
      a_expr();
      setState(6472);
      match(GreenPlumParser::FROM);
      setState(6473);
      expr_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6475);
      match(GreenPlumParser::FROM);
      setState(6476);
      expr_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6477);
      expr_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- In_exprContext ------------------------------------------------------------------

GreenPlumParser::In_exprContext::In_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Select_with_parensContext* GreenPlumParser::In_exprContext::select_with_parens() {
  return getRuleContext<GreenPlumParser::Select_with_parensContext>(0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::In_exprContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}


size_t GreenPlumParser::In_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleIn_expr;
}

void GreenPlumParser::In_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIn_expr(this);
}

void GreenPlumParser::In_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIn_expr(this);
}


antlrcpp::Any GreenPlumParser::In_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIn_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::In_exprContext* GreenPlumParser::in_expr() {
  In_exprContext *_localctx = _tracker.createInstance<In_exprContext>(_ctx, getState());
  enterRule(_localctx, 978, GreenPlumParser::RuleIn_expr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6482);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 706, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6480);
      select_with_parens();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6481);
      paren_expr_list();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_exprContext ------------------------------------------------------------------

GreenPlumParser::Case_exprContext::Case_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Case_exprContext::CASE() {
  return getToken(GreenPlumParser::CASE, 0);
}

tree::TerminalNode* GreenPlumParser::Case_exprContext::END_P() {
  return getToken(GreenPlumParser::END_P, 0);
}

GreenPlumParser::Case_argContext* GreenPlumParser::Case_exprContext::case_arg() {
  return getRuleContext<GreenPlumParser::Case_argContext>(0);
}

std::vector<GreenPlumParser::When_clauseContext *> GreenPlumParser::Case_exprContext::when_clause() {
  return getRuleContexts<GreenPlumParser::When_clauseContext>();
}

GreenPlumParser::When_clauseContext* GreenPlumParser::Case_exprContext::when_clause(size_t i) {
  return getRuleContext<GreenPlumParser::When_clauseContext>(i);
}

GreenPlumParser::Case_defaultContext* GreenPlumParser::Case_exprContext::case_default() {
  return getRuleContext<GreenPlumParser::Case_defaultContext>(0);
}


size_t GreenPlumParser::Case_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleCase_expr;
}

void GreenPlumParser::Case_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_expr(this);
}

void GreenPlumParser::Case_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_expr(this);
}


antlrcpp::Any GreenPlumParser::Case_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCase_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Case_exprContext* GreenPlumParser::case_expr() {
  Case_exprContext *_localctx = _tracker.createInstance<Case_exprContext>(_ctx, getState());
  enterRule(_localctx, 980, GreenPlumParser::RuleCase_expr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6484);
    match(GreenPlumParser::CASE);
    setState(6486);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ARRAY)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CASE)
      | (1ULL << GreenPlumParser::CAST)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTER)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHAR_P)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COALESCE)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CROSS - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_CATALOG - 64))
      | (1ULL << (GreenPlumParser::CURRENT_DATE - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURRENT_ROLE - 64))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 64))
      | (1ULL << (GreenPlumParser::CURRENT_TIME - 64))
      | (1ULL << (GreenPlumParser::CURRENT_TIMESTAMP - 64))
      | (1ULL << (GreenPlumParser::CURRENT_USER - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DEC - 64))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DECODE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXISTS - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::EXTRACT - 128))
      | (1ULL << (GreenPlumParser::FALSE_P - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FLOAT_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FULL - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::GREATEST - 128))
      | (1ULL << (GreenPlumParser::GROUP_ID - 128))
      | (1ULL << (GreenPlumParser::GROUPING - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::ILIKE - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128))
      | (1ULL << (GreenPlumParser::INNER_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INTEGER - 193))
      | (1ULL << (GreenPlumParser::INTERVAL - 193))
      | (1ULL << (GreenPlumParser::INT_P - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::IS - 193))
      | (1ULL << (GreenPlumParser::ISNULL - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::JOIN - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEAST - 193))
      | (1ULL << (GreenPlumParser::LEFT - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIKE - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCALTIME - 193))
      | (1ULL << (GreenPlumParser::LOCALTIMESTAMP - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::LOG_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEDIAN - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NATIONAL - 193))
      | (1ULL << (GreenPlumParser::NATURAL - 193))
      | (1ULL << (GreenPlumParser::NCHAR - 193))
      | (1ULL << (GreenPlumParser::NEW - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOT - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOTNULL - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLIF - 257))
      | (1ULL << (GreenPlumParser::NULL_P - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::NUMERIC - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OLD - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OUTER_P - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OVERLAPS - 257))
      | (1ULL << (GreenPlumParser::OVERLAY - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PERCENTILE_CONT - 257))
      | (1ULL << (GreenPlumParser::PERCENTILE_DISC - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::POSITION - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REAL - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::RIGHT - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SESSION_USER - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMILAR - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SMALLINT - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUBSTRING - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLE - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TIME - 385))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TREAT - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRIM - 385))
      | (1ULL << (GreenPlumParser::TRUE_P - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNIQUE - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::USER - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARCHAR - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERBOSE - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XMLCONCAT - 451))
      | (1ULL << (GreenPlumParser::XMLELEMENT - 451))
      | (1ULL << (GreenPlumParser::XMLEXISTS - 451))
      | (1ULL << (GreenPlumParser::XMLFOREST - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::XMLPARSE - 451))
      | (1ULL << (GreenPlumParser::XMLPI - 451))
      | (1ULL << (GreenPlumParser::XMLROOT - 451))
      | (1ULL << (GreenPlumParser::XMLSERIALIZE - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451))
      | (1ULL << (GreenPlumParser::LEFT_PAREN - 451))
      | (1ULL << (GreenPlumParser::PLUS_SIGN - 451))
      | (1ULL << (GreenPlumParser::MINUS_SIGN - 451))
      | (1ULL << (GreenPlumParser::COLON - 451))
      | (1ULL << (GreenPlumParser::CHAR_STRING - 451))
      | (1ULL << (GreenPlumParser::REGULAR_ID - 451))
      | (1ULL << (GreenPlumParser::DELIMITED_STR - 451))
      | (1ULL << (GreenPlumParser::SCONST - 451))
      | (1ULL << (GreenPlumParser::ICONST - 451))
      | (1ULL << (GreenPlumParser::FCONST - 451))
      | (1ULL << (GreenPlumParser::BCONST - 451))
      | (1ULL << (GreenPlumParser::XCONST - 451))
      | (1ULL << (GreenPlumParser::PARAM - 451)))) != 0)) {
      setState(6485);
      case_arg();
    }
    setState(6489); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(6488);
      when_clause();
      setState(6491); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == GreenPlumParser::WHEN);
    setState(6494);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::ELSE) {
      setState(6493);
      case_default();
    }
    setState(6496);
    match(GreenPlumParser::END_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_clauseContext ------------------------------------------------------------------

GreenPlumParser::When_clauseContext::When_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::When_clauseContext::WHEN() {
  return getToken(GreenPlumParser::WHEN, 0);
}

GreenPlumParser::When_operandContext* GreenPlumParser::When_clauseContext::when_operand() {
  return getRuleContext<GreenPlumParser::When_operandContext>(0);
}

tree::TerminalNode* GreenPlumParser::When_clauseContext::THEN() {
  return getToken(GreenPlumParser::THEN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::When_clauseContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::When_clauseContext::getRuleIndex() const {
  return GreenPlumParser::RuleWhen_clause;
}

void GreenPlumParser::When_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhen_clause(this);
}

void GreenPlumParser::When_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhen_clause(this);
}


antlrcpp::Any GreenPlumParser::When_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWhen_clause(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::When_clauseContext* GreenPlumParser::when_clause() {
  When_clauseContext *_localctx = _tracker.createInstance<When_clauseContext>(_ctx, getState());
  enterRule(_localctx, 982, GreenPlumParser::RuleWhen_clause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6498);
    match(GreenPlumParser::WHEN);
    setState(6499);
    when_operand();
    setState(6500);
    match(GreenPlumParser::THEN);
    setState(6501);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_operandContext ------------------------------------------------------------------

GreenPlumParser::When_operandContext::When_operandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::When_operandContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::When_operandContext::IS() {
  return getToken(GreenPlumParser::IS, 0);
}

tree::TerminalNode* GreenPlumParser::When_operandContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::When_operandContext::DISTINCT() {
  return getToken(GreenPlumParser::DISTINCT, 0);
}

tree::TerminalNode* GreenPlumParser::When_operandContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}


size_t GreenPlumParser::When_operandContext::getRuleIndex() const {
  return GreenPlumParser::RuleWhen_operand;
}

void GreenPlumParser::When_operandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhen_operand(this);
}

void GreenPlumParser::When_operandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhen_operand(this);
}


antlrcpp::Any GreenPlumParser::When_operandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitWhen_operand(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::When_operandContext* GreenPlumParser::when_operand() {
  When_operandContext *_localctx = _tracker.createInstance<When_operandContext>(_ctx, getState());
  enterRule(_localctx, 984, GreenPlumParser::RuleWhen_operand);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6509);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 710, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6503);
      a_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6504);
      match(GreenPlumParser::IS);
      setState(6505);
      match(GreenPlumParser::NOT);
      setState(6506);
      match(GreenPlumParser::DISTINCT);
      setState(6507);
      match(GreenPlumParser::FROM);
      setState(6508);
      a_expr();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_defaultContext ------------------------------------------------------------------

GreenPlumParser::Case_defaultContext::Case_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Case_defaultContext::ELSE() {
  return getToken(GreenPlumParser::ELSE, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Case_defaultContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Case_defaultContext::getRuleIndex() const {
  return GreenPlumParser::RuleCase_default;
}

void GreenPlumParser::Case_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_default(this);
}

void GreenPlumParser::Case_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_default(this);
}


antlrcpp::Any GreenPlumParser::Case_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCase_default(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Case_defaultContext* GreenPlumParser::case_default() {
  Case_defaultContext *_localctx = _tracker.createInstance<Case_defaultContext>(_ctx, getState());
  enterRule(_localctx, 986, GreenPlumParser::RuleCase_default);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6511);
    match(GreenPlumParser::ELSE);
    setState(6512);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_argContext ------------------------------------------------------------------

GreenPlumParser::Case_argContext::Case_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Case_argContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Case_argContext::getRuleIndex() const {
  return GreenPlumParser::RuleCase_arg;
}

void GreenPlumParser::Case_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_arg(this);
}

void GreenPlumParser::Case_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_arg(this);
}


antlrcpp::Any GreenPlumParser::Case_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCase_arg(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Case_argContext* GreenPlumParser::case_arg() {
  Case_argContext *_localctx = _tracker.createInstance<Case_argContext>(_ctx, getState());
  enterRule(_localctx, 988, GreenPlumParser::RuleCase_arg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6514);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decode_exprContext ------------------------------------------------------------------

GreenPlumParser::Decode_exprContext::Decode_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Decode_exprContext::DECODE() {
  return getToken(GreenPlumParser::DECODE, 0);
}

tree::TerminalNode* GreenPlumParser::Decode_exprContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Decode_exprContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Decode_exprContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}

std::vector<GreenPlumParser::Search_resultContext *> GreenPlumParser::Decode_exprContext::search_result() {
  return getRuleContexts<GreenPlumParser::Search_resultContext>();
}

GreenPlumParser::Search_resultContext* GreenPlumParser::Decode_exprContext::search_result(size_t i) {
  return getRuleContext<GreenPlumParser::Search_resultContext>(i);
}

GreenPlumParser::Decode_defaultContext* GreenPlumParser::Decode_exprContext::decode_default() {
  return getRuleContext<GreenPlumParser::Decode_defaultContext>(0);
}


size_t GreenPlumParser::Decode_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleDecode_expr;
}

void GreenPlumParser::Decode_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecode_expr(this);
}

void GreenPlumParser::Decode_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecode_expr(this);
}


antlrcpp::Any GreenPlumParser::Decode_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDecode_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Decode_exprContext* GreenPlumParser::decode_expr() {
  Decode_exprContext *_localctx = _tracker.createInstance<Decode_exprContext>(_ctx, getState());
  enterRule(_localctx, 990, GreenPlumParser::RuleDecode_expr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6516);
    match(GreenPlumParser::DECODE);
    setState(6517);
    match(GreenPlumParser::LEFT_PAREN);
    setState(6518);
    a_expr();
    setState(6520); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(6519);
              search_result();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(6522); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 711, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(6525);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::COMMA) {
      setState(6524);
      decode_default();
    }
    setState(6527);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_resultContext ------------------------------------------------------------------

GreenPlumParser::Search_resultContext::Search_resultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> GreenPlumParser::Search_resultContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Search_resultContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}

std::vector<GreenPlumParser::A_exprContext *> GreenPlumParser::Search_resultContext::a_expr() {
  return getRuleContexts<GreenPlumParser::A_exprContext>();
}

GreenPlumParser::A_exprContext* GreenPlumParser::Search_resultContext::a_expr(size_t i) {
  return getRuleContext<GreenPlumParser::A_exprContext>(i);
}


size_t GreenPlumParser::Search_resultContext::getRuleIndex() const {
  return GreenPlumParser::RuleSearch_result;
}

void GreenPlumParser::Search_resultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_result(this);
}

void GreenPlumParser::Search_resultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_result(this);
}


antlrcpp::Any GreenPlumParser::Search_resultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSearch_result(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Search_resultContext* GreenPlumParser::search_result() {
  Search_resultContext *_localctx = _tracker.createInstance<Search_resultContext>(_ctx, getState());
  enterRule(_localctx, 992, GreenPlumParser::RuleSearch_result);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6529);
    match(GreenPlumParser::COMMA);
    setState(6530);
    a_expr();
    setState(6531);
    match(GreenPlumParser::COMMA);
    setState(6532);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decode_defaultContext ------------------------------------------------------------------

GreenPlumParser::Decode_defaultContext::Decode_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Decode_defaultContext::COMMA() {
  return getToken(GreenPlumParser::COMMA, 0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Decode_defaultContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}


size_t GreenPlumParser::Decode_defaultContext::getRuleIndex() const {
  return GreenPlumParser::RuleDecode_default;
}

void GreenPlumParser::Decode_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecode_default(this);
}

void GreenPlumParser::Decode_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecode_default(this);
}


antlrcpp::Any GreenPlumParser::Decode_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDecode_default(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Decode_defaultContext* GreenPlumParser::decode_default() {
  Decode_defaultContext *_localctx = _tracker.createInstance<Decode_defaultContext>(_ctx, getState());
  enterRule(_localctx, 994, GreenPlumParser::RuleDecode_default);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6534);
    match(GreenPlumParser::COMMA);
    setState(6535);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnrefContext ------------------------------------------------------------------

GreenPlumParser::ColumnrefContext::ColumnrefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Relation_nameContext* GreenPlumParser::ColumnrefContext::relation_name() {
  return getRuleContext<GreenPlumParser::Relation_nameContext>(0);
}

GreenPlumParser::IndirectionContext* GreenPlumParser::ColumnrefContext::indirection() {
  return getRuleContext<GreenPlumParser::IndirectionContext>(0);
}


size_t GreenPlumParser::ColumnrefContext::getRuleIndex() const {
  return GreenPlumParser::RuleColumnref;
}

void GreenPlumParser::ColumnrefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnref(this);
}

void GreenPlumParser::ColumnrefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnref(this);
}


antlrcpp::Any GreenPlumParser::ColumnrefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitColumnref(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::ColumnrefContext* GreenPlumParser::columnref() {
  ColumnrefContext *_localctx = _tracker.createInstance<ColumnrefContext>(_ctx, getState());
  enterRule(_localctx, 996, GreenPlumParser::RuleColumnref);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6537);
    relation_name();
    setState(6539);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 713, _ctx)) {
    case 1: {
      setState(6538);
      indirection();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indirection_elContext ------------------------------------------------------------------

GreenPlumParser::Indirection_elContext::Indirection_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Indirection_elContext::PERIOD() {
  return getToken(GreenPlumParser::PERIOD, 0);
}

GreenPlumParser::Attr_nameContext* GreenPlumParser::Indirection_elContext::attr_name() {
  return getRuleContext<GreenPlumParser::Attr_nameContext>(0);
}

tree::TerminalNode* GreenPlumParser::Indirection_elContext::ASTERISK() {
  return getToken(GreenPlumParser::ASTERISK, 0);
}

tree::TerminalNode* GreenPlumParser::Indirection_elContext::LEFT_BRACKET() {
  return getToken(GreenPlumParser::LEFT_BRACKET, 0);
}

std::vector<GreenPlumParser::A_exprContext *> GreenPlumParser::Indirection_elContext::a_expr() {
  return getRuleContexts<GreenPlumParser::A_exprContext>();
}

GreenPlumParser::A_exprContext* GreenPlumParser::Indirection_elContext::a_expr(size_t i) {
  return getRuleContext<GreenPlumParser::A_exprContext>(i);
}

tree::TerminalNode* GreenPlumParser::Indirection_elContext::RIGHT_BRACKET() {
  return getToken(GreenPlumParser::RIGHT_BRACKET, 0);
}

tree::TerminalNode* GreenPlumParser::Indirection_elContext::SEMICOLON() {
  return getToken(GreenPlumParser::SEMICOLON, 0);
}


size_t GreenPlumParser::Indirection_elContext::getRuleIndex() const {
  return GreenPlumParser::RuleIndirection_el;
}

void GreenPlumParser::Indirection_elContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndirection_el(this);
}

void GreenPlumParser::Indirection_elContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndirection_el(this);
}


antlrcpp::Any GreenPlumParser::Indirection_elContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIndirection_el(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Indirection_elContext* GreenPlumParser::indirection_el() {
  Indirection_elContext *_localctx = _tracker.createInstance<Indirection_elContext>(_ctx, getState());
  enterRule(_localctx, 998, GreenPlumParser::RuleIndirection_el);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6555);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 714, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6541);
      match(GreenPlumParser::PERIOD);
      setState(6542);
      attr_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6543);
      match(GreenPlumParser::PERIOD);
      setState(6544);
      match(GreenPlumParser::ASTERISK);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6545);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(6546);
      a_expr();
      setState(6547);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6549);
      match(GreenPlumParser::LEFT_BRACKET);
      setState(6550);
      a_expr();
      setState(6551);
      match(GreenPlumParser::SEMICOLON);
      setState(6552);
      a_expr();
      setState(6553);
      match(GreenPlumParser::RIGHT_BRACKET);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndirectionContext ------------------------------------------------------------------

GreenPlumParser::IndirectionContext::IndirectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Indirection_elContext *> GreenPlumParser::IndirectionContext::indirection_el() {
  return getRuleContexts<GreenPlumParser::Indirection_elContext>();
}

GreenPlumParser::Indirection_elContext* GreenPlumParser::IndirectionContext::indirection_el(size_t i) {
  return getRuleContext<GreenPlumParser::Indirection_elContext>(i);
}


size_t GreenPlumParser::IndirectionContext::getRuleIndex() const {
  return GreenPlumParser::RuleIndirection;
}

void GreenPlumParser::IndirectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndirection(this);
}

void GreenPlumParser::IndirectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndirection(this);
}


antlrcpp::Any GreenPlumParser::IndirectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIndirection(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::IndirectionContext* GreenPlumParser::indirection() {
  IndirectionContext *_localctx = _tracker.createInstance<IndirectionContext>(_ctx, getState());
  enterRule(_localctx, 1000, GreenPlumParser::RuleIndirection);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6558); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(6557);
              indirection_el();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(6560); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 715, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ctext_exprContext ------------------------------------------------------------------

GreenPlumParser::Ctext_exprContext::Ctext_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::A_exprContext* GreenPlumParser::Ctext_exprContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

tree::TerminalNode* GreenPlumParser::Ctext_exprContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}


size_t GreenPlumParser::Ctext_exprContext::getRuleIndex() const {
  return GreenPlumParser::RuleCtext_expr;
}

void GreenPlumParser::Ctext_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCtext_expr(this);
}

void GreenPlumParser::Ctext_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCtext_expr(this);
}


antlrcpp::Any GreenPlumParser::Ctext_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCtext_expr(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ctext_exprContext* GreenPlumParser::ctext_expr() {
  Ctext_exprContext *_localctx = _tracker.createInstance<Ctext_exprContext>(_ctx, getState());
  enterRule(_localctx, 1002, GreenPlumParser::RuleCtext_expr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6564);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ARRAY:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CASE:
      case GreenPlumParser::CAST:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_CATALOG:
      case GreenPlumParser::CURRENT_DATE:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_ROLE:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURRENT_TIME:
      case GreenPlumParser::CURRENT_TIMESTAMP:
      case GreenPlumParser::CURRENT_USER:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DECODE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCALTIME:
      case GreenPlumParser::LOCALTIMESTAMP:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEDIAN:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOT:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PERCENTILE_CONT:
      case GreenPlumParser::PERCENTILE_DISC:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SESSION_USER:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLE:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNIQUE:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::USER:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XMLCONCAT:
      case GreenPlumParser::XMLELEMENT:
      case GreenPlumParser::XMLEXISTS:
      case GreenPlumParser::XMLFOREST:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::XMLPARSE:
      case GreenPlumParser::XMLPI:
      case GreenPlumParser::XMLROOT:
      case GreenPlumParser::XMLSERIALIZE:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::LEFT_PAREN:
      case GreenPlumParser::PLUS_SIGN:
      case GreenPlumParser::MINUS_SIGN:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST:
      case GreenPlumParser::BCONST:
      case GreenPlumParser::XCONST:
      case GreenPlumParser::PARAM: {
        enterOuterAlt(_localctx, 1);
        setState(6562);
        a_expr();
        break;
      }

      case GreenPlumParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(6563);
        match(GreenPlumParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ctext_expr_listContext ------------------------------------------------------------------

GreenPlumParser::Ctext_expr_listContext::Ctext_expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Ctext_exprContext *> GreenPlumParser::Ctext_expr_listContext::ctext_expr() {
  return getRuleContexts<GreenPlumParser::Ctext_exprContext>();
}

GreenPlumParser::Ctext_exprContext* GreenPlumParser::Ctext_expr_listContext::ctext_expr(size_t i) {
  return getRuleContext<GreenPlumParser::Ctext_exprContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Ctext_expr_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Ctext_expr_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Ctext_expr_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleCtext_expr_list;
}

void GreenPlumParser::Ctext_expr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCtext_expr_list(this);
}

void GreenPlumParser::Ctext_expr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCtext_expr_list(this);
}


antlrcpp::Any GreenPlumParser::Ctext_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCtext_expr_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ctext_expr_listContext* GreenPlumParser::ctext_expr_list() {
  Ctext_expr_listContext *_localctx = _tracker.createInstance<Ctext_expr_listContext>(_ctx, getState());
  enterRule(_localctx, 1004, GreenPlumParser::RuleCtext_expr_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6566);
    ctext_expr();
    setState(6571);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(6567);
      match(GreenPlumParser::COMMA);
      setState(6568);
      ctext_expr();
      setState(6573);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ctext_rowContext ------------------------------------------------------------------

GreenPlumParser::Ctext_rowContext::Ctext_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Ctext_rowContext::LEFT_PAREN() {
  return getToken(GreenPlumParser::LEFT_PAREN, 0);
}

GreenPlumParser::Ctext_expr_listContext* GreenPlumParser::Ctext_rowContext::ctext_expr_list() {
  return getRuleContext<GreenPlumParser::Ctext_expr_listContext>(0);
}

tree::TerminalNode* GreenPlumParser::Ctext_rowContext::RIGHT_PAREN() {
  return getToken(GreenPlumParser::RIGHT_PAREN, 0);
}


size_t GreenPlumParser::Ctext_rowContext::getRuleIndex() const {
  return GreenPlumParser::RuleCtext_row;
}

void GreenPlumParser::Ctext_rowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCtext_row(this);
}

void GreenPlumParser::Ctext_rowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCtext_row(this);
}


antlrcpp::Any GreenPlumParser::Ctext_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCtext_row(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Ctext_rowContext* GreenPlumParser::ctext_row() {
  Ctext_rowContext *_localctx = _tracker.createInstance<Ctext_rowContext>(_ctx, getState());
  enterRule(_localctx, 1006, GreenPlumParser::RuleCtext_row);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6574);
    match(GreenPlumParser::LEFT_PAREN);
    setState(6575);
    ctext_expr_list();
    setState(6576);
    match(GreenPlumParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Target_listContext ------------------------------------------------------------------

GreenPlumParser::Target_listContext::Target_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Target_elContext *> GreenPlumParser::Target_listContext::target_el() {
  return getRuleContexts<GreenPlumParser::Target_elContext>();
}

GreenPlumParser::Target_elContext* GreenPlumParser::Target_listContext::target_el(size_t i) {
  return getRuleContext<GreenPlumParser::Target_elContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Target_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Target_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Target_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleTarget_list;
}

void GreenPlumParser::Target_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTarget_list(this);
}

void GreenPlumParser::Target_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTarget_list(this);
}


antlrcpp::Any GreenPlumParser::Target_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTarget_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Target_listContext* GreenPlumParser::target_list() {
  Target_listContext *_localctx = _tracker.createInstance<Target_listContext>(_ctx, getState());
  enterRule(_localctx, 1008, GreenPlumParser::RuleTarget_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6578);
    target_el();
    setState(6583);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 718, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6579);
        match(GreenPlumParser::COMMA);
        setState(6580);
        target_el(); 
      }
      setState(6585);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 718, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Target_elContext ------------------------------------------------------------------

GreenPlumParser::Target_elContext::Target_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t GreenPlumParser::Target_elContext::getRuleIndex() const {
  return GreenPlumParser::RuleTarget_el;
}

void GreenPlumParser::Target_elContext::copyFrom(Target_elContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Target_el_normalContext ------------------------------------------------------------------

GreenPlumParser::ColumnrefContext* GreenPlumParser::Target_el_normalContext::columnref() {
  return getRuleContext<GreenPlumParser::ColumnrefContext>(0);
}

GreenPlumParser::A_exprContext* GreenPlumParser::Target_el_normalContext::a_expr() {
  return getRuleContext<GreenPlumParser::A_exprContext>(0);
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Target_el_normalContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}

tree::TerminalNode* GreenPlumParser::Target_el_normalContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

GreenPlumParser::Target_el_normalContext::Target_el_normalContext(Target_elContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Target_el_normalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTarget_el_normal(this);
}
void GreenPlumParser::Target_el_normalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTarget_el_normal(this);
}

antlrcpp::Any GreenPlumParser::Target_el_normalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTarget_el_normal(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Target_el_asteriskContext ------------------------------------------------------------------

tree::TerminalNode* GreenPlumParser::Target_el_asteriskContext::ASTERISK() {
  return getToken(GreenPlumParser::ASTERISK, 0);
}

GreenPlumParser::Target_el_asteriskContext::Target_el_asteriskContext(Target_elContext *ctx) { copyFrom(ctx); }

void GreenPlumParser::Target_el_asteriskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTarget_el_asterisk(this);
}
void GreenPlumParser::Target_el_asteriskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTarget_el_asterisk(this);
}

antlrcpp::Any GreenPlumParser::Target_el_asteriskContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitTarget_el_asterisk(this);
  else
    return visitor->visitChildren(this);
}
GreenPlumParser::Target_elContext* GreenPlumParser::target_el() {
  Target_elContext *_localctx = _tracker.createInstance<Target_elContext>(_ctx, getState());
  enterRule(_localctx, 1010, GreenPlumParser::RuleTarget_el);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6597);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ARRAY:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CASE:
      case GreenPlumParser::CAST:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_CATALOG:
      case GreenPlumParser::CURRENT_DATE:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURRENT_ROLE:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::CURRENT_TIME:
      case GreenPlumParser::CURRENT_TIMESTAMP:
      case GreenPlumParser::CURRENT_USER:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DECODE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCALTIME:
      case GreenPlumParser::LOCALTIMESTAMP:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEDIAN:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOT:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OLD:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PERCENTILE_CONT:
      case GreenPlumParser::PERCENTILE_DISC:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SESSION_USER:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLE:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNIQUE:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::USER:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XMLCONCAT:
      case GreenPlumParser::XMLELEMENT:
      case GreenPlumParser::XMLEXISTS:
      case GreenPlumParser::XMLFOREST:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::XMLPARSE:
      case GreenPlumParser::XMLPI:
      case GreenPlumParser::XMLROOT:
      case GreenPlumParser::XMLSERIALIZE:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::LEFT_PAREN:
      case GreenPlumParser::PLUS_SIGN:
      case GreenPlumParser::MINUS_SIGN:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::DELIMITED_STR:
      case GreenPlumParser::SCONST:
      case GreenPlumParser::ICONST:
      case GreenPlumParser::FCONST:
      case GreenPlumParser::BCONST:
      case GreenPlumParser::XCONST:
      case GreenPlumParser::PARAM: {
        _localctx = dynamic_cast<Target_elContext *>(_tracker.createInstance<GreenPlumParser::Target_el_normalContext>(_localctx));
        enterOuterAlt(_localctx, 1);
        setState(6588);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 719, _ctx)) {
        case 1: {
          setState(6586);
          columnref();
          break;
        }

        case 2: {
          setState(6587);
          a_expr();
          break;
        }

        }
        setState(6594);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 721, _ctx)) {
        case 1: {
          setState(6591);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 720, _ctx)) {
          case 1: {
            setState(6590);
            match(GreenPlumParser::AS);
            break;
          }

          }
          setState(6593);
          col_label();
          break;
        }

        }
        break;
      }

      case GreenPlumParser::ASTERISK: {
        _localctx = dynamic_cast<Target_elContext *>(_tracker.createInstance<GreenPlumParser::Target_el_asteriskContext>(_localctx));
        enterOuterAlt(_localctx, 2);
        setState(6596);
        match(GreenPlumParser::ASTERISK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_nameContext ------------------------------------------------------------------

GreenPlumParser::Relation_nameContext::Relation_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Special_rule_relationContext* GreenPlumParser::Relation_nameContext::special_rule_relation() {
  return getRuleContext<GreenPlumParser::Special_rule_relationContext>(0);
}

GreenPlumParser::ColidContext* GreenPlumParser::Relation_nameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Relation_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleRelation_name;
}

void GreenPlumParser::Relation_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelation_name(this);
}

void GreenPlumParser::Relation_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelation_name(this);
}


antlrcpp::Any GreenPlumParser::Relation_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRelation_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Relation_nameContext* GreenPlumParser::relation_name() {
  Relation_nameContext *_localctx = _tracker.createInstance<Relation_nameContext>(_ctx, getState());
  enterRule(_localctx, 1012, GreenPlumParser::RuleRelation_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6601);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::NEW:
      case GreenPlumParser::OLD: {
        enterOuterAlt(_localctx, 1);
        setState(6599);
        special_rule_relation();
        break;
      }

      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE:
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID:
      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 2);
        setState(6600);
        colid();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_name_listContext ------------------------------------------------------------------

GreenPlumParser::Qualified_name_listContext::Qualified_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::Qualified_nameContext *> GreenPlumParser::Qualified_name_listContext::qualified_name() {
  return getRuleContexts<GreenPlumParser::Qualified_nameContext>();
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::Qualified_name_listContext::qualified_name(size_t i) {
  return getRuleContext<GreenPlumParser::Qualified_nameContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Qualified_name_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Qualified_name_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Qualified_name_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleQualified_name_list;
}

void GreenPlumParser::Qualified_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualified_name_list(this);
}

void GreenPlumParser::Qualified_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualified_name_list(this);
}


antlrcpp::Any GreenPlumParser::Qualified_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitQualified_name_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Qualified_name_listContext* GreenPlumParser::qualified_name_list() {
  Qualified_name_listContext *_localctx = _tracker.createInstance<Qualified_name_listContext>(_ctx, getState());
  enterRule(_localctx, 1014, GreenPlumParser::RuleQualified_name_list);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6603);
    qualified_name();
    setState(6608);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GreenPlumParser::COMMA) {
      setState(6604);
      match(GreenPlumParser::COMMA);
      setState(6605);
      qualified_name();
      setState(6610);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_nameContext ------------------------------------------------------------------

GreenPlumParser::Qualified_nameContext::Qualified_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Relation_nameContext* GreenPlumParser::Qualified_nameContext::relation_name() {
  return getRuleContext<GreenPlumParser::Relation_nameContext>(0);
}

GreenPlumParser::IndirectionContext* GreenPlumParser::Qualified_nameContext::indirection() {
  return getRuleContext<GreenPlumParser::IndirectionContext>(0);
}


size_t GreenPlumParser::Qualified_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleQualified_name;
}

void GreenPlumParser::Qualified_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualified_name(this);
}

void GreenPlumParser::Qualified_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualified_name(this);
}


antlrcpp::Any GreenPlumParser::Qualified_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitQualified_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Qualified_nameContext* GreenPlumParser::qualified_name() {
  Qualified_nameContext *_localctx = _tracker.createInstance<Qualified_nameContext>(_ctx, getState());
  enterRule(_localctx, 1016, GreenPlumParser::RuleQualified_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6611);
    relation_name();
    setState(6613);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 725, _ctx)) {
    case 1: {
      setState(6612);
      indirection();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_listContext ------------------------------------------------------------------

GreenPlumParser::Name_listContext::Name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GreenPlumParser::NameContext *> GreenPlumParser::Name_listContext::name() {
  return getRuleContexts<GreenPlumParser::NameContext>();
}

GreenPlumParser::NameContext* GreenPlumParser::Name_listContext::name(size_t i) {
  return getRuleContext<GreenPlumParser::NameContext>(i);
}

std::vector<tree::TerminalNode *> GreenPlumParser::Name_listContext::COMMA() {
  return getTokens(GreenPlumParser::COMMA);
}

tree::TerminalNode* GreenPlumParser::Name_listContext::COMMA(size_t i) {
  return getToken(GreenPlumParser::COMMA, i);
}


size_t GreenPlumParser::Name_listContext::getRuleIndex() const {
  return GreenPlumParser::RuleName_list;
}

void GreenPlumParser::Name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_list(this);
}

void GreenPlumParser::Name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_list(this);
}


antlrcpp::Any GreenPlumParser::Name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitName_list(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Name_listContext* GreenPlumParser::name_list() {
  Name_listContext *_localctx = _tracker.createInstance<Name_listContext>(_ctx, getState());
  enterRule(_localctx, 1018, GreenPlumParser::RuleName_list);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6615);
    name();
    setState(6620);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 726, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6616);
        match(GreenPlumParser::COMMA);
        setState(6617);
        name(); 
      }
      setState(6622);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 726, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

GreenPlumParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::NameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::NameContext::getRuleIndex() const {
  return GreenPlumParser::RuleName;
}

void GreenPlumParser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void GreenPlumParser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


antlrcpp::Any GreenPlumParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::NameContext* GreenPlumParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 1020, GreenPlumParser::RuleName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6623);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_nameContext ------------------------------------------------------------------

GreenPlumParser::Cte_nameContext::Cte_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Cte_nameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Cte_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleCte_name;
}

void GreenPlumParser::Cte_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_name(this);
}

void GreenPlumParser::Cte_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_name(this);
}


antlrcpp::Any GreenPlumParser::Cte_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCte_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Cte_nameContext* GreenPlumParser::cte_name() {
  Cte_nameContext *_localctx = _tracker.createInstance<Cte_nameContext>(_ctx, getState());
  enterRule(_localctx, 1022, GreenPlumParser::RuleCte_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6625);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Database_nameContext ------------------------------------------------------------------

GreenPlumParser::Database_nameContext::Database_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Database_nameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Database_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleDatabase_name;
}

void GreenPlumParser::Database_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatabase_name(this);
}

void GreenPlumParser::Database_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatabase_name(this);
}


antlrcpp::Any GreenPlumParser::Database_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitDatabase_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Database_nameContext* GreenPlumParser::database_name() {
  Database_nameContext *_localctx = _tracker.createInstance<Database_nameContext>(_ctx, getState());
  enterRule(_localctx, 1024, GreenPlumParser::RuleDatabase_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6627);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Access_methodContext ------------------------------------------------------------------

GreenPlumParser::Access_methodContext::Access_methodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Access_methodContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Access_methodContext::getRuleIndex() const {
  return GreenPlumParser::RuleAccess_method;
}

void GreenPlumParser::Access_methodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccess_method(this);
}

void GreenPlumParser::Access_methodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccess_method(this);
}


antlrcpp::Any GreenPlumParser::Access_methodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAccess_method(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Access_methodContext* GreenPlumParser::access_method() {
  Access_methodContext *_localctx = _tracker.createInstance<Access_methodContext>(_ctx, getState());
  enterRule(_localctx, 1026, GreenPlumParser::RuleAccess_method);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6629);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_nameContext ------------------------------------------------------------------

GreenPlumParser::Attr_nameContext::Attr_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Col_labelContext* GreenPlumParser::Attr_nameContext::col_label() {
  return getRuleContext<GreenPlumParser::Col_labelContext>(0);
}


size_t GreenPlumParser::Attr_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleAttr_name;
}

void GreenPlumParser::Attr_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttr_name(this);
}

void GreenPlumParser::Attr_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttr_name(this);
}


antlrcpp::Any GreenPlumParser::Attr_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitAttr_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Attr_nameContext* GreenPlumParser::attr_name() {
  Attr_nameContext *_localctx = _tracker.createInstance<Attr_nameContext>(_ctx, getState());
  enterRule(_localctx, 1028, GreenPlumParser::RuleAttr_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6631);
    col_label();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_nameContext ------------------------------------------------------------------

GreenPlumParser::Index_nameContext::Index_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Index_nameContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Index_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleIndex_name;
}

void GreenPlumParser::Index_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_name(this);
}

void GreenPlumParser::Index_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_name(this);
}


antlrcpp::Any GreenPlumParser::Index_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIndex_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Index_nameContext* GreenPlumParser::index_name() {
  Index_nameContext *_localctx = _tracker.createInstance<Index_nameContext>(_ctx, getState());
  enterRule(_localctx, 1030, GreenPlumParser::RuleIndex_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6633);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_nameContext ------------------------------------------------------------------

GreenPlumParser::File_nameContext::File_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::SconstContext* GreenPlumParser::File_nameContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}


size_t GreenPlumParser::File_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleFile_name;
}

void GreenPlumParser::File_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_name(this);
}

void GreenPlumParser::File_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_name(this);
}


antlrcpp::Any GreenPlumParser::File_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFile_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::File_nameContext* GreenPlumParser::file_name() {
  File_nameContext *_localctx = _tracker.createInstance<File_nameContext>(_ctx, getState());
  enterRule(_localctx, 1032, GreenPlumParser::RuleFile_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6635);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_nameContext ------------------------------------------------------------------

GreenPlumParser::Func_nameContext::Func_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Type_function_nameContext* GreenPlumParser::Func_nameContext::type_function_name() {
  return getRuleContext<GreenPlumParser::Type_function_nameContext>(0);
}

GreenPlumParser::Relation_nameContext* GreenPlumParser::Func_nameContext::relation_name() {
  return getRuleContext<GreenPlumParser::Relation_nameContext>(0);
}

GreenPlumParser::IndirectionContext* GreenPlumParser::Func_nameContext::indirection() {
  return getRuleContext<GreenPlumParser::IndirectionContext>(0);
}


size_t GreenPlumParser::Func_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleFunc_name;
}

void GreenPlumParser::Func_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_name(this);
}

void GreenPlumParser::Func_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_name(this);
}


antlrcpp::Any GreenPlumParser::Func_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitFunc_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::func_name() {
  Func_nameContext *_localctx = _tracker.createInstance<Func_nameContext>(_ctx, getState());
  enterRule(_localctx, 1034, GreenPlumParser::RuleFunc_name);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6642);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 728, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6637);
      type_function_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6638);
      relation_name();
      setState(6640);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::PERIOD

      || _la == GreenPlumParser::LEFT_BRACKET) {
        setState(6639);
        indirection();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_constContext ------------------------------------------------------------------

GreenPlumParser::A_expr_constContext::A_expr_constContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IconstContext* GreenPlumParser::A_expr_constContext::iconst() {
  return getRuleContext<GreenPlumParser::IconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::A_expr_constContext::FCONST() {
  return getToken(GreenPlumParser::FCONST, 0);
}

GreenPlumParser::SconstContext* GreenPlumParser::A_expr_constContext::sconst() {
  return getRuleContext<GreenPlumParser::SconstContext>(0);
}

tree::TerminalNode* GreenPlumParser::A_expr_constContext::BCONST() {
  return getToken(GreenPlumParser::BCONST, 0);
}

tree::TerminalNode* GreenPlumParser::A_expr_constContext::XCONST() {
  return getToken(GreenPlumParser::XCONST, 0);
}

GreenPlumParser::Func_nameContext* GreenPlumParser::A_expr_constContext::func_name() {
  return getRuleContext<GreenPlumParser::Func_nameContext>(0);
}

GreenPlumParser::Paren_expr_listContext* GreenPlumParser::A_expr_constContext::paren_expr_list() {
  return getRuleContext<GreenPlumParser::Paren_expr_listContext>(0);
}

GreenPlumParser::Const_typenameContext* GreenPlumParser::A_expr_constContext::const_typename() {
  return getRuleContext<GreenPlumParser::Const_typenameContext>(0);
}

GreenPlumParser::Const_intervalContext* GreenPlumParser::A_expr_constContext::const_interval() {
  return getRuleContext<GreenPlumParser::Const_intervalContext>(0);
}

GreenPlumParser::Paren_iconstContext* GreenPlumParser::A_expr_constContext::paren_iconst() {
  return getRuleContext<GreenPlumParser::Paren_iconstContext>(0);
}

GreenPlumParser::Opt_intervalContext* GreenPlumParser::A_expr_constContext::opt_interval() {
  return getRuleContext<GreenPlumParser::Opt_intervalContext>(0);
}

tree::TerminalNode* GreenPlumParser::A_expr_constContext::TRUE_P() {
  return getToken(GreenPlumParser::TRUE_P, 0);
}

tree::TerminalNode* GreenPlumParser::A_expr_constContext::FALSE_P() {
  return getToken(GreenPlumParser::FALSE_P, 0);
}

tree::TerminalNode* GreenPlumParser::A_expr_constContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}


size_t GreenPlumParser::A_expr_constContext::getRuleIndex() const {
  return GreenPlumParser::RuleA_expr_const;
}

void GreenPlumParser::A_expr_constContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterA_expr_const(this);
}

void GreenPlumParser::A_expr_constContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitA_expr_const(this);
}


antlrcpp::Any GreenPlumParser::A_expr_constContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_const(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::A_expr_constContext* GreenPlumParser::a_expr_const() {
  A_expr_constContext *_localctx = _tracker.createInstance<A_expr_constContext>(_ctx, getState());
  enterRule(_localctx, 1036, GreenPlumParser::RuleA_expr_const);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6669);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 732, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6644);
      iconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6645);
      match(GreenPlumParser::FCONST);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6646);
      sconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6647);
      match(GreenPlumParser::BCONST);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6648);
      match(GreenPlumParser::XCONST);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6649);
      func_name();
      setState(6651);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(6650);
        paren_expr_list();
      }
      setState(6653);
      sconst();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6655);
      const_typename();
      setState(6656);
      sconst();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6658);
      const_interval();
      setState(6660);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GreenPlumParser::LEFT_PAREN) {
        setState(6659);
        paren_iconst();
      }
      setState(6662);
      sconst();
      setState(6664);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 731, _ctx)) {
      case 1: {
        setState(6663);
        opt_interval();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6666);
      match(GreenPlumParser::TRUE_P);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6667);
      match(GreenPlumParser::FALSE_P);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6668);
      match(GreenPlumParser::NULL_P);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IconstContext ------------------------------------------------------------------

GreenPlumParser::IconstContext::IconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::IconstContext::ICONST() {
  return getToken(GreenPlumParser::ICONST, 0);
}


size_t GreenPlumParser::IconstContext::getRuleIndex() const {
  return GreenPlumParser::RuleIconst;
}

void GreenPlumParser::IconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIconst(this);
}

void GreenPlumParser::IconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIconst(this);
}


antlrcpp::Any GreenPlumParser::IconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIconst(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::IconstContext* GreenPlumParser::iconst() {
  IconstContext *_localctx = _tracker.createInstance<IconstContext>(_ctx, getState());
  enterRule(_localctx, 1038, GreenPlumParser::RuleIconst);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6671);
    match(GreenPlumParser::ICONST);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SconstContext ------------------------------------------------------------------

GreenPlumParser::SconstContext::SconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::SconstContext::SCONST() {
  return getToken(GreenPlumParser::SCONST, 0);
}

tree::TerminalNode* GreenPlumParser::SconstContext::DELIMITED_STR() {
  return getToken(GreenPlumParser::DELIMITED_STR, 0);
}

tree::TerminalNode* GreenPlumParser::SconstContext::CHAR_STRING() {
  return getToken(GreenPlumParser::CHAR_STRING, 0);
}


size_t GreenPlumParser::SconstContext::getRuleIndex() const {
  return GreenPlumParser::RuleSconst;
}

void GreenPlumParser::SconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSconst(this);
}

void GreenPlumParser::SconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSconst(this);
}


antlrcpp::Any GreenPlumParser::SconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSconst(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::SconstContext* GreenPlumParser::sconst() {
  SconstContext *_localctx = _tracker.createInstance<SconstContext>(_ctx, getState());
  enterRule(_localctx, 1040, GreenPlumParser::RuleSconst);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6673);
    _la = _input->LA(1);
    if (!(((((_la - 501) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 501)) & ((1ULL << (GreenPlumParser::CHAR_STRING - 501))
      | (1ULL << (GreenPlumParser::DELIMITED_STR - 501))
      | (1ULL << (GreenPlumParser::SCONST - 501)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Role_idContext ------------------------------------------------------------------

GreenPlumParser::Role_idContext::Role_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Role_idContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Role_idContext::getRuleIndex() const {
  return GreenPlumParser::RuleRole_id;
}

void GreenPlumParser::Role_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRole_id(this);
}

void GreenPlumParser::Role_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRole_id(this);
}


antlrcpp::Any GreenPlumParser::Role_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitRole_id(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Role_idContext* GreenPlumParser::role_id() {
  Role_idContext *_localctx = _tracker.createInstance<Role_idContext>(_ctx, getState());
  enterRule(_localctx, 1042, GreenPlumParser::RuleRole_id);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6675);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Queue_idContext ------------------------------------------------------------------

GreenPlumParser::Queue_idContext::Queue_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::ColidContext* GreenPlumParser::Queue_idContext::colid() {
  return getRuleContext<GreenPlumParser::ColidContext>(0);
}


size_t GreenPlumParser::Queue_idContext::getRuleIndex() const {
  return GreenPlumParser::RuleQueue_id;
}

void GreenPlumParser::Queue_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueue_id(this);
}

void GreenPlumParser::Queue_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueue_id(this);
}


antlrcpp::Any GreenPlumParser::Queue_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitQueue_id(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Queue_idContext* GreenPlumParser::queue_id() {
  Queue_idContext *_localctx = _tracker.createInstance<Queue_idContext>(_ctx, getState());
  enterRule(_localctx, 1044, GreenPlumParser::RuleQueue_id);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6677);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signed_iconstContext ------------------------------------------------------------------

GreenPlumParser::Signed_iconstContext::Signed_iconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Signed_iconstContext::ICONST() {
  return getToken(GreenPlumParser::ICONST, 0);
}

tree::TerminalNode* GreenPlumParser::Signed_iconstContext::PLUS_SIGN() {
  return getToken(GreenPlumParser::PLUS_SIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Signed_iconstContext::MINUS_SIGN() {
  return getToken(GreenPlumParser::MINUS_SIGN, 0);
}


size_t GreenPlumParser::Signed_iconstContext::getRuleIndex() const {
  return GreenPlumParser::RuleSigned_iconst;
}

void GreenPlumParser::Signed_iconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigned_iconst(this);
}

void GreenPlumParser::Signed_iconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigned_iconst(this);
}


antlrcpp::Any GreenPlumParser::Signed_iconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSigned_iconst(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Signed_iconstContext* GreenPlumParser::signed_iconst() {
  Signed_iconstContext *_localctx = _tracker.createInstance<Signed_iconstContext>(_ctx, getState());
  enterRule(_localctx, 1046, GreenPlumParser::RuleSigned_iconst);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6680);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GreenPlumParser::PLUS_SIGN

    || _la == GreenPlumParser::MINUS_SIGN) {
      setState(6679);
      _la = _input->LA(1);
      if (!(_la == GreenPlumParser::PLUS_SIGN

      || _la == GreenPlumParser::MINUS_SIGN)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(6682);
    match(GreenPlumParser::ICONST);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColidContext ------------------------------------------------------------------

GreenPlumParser::ColidContext::ColidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IdentifierContext* GreenPlumParser::ColidContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}

tree::TerminalNode* GreenPlumParser::ColidContext::COLON() {
  return getToken(GreenPlumParser::COLON, 0);
}

GreenPlumParser::Unreserved_keywordContext* GreenPlumParser::ColidContext::unreserved_keyword() {
  return getRuleContext<GreenPlumParser::Unreserved_keywordContext>(0);
}

tree::TerminalNode* GreenPlumParser::ColidContext::SCONST() {
  return getToken(GreenPlumParser::SCONST, 0);
}


size_t GreenPlumParser::ColidContext::getRuleIndex() const {
  return GreenPlumParser::RuleColid;
}

void GreenPlumParser::ColidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColid(this);
}

void GreenPlumParser::ColidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColid(this);
}


antlrcpp::Any GreenPlumParser::ColidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitColid(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::ColidContext* GreenPlumParser::colid() {
  ColidContext *_localctx = _tracker.createInstance<ColidContext>(_ctx, getState());
  enterRule(_localctx, 1048, GreenPlumParser::RuleColid);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6690);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::COLON:
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID: {
        enterOuterAlt(_localctx, 1);
        setState(6685);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GreenPlumParser::COLON) {
          setState(6684);
          match(GreenPlumParser::COLON);
        }
        setState(6687);
        identifier();
        break;
      }

      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE: {
        enterOuterAlt(_localctx, 2);
        setState(6688);
        unreserved_keyword();
        break;
      }

      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 3);
        setState(6689);
        match(GreenPlumParser::SCONST);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_function_nameContext ------------------------------------------------------------------

GreenPlumParser::Type_function_nameContext::Type_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IdentifierContext* GreenPlumParser::Type_function_nameContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}

GreenPlumParser::Unreserved_keywordContext* GreenPlumParser::Type_function_nameContext::unreserved_keyword() {
  return getRuleContext<GreenPlumParser::Unreserved_keywordContext>(0);
}

GreenPlumParser::Type_func_name_keywordContext* GreenPlumParser::Type_function_nameContext::type_func_name_keyword() {
  return getRuleContext<GreenPlumParser::Type_func_name_keywordContext>(0);
}


size_t GreenPlumParser::Type_function_nameContext::getRuleIndex() const {
  return GreenPlumParser::RuleType_function_name;
}

void GreenPlumParser::Type_function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_function_name(this);
}

void GreenPlumParser::Type_function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_function_name(this);
}


antlrcpp::Any GreenPlumParser::Type_function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitType_function_name(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Type_function_nameContext* GreenPlumParser::type_function_name() {
  Type_function_nameContext *_localctx = _tracker.createInstance<Type_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 1050, GreenPlumParser::RuleType_function_name);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6695);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID: {
        enterOuterAlt(_localctx, 1);
        setState(6692);
        identifier();
        break;
      }

      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE: {
        enterOuterAlt(_localctx, 2);
        setState(6693);
        unreserved_keyword();
        break;
      }

      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::VERBOSE: {
        enterOuterAlt(_localctx, 3);
        setState(6694);
        type_func_name_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Col_labelContext ------------------------------------------------------------------

GreenPlumParser::Col_labelContext::Col_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::IdentifierContext* GreenPlumParser::Col_labelContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}

GreenPlumParser::Unreserved_keywordContext* GreenPlumParser::Col_labelContext::unreserved_keyword() {
  return getRuleContext<GreenPlumParser::Unreserved_keywordContext>(0);
}

GreenPlumParser::Col_name_keywordContext* GreenPlumParser::Col_labelContext::col_name_keyword() {
  return getRuleContext<GreenPlumParser::Col_name_keywordContext>(0);
}

GreenPlumParser::Type_func_name_keywordContext* GreenPlumParser::Col_labelContext::type_func_name_keyword() {
  return getRuleContext<GreenPlumParser::Type_func_name_keywordContext>(0);
}

GreenPlumParser::Reserved_keywordContext* GreenPlumParser::Col_labelContext::reserved_keyword() {
  return getRuleContext<GreenPlumParser::Reserved_keywordContext>(0);
}

tree::TerminalNode* GreenPlumParser::Col_labelContext::SCONST() {
  return getToken(GreenPlumParser::SCONST, 0);
}


size_t GreenPlumParser::Col_labelContext::getRuleIndex() const {
  return GreenPlumParser::RuleCol_label;
}

void GreenPlumParser::Col_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCol_label(this);
}

void GreenPlumParser::Col_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCol_label(this);
}


antlrcpp::Any GreenPlumParser::Col_labelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCol_label(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Col_labelContext* GreenPlumParser::col_label() {
  Col_labelContext *_localctx = _tracker.createInstance<Col_labelContext>(_ctx, getState());
  enterRule(_localctx, 1052, GreenPlumParser::RuleCol_label);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6703);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID: {
        enterOuterAlt(_localctx, 1);
        setState(6697);
        identifier();
        break;
      }

      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADD_P:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ALTER:
      case GreenPlumParser::ALWAYS:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AT:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONFIGURATION:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONTINUE_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CURRENT_P:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DATA_P:
      case GreenPlumParser::DAY_P:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DENY:
      case GreenPlumParser::DICTIONARY:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DISCARD:
      case GreenPlumParser::DOCUMENT_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::DXL:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTENSION:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::FAMILY:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILESPACE:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::HOUR_P:
      case GreenPlumParser::IDENTITY_P:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IGNORE_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INLINE_P:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::MAPPING:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINUTE_P:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MONTH_P:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEEXTTABLE:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::ORDERED:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OVER:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARSER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSING:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::PLANS:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROGRAM:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::PUBLIC:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::RANDOMLY:
      case GreenPlumParser::READ:
      case GreenPlumParser::READABLE:
      case GreenPlumParser::READS:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::RECURSIVE:
      case GreenPlumParser::REF:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::REJECT_P:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::REPLICA:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROOTPARTITION:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECOND_P:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::STANDALONE_P:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::STRIP_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TABLESPACE:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::TEXT_P:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATION:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VARYING:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WEB:
      case GreenPlumParser::WHITESPACE_P:
      case GreenPlumParser::WITHIN:
      case GreenPlumParser::WITHOUT:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITABLE:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::XML_P:
      case GreenPlumParser::YEAR_P:
      case GreenPlumParser::YES_P:
      case GreenPlumParser::ZONE: {
        enterOuterAlt(_localctx, 2);
        setState(6698);
        unreserved_keyword();
        break;
      }

      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::CHARACTER:
      case GreenPlumParser::CHAR_P:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::CUBE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::INOUT:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::MEDIAN:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NONE:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OUT_P:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::PERCENTILE_CONT:
      case GreenPlumParser::PERCENTILE_DISC:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PRECISION:
      case GreenPlumParser::REAL:
      case GreenPlumParser::ROLLUP:
      case GreenPlumParser::ROW:
      case GreenPlumParser::SETOF:
      case GreenPlumParser::SETS:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::VALUES:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::XMLATTRIBUTES:
      case GreenPlumParser::XMLCONCAT:
      case GreenPlumParser::XMLELEMENT:
      case GreenPlumParser::XMLEXISTS:
      case GreenPlumParser::XMLFOREST:
      case GreenPlumParser::XMLPARSE:
      case GreenPlumParser::XMLPI:
      case GreenPlumParser::XMLROOT:
      case GreenPlumParser::XMLSERIALIZE: {
        enterOuterAlt(_localctx, 3);
        setState(6699);
        col_name_keyword();
        break;
      }

      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::CROSS:
      case GreenPlumParser::CURRENT_SCHEMA:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FULL:
      case GreenPlumParser::ILIKE:
      case GreenPlumParser::INNER_P:
      case GreenPlumParser::IS:
      case GreenPlumParser::ISNULL:
      case GreenPlumParser::JOIN:
      case GreenPlumParser::LEFT:
      case GreenPlumParser::LIKE:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::NATURAL:
      case GreenPlumParser::NOTNULL:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OVERLAPS:
      case GreenPlumParser::RIGHT:
      case GreenPlumParser::SIMILAR:
      case GreenPlumParser::VERBOSE: {
        enterOuterAlt(_localctx, 4);
        setState(6700);
        type_func_name_keyword();
        break;
      }

      case GreenPlumParser::ALL:
      case GreenPlumParser::ANALYSE:
      case GreenPlumParser::ANALYZE:
      case GreenPlumParser::AND:
      case GreenPlumParser::ANY:
      case GreenPlumParser::ARRAY:
      case GreenPlumParser::AS:
      case GreenPlumParser::ASC:
      case GreenPlumParser::ASYMMETRIC:
      case GreenPlumParser::BETWEEN:
      case GreenPlumParser::BOTH:
      case GreenPlumParser::CASE:
      case GreenPlumParser::CAST:
      case GreenPlumParser::CHECK:
      case GreenPlumParser::COLLATE:
      case GreenPlumParser::COLUMN:
      case GreenPlumParser::CONSTRAINT:
      case GreenPlumParser::CREATE:
      case GreenPlumParser::CURRENT_CATALOG:
      case GreenPlumParser::CURRENT_DATE:
      case GreenPlumParser::CURRENT_ROLE:
      case GreenPlumParser::CURRENT_TIME:
      case GreenPlumParser::CURRENT_TIMESTAMP:
      case GreenPlumParser::CURRENT_USER:
      case GreenPlumParser::DECODE:
      case GreenPlumParser::DEFAULT:
      case GreenPlumParser::DEFERRABLE:
      case GreenPlumParser::DESC:
      case GreenPlumParser::DISTINCT:
      case GreenPlumParser::DISTRIBUTED:
      case GreenPlumParser::DO:
      case GreenPlumParser::ELSE:
      case GreenPlumParser::END_P:
      case GreenPlumParser::EXCEPT:
      case GreenPlumParser::EXCLUDE:
      case GreenPlumParser::FALSE_P:
      case GreenPlumParser::FETCH:
      case GreenPlumParser::FILTER:
      case GreenPlumParser::FOLLOWING:
      case GreenPlumParser::FOR:
      case GreenPlumParser::FOREIGN:
      case GreenPlumParser::FROM:
      case GreenPlumParser::GRANT:
      case GreenPlumParser::GROUP_P:
      case GreenPlumParser::HAVING:
      case GreenPlumParser::INITIALLY:
      case GreenPlumParser::IN_P:
      case GreenPlumParser::INTERSECT:
      case GreenPlumParser::INTO:
      case GreenPlumParser::LEADING:
      case GreenPlumParser::LIMIT:
      case GreenPlumParser::LOCALTIME:
      case GreenPlumParser::LOCALTIMESTAMP:
      case GreenPlumParser::NEW:
      case GreenPlumParser::NOT:
      case GreenPlumParser::NULL_P:
      case GreenPlumParser::OFF:
      case GreenPlumParser::OFFSET:
      case GreenPlumParser::OLD:
      case GreenPlumParser::ON:
      case GreenPlumParser::ONLY:
      case GreenPlumParser::OR:
      case GreenPlumParser::ORDER:
      case GreenPlumParser::PARTITION:
      case GreenPlumParser::PLACING:
      case GreenPlumParser::PRECEDING:
      case GreenPlumParser::PRIMARY:
      case GreenPlumParser::RANGE:
      case GreenPlumParser::REFERENCES:
      case GreenPlumParser::RETURNING:
      case GreenPlumParser::ROWS:
      case GreenPlumParser::SCATTER:
      case GreenPlumParser::SELECT:
      case GreenPlumParser::SESSION_USER:
      case GreenPlumParser::SOME:
      case GreenPlumParser::SYMMETRIC:
      case GreenPlumParser::TABLE:
      case GreenPlumParser::THEN:
      case GreenPlumParser::TO:
      case GreenPlumParser::TRAILING:
      case GreenPlumParser::TRUE_P:
      case GreenPlumParser::UNBOUNDED:
      case GreenPlumParser::UNION:
      case GreenPlumParser::UNIQUE:
      case GreenPlumParser::USER:
      case GreenPlumParser::USING:
      case GreenPlumParser::VARIADIC:
      case GreenPlumParser::WHEN:
      case GreenPlumParser::WHERE:
      case GreenPlumParser::WINDOW:
      case GreenPlumParser::WITH: {
        enterOuterAlt(_localctx, 5);
        setState(6701);
        reserved_keyword();
        break;
      }

      case GreenPlumParser::SCONST: {
        enterOuterAlt(_localctx, 6);
        setState(6702);
        match(GreenPlumParser::SCONST);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

GreenPlumParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::IdentifierContext::REGULAR_ID() {
  return getToken(GreenPlumParser::REGULAR_ID, 0);
}

tree::TerminalNode* GreenPlumParser::IdentifierContext::CHAR_STRING() {
  return getToken(GreenPlumParser::CHAR_STRING, 0);
}


size_t GreenPlumParser::IdentifierContext::getRuleIndex() const {
  return GreenPlumParser::RuleIdentifier;
}

void GreenPlumParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void GreenPlumParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}


antlrcpp::Any GreenPlumParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::IdentifierContext* GreenPlumParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1054, GreenPlumParser::RuleIdentifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6705);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::CHAR_STRING

    || _la == GreenPlumParser::REGULAR_ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unreserved_keywordContext ------------------------------------------------------------------

GreenPlumParser::Unreserved_keywordContext::Unreserved_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ABORT_P() {
  return getToken(GreenPlumParser::ABORT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ABSOLUTE_P() {
  return getToken(GreenPlumParser::ABSOLUTE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ACCESS() {
  return getToken(GreenPlumParser::ACCESS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ACTION() {
  return getToken(GreenPlumParser::ACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ACTIVE() {
  return getToken(GreenPlumParser::ACTIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ADMIN() {
  return getToken(GreenPlumParser::ADMIN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::AFTER() {
  return getToken(GreenPlumParser::AFTER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ALSO() {
  return getToken(GreenPlumParser::ALSO, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ALWAYS() {
  return getToken(GreenPlumParser::ALWAYS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ASSERTION() {
  return getToken(GreenPlumParser::ASSERTION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ASSIGNMENT() {
  return getToken(GreenPlumParser::ASSIGNMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::AT() {
  return getToken(GreenPlumParser::AT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::BACKWARD() {
  return getToken(GreenPlumParser::BACKWARD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::BEFORE() {
  return getToken(GreenPlumParser::BEFORE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::BEGIN_P() {
  return getToken(GreenPlumParser::BEGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CACHE() {
  return getToken(GreenPlumParser::CACHE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CALLED() {
  return getToken(GreenPlumParser::CALLED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CASCADE() {
  return getToken(GreenPlumParser::CASCADE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CASCADED() {
  return getToken(GreenPlumParser::CASCADED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CHAIN() {
  return getToken(GreenPlumParser::CHAIN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CHARACTERISTICS() {
  return getToken(GreenPlumParser::CHARACTERISTICS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CHECKPOINT() {
  return getToken(GreenPlumParser::CHECKPOINT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CLOSE() {
  return getToken(GreenPlumParser::CLOSE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CLUSTER() {
  return getToken(GreenPlumParser::CLUSTER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::COMMENT() {
  return getToken(GreenPlumParser::COMMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::COMMIT() {
  return getToken(GreenPlumParser::COMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::COMMITTED() {
  return getToken(GreenPlumParser::COMMITTED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONCURRENCY() {
  return getToken(GreenPlumParser::CONCURRENCY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONCURRENTLY() {
  return getToken(GreenPlumParser::CONCURRENTLY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONFIGURATION() {
  return getToken(GreenPlumParser::CONFIGURATION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONNECTION() {
  return getToken(GreenPlumParser::CONNECTION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONSTRAINTS() {
  return getToken(GreenPlumParser::CONSTRAINTS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONTAINS() {
  return getToken(GreenPlumParser::CONTAINS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONTENT_P() {
  return getToken(GreenPlumParser::CONTENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONTINUE_P() {
  return getToken(GreenPlumParser::CONTINUE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::COPY() {
  return getToken(GreenPlumParser::COPY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::COST() {
  return getToken(GreenPlumParser::COST, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CPUSET() {
  return getToken(GreenPlumParser::CPUSET, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CPU_RATE_LIMIT() {
  return getToken(GreenPlumParser::CPU_RATE_LIMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CREATEDB() {
  return getToken(GreenPlumParser::CREATEDB, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CREATEEXTTABLE() {
  return getToken(GreenPlumParser::CREATEEXTTABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CREATEROLE() {
  return getToken(GreenPlumParser::CREATEROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CREATEUSER() {
  return getToken(GreenPlumParser::CREATEUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CSV() {
  return getToken(GreenPlumParser::CSV, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CURRENT_P() {
  return getToken(GreenPlumParser::CURRENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CURSOR() {
  return getToken(GreenPlumParser::CURSOR, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::CYCLE() {
  return getToken(GreenPlumParser::CYCLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DATA_P() {
  return getToken(GreenPlumParser::DATA_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DAY_P() {
  return getToken(GreenPlumParser::DAY_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DEALLOCATE() {
  return getToken(GreenPlumParser::DEALLOCATE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DECLARE() {
  return getToken(GreenPlumParser::DECLARE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DEFAULTS() {
  return getToken(GreenPlumParser::DEFAULTS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DEFERRED() {
  return getToken(GreenPlumParser::DEFERRED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DEFINER() {
  return getToken(GreenPlumParser::DEFINER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DELIMITER() {
  return getToken(GreenPlumParser::DELIMITER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DELIMITERS() {
  return getToken(GreenPlumParser::DELIMITERS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DENY() {
  return getToken(GreenPlumParser::DENY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DICTIONARY() {
  return getToken(GreenPlumParser::DICTIONARY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DISABLE_P() {
  return getToken(GreenPlumParser::DISABLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DISCARD() {
  return getToken(GreenPlumParser::DISCARD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DOCUMENT_P() {
  return getToken(GreenPlumParser::DOCUMENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DOUBLE_P() {
  return getToken(GreenPlumParser::DOUBLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::DXL() {
  return getToken(GreenPlumParser::DXL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EACH() {
  return getToken(GreenPlumParser::EACH, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ENABLE_P() {
  return getToken(GreenPlumParser::ENABLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ENCODING() {
  return getToken(GreenPlumParser::ENCODING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ENCRYPTED() {
  return getToken(GreenPlumParser::ENCRYPTED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ENUM_P() {
  return getToken(GreenPlumParser::ENUM_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ERRORS() {
  return getToken(GreenPlumParser::ERRORS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ESCAPE() {
  return getToken(GreenPlumParser::ESCAPE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EVERY() {
  return getToken(GreenPlumParser::EVERY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EXCHANGE() {
  return getToken(GreenPlumParser::EXCHANGE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EXCLUDING() {
  return getToken(GreenPlumParser::EXCLUDING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EXCLUSIVE() {
  return getToken(GreenPlumParser::EXCLUSIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EXECUTE() {
  return getToken(GreenPlumParser::EXECUTE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EXPLAIN() {
  return getToken(GreenPlumParser::EXPLAIN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EXTENSION() {
  return getToken(GreenPlumParser::EXTENSION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::EXTERNAL() {
  return getToken(GreenPlumParser::EXTERNAL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FAMILY() {
  return getToken(GreenPlumParser::FAMILY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FIELDS() {
  return getToken(GreenPlumParser::FIELDS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FILESPACE() {
  return getToken(GreenPlumParser::FILESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FILL() {
  return getToken(GreenPlumParser::FILL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FIRST_P() {
  return getToken(GreenPlumParser::FIRST_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FORCE() {
  return getToken(GreenPlumParser::FORCE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FORMAT() {
  return getToken(GreenPlumParser::FORMAT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FORWARD() {
  return getToken(GreenPlumParser::FORWARD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::GLOBAL() {
  return getToken(GreenPlumParser::GLOBAL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::GRANTED() {
  return getToken(GreenPlumParser::GRANTED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::HANDLER() {
  return getToken(GreenPlumParser::HANDLER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::HASH() {
  return getToken(GreenPlumParser::HASH, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::HEADER_P() {
  return getToken(GreenPlumParser::HEADER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::HOLD() {
  return getToken(GreenPlumParser::HOLD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::HOST() {
  return getToken(GreenPlumParser::HOST, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::HOUR_P() {
  return getToken(GreenPlumParser::HOUR_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::IDENTITY_P() {
  return getToken(GreenPlumParser::IDENTITY_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::IGNORE_P() {
  return getToken(GreenPlumParser::IGNORE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::IMMEDIATE() {
  return getToken(GreenPlumParser::IMMEDIATE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::IMMUTABLE() {
  return getToken(GreenPlumParser::IMMUTABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::IMPLICIT_P() {
  return getToken(GreenPlumParser::IMPLICIT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INCLUDING() {
  return getToken(GreenPlumParser::INCLUDING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INCLUSIVE() {
  return getToken(GreenPlumParser::INCLUSIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INCREMENT() {
  return getToken(GreenPlumParser::INCREMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INDEXES() {
  return getToken(GreenPlumParser::INDEXES, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INHERIT() {
  return getToken(GreenPlumParser::INHERIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INHERITS() {
  return getToken(GreenPlumParser::INHERITS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INLINE_P() {
  return getToken(GreenPlumParser::INLINE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INPUT_P() {
  return getToken(GreenPlumParser::INPUT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INSENSITIVE() {
  return getToken(GreenPlumParser::INSENSITIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INSERT() {
  return getToken(GreenPlumParser::INSERT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INSTEAD() {
  return getToken(GreenPlumParser::INSTEAD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::INVOKER() {
  return getToken(GreenPlumParser::INVOKER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ISOLATION() {
  return getToken(GreenPlumParser::ISOLATION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::KEY() {
  return getToken(GreenPlumParser::KEY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LARGE_P() {
  return getToken(GreenPlumParser::LARGE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LAST_P() {
  return getToken(GreenPlumParser::LAST_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LEVEL() {
  return getToken(GreenPlumParser::LEVEL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LIST() {
  return getToken(GreenPlumParser::LIST, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LISTEN() {
  return getToken(GreenPlumParser::LISTEN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LOAD() {
  return getToken(GreenPlumParser::LOAD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LOCAL() {
  return getToken(GreenPlumParser::LOCAL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LOCATION() {
  return getToken(GreenPlumParser::LOCATION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LOCK_P() {
  return getToken(GreenPlumParser::LOCK_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::LOGIN_P() {
  return getToken(GreenPlumParser::LOGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MAPPING() {
  return getToken(GreenPlumParser::MAPPING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MASTER() {
  return getToken(GreenPlumParser::MASTER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MATCH() {
  return getToken(GreenPlumParser::MATCH, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MAXVALUE() {
  return getToken(GreenPlumParser::MAXVALUE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MEMORY_LIMIT() {
  return getToken(GreenPlumParser::MEMORY_LIMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MEMORY_SHARED_QUOTA() {
  return getToken(GreenPlumParser::MEMORY_SHARED_QUOTA, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MEMORY_SPILL_RATIO() {
  return getToken(GreenPlumParser::MEMORY_SPILL_RATIO, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MERGE() {
  return getToken(GreenPlumParser::MERGE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MINUTE_P() {
  return getToken(GreenPlumParser::MINUTE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MINVALUE() {
  return getToken(GreenPlumParser::MINVALUE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MISSING() {
  return getToken(GreenPlumParser::MISSING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MODE() {
  return getToken(GreenPlumParser::MODE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MODIFIES() {
  return getToken(GreenPlumParser::MODIFIES, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MODIFY() {
  return getToken(GreenPlumParser::MODIFY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MONTH_P() {
  return getToken(GreenPlumParser::MONTH_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::MOVE() {
  return getToken(GreenPlumParser::MOVE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NAME_P() {
  return getToken(GreenPlumParser::NAME_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NAMES() {
  return getToken(GreenPlumParser::NAMES, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NEXT() {
  return getToken(GreenPlumParser::NEXT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOCREATEDB() {
  return getToken(GreenPlumParser::NOCREATEDB, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOCREATEEXTTABLE() {
  return getToken(GreenPlumParser::NOCREATEEXTTABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOCREATEROLE() {
  return getToken(GreenPlumParser::NOCREATEROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOCREATEUSER() {
  return getToken(GreenPlumParser::NOCREATEUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOINHERIT() {
  return getToken(GreenPlumParser::NOINHERIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOLOGIN_P() {
  return getToken(GreenPlumParser::NOLOGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOOVERCOMMIT() {
  return getToken(GreenPlumParser::NOOVERCOMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOSUPERUSER() {
  return getToken(GreenPlumParser::NOSUPERUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOTHING() {
  return getToken(GreenPlumParser::NOTHING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOTIFY() {
  return getToken(GreenPlumParser::NOTIFY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NOWAIT() {
  return getToken(GreenPlumParser::NOWAIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::NULLS_P() {
  return getToken(GreenPlumParser::NULLS_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OBJECT_P() {
  return getToken(GreenPlumParser::OBJECT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OF() {
  return getToken(GreenPlumParser::OF, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OIDS() {
  return getToken(GreenPlumParser::OIDS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OPTIONS() {
  return getToken(GreenPlumParser::OPTIONS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ORDERED() {
  return getToken(GreenPlumParser::ORDERED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OTHERS() {
  return getToken(GreenPlumParser::OTHERS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OVER() {
  return getToken(GreenPlumParser::OVER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OVERCOMMIT() {
  return getToken(GreenPlumParser::OVERCOMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OWNED() {
  return getToken(GreenPlumParser::OWNED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::OWNER() {
  return getToken(GreenPlumParser::OWNER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PARSER() {
  return getToken(GreenPlumParser::PARSER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PARTIAL() {
  return getToken(GreenPlumParser::PARTIAL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PARTITIONS() {
  return getToken(GreenPlumParser::PARTITIONS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PASSING() {
  return getToken(GreenPlumParser::PASSING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PASSWORD() {
  return getToken(GreenPlumParser::PASSWORD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PERCENT() {
  return getToken(GreenPlumParser::PERCENT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PLANS() {
  return getToken(GreenPlumParser::PLANS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PREPARE() {
  return getToken(GreenPlumParser::PREPARE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PREPARED() {
  return getToken(GreenPlumParser::PREPARED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PRESERVE() {
  return getToken(GreenPlumParser::PRESERVE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PRIOR() {
  return getToken(GreenPlumParser::PRIOR, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PRIVILEGES() {
  return getToken(GreenPlumParser::PRIVILEGES, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PROCEDURE() {
  return getToken(GreenPlumParser::PROCEDURE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PROGRAM() {
  return getToken(GreenPlumParser::PROGRAM, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PROTOCOL() {
  return getToken(GreenPlumParser::PROTOCOL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::QUEUE() {
  return getToken(GreenPlumParser::QUEUE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::QUOTE() {
  return getToken(GreenPlumParser::QUOTE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RANDOMLY() {
  return getToken(GreenPlumParser::RANDOMLY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::READ() {
  return getToken(GreenPlumParser::READ, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::READABLE() {
  return getToken(GreenPlumParser::READABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::READS() {
  return getToken(GreenPlumParser::READS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REASSIGN() {
  return getToken(GreenPlumParser::REASSIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RECHECK() {
  return getToken(GreenPlumParser::RECHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RECURSIVE() {
  return getToken(GreenPlumParser::RECURSIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REF() {
  return getToken(GreenPlumParser::REF, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REINDEX() {
  return getToken(GreenPlumParser::REINDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REJECT_P() {
  return getToken(GreenPlumParser::REJECT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RELATIVE_P() {
  return getToken(GreenPlumParser::RELATIVE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RELEASE() {
  return getToken(GreenPlumParser::RELEASE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RENAME() {
  return getToken(GreenPlumParser::RENAME, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REPEATABLE() {
  return getToken(GreenPlumParser::REPEATABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REPLACE() {
  return getToken(GreenPlumParser::REPLACE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REPLICA() {
  return getToken(GreenPlumParser::REPLICA, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RESET() {
  return getToken(GreenPlumParser::RESET, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RESTART() {
  return getToken(GreenPlumParser::RESTART, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RESTRICT() {
  return getToken(GreenPlumParser::RESTRICT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RETURNS() {
  return getToken(GreenPlumParser::RETURNS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::REVOKE() {
  return getToken(GreenPlumParser::REVOKE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ROLLBACK() {
  return getToken(GreenPlumParser::ROLLBACK, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ROOTPARTITION() {
  return getToken(GreenPlumParser::ROOTPARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::RULE() {
  return getToken(GreenPlumParser::RULE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SAVEPOINT() {
  return getToken(GreenPlumParser::SAVEPOINT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SCROLL() {
  return getToken(GreenPlumParser::SCROLL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SECOND_P() {
  return getToken(GreenPlumParser::SECOND_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SECURITY() {
  return getToken(GreenPlumParser::SECURITY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SEGMENT() {
  return getToken(GreenPlumParser::SEGMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SERIALIZABLE() {
  return getToken(GreenPlumParser::SERIALIZABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SESSION() {
  return getToken(GreenPlumParser::SESSION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SHARE() {
  return getToken(GreenPlumParser::SHARE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SHOW() {
  return getToken(GreenPlumParser::SHOW, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SIMPLE() {
  return getToken(GreenPlumParser::SIMPLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SPLIT() {
  return getToken(GreenPlumParser::SPLIT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SQL() {
  return getToken(GreenPlumParser::SQL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STABLE() {
  return getToken(GreenPlumParser::STABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STANDALONE_P() {
  return getToken(GreenPlumParser::STANDALONE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::START() {
  return getToken(GreenPlumParser::START, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STATEMENT() {
  return getToken(GreenPlumParser::STATEMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STATISTICS() {
  return getToken(GreenPlumParser::STATISTICS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STDIN() {
  return getToken(GreenPlumParser::STDIN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STDOUT() {
  return getToken(GreenPlumParser::STDOUT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STORAGE() {
  return getToken(GreenPlumParser::STORAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STRICT_P() {
  return getToken(GreenPlumParser::STRICT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::STRIP_P() {
  return getToken(GreenPlumParser::STRIP_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SUBPARTITION() {
  return getToken(GreenPlumParser::SUBPARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SUBPARTITIONS() {
  return getToken(GreenPlumParser::SUBPARTITIONS, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SUPERUSER_P() {
  return getToken(GreenPlumParser::SUPERUSER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SYSID() {
  return getToken(GreenPlumParser::SYSID, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::SYSTEM_P() {
  return getToken(GreenPlumParser::SYSTEM_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TEMP() {
  return getToken(GreenPlumParser::TEMP, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TEMPORARY() {
  return getToken(GreenPlumParser::TEMPORARY, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TEXT_P() {
  return getToken(GreenPlumParser::TEXT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::THRESHOLD() {
  return getToken(GreenPlumParser::THRESHOLD, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TIES() {
  return getToken(GreenPlumParser::TIES, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TRANSACTION() {
  return getToken(GreenPlumParser::TRANSACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TRUNCATE() {
  return getToken(GreenPlumParser::TRUNCATE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TRUSTED() {
  return getToken(GreenPlumParser::TRUSTED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::UNCOMMITTED() {
  return getToken(GreenPlumParser::UNCOMMITTED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::UNENCRYPTED() {
  return getToken(GreenPlumParser::UNENCRYPTED, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::UNKNOWN() {
  return getToken(GreenPlumParser::UNKNOWN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::UNLISTEN() {
  return getToken(GreenPlumParser::UNLISTEN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::UNTIL() {
  return getToken(GreenPlumParser::UNTIL, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VACUUM() {
  return getToken(GreenPlumParser::VACUUM, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VALID() {
  return getToken(GreenPlumParser::VALID, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VALIDATION() {
  return getToken(GreenPlumParser::VALIDATION, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VALIDATOR() {
  return getToken(GreenPlumParser::VALIDATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VALUE_P() {
  return getToken(GreenPlumParser::VALUE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VARYING() {
  return getToken(GreenPlumParser::VARYING, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VERSION_P() {
  return getToken(GreenPlumParser::VERSION_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VIEW() {
  return getToken(GreenPlumParser::VIEW, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::VOLATILE() {
  return getToken(GreenPlumParser::VOLATILE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::WEB() {
  return getToken(GreenPlumParser::WEB, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::WHITESPACE_P() {
  return getToken(GreenPlumParser::WHITESPACE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::WITHIN() {
  return getToken(GreenPlumParser::WITHIN, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::WITHOUT() {
  return getToken(GreenPlumParser::WITHOUT, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::WORK() {
  return getToken(GreenPlumParser::WORK, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::WRITABLE() {
  return getToken(GreenPlumParser::WRITABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::WRITE() {
  return getToken(GreenPlumParser::WRITE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::XML_P() {
  return getToken(GreenPlumParser::XML_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::YEAR_P() {
  return getToken(GreenPlumParser::YEAR_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::YES_P() {
  return getToken(GreenPlumParser::YES_P, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::ZONE() {
  return getToken(GreenPlumParser::ZONE, 0);
}

tree::TerminalNode* GreenPlumParser::Unreserved_keywordContext::PUBLIC() {
  return getToken(GreenPlumParser::PUBLIC, 0);
}


size_t GreenPlumParser::Unreserved_keywordContext::getRuleIndex() const {
  return GreenPlumParser::RuleUnreserved_keyword;
}

void GreenPlumParser::Unreserved_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnreserved_keyword(this);
}

void GreenPlumParser::Unreserved_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnreserved_keyword(this);
}


antlrcpp::Any GreenPlumParser::Unreserved_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitUnreserved_keyword(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Unreserved_keywordContext* GreenPlumParser::unreserved_keyword() {
  Unreserved_keywordContext *_localctx = _tracker.createInstance<Unreserved_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1056, GreenPlumParser::RuleUnreserved_keyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6707);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADD_P)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ALTER)
      | (1ULL << GreenPlumParser::ALWAYS)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AT)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONFIGURATION)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONTINUE_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CURRENT_P - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DATA_P - 64))
      | (1ULL << (GreenPlumParser::DAY_P - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DENY - 64))
      | (1ULL << (GreenPlumParser::DICTIONARY - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DISCARD - 64))
      | (1ULL << (GreenPlumParser::DOCUMENT_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::DXL - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTENSION - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::FAMILY - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILESPACE - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::HOUR_P - 128))
      | (1ULL << (GreenPlumParser::IDENTITY_P - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IGNORE_P - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INLINE_P - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::MAPPING - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINUTE_P - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MONTH_P - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEEXTTABLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::ORDERED - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OVER - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARSER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSING - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::PLANS - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROGRAM - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257))
      | (1ULL << (GreenPlumParser::PUBLIC - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::RANDOMLY - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::READABLE - 321))
      | (1ULL << (GreenPlumParser::READS - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::RECURSIVE - 321))
      | (1ULL << (GreenPlumParser::REF - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::REJECT_P - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::REPLICA - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROOTPARTITION - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECOND_P - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::STANDALONE_P - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::STRIP_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TABLESPACE - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::TEXT_P - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATION - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VARYING - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385))
      | (1ULL << (GreenPlumParser::WEB - 385))
      | (1ULL << (GreenPlumParser::WHITESPACE_P - 385)))) != 0) || ((((_la - 451) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 451)) & ((1ULL << (GreenPlumParser::WITHIN - 451))
      | (1ULL << (GreenPlumParser::WITHOUT - 451))
      | (1ULL << (GreenPlumParser::WORK - 451))
      | (1ULL << (GreenPlumParser::WRITABLE - 451))
      | (1ULL << (GreenPlumParser::WRITE - 451))
      | (1ULL << (GreenPlumParser::XML_P - 451))
      | (1ULL << (GreenPlumParser::YEAR_P - 451))
      | (1ULL << (GreenPlumParser::YES_P - 451))
      | (1ULL << (GreenPlumParser::ZONE - 451)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keywords_ok_in_alias_no_asContext ------------------------------------------------------------------

GreenPlumParser::Keywords_ok_in_alias_no_asContext::Keywords_ok_in_alias_no_asContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Partition_ident_key_wordContext* GreenPlumParser::Keywords_ok_in_alias_no_asContext::partition_ident_key_word() {
  return getRuleContext<GreenPlumParser::Partition_ident_key_wordContext>(0);
}

tree::TerminalNode* GreenPlumParser::Keywords_ok_in_alias_no_asContext::TABLESPACE() {
  return getToken(GreenPlumParser::TABLESPACE, 0);
}

tree::TerminalNode* GreenPlumParser::Keywords_ok_in_alias_no_asContext::ADD_P() {
  return getToken(GreenPlumParser::ADD_P, 0);
}

tree::TerminalNode* GreenPlumParser::Keywords_ok_in_alias_no_asContext::ALTER() {
  return getToken(GreenPlumParser::ALTER, 0);
}

tree::TerminalNode* GreenPlumParser::Keywords_ok_in_alias_no_asContext::AT() {
  return getToken(GreenPlumParser::AT, 0);
}


size_t GreenPlumParser::Keywords_ok_in_alias_no_asContext::getRuleIndex() const {
  return GreenPlumParser::RuleKeywords_ok_in_alias_no_as;
}

void GreenPlumParser::Keywords_ok_in_alias_no_asContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeywords_ok_in_alias_no_as(this);
}

void GreenPlumParser::Keywords_ok_in_alias_no_asContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeywords_ok_in_alias_no_as(this);
}


antlrcpp::Any GreenPlumParser::Keywords_ok_in_alias_no_asContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitKeywords_ok_in_alias_no_as(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Keywords_ok_in_alias_no_asContext* GreenPlumParser::keywords_ok_in_alias_no_as() {
  Keywords_ok_in_alias_no_asContext *_localctx = _tracker.createInstance<Keywords_ok_in_alias_no_asContext>(_ctx, getState());
  enterRule(_localctx, 1058, GreenPlumParser::RuleKeywords_ok_in_alias_no_as);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6714);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CUBE:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INOUT:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NONE:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OUT_P:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PRECISION:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::READ:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROLLUP:
      case GreenPlumParser::ROW:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SETOF:
      case GreenPlumParser::SETS:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VALUES:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::ZONE: {
        enterOuterAlt(_localctx, 1);
        setState(6709);
        partition_ident_key_word();
        break;
      }

      case GreenPlumParser::TABLESPACE: {
        enterOuterAlt(_localctx, 2);
        setState(6710);
        match(GreenPlumParser::TABLESPACE);
        break;
      }

      case GreenPlumParser::ADD_P: {
        enterOuterAlt(_localctx, 3);
        setState(6711);
        match(GreenPlumParser::ADD_P);
        break;
      }

      case GreenPlumParser::ALTER: {
        enterOuterAlt(_localctx, 4);
        setState(6712);
        match(GreenPlumParser::ALTER);
        break;
      }

      case GreenPlumParser::AT: {
        enterOuterAlt(_localctx, 5);
        setState(6713);
        match(GreenPlumParser::AT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_colidContext ------------------------------------------------------------------

GreenPlumParser::Partition_colidContext::Partition_colidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GreenPlumParser::Partition_ident_key_wordContext* GreenPlumParser::Partition_colidContext::partition_ident_key_word() {
  return getRuleContext<GreenPlumParser::Partition_ident_key_wordContext>(0);
}

GreenPlumParser::IdentifierContext* GreenPlumParser::Partition_colidContext::identifier() {
  return getRuleContext<GreenPlumParser::IdentifierContext>(0);
}


size_t GreenPlumParser::Partition_colidContext::getRuleIndex() const {
  return GreenPlumParser::RulePartition_colid;
}

void GreenPlumParser::Partition_colidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartition_colid(this);
}

void GreenPlumParser::Partition_colidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartition_colid(this);
}


antlrcpp::Any GreenPlumParser::Partition_colidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPartition_colid(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Partition_colidContext* GreenPlumParser::partition_colid() {
  Partition_colidContext *_localctx = _tracker.createInstance<Partition_colidContext>(_ctx, getState());
  enterRule(_localctx, 1060, GreenPlumParser::RulePartition_colid);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6718);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GreenPlumParser::ABORT_P:
      case GreenPlumParser::ABSOLUTE_P:
      case GreenPlumParser::ACCESS:
      case GreenPlumParser::ACTION:
      case GreenPlumParser::ACTIVE:
      case GreenPlumParser::ADMIN:
      case GreenPlumParser::AFTER:
      case GreenPlumParser::AGGREGATE:
      case GreenPlumParser::ALSO:
      case GreenPlumParser::ASSERTION:
      case GreenPlumParser::ASSIGNMENT:
      case GreenPlumParser::AUTHORIZATION:
      case GreenPlumParser::BACKWARD:
      case GreenPlumParser::BEFORE:
      case GreenPlumParser::BEGIN_P:
      case GreenPlumParser::BIGINT:
      case GreenPlumParser::BINARY:
      case GreenPlumParser::BIT:
      case GreenPlumParser::BOOLEAN_P:
      case GreenPlumParser::BY:
      case GreenPlumParser::CACHE:
      case GreenPlumParser::CALLED:
      case GreenPlumParser::CASCADE:
      case GreenPlumParser::CASCADED:
      case GreenPlumParser::CHAIN:
      case GreenPlumParser::CHARACTERISTICS:
      case GreenPlumParser::CHECKPOINT:
      case GreenPlumParser::CLASS:
      case GreenPlumParser::CLOSE:
      case GreenPlumParser::CLUSTER:
      case GreenPlumParser::COALESCE:
      case GreenPlumParser::COMMENT:
      case GreenPlumParser::COMMIT:
      case GreenPlumParser::COMMITTED:
      case GreenPlumParser::CONCURRENCY:
      case GreenPlumParser::CONCURRENTLY:
      case GreenPlumParser::CONNECTION:
      case GreenPlumParser::CONSTRAINTS:
      case GreenPlumParser::CONTAINS:
      case GreenPlumParser::CONTENT_P:
      case GreenPlumParser::CONVERSION_P:
      case GreenPlumParser::COPY:
      case GreenPlumParser::COST:
      case GreenPlumParser::CPU_RATE_LIMIT:
      case GreenPlumParser::CPUSET:
      case GreenPlumParser::CREATEDB:
      case GreenPlumParser::CREATEEXTTABLE:
      case GreenPlumParser::CREATEROLE:
      case GreenPlumParser::CREATEUSER:
      case GreenPlumParser::CSV:
      case GreenPlumParser::CUBE:
      case GreenPlumParser::CURSOR:
      case GreenPlumParser::CYCLE:
      case GreenPlumParser::DATABASE:
      case GreenPlumParser::DEALLOCATE:
      case GreenPlumParser::DEC:
      case GreenPlumParser::DECIMAL_P:
      case GreenPlumParser::DECLARE:
      case GreenPlumParser::DEFAULTS:
      case GreenPlumParser::DEFERRED:
      case GreenPlumParser::DEFINER:
      case GreenPlumParser::DELETE_P:
      case GreenPlumParser::DELIMITER:
      case GreenPlumParser::DELIMITERS:
      case GreenPlumParser::DISABLE_P:
      case GreenPlumParser::DOMAIN_P:
      case GreenPlumParser::DOUBLE_P:
      case GreenPlumParser::DROP:
      case GreenPlumParser::EACH:
      case GreenPlumParser::ENABLE_P:
      case GreenPlumParser::ENCODING:
      case GreenPlumParser::ENCRYPTED:
      case GreenPlumParser::ENUM_P:
      case GreenPlumParser::ERRORS:
      case GreenPlumParser::ESCAPE:
      case GreenPlumParser::EVERY:
      case GreenPlumParser::EXCHANGE:
      case GreenPlumParser::EXCLUDING:
      case GreenPlumParser::EXCLUSIVE:
      case GreenPlumParser::EXECUTE:
      case GreenPlumParser::EXISTS:
      case GreenPlumParser::EXPLAIN:
      case GreenPlumParser::EXTERNAL:
      case GreenPlumParser::EXTRACT:
      case GreenPlumParser::FIELDS:
      case GreenPlumParser::FILL:
      case GreenPlumParser::FIRST_P:
      case GreenPlumParser::FLOAT_P:
      case GreenPlumParser::FORCE:
      case GreenPlumParser::FORMAT:
      case GreenPlumParser::FORWARD:
      case GreenPlumParser::FREEZE:
      case GreenPlumParser::FUNCTION:
      case GreenPlumParser::GLOBAL:
      case GreenPlumParser::GRANTED:
      case GreenPlumParser::GREATEST:
      case GreenPlumParser::GROUP_ID:
      case GreenPlumParser::GROUPING:
      case GreenPlumParser::HANDLER:
      case GreenPlumParser::HASH:
      case GreenPlumParser::HEADER_P:
      case GreenPlumParser::HOLD:
      case GreenPlumParser::HOST:
      case GreenPlumParser::IF_P:
      case GreenPlumParser::IMMEDIATE:
      case GreenPlumParser::IMMUTABLE:
      case GreenPlumParser::IMPLICIT_P:
      case GreenPlumParser::INCLUDING:
      case GreenPlumParser::INCLUSIVE:
      case GreenPlumParser::INCREMENT:
      case GreenPlumParser::INDEX:
      case GreenPlumParser::INDEXES:
      case GreenPlumParser::INHERIT:
      case GreenPlumParser::INHERITS:
      case GreenPlumParser::INOUT:
      case GreenPlumParser::INPUT_P:
      case GreenPlumParser::INSENSITIVE:
      case GreenPlumParser::INSERT:
      case GreenPlumParser::INSTEAD:
      case GreenPlumParser::INTEGER:
      case GreenPlumParser::INTERVAL:
      case GreenPlumParser::INT_P:
      case GreenPlumParser::INVOKER:
      case GreenPlumParser::ISOLATION:
      case GreenPlumParser::KEY:
      case GreenPlumParser::LANGUAGE:
      case GreenPlumParser::LARGE_P:
      case GreenPlumParser::LAST_P:
      case GreenPlumParser::LEAST:
      case GreenPlumParser::LEVEL:
      case GreenPlumParser::LIST:
      case GreenPlumParser::LISTEN:
      case GreenPlumParser::LOAD:
      case GreenPlumParser::LOCAL:
      case GreenPlumParser::LOCATION:
      case GreenPlumParser::LOCK_P:
      case GreenPlumParser::LOGIN_P:
      case GreenPlumParser::LOG_P:
      case GreenPlumParser::MASTER:
      case GreenPlumParser::MATCH:
      case GreenPlumParser::MAXVALUE:
      case GreenPlumParser::MEMORY_LIMIT:
      case GreenPlumParser::MEMORY_SHARED_QUOTA:
      case GreenPlumParser::MEMORY_SPILL_RATIO:
      case GreenPlumParser::MERGE:
      case GreenPlumParser::MINVALUE:
      case GreenPlumParser::MISSING:
      case GreenPlumParser::MODE:
      case GreenPlumParser::MODIFIES:
      case GreenPlumParser::MODIFY:
      case GreenPlumParser::MOVE:
      case GreenPlumParser::NAME_P:
      case GreenPlumParser::NAMES:
      case GreenPlumParser::NATIONAL:
      case GreenPlumParser::NCHAR:
      case GreenPlumParser::NEXT:
      case GreenPlumParser::NO:
      case GreenPlumParser::NOCREATEDB:
      case GreenPlumParser::NOCREATEROLE:
      case GreenPlumParser::NOCREATEUSER:
      case GreenPlumParser::NOINHERIT:
      case GreenPlumParser::NOLOGIN_P:
      case GreenPlumParser::NONE:
      case GreenPlumParser::NOOVERCOMMIT:
      case GreenPlumParser::NOSUPERUSER:
      case GreenPlumParser::NOTHING:
      case GreenPlumParser::NOTIFY:
      case GreenPlumParser::NOWAIT:
      case GreenPlumParser::NULLIF:
      case GreenPlumParser::NULLS_P:
      case GreenPlumParser::NUMERIC:
      case GreenPlumParser::OBJECT_P:
      case GreenPlumParser::OF:
      case GreenPlumParser::OIDS:
      case GreenPlumParser::OPERATOR:
      case GreenPlumParser::OPTION:
      case GreenPlumParser::OPTIONS:
      case GreenPlumParser::OTHERS:
      case GreenPlumParser::OUTER_P:
      case GreenPlumParser::OUT_P:
      case GreenPlumParser::OVERCOMMIT:
      case GreenPlumParser::OVERLAY:
      case GreenPlumParser::OWNED:
      case GreenPlumParser::OWNER:
      case GreenPlumParser::PARTIAL:
      case GreenPlumParser::PARTITIONS:
      case GreenPlumParser::PASSWORD:
      case GreenPlumParser::PERCENT:
      case GreenPlumParser::POSITION:
      case GreenPlumParser::PRECISION:
      case GreenPlumParser::PREPARE:
      case GreenPlumParser::PREPARED:
      case GreenPlumParser::PRESERVE:
      case GreenPlumParser::PRIOR:
      case GreenPlumParser::PRIVILEGES:
      case GreenPlumParser::PROCEDURAL:
      case GreenPlumParser::PROCEDURE:
      case GreenPlumParser::PROTOCOL:
      case GreenPlumParser::QUEUE:
      case GreenPlumParser::QUOTE:
      case GreenPlumParser::READ:
      case GreenPlumParser::REAL:
      case GreenPlumParser::REASSIGN:
      case GreenPlumParser::RECHECK:
      case GreenPlumParser::REINDEX:
      case GreenPlumParser::RELATIVE_P:
      case GreenPlumParser::RELEASE:
      case GreenPlumParser::RENAME:
      case GreenPlumParser::REPEATABLE:
      case GreenPlumParser::REPLACE:
      case GreenPlumParser::RESET:
      case GreenPlumParser::RESOURCE:
      case GreenPlumParser::RESTART:
      case GreenPlumParser::RESTRICT:
      case GreenPlumParser::RETURNS:
      case GreenPlumParser::REVOKE:
      case GreenPlumParser::ROLE:
      case GreenPlumParser::ROLLBACK:
      case GreenPlumParser::ROLLUP:
      case GreenPlumParser::ROW:
      case GreenPlumParser::RULE:
      case GreenPlumParser::SAVEPOINT:
      case GreenPlumParser::SCHEMA:
      case GreenPlumParser::SCROLL:
      case GreenPlumParser::SEARCH:
      case GreenPlumParser::SECURITY:
      case GreenPlumParser::SEGMENT:
      case GreenPlumParser::SEQUENCE:
      case GreenPlumParser::SERIALIZABLE:
      case GreenPlumParser::SESSION:
      case GreenPlumParser::SET:
      case GreenPlumParser::SETOF:
      case GreenPlumParser::SETS:
      case GreenPlumParser::SHARE:
      case GreenPlumParser::SHOW:
      case GreenPlumParser::SIMPLE:
      case GreenPlumParser::SMALLINT:
      case GreenPlumParser::SPLIT:
      case GreenPlumParser::SQL:
      case GreenPlumParser::STABLE:
      case GreenPlumParser::START:
      case GreenPlumParser::STATEMENT:
      case GreenPlumParser::STATISTICS:
      case GreenPlumParser::STDIN:
      case GreenPlumParser::STDOUT:
      case GreenPlumParser::STORAGE:
      case GreenPlumParser::STRICT_P:
      case GreenPlumParser::SUBPARTITION:
      case GreenPlumParser::SUBPARTITIONS:
      case GreenPlumParser::SUBSTRING:
      case GreenPlumParser::SUPERUSER_P:
      case GreenPlumParser::SYSID:
      case GreenPlumParser::SYSTEM_P:
      case GreenPlumParser::TEMP:
      case GreenPlumParser::TEMPLATE:
      case GreenPlumParser::TEMPORARY:
      case GreenPlumParser::THRESHOLD:
      case GreenPlumParser::TIES:
      case GreenPlumParser::TIME:
      case GreenPlumParser::TIMESTAMP:
      case GreenPlumParser::TRANSACTION:
      case GreenPlumParser::TREAT:
      case GreenPlumParser::TRIGGER:
      case GreenPlumParser::TRIM:
      case GreenPlumParser::TRUNCATE:
      case GreenPlumParser::TRUSTED:
      case GreenPlumParser::TYPE_P:
      case GreenPlumParser::UNCOMMITTED:
      case GreenPlumParser::UNENCRYPTED:
      case GreenPlumParser::UNKNOWN:
      case GreenPlumParser::UNLISTEN:
      case GreenPlumParser::UNTIL:
      case GreenPlumParser::UPDATE:
      case GreenPlumParser::VACUUM:
      case GreenPlumParser::VALID:
      case GreenPlumParser::VALIDATOR:
      case GreenPlumParser::VALUE_P:
      case GreenPlumParser::VALUES:
      case GreenPlumParser::VARCHAR:
      case GreenPlumParser::VERBOSE:
      case GreenPlumParser::VERSION_P:
      case GreenPlumParser::VIEW:
      case GreenPlumParser::VOLATILE:
      case GreenPlumParser::WORK:
      case GreenPlumParser::WRITE:
      case GreenPlumParser::ZONE: {
        enterOuterAlt(_localctx, 1);
        setState(6716);
        partition_ident_key_word();
        break;
      }

      case GreenPlumParser::CHAR_STRING:
      case GreenPlumParser::REGULAR_ID: {
        enterOuterAlt(_localctx, 2);
        setState(6717);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_ident_key_wordContext ------------------------------------------------------------------

GreenPlumParser::Partition_ident_key_wordContext::Partition_ident_key_wordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ABORT_P() {
  return getToken(GreenPlumParser::ABORT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ABSOLUTE_P() {
  return getToken(GreenPlumParser::ABSOLUTE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ACCESS() {
  return getToken(GreenPlumParser::ACCESS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ACTION() {
  return getToken(GreenPlumParser::ACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ACTIVE() {
  return getToken(GreenPlumParser::ACTIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ADMIN() {
  return getToken(GreenPlumParser::ADMIN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::AFTER() {
  return getToken(GreenPlumParser::AFTER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::AGGREGATE() {
  return getToken(GreenPlumParser::AGGREGATE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ALSO() {
  return getToken(GreenPlumParser::ALSO, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ASSERTION() {
  return getToken(GreenPlumParser::ASSERTION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ASSIGNMENT() {
  return getToken(GreenPlumParser::ASSIGNMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BACKWARD() {
  return getToken(GreenPlumParser::BACKWARD, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BEFORE() {
  return getToken(GreenPlumParser::BEFORE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BEGIN_P() {
  return getToken(GreenPlumParser::BEGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BY() {
  return getToken(GreenPlumParser::BY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CACHE() {
  return getToken(GreenPlumParser::CACHE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CALLED() {
  return getToken(GreenPlumParser::CALLED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CASCADE() {
  return getToken(GreenPlumParser::CASCADE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CASCADED() {
  return getToken(GreenPlumParser::CASCADED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CHAIN() {
  return getToken(GreenPlumParser::CHAIN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CHARACTERISTICS() {
  return getToken(GreenPlumParser::CHARACTERISTICS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CHECKPOINT() {
  return getToken(GreenPlumParser::CHECKPOINT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CLASS() {
  return getToken(GreenPlumParser::CLASS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CLOSE() {
  return getToken(GreenPlumParser::CLOSE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CLUSTER() {
  return getToken(GreenPlumParser::CLUSTER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::COMMENT() {
  return getToken(GreenPlumParser::COMMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::COMMIT() {
  return getToken(GreenPlumParser::COMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::COMMITTED() {
  return getToken(GreenPlumParser::COMMITTED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CONCURRENCY() {
  return getToken(GreenPlumParser::CONCURRENCY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CONCURRENTLY() {
  return getToken(GreenPlumParser::CONCURRENTLY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CONNECTION() {
  return getToken(GreenPlumParser::CONNECTION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CONSTRAINTS() {
  return getToken(GreenPlumParser::CONSTRAINTS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CONTAINS() {
  return getToken(GreenPlumParser::CONTAINS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CONTENT_P() {
  return getToken(GreenPlumParser::CONTENT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CONVERSION_P() {
  return getToken(GreenPlumParser::CONVERSION_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::COPY() {
  return getToken(GreenPlumParser::COPY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::COST() {
  return getToken(GreenPlumParser::COST, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CPU_RATE_LIMIT() {
  return getToken(GreenPlumParser::CPU_RATE_LIMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CPUSET() {
  return getToken(GreenPlumParser::CPUSET, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CREATEDB() {
  return getToken(GreenPlumParser::CREATEDB, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CREATEEXTTABLE() {
  return getToken(GreenPlumParser::CREATEEXTTABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CREATEROLE() {
  return getToken(GreenPlumParser::CREATEROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CREATEUSER() {
  return getToken(GreenPlumParser::CREATEUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CSV() {
  return getToken(GreenPlumParser::CSV, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CURSOR() {
  return getToken(GreenPlumParser::CURSOR, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CYCLE() {
  return getToken(GreenPlumParser::CYCLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DATABASE() {
  return getToken(GreenPlumParser::DATABASE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DEALLOCATE() {
  return getToken(GreenPlumParser::DEALLOCATE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DECLARE() {
  return getToken(GreenPlumParser::DECLARE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DEFAULTS() {
  return getToken(GreenPlumParser::DEFAULTS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DEFERRED() {
  return getToken(GreenPlumParser::DEFERRED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DEFINER() {
  return getToken(GreenPlumParser::DEFINER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DELETE_P() {
  return getToken(GreenPlumParser::DELETE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DELIMITER() {
  return getToken(GreenPlumParser::DELIMITER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DELIMITERS() {
  return getToken(GreenPlumParser::DELIMITERS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DISABLE_P() {
  return getToken(GreenPlumParser::DISABLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DOMAIN_P() {
  return getToken(GreenPlumParser::DOMAIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DOUBLE_P() {
  return getToken(GreenPlumParser::DOUBLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DROP() {
  return getToken(GreenPlumParser::DROP, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EACH() {
  return getToken(GreenPlumParser::EACH, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ENABLE_P() {
  return getToken(GreenPlumParser::ENABLE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ENCODING() {
  return getToken(GreenPlumParser::ENCODING, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ENCRYPTED() {
  return getToken(GreenPlumParser::ENCRYPTED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ERRORS() {
  return getToken(GreenPlumParser::ERRORS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ENUM_P() {
  return getToken(GreenPlumParser::ENUM_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ESCAPE() {
  return getToken(GreenPlumParser::ESCAPE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EVERY() {
  return getToken(GreenPlumParser::EVERY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXCHANGE() {
  return getToken(GreenPlumParser::EXCHANGE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXCLUDING() {
  return getToken(GreenPlumParser::EXCLUDING, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXCLUSIVE() {
  return getToken(GreenPlumParser::EXCLUSIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXECUTE() {
  return getToken(GreenPlumParser::EXECUTE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXPLAIN() {
  return getToken(GreenPlumParser::EXPLAIN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXTERNAL() {
  return getToken(GreenPlumParser::EXTERNAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FIELDS() {
  return getToken(GreenPlumParser::FIELDS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FILL() {
  return getToken(GreenPlumParser::FILL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FIRST_P() {
  return getToken(GreenPlumParser::FIRST_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FORCE() {
  return getToken(GreenPlumParser::FORCE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FORMAT() {
  return getToken(GreenPlumParser::FORMAT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FORWARD() {
  return getToken(GreenPlumParser::FORWARD, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FUNCTION() {
  return getToken(GreenPlumParser::FUNCTION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::GLOBAL() {
  return getToken(GreenPlumParser::GLOBAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::GRANTED() {
  return getToken(GreenPlumParser::GRANTED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::HANDLER() {
  return getToken(GreenPlumParser::HANDLER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::HASH() {
  return getToken(GreenPlumParser::HASH, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::HEADER_P() {
  return getToken(GreenPlumParser::HEADER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::HOLD() {
  return getToken(GreenPlumParser::HOLD, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::HOST() {
  return getToken(GreenPlumParser::HOST, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::IF_P() {
  return getToken(GreenPlumParser::IF_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::IMMEDIATE() {
  return getToken(GreenPlumParser::IMMEDIATE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::IMMUTABLE() {
  return getToken(GreenPlumParser::IMMUTABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::IMPLICIT_P() {
  return getToken(GreenPlumParser::IMPLICIT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INCLUDING() {
  return getToken(GreenPlumParser::INCLUDING, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INCLUSIVE() {
  return getToken(GreenPlumParser::INCLUSIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INCREMENT() {
  return getToken(GreenPlumParser::INCREMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INDEX() {
  return getToken(GreenPlumParser::INDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INDEXES() {
  return getToken(GreenPlumParser::INDEXES, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INHERIT() {
  return getToken(GreenPlumParser::INHERIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INHERITS() {
  return getToken(GreenPlumParser::INHERITS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INPUT_P() {
  return getToken(GreenPlumParser::INPUT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INSENSITIVE() {
  return getToken(GreenPlumParser::INSENSITIVE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INSERT() {
  return getToken(GreenPlumParser::INSERT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INSTEAD() {
  return getToken(GreenPlumParser::INSTEAD, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INVOKER() {
  return getToken(GreenPlumParser::INVOKER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ISOLATION() {
  return getToken(GreenPlumParser::ISOLATION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::KEY() {
  return getToken(GreenPlumParser::KEY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LANGUAGE() {
  return getToken(GreenPlumParser::LANGUAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LARGE_P() {
  return getToken(GreenPlumParser::LARGE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LAST_P() {
  return getToken(GreenPlumParser::LAST_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LEVEL() {
  return getToken(GreenPlumParser::LEVEL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LIST() {
  return getToken(GreenPlumParser::LIST, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LISTEN() {
  return getToken(GreenPlumParser::LISTEN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LOAD() {
  return getToken(GreenPlumParser::LOAD, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LOCAL() {
  return getToken(GreenPlumParser::LOCAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LOCATION() {
  return getToken(GreenPlumParser::LOCATION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LOCK_P() {
  return getToken(GreenPlumParser::LOCK_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LOGIN_P() {
  return getToken(GreenPlumParser::LOGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MASTER() {
  return getToken(GreenPlumParser::MASTER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MATCH() {
  return getToken(GreenPlumParser::MATCH, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MAXVALUE() {
  return getToken(GreenPlumParser::MAXVALUE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MEMORY_LIMIT() {
  return getToken(GreenPlumParser::MEMORY_LIMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MEMORY_SHARED_QUOTA() {
  return getToken(GreenPlumParser::MEMORY_SHARED_QUOTA, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MEMORY_SPILL_RATIO() {
  return getToken(GreenPlumParser::MEMORY_SPILL_RATIO, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MERGE() {
  return getToken(GreenPlumParser::MERGE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MINVALUE() {
  return getToken(GreenPlumParser::MINVALUE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MISSING() {
  return getToken(GreenPlumParser::MISSING, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MODE() {
  return getToken(GreenPlumParser::MODE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MODIFIES() {
  return getToken(GreenPlumParser::MODIFIES, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MODIFY() {
  return getToken(GreenPlumParser::MODIFY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::MOVE() {
  return getToken(GreenPlumParser::MOVE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NAME_P() {
  return getToken(GreenPlumParser::NAME_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NAMES() {
  return getToken(GreenPlumParser::NAMES, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NEXT() {
  return getToken(GreenPlumParser::NEXT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NO() {
  return getToken(GreenPlumParser::NO, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOCREATEDB() {
  return getToken(GreenPlumParser::NOCREATEDB, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOCREATEROLE() {
  return getToken(GreenPlumParser::NOCREATEROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOCREATEUSER() {
  return getToken(GreenPlumParser::NOCREATEUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOINHERIT() {
  return getToken(GreenPlumParser::NOINHERIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOLOGIN_P() {
  return getToken(GreenPlumParser::NOLOGIN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOOVERCOMMIT() {
  return getToken(GreenPlumParser::NOOVERCOMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOSUPERUSER() {
  return getToken(GreenPlumParser::NOSUPERUSER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOTHING() {
  return getToken(GreenPlumParser::NOTHING, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOTIFY() {
  return getToken(GreenPlumParser::NOTIFY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NOWAIT() {
  return getToken(GreenPlumParser::NOWAIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NULLS_P() {
  return getToken(GreenPlumParser::NULLS_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OBJECT_P() {
  return getToken(GreenPlumParser::OBJECT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OF() {
  return getToken(GreenPlumParser::OF, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OIDS() {
  return getToken(GreenPlumParser::OIDS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OPERATOR() {
  return getToken(GreenPlumParser::OPERATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OPTION() {
  return getToken(GreenPlumParser::OPTION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OPTIONS() {
  return getToken(GreenPlumParser::OPTIONS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OTHERS() {
  return getToken(GreenPlumParser::OTHERS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OVERCOMMIT() {
  return getToken(GreenPlumParser::OVERCOMMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OWNED() {
  return getToken(GreenPlumParser::OWNED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OWNER() {
  return getToken(GreenPlumParser::OWNER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PARTIAL() {
  return getToken(GreenPlumParser::PARTIAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PARTITIONS() {
  return getToken(GreenPlumParser::PARTITIONS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PASSWORD() {
  return getToken(GreenPlumParser::PASSWORD, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PERCENT() {
  return getToken(GreenPlumParser::PERCENT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PREPARE() {
  return getToken(GreenPlumParser::PREPARE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PREPARED() {
  return getToken(GreenPlumParser::PREPARED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PRESERVE() {
  return getToken(GreenPlumParser::PRESERVE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PRIOR() {
  return getToken(GreenPlumParser::PRIOR, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PRIVILEGES() {
  return getToken(GreenPlumParser::PRIVILEGES, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PROCEDURAL() {
  return getToken(GreenPlumParser::PROCEDURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PROCEDURE() {
  return getToken(GreenPlumParser::PROCEDURE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PROTOCOL() {
  return getToken(GreenPlumParser::PROTOCOL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::QUEUE() {
  return getToken(GreenPlumParser::QUEUE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::QUOTE() {
  return getToken(GreenPlumParser::QUOTE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::READ() {
  return getToken(GreenPlumParser::READ, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::REASSIGN() {
  return getToken(GreenPlumParser::REASSIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RECHECK() {
  return getToken(GreenPlumParser::RECHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::REINDEX() {
  return getToken(GreenPlumParser::REINDEX, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RELATIVE_P() {
  return getToken(GreenPlumParser::RELATIVE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RELEASE() {
  return getToken(GreenPlumParser::RELEASE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RENAME() {
  return getToken(GreenPlumParser::RENAME, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::REPEATABLE() {
  return getToken(GreenPlumParser::REPEATABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::REPLACE() {
  return getToken(GreenPlumParser::REPLACE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RESET() {
  return getToken(GreenPlumParser::RESET, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RESOURCE() {
  return getToken(GreenPlumParser::RESOURCE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RESTART() {
  return getToken(GreenPlumParser::RESTART, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RESTRICT() {
  return getToken(GreenPlumParser::RESTRICT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RETURNS() {
  return getToken(GreenPlumParser::RETURNS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::REVOKE() {
  return getToken(GreenPlumParser::REVOKE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ROLE() {
  return getToken(GreenPlumParser::ROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ROLLBACK() {
  return getToken(GreenPlumParser::ROLLBACK, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::RULE() {
  return getToken(GreenPlumParser::RULE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SAVEPOINT() {
  return getToken(GreenPlumParser::SAVEPOINT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SCHEMA() {
  return getToken(GreenPlumParser::SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SCROLL() {
  return getToken(GreenPlumParser::SCROLL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SEARCH() {
  return getToken(GreenPlumParser::SEARCH, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SECURITY() {
  return getToken(GreenPlumParser::SECURITY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SEGMENT() {
  return getToken(GreenPlumParser::SEGMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SEQUENCE() {
  return getToken(GreenPlumParser::SEQUENCE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SERIALIZABLE() {
  return getToken(GreenPlumParser::SERIALIZABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SESSION() {
  return getToken(GreenPlumParser::SESSION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SET() {
  return getToken(GreenPlumParser::SET, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SHARE() {
  return getToken(GreenPlumParser::SHARE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SHOW() {
  return getToken(GreenPlumParser::SHOW, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SIMPLE() {
  return getToken(GreenPlumParser::SIMPLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SPLIT() {
  return getToken(GreenPlumParser::SPLIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SQL() {
  return getToken(GreenPlumParser::SQL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::STABLE() {
  return getToken(GreenPlumParser::STABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::START() {
  return getToken(GreenPlumParser::START, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::STATEMENT() {
  return getToken(GreenPlumParser::STATEMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::STATISTICS() {
  return getToken(GreenPlumParser::STATISTICS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::STDIN() {
  return getToken(GreenPlumParser::STDIN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::STDOUT() {
  return getToken(GreenPlumParser::STDOUT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::STORAGE() {
  return getToken(GreenPlumParser::STORAGE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::STRICT_P() {
  return getToken(GreenPlumParser::STRICT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SUBPARTITION() {
  return getToken(GreenPlumParser::SUBPARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SUBPARTITIONS() {
  return getToken(GreenPlumParser::SUBPARTITIONS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SUPERUSER_P() {
  return getToken(GreenPlumParser::SUPERUSER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SYSID() {
  return getToken(GreenPlumParser::SYSID, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SYSTEM_P() {
  return getToken(GreenPlumParser::SYSTEM_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TEMP() {
  return getToken(GreenPlumParser::TEMP, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TEMPLATE() {
  return getToken(GreenPlumParser::TEMPLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TEMPORARY() {
  return getToken(GreenPlumParser::TEMPORARY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::THRESHOLD() {
  return getToken(GreenPlumParser::THRESHOLD, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TIES() {
  return getToken(GreenPlumParser::TIES, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TRANSACTION() {
  return getToken(GreenPlumParser::TRANSACTION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TRIGGER() {
  return getToken(GreenPlumParser::TRIGGER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TRUNCATE() {
  return getToken(GreenPlumParser::TRUNCATE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TRUSTED() {
  return getToken(GreenPlumParser::TRUSTED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TYPE_P() {
  return getToken(GreenPlumParser::TYPE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::UNCOMMITTED() {
  return getToken(GreenPlumParser::UNCOMMITTED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::UNENCRYPTED() {
  return getToken(GreenPlumParser::UNENCRYPTED, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::UNKNOWN() {
  return getToken(GreenPlumParser::UNKNOWN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::UNLISTEN() {
  return getToken(GreenPlumParser::UNLISTEN, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::UNTIL() {
  return getToken(GreenPlumParser::UNTIL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::UPDATE() {
  return getToken(GreenPlumParser::UPDATE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VACUUM() {
  return getToken(GreenPlumParser::VACUUM, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VALID() {
  return getToken(GreenPlumParser::VALID, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VALIDATOR() {
  return getToken(GreenPlumParser::VALIDATOR, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VERSION_P() {
  return getToken(GreenPlumParser::VERSION_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VIEW() {
  return getToken(GreenPlumParser::VIEW, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VALUE_P() {
  return getToken(GreenPlumParser::VALUE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VOLATILE() {
  return getToken(GreenPlumParser::VOLATILE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::WORK() {
  return getToken(GreenPlumParser::WORK, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::WRITE() {
  return getToken(GreenPlumParser::WRITE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ZONE() {
  return getToken(GreenPlumParser::ZONE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BIGINT() {
  return getToken(GreenPlumParser::BIGINT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BIT() {
  return getToken(GreenPlumParser::BIT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BOOLEAN_P() {
  return getToken(GreenPlumParser::BOOLEAN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::COALESCE() {
  return getToken(GreenPlumParser::COALESCE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::CUBE() {
  return getToken(GreenPlumParser::CUBE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DEC() {
  return getToken(GreenPlumParser::DEC, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::DECIMAL_P() {
  return getToken(GreenPlumParser::DECIMAL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::EXTRACT() {
  return getToken(GreenPlumParser::EXTRACT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FLOAT_P() {
  return getToken(GreenPlumParser::FLOAT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::GREATEST() {
  return getToken(GreenPlumParser::GREATEST, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::GROUP_ID() {
  return getToken(GreenPlumParser::GROUP_ID, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::GROUPING() {
  return getToken(GreenPlumParser::GROUPING, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INOUT() {
  return getToken(GreenPlumParser::INOUT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INT_P() {
  return getToken(GreenPlumParser::INT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INTEGER() {
  return getToken(GreenPlumParser::INTEGER, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::INTERVAL() {
  return getToken(GreenPlumParser::INTERVAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LEAST() {
  return getToken(GreenPlumParser::LEAST, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NATIONAL() {
  return getToken(GreenPlumParser::NATIONAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NCHAR() {
  return getToken(GreenPlumParser::NCHAR, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NONE() {
  return getToken(GreenPlumParser::NONE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NULLIF() {
  return getToken(GreenPlumParser::NULLIF, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::NUMERIC() {
  return getToken(GreenPlumParser::NUMERIC, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OUT_P() {
  return getToken(GreenPlumParser::OUT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OVERLAY() {
  return getToken(GreenPlumParser::OVERLAY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::POSITION() {
  return getToken(GreenPlumParser::POSITION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::PRECISION() {
  return getToken(GreenPlumParser::PRECISION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::REAL() {
  return getToken(GreenPlumParser::REAL, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ROLLUP() {
  return getToken(GreenPlumParser::ROLLUP, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SETOF() {
  return getToken(GreenPlumParser::SETOF, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SETS() {
  return getToken(GreenPlumParser::SETS, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SMALLINT() {
  return getToken(GreenPlumParser::SMALLINT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::SUBSTRING() {
  return getToken(GreenPlumParser::SUBSTRING, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TIMESTAMP() {
  return getToken(GreenPlumParser::TIMESTAMP, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TREAT() {
  return getToken(GreenPlumParser::TREAT, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::TRIM() {
  return getToken(GreenPlumParser::TRIM, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VALUES() {
  return getToken(GreenPlumParser::VALUES, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VARCHAR() {
  return getToken(GreenPlumParser::VARCHAR, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::AUTHORIZATION() {
  return getToken(GreenPlumParser::AUTHORIZATION, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::BINARY() {
  return getToken(GreenPlumParser::BINARY, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::FREEZE() {
  return getToken(GreenPlumParser::FREEZE, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::LOG_P() {
  return getToken(GreenPlumParser::LOG_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::OUTER_P() {
  return getToken(GreenPlumParser::OUTER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Partition_ident_key_wordContext::VERBOSE() {
  return getToken(GreenPlumParser::VERBOSE, 0);
}


size_t GreenPlumParser::Partition_ident_key_wordContext::getRuleIndex() const {
  return GreenPlumParser::RulePartition_ident_key_word;
}

void GreenPlumParser::Partition_ident_key_wordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartition_ident_key_word(this);
}

void GreenPlumParser::Partition_ident_key_wordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartition_ident_key_word(this);
}


antlrcpp::Any GreenPlumParser::Partition_ident_key_wordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitPartition_ident_key_word(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Partition_ident_key_wordContext* GreenPlumParser::partition_ident_key_word() {
  Partition_ident_key_wordContext *_localctx = _tracker.createInstance<Partition_ident_key_wordContext>(_ctx, getState());
  enterRule(_localctx, 1062, GreenPlumParser::RulePartition_ident_key_word);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6720);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ABORT_P)
      | (1ULL << GreenPlumParser::ABSOLUTE_P)
      | (1ULL << GreenPlumParser::ACCESS)
      | (1ULL << GreenPlumParser::ACTION)
      | (1ULL << GreenPlumParser::ACTIVE)
      | (1ULL << GreenPlumParser::ADMIN)
      | (1ULL << GreenPlumParser::AFTER)
      | (1ULL << GreenPlumParser::AGGREGATE)
      | (1ULL << GreenPlumParser::ALSO)
      | (1ULL << GreenPlumParser::ASSERTION)
      | (1ULL << GreenPlumParser::ASSIGNMENT)
      | (1ULL << GreenPlumParser::AUTHORIZATION)
      | (1ULL << GreenPlumParser::BACKWARD)
      | (1ULL << GreenPlumParser::BEFORE)
      | (1ULL << GreenPlumParser::BEGIN_P)
      | (1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BINARY)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::BY)
      | (1ULL << GreenPlumParser::CACHE)
      | (1ULL << GreenPlumParser::CALLED)
      | (1ULL << GreenPlumParser::CASCADE)
      | (1ULL << GreenPlumParser::CASCADED)
      | (1ULL << GreenPlumParser::CHAIN)
      | (1ULL << GreenPlumParser::CHARACTERISTICS)
      | (1ULL << GreenPlumParser::CHECKPOINT)
      | (1ULL << GreenPlumParser::CLASS)
      | (1ULL << GreenPlumParser::CLOSE)
      | (1ULL << GreenPlumParser::CLUSTER)
      | (1ULL << GreenPlumParser::COALESCE)
      | (1ULL << GreenPlumParser::COMMENT)
      | (1ULL << GreenPlumParser::COMMIT)
      | (1ULL << GreenPlumParser::COMMITTED)
      | (1ULL << GreenPlumParser::CONCURRENCY)
      | (1ULL << GreenPlumParser::CONCURRENTLY)
      | (1ULL << GreenPlumParser::CONNECTION))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (GreenPlumParser::CONSTRAINTS - 64))
      | (1ULL << (GreenPlumParser::CONTAINS - 64))
      | (1ULL << (GreenPlumParser::CONTENT_P - 64))
      | (1ULL << (GreenPlumParser::CONVERSION_P - 64))
      | (1ULL << (GreenPlumParser::COPY - 64))
      | (1ULL << (GreenPlumParser::COST - 64))
      | (1ULL << (GreenPlumParser::CPU_RATE_LIMIT - 64))
      | (1ULL << (GreenPlumParser::CPUSET - 64))
      | (1ULL << (GreenPlumParser::CREATEDB - 64))
      | (1ULL << (GreenPlumParser::CREATEEXTTABLE - 64))
      | (1ULL << (GreenPlumParser::CREATEROLE - 64))
      | (1ULL << (GreenPlumParser::CREATEUSER - 64))
      | (1ULL << (GreenPlumParser::CSV - 64))
      | (1ULL << (GreenPlumParser::CUBE - 64))
      | (1ULL << (GreenPlumParser::CURSOR - 64))
      | (1ULL << (GreenPlumParser::CYCLE - 64))
      | (1ULL << (GreenPlumParser::DATABASE - 64))
      | (1ULL << (GreenPlumParser::DEALLOCATE - 64))
      | (1ULL << (GreenPlumParser::DEC - 64))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 64))
      | (1ULL << (GreenPlumParser::DECLARE - 64))
      | (1ULL << (GreenPlumParser::DEFAULTS - 64))
      | (1ULL << (GreenPlumParser::DEFERRED - 64))
      | (1ULL << (GreenPlumParser::DEFINER - 64))
      | (1ULL << (GreenPlumParser::DELETE_P - 64))
      | (1ULL << (GreenPlumParser::DELIMITER - 64))
      | (1ULL << (GreenPlumParser::DELIMITERS - 64))
      | (1ULL << (GreenPlumParser::DISABLE_P - 64))
      | (1ULL << (GreenPlumParser::DOMAIN_P - 64))
      | (1ULL << (GreenPlumParser::DOUBLE_P - 64))
      | (1ULL << (GreenPlumParser::DROP - 64))
      | (1ULL << (GreenPlumParser::EACH - 64))
      | (1ULL << (GreenPlumParser::ENABLE_P - 64))
      | (1ULL << (GreenPlumParser::ENCODING - 64))
      | (1ULL << (GreenPlumParser::ENCRYPTED - 64))
      | (1ULL << (GreenPlumParser::ENUM_P - 64))
      | (1ULL << (GreenPlumParser::ERRORS - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (GreenPlumParser::ESCAPE - 128))
      | (1ULL << (GreenPlumParser::EVERY - 128))
      | (1ULL << (GreenPlumParser::EXCHANGE - 128))
      | (1ULL << (GreenPlumParser::EXCLUDING - 128))
      | (1ULL << (GreenPlumParser::EXCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::EXECUTE - 128))
      | (1ULL << (GreenPlumParser::EXISTS - 128))
      | (1ULL << (GreenPlumParser::EXPLAIN - 128))
      | (1ULL << (GreenPlumParser::EXTERNAL - 128))
      | (1ULL << (GreenPlumParser::EXTRACT - 128))
      | (1ULL << (GreenPlumParser::FIELDS - 128))
      | (1ULL << (GreenPlumParser::FILL - 128))
      | (1ULL << (GreenPlumParser::FIRST_P - 128))
      | (1ULL << (GreenPlumParser::FLOAT_P - 128))
      | (1ULL << (GreenPlumParser::FORCE - 128))
      | (1ULL << (GreenPlumParser::FORMAT - 128))
      | (1ULL << (GreenPlumParser::FORWARD - 128))
      | (1ULL << (GreenPlumParser::FREEZE - 128))
      | (1ULL << (GreenPlumParser::FUNCTION - 128))
      | (1ULL << (GreenPlumParser::GLOBAL - 128))
      | (1ULL << (GreenPlumParser::GRANTED - 128))
      | (1ULL << (GreenPlumParser::GREATEST - 128))
      | (1ULL << (GreenPlumParser::GROUP_ID - 128))
      | (1ULL << (GreenPlumParser::GROUPING - 128))
      | (1ULL << (GreenPlumParser::HANDLER - 128))
      | (1ULL << (GreenPlumParser::HASH - 128))
      | (1ULL << (GreenPlumParser::HEADER_P - 128))
      | (1ULL << (GreenPlumParser::HOLD - 128))
      | (1ULL << (GreenPlumParser::HOST - 128))
      | (1ULL << (GreenPlumParser::IF_P - 128))
      | (1ULL << (GreenPlumParser::IMMEDIATE - 128))
      | (1ULL << (GreenPlumParser::IMMUTABLE - 128))
      | (1ULL << (GreenPlumParser::IMPLICIT_P - 128))
      | (1ULL << (GreenPlumParser::INCLUDING - 128))
      | (1ULL << (GreenPlumParser::INCLUSIVE - 128))
      | (1ULL << (GreenPlumParser::INCREMENT - 128))
      | (1ULL << (GreenPlumParser::INDEX - 128))
      | (1ULL << (GreenPlumParser::INDEXES - 128))
      | (1ULL << (GreenPlumParser::INHERIT - 128))
      | (1ULL << (GreenPlumParser::INHERITS - 128))
      | (1ULL << (GreenPlumParser::INOUT - 128)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (GreenPlumParser::INPUT_P - 193))
      | (1ULL << (GreenPlumParser::INSENSITIVE - 193))
      | (1ULL << (GreenPlumParser::INSERT - 193))
      | (1ULL << (GreenPlumParser::INSTEAD - 193))
      | (1ULL << (GreenPlumParser::INTEGER - 193))
      | (1ULL << (GreenPlumParser::INTERVAL - 193))
      | (1ULL << (GreenPlumParser::INT_P - 193))
      | (1ULL << (GreenPlumParser::INVOKER - 193))
      | (1ULL << (GreenPlumParser::ISOLATION - 193))
      | (1ULL << (GreenPlumParser::KEY - 193))
      | (1ULL << (GreenPlumParser::LANGUAGE - 193))
      | (1ULL << (GreenPlumParser::LARGE_P - 193))
      | (1ULL << (GreenPlumParser::LAST_P - 193))
      | (1ULL << (GreenPlumParser::LEAST - 193))
      | (1ULL << (GreenPlumParser::LEVEL - 193))
      | (1ULL << (GreenPlumParser::LIST - 193))
      | (1ULL << (GreenPlumParser::LISTEN - 193))
      | (1ULL << (GreenPlumParser::LOAD - 193))
      | (1ULL << (GreenPlumParser::LOCAL - 193))
      | (1ULL << (GreenPlumParser::LOCATION - 193))
      | (1ULL << (GreenPlumParser::LOCK_P - 193))
      | (1ULL << (GreenPlumParser::LOGIN_P - 193))
      | (1ULL << (GreenPlumParser::LOG_P - 193))
      | (1ULL << (GreenPlumParser::MASTER - 193))
      | (1ULL << (GreenPlumParser::MATCH - 193))
      | (1ULL << (GreenPlumParser::MAXVALUE - 193))
      | (1ULL << (GreenPlumParser::MEMORY_LIMIT - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SHARED_QUOTA - 193))
      | (1ULL << (GreenPlumParser::MEMORY_SPILL_RATIO - 193))
      | (1ULL << (GreenPlumParser::MERGE - 193))
      | (1ULL << (GreenPlumParser::MINVALUE - 193))
      | (1ULL << (GreenPlumParser::MISSING - 193))
      | (1ULL << (GreenPlumParser::MODE - 193))
      | (1ULL << (GreenPlumParser::MODIFIES - 193))
      | (1ULL << (GreenPlumParser::MODIFY - 193))
      | (1ULL << (GreenPlumParser::MOVE - 193))
      | (1ULL << (GreenPlumParser::NAME_P - 193))
      | (1ULL << (GreenPlumParser::NAMES - 193))
      | (1ULL << (GreenPlumParser::NATIONAL - 193))
      | (1ULL << (GreenPlumParser::NCHAR - 193))
      | (1ULL << (GreenPlumParser::NEXT - 193))
      | (1ULL << (GreenPlumParser::NO - 193))
      | (1ULL << (GreenPlumParser::NOCREATEDB - 193))
      | (1ULL << (GreenPlumParser::NOCREATEROLE - 193))
      | (1ULL << (GreenPlumParser::NOCREATEUSER - 193)))) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & ((1ULL << (GreenPlumParser::NOINHERIT - 257))
      | (1ULL << (GreenPlumParser::NOLOGIN_P - 257))
      | (1ULL << (GreenPlumParser::NONE - 257))
      | (1ULL << (GreenPlumParser::NOOVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::NOSUPERUSER - 257))
      | (1ULL << (GreenPlumParser::NOTHING - 257))
      | (1ULL << (GreenPlumParser::NOTIFY - 257))
      | (1ULL << (GreenPlumParser::NOWAIT - 257))
      | (1ULL << (GreenPlumParser::NULLIF - 257))
      | (1ULL << (GreenPlumParser::NULLS_P - 257))
      | (1ULL << (GreenPlumParser::NUMERIC - 257))
      | (1ULL << (GreenPlumParser::OBJECT_P - 257))
      | (1ULL << (GreenPlumParser::OF - 257))
      | (1ULL << (GreenPlumParser::OIDS - 257))
      | (1ULL << (GreenPlumParser::OPERATOR - 257))
      | (1ULL << (GreenPlumParser::OPTION - 257))
      | (1ULL << (GreenPlumParser::OPTIONS - 257))
      | (1ULL << (GreenPlumParser::OTHERS - 257))
      | (1ULL << (GreenPlumParser::OUTER_P - 257))
      | (1ULL << (GreenPlumParser::OUT_P - 257))
      | (1ULL << (GreenPlumParser::OVERCOMMIT - 257))
      | (1ULL << (GreenPlumParser::OVERLAY - 257))
      | (1ULL << (GreenPlumParser::OWNED - 257))
      | (1ULL << (GreenPlumParser::OWNER - 257))
      | (1ULL << (GreenPlumParser::PARTIAL - 257))
      | (1ULL << (GreenPlumParser::PARTITIONS - 257))
      | (1ULL << (GreenPlumParser::PASSWORD - 257))
      | (1ULL << (GreenPlumParser::PERCENT - 257))
      | (1ULL << (GreenPlumParser::POSITION - 257))
      | (1ULL << (GreenPlumParser::PRECISION - 257))
      | (1ULL << (GreenPlumParser::PREPARE - 257))
      | (1ULL << (GreenPlumParser::PREPARED - 257))
      | (1ULL << (GreenPlumParser::PRESERVE - 257))
      | (1ULL << (GreenPlumParser::PRIOR - 257))
      | (1ULL << (GreenPlumParser::PRIVILEGES - 257))
      | (1ULL << (GreenPlumParser::PROCEDURAL - 257))
      | (1ULL << (GreenPlumParser::PROCEDURE - 257))
      | (1ULL << (GreenPlumParser::PROTOCOL - 257)))) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (GreenPlumParser::QUEUE - 321))
      | (1ULL << (GreenPlumParser::QUOTE - 321))
      | (1ULL << (GreenPlumParser::READ - 321))
      | (1ULL << (GreenPlumParser::REAL - 321))
      | (1ULL << (GreenPlumParser::REASSIGN - 321))
      | (1ULL << (GreenPlumParser::RECHECK - 321))
      | (1ULL << (GreenPlumParser::REINDEX - 321))
      | (1ULL << (GreenPlumParser::RELATIVE_P - 321))
      | (1ULL << (GreenPlumParser::RELEASE - 321))
      | (1ULL << (GreenPlumParser::RENAME - 321))
      | (1ULL << (GreenPlumParser::REPEATABLE - 321))
      | (1ULL << (GreenPlumParser::REPLACE - 321))
      | (1ULL << (GreenPlumParser::RESET - 321))
      | (1ULL << (GreenPlumParser::RESOURCE - 321))
      | (1ULL << (GreenPlumParser::RESTART - 321))
      | (1ULL << (GreenPlumParser::RESTRICT - 321))
      | (1ULL << (GreenPlumParser::RETURNS - 321))
      | (1ULL << (GreenPlumParser::REVOKE - 321))
      | (1ULL << (GreenPlumParser::ROLE - 321))
      | (1ULL << (GreenPlumParser::ROLLBACK - 321))
      | (1ULL << (GreenPlumParser::ROLLUP - 321))
      | (1ULL << (GreenPlumParser::ROW - 321))
      | (1ULL << (GreenPlumParser::RULE - 321))
      | (1ULL << (GreenPlumParser::SAVEPOINT - 321))
      | (1ULL << (GreenPlumParser::SCHEMA - 321))
      | (1ULL << (GreenPlumParser::SCROLL - 321))
      | (1ULL << (GreenPlumParser::SEARCH - 321))
      | (1ULL << (GreenPlumParser::SECURITY - 321))
      | (1ULL << (GreenPlumParser::SEGMENT - 321))
      | (1ULL << (GreenPlumParser::SEQUENCE - 321))
      | (1ULL << (GreenPlumParser::SERIALIZABLE - 321))
      | (1ULL << (GreenPlumParser::SESSION - 321))
      | (1ULL << (GreenPlumParser::SET - 321))
      | (1ULL << (GreenPlumParser::SETOF - 321))
      | (1ULL << (GreenPlumParser::SETS - 321))
      | (1ULL << (GreenPlumParser::SHARE - 321))
      | (1ULL << (GreenPlumParser::SHOW - 321))
      | (1ULL << (GreenPlumParser::SIMPLE - 321))
      | (1ULL << (GreenPlumParser::SMALLINT - 321))
      | (1ULL << (GreenPlumParser::SPLIT - 321))
      | (1ULL << (GreenPlumParser::SQL - 321))
      | (1ULL << (GreenPlumParser::STABLE - 321))
      | (1ULL << (GreenPlumParser::START - 321))
      | (1ULL << (GreenPlumParser::STATEMENT - 321)))) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & ((1ULL << (GreenPlumParser::STATISTICS - 385))
      | (1ULL << (GreenPlumParser::STDIN - 385))
      | (1ULL << (GreenPlumParser::STDOUT - 385))
      | (1ULL << (GreenPlumParser::STORAGE - 385))
      | (1ULL << (GreenPlumParser::STRICT_P - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITION - 385))
      | (1ULL << (GreenPlumParser::SUBPARTITIONS - 385))
      | (1ULL << (GreenPlumParser::SUBSTRING - 385))
      | (1ULL << (GreenPlumParser::SUPERUSER_P - 385))
      | (1ULL << (GreenPlumParser::SYSID - 385))
      | (1ULL << (GreenPlumParser::SYSTEM_P - 385))
      | (1ULL << (GreenPlumParser::TEMP - 385))
      | (1ULL << (GreenPlumParser::TEMPLATE - 385))
      | (1ULL << (GreenPlumParser::TEMPORARY - 385))
      | (1ULL << (GreenPlumParser::THRESHOLD - 385))
      | (1ULL << (GreenPlumParser::TIES - 385))
      | (1ULL << (GreenPlumParser::TIME - 385))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 385))
      | (1ULL << (GreenPlumParser::TRANSACTION - 385))
      | (1ULL << (GreenPlumParser::TREAT - 385))
      | (1ULL << (GreenPlumParser::TRIGGER - 385))
      | (1ULL << (GreenPlumParser::TRIM - 385))
      | (1ULL << (GreenPlumParser::TRUNCATE - 385))
      | (1ULL << (GreenPlumParser::TRUSTED - 385))
      | (1ULL << (GreenPlumParser::TYPE_P - 385))
      | (1ULL << (GreenPlumParser::UNCOMMITTED - 385))
      | (1ULL << (GreenPlumParser::UNENCRYPTED - 385))
      | (1ULL << (GreenPlumParser::UNKNOWN - 385))
      | (1ULL << (GreenPlumParser::UNLISTEN - 385))
      | (1ULL << (GreenPlumParser::UNTIL - 385))
      | (1ULL << (GreenPlumParser::UPDATE - 385))
      | (1ULL << (GreenPlumParser::VACUUM - 385))
      | (1ULL << (GreenPlumParser::VALID - 385))
      | (1ULL << (GreenPlumParser::VALIDATOR - 385))
      | (1ULL << (GreenPlumParser::VALUE_P - 385))
      | (1ULL << (GreenPlumParser::VALUES - 385))
      | (1ULL << (GreenPlumParser::VARCHAR - 385))
      | (1ULL << (GreenPlumParser::VERBOSE - 385))
      | (1ULL << (GreenPlumParser::VERSION_P - 385))
      | (1ULL << (GreenPlumParser::VIEW - 385))
      | (1ULL << (GreenPlumParser::VOLATILE - 385)))) != 0) || ((((_la - 453) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 453)) & ((1ULL << (GreenPlumParser::WORK - 453))
      | (1ULL << (GreenPlumParser::WRITE - 453))
      | (1ULL << (GreenPlumParser::ZONE - 453)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Col_name_keywordContext ------------------------------------------------------------------

GreenPlumParser::Col_name_keywordContext::Col_name_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::BIGINT() {
  return getToken(GreenPlumParser::BIGINT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::BIT() {
  return getToken(GreenPlumParser::BIT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::BOOLEAN_P() {
  return getToken(GreenPlumParser::BOOLEAN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::CHAR_P() {
  return getToken(GreenPlumParser::CHAR_P, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::CHARACTER() {
  return getToken(GreenPlumParser::CHARACTER, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::COALESCE() {
  return getToken(GreenPlumParser::COALESCE, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::CUBE() {
  return getToken(GreenPlumParser::CUBE, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::DEC() {
  return getToken(GreenPlumParser::DEC, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::DECIMAL_P() {
  return getToken(GreenPlumParser::DECIMAL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::EXISTS() {
  return getToken(GreenPlumParser::EXISTS, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::EXTRACT() {
  return getToken(GreenPlumParser::EXTRACT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::FLOAT_P() {
  return getToken(GreenPlumParser::FLOAT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::GREATEST() {
  return getToken(GreenPlumParser::GREATEST, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::GROUPING() {
  return getToken(GreenPlumParser::GROUPING, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::GROUP_ID() {
  return getToken(GreenPlumParser::GROUP_ID, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::INOUT() {
  return getToken(GreenPlumParser::INOUT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::INT_P() {
  return getToken(GreenPlumParser::INT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::INTEGER() {
  return getToken(GreenPlumParser::INTEGER, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::INTERVAL() {
  return getToken(GreenPlumParser::INTERVAL, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::LEAST() {
  return getToken(GreenPlumParser::LEAST, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::MEDIAN() {
  return getToken(GreenPlumParser::MEDIAN, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::NATIONAL() {
  return getToken(GreenPlumParser::NATIONAL, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::NCHAR() {
  return getToken(GreenPlumParser::NCHAR, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::NONE() {
  return getToken(GreenPlumParser::NONE, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::NULLIF() {
  return getToken(GreenPlumParser::NULLIF, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::NUMERIC() {
  return getToken(GreenPlumParser::NUMERIC, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::OUT_P() {
  return getToken(GreenPlumParser::OUT_P, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::OVERLAY() {
  return getToken(GreenPlumParser::OVERLAY, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::PERCENTILE_CONT() {
  return getToken(GreenPlumParser::PERCENTILE_CONT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::PERCENTILE_DISC() {
  return getToken(GreenPlumParser::PERCENTILE_DISC, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::POSITION() {
  return getToken(GreenPlumParser::POSITION, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::PRECISION() {
  return getToken(GreenPlumParser::PRECISION, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::REAL() {
  return getToken(GreenPlumParser::REAL, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::ROLLUP() {
  return getToken(GreenPlumParser::ROLLUP, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::ROW() {
  return getToken(GreenPlumParser::ROW, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::SETOF() {
  return getToken(GreenPlumParser::SETOF, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::SETS() {
  return getToken(GreenPlumParser::SETS, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::SMALLINT() {
  return getToken(GreenPlumParser::SMALLINT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::SUBSTRING() {
  return getToken(GreenPlumParser::SUBSTRING, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::TIME() {
  return getToken(GreenPlumParser::TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::TIMESTAMP() {
  return getToken(GreenPlumParser::TIMESTAMP, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::TREAT() {
  return getToken(GreenPlumParser::TREAT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::TRIM() {
  return getToken(GreenPlumParser::TRIM, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::VALUES() {
  return getToken(GreenPlumParser::VALUES, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::VARCHAR() {
  return getToken(GreenPlumParser::VARCHAR, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLATTRIBUTES() {
  return getToken(GreenPlumParser::XMLATTRIBUTES, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLCONCAT() {
  return getToken(GreenPlumParser::XMLCONCAT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLELEMENT() {
  return getToken(GreenPlumParser::XMLELEMENT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLEXISTS() {
  return getToken(GreenPlumParser::XMLEXISTS, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLFOREST() {
  return getToken(GreenPlumParser::XMLFOREST, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLPARSE() {
  return getToken(GreenPlumParser::XMLPARSE, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLPI() {
  return getToken(GreenPlumParser::XMLPI, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLROOT() {
  return getToken(GreenPlumParser::XMLROOT, 0);
}

tree::TerminalNode* GreenPlumParser::Col_name_keywordContext::XMLSERIALIZE() {
  return getToken(GreenPlumParser::XMLSERIALIZE, 0);
}


size_t GreenPlumParser::Col_name_keywordContext::getRuleIndex() const {
  return GreenPlumParser::RuleCol_name_keyword;
}

void GreenPlumParser::Col_name_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCol_name_keyword(this);
}

void GreenPlumParser::Col_name_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCol_name_keyword(this);
}


antlrcpp::Any GreenPlumParser::Col_name_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitCol_name_keyword(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Col_name_keywordContext* GreenPlumParser::col_name_keyword() {
  Col_name_keywordContext *_localctx = _tracker.createInstance<Col_name_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1064, GreenPlumParser::RuleCol_name_keyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6722);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::BIGINT)
      | (1ULL << GreenPlumParser::BIT)
      | (1ULL << GreenPlumParser::BOOLEAN_P)
      | (1ULL << GreenPlumParser::CHARACTER)
      | (1ULL << GreenPlumParser::CHAR_P)
      | (1ULL << GreenPlumParser::COALESCE))) != 0) || ((((_la - 80) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 80)) & ((1ULL << (GreenPlumParser::CUBE - 80))
      | (1ULL << (GreenPlumParser::DEC - 80))
      | (1ULL << (GreenPlumParser::DECIMAL_P - 80))
      | (1ULL << (GreenPlumParser::EXISTS - 80))
      | (1ULL << (GreenPlumParser::EXTRACT - 80)))) != 0) || ((((_la - 149) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 149)) & ((1ULL << (GreenPlumParser::FLOAT_P - 149))
      | (1ULL << (GreenPlumParser::GREATEST - 149))
      | (1ULL << (GreenPlumParser::GROUP_ID - 149))
      | (1ULL << (GreenPlumParser::GROUPING - 149))
      | (1ULL << (GreenPlumParser::INOUT - 149))
      | (1ULL << (GreenPlumParser::INTEGER - 149))
      | (1ULL << (GreenPlumParser::INTERVAL - 149))
      | (1ULL << (GreenPlumParser::INT_P - 149))
      | (1ULL << (GreenPlumParser::LEAST - 149)))) != 0) || ((((_la - 231) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 231)) & ((1ULL << (GreenPlumParser::MEDIAN - 231))
      | (1ULL << (GreenPlumParser::NATIONAL - 231))
      | (1ULL << (GreenPlumParser::NCHAR - 231))
      | (1ULL << (GreenPlumParser::NONE - 231))
      | (1ULL << (GreenPlumParser::NULLIF - 231))
      | (1ULL << (GreenPlumParser::NUMERIC - 231))
      | (1ULL << (GreenPlumParser::OUT_P - 231))
      | (1ULL << (GreenPlumParser::OVERLAY - 231)))) != 0) || ((((_la - 303) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 303)) & ((1ULL << (GreenPlumParser::PERCENTILE_CONT - 303))
      | (1ULL << (GreenPlumParser::PERCENTILE_DISC - 303))
      | (1ULL << (GreenPlumParser::POSITION - 303))
      | (1ULL << (GreenPlumParser::PRECISION - 303))
      | (1ULL << (GreenPlumParser::REAL - 303))
      | (1ULL << (GreenPlumParser::ROLLUP - 303))
      | (1ULL << (GreenPlumParser::ROW - 303)))) != 0) || ((((_la - 371) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 371)) & ((1ULL << (GreenPlumParser::SETOF - 371))
      | (1ULL << (GreenPlumParser::SETS - 371))
      | (1ULL << (GreenPlumParser::SMALLINT - 371))
      | (1ULL << (GreenPlumParser::SUBSTRING - 371))
      | (1ULL << (GreenPlumParser::TIME - 371))
      | (1ULL << (GreenPlumParser::TIMESTAMP - 371))
      | (1ULL << (GreenPlumParser::TREAT - 371))
      | (1ULL << (GreenPlumParser::TRIM - 371)))) != 0) || ((((_la - 437) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 437)) & ((1ULL << (GreenPlumParser::VALUES - 437))
      | (1ULL << (GreenPlumParser::VARCHAR - 437))
      | (1ULL << (GreenPlumParser::XMLATTRIBUTES - 437))
      | (1ULL << (GreenPlumParser::XMLCONCAT - 437))
      | (1ULL << (GreenPlumParser::XMLELEMENT - 437))
      | (1ULL << (GreenPlumParser::XMLEXISTS - 437))
      | (1ULL << (GreenPlumParser::XMLFOREST - 437))
      | (1ULL << (GreenPlumParser::XMLPARSE - 437))
      | (1ULL << (GreenPlumParser::XMLPI - 437))
      | (1ULL << (GreenPlumParser::XMLROOT - 437))
      | (1ULL << (GreenPlumParser::XMLSERIALIZE - 437)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_func_name_keywordContext ------------------------------------------------------------------

GreenPlumParser::Type_func_name_keywordContext::Type_func_name_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::AUTHORIZATION() {
  return getToken(GreenPlumParser::AUTHORIZATION, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::BINARY() {
  return getToken(GreenPlumParser::BINARY, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::CROSS() {
  return getToken(GreenPlumParser::CROSS, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::CURRENT_SCHEMA() {
  return getToken(GreenPlumParser::CURRENT_SCHEMA, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::FREEZE() {
  return getToken(GreenPlumParser::FREEZE, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::FULL() {
  return getToken(GreenPlumParser::FULL, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::ILIKE() {
  return getToken(GreenPlumParser::ILIKE, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::INNER_P() {
  return getToken(GreenPlumParser::INNER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::IS() {
  return getToken(GreenPlumParser::IS, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::ISNULL() {
  return getToken(GreenPlumParser::ISNULL, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::JOIN() {
  return getToken(GreenPlumParser::JOIN, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::LEFT() {
  return getToken(GreenPlumParser::LEFT, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::LIKE() {
  return getToken(GreenPlumParser::LIKE, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::LOG_P() {
  return getToken(GreenPlumParser::LOG_P, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::NATURAL() {
  return getToken(GreenPlumParser::NATURAL, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::NOTNULL() {
  return getToken(GreenPlumParser::NOTNULL, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::OUTER_P() {
  return getToken(GreenPlumParser::OUTER_P, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::OVERLAPS() {
  return getToken(GreenPlumParser::OVERLAPS, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::RIGHT() {
  return getToken(GreenPlumParser::RIGHT, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::SIMILAR() {
  return getToken(GreenPlumParser::SIMILAR, 0);
}

tree::TerminalNode* GreenPlumParser::Type_func_name_keywordContext::VERBOSE() {
  return getToken(GreenPlumParser::VERBOSE, 0);
}


size_t GreenPlumParser::Type_func_name_keywordContext::getRuleIndex() const {
  return GreenPlumParser::RuleType_func_name_keyword;
}

void GreenPlumParser::Type_func_name_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_func_name_keyword(this);
}

void GreenPlumParser::Type_func_name_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_func_name_keyword(this);
}


antlrcpp::Any GreenPlumParser::Type_func_name_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitType_func_name_keyword(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Type_func_name_keywordContext* GreenPlumParser::type_func_name_keyword() {
  Type_func_name_keywordContext *_localctx = _tracker.createInstance<Type_func_name_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1066, GreenPlumParser::RuleType_func_name_keyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6724);
    _la = _input->LA(1);
    if (!(((((_la - 25) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 25)) & ((1ULL << (GreenPlumParser::AUTHORIZATION - 25))
      | (1ULL << (GreenPlumParser::BINARY - 25))
      | (1ULL << (GreenPlumParser::CROSS - 25))
      | (1ULL << (GreenPlumParser::CURRENT_SCHEMA - 25)))) != 0) || ((((_la - 156) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 156)) & ((1ULL << (GreenPlumParser::FREEZE - 156))
      | (1ULL << (GreenPlumParser::FULL - 156))
      | (1ULL << (GreenPlumParser::ILIKE - 156))
      | (1ULL << (GreenPlumParser::INNER_P - 156))
      | (1ULL << (GreenPlumParser::IS - 156))
      | (1ULL << (GreenPlumParser::ISNULL - 156))
      | (1ULL << (GreenPlumParser::JOIN - 156))
      | (1ULL << (GreenPlumParser::LEFT - 156))
      | (1ULL << (GreenPlumParser::LIKE - 156)))) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & ((1ULL << (GreenPlumParser::LOG_P - 226))
      | (1ULL << (GreenPlumParser::NATURAL - 226))
      | (1ULL << (GreenPlumParser::NOTNULL - 226))
      | (1ULL << (GreenPlumParser::OUTER_P - 226)))) != 0) || _la == GreenPlumParser::OVERLAPS

    || _la == GreenPlumParser::RIGHT || _la == GreenPlumParser::SIMILAR || _la == GreenPlumParser::VERBOSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reserved_keywordContext ------------------------------------------------------------------

GreenPlumParser::Reserved_keywordContext::Reserved_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ALL() {
  return getToken(GreenPlumParser::ALL, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ANALYSE() {
  return getToken(GreenPlumParser::ANALYSE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ANALYZE() {
  return getToken(GreenPlumParser::ANALYZE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::AND() {
  return getToken(GreenPlumParser::AND, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ANY() {
  return getToken(GreenPlumParser::ANY, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ARRAY() {
  return getToken(GreenPlumParser::ARRAY, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::AS() {
  return getToken(GreenPlumParser::AS, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ASC() {
  return getToken(GreenPlumParser::ASC, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ASYMMETRIC() {
  return getToken(GreenPlumParser::ASYMMETRIC, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::BETWEEN() {
  return getToken(GreenPlumParser::BETWEEN, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::BOTH() {
  return getToken(GreenPlumParser::BOTH, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CASE() {
  return getToken(GreenPlumParser::CASE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CAST() {
  return getToken(GreenPlumParser::CAST, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CHECK() {
  return getToken(GreenPlumParser::CHECK, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::COLLATE() {
  return getToken(GreenPlumParser::COLLATE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::COLUMN() {
  return getToken(GreenPlumParser::COLUMN, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CONSTRAINT() {
  return getToken(GreenPlumParser::CONSTRAINT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CREATE() {
  return getToken(GreenPlumParser::CREATE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CURRENT_CATALOG() {
  return getToken(GreenPlumParser::CURRENT_CATALOG, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CURRENT_DATE() {
  return getToken(GreenPlumParser::CURRENT_DATE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CURRENT_ROLE() {
  return getToken(GreenPlumParser::CURRENT_ROLE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CURRENT_TIME() {
  return getToken(GreenPlumParser::CURRENT_TIME, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CURRENT_TIMESTAMP() {
  return getToken(GreenPlumParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::CURRENT_USER() {
  return getToken(GreenPlumParser::CURRENT_USER, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::DECODE() {
  return getToken(GreenPlumParser::DECODE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::DEFAULT() {
  return getToken(GreenPlumParser::DEFAULT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::DEFERRABLE() {
  return getToken(GreenPlumParser::DEFERRABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::DESC() {
  return getToken(GreenPlumParser::DESC, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::DISTINCT() {
  return getToken(GreenPlumParser::DISTINCT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::DISTRIBUTED() {
  return getToken(GreenPlumParser::DISTRIBUTED, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::DO() {
  return getToken(GreenPlumParser::DO, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ELSE() {
  return getToken(GreenPlumParser::ELSE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::END_P() {
  return getToken(GreenPlumParser::END_P, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::EXCEPT() {
  return getToken(GreenPlumParser::EXCEPT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::EXCLUDE() {
  return getToken(GreenPlumParser::EXCLUDE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::FALSE_P() {
  return getToken(GreenPlumParser::FALSE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::FETCH() {
  return getToken(GreenPlumParser::FETCH, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::FILTER() {
  return getToken(GreenPlumParser::FILTER, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::FOLLOWING() {
  return getToken(GreenPlumParser::FOLLOWING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::FOR() {
  return getToken(GreenPlumParser::FOR, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::FOREIGN() {
  return getToken(GreenPlumParser::FOREIGN, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::FROM() {
  return getToken(GreenPlumParser::FROM, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::GRANT() {
  return getToken(GreenPlumParser::GRANT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::GROUP_P() {
  return getToken(GreenPlumParser::GROUP_P, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::HAVING() {
  return getToken(GreenPlumParser::HAVING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::IN_P() {
  return getToken(GreenPlumParser::IN_P, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::INITIALLY() {
  return getToken(GreenPlumParser::INITIALLY, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::INTERSECT() {
  return getToken(GreenPlumParser::INTERSECT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::INTO() {
  return getToken(GreenPlumParser::INTO, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::LEADING() {
  return getToken(GreenPlumParser::LEADING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::LIMIT() {
  return getToken(GreenPlumParser::LIMIT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::LOCALTIME() {
  return getToken(GreenPlumParser::LOCALTIME, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::LOCALTIMESTAMP() {
  return getToken(GreenPlumParser::LOCALTIMESTAMP, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::NEW() {
  return getToken(GreenPlumParser::NEW, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::NOT() {
  return getToken(GreenPlumParser::NOT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::NULL_P() {
  return getToken(GreenPlumParser::NULL_P, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::OFF() {
  return getToken(GreenPlumParser::OFF, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::OFFSET() {
  return getToken(GreenPlumParser::OFFSET, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::OLD() {
  return getToken(GreenPlumParser::OLD, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ON() {
  return getToken(GreenPlumParser::ON, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ONLY() {
  return getToken(GreenPlumParser::ONLY, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::OR() {
  return getToken(GreenPlumParser::OR, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ORDER() {
  return getToken(GreenPlumParser::ORDER, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::PARTITION() {
  return getToken(GreenPlumParser::PARTITION, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::PLACING() {
  return getToken(GreenPlumParser::PLACING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::PRECEDING() {
  return getToken(GreenPlumParser::PRECEDING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::PRIMARY() {
  return getToken(GreenPlumParser::PRIMARY, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::RANGE() {
  return getToken(GreenPlumParser::RANGE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::REFERENCES() {
  return getToken(GreenPlumParser::REFERENCES, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::RETURNING() {
  return getToken(GreenPlumParser::RETURNING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::ROWS() {
  return getToken(GreenPlumParser::ROWS, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::SCATTER() {
  return getToken(GreenPlumParser::SCATTER, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::SELECT() {
  return getToken(GreenPlumParser::SELECT, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::SESSION_USER() {
  return getToken(GreenPlumParser::SESSION_USER, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::SOME() {
  return getToken(GreenPlumParser::SOME, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::SYMMETRIC() {
  return getToken(GreenPlumParser::SYMMETRIC, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::TABLE() {
  return getToken(GreenPlumParser::TABLE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::THEN() {
  return getToken(GreenPlumParser::THEN, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::TO() {
  return getToken(GreenPlumParser::TO, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::TRAILING() {
  return getToken(GreenPlumParser::TRAILING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::TRUE_P() {
  return getToken(GreenPlumParser::TRUE_P, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::UNBOUNDED() {
  return getToken(GreenPlumParser::UNBOUNDED, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::UNION() {
  return getToken(GreenPlumParser::UNION, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::UNIQUE() {
  return getToken(GreenPlumParser::UNIQUE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::USER() {
  return getToken(GreenPlumParser::USER, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::USING() {
  return getToken(GreenPlumParser::USING, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::VARIADIC() {
  return getToken(GreenPlumParser::VARIADIC, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::WHEN() {
  return getToken(GreenPlumParser::WHEN, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::WHERE() {
  return getToken(GreenPlumParser::WHERE, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::WINDOW() {
  return getToken(GreenPlumParser::WINDOW, 0);
}

tree::TerminalNode* GreenPlumParser::Reserved_keywordContext::WITH() {
  return getToken(GreenPlumParser::WITH, 0);
}


size_t GreenPlumParser::Reserved_keywordContext::getRuleIndex() const {
  return GreenPlumParser::RuleReserved_keyword;
}

void GreenPlumParser::Reserved_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReserved_keyword(this);
}

void GreenPlumParser::Reserved_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReserved_keyword(this);
}


antlrcpp::Any GreenPlumParser::Reserved_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitReserved_keyword(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Reserved_keywordContext* GreenPlumParser::reserved_keyword() {
  Reserved_keywordContext *_localctx = _tracker.createInstance<Reserved_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1068, GreenPlumParser::RuleReserved_keyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6726);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << GreenPlumParser::ALL)
      | (1ULL << GreenPlumParser::ANALYSE)
      | (1ULL << GreenPlumParser::ANALYZE)
      | (1ULL << GreenPlumParser::AND)
      | (1ULL << GreenPlumParser::ANY)
      | (1ULL << GreenPlumParser::ARRAY)
      | (1ULL << GreenPlumParser::AS)
      | (1ULL << GreenPlumParser::ASC)
      | (1ULL << GreenPlumParser::ASYMMETRIC)
      | (1ULL << GreenPlumParser::BETWEEN)
      | (1ULL << GreenPlumParser::BOTH)
      | (1ULL << GreenPlumParser::CASE)
      | (1ULL << GreenPlumParser::CAST)
      | (1ULL << GreenPlumParser::CHECK)
      | (1ULL << GreenPlumParser::COLLATE)
      | (1ULL << GreenPlumParser::COLUMN)
      | (1ULL << GreenPlumParser::CONSTRAINT))) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & ((1ULL << (GreenPlumParser::CREATE - 73))
      | (1ULL << (GreenPlumParser::CURRENT_CATALOG - 73))
      | (1ULL << (GreenPlumParser::CURRENT_DATE - 73))
      | (1ULL << (GreenPlumParser::CURRENT_ROLE - 73))
      | (1ULL << (GreenPlumParser::CURRENT_TIME - 73))
      | (1ULL << (GreenPlumParser::CURRENT_TIMESTAMP - 73))
      | (1ULL << (GreenPlumParser::CURRENT_USER - 73))
      | (1ULL << (GreenPlumParser::DECODE - 73))
      | (1ULL << (GreenPlumParser::DEFAULT - 73))
      | (1ULL << (GreenPlumParser::DEFERRABLE - 73))
      | (1ULL << (GreenPlumParser::DESC - 73))
      | (1ULL << (GreenPlumParser::DISTINCT - 73))
      | (1ULL << (GreenPlumParser::DISTRIBUTED - 73))
      | (1ULL << (GreenPlumParser::DO - 73))
      | (1ULL << (GreenPlumParser::ELSE - 73))
      | (1ULL << (GreenPlumParser::END_P - 73))
      | (1ULL << (GreenPlumParser::EXCEPT - 73))
      | (1ULL << (GreenPlumParser::EXCLUDE - 73)))) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & ((1ULL << (GreenPlumParser::FALSE_P - 141))
      | (1ULL << (GreenPlumParser::FETCH - 141))
      | (1ULL << (GreenPlumParser::FILTER - 141))
      | (1ULL << (GreenPlumParser::FOLLOWING - 141))
      | (1ULL << (GreenPlumParser::FOR - 141))
      | (1ULL << (GreenPlumParser::FOREIGN - 141))
      | (1ULL << (GreenPlumParser::FROM - 141))
      | (1ULL << (GreenPlumParser::GRANT - 141))
      | (1ULL << (GreenPlumParser::GROUP_P - 141))
      | (1ULL << (GreenPlumParser::HAVING - 141))
      | (1ULL << (GreenPlumParser::INITIALLY - 141))
      | (1ULL << (GreenPlumParser::IN_P - 141))
      | (1ULL << (GreenPlumParser::INTERSECT - 141))
      | (1ULL << (GreenPlumParser::INTO - 141)))) != 0) || ((((_la - 211) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 211)) & ((1ULL << (GreenPlumParser::LEADING - 211))
      | (1ULL << (GreenPlumParser::LIMIT - 211))
      | (1ULL << (GreenPlumParser::LOCALTIME - 211))
      | (1ULL << (GreenPlumParser::LOCALTIMESTAMP - 211))
      | (1ULL << (GreenPlumParser::NEW - 211))
      | (1ULL << (GreenPlumParser::NOT - 211))
      | (1ULL << (GreenPlumParser::NULL_P - 211)))) != 0) || ((((_la - 275) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 275)) & ((1ULL << (GreenPlumParser::OFF - 275))
      | (1ULL << (GreenPlumParser::OFFSET - 275))
      | (1ULL << (GreenPlumParser::OLD - 275))
      | (1ULL << (GreenPlumParser::ON - 275))
      | (1ULL << (GreenPlumParser::ONLY - 275))
      | (1ULL << (GreenPlumParser::OR - 275))
      | (1ULL << (GreenPlumParser::ORDER - 275))
      | (1ULL << (GreenPlumParser::PARTITION - 275))
      | (1ULL << (GreenPlumParser::PLACING - 275))
      | (1ULL << (GreenPlumParser::PRECEDING - 275))
      | (1ULL << (GreenPlumParser::PRIMARY - 275))
      | (1ULL << (GreenPlumParser::RANGE - 275))
      | (1ULL << (GreenPlumParser::REFERENCES - 275)))) != 0) || ((((_la - 346) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 346)) & ((1ULL << (GreenPlumParser::RETURNING - 346))
      | (1ULL << (GreenPlumParser::ROWS - 346))
      | (1ULL << (GreenPlumParser::SCATTER - 346))
      | (1ULL << (GreenPlumParser::SELECT - 346))
      | (1ULL << (GreenPlumParser::SESSION_USER - 346))
      | (1ULL << (GreenPlumParser::SOME - 346))
      | (1ULL << (GreenPlumParser::SYMMETRIC - 346))
      | (1ULL << (GreenPlumParser::TABLE - 346))
      | (1ULL << (GreenPlumParser::THEN - 346))
      | (1ULL << (GreenPlumParser::TO - 346)))) != 0) || ((((_la - 410) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 410)) & ((1ULL << (GreenPlumParser::TRAILING - 410))
      | (1ULL << (GreenPlumParser::TRUE_P - 410))
      | (1ULL << (GreenPlumParser::UNBOUNDED - 410))
      | (1ULL << (GreenPlumParser::UNION - 410))
      | (1ULL << (GreenPlumParser::UNIQUE - 410))
      | (1ULL << (GreenPlumParser::USER - 410))
      | (1ULL << (GreenPlumParser::USING - 410))
      | (1ULL << (GreenPlumParser::VARIADIC - 410))
      | (1ULL << (GreenPlumParser::WHEN - 410))
      | (1ULL << (GreenPlumParser::WHERE - 410))
      | (1ULL << (GreenPlumParser::WINDOW - 410))
      | (1ULL << (GreenPlumParser::WITH - 410)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Special_rule_relationContext ------------------------------------------------------------------

GreenPlumParser::Special_rule_relationContext::Special_rule_relationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GreenPlumParser::Special_rule_relationContext::OLD() {
  return getToken(GreenPlumParser::OLD, 0);
}

tree::TerminalNode* GreenPlumParser::Special_rule_relationContext::NEW() {
  return getToken(GreenPlumParser::NEW, 0);
}


size_t GreenPlumParser::Special_rule_relationContext::getRuleIndex() const {
  return GreenPlumParser::RuleSpecial_rule_relation;
}

void GreenPlumParser::Special_rule_relationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecial_rule_relation(this);
}

void GreenPlumParser::Special_rule_relationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GreenPlumParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecial_rule_relation(this);
}


antlrcpp::Any GreenPlumParser::Special_rule_relationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GreenPlumParserVisitor*>(visitor))
    return parserVisitor->visitSpecial_rule_relation(this);
  else
    return visitor->visitChildren(this);
}

GreenPlumParser::Special_rule_relationContext* GreenPlumParser::special_rule_relation() {
  Special_rule_relationContext *_localctx = _tracker.createInstance<Special_rule_relationContext>(_ctx, getState());
  enterRule(_localctx, 1070, GreenPlumParser::RuleSpecial_rule_relation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6728);
    _la = _input->LA(1);
    if (!(_la == GreenPlumParser::NEW

    || _la == GreenPlumParser::OLD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool GreenPlumParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 40: return var_nameSempred(dynamic_cast<Var_nameContext *>(context), predicateIndex);
    case 116: return tab_part_val_no_paranSempred(dynamic_cast<Tab_part_val_no_paranContext *>(context), predicateIndex);
    case 399: return values_clauseSempred(dynamic_cast<Values_clauseContext *>(context), predicateIndex);
    case 402: return table_refSempred(dynamic_cast<Table_refContext *>(context), predicateIndex);
    case 433: return logical_exprSempred(dynamic_cast<Logical_exprContext *>(context), predicateIndex);
    case 435: return relational_exprSempred(dynamic_cast<Relational_exprContext *>(context), predicateIndex);
    case 440: return concatenationSempred(dynamic_cast<ConcatenationContext *>(context), predicateIndex);
    case 442: return unary_exprSempred(dynamic_cast<Unary_exprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::var_nameSempred(Var_nameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::tab_part_val_no_paranSempred(Tab_part_val_no_paranContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::values_clauseSempred(Values_clauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::table_refSempred(Table_refContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::logical_exprSempred(Logical_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::relational_exprSempred(Relational_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::concatenationSempred(ConcatenationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return precpred(_ctx, 4);
    case 8: return precpred(_ctx, 3);
    case 9: return precpred(_ctx, 2);
    case 10: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GreenPlumParser::unary_exprSempred(Unary_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> GreenPlumParser::_decisionToDFA;
atn::PredictionContextCache GreenPlumParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN GreenPlumParser::_atn;
std::vector<uint16_t> GreenPlumParser::_serializedATN;

std::vector<std::string> GreenPlumParser::_ruleNames = {
  "stmtblock", "stmtmulti", "stmt", "create_queue_stmt", "opt_queue_elem", 
  "alter_queue_stmt", "with_out_definition", "drop_queue_stmt", "create_resource_group_stmt", 
  "drop_resource_group_stmt", "alter_resource_group_stmt", "resource_group_elem", 
  "create_role_stmt", "opt_with", "role_elem", "deny_login_role", "deny_interval", 
  "deny_day_specifier", "deny_point", "opt_time", "exttab_auth_list", "keyvalue_list", 
  "keyvalue_pair", "create_user_stmt", "alter_role_stmt", "alter_role_set_stmt", 
  "alter_role_elem", "alter_user_stmt", "alter_user_set_stmt", "drop_role_stmt", 
  "drop_user_stmt", "create_group_stmt", "alter_group_stmt", "add_drop", 
  "drop_group_stmt", "create_schema_stmt", "schema_name", "schema_stmt", 
  "variable_set_stmt", "set_rest", "var_name", "var_list", "var_value", 
  "iso_level", "opt_boolean", "zone_value", "paren_iconst", "opt_encoding", 
  "colid_or_sconst", "variable_reset_stmt", "set_reset_clause", "variable_show_stmt", 
  "constraints_set_stmt", "constraints_set_list", "constraints_set_mode", 
  "check_point_stmt", "discard_stmt", "alter_table_stmt", "alter_table_cmds", 
  "alter_table_cmd", "opt_table_partition_split_into", "opt_table_partition_merge_into", 
  "table_partition_modify", "opt_table_partition_exchange_validate", "alter_table_partition_id_spec", 
  "alter_table_partition_id_spec_with_opt_default", "alter_table_partition_cmd", 
  "alter_rel_cmds", "alter_rel_cmd", "alter_column_default", "opt_drop_behavior", 
  "alter_using", "close_portal_stmt", "copy_stmt", "copy_from", "skip_external_partition", 
  "copy_file_name", "copy_opt_item", "opt_oids", "copy_delimiter", "create_stmt", 
  "opt_temp", "table_element_list", "table_element", "column_reference_storage_directive", 
  "column_def", "col_constraint", "opt_storage_encoding", "col_constraint_elem", 
  "constraint_attr", "table_like_clause", "table_list_option", "table_constraint", 
  "constraint_elem", "paren_column", "paren_column_list", "column_list", 
  "column_elem", "key_match", "key_actions", "key_update", "key_delete", 
  "key_action", "opt_inherit", "opt_with_def_oids", "on_commit_option", 
  "opt_table_space", "constraint_table_space", "distributed_by", "opt_distributed_by", 
  "tab_partition_column_enc_list", "opt_tab_partition_storage_attr", "opt_tab_partition_spec", 
  "opt_tab_sub_partition_spec", "tab_partition_elem_list", "tab_sub_partition_elem_list", 
  "tab_part_val_no_paran", "tab_part_val", "tab_partition_boundary_spec_val_list", 
  "opt_tab_partition_range_inclusive", "tab_partition_boundary_spec_start", 
  "tab_partition_boundary_spec_end", "opt_tab_partition_boundary_spec_every", 
  "tab_partition_boundary_spec", "paren_part_values_single", "multi_spec_value_list", 
  "part_values_single", "part_values_clause", "part_values_or_spec_list", 
  "tab_partition_elem", "tab_sub_partition_elem", "tab_partition_elemOption", 
  "tab_partition_name_decl", "tab_partition_default_name_decl", "tab_sub_partition_name_decl", 
  "tab_sub_partition_default_name_decl", "tab_partition_by_type", "opt_tab_partition_by", 
  "tab_sub_partition_by_list", "tab_sub_partition_template", "tab_sub_partition_by", 
  "opt_partitions_number", "create_as_stmt", "create_as_target", "opt_create_as", 
  "create_as_list", "create_as_element", "opt_with_data", "create_external_stmt", 
  "opt_writable", "ext_type_desc", "ext_on_clause_item", "double_parens", 
  "format_opt", "format_opt_list", "format_def_list", "format_def_item", 
  "format_opt_item", "ext_options_opt", "ext_options", "ext_options_list", 
  "ext_options_item", "ext_table_element_list", "ext_table_element", "ext_column_def", 
  "opt_single_row_error_handling", "opt_log_error_table", "opt_sreh_limit_type", 
  "ext_opt_encoding_list", "ext_opt_encoding_item", "create_seq_stmt", "alter_seq_stmt", 
  "opt_seq_list", "opt_seq_elem", "numberic_only", "float_only", "integer_only", 
  "create_p_lang_stmt", "create_p_lang_stmtOption", "handler_name", "opt_inline_handler", 
  "validator_clause", "opt_validator", "drop_p_lang_stmt", "create_file_space_stmt", 
  "file_space_seg_list", "file_space_seg", "opt_owner", "create_table_space_stmt", 
  "create_extension_stmt", "create_extension_opt_list", "create_extension_opt_item", 
  "alter_extension_stmt", "alter_extension_opt_list", "alter_extension_opt_item", 
  "alter_extension_content_stmt", "alter_extension_content_stmtOption", 
  "create_trig_stmt", "trigger_action_time", "trigger_events", "trigger_one_event", 
  "trigger_for_spec", "trigger_for_type", "trigger_func_args", "trigger_func_arg", 
  "opt_constr_from_table", "constraint_attr_spec", "constraint_deferrability_spec", 
  "constraint_time_spec", "drop_trig_stmt", "create_assert_stmt", "drop_assert_stmt", 
  "define_stmt", "definition", "def_list", "def_elem", "def_arg", "aggr_args", 
  "old_aggr_definition", "old_aggr_list", "old_aggr_elem", "enum_val_list", 
  "create_op_class_stmt", "opclass_item_list", "opclass_item", "opt_opfamily", 
  "create_op_family_stmt", "alter_op_family_stmt", "opclass_drop_list", 
  "opclass_drop", "drop_op_class_stmt", "drop_op_family_stmt", "drop_owned_stmt", 
  "reassign_owned_stmt", "drop_stmt", "drop_type", "any_name_list", "any_name", 
  "attrs", "truncate_stmt", "comment_stmt", "comment_stmtOption", "comment_option", 
  "comment_type", "comment_text", "fetch_stmt", "fetch_direction", "grant_stmt", 
  "revoke_stmt", "privileges", "privilege_list", "privilege", "privilege_target", 
  "grantee_list", "grantee", "opt_grant_grant_option", "function_with_argtypes_list", 
  "function_with_argtypes", "grant_role_stmt", "revoke_role_stmt", "opt_grant_admin_option", 
  "opt_granted_by", "index_stmt", "index_params", "index_elem", "opt_class", 
  "opt_asc_desc", "opt_nulls_order", "create_function_stmt", "opt_or_replace", 
  "func_args", "func_args_list", "func_args_with_defaults", "func_args_with_defaults_list", 
  "func_arg", "func_arg_with_default", "arg_class", "param_name", "func_return", 
  "func_type", "func_type_table_option_list", "func_type_table_option", 
  "createfunc_opt_list", "common_func_opt_item", "createfunc_opt_item", 
  "func_as", "table_func_column", "table_func_column_list", "alter_function_stmt", 
  "alterfunc_opt_list", "remove_func_stmt", "remove_aggr_stmt", "remove_oper_stmt", 
  "oper_argtypes", "any_operator", "do_stmt", "dostmt_opt_item", "create_cast_stmt", 
  "cast_context", "drop_cast_stmt", "reindex_stmt", "alter_type_stmt", "rename_stmt", 
  "opt_column", "alter_object_schema_stmt", "alter_owner_stmt", "rule_stmt", 
  "rule_action_list", "rule_action_multi", "rule_action_stmt", "event", 
  "opt_instead", "drop_rule_stmt", "notify_stmt", "listen_stmt", "unlisten_stmt", 
  "transaction_stmt", "opt_transaction", "transaction_mode_item", "transaction_mode_list", 
  "view_stmt", "opt_check_option", "load_stmt", "createdb_stmt", "createdb_opt_item", 
  "alter_database_stmt", "alter_database_set_stmt", "alterdb_opt_item", 
  "dropdb_stmt", "create_domain_stmt", "alter_domain_stmt", "alter_domain_option", 
  "alter_tsdictionary_stmt", "alter_tsconfiguration_stmt", "alter_txt_search_conf_option", 
  "create_conversion_stmt", "cluster_stmt", "cluster_option", "vacuum_stmt", 
  "analyze_stmt", "analyze_keyword", "paren_name_list", "explain_stmt", 
  "explainable_stmt", "prepare_stmt", "paren_type_list", "preparable_stmt", 
  "execute_stmt", "deallocate_stmt", "cdb_string_list", "cdb_string", "insert_stmt", 
  "insert_rest", "insert_column_list", "insert_column_item", "returning_clause", 
  "delete_stmt", "lock_stmt", "opt_lock", "lock_type", "update_stmt", "set_clause_list", 
  "set_clause", "single_set_clause", "multiple_set_clause", "set_target", 
  "set_target_list", "declare_cursor_stmt", "cursor_option", "opt_hold", 
  "select_stmt", "subquery_basic_elements", "subquery_operation_part", "select_with_parens", 
  "select_no_parens", "simple_select", "with_clause", "cte_list", "common_table_expr", 
  "into_clause", "opt_tempTableName", "opt_distinct", "sort_clause", "sortby_list", 
  "sortby", "select_limit", "select_limit_value", "opt_select_fetch_first_value", 
  "select_offset_value", "select_offset_value2", "row_or_rows", "first_or_next", 
  "group_clause", "group_elem_list", "group_elem", "having_clause", "for_locking_clause", 
  "for_locking_item", "locked_rels_list", "values_clause", "from_clause", 
  "from_list", "table_ref", "join_type", "join_qual", "relation_expr", "relation_expr_opt_alias", 
  "func_table", "where_clause", "where_or_current_clause", "table_func_element_list", 
  "table_func_element", "typename_pg", "opt_array_bounds", "simple_typename", 
  "const_typename", "generic_type", "numeric", "bit", "const_bit", "bit_with_length", 
  "bit_without_length", "multi_character", "const_character", "character_with_length", 
  "character_without_length", "character", "opt_charset", "const_datatime", 
  "const_interval", "opt_timezone", "opt_interval", "a_expr", "logical_expr", 
  "multiset_expr", "relational_expr", "relational_op", "compound_expr", 
  "between_elements", "concatenation_list", "concatenation", "model_expr", 
  "unary_expr", "c_expr", "scatter_clause", "table_value_select_clause", 
  "simple_func", "simple_func_params", "func_expr", "xml_root_version", 
  "opt_xml_root_standalone", "xml_attributes", "xml_attribute_list", "xml_attribute_el", 
  "document_or_content", "xml_whitespace_option", "xmlexists_argument", 
  "window_clause", "window_definition_list", "window_definition", "window_specification", 
  "opt_partition_clause", "window_frame_clause", "window_frame_units", "window_frame_extent", 
  "window_frame_start", "window_frame_between", "window_frame_bound", "window_frame_exclusion", 
  "row", "op_signs", "all_Op", "qual_Op", "qual_all_Op", "subquery_Op", 
  "paren_expr_list", "expr_list", "type_list", "array_expr", "array_expr_list", 
  "extract_list", "extract_arg", "overlay_list", "overlay_placing", "position_list", 
  "substr_list", "substr_from", "substr_for", "trim_list", "in_expr", "case_expr", 
  "when_clause", "when_operand", "case_default", "case_arg", "decode_expr", 
  "search_result", "decode_default", "columnref", "indirection_el", "indirection", 
  "ctext_expr", "ctext_expr_list", "ctext_row", "target_list", "target_el", 
  "relation_name", "qualified_name_list", "qualified_name", "name_list", 
  "name", "cte_name", "database_name", "access_method", "attr_name", "index_name", 
  "file_name", "func_name", "a_expr_const", "iconst", "sconst", "role_id", 
  "queue_id", "signed_iconst", "colid", "type_function_name", "col_label", 
  "identifier", "unreserved_keyword", "keywords_ok_in_alias_no_as", "partition_colid", 
  "partition_ident_key_word", "col_name_keyword", "type_func_name_keyword", 
  "reserved_keyword", "special_rule_relation"
};

std::vector<std::string> GreenPlumParser::_literalNames = {
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "'%'", "'&'", "'('", "')'", "'**'", "'*'", "'+'", "'-'", "','", "'/'", 
  "'@'", "':='", "'.'", "'`'", "'?'", "", "'^'", "'~'", "'!'", "'>'", "'<'", 
  "':'", "';'", "'#'", "'::'", "'|'", "'='", "'['", "']'"
};

std::vector<std::string> GreenPlumParser::_symbolicNames = {
  "", "ABORT_P", "ABSOLUTE_P", "ACCESS", "ACTION", "ACTIVE", "ADD_P", "ADMIN", 
  "AFTER", "AGGREGATE", "ALL", "ALSO", "ALTER", "ALWAYS", "ANALYSE", "ANALYZE", 
  "AND", "ANY", "ARRAY", "AS", "ASC", "ASSERTION", "ASSIGNMENT", "ASYMMETRIC", 
  "AT", "AUTHORIZATION", "BACKWARD", "BEFORE", "BEGIN_P", "BETWEEN", "BIGINT", 
  "BINARY", "BIT", "BOOLEAN_P", "BOTH", "BY", "CACHE", "CALLED", "CASCADE", 
  "CASCADED", "CASE", "CAST", "CHAIN", "CHARACTER", "CHARACTERISTICS", "CHAR_P", 
  "CHECK", "CHECKPOINT", "CLASS", "CLOSE", "CLUSTER", "COALESCE", "COLLATE", 
  "COLUMN", "COMMENT", "COMMIT", "COMMITED", "COMMITTED", "CONCURRENCY", 
  "CONCURRENTLY", "CONFIGURATION", "CONNECT", "CONNECTION", "CONSTRAINT", 
  "CONSTRAINTS", "CONTAINS", "CONTENT_P", "CONTINUE_P", "CONVERSION_P", 
  "COPY", "COST", "CPU_RATE_LIMIT", "CPUSET", "CREATE", "CREATEDB", "CREATEEXTTABLE", 
  "CREATEROLE", "CREATEUSER", "CROSS", "CSV", "CUBE", "CURRENT_CATALOG", 
  "CURRENT_DATE", "CURRENT_P", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TIME", 
  "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "CYCLE", "DATABASE", "DATA_P", 
  "DAY_P", "DEALLOCATE", "DEC", "DECIMAL_P", "DECLARE", "DECODE", "DEFAULT", 
  "DEFAULTS", "DEFERRABLE", "DEFERRED", "DEFINER", "DELETE_P", "DELIMITER", 
  "DELIMITERS", "DENY", "DESC", "DICTIONARY", "DISABLE_P", "DISCARD", "DISTINCT", 
  "DISTRIBUTED", "DO", "DOCUMENT_P", "DOMAIN_P", "DOUBLE_P", "DROP", "DXL", 
  "EACH", "ELSE", "ENABLE_P", "ENCODING", "ENCRYPTED", "END_P", "ENUM_P", 
  "ERRORS", "ESCAPE", "EVERY", "EXCEPT", "EXCHANGE", "EXCLUDE", "EXCLUDING", 
  "EXCLUSIVE", "EXECUTE", "EXISTS", "EXPLAIN", "EXTENSION", "EXTERNAL", 
  "EXTRACT", "FALSE_P", "FAMILY", "FETCH", "FIELDS", "FILESPACE", "FILL", 
  "FILTER", "FIRST_P", "FLOAT_P", "FOLLOWING", "FOR", "FORCE", "FOREIGN", 
  "FORMAT", "FORWARD", "FREEZE", "FROM", "FULL", "FUNCTION", "GLOBAL", "GRANT", 
  "GRANTED", "GREATEST", "GROUP_ID", "GROUPING", "GROUP_P", "HANDLER", "HASH", 
  "HAVING", "HEADER_P", "HOLD", "HOST", "HOUR_P", "IDENTITY_P", "IF_P", 
  "IGNORE_P", "ILIKE", "IMMEDIATE", "IMMUTABLE", "IMPLICIT_P", "INCLUDING", 
  "INCLUSIVE", "INCREMENT", "INDEX", "INDEXES", "INHERIT", "INHERITS", "INITIALLY", 
  "INLINE_P", "INNER_P", "INOUT", "IN_P", "INPUT_P", "INSENSITIVE", "INSERT", 
  "INSTEAD", "INTEGER", "INTERSECT", "INTERVAL", "INTO", "INT_P", "INVOKER", 
  "IS", "ISNULL", "ISOLATION", "JOIN", "KEY", "LANGUAGE", "LARGE_P", "LAST_P", 
  "LEADING", "LEAST", "LEFT", "LEVEL", "LIKE", "LIMIT", "LIST", "LISTEN", 
  "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATION", "LOCK_P", 
  "LOGIN_P", "LOG_P", "MAPPING", "MASTER", "MATCH", "MAXVALUE", "MEDIAN", 
  "MEMORY_LIMIT", "MEMORY_SHARED_QUOTA", "MEMORY_SPILL_RATIO", "MERGE", 
  "MINUTE_P", "MINVALUE", "MISSING", "MODE", "MODIFIES", "MODIFY", "MONTH_P", 
  "MOVE", "MPP", "NAME_P", "NAMES", "NATIONAL", "NATURAL", "NCHAR", "NEW", 
  "NEXT", "NO", "NOCREATEDB", "NOCREATEEXTTABLE", "NOCREATEROLE", "NOCREATEUSER", 
  "NOINHERIT", "NOLOGIN_P", "NONE", "NOOVERCOMMIT", "NOSUPERUSER", "NOT", 
  "NOTHING", "NOTIFY", "NOTNULL", "NOWAIT", "NULLIF", "NULL_P", "NULLS_FIRST", 
  "NULLS_LAST", "NULLS_P", "NUMERIC", "OBJECT_P", "OF", "OFF", "OFFSET", 
  "OIDS", "OLD", "ON", "ONLY", "OPERATOR", "OPTION", "OPTIONS", "OR", "ORDER", 
  "ORDERED", "OTHERS", "OUTER_P", "OUT_P", "OVER", "OVERCOMMIT", "OVERLAPS", 
  "OVERLAY", "OWNED", "OWNER", "PARSER", "PARTIAL", "PARTITION", "PARTITIONS", 
  "PASSING", "PASSWORD", "PERCENT", "PERCENTILE_CONT", "PERCENTILE_DISC", 
  "PLACING", "PLANS", "POSITION", "PRECEDING", "PRECISION", "PREPARE", "PREPARED", 
  "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURAL", "PROCEDURE", 
  "PROGRAM", "PROTOCOL", "PUBLIC", "QUEUE", "QUOTE", "RANDOMLY", "RANGE", 
  "READ", "READABLE", "READS", "REAL", "REASSIGN", "RECHECK", "RECURSIVE", 
  "REF", "REFERENCES", "REINDEX", "REJECT_P", "RELATIVE_P", "RELEASE", "RENAME", 
  "REPEATABLE", "REPLACE", "REPLICA", "RESET", "RESOURCE", "RESTART", "RESTRICT", 
  "RETURNING", "RETURNS", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROLLUP", 
  "ROOTPARTITION", "ROW", "ROWS", "RULE", "SAVEPOINT", "SCATTER", "SCHEMA", 
  "SCROLL", "SEARCH", "SECOND_P", "SECURITY", "SEGMENT", "SELECT", "SEQUENCE", 
  "SERIALIZABLE", "SESSION", "SESSION_USER", "SET", "SETOF", "SETS", "SHARE", 
  "SHOW", "SIMILAR", "SIMPLE", "SMALLINT", "SOME", "SPLIT", "SQL", "STABLE", 
  "STANDALONE_P", "START", "STATEMENT", "STATISTICS", "STDIN", "STDOUT", 
  "STORAGE", "STRICT_P", "STRIP_P", "SUBPARTITION", "SUBPARTITIONS", "SUBSTRING", 
  "SUPERUSER_P", "SYMMETRIC", "SYSID", "SYSTEM_P", "TABLE", "TABLESPACE", 
  "TEMP", "TEMPLATE", "TEMPORARY", "TEXT_P", "THEN", "THRESHOLD", "TIES", 
  "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION", "TREAT", "TRIGGER", 
  "TRIM", "TRUE_P", "TRUNCATE", "TRUSTED", "TYPE_P", "UMINUS", "UNBOUNDED", 
  "UNCOMMITTED", "UNENCRYPTED", "UNION", "UNIQUE", "UNKNOWN", "UNLISTEN", 
  "UNTIL", "UPDATE", "USAGE", "USER", "USING", "VACUUM", "VALID", "VALIDATION", 
  "VALIDATOR", "VALUE_P", "VALUES", "VARCHAR", "VARIADIC", "VARYING", "VERBOSE", 
  "VERSION_P", "VIEW", "VOLATILE", "WEB", "WHEN", "WHERE", "WHITESPACE_P", 
  "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRITABLE", "WRITE", "XMLATTRIBUTES", 
  "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XML_P", "XMLPARSE", 
  "XMLPI", "XMLROOT", "XMLSERIALIZE", "YEAR_P", "YES_P", "ZONE", "PERCENT_SIGN", 
  "AMPERSAND", "LEFT_PAREN", "RIGHT_PAREN", "DOUBLE_ASTERISK", "ASTERISK", 
  "PLUS_SIGN", "MINUS_SIGN", "COMMA", "SOLIDUS", "AT_SIGN", "ASSIGN_OP", 
  "PERIOD", "SLASH_SINGLE", "QUESTION_MARK", "NOT_EQUAL_OP", "CARRET_OPERATOR_PART", 
  "TILDE_OPERATOR_PART", "EXCLAMATION_OPERATOR_PART", "GREATER_THAN_OP", 
  "LESS_THAN_OP", "COLON", "SEMICOLON", "POUND_SIGN", "TYPECAST", "BAR", 
  "EQUALS_OP", "LEFT_BRACKET", "RIGHT_BRACKET", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT", 
  "SPACES", "CHAR_STRING", "REGULAR_ID", "DELIMITED_STR", "SCONST", "ICONST", 
  "FCONST", "BCONST", "XCONST", "PARAM", "OP_CHARS"
};

dfa::Vocabulary GreenPlumParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> GreenPlumParser::_tokenNames;

GreenPlumParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x200, 0x1a4d, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 
       0x4, 0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 
       0x9, 0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 
       0xa, 0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 
       0x4, 0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 
       0x11, 0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 
       0x14, 0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 
       0x17, 0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 
       0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 
       0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 
       0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 
       0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 
       0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 
       0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 
       0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 
       0x2f, 0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 
       0x32, 0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 
       0x35, 0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 
       0x38, 0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 
       0x3b, 0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 
       0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 
       0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 
       0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 
       0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 
       0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 
       0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 
       0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 
       0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 
       0x56, 0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 
       0x59, 0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 
       0x5c, 0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 
       0x5f, 0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 
       0x62, 0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 
       0x65, 0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 
       0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 
       0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 
       0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 
       0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 
       0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 
       0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 
       0x7a, 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 
       0x7d, 0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 
       0x80, 0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 
       0x83, 0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 
       0x86, 0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 
       0x89, 0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 
       0x8c, 0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 
       0x8f, 0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 
       0x92, 0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 
       0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 
       0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 
       0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 
       0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 
       0xa1, 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 
       0xa4, 0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 
       0xa7, 0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 
       0xaa, 0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 
       0xad, 0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 
       0xb0, 0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 
       0xb3, 0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 
       0xb6, 0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 
       0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 
       0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 
       0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 
       0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 
       0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 
       0xc8, 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 
       0xcb, 0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 
       0xce, 0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 
       0xd1, 0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 
       0xd4, 0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 
       0xd7, 0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 
       0xda, 0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 
       0xdd, 0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 
       0xe0, 0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 
       0xe3, 0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, 0x4, 0xe5, 0x9, 0xe5, 0x4, 
       0xe6, 0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, 0xe8, 0x9, 0xe8, 0x4, 
       0xe9, 0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, 0x9, 0xeb, 0x4, 
       0xec, 0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, 0xee, 0x4, 
       0xef, 0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, 0x4, 
       0xf2, 0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, 
       0xf5, 0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 
       0xf8, 0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 
       0xfb, 0x9, 0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x4, 
       0xfe, 0x9, 0xfe, 0x4, 0xff, 0x9, 0xff, 0x4, 0x100, 0x9, 0x100, 0x4, 
       0x101, 0x9, 0x101, 0x4, 0x102, 0x9, 0x102, 0x4, 0x103, 0x9, 0x103, 
       0x4, 0x104, 0x9, 0x104, 0x4, 0x105, 0x9, 0x105, 0x4, 0x106, 0x9, 
       0x106, 0x4, 0x107, 0x9, 0x107, 0x4, 0x108, 0x9, 0x108, 0x4, 0x109, 
       0x9, 0x109, 0x4, 0x10a, 0x9, 0x10a, 0x4, 0x10b, 0x9, 0x10b, 0x4, 
       0x10c, 0x9, 0x10c, 0x4, 0x10d, 0x9, 0x10d, 0x4, 0x10e, 0x9, 0x10e, 
       0x4, 0x10f, 0x9, 0x10f, 0x4, 0x110, 0x9, 0x110, 0x4, 0x111, 0x9, 
       0x111, 0x4, 0x112, 0x9, 0x112, 0x4, 0x113, 0x9, 0x113, 0x4, 0x114, 
       0x9, 0x114, 0x4, 0x115, 0x9, 0x115, 0x4, 0x116, 0x9, 0x116, 0x4, 
       0x117, 0x9, 0x117, 0x4, 0x118, 0x9, 0x118, 0x4, 0x119, 0x9, 0x119, 
       0x4, 0x11a, 0x9, 0x11a, 0x4, 0x11b, 0x9, 0x11b, 0x4, 0x11c, 0x9, 
       0x11c, 0x4, 0x11d, 0x9, 0x11d, 0x4, 0x11e, 0x9, 0x11e, 0x4, 0x11f, 
       0x9, 0x11f, 0x4, 0x120, 0x9, 0x120, 0x4, 0x121, 0x9, 0x121, 0x4, 
       0x122, 0x9, 0x122, 0x4, 0x123, 0x9, 0x123, 0x4, 0x124, 0x9, 0x124, 
       0x4, 0x125, 0x9, 0x125, 0x4, 0x126, 0x9, 0x126, 0x4, 0x127, 0x9, 
       0x127, 0x4, 0x128, 0x9, 0x128, 0x4, 0x129, 0x9, 0x129, 0x4, 0x12a, 
       0x9, 0x12a, 0x4, 0x12b, 0x9, 0x12b, 0x4, 0x12c, 0x9, 0x12c, 0x4, 
       0x12d, 0x9, 0x12d, 0x4, 0x12e, 0x9, 0x12e, 0x4, 0x12f, 0x9, 0x12f, 
       0x4, 0x130, 0x9, 0x130, 0x4, 0x131, 0x9, 0x131, 0x4, 0x132, 0x9, 
       0x132, 0x4, 0x133, 0x9, 0x133, 0x4, 0x134, 0x9, 0x134, 0x4, 0x135, 
       0x9, 0x135, 0x4, 0x136, 0x9, 0x136, 0x4, 0x137, 0x9, 0x137, 0x4, 
       0x138, 0x9, 0x138, 0x4, 0x139, 0x9, 0x139, 0x4, 0x13a, 0x9, 0x13a, 
       0x4, 0x13b, 0x9, 0x13b, 0x4, 0x13c, 0x9, 0x13c, 0x4, 0x13d, 0x9, 
       0x13d, 0x4, 0x13e, 0x9, 0x13e, 0x4, 0x13f, 0x9, 0x13f, 0x4, 0x140, 
       0x9, 0x140, 0x4, 0x141, 0x9, 0x141, 0x4, 0x142, 0x9, 0x142, 0x4, 
       0x143, 0x9, 0x143, 0x4, 0x144, 0x9, 0x144, 0x4, 0x145, 0x9, 0x145, 
       0x4, 0x146, 0x9, 0x146, 0x4, 0x147, 0x9, 0x147, 0x4, 0x148, 0x9, 
       0x148, 0x4, 0x149, 0x9, 0x149, 0x4, 0x14a, 0x9, 0x14a, 0x4, 0x14b, 
       0x9, 0x14b, 0x4, 0x14c, 0x9, 0x14c, 0x4, 0x14d, 0x9, 0x14d, 0x4, 
       0x14e, 0x9, 0x14e, 0x4, 0x14f, 0x9, 0x14f, 0x4, 0x150, 0x9, 0x150, 
       0x4, 0x151, 0x9, 0x151, 0x4, 0x152, 0x9, 0x152, 0x4, 0x153, 0x9, 
       0x153, 0x4, 0x154, 0x9, 0x154, 0x4, 0x155, 0x9, 0x155, 0x4, 0x156, 
       0x9, 0x156, 0x4, 0x157, 0x9, 0x157, 0x4, 0x158, 0x9, 0x158, 0x4, 
       0x159, 0x9, 0x159, 0x4, 0x15a, 0x9, 0x15a, 0x4, 0x15b, 0x9, 0x15b, 
       0x4, 0x15c, 0x9, 0x15c, 0x4, 0x15d, 0x9, 0x15d, 0x4, 0x15e, 0x9, 
       0x15e, 0x4, 0x15f, 0x9, 0x15f, 0x4, 0x160, 0x9, 0x160, 0x4, 0x161, 
       0x9, 0x161, 0x4, 0x162, 0x9, 0x162, 0x4, 0x163, 0x9, 0x163, 0x4, 
       0x164, 0x9, 0x164, 0x4, 0x165, 0x9, 0x165, 0x4, 0x166, 0x9, 0x166, 
       0x4, 0x167, 0x9, 0x167, 0x4, 0x168, 0x9, 0x168, 0x4, 0x169, 0x9, 
       0x169, 0x4, 0x16a, 0x9, 0x16a, 0x4, 0x16b, 0x9, 0x16b, 0x4, 0x16c, 
       0x9, 0x16c, 0x4, 0x16d, 0x9, 0x16d, 0x4, 0x16e, 0x9, 0x16e, 0x4, 
       0x16f, 0x9, 0x16f, 0x4, 0x170, 0x9, 0x170, 0x4, 0x171, 0x9, 0x171, 
       0x4, 0x172, 0x9, 0x172, 0x4, 0x173, 0x9, 0x173, 0x4, 0x174, 0x9, 
       0x174, 0x4, 0x175, 0x9, 0x175, 0x4, 0x176, 0x9, 0x176, 0x4, 0x177, 
       0x9, 0x177, 0x4, 0x178, 0x9, 0x178, 0x4, 0x179, 0x9, 0x179, 0x4, 
       0x17a, 0x9, 0x17a, 0x4, 0x17b, 0x9, 0x17b, 0x4, 0x17c, 0x9, 0x17c, 
       0x4, 0x17d, 0x9, 0x17d, 0x4, 0x17e, 0x9, 0x17e, 0x4, 0x17f, 0x9, 
       0x17f, 0x4, 0x180, 0x9, 0x180, 0x4, 0x181, 0x9, 0x181, 0x4, 0x182, 
       0x9, 0x182, 0x4, 0x183, 0x9, 0x183, 0x4, 0x184, 0x9, 0x184, 0x4, 
       0x185, 0x9, 0x185, 0x4, 0x186, 0x9, 0x186, 0x4, 0x187, 0x9, 0x187, 
       0x4, 0x188, 0x9, 0x188, 0x4, 0x189, 0x9, 0x189, 0x4, 0x18a, 0x9, 
       0x18a, 0x4, 0x18b, 0x9, 0x18b, 0x4, 0x18c, 0x9, 0x18c, 0x4, 0x18d, 
       0x9, 0x18d, 0x4, 0x18e, 0x9, 0x18e, 0x4, 0x18f, 0x9, 0x18f, 0x4, 
       0x190, 0x9, 0x190, 0x4, 0x191, 0x9, 0x191, 0x4, 0x192, 0x9, 0x192, 
       0x4, 0x193, 0x9, 0x193, 0x4, 0x194, 0x9, 0x194, 0x4, 0x195, 0x9, 
       0x195, 0x4, 0x196, 0x9, 0x196, 0x4, 0x197, 0x9, 0x197, 0x4, 0x198, 
       0x9, 0x198, 0x4, 0x199, 0x9, 0x199, 0x4, 0x19a, 0x9, 0x19a, 0x4, 
       0x19b, 0x9, 0x19b, 0x4, 0x19c, 0x9, 0x19c, 0x4, 0x19d, 0x9, 0x19d, 
       0x4, 0x19e, 0x9, 0x19e, 0x4, 0x19f, 0x9, 0x19f, 0x4, 0x1a0, 0x9, 
       0x1a0, 0x4, 0x1a1, 0x9, 0x1a1, 0x4, 0x1a2, 0x9, 0x1a2, 0x4, 0x1a3, 
       0x9, 0x1a3, 0x4, 0x1a4, 0x9, 0x1a4, 0x4, 0x1a5, 0x9, 0x1a5, 0x4, 
       0x1a6, 0x9, 0x1a6, 0x4, 0x1a7, 0x9, 0x1a7, 0x4, 0x1a8, 0x9, 0x1a8, 
       0x4, 0x1a9, 0x9, 0x1a9, 0x4, 0x1aa, 0x9, 0x1aa, 0x4, 0x1ab, 0x9, 
       0x1ab, 0x4, 0x1ac, 0x9, 0x1ac, 0x4, 0x1ad, 0x9, 0x1ad, 0x4, 0x1ae, 
       0x9, 0x1ae, 0x4, 0x1af, 0x9, 0x1af, 0x4, 0x1b0, 0x9, 0x1b0, 0x4, 
       0x1b1, 0x9, 0x1b1, 0x4, 0x1b2, 0x9, 0x1b2, 0x4, 0x1b3, 0x9, 0x1b3, 
       0x4, 0x1b4, 0x9, 0x1b4, 0x4, 0x1b5, 0x9, 0x1b5, 0x4, 0x1b6, 0x9, 
       0x1b6, 0x4, 0x1b7, 0x9, 0x1b7, 0x4, 0x1b8, 0x9, 0x1b8, 0x4, 0x1b9, 
       0x9, 0x1b9, 0x4, 0x1ba, 0x9, 0x1ba, 0x4, 0x1bb, 0x9, 0x1bb, 0x4, 
       0x1bc, 0x9, 0x1bc, 0x4, 0x1bd, 0x9, 0x1bd, 0x4, 0x1be, 0x9, 0x1be, 
       0x4, 0x1bf, 0x9, 0x1bf, 0x4, 0x1c0, 0x9, 0x1c0, 0x4, 0x1c1, 0x9, 
       0x1c1, 0x4, 0x1c2, 0x9, 0x1c2, 0x4, 0x1c3, 0x9, 0x1c3, 0x4, 0x1c4, 
       0x9, 0x1c4, 0x4, 0x1c5, 0x9, 0x1c5, 0x4, 0x1c6, 0x9, 0x1c6, 0x4, 
       0x1c7, 0x9, 0x1c7, 0x4, 0x1c8, 0x9, 0x1c8, 0x4, 0x1c9, 0x9, 0x1c9, 
       0x4, 0x1ca, 0x9, 0x1ca, 0x4, 0x1cb, 0x9, 0x1cb, 0x4, 0x1cc, 0x9, 
       0x1cc, 0x4, 0x1cd, 0x9, 0x1cd, 0x4, 0x1ce, 0x9, 0x1ce, 0x4, 0x1cf, 
       0x9, 0x1cf, 0x4, 0x1d0, 0x9, 0x1d0, 0x4, 0x1d1, 0x9, 0x1d1, 0x4, 
       0x1d2, 0x9, 0x1d2, 0x4, 0x1d3, 0x9, 0x1d3, 0x4, 0x1d4, 0x9, 0x1d4, 
       0x4, 0x1d5, 0x9, 0x1d5, 0x4, 0x1d6, 0x9, 0x1d6, 0x4, 0x1d7, 0x9, 
       0x1d7, 0x4, 0x1d8, 0x9, 0x1d8, 0x4, 0x1d9, 0x9, 0x1d9, 0x4, 0x1da, 
       0x9, 0x1da, 0x4, 0x1db, 0x9, 0x1db, 0x4, 0x1dc, 0x9, 0x1dc, 0x4, 
       0x1dd, 0x9, 0x1dd, 0x4, 0x1de, 0x9, 0x1de, 0x4, 0x1df, 0x9, 0x1df, 
       0x4, 0x1e0, 0x9, 0x1e0, 0x4, 0x1e1, 0x9, 0x1e1, 0x4, 0x1e2, 0x9, 
       0x1e2, 0x4, 0x1e3, 0x9, 0x1e3, 0x4, 0x1e4, 0x9, 0x1e4, 0x4, 0x1e5, 
       0x9, 0x1e5, 0x4, 0x1e6, 0x9, 0x1e6, 0x4, 0x1e7, 0x9, 0x1e7, 0x4, 
       0x1e8, 0x9, 0x1e8, 0x4, 0x1e9, 0x9, 0x1e9, 0x4, 0x1ea, 0x9, 0x1ea, 
       0x4, 0x1eb, 0x9, 0x1eb, 0x4, 0x1ec, 0x9, 0x1ec, 0x4, 0x1ed, 0x9, 
       0x1ed, 0x4, 0x1ee, 0x9, 0x1ee, 0x4, 0x1ef, 0x9, 0x1ef, 0x4, 0x1f0, 
       0x9, 0x1f0, 0x4, 0x1f1, 0x9, 0x1f1, 0x4, 0x1f2, 0x9, 0x1f2, 0x4, 
       0x1f3, 0x9, 0x1f3, 0x4, 0x1f4, 0x9, 0x1f4, 0x4, 0x1f5, 0x9, 0x1f5, 
       0x4, 0x1f6, 0x9, 0x1f6, 0x4, 0x1f7, 0x9, 0x1f7, 0x4, 0x1f8, 0x9, 
       0x1f8, 0x4, 0x1f9, 0x9, 0x1f9, 0x4, 0x1fa, 0x9, 0x1fa, 0x4, 0x1fb, 
       0x9, 0x1fb, 0x4, 0x1fc, 0x9, 0x1fc, 0x4, 0x1fd, 0x9, 0x1fd, 0x4, 
       0x1fe, 0x9, 0x1fe, 0x4, 0x1ff, 0x9, 0x1ff, 0x4, 0x200, 0x9, 0x200, 
       0x4, 0x201, 0x9, 0x201, 0x4, 0x202, 0x9, 0x202, 0x4, 0x203, 0x9, 
       0x203, 0x4, 0x204, 0x9, 0x204, 0x4, 0x205, 0x9, 0x205, 0x4, 0x206, 
       0x9, 0x206, 0x4, 0x207, 0x9, 0x207, 0x4, 0x208, 0x9, 0x208, 0x4, 
       0x209, 0x9, 0x209, 0x4, 0x20a, 0x9, 0x20a, 0x4, 0x20b, 0x9, 0x20b, 
       0x4, 0x20c, 0x9, 0x20c, 0x4, 0x20d, 0x9, 0x20d, 0x4, 0x20e, 0x9, 
       0x20e, 0x4, 0x20f, 0x9, 0x20f, 0x4, 0x210, 0x9, 0x210, 0x4, 0x211, 
       0x9, 0x211, 0x4, 0x212, 0x9, 0x212, 0x4, 0x213, 0x9, 0x213, 0x4, 
       0x214, 0x9, 0x214, 0x4, 0x215, 0x9, 0x215, 0x4, 0x216, 0x9, 0x216, 
       0x4, 0x217, 0x9, 0x217, 0x4, 0x218, 0x9, 0x218, 0x4, 0x219, 0x9, 
       0x219, 0x3, 0x2, 0x3, 0x2, 0x5, 0x2, 0x435, 0xa, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x7, 0x3, 0x43c, 0xa, 0x3, 0xc, 
       0x3, 0xe, 0x3, 0x43f, 0xb, 0x3, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x4a9, 0xa, 0x4, 0x3, 0x5, 
       0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x7, 0x5, 0x4b0, 0xa, 0x5, 
       0xc, 0x5, 0xe, 0x5, 0x4b3, 0xb, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 
       0x3, 0x5, 0x3, 0x5, 0x7, 0x5, 0x4ba, 0xa, 0x5, 0xc, 0x5, 0xe, 0x5, 
       0x4bd, 0xb, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x4c2, 0xa, 
       0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 
       0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x4cf, 
       0xa, 0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x7, 
       0x7, 0x4d6, 0xa, 0x7, 0xc, 0x7, 0xe, 0x7, 0x4d9, 0xb, 0x7, 0x3, 0x7, 
       0x7, 0x7, 0x4dc, 0xa, 0x7, 0xc, 0x7, 0xe, 0x7, 0x4df, 0xb, 0x7, 0x3, 
       0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x9, 0x3, 0x9, 0x3, 0x9, 0x3, 0x9, 
       0x3, 0x9, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 
       0xa, 0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 0x3, 0xc, 
       0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x4fa, 
       0xa, 0xc, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 
       0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 
       0x5, 0xd, 0x508, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 
       0x5, 0xe, 0x50e, 0xa, 0xe, 0x3, 0xe, 0x7, 0xe, 0x511, 0xa, 0xe, 0xc, 
       0xe, 0xe, 0xe, 0x514, 0xb, 0xe, 0x3, 0xf, 0x3, 0xf, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x54d, 0xa, 0x10, 
       0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x553, 0xa, 
       0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 
       0x13, 0x3, 0x13, 0x5, 0x13, 0x55c, 0xa, 0x13, 0x3, 0x14, 0x3, 0x14, 
       0x3, 0x14, 0x3, 0x14, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x16, 
       0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x7, 0x17, 0x56c, 0xa, 0x17, 0xc, 0x17, 0xe, 0x17, 0x56f, 0xb, 0x17, 
       0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x19, 0x3, 0x19, 
       0x3, 0x19, 0x3, 0x19, 0x5, 0x19, 0x579, 0xa, 0x19, 0x3, 0x19, 0x7, 
       0x19, 0x57c, 0xa, 0x19, 0xc, 0x19, 0xe, 0x19, 0x57f, 0xb, 0x19, 0x3, 
       0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x585, 0xa, 0x1a, 
       0x3, 0x1a, 0x7, 0x1a, 0x588, 0xa, 0x1a, 0xc, 0x1a, 0xe, 0x1a, 0x58b, 
       0xb, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 
       0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 
       0x597, 0xa, 0x1c, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x5, 
       0x1d, 0x59d, 0xa, 0x1d, 0x3, 0x1d, 0x7, 0x1d, 0x5a0, 0xa, 0x1d, 0xc, 
       0x1d, 0xe, 0x1d, 0x5a3, 0xb, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 
       0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 
       0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x5, 0x1f, 0x5b2, 0xa, 
       0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 
       0x20, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x5bc, 0xa, 0x20, 0x3, 0x21, 
       0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x5c2, 0xa, 0x21, 0x3, 
       0x21, 0x7, 0x21, 0x5c5, 0xa, 0x21, 0xc, 0x21, 0xe, 0x21, 0x5c8, 0xb, 
       0x21, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x3, 0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x3, 0x24, 0x5, 0x24, 0x5d7, 0xa, 0x24, 0x3, 0x24, 0x3, 0x24, 
       0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x5de, 0xa, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x7, 0x25, 0x5e3, 0xa, 0x25, 0xc, 0x25, 
       0xe, 0x25, 0x5e6, 0xb, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x7, 0x25, 0x5ec, 0xa, 0x25, 0xc, 0x25, 0xe, 0x25, 0x5ef, 0xb, 
       0x25, 0x5, 0x25, 0x5f1, 0xa, 0x25, 0x3, 0x26, 0x3, 0x26, 0x3, 0x27, 
       0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 
       0x5fb, 0xa, 0x27, 0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x5ff, 0xa, 0x28, 
       0x3, 0x28, 0x3, 0x28, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x5, 0x29, 0x61d, 0xa, 
       0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 
       0x29, 0x5, 0x29, 0x625, 0xa, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x5, 0x29, 0x62a, 0xa, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 
       0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x7, 0x2a, 0x632, 0xa, 0x2a, 0xc, 0x2a, 
       0xe, 0x2a, 0x635, 0xb, 0x2a, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x7, 
       0x2b, 0x63a, 0xa, 0x2b, 0xc, 0x2b, 0xe, 0x2b, 0x63d, 0xb, 0x2b, 0x3, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x642, 0xa, 0x2c, 0x3, 0x2d, 
       0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x649, 0xa, 
       0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 
       0x2f, 0x5, 0x2f, 0x651, 0xa, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x5, 0x2f, 
       0x655, 0xa, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x5, 0x2f, 0x65a, 
       0xa, 0x2f, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x31, 
       0x3, 0x31, 0x5, 0x31, 0x662, 0xa, 0x31, 0x3, 0x32, 0x3, 0x32, 0x5, 
       0x32, 0x666, 0xa, 0x32, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x676, 0xa, 
       0x33, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x5, 0x34, 0x67b, 0xa, 0x34, 
       0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 
       0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 
       0x3, 0x35, 0x3, 0x35, 0x5, 0x35, 0x68b, 0xa, 0x35, 0x3, 0x36, 0x3, 
       0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x37, 0x3, 0x37, 0x5, 
       0x37, 0x694, 0xa, 0x37, 0x3, 0x38, 0x3, 0x38, 0x3, 0x39, 0x3, 0x39, 
       0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x5, 0x3b, 
       0x69f, 0xa, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 
       0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x5, 0x3b, 0x6aa, 
       0xa, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x7, 0x3c, 0x6af, 0xa, 
       0x3c, 0xc, 0x3c, 0xe, 0x3c, 0x6b2, 0xb, 0x3c, 0x3, 0x3d, 0x3, 0x3d, 
       0x5, 0x3d, 0x6b6, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 
       0x3d, 0x6bb, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x5, 0x3d, 0x6c2, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x6cb, 
       0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x6d4, 0xa, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 
       0x3d, 0x6dd, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x6e6, 0xa, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x6ea, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x5, 0x3d, 0x6ee, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x5, 0x3d, 0x6f4, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x6fc, 0xa, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x709, 
       0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 
       0x715, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x719, 0xa, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x5, 0x3d, 0x721, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x5, 0x3d, 0x727, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x72e, 0xa, 0x3d, 0x3, 0x3e, 0x3, 
       0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 
       0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x5, 0x40, 0x73c, 
       0xa, 0x40, 0x3, 0x40, 0x5, 0x40, 0x73f, 0xa, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x5, 0x40, 0x743, 0xa, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 
       0x5, 0x40, 0x748, 0xa, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 
       0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 
       0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 
       0x42, 0x759, 0xa, 0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 
       0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x762, 0xa, 0x43, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x767, 0xa, 0x44, 0x3, 0x44, 
       0x5, 0x44, 0x76a, 0xa, 0x44, 0x3, 0x44, 0x5, 0x44, 0x76d, 0xa, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 
       0x774, 0xa, 0x44, 0x3, 0x44, 0x5, 0x44, 0x777, 0xa, 0x44, 0x3, 0x44, 
       0x5, 0x44, 0x77a, 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x5, 0x44, 0x780, 0xa, 0x44, 0x3, 0x44, 0x5, 0x44, 0x783, 0xa, 
       0x44, 0x3, 0x44, 0x5, 0x44, 0x786, 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x44, 0x5, 0x44, 0x797, 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x79f, 0xa, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x7a4, 0xa, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x5, 0x44, 0x7ae, 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x7b5, 0xa, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x7d2, 0xa, 0x44, 0x3, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x5, 0x44, 0x7db, 0xa, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 
       0x44, 0x7e0, 0xa, 0x44, 0x5, 0x44, 0x7e2, 0xa, 0x44, 0x3, 0x45, 0x3, 
       0x45, 0x3, 0x45, 0x7, 0x45, 0x7e7, 0xa, 0x45, 0xc, 0x45, 0xe, 0x45, 
       0x7ea, 0xb, 0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 
       0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x7f4, 0xa, 0x46, 
       0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x5, 0x47, 
       0x7fb, 0xa, 0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 
       0x49, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x805, 0xa, 0x4a, 
       0x3, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x809, 0xa, 0x4b, 0x3, 0x4b, 0x3, 
       0x4b, 0x5, 0x4b, 0x80d, 0xa, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x810, 0xa, 
       0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x814, 0xa, 0x4b, 0x3, 0x4b, 
       0x3, 0x4b, 0x5, 0x4b, 0x818, 0xa, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x81b, 
       0xa, 0x4b, 0x3, 0x4b, 0x7, 0x4b, 0x81e, 0xa, 0x4b, 0xc, 0x4b, 0xe, 
       0x4b, 0x821, 0xb, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x824, 0xa, 0x4b, 0x3, 
       0x4b, 0x5, 0x4b, 0x827, 0xa, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 
       0x3, 0x4b, 0x5, 0x4b, 0x82d, 0xa, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x5, 
       0x4b, 0x831, 0xa, 0x4b, 0x3, 0x4b, 0x7, 0x4b, 0x834, 0xa, 0x4b, 0xc, 
       0x4b, 0xe, 0x4b, 0x837, 0xb, 0x4b, 0x5, 0x4b, 0x839, 0xa, 0x4b, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 
       0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x5, 0x4e, 0x844, 0xa, 0x4e, 0x3, 0x4f, 
       0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 0x84a, 0xa, 0x4f, 0x3, 
       0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 
       0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 
       0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 0x85b, 0xa, 0x4f, 0x3, 0x50, 
       0x3, 0x50, 0x3, 0x50, 0x3, 0x51, 0x5, 0x51, 0x861, 0xa, 0x51, 0x3, 
       0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x868, 
       0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 
       0x86e, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x872, 0xa, 0x52, 
       0x3, 0x52, 0x5, 0x52, 0x875, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x878, 
       0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x87b, 0xa, 0x52, 0x3, 0x52, 0x5, 
       0x52, 0x87e, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x881, 0xa, 0x52, 0x3, 
       0x53, 0x5, 0x53, 0x884, 0xa, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x54, 
       0x3, 0x54, 0x3, 0x54, 0x7, 0x54, 0x88b, 0xa, 0x54, 0xc, 0x54, 0xe, 
       0x54, 0x88e, 0xb, 0x54, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 
       0x5, 0x55, 0x894, 0xa, 0x55, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 
       0x56, 0x89f, 0xa, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x7, 0x57, 
       0x8a4, 0xa, 0x57, 0xc, 0x57, 0xe, 0x57, 0x8a7, 0xb, 0x57, 0x3, 0x57, 
       0x5, 0x57, 0x8aa, 0xa, 0x57, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 
       0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 0x8b2, 0xa, 0x58, 0x3, 0x59, 
       0x3, 0x59, 0x3, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x5, 0x5a, 0x8bc, 0xa, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x8bf, 
       0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x8c4, 0xa, 
       0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x8c7, 0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x8d3, 0xa, 0x5a, 0x3, 0x5a, 0x5, 
       0x5a, 0x8d6, 0xa, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x8d9, 0xa, 0x5a, 0x5, 
       0x5a, 0x8db, 0xa, 0x5a, 0x3, 0x5b, 0x5, 0x5b, 0x8de, 0xa, 0x5b, 0x3, 
       0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x8e3, 0xa, 0x5b, 0x3, 0x5c, 
       0x3, 0x5c, 0x3, 0x5c, 0x7, 0x5c, 0x8e8, 0xa, 0x5c, 0xc, 0x5c, 0xe, 
       0x5c, 0x8eb, 0xb, 0x5c, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 
       0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x8f3, 0xa, 0x5d, 0x3, 0x5e, 0x3, 
       0x5e, 0x5, 0x5e, 0x8f7, 0xa, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5f, 
       0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 
       0x3, 0x5f, 0x5, 0x5f, 0x903, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, 
       0x5f, 0x907, 0xa, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x90a, 0xa, 0x5f, 0x3, 
       0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, 
       0x5f, 0x912, 0xa, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x915, 0xa, 0x5f, 0x3, 
       0x5f, 0x5, 0x5f, 0x918, 0xa, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x91b, 0xa, 
       0x5f, 0x5, 0x5f, 0x91d, 0xa, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 
       0x3, 0x60, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x62, 
       0x3, 0x62, 0x3, 0x62, 0x7, 0x62, 0x92a, 0xa, 0x62, 0xc, 0x62, 0xe, 
       0x62, 0x92d, 0xb, 0x62, 0x3, 0x63, 0x3, 0x63, 0x3, 0x64, 0x3, 0x64, 
       0x3, 0x64, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 
       0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x5, 0x65, 0x93c, 0xa, 0x65, 0x3, 
       0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 
       0x68, 0x3, 0x68, 0x5, 0x68, 0x94c, 0xa, 0x68, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 
       0x3, 0x6a, 0x5, 0x6a, 0x957, 0xa, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x3, 
       0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x5, 0x6b, 0x960, 
       0xa, 0x6b, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 
       0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x96f, 0xa, 0x6e, 0x3, 0x6f, 0x3, 
       0x6f, 0x3, 0x70, 0x6, 0x70, 0x974, 0xa, 0x70, 0xd, 0x70, 0xe, 0x70, 
       0x975, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 0x97c, 
       0xa, 0x71, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 0x980, 0xa, 0x71, 0x3, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x7, 0x74, 0x98d, 
       0xa, 0x74, 0xc, 0x74, 0xe, 0x74, 0x990, 0xb, 0x74, 0x3, 0x75, 0x3, 
       0x75, 0x3, 0x75, 0x7, 0x75, 0x995, 0xa, 0x75, 0xc, 0x75, 0xe, 0x75, 
       0x998, 0xb, 0x75, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 
       0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 
       0x76, 0x5, 0x76, 0x9a5, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 
       0x7, 0x76, 0x9aa, 0xa, 0x76, 0xc, 0x76, 0xe, 0x76, 0x9ad, 0xb, 0x76, 
       0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 
       0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 
       0x9ba, 0xa, 0x77, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x7, 0x78, 0x9bf, 
       0xa, 0x78, 0xc, 0x78, 0xe, 0x78, 0x9c2, 0xb, 0x78, 0x3, 0x79, 0x3, 
       0x79, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x5, 0x7a, 0x9c9, 0xa, 0x7a, 
       0x3, 0x7a, 0x3, 0x7a, 0x5, 0x7a, 0x9cd, 0xa, 0x7a, 0x3, 0x7b, 0x3, 
       0x7b, 0x3, 0x7b, 0x5, 0x7b, 0x9d2, 0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 
       0x5, 0x7b, 0x9d6, 0xa, 0x7b, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 
       0x7c, 0x3, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 0x9e0, 
       0xa, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 0x9e3, 0xa, 0x7d, 0x3, 0x7d, 0x3, 
       0x7d, 0x5, 0x7d, 0x9e7, 0xa, 0x7d, 0x5, 0x7d, 0x9e9, 0xa, 0x7d, 0x3, 
       0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x3, 
       0x7f, 0x7, 0x7f, 0x9f2, 0xa, 0x7f, 0xc, 0x7f, 0xe, 0x7f, 0x9f5, 0xb, 
       0x7f, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x7, 0x80, 0x9fa, 0xa, 0x80, 
       0xc, 0x80, 0xe, 0x80, 0x9fd, 0xb, 0x80, 0x3, 0x81, 0x3, 0x81, 0x3, 
       0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x5, 0x81, 0xa06, 
       0xa, 0x81, 0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xa0a, 0xa, 0x82, 0x3, 
       0x83, 0x3, 0x83, 0x5, 0x83, 0xa0e, 0xa, 0x83, 0x3, 0x83, 0x5, 0x83, 
       0xa11, 0xa, 0x83, 0x3, 0x83, 0x5, 0x83, 0xa14, 0xa, 0x83, 0x3, 0x83, 
       0x5, 0x83, 0xa17, 0xa, 0x83, 0x3, 0x83, 0x5, 0x83, 0xa1a, 0xa, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0xa1e, 0xa, 0x83, 0x3, 0x84, 0x3, 
       0x84, 0x5, 0x84, 0xa22, 0xa, 0x84, 0x3, 0x84, 0x5, 0x84, 0xa25, 0xa, 
       0x84, 0x3, 0x84, 0x5, 0x84, 0xa28, 0xa, 0x84, 0x3, 0x84, 0x5, 0x84, 
       0xa2b, 0xa, 0x84, 0x3, 0x84, 0x5, 0x84, 0xa2e, 0xa, 0x84, 0x3, 0x84, 
       0x3, 0x84, 0x5, 0x84, 0xa32, 0xa, 0x84, 0x3, 0x85, 0x3, 0x85, 0x5, 
       0x85, 0xa36, 0xa, 0x85, 0x3, 0x85, 0x5, 0x85, 0xa39, 0xa, 0x85, 0x3, 
       0x85, 0x5, 0x85, 0xa3c, 0xa, 0x85, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 
       0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x88, 0x3, 0x88, 
       0x3, 0x88, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x8a, 
       0x3, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xa51, 0xa, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xa55, 0xa, 0x8b, 0x3, 0x8b, 
       0x5, 0x8b, 0xa58, 0xa, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xa5b, 0xa, 0x8b, 
       0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0xa5f, 0xa, 0x8c, 0x3, 0x8c, 0x7, 
       0x8c, 0xa62, 0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 0xa65, 0xb, 0x8c, 0x3, 
       0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 
       0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0xa72, 
       0xa, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0xa75, 0xa, 0x8e, 0x3, 0x8f, 0x3, 
       0x8f, 0x3, 0x8f, 0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 0xa7c, 0xa, 0x90, 
       0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 
       0xa83, 0xa, 0x90, 0x3, 0x90, 0x5, 0x90, 0xa86, 0xa, 0x90, 0x3, 0x90, 
       0x5, 0x90, 0xa89, 0xa, 0x90, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 0xa8d, 
       0xa, 0x91, 0x3, 0x91, 0x5, 0x91, 0xa90, 0xa, 0x91, 0x3, 0x91, 0x5, 
       0x91, 0xa93, 0xa, 0x91, 0x3, 0x91, 0x5, 0x91, 0xa96, 0xa, 0x91, 0x3, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x93, 0x3, 0x93, 0x3, 
       0x93, 0x7, 0x93, 0xa9f, 0xa, 0x93, 0xc, 0x93, 0xe, 0x93, 0xaa2, 0xb, 
       0x93, 0x3, 0x94, 0x3, 0x94, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xaa8, 
       0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 
       0xaae, 0xa, 0x95, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xab2, 0xa, 0x96, 
       0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xab6, 0xa, 0x96, 0x3, 0x96, 0x5, 
       0x96, 0xab9, 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 
       0x5, 0x96, 0xabf, 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 
       0x96, 0x3, 0x96, 0x5, 0x96, 0xac6, 0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 
       0xac9, 0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 0xacc, 0xa, 0x96, 0x3, 0x96, 
       0x5, 0x96, 0xacf, 0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 0xad2, 0xa, 0x96, 
       0x3, 0x97, 0x3, 0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 
       0x3, 0x98, 0x7, 0x98, 0xadb, 0xa, 0x98, 0xc, 0x98, 0xe, 0x98, 0xade, 
       0xb, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x7, 0x98, 0xae3, 0xa, 
       0x98, 0xc, 0x98, 0xe, 0x98, 0xae6, 0xb, 0x98, 0x5, 0x98, 0xae8, 0xa, 
       0x98, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x5, 
       0x99, 0xaef, 0xa, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 
       0x5, 0x99, 0xaf5, 0xa, 0x99, 0x3, 0x99, 0x5, 0x99, 0xaf8, 0xa, 0x99, 
       0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 
       0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 
       0x5, 0x9b, 0xb06, 0xa, 0x9b, 0x3, 0x9c, 0x6, 0x9c, 0xb09, 0xa, 0x9c, 
       0xd, 0x9c, 0xe, 0x9c, 0xb0a, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x7, 
       0x9d, 0xb10, 0xa, 0x9d, 0xc, 0x9d, 0xe, 0x9d, 0xb13, 0xb, 0x9d, 0x3, 
       0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 
       0x9e, 0x3, 0x9e, 0x5, 0x9e, 0xb1d, 0xa, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 
       0x5, 0x9f, 0xb21, 0xa, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 
       0x9f, 0xb26, 0xa, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xb2f, 0xa, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xb35, 0xa, 0x9f, 
       0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 
       0x3, 0xa1, 0x3, 0xa1, 0x5, 0xa1, 0xb3f, 0xa, 0xa1, 0x3, 0xa2, 0x3, 
       0xa2, 0x3, 0xa2, 0x7, 0xa2, 0xb44, 0xa, 0xa2, 0xc, 0xa2, 0xe, 0xa2, 
       0xb47, 0xb, 0xa2, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa4, 0x3, 
       0xa4, 0x3, 0xa4, 0x7, 0xa4, 0xb4f, 0xa, 0xa4, 0xc, 0xa4, 0xe, 0xa4, 
       0xb52, 0xb, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 0x5, 0xa5, 0xb56, 0xa, 0xa5, 
       0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa7, 0x5, 0xa7, 0xb5c, 0xa, 
       0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x5, 
       0xa7, 0xb63, 0xa, 0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 
       0x3, 0xa8, 0x3, 0xa8, 0x5, 0xa8, 0xb6b, 0xa, 0xa8, 0x3, 0xa9, 0x3, 
       0xa9, 0x3, 0xaa, 0x6, 0xaa, 0xb70, 0xa, 0xaa, 0xd, 0xaa, 0xe, 0xaa, 
       0xb71, 0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 0xb76, 0xa, 0xab, 0x3, 0xab, 
       0x3, 0xab, 0x5, 0xab, 0xb7a, 0xa, 0xab, 0x3, 0xac, 0x3, 0xac, 0x5, 
       0xac, 0xb7e, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 
       0xb83, 0xa, 0xac, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x5, 
       0xad, 0xb89, 0xa, 0xad, 0x3, 0xae, 0x6, 0xae, 0xb8c, 0xa, 0xae, 0xd, 
       0xae, 0xe, 0xae, 0xb8d, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 
       0xb93, 0xa, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 
       0xaf, 0x5, 0xaf, 0xb9a, 0xa, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 
       0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 
       0x3, 0xaf, 0x5, 0xaf, 0xba6, 0xa, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 0xba9, 
       0xa, 0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xbad, 0xa, 0xb0, 0x3, 
       0xb1, 0x5, 0xb1, 0xbb0, 0xa, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb2, 
       0x3, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xbb8, 0xa, 0xb3, 0x3, 
       0xb3, 0x5, 0xb3, 0xbbb, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x5, 0xb3, 0xbc0, 0xa, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x5, 
       0xb4, 0xbc5, 0xa, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xbc8, 0xa, 0xb4, 0x3, 
       0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xbce, 0xa, 0xb5, 
       0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 
       0x3, 0xb7, 0x5, 0xb7, 0xbd7, 0xa, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb9, 0x3, 0xb9, 0x5, 0xb9, 0xbdd, 0xa, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 
       0x3, 0xb9, 0x5, 0xb9, 0xbe2, 0xa, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x5, 
       0xb9, 0xbe6, 0xa, 0xb9, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 
       0x5, 0xba, 0xbec, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 
       0xba, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x7, 0xbb, 0xbf5, 0xa, 0xbb, 
       0xc, 0xbb, 0xe, 0xbb, 0xbf8, 0xb, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 0x3, 
       0xbc, 0x3, 0xbc, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbe, 0x3, 
       0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xc05, 0xa, 0xbe, 0x3, 0xbe, 
       0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 
       0x3, 0xbf, 0x5, 0xbf, 0xc0f, 0xa, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x5, 
       0xbf, 0xc13, 0xa, 0xbf, 0x3, 0xbf, 0x5, 0xbf, 0xc16, 0xa, 0xbf, 0x3, 
       0xc0, 0x6, 0xc0, 0xc19, 0xa, 0xc0, 0xd, 0xc0, 0xe, 0xc0, 0xc1a, 0x3, 
       0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x5, 
       0xc1, 0xc23, 0xa, 0xc1, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 
       0x3, 0xc2, 0x5, 0xc2, 0xc2a, 0xa, 0xc2, 0x3, 0xc3, 0x6, 0xc3, 0xc2d, 
       0xa, 0xc3, 0xd, 0xc3, 0xe, 0xc3, 0xc2e, 0x3, 0xc4, 0x3, 0xc4, 0x3, 
       0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 
       0xc5, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 
       0xc6, 0x5, 0xc6, 0xc4c, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 
       0xc7a, 0xa, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xc84, 0xa, 0xc7, 
       0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 
       0xc8b, 0xa, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x5, 0xc7, 0xc98, 0xa, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xc9b, 0xa, 
       0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xca5, 0xa, 0xc7, 0x3, 0xc7, 
       0x3, 0xc7, 0x5, 0xc7, 0xca9, 0xa, 0xc7, 0x3, 0xc8, 0x3, 0xc8, 0x3, 
       0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x7, 0xc9, 0xcb0, 0xa, 0xc9, 0xc, 0xc9, 
       0xe, 0xc9, 0xcb3, 0xb, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 0xcb, 0x3, 
       0xcb, 0x5, 0xcb, 0xcb9, 0xa, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcc, 
       0x3, 0xcc, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x7, 0xcd, 0xcc2, 0xa, 
       0xcd, 0xc, 0xcd, 0xe, 0xcd, 0xcc5, 0xb, 0xcd, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0xccd, 0xa, 
       0xce, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xd0, 0x3, 0xd0, 0x5, 
       0xd0, 0xcd4, 0xa, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x5, 0xd0, 0xcd8, 0xa, 
       0xd0, 0x5, 0xd0, 0xcda, 0xa, 0xd0, 0x3, 0xd1, 0x5, 0xd1, 0xcdd, 0xa, 
       0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 
       0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x5, 
       0xd3, 0xcea, 0xa, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 
       0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x5, 0xd3, 0xcf4, 0xa, 
       0xd3, 0x5, 0xd3, 0xcf6, 0xa, 0xd3, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 
       0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 
       0xd00, 0xa, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x5, 
       0xd5, 0xd06, 0xa, 0xd5, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xd0a, 0xa, 
       0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 
       0xd6, 0x5, 0xd6, 0xd12, 0xa, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xd2b, 0xa, 0xd6, 0x3, 0xd6, 0x3, 
       0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 
       0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xd38, 0xa, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xd43, 0xa, 0xd6, 0x3, 
       0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x3, 
       0xd8, 0x7, 0xd8, 0xd4c, 0xa, 0xd8, 0xc, 0xd8, 0xe, 0xd8, 0xd4f, 0xb, 
       0xd8, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x5, 
       0xd9, 0xd56, 0xa, 0xd9, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 
       0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0xd5f, 0xa, 0xda, 0x3, 
       0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x5, 0xdb, 0xd65, 0xa, 0xdb, 
       0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdd, 0x3, 0xdd, 
       0x3, 0xdd, 0x7, 0xdd, 0xd6e, 0xa, 0xdd, 0xc, 0xdd, 0xe, 0xdd, 0xd71, 
       0xb, 0xdd, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xdf, 
       0x3, 0xdf, 0x3, 0xdf, 0x7, 0xdf, 0xd7a, 0xa, 0xdf, 0xc, 0xdf, 0xe, 
       0xdf, 0xd7d, 0xb, 0xdf, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe0, 
       0x3, 0xe0, 0x5, 0xe0, 0xd84, 0xa, 0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x3, 
       0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x5, 0xe0, 0xd8c, 0xa, 0xe0, 
       0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 
       0x7, 0xe1, 0xd94, 0xa, 0xe1, 0xc, 0xe1, 0xe, 0xe1, 0xd97, 0xb, 0xe1, 
       0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x5, 0xe2, 0xd9d, 0xa, 
       0xe2, 0x3, 0xe2, 0x5, 0xe2, 0xda0, 0xa, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 
       0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 
       0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x5, 0xe2, 
       0xdaf, 0xa, 0xe2, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe4, 0x3, 
       0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 
       0xe5, 0xdcd, 0xa, 0xe5, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x7, 0xe6, 
       0xdd2, 0xa, 0xe6, 0xc, 0xe6, 0xe, 0xe6, 0xdd5, 0xb, 0xe6, 0x3, 0xe7, 
       0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe8, 0x3, 0xe8, 0x3, 0xe8, 
       0x3, 0xe8, 0x3, 0xe8, 0x5, 0xe8, 0xde0, 0xa, 0xe8, 0x3, 0xe8, 0x3, 
       0xe8, 0x3, 0xe8, 0x3, 0xe8, 0x5, 0xe8, 0xde6, 0xa, 0xe8, 0x3, 0xe9, 
       0x3, 0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x5, 0xe9, 0xded, 0xa, 
       0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x5, 0xe9, 0xdf3, 
       0xa, 0xe9, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 
       0x5, 0xea, 0xdfa, 0xa, 0xea, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 
       0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xec, 0x3, 0xec, 0x3, 
       0xec, 0x3, 0xec, 0x5, 0xec, 0xe07, 0xa, 0xec, 0x3, 0xec, 0x3, 0xec, 
       0x5, 0xec, 0xe0b, 0xa, 0xec, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 
       0xed, 0xe10, 0xa, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 
       0xe21, 0xa, 0xed, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x7, 0xee, 0xe26, 
       0xa, 0xee, 0xc, 0xee, 0xe, 0xee, 0xe29, 0xb, 0xee, 0x3, 0xef, 0x3, 
       0xef, 0x5, 0xef, 0xe2d, 0xa, 0xef, 0x3, 0xf0, 0x3, 0xf0, 0x6, 0xf0, 
       0xe31, 0xa, 0xf0, 0xd, 0xf0, 0xe, 0xf0, 0xe32, 0x3, 0xf1, 0x3, 0xf1, 
       0x5, 0xf1, 0xe37, 0xa, 0xf1, 0x3, 0xf1, 0x3, 0xf1, 0x5, 0xf1, 0xe3b, 
       0xa, 0xf1, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf3, 
       0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x5, 0xf4, 
       0xe71, 0xa, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 
       0xf4, 0x3, 0xf4, 0x5, 0xf4, 0xe79, 0xa, 0xf4, 0x3, 0xf5, 0x3, 0xf5, 
       0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 
       0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 
       0x3, 0xf5, 0x3, 0xf5, 0x5, 0xf5, 0xe8b, 0xa, 0xf5, 0x3, 0xf6, 0x3, 
       0xf6, 0x5, 0xf6, 0xe8f, 0xa, 0xf6, 0x3, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 
       0xe93, 0xa, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 0xe96, 0xa, 0xf7, 0x3, 0xf7, 
       0x3, 0xf7, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 
       0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 
       0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 
       0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x5, 0xf8, 0xeae, 0xa, 0xf8, 0x3, 
       0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 
       0xf9, 0x5, 0xf9, 0xeb7, 0xa, 0xf9, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 
       0x3, 0xfa, 0x5, 0xfa, 0xebd, 0xa, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x3, 
       0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x5, 0xfa, 0xec5, 0xa, 0xfa, 
       0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x5, 0xfb, 0xeca, 0xa, 0xfb, 0x5, 
       0xfb, 0xecc, 0xa, 0xfb, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x7, 0xfc, 
       0xed1, 0xa, 0xfc, 0xc, 0xfc, 0xe, 0xfc, 0xed4, 0xb, 0xfc, 0x3, 0xfd, 
       0x3, 0xfd, 0x3, 0xfe, 0x3, 0xfe, 0x5, 0xfe, 0xeda, 0xa, 0xfe, 0x3, 
       0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 
       0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 
       0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x5, 0xfe, 0xeeb, 0xa, 0xfe, 0x3, 0xff, 
       0x3, 0xff, 0x3, 0xff, 0x7, 0xff, 0xef0, 0xa, 0xff, 0xc, 0xff, 0xe, 
       0xff, 0xef3, 0xb, 0xff, 0x3, 0x100, 0x3, 0x100, 0x5, 0x100, 0xef7, 
       0xa, 0x100, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 
       0x102, 0x3, 0x102, 0x3, 0x102, 0x7, 0x102, 0xf00, 0xa, 0x102, 0xc, 
       0x102, 0xe, 0x102, 0xf03, 0xb, 0x102, 0x3, 0x103, 0x3, 0x103, 0x3, 
       0x103, 0x3, 0x104, 0x3, 0x104, 0x3, 0x104, 0x3, 0x104, 0x3, 0x104, 
       0x5, 0x104, 0xf0d, 0xa, 0x104, 0x3, 0x104, 0x5, 0x104, 0xf10, 0xa, 
       0x104, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x5, 0x105, 
       0xf16, 0xa, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 
       0x5, 0x105, 0xf1c, 0xa, 0x105, 0x3, 0x105, 0x5, 0x105, 0xf1f, 0xa, 
       0x105, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x107, 
       0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 0x3, 0x108, 0x3, 0x108, 0x5, 
       0x108, 0xf2b, 0xa, 0x108, 0x3, 0x108, 0x3, 0x108, 0x3, 0x108, 0x3, 
       0x108, 0x3, 0x108, 0x3, 0x108, 0x5, 0x108, 0xf33, 0xa, 0x108, 0x3, 
       0x108, 0x3, 0x108, 0x3, 0x108, 0x3, 0x108, 0x5, 0x108, 0xf39, 0xa, 
       0x108, 0x3, 0x108, 0x5, 0x108, 0xf3c, 0xa, 0x108, 0x3, 0x108, 0x5, 
       0x108, 0xf3f, 0xa, 0x108, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x7, 
       0x109, 0xf44, 0xa, 0x109, 0xc, 0x109, 0xe, 0x109, 0xf47, 0xb, 0x109, 
       0x3, 0x10a, 0x3, 0x10a, 0x5, 0x10a, 0xf4b, 0xa, 0x10a, 0x3, 0x10a, 
       0x5, 0x10a, 0xf4e, 0xa, 0x10a, 0x3, 0x10a, 0x5, 0x10a, 0xf51, 0xa, 
       0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x5, 0x10a, 0xf55, 0xa, 0x10a, 0x3, 
       0x10a, 0x5, 0x10a, 0xf58, 0xa, 0x10a, 0x3, 0x10a, 0x5, 0x10a, 0xf5b, 
       0xa, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x5, 
       0x10a, 0xf61, 0xa, 0x10a, 0x3, 0x10a, 0x5, 0x10a, 0xf64, 0xa, 0x10a, 
       0x3, 0x10a, 0x5, 0x10a, 0xf67, 0xa, 0x10a, 0x5, 0x10a, 0xf69, 0xa, 
       0x10a, 0x3, 0x10b, 0x5, 0x10b, 0xf6c, 0xa, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10e, 
       0x3, 0x10e, 0x5, 0x10e, 0xf76, 0xa, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 
       0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x5, 0x10e, 0xf7d, 0xa, 0x10e, 
       0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x5, 
       0x10e, 0xf84, 0xa, 0x10e, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 
       0x110, 0x3, 0x110, 0x5, 0x110, 0xf8b, 0xa, 0x110, 0x3, 0x110, 0x3, 
       0x110, 0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x7, 0x111, 0xf92, 0xa, 
       0x111, 0xc, 0x111, 0xe, 0x111, 0xf95, 0xb, 0x111, 0x3, 0x112, 0x3, 
       0x112, 0x5, 0x112, 0xf99, 0xa, 0x112, 0x3, 0x112, 0x3, 0x112, 0x3, 
       0x113, 0x3, 0x113, 0x3, 0x113, 0x7, 0x113, 0xfa0, 0xa, 0x113, 0xc, 
       0x113, 0xe, 0x113, 0xfa3, 0xb, 0x113, 0x3, 0x114, 0x5, 0x114, 0xfa6, 
       0xa, 0x114, 0x3, 0x114, 0x5, 0x114, 0xfa9, 0xa, 0x114, 0x3, 0x114, 
       0x3, 0x114, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x5, 0x115, 0xfb0, 
       0xa, 0x115, 0x3, 0x116, 0x3, 0x116, 0x3, 0x117, 0x3, 0x117, 0x3, 
       0x118, 0x3, 0x118, 0x3, 0x119, 0x5, 0x119, 0xfb9, 0xa, 0x119, 0x3, 
       0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x5, 0x119, 0xfbf, 0xa, 
       0x119, 0x3, 0x119, 0x5, 0x119, 0xfc2, 0xa, 0x119, 0x3, 0x11a, 0x3, 
       0x11a, 0x3, 0x11a, 0x7, 0x11a, 0xfc7, 0xa, 0x11a, 0xc, 0x11a, 0xe, 
       0x11a, 0xfca, 0xb, 0x11a, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 
       0x11b, 0x3, 0x11b, 0x5, 0x11b, 0xfd1, 0xa, 0x11b, 0x3, 0x11c, 0x6, 
       0x11c, 0xfd4, 0xa, 0x11c, 0xd, 0x11c, 0xe, 0x11c, 0xfd5, 0x3, 0x11d, 
       0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 
       0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 
       0x3, 0x11d, 0x3, 0x11d, 0x5, 0x11d, 0xfe6, 0xa, 0x11d, 0x3, 0x11d, 
       0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 
       0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 
       0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x5, 
       0x11d, 0xff9, 0xa, 0x11d, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 
       0x11e, 0x3, 0x11e, 0x5, 0x11e, 0x1000, 0xa, 0x11e, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x1005, 0xa, 0x11f, 0x3, 0x120, 0x3, 
       0x120, 0x3, 0x120, 0x3, 0x121, 0x3, 0x121, 0x3, 0x121, 0x7, 0x121, 
       0x100d, 0xa, 0x121, 0xc, 0x121, 0xe, 0x121, 0x1010, 0xb, 0x121, 0x3, 
       0x122, 0x3, 0x122, 0x3, 0x122, 0x3, 0x122, 0x3, 0x122, 0x5, 0x122, 
       0x1017, 0xa, 0x122, 0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x7, 0x123, 
       0x101c, 0xa, 0x123, 0xc, 0x123, 0xe, 0x123, 0x101f, 0xb, 0x123, 0x3, 
       0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 
       0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x5, 0x123, 0x102a, 0xa, 0x123, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1030, 
       0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1035, 
       0xa, 0x124, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 
       0x125, 0x103b, 0xa, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 
       0x125, 0x1040, 0xa, 0x125, 0x3, 0x126, 0x3, 0x126, 0x3, 0x126, 0x3, 
       0x126, 0x5, 0x126, 0x1046, 0xa, 0x126, 0x3, 0x126, 0x3, 0x126, 0x3, 
       0x126, 0x5, 0x126, 0x104b, 0xa, 0x126, 0x3, 0x127, 0x3, 0x127, 0x3, 
       0x127, 0x3, 0x127, 0x5, 0x127, 0x1051, 0xa, 0x127, 0x3, 0x127, 0x3, 
       0x127, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 
       0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 0x3, 
       0x127, 0x3, 0x127, 0x5, 0x127, 0x1061, 0xa, 0x127, 0x3, 0x128, 0x3, 
       0x128, 0x3, 0x128, 0x3, 0x128, 0x3, 0x128, 0x5, 0x128, 0x1068, 0xa, 
       0x128, 0x3, 0x129, 0x3, 0x129, 0x6, 0x129, 0x106c, 0xa, 0x129, 0xd, 
       0x129, 0xe, 0x129, 0x106d, 0x3, 0x12a, 0x5, 0x12a, 0x1071, 0xa, 0x12a, 
       0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12b, 0x3, 0x12b, 0x3, 0x12b, 0x3, 
       0x12b, 0x3, 0x12b, 0x3, 0x12b, 0x3, 0x12b, 0x3, 0x12b, 0x3, 0x12b, 
       0x3, 0x12b, 0x5, 0x12b, 0x107f, 0xa, 0x12b, 0x3, 0x12b, 0x5, 0x12b, 
       0x1082, 0xa, 0x12b, 0x3, 0x12c, 0x3, 0x12c, 0x3, 0x12c, 0x3, 0x12c, 
       0x5, 0x12c, 0x1088, 0xa, 0x12c, 0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 
       0x3, 0x12d, 0x5, 0x12d, 0x108e, 0xa, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 
       0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 0x5, 0x12d, 0x1096, 
       0xa, 0x12d, 0x3, 0x12e, 0x3, 0x12e, 0x3, 0x12e, 0x3, 0x12e, 0x5, 
       0x12e, 0x109c, 0xa, 0x12e, 0x3, 0x12f, 0x3, 0x12f, 0x3, 0x12f, 0x3, 
       0x12f, 0x3, 0x12f, 0x3, 0x12f, 0x3, 0x12f, 0x3, 0x12f, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x5, 0x130, 0x10d3, 0xa, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x5, 0x130, 
       0x10f8, 0xa, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 
       0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 
       0x130, 0x5, 0x130, 0x1125, 0xa, 0x130, 0x3, 0x131, 0x3, 0x131, 0x3, 
       0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 
       0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 
       0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 
       0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 
       0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 
       0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 
       0x132, 0x3, 0x132, 0x3, 0x132, 0x5, 0x132, 0x114d, 0xa, 0x132, 0x3, 
       0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 
       0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 
       0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x5, 0x133, 0x116e, 0xa, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 
       0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 
       0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 
       0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 0x133, 0x3, 
       0x133, 0x3, 0x133, 0x5, 0x133, 0x1198, 0xa, 0x133, 0x3, 0x134, 0x3, 
       0x134, 0x5, 0x134, 0x119c, 0xa, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 
       0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 
       0x5, 0x134, 0x11a6, 0xa, 0x134, 0x3, 0x134, 0x3, 0x134, 0x5, 0x134, 
       0x11aa, 0xa, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x135, 0x3, 0x135, 
       0x3, 0x135, 0x3, 0x135, 0x5, 0x135, 0x11b2, 0xa, 0x135, 0x3, 0x135, 
       0x5, 0x135, 0x11b5, 0xa, 0x135, 0x3, 0x136, 0x3, 0x136, 0x3, 0x136, 
       0x7, 0x136, 0x11ba, 0xa, 0x136, 0xc, 0x136, 0xe, 0x136, 0x11bd, 0xb, 
       0x136, 0x3, 0x137, 0x3, 0x137, 0x3, 0x137, 0x3, 0x137, 0x3, 0x137, 
       0x5, 0x137, 0x11c4, 0xa, 0x137, 0x3, 0x138, 0x3, 0x138, 0x3, 0x139, 
       0x3, 0x139, 0x3, 0x13a, 0x3, 0x13a, 0x3, 0x13a, 0x3, 0x13a, 0x5, 
       0x13a, 0x11ce, 0xa, 0x13a, 0x3, 0x13a, 0x3, 0x13a, 0x3, 0x13a, 0x3, 
       0x13a, 0x5, 0x13a, 0x11d4, 0xa, 0x13a, 0x3, 0x13b, 0x3, 0x13b, 0x3, 
       0x13b, 0x3, 0x13c, 0x3, 0x13c, 0x3, 0x13c, 0x3, 0x13d, 0x3, 0x13d, 
       0x3, 0x13d, 0x3, 0x13d, 0x5, 0x13d, 0x11e0, 0xa, 0x13d, 0x3, 0x13e, 
       0x3, 0x13e, 0x5, 0x13e, 0x11e4, 0xa, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 
       0x5, 0x13e, 0x11e8, 0xa, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 0x11eb, 0xa, 
       0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 0x11f0, 0xa, 
       0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 
       0x11f6, 0xa, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 
       0x11fb, 0xa, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 0x11ff, 0xa, 
       0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 
       0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 0x1208, 0xa, 0x13e, 0x3, 0x13f, 
       0x3, 0x13f, 0x3, 0x140, 0x3, 0x140, 0x3, 0x140, 0x3, 0x140, 0x3, 
       0x140, 0x5, 0x140, 0x1211, 0xa, 0x140, 0x3, 0x141, 0x3, 0x141, 0x3, 
       0x141, 0x7, 0x141, 0x1216, 0xa, 0x141, 0xc, 0x141, 0xe, 0x141, 0x1219, 
       0xb, 0x141, 0x3, 0x141, 0x6, 0x141, 0x121c, 0xa, 0x141, 0xd, 0x141, 
       0xe, 0x141, 0x121d, 0x5, 0x141, 0x1220, 0xa, 0x141, 0x3, 0x142, 0x3, 
       0x142, 0x3, 0x142, 0x5, 0x142, 0x1225, 0xa, 0x142, 0x3, 0x142, 0x5, 
       0x142, 0x1228, 0xa, 0x142, 0x3, 0x142, 0x3, 0x142, 0x3, 0x142, 0x5, 
       0x142, 0x122d, 0xa, 0x142, 0x3, 0x142, 0x3, 0x142, 0x3, 0x142, 0x5, 
       0x142, 0x1232, 0xa, 0x142, 0x3, 0x143, 0x5, 0x143, 0x1235, 0xa, 0x143, 
       0x3, 0x143, 0x3, 0x143, 0x3, 0x143, 0x3, 0x144, 0x3, 0x144, 0x3, 
       0x144, 0x3, 0x145, 0x3, 0x145, 0x3, 0x145, 0x3, 0x145, 0x5, 0x145, 
       0x1241, 0xa, 0x145, 0x3, 0x145, 0x7, 0x145, 0x1244, 0xa, 0x145, 0xc, 
       0x145, 0xe, 0x145, 0x1247, 0xb, 0x145, 0x3, 0x146, 0x3, 0x146, 0x5, 
       0x146, 0x124b, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 0x124f, 
       0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 0x1253, 0xa, 0x146, 
       0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 0x1257, 0xa, 0x146, 0x3, 0x146, 
       0x3, 0x146, 0x5, 0x146, 0x125b, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 
       0x5, 0x146, 0x125f, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 
       0x1263, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 
       0x1268, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 
       0x126d, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 
       0x1272, 0xa, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 0x1276, 0xa, 
       0x146, 0x5, 0x146, 0x1278, 0xa, 0x146, 0x3, 0x147, 0x3, 0x147, 0x3, 
       0x147, 0x3, 0x147, 0x5, 0x147, 0x127e, 0xa, 0x147, 0x3, 0x147, 0x7, 
       0x147, 0x1281, 0xa, 0x147, 0xc, 0x147, 0xe, 0x147, 0x1284, 0xb, 0x147, 
       0x3, 0x148, 0x3, 0x148, 0x3, 0x148, 0x3, 0x148, 0x3, 0x148, 0x3, 
       0x149, 0x3, 0x149, 0x3, 0x149, 0x5, 0x149, 0x128e, 0xa, 0x149, 0x3, 
       0x149, 0x3, 0x149, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 
       0x5, 0x14a, 0x1296, 0xa, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14b, 
       0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x5, 0x14b, 0x129e, 0xa, 0x14b, 
       0x3, 0x14b, 0x3, 0x14b, 0x7, 0x14b, 0x12a2, 0xa, 0x14b, 0xc, 0x14b, 
       0xe, 0x14b, 0x12a5, 0xb, 0x14b, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 
       0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 
       0x3, 0x14d, 0x5, 0x14d, 0x12b6, 0xa, 0x14d, 0x5, 0x14d, 0x12b8, 0xa, 
       0x14d, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 
       0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 
       0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x5, 0x150, 0x12d3, 0xa, 
       0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x5, 0x150, 0x12de, 
       0xa, 0x150, 0x3, 0x150, 0x3, 0x150, 0x5, 0x150, 0x12e2, 0xa, 0x150, 
       0x3, 0x151, 0x3, 0x151, 0x5, 0x151, 0x12e6, 0xa, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x152, 0x3, 0x152, 0x5, 0x152, 
       0x12f3, 0xa, 0x152, 0x3, 0x153, 0x3, 0x153, 0x3, 0x153, 0x5, 0x153, 
       0x12f8, 0xa, 0x153, 0x3, 0x153, 0x3, 0x153, 0x3, 0x153, 0x3, 0x153, 
       0x5, 0x153, 0x12fe, 0xa, 0x153, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 
       0x1302, 0xa, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1305, 0xa, 0x154, 0x3, 
       0x154, 0x5, 0x154, 0x1308, 0xa, 0x154, 0x3, 0x154, 0x5, 0x154, 0x130b, 
       0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x130f, 0xa, 0x154, 
       0x3, 0x154, 0x5, 0x154, 0x1312, 0xa, 0x154, 0x3, 0x154, 0x5, 0x154, 
       0x1315, 0xa, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1318, 0xa, 0x154, 0x3, 
       0x155, 0x3, 0x155, 0x5, 0x155, 0x131c, 0xa, 0x155, 0x3, 0x155, 0x3, 
       0x155, 0x5, 0x155, 0x1320, 0xa, 0x155, 0x3, 0x155, 0x3, 0x155, 0x5, 
       0x155, 0x1324, 0xa, 0x155, 0x3, 0x155, 0x5, 0x155, 0x1327, 0xa, 0x155, 
       0x3, 0x155, 0x3, 0x155, 0x5, 0x155, 0x132b, 0xa, 0x155, 0x5, 0x155, 
       0x132d, 0xa, 0x155, 0x5, 0x155, 0x132f, 0xa, 0x155, 0x3, 0x156, 0x3, 
       0x156, 0x3, 0x157, 0x3, 0x157, 0x3, 0x157, 0x3, 0x157, 0x3, 0x158, 
       0x3, 0x158, 0x5, 0x158, 0x1339, 0xa, 0x158, 0x3, 0x158, 0x5, 0x158, 
       0x133c, 0xa, 0x158, 0x3, 0x158, 0x5, 0x158, 0x133f, 0xa, 0x158, 0x3, 
       0x158, 0x5, 0x158, 0x1342, 0xa, 0x158, 0x3, 0x158, 0x3, 0x158, 0x3, 
       0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 0x134e, 0xa, 0x159, 0x3, 0x15a, 
       0x3, 0x15a, 0x3, 0x15a, 0x5, 0x15a, 0x1353, 0xa, 0x15a, 0x3, 0x15a, 
       0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15b, 0x3, 0x15b, 0x3, 0x15b, 0x3, 
       0x15b, 0x3, 0x15c, 0x3, 0x15c, 0x3, 0x15c, 0x3, 0x15c, 0x5, 0x15c, 
       0x1360, 0xa, 0x15c, 0x3, 0x15d, 0x3, 0x15d, 0x5, 0x15d, 0x1364, 0xa, 
       0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x5, 0x15d, 
       0x136a, 0xa, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x5, 0x15d, 
       0x136f, 0xa, 0x15d, 0x3, 0x15e, 0x3, 0x15e, 0x5, 0x15e, 0x1373, 0xa, 
       0x15e, 0x3, 0x15e, 0x3, 0x15e, 0x5, 0x15e, 0x1377, 0xa, 0x15e, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x7, 0x15f, 0x137c, 0xa, 0x15f, 0xc, 
       0x15f, 0xe, 0x15f, 0x137f, 0xb, 0x15f, 0x3, 0x160, 0x3, 0x160, 0x3, 
       0x161, 0x3, 0x161, 0x3, 0x161, 0x3, 0x161, 0x5, 0x161, 0x1387, 0xa, 
       0x161, 0x3, 0x161, 0x3, 0x161, 0x5, 0x161, 0x138b, 0xa, 0x161, 0x3, 
       0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 
       0x3, 0x162, 0x3, 0x162, 0x5, 0x162, 0x1395, 0xa, 0x162, 0x3, 0x163, 
       0x3, 0x163, 0x3, 0x163, 0x7, 0x163, 0x139a, 0xa, 0x163, 0xc, 0x163, 
       0xe, 0x163, 0x139d, 0xb, 0x163, 0x3, 0x164, 0x3, 0x164, 0x5, 0x164, 
       0x13a1, 0xa, 0x164, 0x3, 0x164, 0x5, 0x164, 0x13a4, 0xa, 0x164, 0x3, 
       0x165, 0x3, 0x165, 0x3, 0x165, 0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 
       0x5, 0x166, 0x13ac, 0xa, 0x166, 0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 
       0x5, 0x166, 0x13b1, 0xa, 0x166, 0x3, 0x166, 0x5, 0x166, 0x13b4, 0xa, 
       0x166, 0x3, 0x166, 0x5, 0x166, 0x13b7, 0xa, 0x166, 0x3, 0x167, 0x3, 
       0x167, 0x5, 0x167, 0x13bb, 0xa, 0x167, 0x3, 0x167, 0x3, 0x167, 0x5, 
       0x167, 0x13bf, 0xa, 0x167, 0x3, 0x167, 0x5, 0x167, 0x13c2, 0xa, 0x167, 
       0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x169, 0x5, 
       0x169, 0x13c9, 0xa, 0x169, 0x3, 0x169, 0x3, 0x169, 0x3, 0x169, 0x3, 
       0x169, 0x3, 0x169, 0x5, 0x169, 0x13d0, 0xa, 0x169, 0x3, 0x169, 0x5, 
       0x169, 0x13d3, 0xa, 0x169, 0x3, 0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x13d7, 
       0xa, 0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x5, 
       0x16a, 0x13dd, 0xa, 0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x13e0, 0xa, 0x16a, 
       0x3, 0x16a, 0x5, 0x16a, 0x13e3, 0xa, 0x16a, 0x3, 0x16b, 0x3, 0x16b, 
       0x3, 0x16b, 0x7, 0x16b, 0x13e8, 0xa, 0x16b, 0xc, 0x16b, 0xe, 0x16b, 
       0x13eb, 0xb, 0x16b, 0x3, 0x16c, 0x3, 0x16c, 0x5, 0x16c, 0x13ef, 0xa, 
       0x16c, 0x3, 0x16d, 0x3, 0x16d, 0x3, 0x16d, 0x3, 0x16d, 0x3, 0x16e, 
       0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 
       0x16f, 0x3, 0x16f, 0x5, 0x16f, 0x13fd, 0xa, 0x16f, 0x3, 0x170, 0x3, 
       0x170, 0x3, 0x170, 0x7, 0x170, 0x1402, 0xa, 0x170, 0xc, 0x170, 0xe, 
       0x170, 0x1405, 0xb, 0x170, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x7, 
       0x171, 0x140a, 0xa, 0x171, 0xc, 0x171, 0xe, 0x171, 0x140d, 0xb, 0x171, 
       0x3, 0x171, 0x3, 0x171, 0x5, 0x171, 0x1411, 0xa, 0x171, 0x3, 0x171, 
       0x3, 0x171, 0x3, 0x171, 0x3, 0x172, 0x5, 0x172, 0x1417, 0xa, 0x172, 
       0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x5, 0x172, 0x141c, 0xa, 0x172, 
       0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x174, 0x3, 0x174, 0x7, 
       0x174, 0x1423, 0xa, 0x174, 0xc, 0x174, 0xe, 0x174, 0x1426, 0xb, 0x174, 
       0x3, 0x175, 0x3, 0x175, 0x5, 0x175, 0x142a, 0xa, 0x175, 0x3, 0x176, 
       0x3, 0x176, 0x5, 0x176, 0x142e, 0xa, 0x176, 0x3, 0x176, 0x3, 0x176, 
       0x3, 0x177, 0x3, 0x177, 0x3, 0x177, 0x3, 0x177, 0x3, 0x178, 0x5, 
       0x178, 0x1437, 0xa, 0x178, 0x3, 0x178, 0x3, 0x178, 0x5, 0x178, 0x143b, 
       0xa, 0x178, 0x3, 0x178, 0x5, 0x178, 0x143e, 0xa, 0x178, 0x3, 0x178, 
       0x5, 0x178, 0x1441, 0xa, 0x178, 0x3, 0x179, 0x3, 0x179, 0x5, 0x179, 
       0x1445, 0xa, 0x179, 0x3, 0x179, 0x3, 0x179, 0x5, 0x179, 0x1449, 0xa, 
       0x179, 0x3, 0x179, 0x5, 0x179, 0x144c, 0xa, 0x179, 0x3, 0x179, 0x5, 
       0x179, 0x144f, 0xa, 0x179, 0x3, 0x179, 0x5, 0x179, 0x1452, 0xa, 0x179, 
       0x3, 0x179, 0x5, 0x179, 0x1455, 0xa, 0x179, 0x3, 0x179, 0x5, 0x179, 
       0x1458, 0xa, 0x179, 0x3, 0x179, 0x5, 0x179, 0x145b, 0xa, 0x179, 0x3, 
       0x17a, 0x3, 0x17a, 0x5, 0x17a, 0x145f, 0xa, 0x17a, 0x3, 0x17a, 0x3, 
       0x17a, 0x3, 0x17b, 0x3, 0x17b, 0x3, 0x17b, 0x7, 0x17b, 0x1466, 0xa, 
       0x17b, 0xc, 0x17b, 0xe, 0x17b, 0x1469, 0xb, 0x17b, 0x3, 0x17c, 0x3, 
       0x17c, 0x5, 0x17c, 0x146d, 0xa, 0x17c, 0x3, 0x17c, 0x3, 0x17c, 0x3, 
       0x17c, 0x3, 0x17d, 0x3, 0x17d, 0x5, 0x17d, 0x1474, 0xa, 0x17d, 0x3, 
       0x17e, 0x5, 0x17e, 0x1477, 0xa, 0x17e, 0x3, 0x17e, 0x5, 0x17e, 0x147a, 
       0xa, 0x17e, 0x3, 0x17e, 0x5, 0x17e, 0x147d, 0xa, 0x17e, 0x3, 0x17e, 
       0x3, 0x17e, 0x3, 0x17f, 0x3, 0x17f, 0x3, 0x17f, 0x5, 0x17f, 0x1484, 
       0xa, 0x17f, 0x3, 0x17f, 0x5, 0x17f, 0x1487, 0xa, 0x17f, 0x3, 0x180, 
       0x3, 0x180, 0x3, 0x180, 0x3, 0x180, 0x3, 0x181, 0x3, 0x181, 0x3, 
       0x181, 0x7, 0x181, 0x1490, 0xa, 0x181, 0xc, 0x181, 0xe, 0x181, 0x1493, 
       0xb, 0x181, 0x3, 0x182, 0x3, 0x182, 0x3, 0x182, 0x3, 0x182, 0x5, 
       0x182, 0x1499, 0xa, 0x182, 0x3, 0x182, 0x3, 0x182, 0x5, 0x182, 0x149d, 
       0xa, 0x182, 0x3, 0x182, 0x5, 0x182, 0x14a0, 0xa, 0x182, 0x5, 0x182, 
       0x14a2, 0xa, 0x182, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 
       0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 
       0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 
       0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 
       0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 
       0x5, 0x183, 0x14be, 0xa, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 
       0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 
       0x183, 0x5, 0x183, 0x14c9, 0xa, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 
       0x183, 0x5, 0x183, 0x14ce, 0xa, 0x183, 0x3, 0x184, 0x3, 0x184, 0x5, 
       0x184, 0x14d2, 0xa, 0x184, 0x3, 0x185, 0x3, 0x185, 0x3, 0x185, 0x3, 
       0x185, 0x3, 0x185, 0x5, 0x185, 0x14d9, 0xa, 0x185, 0x3, 0x186, 0x3, 
       0x186, 0x3, 0x187, 0x3, 0x187, 0x3, 0x188, 0x3, 0x188, 0x3, 0x189, 
       0x3, 0x189, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 
       0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x7, 0x18b, 0x14ea, 0xa, 0x18b, 0xc, 
       0x18b, 0xe, 0x18b, 0x14ed, 0xb, 0x18b, 0x3, 0x18c, 0x3, 0x18c, 0x3, 
       0x18c, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 
       0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 0x5, 0x18c, 0x14fb, 
       0xa, 0x18c, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18e, 0x6, 
       0x18e, 0x1501, 0xa, 0x18e, 0xd, 0x18e, 0xe, 0x18e, 0x1502, 0x3, 0x18e, 
       0x3, 0x18e, 0x3, 0x18e, 0x5, 0x18e, 0x1508, 0xa, 0x18e, 0x3, 0x18f, 
       0x3, 0x18f, 0x3, 0x18f, 0x5, 0x18f, 0x150d, 0xa, 0x18f, 0x3, 0x18f, 
       0x5, 0x18f, 0x1510, 0xa, 0x18f, 0x3, 0x190, 0x3, 0x190, 0x3, 0x190, 
       0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 
       0x191, 0x3, 0x191, 0x7, 0x191, 0x151c, 0xa, 0x191, 0xc, 0x191, 0xe, 
       0x191, 0x151f, 0xb, 0x191, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 
       0x193, 0x3, 0x193, 0x3, 0x193, 0x7, 0x193, 0x1527, 0xa, 0x193, 0xc, 
       0x193, 0xe, 0x193, 0x152a, 0xb, 0x193, 0x3, 0x194, 0x3, 0x194, 0x3, 
       0x194, 0x5, 0x194, 0x152f, 0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 0x5, 
       0x194, 0x1533, 0xa, 0x194, 0x5, 0x194, 0x1535, 0xa, 0x194, 0x3, 0x194, 
       0x3, 0x194, 0x5, 0x194, 0x1539, 0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 
       0x5, 0x194, 0x153d, 0xa, 0x194, 0x5, 0x194, 0x153f, 0xa, 0x194, 0x3, 
       0x194, 0x3, 0x194, 0x5, 0x194, 0x1543, 0xa, 0x194, 0x3, 0x194, 0x5, 
       0x194, 0x1546, 0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 
       0x194, 0x3, 0x194, 0x3, 0x194, 0x5, 0x194, 0x154e, 0xa, 0x194, 0x3, 
       0x194, 0x3, 0x194, 0x5, 0x194, 0x1552, 0xa, 0x194, 0x5, 0x194, 0x1554, 
       0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x5, 
       0x194, 0x155a, 0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 0x5, 0x194, 0x155e, 
       0xa, 0x194, 0x5, 0x194, 0x1560, 0xa, 0x194, 0x5, 0x194, 0x1562, 0xa, 
       0x194, 0x3, 0x194, 0x3, 0x194, 0x5, 0x194, 0x1566, 0xa, 0x194, 0x3, 
       0x194, 0x5, 0x194, 0x1569, 0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 
       0x194, 0x5, 0x194, 0x156e, 0xa, 0x194, 0x7, 0x194, 0x1570, 0xa, 0x194, 
       0xc, 0x194, 0xe, 0x194, 0x1573, 0xb, 0x194, 0x3, 0x195, 0x3, 0x195, 
       0x5, 0x195, 0x1577, 0xa, 0x195, 0x3, 0x195, 0x3, 0x195, 0x5, 0x195, 
       0x157b, 0xa, 0x195, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 
       0x5, 0x196, 0x1581, 0xa, 0x196, 0x3, 0x197, 0x3, 0x197, 0x5, 0x197, 
       0x1585, 0xa, 0x197, 0x3, 0x197, 0x3, 0x197, 0x3, 0x197, 0x3, 0x197, 
       0x3, 0x197, 0x3, 0x197, 0x3, 0x197, 0x5, 0x197, 0x158e, 0xa, 0x197, 
       0x3, 0x198, 0x3, 0x198, 0x5, 0x198, 0x1592, 0xa, 0x198, 0x3, 0x198, 
       0x5, 0x198, 0x1595, 0xa, 0x198, 0x3, 0x199, 0x3, 0x199, 0x3, 0x19a, 
       0x3, 0x19a, 0x3, 0x19a, 0x3, 0x19b, 0x3, 0x19b, 0x3, 0x19b, 0x3, 
       0x19b, 0x3, 0x19b, 0x3, 0x19b, 0x3, 0x19b, 0x5, 0x19b, 0x15a3, 0xa, 
       0x19b, 0x5, 0x19b, 0x15a5, 0xa, 0x19b, 0x3, 0x19c, 0x3, 0x19c, 0x3, 
       0x19c, 0x7, 0x19c, 0x15aa, 0xa, 0x19c, 0xc, 0x19c, 0xe, 0x19c, 0x15ad, 
       0xb, 0x19c, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19e, 0x3, 
       0x19e, 0x7, 0x19e, 0x15b4, 0xa, 0x19e, 0xc, 0x19e, 0xe, 0x19e, 0x15b7, 
       0xb, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x7, 0x19e, 0x15bc, 
       0xa, 0x19e, 0xc, 0x19e, 0xe, 0x19e, 0x15bf, 0xb, 0x19e, 0x3, 0x19e, 
       0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 
       0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 
       0x3, 0x19e, 0x5, 0x19e, 0x15ce, 0xa, 0x19e, 0x3, 0x19f, 0x3, 0x19f, 
       0x3, 0x19f, 0x3, 0x19f, 0x3, 0x19f, 0x3, 0x19f, 0x5, 0x19f, 0x15d6, 
       0xa, 0x19f, 0x3, 0x1a0, 0x3, 0x1a0, 0x3, 0x1a0, 0x3, 0x1a0, 0x3, 
       0x1a0, 0x3, 0x1a0, 0x3, 0x1a0, 0x5, 0x1a0, 0x15df, 0xa, 0x1a0, 0x3, 
       0x1a0, 0x5, 0x1a0, 0x15e2, 0xa, 0x1a0, 0x5, 0x1a0, 0x15e4, 0xa, 0x1a0, 
       0x3, 0x1a1, 0x3, 0x1a1, 0x3, 0x1a1, 0x3, 0x1a1, 0x5, 0x1a1, 0x15ea, 
       0xa, 0x1a1, 0x3, 0x1a2, 0x3, 0x1a2, 0x5, 0x1a2, 0x15ee, 0xa, 0x1a2, 
       0x3, 0x1a2, 0x5, 0x1a2, 0x15f1, 0xa, 0x1a2, 0x3, 0x1a3, 0x3, 0x1a3, 
       0x3, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x5, 
       0x1a3, 0x15fa, 0xa, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x3, 
       0x1a3, 0x5, 0x1a3, 0x1600, 0xa, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x5, 
       0x1a3, 0x1604, 0xa, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x5, 0x1a3, 0x1608, 
       0xa, 0x1a3, 0x3, 0x1a3, 0x5, 0x1a3, 0x160b, 0xa, 0x1a3, 0x3, 0x1a4, 
       0x3, 0x1a4, 0x5, 0x1a4, 0x160f, 0xa, 0x1a4, 0x3, 0x1a5, 0x3, 0x1a5, 
       0x5, 0x1a5, 0x1613, 0xa, 0x1a5, 0x3, 0x1a6, 0x3, 0x1a6, 0x5, 0x1a6, 
       0x1617, 0xa, 0x1a6, 0x3, 0x1a6, 0x3, 0x1a6, 0x3, 0x1a7, 0x3, 0x1a7, 
       0x5, 0x1a7, 0x161d, 0xa, 0x1a7, 0x3, 0x1a8, 0x3, 0x1a8, 0x5, 0x1a8, 
       0x1621, 0xa, 0x1a8, 0x3, 0x1a9, 0x3, 0x1a9, 0x5, 0x1a9, 0x1625, 0xa, 
       0x1a9, 0x3, 0x1aa, 0x3, 0x1aa, 0x3, 0x1aa, 0x5, 0x1aa, 0x162a, 0xa, 
       0x1aa, 0x3, 0x1ab, 0x3, 0x1ab, 0x5, 0x1ab, 0x162e, 0xa, 0x1ab, 0x3, 
       0x1ac, 0x3, 0x1ac, 0x5, 0x1ac, 0x1632, 0xa, 0x1ac, 0x3, 0x1ac, 0x3, 
       0x1ac, 0x3, 0x1ac, 0x3, 0x1ac, 0x5, 0x1ac, 0x1638, 0xa, 0x1ac, 0x5, 
       0x1ac, 0x163a, 0xa, 0x1ac, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 
       0x1ad, 0x3, 0x1ae, 0x3, 0x1ae, 0x5, 0x1ae, 0x1642, 0xa, 0x1ae, 0x3, 
       0x1ae, 0x5, 0x1ae, 0x1645, 0xa, 0x1ae, 0x3, 0x1af, 0x3, 0x1af, 0x3, 
       0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b1, 0x3, 0x1b1, 
       0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 
       0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 
       0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 
       0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 
       0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x5, 0x1b1, 0x1668, 0xa, 0x1b1, 
       0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 
       0x1b3, 0x5, 0x1b3, 0x1670, 0xa, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 
       0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 
       0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x5, 
       0x1b3, 0x167f, 0xa, 0x1b3, 0x5, 0x1b3, 0x1681, 0xa, 0x1b3, 0x3, 0x1b3, 
       0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x5, 0x1b3, 0x1688, 
       0xa, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 
       0x1b3, 0x3, 0x1b3, 0x7, 0x1b3, 0x1690, 0xa, 0x1b3, 0xc, 0x1b3, 0xe, 
       0x1b3, 0x1693, 0xb, 0x1b3, 0x3, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b5, 0x3, 
       0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 
       0x7, 0x1b5, 0x169e, 0xa, 0x1b5, 0xc, 0x1b5, 0xe, 0x1b5, 0x16a1, 0xb, 
       0x1b5, 0x3, 0x1b6, 0x3, 0x1b6, 0x5, 0x1b6, 0x16a5, 0xa, 0x1b6, 0x3, 
       0x1b6, 0x3, 0x1b6, 0x5, 0x1b6, 0x16a9, 0xa, 0x1b6, 0x3, 0x1b7, 0x3, 
       0x1b7, 0x5, 0x1b7, 0x16ad, 0xa, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b7, 0x3, 
       0x1b7, 0x3, 0x1b7, 0x5, 0x1b7, 0x16b3, 0xa, 0x1b7, 0x3, 0x1b7, 0x5, 
       0x1b7, 0x16b6, 0xa, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b7, 0x3, 
       0x1b7, 0x3, 0x1b7, 0x5, 0x1b7, 0x16bd, 0xa, 0x1b7, 0x3, 0x1b7, 0x3, 
       0x1b7, 0x3, 0x1b7, 0x5, 0x1b7, 0x16c2, 0xa, 0x1b7, 0x5, 0x1b7, 0x16c4, 
       0xa, 0x1b7, 0x5, 0x1b7, 0x16c6, 0xa, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b7, 
       0x3, 0x1b7, 0x3, 0x1b7, 0x5, 0x1b7, 0x16cc, 0xa, 0x1b7, 0x3, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b9, 0x3, 0x1b9, 0x3, 
       0x1b9, 0x3, 0x1b9, 0x7, 0x1b9, 0x16d6, 0xa, 0x1b9, 0xc, 0x1b9, 0xe, 
       0x1b9, 0x16d9, 0xb, 0x1b9, 0x3, 0x1b9, 0x3, 0x1b9, 0x3, 0x1ba, 0x3, 
       0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x5, 0x1ba, 
       0x16e3, 0xa, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 
       0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 
       0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x7, 0x1ba, 0x16f2, 0xa, 
       0x1ba, 0xc, 0x1ba, 0xe, 0x1ba, 0x16f5, 0xb, 0x1ba, 0x3, 0x1bb, 0x3, 
       0x1bb, 0x3, 0x1bc, 0x3, 0x1bc, 0x3, 0x1bc, 0x3, 0x1bc, 0x5, 0x1bc, 
       0x16fd, 0xa, 0x1bc, 0x3, 0x1bc, 0x3, 0x1bc, 0x3, 0x1bc, 0x7, 0x1bc, 
       0x1702, 0xa, 0x1bc, 0xc, 0x1bc, 0xe, 0x1bc, 0x1705, 0xb, 0x1bc, 0x3, 
       0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x5, 0x1bd, 0x170b, 0xa, 
       0x1bd, 0x3, 0x1bd, 0x5, 0x1bd, 0x170e, 0xa, 0x1bd, 0x3, 0x1bd, 0x3, 
       0x1bd, 0x5, 0x1bd, 0x1712, 0xa, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 
       0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x5, 0x1bd, 0x171a, 0xa, 
       0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x5, 0x1bd, 0x171f, 0xa, 
       0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 
       0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x5, 
       0x1bd, 0x172b, 0xa, 0x1bd, 0x3, 0x1be, 0x3, 0x1be, 0x3, 0x1be, 0x3, 
       0x1be, 0x5, 0x1be, 0x1731, 0xa, 0x1be, 0x3, 0x1bf, 0x3, 0x1bf, 0x5, 
       0x1bf, 0x1735, 0xa, 0x1bf, 0x3, 0x1c0, 0x3, 0x1c0, 0x3, 0x1c0, 0x3, 
       0x1c1, 0x3, 0x1c1, 0x5, 0x1c1, 0x173c, 0xa, 0x1c1, 0x3, 0x1c1, 0x3, 
       0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 
       0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 
       0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x5, 0x1c1, 0x174e, 0xa, 
       0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x5, 0x1c1, 0x1752, 0xa, 0x1c1, 0x3, 
       0x1c1, 0x3, 0x1c1, 0x5, 0x1c1, 0x1756, 0xa, 0x1c1, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x5, 0x1c2, 0x1763, 
       0xa, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x5, 0x1c2, 0x1775, 0xa, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x5, 0x1c2, 0x1780, 0xa, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x5, 0x1c2, 0x1786, 0xa, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x5, 0x1c2, 0x1815, 0xa, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x5, 
       0x1c2, 0x182d, 0xa, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x5, 0x1c2, 0x1839, 0xa, 0x1c2, 0x3, 0x1c3, 0x3, 0x1c3, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1840, 0xa, 0x1c3, 
       0x3, 0x1c4, 0x3, 0x1c4, 0x3, 0x1c4, 0x3, 0x1c4, 0x3, 0x1c4, 0x5, 
       0x1c4, 0x1847, 0xa, 0x1c4, 0x5, 0x1c4, 0x1849, 0xa, 0x1c4, 0x3, 0x1c5, 
       0x3, 0x1c5, 0x3, 0x1c5, 0x3, 0x1c5, 0x3, 0x1c5, 0x3, 0x1c6, 0x3, 
       0x1c6, 0x3, 0x1c6, 0x7, 0x1c6, 0x1853, 0xa, 0x1c6, 0xc, 0x1c6, 0xe, 
       0x1c6, 0x1856, 0xb, 0x1c6, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 
       0x1c7, 0x185b, 0xa, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x185e, 0xa, 0x1c7, 
       0x3, 0x1c8, 0x3, 0x1c8, 0x3, 0x1c9, 0x3, 0x1c9, 0x3, 0x1c9, 0x3, 
       0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x5, 0x1ca, 0x1869, 0xa, 
       0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 
       0x3, 0x1ca, 0x5, 0x1ca, 0x1871, 0xa, 0x1ca, 0x5, 0x1ca, 0x1873, 0xa, 
       0x1ca, 0x3, 0x1cb, 0x3, 0x1cb, 0x3, 0x1cb, 0x3, 0x1cc, 0x3, 0x1cc, 
       0x3, 0x1cc, 0x7, 0x1cc, 0x187b, 0xa, 0x1cc, 0xc, 0x1cc, 0xe, 0x1cc, 
       0x187e, 0xb, 0x1cc, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 
       0x3, 0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 0x1886, 0xa, 0x1ce, 0x3, 0x1ce, 
       0x5, 0x1ce, 0x1889, 0xa, 0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 0x188c, 0xa, 
       0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 0x188f, 0xa, 0x1ce, 0x3, 0x1ce, 0x3, 
       0x1ce, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1d0, 
       0x3, 0x1d0, 0x3, 0x1d0, 0x5, 0x1d0, 0x189a, 0xa, 0x1d0, 0x3, 0x1d1, 
       0x3, 0x1d1, 0x3, 0x1d2, 0x3, 0x1d2, 0x5, 0x1d2, 0x18a0, 0xa, 0x1d2, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 
       0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x18a9, 0xa, 0x1d3, 0x3, 0x1d4, 0x3, 
       0x1d4, 0x3, 0x1d4, 0x3, 0x1d4, 0x3, 0x1d4, 0x3, 0x1d5, 0x3, 0x1d5, 
       0x3, 0x1d5, 0x3, 0x1d5, 0x3, 0x1d5, 0x3, 0x1d5, 0x5, 0x1d5, 0x18b6, 
       0xa, 0x1d5, 0x3, 0x1d6, 0x3, 0x1d6, 0x3, 0x1d6, 0x3, 0x1d6, 0x3, 
       0x1d6, 0x3, 0x1d6, 0x3, 0x1d6, 0x3, 0x1d6, 0x3, 0x1d6, 0x3, 0x1d6, 
       0x5, 0x1d6, 0x18c2, 0xa, 0x1d6, 0x3, 0x1d7, 0x3, 0x1d7, 0x5, 0x1d7, 
       0x18c6, 0xa, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d8, 0x6, 0x1d8, 
       0x18cb, 0xa, 0x1d8, 0xd, 0x1d8, 0xe, 0x1d8, 0x18cc, 0x3, 0x1d9, 0x3, 
       0x1d9, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 
       0x3, 0x1da, 0x5, 0x1da, 0x18d7, 0xa, 0x1da, 0x3, 0x1db, 0x3, 0x1db, 
       0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x5, 0x1db, 0x18df, 
       0xa, 0x1db, 0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dc, 0x3, 
       0x1dc, 0x3, 0x1dc, 0x3, 0x1dc, 0x5, 0x1dc, 0x18e8, 0xa, 0x1dc, 0x3, 
       0x1dc, 0x3, 0x1dc, 0x5, 0x1dc, 0x18ec, 0xa, 0x1dc, 0x3, 0x1dc, 0x5, 
       0x1dc, 0x18ef, 0xa, 0x1dc, 0x3, 0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 0x3, 
       0x1dd, 0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 0x7, 0x1de, 0x18f8, 0xa, 
       0x1de, 0xc, 0x1de, 0xe, 0x1de, 0x18fb, 0xb, 0x1de, 0x3, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x7, 0x1df, 0x1900, 0xa, 0x1df, 0xc, 0x1df, 0xe, 
       0x1df, 0x1903, 0xb, 0x1df, 0x3, 0x1e0, 0x3, 0x1e0, 0x5, 0x1e0, 0x1907, 
       0xa, 0x1e0, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 
       0x1e0, 0x5, 0x1e0, 0x190e, 0xa, 0x1e0, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 
       0x1e1, 0x7, 0x1e1, 0x1913, 0xa, 0x1e1, 0xc, 0x1e1, 0xe, 0x1e1, 0x1916, 
       0xb, 0x1e1, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 
       0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 
       0x3, 0x1e3, 0x3, 0x1e3, 0x5, 0x1e3, 0x1924, 0xa, 0x1e3, 0x3, 0x1e4, 
       0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x5, 0x1e4, 0x192a, 0xa, 0x1e4, 
       0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e6, 0x3, 0x1e6, 0x3, 
       0x1e6, 0x3, 0x1e6, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 
       0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 
       0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 
       0x5, 0x1e7, 0x1942, 0xa, 0x1e7, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 
       0x3, 0x1e9, 0x3, 0x1e9, 0x3, 0x1e9, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 
       0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x5, 0x1ea, 
       0x1951, 0xa, 0x1ea, 0x3, 0x1eb, 0x3, 0x1eb, 0x5, 0x1eb, 0x1955, 0xa, 
       0x1eb, 0x3, 0x1ec, 0x3, 0x1ec, 0x5, 0x1ec, 0x1959, 0xa, 0x1ec, 0x3, 
       0x1ec, 0x6, 0x1ec, 0x195c, 0xa, 0x1ec, 0xd, 0x1ec, 0xe, 0x1ec, 0x195d, 
       0x3, 0x1ec, 0x5, 0x1ec, 0x1961, 0xa, 0x1ec, 0x3, 0x1ec, 0x3, 0x1ec, 
       0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 
       0x1ee, 0x3, 0x1ee, 0x3, 0x1ee, 0x3, 0x1ee, 0x3, 0x1ee, 0x3, 0x1ee, 
       0x5, 0x1ee, 0x1970, 0xa, 0x1ee, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 
       0x3, 0x1f0, 0x3, 0x1f0, 0x3, 0x1f1, 0x3, 0x1f1, 0x3, 0x1f1, 0x3, 
       0x1f1, 0x6, 0x1f1, 0x197b, 0xa, 0x1f1, 0xd, 0x1f1, 0xe, 0x1f1, 0x197c, 
       0x3, 0x1f1, 0x5, 0x1f1, 0x1980, 0xa, 0x1f1, 0x3, 0x1f1, 0x3, 0x1f1, 
       0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 
       0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f4, 0x3, 0x1f4, 0x5, 0x1f4, 
       0x198e, 0xa, 0x1f4, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 
       0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 
       0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x5, 0x1f5, 
       0x199e, 0xa, 0x1f5, 0x3, 0x1f6, 0x6, 0x1f6, 0x19a1, 0xa, 0x1f6, 0xd, 
       0x1f6, 0xe, 0x1f6, 0x19a2, 0x3, 0x1f7, 0x3, 0x1f7, 0x5, 0x1f7, 0x19a7, 
       0xa, 0x1f7, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x7, 0x1f8, 0x19ac, 
       0xa, 0x1f8, 0xc, 0x1f8, 0xe, 0x1f8, 0x19af, 0xb, 0x1f8, 0x3, 0x1f9, 
       0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1fa, 0x3, 0x1fa, 0x3, 
       0x1fa, 0x7, 0x1fa, 0x19b8, 0xa, 0x1fa, 0xc, 0x1fa, 0xe, 0x1fa, 0x19bb, 
       0xb, 0x1fa, 0x3, 0x1fb, 0x3, 0x1fb, 0x5, 0x1fb, 0x19bf, 0xa, 0x1fb, 
       0x3, 0x1fb, 0x5, 0x1fb, 0x19c2, 0xa, 0x1fb, 0x3, 0x1fb, 0x5, 0x1fb, 
       0x19c5, 0xa, 0x1fb, 0x3, 0x1fb, 0x5, 0x1fb, 0x19c8, 0xa, 0x1fb, 0x3, 
       0x1fc, 0x3, 0x1fc, 0x5, 0x1fc, 0x19cc, 0xa, 0x1fc, 0x3, 0x1fd, 0x3, 
       0x1fd, 0x3, 0x1fd, 0x7, 0x1fd, 0x19d1, 0xa, 0x1fd, 0xc, 0x1fd, 0xe, 
       0x1fd, 0x19d4, 0xb, 0x1fd, 0x3, 0x1fe, 0x3, 0x1fe, 0x5, 0x1fe, 0x19d8, 
       0xa, 0x1fe, 0x3, 0x1ff, 0x3, 0x1ff, 0x3, 0x1ff, 0x7, 0x1ff, 0x19dd, 
       0xa, 0x1ff, 0xc, 0x1ff, 0xe, 0x1ff, 0x19e0, 0xb, 0x1ff, 0x3, 0x200, 
       0x3, 0x200, 0x3, 0x201, 0x3, 0x201, 0x3, 0x202, 0x3, 0x202, 0x3, 
       0x203, 0x3, 0x203, 0x3, 0x204, 0x3, 0x204, 0x3, 0x205, 0x3, 0x205, 
       0x3, 0x206, 0x3, 0x206, 0x3, 0x207, 0x3, 0x207, 0x3, 0x207, 0x5, 
       0x207, 0x19f3, 0xa, 0x207, 0x5, 0x207, 0x19f5, 0xa, 0x207, 0x3, 0x208, 
       0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 
       0x208, 0x5, 0x208, 0x19fe, 0xa, 0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 
       0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 0x5, 0x208, 
       0x1a07, 0xa, 0x208, 0x3, 0x208, 0x3, 0x208, 0x5, 0x208, 0x1a0b, 0xa, 
       0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 0x5, 0x208, 0x1a10, 0xa, 
       0x208, 0x3, 0x209, 0x3, 0x209, 0x3, 0x20a, 0x3, 0x20a, 0x3, 0x20b, 
       0x3, 0x20b, 0x3, 0x20c, 0x3, 0x20c, 0x3, 0x20d, 0x5, 0x20d, 0x1a1b, 
       0xa, 0x20d, 0x3, 0x20d, 0x3, 0x20d, 0x3, 0x20e, 0x5, 0x20e, 0x1a20, 
       0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1a25, 
       0xa, 0x20e, 0x3, 0x20f, 0x3, 0x20f, 0x3, 0x20f, 0x5, 0x20f, 0x1a2a, 
       0xa, 0x20f, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x3, 
       0x210, 0x3, 0x210, 0x5, 0x210, 0x1a32, 0xa, 0x210, 0x3, 0x211, 0x3, 
       0x211, 0x3, 0x212, 0x3, 0x212, 0x3, 0x213, 0x3, 0x213, 0x3, 0x213, 
       0x3, 0x213, 0x3, 0x213, 0x5, 0x213, 0x1a3d, 0xa, 0x213, 0x3, 0x214, 
       0x3, 0x214, 0x5, 0x214, 0x1a41, 0xa, 0x214, 0x3, 0x215, 0x3, 0x215, 
       0x3, 0x216, 0x3, 0x216, 0x3, 0x217, 0x3, 0x217, 0x3, 0x218, 0x3, 
       0x218, 0x3, 0x219, 0x3, 0x219, 0x3, 0x219, 0x4, 0x5e4, 0x5ed, 0xa, 
       0x52, 0xea, 0x320, 0x326, 0x364, 0x368, 0x372, 0x376, 0x21a, 0x2, 
       0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 
       0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 
       0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 
       0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 
       0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 
       0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 
       0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 
       0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 
       0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 
       0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 
       0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 
       0xf8, 0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 
       0x10c, 0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 
       0x120, 0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x132, 
       0x134, 0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 0x142, 0x144, 0x146, 
       0x148, 0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15a, 
       0x15c, 0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 0x16c, 0x16e, 
       0x170, 0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 0x17e, 0x180, 0x182, 
       0x184, 0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 0x192, 0x194, 0x196, 
       0x198, 0x19a, 0x19c, 0x19e, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 0x1a8, 0x1aa, 
       0x1ac, 0x1ae, 0x1b0, 0x1b2, 0x1b4, 0x1b6, 0x1b8, 0x1ba, 0x1bc, 0x1be, 
       0x1c0, 0x1c2, 0x1c4, 0x1c6, 0x1c8, 0x1ca, 0x1cc, 0x1ce, 0x1d0, 0x1d2, 
       0x1d4, 0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1de, 0x1e0, 0x1e2, 0x1e4, 0x1e6, 
       0x1e8, 0x1ea, 0x1ec, 0x1ee, 0x1f0, 0x1f2, 0x1f4, 0x1f6, 0x1f8, 0x1fa, 
       0x1fc, 0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c, 0x20e, 
       0x210, 0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 0x220, 0x222, 
       0x224, 0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 0x234, 0x236, 
       0x238, 0x23a, 0x23c, 0x23e, 0x240, 0x242, 0x244, 0x246, 0x248, 0x24a, 
       0x24c, 0x24e, 0x250, 0x252, 0x254, 0x256, 0x258, 0x25a, 0x25c, 0x25e, 
       0x260, 0x262, 0x264, 0x266, 0x268, 0x26a, 0x26c, 0x26e, 0x270, 0x272, 
       0x274, 0x276, 0x278, 0x27a, 0x27c, 0x27e, 0x280, 0x282, 0x284, 0x286, 
       0x288, 0x28a, 0x28c, 0x28e, 0x290, 0x292, 0x294, 0x296, 0x298, 0x29a, 
       0x29c, 0x29e, 0x2a0, 0x2a2, 0x2a4, 0x2a6, 0x2a8, 0x2aa, 0x2ac, 0x2ae, 
       0x2b0, 0x2b2, 0x2b4, 0x2b6, 0x2b8, 0x2ba, 0x2bc, 0x2be, 0x2c0, 0x2c2, 
       0x2c4, 0x2c6, 0x2c8, 0x2ca, 0x2cc, 0x2ce, 0x2d0, 0x2d2, 0x2d4, 0x2d6, 
       0x2d8, 0x2da, 0x2dc, 0x2de, 0x2e0, 0x2e2, 0x2e4, 0x2e6, 0x2e8, 0x2ea, 
       0x2ec, 0x2ee, 0x2f0, 0x2f2, 0x2f4, 0x2f6, 0x2f8, 0x2fa, 0x2fc, 0x2fe, 
       0x300, 0x302, 0x304, 0x306, 0x308, 0x30a, 0x30c, 0x30e, 0x310, 0x312, 
       0x314, 0x316, 0x318, 0x31a, 0x31c, 0x31e, 0x320, 0x322, 0x324, 0x326, 
       0x328, 0x32a, 0x32c, 0x32e, 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 
       0x33c, 0x33e, 0x340, 0x342, 0x344, 0x346, 0x348, 0x34a, 0x34c, 0x34e, 
       0x350, 0x352, 0x354, 0x356, 0x358, 0x35a, 0x35c, 0x35e, 0x360, 0x362, 
       0x364, 0x366, 0x368, 0x36a, 0x36c, 0x36e, 0x370, 0x372, 0x374, 0x376, 
       0x378, 0x37a, 0x37c, 0x37e, 0x380, 0x382, 0x384, 0x386, 0x388, 0x38a, 
       0x38c, 0x38e, 0x390, 0x392, 0x394, 0x396, 0x398, 0x39a, 0x39c, 0x39e, 
       0x3a0, 0x3a2, 0x3a4, 0x3a6, 0x3a8, 0x3aa, 0x3ac, 0x3ae, 0x3b0, 0x3b2, 
       0x3b4, 0x3b6, 0x3b8, 0x3ba, 0x3bc, 0x3be, 0x3c0, 0x3c2, 0x3c4, 0x3c6, 
       0x3c8, 0x3ca, 0x3cc, 0x3ce, 0x3d0, 0x3d2, 0x3d4, 0x3d6, 0x3d8, 0x3da, 
       0x3dc, 0x3de, 0x3e0, 0x3e2, 0x3e4, 0x3e6, 0x3e8, 0x3ea, 0x3ec, 0x3ee, 
       0x3f0, 0x3f2, 0x3f4, 0x3f6, 0x3f8, 0x3fa, 0x3fc, 0x3fe, 0x400, 0x402, 
       0x404, 0x406, 0x408, 0x40a, 0x40c, 0x40e, 0x410, 0x412, 0x414, 0x416, 
       0x418, 0x41a, 0x41c, 0x41e, 0x420, 0x422, 0x424, 0x426, 0x428, 0x42a, 
       0x42c, 0x42e, 0x430, 0x2, 0x58, 0x4, 0x2, 0x1c4, 0x1c4, 0x1c6, 0x1c6, 
       0x4, 0x2, 0x8, 0x8, 0x78, 0x78, 0x4, 0x2, 0xde, 0xde, 0x172, 0x172, 
       0x4, 0x2, 0x19b, 0x19b, 0x1f1, 0x1f1, 0x4, 0x2, 0x3a, 0x3a, 0x1a7, 
       0x1a7, 0x6, 0x2, 0x8f, 0x8f, 0x115, 0x115, 0x119, 0x119, 0x1a1, 0x1a1, 
       0x4, 0x2, 0x68, 0x68, 0xb4, 0xb4, 0x6, 0x2, 0xc, 0xc, 0x134, 0x134, 
       0x192, 0x192, 0x194, 0x194, 0x4, 0x2, 0xf, 0xf, 0x157, 0x157, 0x4, 
       0x2, 0xc, 0xc, 0x1b0, 0x1b0, 0x4, 0x2, 0x158, 0x158, 0x174, 0x174, 
       0x4, 0x2, 0x28, 0x28, 0x15b, 0x15b, 0x4, 0x2, 0x9f, 0x9f, 0x19b, 
       0x19b, 0x6, 0x2, 0x6b, 0x6b, 0x82, 0x82, 0x10e, 0x10e, 0x144, 0x144, 
       0x4, 0x2, 0xa2, 0xa2, 0xde, 0xde, 0x4, 0x2, 0x192, 0x192, 0x194, 
       0x194, 0x4, 0x2, 0x87, 0x87, 0xb7, 0xb7, 0x5, 0x2, 0xa0, 0xa0, 0x12b, 
       0x12b, 0x17a, 0x17a, 0x4, 0x2, 0x65, 0x65, 0x10e, 0x10e, 0x4, 0x2, 
       0x6a, 0x6a, 0x13a, 0x13a, 0x4, 0x2, 0x88, 0x88, 0xb8, 0xb8, 0x5, 
       0x2, 0xaa, 0xaa, 0xdb, 0xdb, 0x146, 0x146, 0x4, 0x2, 0x12d, 0x12d, 
       0x18a, 0x18a, 0x4, 0x2, 0x148, 0x148, 0x1c8, 0x1c8, 0x5, 0x2, 0x82, 
       0x82, 0x10e, 0x10e, 0x144, 0x144, 0x4, 0x2, 0x130, 0x130, 0x165, 
       0x165, 0x4, 0x2, 0xe8, 0xe8, 0xef, 0xef, 0x4, 0x2, 0x15a, 0x15a, 
       0x181, 0x181, 0x4, 0x2, 0xa, 0xa, 0x1d, 0x1d, 0x5, 0x2, 0x6a, 0x6a, 
       0xc5, 0xc5, 0x1ae, 0x1ae, 0x4, 0x2, 0x164, 0x164, 0x182, 0x182, 0x6, 
       0x2, 0x3e, 0x3e, 0x6f, 0x6f, 0x12a, 0x12a, 0x193, 0x193, 0x4, 0x2, 
       0xa1, 0xa1, 0x11b, 0x11b, 0x4, 0x2, 0x166, 0x166, 0x19f, 0x19f, 0x4, 
       0x2, 0x32, 0x32, 0x90, 0x90, 0x4, 0x2, 0x9f, 0x9f, 0xc2, 0xc2, 0xe, 
       0x2, 0x3f, 0x3f, 0x4b, 0x4b, 0x6a, 0x6a, 0x89, 0x89, 0xc5, 0xc5, 
       0x14f, 0x14f, 0x16f, 0x16f, 0x192, 0x192, 0x194, 0x194, 0x19f, 0x19f, 
       0x1a2, 0x1a2, 0x1ae, 0x1af, 0x4, 0x2, 0x16, 0x16, 0x6e, 0x6e, 0x3, 
       0x2, 0x10f, 0x110, 0x4, 0x2, 0x65, 0x65, 0x1f1, 0x1f1, 0x5, 0x2, 
       0xc1, 0xc2, 0x123, 0x123, 0x1b9, 0x1b9, 0x4, 0x2, 0x69, 0x69, 0xcc, 
       0xcc, 0x5, 0x2, 0x5d, 0x5d, 0xba, 0xba, 0x18f, 0x190, 0x6, 0x2, 0xba, 
       0xba, 0x170, 0x170, 0x190, 0x190, 0x1bd, 0x1bd, 0x4, 0x2, 0x160, 
       0x160, 0x1b0, 0x1b0, 0x4, 0x2, 0x76, 0x76, 0x8c, 0x8c, 0x4, 0x2, 
       0x170, 0x170, 0x190, 0x190, 0x4, 0x2, 0x46, 0x46, 0x76, 0x76, 0x7, 
       0x2, 0x5d, 0x5d, 0x93, 0x93, 0x141, 0x141, 0x169, 0x169, 0x191, 0x191, 
       0x4, 0x2, 0x3e, 0x3e, 0x6f, 0x6f, 0x6, 0x2, 0x6a, 0x6a, 0xc5, 0xc5, 
       0x16f, 0x16f, 0x1ae, 0x1ae, 0x4, 0x2, 0xd, 0xd, 0xc6, 0xc6, 0x6, 
       0x2, 0x3, 0x3, 0x39, 0x39, 0x7f, 0x7f, 0x161, 0x161, 0x4, 0x2, 0x39, 
       0x39, 0x161, 0x161, 0x4, 0x2, 0x19d, 0x19d, 0x1c7, 0x1c7, 0x4, 0x2, 
       0x11a, 0x11a, 0x1c9, 0x1c9, 0x4, 0x2, 0x29, 0x29, 0xde, 0xde, 0x4, 
       0x2, 0x78, 0x78, 0x174, 0x174, 0x4, 0x2, 0x8, 0x8, 0xe, 0xe, 0x3, 
       0x2, 0x10, 0x11, 0x4, 0x2, 0x5, 0x5, 0x164, 0x164, 0x4, 0x2, 0x164, 
       0x164, 0x1ae, 0x1ae, 0x5, 0x2, 0x84, 0x84, 0xc8, 0xc8, 0x1a9, 0x1a9, 
       0x3, 0x2, 0x164, 0x165, 0x4, 0x2, 0x96, 0x96, 0xfd, 0xfd, 0x4, 0x2, 
       0x177, 0x177, 0x1ae, 0x1ae, 0x5, 0x2, 0xa0, 0xa0, 0xd7, 0xd7, 0x15f, 
       0x15f, 0x5, 0x2, 0x2d, 0x2d, 0x2f, 0x2f, 0xfb, 0xfb, 0x4, 0x2, 0x2d, 
       0x2d, 0x2f, 0x2f, 0x3, 0x2, 0x199, 0x19a, 0x4, 0x2, 0xce, 0xce, 0x10b, 
       0x10b, 0x3, 0x2, 0x1ea, 0x1eb, 0x5, 0x2, 0x1d7, 0x1d7, 0x1dc, 0x1dc, 
       0x1e0, 0x1e0, 0x3, 0x2, 0x1dd, 0x1de, 0x4, 0x2, 0x58, 0x59, 0xdf, 
       0xe0, 0x4, 0x2, 0x44, 0x44, 0x75, 0x75, 0x4, 0x2, 0x13a, 0x13a, 0x188, 
       0x188, 0x4, 0x2, 0x146, 0x146, 0x165, 0x165, 0x4, 0x2, 0x1f7, 0x1f7, 
       0x1f9, 0x1fa, 0x3, 0x2, 0x1f7, 0x1f8, 0x5e, 0x2, 0x3, 0xb, 0xd, 0xf, 
       0x17, 0x18, 0x1a, 0x1a, 0x1c, 0x1e, 0x25, 0x29, 0x2c, 0x2c, 0x2e, 
       0x2e, 0x31, 0x34, 0x38, 0x39, 0x3b, 0x3e, 0x40, 0x40, 0x42, 0x4a, 
       0x4c, 0x4f, 0x51, 0x51, 0x55, 0x55, 0x5b, 0x60, 0x63, 0x63, 0x66, 
       0x66, 0x68, 0x6d, 0x6f, 0x71, 0x75, 0x7a, 0x7c, 0x7e, 0x80, 0x83, 
       0x85, 0x85, 0x87, 0x89, 0x8b, 0x8d, 0x90, 0x90, 0x92, 0x94, 0x96, 
       0x96, 0x9a, 0x9a, 0x9c, 0x9d, 0xa1, 0xa2, 0xa4, 0xa4, 0xa9, 0xaa, 
       0xac, 0xb2, 0xb4, 0xbd, 0xbf, 0xbf, 0xc3, 0xc6, 0xcc, 0xcc, 0xcf, 
       0xcf, 0xd1, 0xd4, 0xd8, 0xd8, 0xdb, 0xde, 0xe1, 0xe3, 0xe5, 0xe8, 
       0xea, 0xf5, 0xf7, 0xf8, 0xfd, 0x104, 0x106, 0x107, 0x109, 0x10a, 
       0x10c, 0x10c, 0x111, 0x111, 0x113, 0x114, 0x117, 0x117, 0x11b, 0x11d, 
       0x120, 0x121, 0x124, 0x125, 0x128, 0x12b, 0x12d, 0x130, 0x134, 0x134, 
       0x138, 0x13a, 0x13c, 0x145, 0x147, 0x149, 0x14b, 0x14e, 0x150, 0x15b, 
       0x15d, 0x15e, 0x160, 0x161, 0x163, 0x163, 0x166, 0x167, 0x169, 0x16e, 
       0x170, 0x172, 0x174, 0x174, 0x177, 0x178, 0x17a, 0x17a, 0x17d, 0x18a, 
       0x18c, 0x18c, 0x18e, 0x18f, 0x191, 0x195, 0x197, 0x198, 0x19d, 0x19d, 
       0x19f, 0x19f, 0x1a2, 0x1a4, 0x1a7, 0x1a8, 0x1ab, 0x1ae, 0x1b2, 0x1b6, 
       0x1ba, 0x1ba, 0x1bc, 0x1bf, 0x1c2, 0x1c2, 0x1c5, 0x1c9, 0x1cf, 0x1cf, 
       0x1d4, 0x1d6, 0x6a, 0x2, 0x3, 0x7, 0x9, 0xb, 0xd, 0xd, 0x17, 0x18, 
       0x1b, 0x1e, 0x20, 0x23, 0x25, 0x29, 0x2c, 0x2c, 0x2e, 0x2e, 0x31, 
       0x35, 0x38, 0x39, 0x3b, 0x3d, 0x40, 0x40, 0x42, 0x44, 0x46, 0x4a, 
       0x4c, 0x4f, 0x51, 0x52, 0x5b, 0x5d, 0x60, 0x63, 0x66, 0x66, 0x68, 
       0x6c, 0x70, 0x70, 0x76, 0x78, 0x7a, 0x7a, 0x7c, 0x7e, 0x80, 0x83, 
       0x85, 0x85, 0x87, 0x8b, 0x8d, 0x8e, 0x92, 0x92, 0x94, 0x94, 0x96, 
       0x97, 0x9a, 0x9a, 0x9c, 0x9e, 0xa1, 0xa2, 0xa4, 0xa7, 0xa9, 0xaa, 
       0xac, 0xae, 0xb1, 0xb1, 0xb4, 0xbd, 0xc1, 0xc1, 0xc3, 0xc7, 0xc9, 
       0xc9, 0xcb, 0xcc, 0xcf, 0xcf, 0xd1, 0xd4, 0xd6, 0xd6, 0xd8, 0xd8, 
       0xdb, 0xde, 0xe1, 0xe4, 0xe6, 0xe8, 0xea, 0xed, 0xef, 0xf3, 0xf5, 
       0xf5, 0xf7, 0xf9, 0xfb, 0xfb, 0xfd, 0xff, 0x101, 0x107, 0x109, 0x10a, 
       0x10c, 0x10d, 0x111, 0x114, 0x117, 0x117, 0x11b, 0x11d, 0x121, 0x123, 
       0x125, 0x125, 0x127, 0x129, 0x12b, 0x12b, 0x12d, 0x12d, 0x12f, 0x130, 
       0x135, 0x135, 0x137, 0x13a, 0x13c, 0x13f, 0x141, 0x141, 0x143, 0x144, 
       0x147, 0x147, 0x14a, 0x14c, 0x150, 0x150, 0x152, 0x156, 0x158, 0x15b, 
       0x15d, 0x15e, 0x160, 0x162, 0x164, 0x164, 0x166, 0x167, 0x169, 0x16b, 
       0x16d, 0x16e, 0x170, 0x172, 0x174, 0x178, 0x17a, 0x17b, 0x17d, 0x17f, 
       0x181, 0x187, 0x189, 0x18c, 0x18e, 0x18f, 0x192, 0x194, 0x197, 0x19a, 
       0x19d, 0x1a0, 0x1a2, 0x1a4, 0x1a7, 0x1a8, 0x1ab, 0x1ae, 0x1b2, 0x1b3, 
       0x1b5, 0x1b8, 0x1bb, 0x1be, 0x1c7, 0x1c7, 0x1c9, 0x1c9, 0x1d6, 0x1d6, 
       0x29, 0x2, 0x20, 0x20, 0x22, 0x23, 0x2d, 0x2d, 0x2f, 0x2f, 0x35, 
       0x35, 0x52, 0x52, 0x61, 0x62, 0x8a, 0x8a, 0x8e, 0x8e, 0x97, 0x97, 
       0xa5, 0xa7, 0xc1, 0xc1, 0xc7, 0xc7, 0xc9, 0xc9, 0xcb, 0xcb, 0xd6, 
       0xd6, 0xe9, 0xe9, 0xf9, 0xf9, 0xfb, 0xfb, 0x105, 0x105, 0x10d, 0x10d, 
       0x112, 0x112, 0x123, 0x123, 0x127, 0x127, 0x131, 0x132, 0x135, 0x135, 
       0x137, 0x137, 0x14a, 0x14a, 0x162, 0x162, 0x164, 0x164, 0x175, 0x176, 
       0x17b, 0x17b, 0x18b, 0x18b, 0x199, 0x19a, 0x19e, 0x19e, 0x1a0, 0x1a0, 
       0x1b7, 0x1b8, 0x1ca, 0x1ce, 0x1d0, 0x1d3, 0x16, 0x2, 0x1b, 0x1b, 
       0x21, 0x21, 0x50, 0x50, 0x57, 0x57, 0x9e, 0x9e, 0xa0, 0xa0, 0xb3, 
       0xb3, 0xc0, 0xc0, 0xcd, 0xce, 0xd0, 0xd0, 0xd7, 0xd7, 0xd9, 0xd9, 
       0xe4, 0xe4, 0xfa, 0xfa, 0x10b, 0x10b, 0x122, 0x122, 0x126, 0x126, 
       0x15f, 0x15f, 0x179, 0x179, 0x1bb, 0x1bb, 0x44, 0x2, 0xc, 0xc, 0x10, 
       0x16, 0x19, 0x19, 0x1f, 0x1f, 0x24, 0x24, 0x2a, 0x2b, 0x30, 0x30, 
       0x36, 0x37, 0x41, 0x41, 0x4b, 0x4b, 0x53, 0x54, 0x56, 0x56, 0x58, 
       0x5a, 0x64, 0x65, 0x67, 0x67, 0x6e, 0x6e, 0x72, 0x74, 0x7b, 0x7b, 
       0x7f, 0x7f, 0x84, 0x84, 0x86, 0x86, 0x8f, 0x8f, 0x91, 0x91, 0x95, 
       0x95, 0x98, 0x99, 0x9b, 0x9b, 0x9f, 0x9f, 0xa3, 0xa3, 0xa8, 0xa8, 
       0xab, 0xab, 0xbe, 0xbe, 0xc2, 0xc2, 0xc8, 0xc8, 0xca, 0xca, 0xd5, 
       0xd5, 0xda, 0xda, 0xdf, 0xe0, 0xfc, 0xfc, 0x108, 0x108, 0x10e, 0x10e, 
       0x115, 0x116, 0x118, 0x11a, 0x11e, 0x11f, 0x12c, 0x12c, 0x133, 0x133, 
       0x136, 0x136, 0x13b, 0x13b, 0x146, 0x146, 0x14f, 0x14f, 0x15c, 0x15c, 
       0x165, 0x165, 0x168, 0x168, 0x16f, 0x16f, 0x173, 0x173, 0x17c, 0x17c, 
       0x18d, 0x18d, 0x190, 0x190, 0x196, 0x196, 0x19b, 0x19c, 0x1a1, 0x1a1, 
       0x1a6, 0x1a6, 0x1a9, 0x1aa, 0x1b0, 0x1b1, 0x1b9, 0x1b9, 0x1c0, 0x1c1, 
       0x1c3, 0x1c4, 0x4, 0x2, 0xfc, 0xfc, 0x118, 0x118, 0x2, 0x1d3a, 0x2, 
       0x432, 0x3, 0x2, 0x2, 0x2, 0x4, 0x438, 0x3, 0x2, 0x2, 0x2, 0x6, 0x4a8, 
       0x3, 0x2, 0x2, 0x2, 0x8, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0xa, 0x4ce, 0x3, 
       0x2, 0x2, 0x2, 0xc, 0x4d0, 0x3, 0x2, 0x2, 0x2, 0xe, 0x4e0, 0x3, 0x2, 
       0x2, 0x2, 0x10, 0x4e3, 0x3, 0x2, 0x2, 0x2, 0x12, 0x4e8, 0x3, 0x2, 
       0x2, 0x2, 0x14, 0x4ee, 0x3, 0x2, 0x2, 0x2, 0x16, 0x4f3, 0x3, 0x2, 
       0x2, 0x2, 0x18, 0x507, 0x3, 0x2, 0x2, 0x2, 0x1a, 0x509, 0x3, 0x2, 
       0x2, 0x2, 0x1c, 0x515, 0x3, 0x2, 0x2, 0x2, 0x1e, 0x54c, 0x3, 0x2, 
       0x2, 0x2, 0x20, 0x552, 0x3, 0x2, 0x2, 0x2, 0x22, 0x554, 0x3, 0x2, 
       0x2, 0x2, 0x24, 0x55b, 0x3, 0x2, 0x2, 0x2, 0x26, 0x55d, 0x3, 0x2, 
       0x2, 0x2, 0x28, 0x561, 0x3, 0x2, 0x2, 0x2, 0x2a, 0x564, 0x3, 0x2, 
       0x2, 0x2, 0x2c, 0x568, 0x3, 0x2, 0x2, 0x2, 0x2e, 0x570, 0x3, 0x2, 
       0x2, 0x2, 0x30, 0x574, 0x3, 0x2, 0x2, 0x2, 0x32, 0x580, 0x3, 0x2, 
       0x2, 0x2, 0x34, 0x58c, 0x3, 0x2, 0x2, 0x2, 0x36, 0x596, 0x3, 0x2, 
       0x2, 0x2, 0x38, 0x598, 0x3, 0x2, 0x2, 0x2, 0x3a, 0x5a4, 0x3, 0x2, 
       0x2, 0x2, 0x3c, 0x5b1, 0x3, 0x2, 0x2, 0x2, 0x3e, 0x5bb, 0x3, 0x2, 
       0x2, 0x2, 0x40, 0x5bd, 0x3, 0x2, 0x2, 0x2, 0x42, 0x5c9, 0x3, 0x2, 
       0x2, 0x2, 0x44, 0x5d0, 0x3, 0x2, 0x2, 0x2, 0x46, 0x5d2, 0x3, 0x2, 
       0x2, 0x2, 0x48, 0x5f0, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x5f2, 0x3, 0x2, 
       0x2, 0x2, 0x4c, 0x5fa, 0x3, 0x2, 0x2, 0x2, 0x4e, 0x5fc, 0x3, 0x2, 
       0x2, 0x2, 0x50, 0x629, 0x3, 0x2, 0x2, 0x2, 0x52, 0x62b, 0x3, 0x2, 
       0x2, 0x2, 0x54, 0x636, 0x3, 0x2, 0x2, 0x2, 0x56, 0x641, 0x3, 0x2, 
       0x2, 0x2, 0x58, 0x648, 0x3, 0x2, 0x2, 0x2, 0x5a, 0x64a, 0x3, 0x2, 
       0x2, 0x2, 0x5c, 0x659, 0x3, 0x2, 0x2, 0x2, 0x5e, 0x65b, 0x3, 0x2, 
       0x2, 0x2, 0x60, 0x661, 0x3, 0x2, 0x2, 0x2, 0x62, 0x665, 0x3, 0x2, 
       0x2, 0x2, 0x64, 0x675, 0x3, 0x2, 0x2, 0x2, 0x66, 0x67a, 0x3, 0x2, 
       0x2, 0x2, 0x68, 0x68a, 0x3, 0x2, 0x2, 0x2, 0x6a, 0x68c, 0x3, 0x2, 
       0x2, 0x2, 0x6c, 0x693, 0x3, 0x2, 0x2, 0x2, 0x6e, 0x695, 0x3, 0x2, 
       0x2, 0x2, 0x70, 0x697, 0x3, 0x2, 0x2, 0x2, 0x72, 0x699, 0x3, 0x2, 
       0x2, 0x2, 0x74, 0x6a9, 0x3, 0x2, 0x2, 0x2, 0x76, 0x6ab, 0x3, 0x2, 
       0x2, 0x2, 0x78, 0x72d, 0x3, 0x2, 0x2, 0x2, 0x7a, 0x72f, 0x3, 0x2, 
       0x2, 0x2, 0x7c, 0x736, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x747, 0x3, 0x2, 
       0x2, 0x2, 0x80, 0x749, 0x3, 0x2, 0x2, 0x2, 0x82, 0x758, 0x3, 0x2, 
       0x2, 0x2, 0x84, 0x761, 0x3, 0x2, 0x2, 0x2, 0x86, 0x7e1, 0x3, 0x2, 
       0x2, 0x2, 0x88, 0x7e3, 0x3, 0x2, 0x2, 0x2, 0x8a, 0x7f3, 0x3, 0x2, 
       0x2, 0x2, 0x8c, 0x7fa, 0x3, 0x2, 0x2, 0x2, 0x8e, 0x7fc, 0x3, 0x2, 
       0x2, 0x2, 0x90, 0x7fe, 0x3, 0x2, 0x2, 0x2, 0x92, 0x801, 0x3, 0x2, 
       0x2, 0x2, 0x94, 0x838, 0x3, 0x2, 0x2, 0x2, 0x96, 0x83a, 0x3, 0x2, 
       0x2, 0x2, 0x98, 0x83c, 0x3, 0x2, 0x2, 0x2, 0x9a, 0x843, 0x3, 0x2, 
       0x2, 0x2, 0x9c, 0x85a, 0x3, 0x2, 0x2, 0x2, 0x9e, 0x85c, 0x3, 0x2, 
       0x2, 0x2, 0xa0, 0x860, 0x3, 0x2, 0x2, 0x2, 0xa2, 0x865, 0x3, 0x2, 
       0x2, 0x2, 0xa4, 0x883, 0x3, 0x2, 0x2, 0x2, 0xa6, 0x887, 0x3, 0x2, 
       0x2, 0x2, 0xa8, 0x893, 0x3, 0x2, 0x2, 0x2, 0xaa, 0x89e, 0x3, 0x2, 
       0x2, 0x2, 0xac, 0x8a0, 0x3, 0x2, 0x2, 0x2, 0xae, 0x8b1, 0x3, 0x2, 
       0x2, 0x2, 0xb0, 0x8b3, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x8da, 0x3, 0x2, 
       0x2, 0x2, 0xb4, 0x8e2, 0x3, 0x2, 0x2, 0x2, 0xb6, 0x8e4, 0x3, 0x2, 
       0x2, 0x2, 0xb8, 0x8f2, 0x3, 0x2, 0x2, 0x2, 0xba, 0x8f6, 0x3, 0x2, 
       0x2, 0x2, 0xbc, 0x91c, 0x3, 0x2, 0x2, 0x2, 0xbe, 0x91e, 0x3, 0x2, 
       0x2, 0x2, 0xc0, 0x922, 0x3, 0x2, 0x2, 0x2, 0xc2, 0x926, 0x3, 0x2, 
       0x2, 0x2, 0xc4, 0x92e, 0x3, 0x2, 0x2, 0x2, 0xc6, 0x930, 0x3, 0x2, 
       0x2, 0x2, 0xc8, 0x93b, 0x3, 0x2, 0x2, 0x2, 0xca, 0x93d, 0x3, 0x2, 
       0x2, 0x2, 0xcc, 0x941, 0x3, 0x2, 0x2, 0x2, 0xce, 0x94b, 0x3, 0x2, 
       0x2, 0x2, 0xd0, 0x94d, 0x3, 0x2, 0x2, 0x2, 0xd2, 0x956, 0x3, 0x2, 
       0x2, 0x2, 0xd4, 0x95f, 0x3, 0x2, 0x2, 0x2, 0xd6, 0x961, 0x3, 0x2, 
       0x2, 0x2, 0xd8, 0x964, 0x3, 0x2, 0x2, 0x2, 0xda, 0x96e, 0x3, 0x2, 
       0x2, 0x2, 0xdc, 0x970, 0x3, 0x2, 0x2, 0x2, 0xde, 0x973, 0x3, 0x2, 
       0x2, 0x2, 0xe0, 0x97f, 0x3, 0x2, 0x2, 0x2, 0xe2, 0x981, 0x3, 0x2, 
       0x2, 0x2, 0xe4, 0x985, 0x3, 0x2, 0x2, 0x2, 0xe6, 0x989, 0x3, 0x2, 
       0x2, 0x2, 0xe8, 0x991, 0x3, 0x2, 0x2, 0x2, 0xea, 0x9a4, 0x3, 0x2, 
       0x2, 0x2, 0xec, 0x9b9, 0x3, 0x2, 0x2, 0x2, 0xee, 0x9bb, 0x3, 0x2, 
       0x2, 0x2, 0xf0, 0x9c3, 0x3, 0x2, 0x2, 0x2, 0xf2, 0x9c5, 0x3, 0x2, 
       0x2, 0x2, 0xf4, 0x9ce, 0x3, 0x2, 0x2, 0x2, 0xf6, 0x9d7, 0x3, 0x2, 
       0x2, 0x2, 0xf8, 0x9e8, 0x3, 0x2, 0x2, 0x2, 0xfa, 0x9ea, 0x3, 0x2, 
       0x2, 0x2, 0xfc, 0x9ee, 0x3, 0x2, 0x2, 0x2, 0xfe, 0x9f6, 0x3, 0x2, 
       0x2, 0x2, 0x100, 0xa05, 0x3, 0x2, 0x2, 0x2, 0x102, 0xa09, 0x3, 0x2, 
       0x2, 0x2, 0x104, 0xa1d, 0x3, 0x2, 0x2, 0x2, 0x106, 0xa31, 0x3, 0x2, 
       0x2, 0x2, 0x108, 0xa33, 0x3, 0x2, 0x2, 0x2, 0x10a, 0xa3d, 0x3, 0x2, 
       0x2, 0x2, 0x10c, 0xa40, 0x3, 0x2, 0x2, 0x2, 0x10e, 0xa44, 0x3, 0x2, 
       0x2, 0x2, 0x110, 0xa47, 0x3, 0x2, 0x2, 0x2, 0x112, 0xa4b, 0x3, 0x2, 
       0x2, 0x2, 0x114, 0xa4d, 0x3, 0x2, 0x2, 0x2, 0x116, 0xa5c, 0x3, 0x2, 
       0x2, 0x2, 0x118, 0xa66, 0x3, 0x2, 0x2, 0x2, 0x11a, 0xa74, 0x3, 0x2, 
       0x2, 0x2, 0x11c, 0xa76, 0x3, 0x2, 0x2, 0x2, 0x11e, 0xa79, 0x3, 0x2, 
       0x2, 0x2, 0x120, 0xa8a, 0x3, 0x2, 0x2, 0x2, 0x122, 0xa97, 0x3, 0x2, 
       0x2, 0x2, 0x124, 0xa9b, 0x3, 0x2, 0x2, 0x2, 0x126, 0xaa3, 0x3, 0x2, 
       0x2, 0x2, 0x128, 0xaad, 0x3, 0x2, 0x2, 0x2, 0x12a, 0xaaf, 0x3, 0x2, 
       0x2, 0x2, 0x12c, 0xad3, 0x3, 0x2, 0x2, 0x2, 0x12e, 0xae7, 0x3, 0x2, 
       0x2, 0x2, 0x130, 0xaf7, 0x3, 0x2, 0x2, 0x2, 0x132, 0xaf9, 0x3, 0x2, 
       0x2, 0x2, 0x134, 0xb05, 0x3, 0x2, 0x2, 0x2, 0x136, 0xb08, 0x3, 0x2, 
       0x2, 0x2, 0x138, 0xb0c, 0x3, 0x2, 0x2, 0x2, 0x13a, 0xb1c, 0x3, 0x2, 
       0x2, 0x2, 0x13c, 0xb34, 0x3, 0x2, 0x2, 0x2, 0x13e, 0xb36, 0x3, 0x2, 
       0x2, 0x2, 0x140, 0xb3e, 0x3, 0x2, 0x2, 0x2, 0x142, 0xb40, 0x3, 0x2, 
       0x2, 0x2, 0x144, 0xb48, 0x3, 0x2, 0x2, 0x2, 0x146, 0xb4b, 0x3, 0x2, 
       0x2, 0x2, 0x148, 0xb55, 0x3, 0x2, 0x2, 0x2, 0x14a, 0xb57, 0x3, 0x2, 
       0x2, 0x2, 0x14c, 0xb5b, 0x3, 0x2, 0x2, 0x2, 0x14e, 0xb6a, 0x3, 0x2, 
       0x2, 0x2, 0x150, 0xb6c, 0x3, 0x2, 0x2, 0x2, 0x152, 0xb6f, 0x3, 0x2, 
       0x2, 0x2, 0x154, 0xb73, 0x3, 0x2, 0x2, 0x2, 0x156, 0xb7b, 0x3, 0x2, 
       0x2, 0x2, 0x158, 0xb84, 0x3, 0x2, 0x2, 0x2, 0x15a, 0xb8b, 0x3, 0x2, 
       0x2, 0x2, 0x15c, 0xba8, 0x3, 0x2, 0x2, 0x2, 0x15e, 0xbac, 0x3, 0x2, 
       0x2, 0x2, 0x160, 0xbaf, 0x3, 0x2, 0x2, 0x2, 0x162, 0xbb3, 0x3, 0x2, 
       0x2, 0x2, 0x164, 0xbb5, 0x3, 0x2, 0x2, 0x2, 0x166, 0xbc1, 0x3, 0x2, 
       0x2, 0x2, 0x168, 0xbcd, 0x3, 0x2, 0x2, 0x2, 0x16a, 0xbcf, 0x3, 0x2, 
       0x2, 0x2, 0x16c, 0xbd6, 0x3, 0x2, 0x2, 0x2, 0x16e, 0xbd8, 0x3, 0x2, 
       0x2, 0x2, 0x170, 0xbda, 0x3, 0x2, 0x2, 0x2, 0x172, 0xbe7, 0x3, 0x2, 
       0x2, 0x2, 0x174, 0xbf1, 0x3, 0x2, 0x2, 0x2, 0x176, 0xbf9, 0x3, 0x2, 
       0x2, 0x2, 0x178, 0xbfd, 0x3, 0x2, 0x2, 0x2, 0x17a, 0xc00, 0x3, 0x2, 
       0x2, 0x2, 0x17c, 0xc09, 0x3, 0x2, 0x2, 0x2, 0x17e, 0xc18, 0x3, 0x2, 
       0x2, 0x2, 0x180, 0xc22, 0x3, 0x2, 0x2, 0x2, 0x182, 0xc24, 0x3, 0x2, 
       0x2, 0x2, 0x184, 0xc2c, 0x3, 0x2, 0x2, 0x2, 0x186, 0xc30, 0x3, 0x2, 
       0x2, 0x2, 0x188, 0xc33, 0x3, 0x2, 0x2, 0x2, 0x18a, 0xc79, 0x3, 0x2, 
       0x2, 0x2, 0x18c, 0xca8, 0x3, 0x2, 0x2, 0x2, 0x18e, 0xcaa, 0x3, 0x2, 
       0x2, 0x2, 0x190, 0xcac, 0x3, 0x2, 0x2, 0x2, 0x192, 0xcb4, 0x3, 0x2, 
       0x2, 0x2, 0x194, 0xcb6, 0x3, 0x2, 0x2, 0x2, 0x196, 0xcbc, 0x3, 0x2, 
       0x2, 0x2, 0x198, 0xcbe, 0x3, 0x2, 0x2, 0x2, 0x19a, 0xccc, 0x3, 0x2, 
       0x2, 0x2, 0x19c, 0xcce, 0x3, 0x2, 0x2, 0x2, 0x19e, 0xcd9, 0x3, 0x2, 
       0x2, 0x2, 0x1a0, 0xcdc, 0x3, 0x2, 0x2, 0x2, 0x1a2, 0xce0, 0x3, 0x2, 
       0x2, 0x2, 0x1a4, 0xcf5, 0x3, 0x2, 0x2, 0x2, 0x1a6, 0xcf7, 0x3, 0x2, 
       0x2, 0x2, 0x1a8, 0xd01, 0x3, 0x2, 0x2, 0x2, 0x1aa, 0xd42, 0x3, 0x2, 
       0x2, 0x2, 0x1ac, 0xd44, 0x3, 0x2, 0x2, 0x2, 0x1ae, 0xd48, 0x3, 0x2, 
       0x2, 0x2, 0x1b0, 0xd55, 0x3, 0x2, 0x2, 0x2, 0x1b2, 0xd5e, 0x3, 0x2, 
       0x2, 0x2, 0x1b4, 0xd64, 0x3, 0x2, 0x2, 0x2, 0x1b6, 0xd66, 0x3, 0x2, 
       0x2, 0x2, 0x1b8, 0xd6a, 0x3, 0x2, 0x2, 0x2, 0x1ba, 0xd72, 0x3, 0x2, 
       0x2, 0x2, 0x1bc, 0xd76, 0x3, 0x2, 0x2, 0x2, 0x1be, 0xd7e, 0x3, 0x2, 
       0x2, 0x2, 0x1c0, 0xd90, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0xdae, 0x3, 0x2, 
       0x2, 0x2, 0x1c4, 0xdb0, 0x3, 0x2, 0x2, 0x2, 0x1c6, 0xdb3, 0x3, 0x2, 
       0x2, 0x2, 0x1c8, 0xdcc, 0x3, 0x2, 0x2, 0x2, 0x1ca, 0xdce, 0x3, 0x2, 
       0x2, 0x2, 0x1cc, 0xdd6, 0x3, 0x2, 0x2, 0x2, 0x1ce, 0xdda, 0x3, 0x2, 
       0x2, 0x2, 0x1d0, 0xde7, 0x3, 0x2, 0x2, 0x2, 0x1d2, 0xdf4, 0x3, 0x2, 
       0x2, 0x2, 0x1d4, 0xdfb, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0xe02, 0x3, 0x2, 
       0x2, 0x2, 0x1d8, 0xe20, 0x3, 0x2, 0x2, 0x2, 0x1da, 0xe22, 0x3, 0x2, 
       0x2, 0x2, 0x1dc, 0xe2a, 0x3, 0x2, 0x2, 0x2, 0x1de, 0xe30, 0x3, 0x2, 
       0x2, 0x2, 0x1e0, 0xe34, 0x3, 0x2, 0x2, 0x2, 0x1e2, 0xe3c, 0x3, 0x2, 
       0x2, 0x2, 0x1e4, 0xe40, 0x3, 0x2, 0x2, 0x2, 0x1e6, 0xe78, 0x3, 0x2, 
       0x2, 0x2, 0x1e8, 0xe8a, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0xe8e, 0x3, 0x2, 
       0x2, 0x2, 0x1ec, 0xe90, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0xead, 0x3, 0x2, 
       0x2, 0x2, 0x1f0, 0xeaf, 0x3, 0x2, 0x2, 0x2, 0x1f2, 0xeb8, 0x3, 0x2, 
       0x2, 0x2, 0x1f4, 0xecb, 0x3, 0x2, 0x2, 0x2, 0x1f6, 0xecd, 0x3, 0x2, 
       0x2, 0x2, 0x1f8, 0xed5, 0x3, 0x2, 0x2, 0x2, 0x1fa, 0xeea, 0x3, 0x2, 
       0x2, 0x2, 0x1fc, 0xeec, 0x3, 0x2, 0x2, 0x2, 0x1fe, 0xef6, 0x3, 0x2, 
       0x2, 0x2, 0x200, 0xef8, 0x3, 0x2, 0x2, 0x2, 0x202, 0xefc, 0x3, 0x2, 
       0x2, 0x2, 0x204, 0xf04, 0x3, 0x2, 0x2, 0x2, 0x206, 0xf07, 0x3, 0x2, 
       0x2, 0x2, 0x208, 0xf11, 0x3, 0x2, 0x2, 0x2, 0x20a, 0xf20, 0x3, 0x2, 
       0x2, 0x2, 0x20c, 0xf24, 0x3, 0x2, 0x2, 0x2, 0x20e, 0xf28, 0x3, 0x2, 
       0x2, 0x2, 0x210, 0xf40, 0x3, 0x2, 0x2, 0x2, 0x212, 0xf68, 0x3, 0x2, 
       0x2, 0x2, 0x214, 0xf6b, 0x3, 0x2, 0x2, 0x2, 0x216, 0xf6f, 0x3, 0x2, 
       0x2, 0x2, 0x218, 0xf71, 0x3, 0x2, 0x2, 0x2, 0x21a, 0xf73, 0x3, 0x2, 
       0x2, 0x2, 0x21c, 0xf85, 0x3, 0x2, 0x2, 0x2, 0x21e, 0xf88, 0x3, 0x2, 
       0x2, 0x2, 0x220, 0xf8e, 0x3, 0x2, 0x2, 0x2, 0x222, 0xf96, 0x3, 0x2, 
       0x2, 0x2, 0x224, 0xf9c, 0x3, 0x2, 0x2, 0x2, 0x226, 0xfa5, 0x3, 0x2, 
       0x2, 0x2, 0x228, 0xfac, 0x3, 0x2, 0x2, 0x2, 0x22a, 0xfb1, 0x3, 0x2, 
       0x2, 0x2, 0x22c, 0xfb3, 0x3, 0x2, 0x2, 0x2, 0x22e, 0xfb5, 0x3, 0x2, 
       0x2, 0x2, 0x230, 0xfc1, 0x3, 0x2, 0x2, 0x2, 0x232, 0xfc3, 0x3, 0x2, 
       0x2, 0x2, 0x234, 0xfd0, 0x3, 0x2, 0x2, 0x2, 0x236, 0xfd3, 0x3, 0x2, 
       0x2, 0x2, 0x238, 0xff8, 0x3, 0x2, 0x2, 0x2, 0x23a, 0xfff, 0x3, 0x2, 
       0x2, 0x2, 0x23c, 0x1001, 0x3, 0x2, 0x2, 0x2, 0x23e, 0x1006, 0x3, 
       0x2, 0x2, 0x2, 0x240, 0x1009, 0x3, 0x2, 0x2, 0x2, 0x242, 0x1011, 
       0x3, 0x2, 0x2, 0x2, 0x244, 0x1029, 0x3, 0x2, 0x2, 0x2, 0x246, 0x102b, 
       0x3, 0x2, 0x2, 0x2, 0x248, 0x1036, 0x3, 0x2, 0x2, 0x2, 0x24a, 0x1041, 
       0x3, 0x2, 0x2, 0x2, 0x24c, 0x1060, 0x3, 0x2, 0x2, 0x2, 0x24e, 0x1067, 
       0x3, 0x2, 0x2, 0x2, 0x250, 0x1069, 0x3, 0x2, 0x2, 0x2, 0x252, 0x1070, 
       0x3, 0x2, 0x2, 0x2, 0x254, 0x1074, 0x3, 0x2, 0x2, 0x2, 0x256, 0x1087, 
       0x3, 0x2, 0x2, 0x2, 0x258, 0x1089, 0x3, 0x2, 0x2, 0x2, 0x25a, 0x1097, 
       0x3, 0x2, 0x2, 0x2, 0x25c, 0x109d, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x1124, 
       0x3, 0x2, 0x2, 0x2, 0x260, 0x1126, 0x3, 0x2, 0x2, 0x2, 0x262, 0x114c, 
       0x3, 0x2, 0x2, 0x2, 0x264, 0x1197, 0x3, 0x2, 0x2, 0x2, 0x266, 0x1199, 
       0x3, 0x2, 0x2, 0x2, 0x268, 0x11b4, 0x3, 0x2, 0x2, 0x2, 0x26a, 0x11b6, 
       0x3, 0x2, 0x2, 0x2, 0x26c, 0x11c3, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x11c5, 
       0x3, 0x2, 0x2, 0x2, 0x270, 0x11c7, 0x3, 0x2, 0x2, 0x2, 0x272, 0x11c9, 
       0x3, 0x2, 0x2, 0x2, 0x274, 0x11d5, 0x3, 0x2, 0x2, 0x2, 0x276, 0x11d8, 
       0x3, 0x2, 0x2, 0x2, 0x278, 0x11df, 0x3, 0x2, 0x2, 0x2, 0x27a, 0x1207, 
       0x3, 0x2, 0x2, 0x2, 0x27c, 0x1209, 0x3, 0x2, 0x2, 0x2, 0x27e, 0x1210, 
       0x3, 0x2, 0x2, 0x2, 0x280, 0x121f, 0x3, 0x2, 0x2, 0x2, 0x282, 0x1221, 
       0x3, 0x2, 0x2, 0x2, 0x284, 0x1234, 0x3, 0x2, 0x2, 0x2, 0x286, 0x1239, 
       0x3, 0x2, 0x2, 0x2, 0x288, 0x123c, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x1277, 
       0x3, 0x2, 0x2, 0x2, 0x28c, 0x1279, 0x3, 0x2, 0x2, 0x2, 0x28e, 0x1285, 
       0x3, 0x2, 0x2, 0x2, 0x290, 0x128a, 0x3, 0x2, 0x2, 0x2, 0x292, 0x1291, 
       0x3, 0x2, 0x2, 0x2, 0x294, 0x1299, 0x3, 0x2, 0x2, 0x2, 0x296, 0x12a6, 
       0x3, 0x2, 0x2, 0x2, 0x298, 0x12b7, 0x3, 0x2, 0x2, 0x2, 0x29a, 0x12b9, 
       0x3, 0x2, 0x2, 0x2, 0x29c, 0x12c0, 0x3, 0x2, 0x2, 0x2, 0x29e, 0x12e1, 
       0x3, 0x2, 0x2, 0x2, 0x2a0, 0x12e3, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x12f0, 
       0x3, 0x2, 0x2, 0x2, 0x2a4, 0x12fd, 0x3, 0x2, 0x2, 0x2, 0x2a6, 0x1317, 
       0x3, 0x2, 0x2, 0x2, 0x2a8, 0x132e, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x1330, 
       0x3, 0x2, 0x2, 0x2, 0x2ac, 0x1332, 0x3, 0x2, 0x2, 0x2, 0x2ae, 0x1336, 
       0x3, 0x2, 0x2, 0x2, 0x2b0, 0x134d, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0x134f, 
       0x3, 0x2, 0x2, 0x2, 0x2b4, 0x1357, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x135f, 
       0x3, 0x2, 0x2, 0x2, 0x2b8, 0x1369, 0x3, 0x2, 0x2, 0x2, 0x2ba, 0x1370, 
       0x3, 0x2, 0x2, 0x2, 0x2bc, 0x1378, 0x3, 0x2, 0x2, 0x2, 0x2be, 0x1380, 
       0x3, 0x2, 0x2, 0x2, 0x2c0, 0x1382, 0x3, 0x2, 0x2, 0x2, 0x2c2, 0x1394, 
       0x3, 0x2, 0x2, 0x2, 0x2c4, 0x1396, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x13a3, 
       0x3, 0x2, 0x2, 0x2, 0x2c8, 0x13a5, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0x13a8, 
       0x3, 0x2, 0x2, 0x2, 0x2cc, 0x13b8, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0x13c3, 
       0x3, 0x2, 0x2, 0x2, 0x2d0, 0x13d2, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x13d4, 
       0x3, 0x2, 0x2, 0x2, 0x2d4, 0x13e4, 0x3, 0x2, 0x2, 0x2, 0x2d6, 0x13ee, 
       0x3, 0x2, 0x2, 0x2, 0x2d8, 0x13f0, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x13f4, 
       0x3, 0x2, 0x2, 0x2, 0x2dc, 0x13fa, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x13fe, 
       0x3, 0x2, 0x2, 0x2, 0x2e0, 0x1406, 0x3, 0x2, 0x2, 0x2, 0x2e2, 0x141b, 
       0x3, 0x2, 0x2, 0x2, 0x2e4, 0x141d, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x1420, 
       0x3, 0x2, 0x2, 0x2, 0x2e8, 0x1429, 0x3, 0x2, 0x2, 0x2, 0x2ea, 0x142b, 
       0x3, 0x2, 0x2, 0x2, 0x2ec, 0x1431, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x1436, 
       0x3, 0x2, 0x2, 0x2, 0x2f0, 0x145a, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x145c, 
       0x3, 0x2, 0x2, 0x2, 0x2f4, 0x1462, 0x3, 0x2, 0x2, 0x2, 0x2f6, 0x146a, 
       0x3, 0x2, 0x2, 0x2, 0x2f8, 0x1471, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x1479, 
       0x3, 0x2, 0x2, 0x2, 0x2fc, 0x1486, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x1488, 
       0x3, 0x2, 0x2, 0x2, 0x300, 0x148c, 0x3, 0x2, 0x2, 0x2, 0x302, 0x14a1, 
       0x3, 0x2, 0x2, 0x2, 0x304, 0x14cd, 0x3, 0x2, 0x2, 0x2, 0x306, 0x14d1, 
       0x3, 0x2, 0x2, 0x2, 0x308, 0x14d8, 0x3, 0x2, 0x2, 0x2, 0x30a, 0x14da, 
       0x3, 0x2, 0x2, 0x2, 0x30c, 0x14dc, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x14de, 
       0x3, 0x2, 0x2, 0x2, 0x310, 0x14e0, 0x3, 0x2, 0x2, 0x2, 0x312, 0x14e2, 
       0x3, 0x2, 0x2, 0x2, 0x314, 0x14e6, 0x3, 0x2, 0x2, 0x2, 0x316, 0x14fa, 
       0x3, 0x2, 0x2, 0x2, 0x318, 0x14fc, 0x3, 0x2, 0x2, 0x2, 0x31a, 0x1507, 
       0x3, 0x2, 0x2, 0x2, 0x31c, 0x1509, 0x3, 0x2, 0x2, 0x2, 0x31e, 0x1511, 
       0x3, 0x2, 0x2, 0x2, 0x320, 0x1514, 0x3, 0x2, 0x2, 0x2, 0x322, 0x1520, 
       0x3, 0x2, 0x2, 0x2, 0x324, 0x1523, 0x3, 0x2, 0x2, 0x2, 0x326, 0x1561, 
       0x3, 0x2, 0x2, 0x2, 0x328, 0x157a, 0x3, 0x2, 0x2, 0x2, 0x32a, 0x1580, 
       0x3, 0x2, 0x2, 0x2, 0x32c, 0x158d, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x158f, 
       0x3, 0x2, 0x2, 0x2, 0x330, 0x1596, 0x3, 0x2, 0x2, 0x2, 0x332, 0x1598, 
       0x3, 0x2, 0x2, 0x2, 0x334, 0x15a4, 0x3, 0x2, 0x2, 0x2, 0x336, 0x15a6, 
       0x3, 0x2, 0x2, 0x2, 0x338, 0x15ae, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x15cd, 
       0x3, 0x2, 0x2, 0x2, 0x33c, 0x15d5, 0x3, 0x2, 0x2, 0x2, 0x33e, 0x15e3, 
       0x3, 0x2, 0x2, 0x2, 0x340, 0x15e9, 0x3, 0x2, 0x2, 0x2, 0x342, 0x15eb, 
       0x3, 0x2, 0x2, 0x2, 0x344, 0x160a, 0x3, 0x2, 0x2, 0x2, 0x346, 0x160e, 
       0x3, 0x2, 0x2, 0x2, 0x348, 0x1612, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x1614, 
       0x3, 0x2, 0x2, 0x2, 0x34c, 0x161a, 0x3, 0x2, 0x2, 0x2, 0x34e, 0x1620, 
       0x3, 0x2, 0x2, 0x2, 0x350, 0x1624, 0x3, 0x2, 0x2, 0x2, 0x352, 0x1626, 
       0x3, 0x2, 0x2, 0x2, 0x354, 0x162b, 0x3, 0x2, 0x2, 0x2, 0x356, 0x1639, 
       0x3, 0x2, 0x2, 0x2, 0x358, 0x163b, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x163f, 
       0x3, 0x2, 0x2, 0x2, 0x35c, 0x1646, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x1648, 
       0x3, 0x2, 0x2, 0x2, 0x360, 0x1667, 0x3, 0x2, 0x2, 0x2, 0x362, 0x1669, 
       0x3, 0x2, 0x2, 0x2, 0x364, 0x1687, 0x3, 0x2, 0x2, 0x2, 0x366, 0x1694, 
       0x3, 0x2, 0x2, 0x2, 0x368, 0x1696, 0x3, 0x2, 0x2, 0x2, 0x36a, 0x16a8, 
       0x3, 0x2, 0x2, 0x2, 0x36c, 0x16cb, 0x3, 0x2, 0x2, 0x2, 0x36e, 0x16cd, 
       0x3, 0x2, 0x2, 0x2, 0x370, 0x16d1, 0x3, 0x2, 0x2, 0x2, 0x372, 0x16dc, 
       0x3, 0x2, 0x2, 0x2, 0x374, 0x16f6, 0x3, 0x2, 0x2, 0x2, 0x376, 0x16fc, 
       0x3, 0x2, 0x2, 0x2, 0x378, 0x172a, 0x3, 0x2, 0x2, 0x2, 0x37a, 0x172c, 
       0x3, 0x2, 0x2, 0x2, 0x37c, 0x1732, 0x3, 0x2, 0x2, 0x2, 0x37e, 0x1736, 
       0x3, 0x2, 0x2, 0x2, 0x380, 0x1755, 0x3, 0x2, 0x2, 0x2, 0x382, 0x1838, 
       0x3, 0x2, 0x2, 0x2, 0x384, 0x183f, 0x3, 0x2, 0x2, 0x2, 0x386, 0x1841, 
       0x3, 0x2, 0x2, 0x2, 0x388, 0x184a, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x184f, 
       0x3, 0x2, 0x2, 0x2, 0x38c, 0x185d, 0x3, 0x2, 0x2, 0x2, 0x38e, 0x185f, 
       0x3, 0x2, 0x2, 0x2, 0x390, 0x1861, 0x3, 0x2, 0x2, 0x2, 0x392, 0x1872, 
       0x3, 0x2, 0x2, 0x2, 0x394, 0x1874, 0x3, 0x2, 0x2, 0x2, 0x396, 0x1877, 
       0x3, 0x2, 0x2, 0x2, 0x398, 0x187f, 0x3, 0x2, 0x2, 0x2, 0x39a, 0x1883, 
       0x3, 0x2, 0x2, 0x2, 0x39c, 0x1892, 0x3, 0x2, 0x2, 0x2, 0x39e, 0x1896, 
       0x3, 0x2, 0x2, 0x2, 0x3a0, 0x189b, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x189f, 
       0x3, 0x2, 0x2, 0x2, 0x3a4, 0x18a8, 0x3, 0x2, 0x2, 0x2, 0x3a6, 0x18aa, 
       0x3, 0x2, 0x2, 0x2, 0x3a8, 0x18b5, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x18c1, 
       0x3, 0x2, 0x2, 0x2, 0x3ac, 0x18c3, 0x3, 0x2, 0x2, 0x2, 0x3ae, 0x18ca, 
       0x3, 0x2, 0x2, 0x2, 0x3b0, 0x18ce, 0x3, 0x2, 0x2, 0x2, 0x3b2, 0x18d6, 
       0x3, 0x2, 0x2, 0x2, 0x3b4, 0x18de, 0x3, 0x2, 0x2, 0x2, 0x3b6, 0x18ee, 
       0x3, 0x2, 0x2, 0x2, 0x3b8, 0x18f0, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x18f4, 
       0x3, 0x2, 0x2, 0x2, 0x3bc, 0x18fc, 0x3, 0x2, 0x2, 0x2, 0x3be, 0x190d, 
       0x3, 0x2, 0x2, 0x2, 0x3c0, 0x190f, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x1917, 
       0x3, 0x2, 0x2, 0x2, 0x3c4, 0x1923, 0x3, 0x2, 0x2, 0x2, 0x3c6, 0x1925, 
       0x3, 0x2, 0x2, 0x2, 0x3c8, 0x192b, 0x3, 0x2, 0x2, 0x2, 0x3ca, 0x192e, 
       0x3, 0x2, 0x2, 0x2, 0x3cc, 0x1941, 0x3, 0x2, 0x2, 0x2, 0x3ce, 0x1943, 
       0x3, 0x2, 0x2, 0x2, 0x3d0, 0x1946, 0x3, 0x2, 0x2, 0x2, 0x3d2, 0x1950, 
       0x3, 0x2, 0x2, 0x2, 0x3d4, 0x1954, 0x3, 0x2, 0x2, 0x2, 0x3d6, 0x1956, 
       0x3, 0x2, 0x2, 0x2, 0x3d8, 0x1964, 0x3, 0x2, 0x2, 0x2, 0x3da, 0x196f, 
       0x3, 0x2, 0x2, 0x2, 0x3dc, 0x1971, 0x3, 0x2, 0x2, 0x2, 0x3de, 0x1974, 
       0x3, 0x2, 0x2, 0x2, 0x3e0, 0x1976, 0x3, 0x2, 0x2, 0x2, 0x3e2, 0x1983, 
       0x3, 0x2, 0x2, 0x2, 0x3e4, 0x1988, 0x3, 0x2, 0x2, 0x2, 0x3e6, 0x198b, 
       0x3, 0x2, 0x2, 0x2, 0x3e8, 0x199d, 0x3, 0x2, 0x2, 0x2, 0x3ea, 0x19a0, 
       0x3, 0x2, 0x2, 0x2, 0x3ec, 0x19a6, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x19a8, 
       0x3, 0x2, 0x2, 0x2, 0x3f0, 0x19b0, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x19b4, 
       0x3, 0x2, 0x2, 0x2, 0x3f4, 0x19c7, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x19cb, 
       0x3, 0x2, 0x2, 0x2, 0x3f8, 0x19cd, 0x3, 0x2, 0x2, 0x2, 0x3fa, 0x19d5, 
       0x3, 0x2, 0x2, 0x2, 0x3fc, 0x19d9, 0x3, 0x2, 0x2, 0x2, 0x3fe, 0x19e1, 
       0x3, 0x2, 0x2, 0x2, 0x400, 0x19e3, 0x3, 0x2, 0x2, 0x2, 0x402, 0x19e5, 
       0x3, 0x2, 0x2, 0x2, 0x404, 0x19e7, 0x3, 0x2, 0x2, 0x2, 0x406, 0x19e9, 
       0x3, 0x2, 0x2, 0x2, 0x408, 0x19eb, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x19ed, 
       0x3, 0x2, 0x2, 0x2, 0x40c, 0x19f4, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x1a0f, 
       0x3, 0x2, 0x2, 0x2, 0x410, 0x1a11, 0x3, 0x2, 0x2, 0x2, 0x412, 0x1a13, 
       0x3, 0x2, 0x2, 0x2, 0x414, 0x1a15, 0x3, 0x2, 0x2, 0x2, 0x416, 0x1a17, 
       0x3, 0x2, 0x2, 0x2, 0x418, 0x1a1a, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x1a24, 
       0x3, 0x2, 0x2, 0x2, 0x41c, 0x1a29, 0x3, 0x2, 0x2, 0x2, 0x41e, 0x1a31, 
       0x3, 0x2, 0x2, 0x2, 0x420, 0x1a33, 0x3, 0x2, 0x2, 0x2, 0x422, 0x1a35, 
       0x3, 0x2, 0x2, 0x2, 0x424, 0x1a3c, 0x3, 0x2, 0x2, 0x2, 0x426, 0x1a40, 
       0x3, 0x2, 0x2, 0x2, 0x428, 0x1a42, 0x3, 0x2, 0x2, 0x2, 0x42a, 0x1a44, 
       0x3, 0x2, 0x2, 0x2, 0x42c, 0x1a46, 0x3, 0x2, 0x2, 0x2, 0x42e, 0x1a48, 
       0x3, 0x2, 0x2, 0x2, 0x430, 0x1a4a, 0x3, 0x2, 0x2, 0x2, 0x432, 0x434, 
       0x5, 0x4, 0x3, 0x2, 0x433, 0x435, 0x7, 0x1ed, 0x2, 0x2, 0x434, 0x433, 
       0x3, 0x2, 0x2, 0x2, 0x434, 0x435, 0x3, 0x2, 0x2, 0x2, 0x435, 0x436, 
       0x3, 0x2, 0x2, 0x2, 0x436, 0x437, 0x7, 0x2, 0x2, 0x3, 0x437, 0x3, 
       0x3, 0x2, 0x2, 0x2, 0x438, 0x43d, 0x5, 0x6, 0x4, 0x2, 0x439, 0x43a, 
       0x7, 0x1ed, 0x2, 0x2, 0x43a, 0x43c, 0x5, 0x6, 0x4, 0x2, 0x43b, 0x439, 
       0x3, 0x2, 0x2, 0x2, 0x43c, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x43d, 0x43b, 
       0x3, 0x2, 0x2, 0x2, 0x43d, 0x43e, 0x3, 0x2, 0x2, 0x2, 0x43e, 0x5, 
       0x3, 0x2, 0x2, 0x2, 0x43f, 0x43d, 0x3, 0x2, 0x2, 0x2, 0x440, 0x4a9, 
       0x5, 0x28c, 0x147, 0x2, 0x441, 0x4a9, 0x5, 0x28e, 0x148, 0x2, 0x442, 
       0x4a9, 0x5, 0x296, 0x14c, 0x2, 0x443, 0x4a9, 0x5, 0x182, 0xc2, 0x2, 
       0x444, 0x4a9, 0x5, 0x188, 0xc5, 0x2, 0x445, 0x4a9, 0x5, 0x242, 0x122, 
       0x2, 0x446, 0x4a9, 0x5, 0x42, 0x22, 0x2, 0x447, 0x4a9, 0x5, 0x262, 
       0x132, 0x2, 0x448, 0x4a9, 0x5, 0x264, 0x133, 0x2, 0x449, 0x4a9, 0x5, 
       0xc, 0x7, 0x2, 0x44a, 0x4a9, 0x5, 0x16, 0xc, 0x2, 0x44b, 0x4a9, 0x5, 
       0x34, 0x1b, 0x2, 0x44c, 0x4a9, 0x5, 0x32, 0x1a, 0x2, 0x44d, 0x4a9, 
       0x5, 0x29c, 0x14f, 0x2, 0x44e, 0x4a9, 0x5, 0x29a, 0x14e, 0x2, 0x44f, 
       0x4a9, 0x5, 0x158, 0xad, 0x2, 0x450, 0x4a9, 0x5, 0x74, 0x3b, 0x2, 
       0x451, 0x4a9, 0x5, 0x25c, 0x12f, 0x2, 0x452, 0x4a9, 0x5, 0x3a, 0x1e, 
       0x2, 0x453, 0x4a9, 0x5, 0x38, 0x1d, 0x2, 0x454, 0x4a9, 0x5, 0x2a8, 
       0x155, 0x2, 0x455, 0x4a9, 0x5, 0x70, 0x39, 0x2, 0x456, 0x4a9, 0x5, 
       0x92, 0x4a, 0x2, 0x457, 0x4a9, 0x5, 0x2a2, 0x152, 0x2, 0x458, 0x4a9, 
       0x5, 0x1e2, 0xf2, 0x2, 0x459, 0x4a9, 0x5, 0x6a, 0x36, 0x2, 0x45a, 
       0x4a9, 0x5, 0x94, 0x4b, 0x2, 0x45b, 0x4a9, 0x5, 0x11e, 0x90, 0x2, 
       0x45c, 0x4a9, 0x5, 0x1a6, 0xd4, 0x2, 0x45d, 0x4a9, 0x5, 0x254, 0x12b, 
       0x2, 0x45e, 0x4a9, 0x5, 0x2a0, 0x151, 0x2, 0x45f, 0x4a9, 0x5, 0x294, 
       0x14b, 0x2, 0x460, 0x4a9, 0x5, 0x17c, 0xbf, 0x2, 0x461, 0x4a9, 0x5, 
       0x12a, 0x96, 0x2, 0x462, 0x4a9, 0x5, 0x172, 0xba, 0x2, 0x463, 0x4a9, 
       0x5, 0x21a, 0x10e, 0x2, 0x464, 0x4a9, 0x5, 0x40, 0x21, 0x2, 0x465, 
       0x4a9, 0x5, 0x1be, 0xe0, 0x2, 0x466, 0x4a9, 0x5, 0x1c6, 0xe4, 0x2, 
       0x467, 0x4a9, 0x5, 0x1c8, 0xe5, 0x2, 0x468, 0x4a9, 0x5, 0x164, 0xb3, 
       0x2, 0x469, 0x4a9, 0x5, 0x8, 0x5, 0x2, 0x46a, 0x4a9, 0x5, 0x12, 0xa, 
       0x2, 0x46b, 0x4a9, 0x5, 0x48, 0x25, 0x2, 0x46c, 0x4a9, 0x5, 0x156, 
       0xac, 0x2, 0x46d, 0x4a9, 0x5, 0xa2, 0x52, 0x2, 0x46e, 0x4a9, 0x5, 
       0x17a, 0xbe, 0x2, 0x46f, 0x4a9, 0x5, 0x18c, 0xc7, 0x2, 0x470, 0x4a9, 
       0x5, 0x1a, 0xe, 0x2, 0x471, 0x4a9, 0x5, 0x30, 0x19, 0x2, 0x472, 0x4a9, 
       0x5, 0x288, 0x145, 0x2, 0x473, 0x4a9, 0x5, 0x2ba, 0x15e, 0x2, 0x474, 
       0x4a9, 0x5, 0x2e0, 0x171, 0x2, 0x475, 0x4a9, 0x5, 0x1aa, 0xd6, 0x2, 
       0x476, 0x4a9, 0x5, 0x2ca, 0x166, 0x2, 0x477, 0x4a9, 0x5, 0x72, 0x3a, 
       0x2, 0x478, 0x4a9, 0x5, 0x250, 0x129, 0x2, 0x479, 0x4a9, 0x5, 0x1a8, 
       0xd5, 0x2, 0x47a, 0x4a9, 0x5, 0x258, 0x12d, 0x2, 0x47b, 0x4a9, 0x5, 
       0x46, 0x24, 0x2, 0x47c, 0x4a9, 0x5, 0x1ce, 0xe8, 0x2, 0x47d, 0x4a9, 
       0x5, 0x1d0, 0xe9, 0x2, 0x47e, 0x4a9, 0x5, 0x1d2, 0xea, 0x2, 0x47f, 
       0x4a9, 0x5, 0x170, 0xb9, 0x2, 0x480, 0x4a9, 0x5, 0x10, 0x9, 0x2, 
       0x481, 0x4a9, 0x5, 0x14, 0xb, 0x2, 0x482, 0x4a9, 0x5, 0x272, 0x13a, 
       0x2, 0x483, 0x4a9, 0x5, 0x1d6, 0xec, 0x2, 0x484, 0x4a9, 0x5, 0x1a4, 
       0xd3, 0x2, 0x485, 0x4a9, 0x5, 0x3c, 0x1f, 0x2, 0x486, 0x4a9, 0x5, 
       0x3e, 0x20, 0x2, 0x487, 0x4a9, 0x5, 0x292, 0x14a, 0x2, 0x488, 0x4a9, 
       0x5, 0x2b8, 0x15d, 0x2, 0x489, 0x4a9, 0x5, 0x2ae, 0x158, 0x2, 0x48a, 
       0x4a9, 0x5, 0x1ec, 0xf7, 0x2, 0x48b, 0x4a9, 0x5, 0x1f0, 0xf9, 0x2, 
       0x48c, 0x4a9, 0x5, 0x206, 0x104, 0x2, 0x48d, 0x4a9, 0x5, 0x20e, 0x108, 
       0x2, 0x48e, 0x4a9, 0x5, 0x2c0, 0x161, 0x2, 0x48f, 0x4a9, 0x5, 0x276, 
       0x13c, 0x2, 0x490, 0x4a9, 0x5, 0x286, 0x144, 0x2, 0x491, 0x4a9, 0x5, 
       0x2cc, 0x167, 0x2, 0x492, 0x4a9, 0x5, 0x274, 0x13b, 0x2, 0x493, 0x4a9, 
       0x5, 0x2b2, 0x15a, 0x2, 0x494, 0x4a9, 0x5, 0x1d4, 0xeb, 0x2, 0x495, 
       0x4a9, 0x5, 0x25a, 0x12e, 0x2, 0x496, 0x4a9, 0x5, 0x248, 0x125, 0x2, 
       0x497, 0x4a9, 0x5, 0x246, 0x124, 0x2, 0x498, 0x4a9, 0x5, 0x24a, 0x126, 
       0x2, 0x499, 0x4a9, 0x5, 0x25e, 0x130, 0x2, 0x49a, 0x4a9, 0x5, 0x1f2, 
       0xfa, 0x2, 0x49b, 0x4a9, 0x5, 0x208, 0x105, 0x2, 0x49c, 0x4a9, 0x5, 
       0x266, 0x134, 0x2, 0x49d, 0x4a9, 0x5, 0x2e6, 0x174, 0x2, 0x49e, 0x4a9, 
       0x5, 0x27a, 0x13e, 0x2, 0x49f, 0x4a9, 0x5, 0x1e0, 0xf1, 0x2, 0x4a0, 
       0x4a9, 0x5, 0x278, 0x13d, 0x2, 0x4a1, 0x4a9, 0x5, 0x2d2, 0x16a, 0x2, 
       0x4a2, 0x4a9, 0x5, 0x2a6, 0x154, 0x2, 0x4a3, 0x4a9, 0x5, 0x64, 0x33, 
       0x2, 0x4a4, 0x4a9, 0x5, 0x4e, 0x28, 0x2, 0x4a5, 0x4a9, 0x5, 0x68, 
       0x35, 0x2, 0x4a6, 0x4a9, 0x5, 0x282, 0x142, 0x2, 0x4a7, 0x4a9, 0x7, 
       0x1ed, 0x2, 0x2, 0x4a8, 0x440, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x441, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x442, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x443, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x444, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x445, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x446, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x447, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x448, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x449, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x44a, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x44b, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x44c, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x44d, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x44e, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x44f, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x450, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x451, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x452, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x453, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x454, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x455, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x456, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x457, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x458, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x459, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x45a, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x45b, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x45c, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x45d, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x45e, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x45f, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x460, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x461, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x462, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x463, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x464, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x465, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x466, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x467, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x468, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x469, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x46a, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x46b, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x46c, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x46d, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x46e, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x46f, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x470, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x471, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x472, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x473, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x474, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x475, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x476, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x477, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x478, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x479, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x47a, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x47b, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x47c, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x47d, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x47e, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x47f, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x480, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x481, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x482, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x483, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x484, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x485, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x486, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x487, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x488, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x489, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x48a, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x48b, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x48c, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x48d, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x48e, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x48f, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x490, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x491, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x492, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x493, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x494, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x495, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x496, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x497, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x498, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x499, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x49a, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x49b, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x49c, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x49d, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x49e, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x49f, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a0, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a1, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a2, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a3, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a4, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a5, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a6, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4a7, 
       0x3, 0x2, 0x2, 0x2, 0x4a9, 0x7, 0x3, 0x2, 0x2, 0x2, 0x4aa, 0x4ab, 
       0x7, 0x4b, 0x2, 0x2, 0x4ab, 0x4ac, 0x7, 0x159, 0x2, 0x2, 0x4ac, 0x4ad, 
       0x7, 0x143, 0x2, 0x2, 0x4ad, 0x4b1, 0x5, 0x416, 0x20c, 0x2, 0x4ae, 
       0x4b0, 0x5, 0xa, 0x6, 0x2, 0x4af, 0x4ae, 0x3, 0x2, 0x2, 0x2, 0x4b0, 
       0x4b3, 0x3, 0x2, 0x2, 0x2, 0x4b1, 0x4af, 0x3, 0x2, 0x2, 0x2, 0x4b1, 
       0x4b2, 0x3, 0x2, 0x2, 0x2, 0x4b2, 0x4c2, 0x3, 0x2, 0x2, 0x2, 0x4b3, 
       0x4b1, 0x3, 0x2, 0x2, 0x2, 0x4b4, 0x4b5, 0x7, 0x4b, 0x2, 0x2, 0x4b5, 
       0x4b6, 0x7, 0x159, 0x2, 0x2, 0x4b6, 0x4b7, 0x7, 0x143, 0x2, 0x2, 
       0x4b7, 0x4bb, 0x5, 0x416, 0x20c, 0x2, 0x4b8, 0x4ba, 0x5, 0xa, 0x6, 
       0x2, 0x4b9, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0x4ba, 0x4bd, 0x3, 0x2, 0x2, 
       0x2, 0x4bb, 0x4b9, 0x3, 0x2, 0x2, 0x2, 0x4bb, 0x4bc, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4be, 0x3, 0x2, 0x2, 0x2, 0x4bd, 0x4bb, 0x3, 0x2, 0x2, 
       0x2, 0x4be, 0x4bf, 0x7, 0x1c4, 0x2, 0x2, 0x4bf, 0x4c0, 0x5, 0x1ac, 
       0xd7, 0x2, 0x4c0, 0x4c2, 0x3, 0x2, 0x2, 0x2, 0x4c1, 0x4aa, 0x3, 0x2, 
       0x2, 0x2, 0x4c1, 0x4b4, 0x3, 0x2, 0x2, 0x2, 0x4c2, 0x9, 0x3, 0x2, 
       0x2, 0x2, 0x4c3, 0x4c4, 0x7, 0x7, 0x2, 0x2, 0x4c4, 0x4c5, 0x7, 0x197, 
       0x2, 0x2, 0x4c5, 0x4cf, 0x5, 0x15e, 0xb0, 0x2, 0x4c6, 0x4c7, 0x7, 
       0x48, 0x2, 0x2, 0x4c7, 0x4c8, 0x7, 0x197, 0x2, 0x2, 0x4c8, 0x4cf, 
       0x5, 0x15e, 0xb0, 0x2, 0x4c9, 0x4ca, 0x7, 0xb2, 0x2, 0x2, 0x4ca, 
       0x4cb, 0x7, 0x197, 0x2, 0x2, 0x4cb, 0x4cf, 0x5, 0x15e, 0xb0, 0x2, 
       0x4cc, 0x4cf, 0x7, 0x125, 0x2, 0x2, 0x4cd, 0x4cf, 0x7, 0x106, 0x2, 
       0x2, 0x4ce, 0x4c3, 0x3, 0x2, 0x2, 0x2, 0x4ce, 0x4c6, 0x3, 0x2, 0x2, 
       0x2, 0x4ce, 0x4c9, 0x3, 0x2, 0x2, 0x2, 0x4ce, 0x4cc, 0x3, 0x2, 0x2, 
       0x2, 0x4ce, 0x4cd, 0x3, 0x2, 0x2, 0x2, 0x4cf, 0xb, 0x3, 0x2, 0x2, 
       0x2, 0x4d0, 0x4d1, 0x7, 0xe, 0x2, 0x2, 0x4d1, 0x4d2, 0x7, 0x159, 
       0x2, 0x2, 0x4d2, 0x4d3, 0x7, 0x143, 0x2, 0x2, 0x4d3, 0x4d7, 0x5, 
       0x416, 0x20c, 0x2, 0x4d4, 0x4d6, 0x5, 0xa, 0x6, 0x2, 0x4d5, 0x4d4, 
       0x3, 0x2, 0x2, 0x2, 0x4d6, 0x4d9, 0x3, 0x2, 0x2, 0x2, 0x4d7, 0x4d5, 
       0x3, 0x2, 0x2, 0x2, 0x4d7, 0x4d8, 0x3, 0x2, 0x2, 0x2, 0x4d8, 0x4dd, 
       0x3, 0x2, 0x2, 0x2, 0x4d9, 0x4d7, 0x3, 0x2, 0x2, 0x2, 0x4da, 0x4dc, 
       0x5, 0xe, 0x8, 0x2, 0x4db, 0x4da, 0x3, 0x2, 0x2, 0x2, 0x4dc, 0x4df, 
       0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4db, 0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4de, 
       0x3, 0x2, 0x2, 0x2, 0x4de, 0xd, 0x3, 0x2, 0x2, 0x2, 0x4df, 0x4dd, 
       0x3, 0x2, 0x2, 0x2, 0x4e0, 0x4e1, 0x9, 0x2, 0x2, 0x2, 0x4e1, 0x4e2, 
       0x5, 0x1ac, 0xd7, 0x2, 0x4e2, 0xf, 0x3, 0x2, 0x2, 0x2, 0x4e3, 0x4e4, 
       0x7, 0x78, 0x2, 0x2, 0x4e4, 0x4e5, 0x7, 0x159, 0x2, 0x2, 0x4e5, 0x4e6, 
       0x7, 0x143, 0x2, 0x2, 0x4e6, 0x4e7, 0x5, 0x416, 0x20c, 0x2, 0x4e7, 
       0x11, 0x3, 0x2, 0x2, 0x2, 0x4e8, 0x4e9, 0x7, 0x4b, 0x2, 0x2, 0x4e9, 
       0x4ea, 0x7, 0x159, 0x2, 0x2, 0x4ea, 0x4eb, 0x7, 0xa8, 0x2, 0x2, 0x4eb, 
       0x4ec, 0x5, 0x3fe, 0x200, 0x2, 0x4ec, 0x4ed, 0x5, 0xe, 0x8, 0x2, 
       0x4ed, 0x13, 0x3, 0x2, 0x2, 0x2, 0x4ee, 0x4ef, 0x7, 0x78, 0x2, 0x2, 
       0x4ef, 0x4f0, 0x7, 0x159, 0x2, 0x2, 0x4f0, 0x4f1, 0x7, 0xa8, 0x2, 
       0x2, 0x4f1, 0x4f2, 0x5, 0x3fe, 0x200, 0x2, 0x4f2, 0x15, 0x3, 0x2, 
       0x2, 0x2, 0x4f3, 0x4f4, 0x7, 0xe, 0x2, 0x2, 0x4f4, 0x4f5, 0x7, 0x159, 
       0x2, 0x2, 0x4f5, 0x4f6, 0x7, 0xa8, 0x2, 0x2, 0x4f6, 0x4f7, 0x5, 0x3fe, 
       0x200, 0x2, 0x4f7, 0x4f9, 0x7, 0x174, 0x2, 0x2, 0x4f8, 0x4fa, 0x5, 
       0x18, 0xd, 0x2, 0x4f9, 0x4f8, 0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4fa, 0x3, 
       0x2, 0x2, 0x2, 0x4fa, 0x17, 0x3, 0x2, 0x2, 0x2, 0x4fb, 0x4fc, 0x7, 
       0x3c, 0x2, 0x2, 0x4fc, 0x508, 0x5, 0x162, 0xb2, 0x2, 0x4fd, 0x4fe, 
       0x7, 0x49, 0x2, 0x2, 0x4fe, 0x508, 0x5, 0x162, 0xb2, 0x2, 0x4ff, 
       0x500, 0x7, 0x4a, 0x2, 0x2, 0x500, 0x508, 0x5, 0x412, 0x20a, 0x2, 
       0x501, 0x502, 0x7, 0xeb, 0x2, 0x2, 0x502, 0x508, 0x5, 0x162, 0xb2, 
       0x2, 0x503, 0x504, 0x7, 0xea, 0x2, 0x2, 0x504, 0x508, 0x5, 0x162, 
       0xb2, 0x2, 0x505, 0x506, 0x7, 0xec, 0x2, 0x2, 0x506, 0x508, 0x5, 
       0x162, 0xb2, 0x2, 0x507, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x507, 0x4fd, 
       0x3, 0x2, 0x2, 0x2, 0x507, 0x4ff, 0x3, 0x2, 0x2, 0x2, 0x507, 0x501, 
       0x3, 0x2, 0x2, 0x2, 0x507, 0x503, 0x3, 0x2, 0x2, 0x2, 0x507, 0x505, 
       0x3, 0x2, 0x2, 0x2, 0x508, 0x19, 0x3, 0x2, 0x2, 0x2, 0x509, 0x50a, 
       0x7, 0x4b, 0x2, 0x2, 0x50a, 0x50b, 0x7, 0x160, 0x2, 0x2, 0x50b, 0x50d, 
       0x5, 0x414, 0x20b, 0x2, 0x50c, 0x50e, 0x5, 0x1c, 0xf, 0x2, 0x50d, 
       0x50c, 0x3, 0x2, 0x2, 0x2, 0x50d, 0x50e, 0x3, 0x2, 0x2, 0x2, 0x50e, 
       0x512, 0x3, 0x2, 0x2, 0x2, 0x50f, 0x511, 0x5, 0x1e, 0x10, 0x2, 0x510, 
       0x50f, 0x3, 0x2, 0x2, 0x2, 0x511, 0x514, 0x3, 0x2, 0x2, 0x2, 0x512, 
       0x510, 0x3, 0x2, 0x2, 0x2, 0x512, 0x513, 0x3, 0x2, 0x2, 0x2, 0x513, 
       0x1b, 0x3, 0x2, 0x2, 0x2, 0x514, 0x512, 0x3, 0x2, 0x2, 0x2, 0x515, 
       0x516, 0x7, 0x1c4, 0x2, 0x2, 0x516, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x517, 
       0x518, 0x7, 0x12f, 0x2, 0x2, 0x518, 0x54d, 0x5, 0x412, 0x20a, 0x2, 
       0x519, 0x51a, 0x7, 0x12f, 0x2, 0x2, 0x51a, 0x54d, 0x7, 0x10e, 0x2, 
       0x2, 0x51b, 0x51c, 0x7, 0x7e, 0x2, 0x2, 0x51c, 0x51d, 0x7, 0x12f, 
       0x2, 0x2, 0x51d, 0x54d, 0x5, 0x412, 0x20a, 0x2, 0x51e, 0x51f, 0x7, 
       0x1a8, 0x2, 0x2, 0x51f, 0x520, 0x7, 0x12f, 0x2, 0x2, 0x520, 0x54d, 
       0x5, 0x412, 0x20a, 0x2, 0x521, 0x54d, 0x7, 0x18c, 0x2, 0x2, 0x522, 
       0x54d, 0x7, 0x107, 0x2, 0x2, 0x523, 0x54d, 0x7, 0xbc, 0x2, 0x2, 0x524, 
       0x54d, 0x7, 0x103, 0x2, 0x2, 0x525, 0x54d, 0x7, 0x4c, 0x2, 0x2, 0x526, 
       0x54d, 0x7, 0xff, 0x2, 0x2, 0x527, 0x54d, 0x7, 0x4e, 0x2, 0x2, 0x528, 
       0x54d, 0x7, 0x101, 0x2, 0x2, 0x529, 0x54d, 0x7, 0x4f, 0x2, 0x2, 0x52a, 
       0x54d, 0x7, 0x102, 0x2, 0x2, 0x52b, 0x54d, 0x7, 0xe3, 0x2, 0x2, 0x52c, 
       0x54d, 0x7, 0x104, 0x2, 0x2, 0x52d, 0x52e, 0x7, 0x40, 0x2, 0x2, 0x52e, 
       0x52f, 0x7, 0xda, 0x2, 0x2, 0x52f, 0x54d, 0x5, 0x418, 0x20d, 0x2, 
       0x530, 0x531, 0x7, 0x1b3, 0x2, 0x2, 0x531, 0x532, 0x7, 0x1ad, 0x2, 
       0x2, 0x532, 0x54d, 0x5, 0x412, 0x20a, 0x2, 0x533, 0x534, 0x7, 0x159, 
       0x2, 0x2, 0x534, 0x535, 0x7, 0x143, 0x2, 0x2, 0x535, 0x54d, 0x5, 
       0x1dc, 0xef, 0x2, 0x536, 0x537, 0x7, 0x159, 0x2, 0x2, 0x537, 0x538, 
       0x7, 0xa8, 0x2, 0x2, 0x538, 0x54d, 0x5, 0x1dc, 0xef, 0x2, 0x539, 
       0x53a, 0x7, 0x1b0, 0x2, 0x2, 0x53a, 0x54d, 0x5, 0x3fc, 0x1ff, 0x2, 
       0x53b, 0x53c, 0x7, 0x18e, 0x2, 0x2, 0x53c, 0x54d, 0x5, 0x410, 0x209, 
       0x2, 0x53d, 0x53e, 0x7, 0x9, 0x2, 0x2, 0x53e, 0x54d, 0x5, 0x3fc, 
       0x1ff, 0x2, 0x53f, 0x540, 0x7, 0x160, 0x2, 0x2, 0x540, 0x54d, 0x5, 
       0x3fc, 0x1ff, 0x2, 0x541, 0x542, 0x7, 0xc2, 0x2, 0x2, 0x542, 0x543, 
       0x7, 0x160, 0x2, 0x2, 0x543, 0x54d, 0x5, 0x3fc, 0x1ff, 0x2, 0x544, 
       0x545, 0x7, 0xc2, 0x2, 0x2, 0x545, 0x546, 0x7, 0xa8, 0x2, 0x2, 0x546, 
       0x54d, 0x5, 0x3fc, 0x1ff, 0x2, 0x547, 0x548, 0x7, 0x4d, 0x2, 0x2, 
       0x548, 0x54d, 0x5, 0x2a, 0x16, 0x2, 0x549, 0x54a, 0x7, 0x100, 0x2, 
       0x2, 0x54a, 0x54d, 0x5, 0x2a, 0x16, 0x2, 0x54b, 0x54d, 0x5, 0x20, 
       0x11, 0x2, 0x54c, 0x517, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x519, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x51b, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x51e, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x521, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x522, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x523, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x524, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x525, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x526, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x527, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x528, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x529, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x52a, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x52b, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x52c, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x52d, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x530, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x533, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x536, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x539, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x53b, 0x3, 0x2, 
       0x2, 0x2, 0x54c, 0x53d, 0x3, 0x2, 0x2, 0x2, 0x54c, 
  };
  static uint16_t serializedATNSegment1[] = {
    0x53f, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x541, 0x3, 0x2, 0x2, 0x2, 0x54c, 
       0x544, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x547, 0x3, 0x2, 0x2, 0x2, 0x54c, 
       0x549, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x54b, 0x3, 0x2, 0x2, 0x2, 0x54d, 
       0x1f, 0x3, 0x2, 0x2, 0x2, 0x54e, 0x54f, 0x7, 0x6d, 0x2, 0x2, 0x54f, 
       0x553, 0x5, 0x22, 0x12, 0x2, 0x550, 0x551, 0x7, 0x6d, 0x2, 0x2, 0x551, 
       0x553, 0x5, 0x26, 0x14, 0x2, 0x552, 0x54e, 0x3, 0x2, 0x2, 0x2, 0x552, 
       0x550, 0x3, 0x2, 0x2, 0x2, 0x553, 0x21, 0x3, 0x2, 0x2, 0x2, 0x554, 
       0x555, 0x7, 0x1f, 0x2, 0x2, 0x555, 0x556, 0x5, 0x26, 0x14, 0x2, 0x556, 
       0x557, 0x7, 0x12, 0x2, 0x2, 0x557, 0x558, 0x5, 0x26, 0x14, 0x2, 0x558, 
       0x23, 0x3, 0x2, 0x2, 0x2, 0x559, 0x55c, 0x5, 0x412, 0x20a, 0x2, 0x55a, 
       0x55c, 0x5, 0x410, 0x209, 0x2, 0x55b, 0x559, 0x3, 0x2, 0x2, 0x2, 
       0x55b, 0x55a, 0x3, 0x2, 0x2, 0x2, 0x55c, 0x25, 0x3, 0x2, 0x2, 0x2, 
       0x55d, 0x55e, 0x7, 0x5f, 0x2, 0x2, 0x55e, 0x55f, 0x5, 0x24, 0x13, 
       0x2, 0x55f, 0x560, 0x5, 0x28, 0x15, 0x2, 0x560, 0x27, 0x3, 0x2, 0x2, 
       0x2, 0x561, 0x562, 0x7, 0x199, 0x2, 0x2, 0x562, 0x563, 0x5, 0x412, 
       0x20a, 0x2, 0x563, 0x29, 0x3, 0x2, 0x2, 0x2, 0x564, 0x565, 0x7, 0x1d9, 
       0x2, 0x2, 0x565, 0x566, 0x5, 0x2c, 0x17, 0x2, 0x566, 0x567, 0x7, 
       0x1da, 0x2, 0x2, 0x567, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x568, 0x56d, 0x5, 
       0x2e, 0x18, 0x2, 0x569, 0x56a, 0x7, 0x1df, 0x2, 0x2, 0x56a, 0x56c, 
       0x5, 0x2e, 0x18, 0x2, 0x56b, 0x569, 0x3, 0x2, 0x2, 0x2, 0x56c, 0x56f, 
       0x3, 0x2, 0x2, 0x2, 0x56d, 0x56b, 0x3, 0x2, 0x2, 0x2, 0x56d, 0x56e, 
       0x3, 0x2, 0x2, 0x2, 0x56e, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x56f, 0x56d, 
       0x3, 0x2, 0x2, 0x2, 0x570, 0x571, 0x5, 0x41e, 0x210, 0x2, 0x571, 
       0x572, 0x7, 0x1f1, 0x2, 0x2, 0x572, 0x573, 0x5, 0x412, 0x20a, 0x2, 
       0x573, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x574, 0x575, 0x7, 0x4b, 0x2, 0x2, 
       0x575, 0x576, 0x7, 0x1b0, 0x2, 0x2, 0x576, 0x578, 0x5, 0x414, 0x20b, 
       0x2, 0x577, 0x579, 0x5, 0x1c, 0xf, 0x2, 0x578, 0x577, 0x3, 0x2, 0x2, 
       0x2, 0x578, 0x579, 0x3, 0x2, 0x2, 0x2, 0x579, 0x57d, 0x3, 0x2, 0x2, 
       0x2, 0x57a, 0x57c, 0x5, 0x1e, 0x10, 0x2, 0x57b, 0x57a, 0x3, 0x2, 
       0x2, 0x2, 0x57c, 0x57f, 0x3, 0x2, 0x2, 0x2, 0x57d, 0x57b, 0x3, 0x2, 
       0x2, 0x2, 0x57d, 0x57e, 0x3, 0x2, 0x2, 0x2, 0x57e, 0x31, 0x3, 0x2, 
       0x2, 0x2, 0x57f, 0x57d, 0x3, 0x2, 0x2, 0x2, 0x580, 0x581, 0x7, 0xe, 
       0x2, 0x2, 0x581, 0x582, 0x7, 0x160, 0x2, 0x2, 0x582, 0x584, 0x5, 
       0x414, 0x20b, 0x2, 0x583, 0x585, 0x5, 0x1c, 0xf, 0x2, 0x584, 0x583, 
       0x3, 0x2, 0x2, 0x2, 0x584, 0x585, 0x3, 0x2, 0x2, 0x2, 0x585, 0x589, 
       0x3, 0x2, 0x2, 0x2, 0x586, 0x588, 0x5, 0x36, 0x1c, 0x2, 0x587, 0x586, 
       0x3, 0x2, 0x2, 0x2, 0x588, 0x58b, 0x3, 0x2, 0x2, 0x2, 0x589, 0x587, 
       0x3, 0x2, 0x2, 0x2, 0x589, 0x58a, 0x3, 0x2, 0x2, 0x2, 0x58a, 0x33, 
       0x3, 0x2, 0x2, 0x2, 0x58b, 0x589, 0x3, 0x2, 0x2, 0x2, 0x58c, 0x58d, 
       0x7, 0xe, 0x2, 0x2, 0x58d, 0x58e, 0x7, 0x160, 0x2, 0x2, 0x58e, 0x58f, 
       0x5, 0x414, 0x20b, 0x2, 0x58f, 0x590, 0x5, 0x66, 0x34, 0x2, 0x590, 
       0x35, 0x3, 0x2, 0x2, 0x2, 0x591, 0x597, 0x5, 0x1e, 0x10, 0x2, 0x592, 
       0x593, 0x7, 0x78, 0x2, 0x2, 0x593, 0x594, 0x7, 0x6d, 0x2, 0x2, 0x594, 
       0x595, 0x7, 0x99, 0x2, 0x2, 0x595, 0x597, 0x5, 0x26, 0x14, 0x2, 0x596, 
       0x591, 0x3, 0x2, 0x2, 0x2, 0x596, 0x592, 0x3, 0x2, 0x2, 0x2, 0x597, 
       0x37, 0x3, 0x2, 0x2, 0x2, 0x598, 0x599, 0x7, 0xe, 0x2, 0x2, 0x599, 
       0x59a, 0x7, 0x1b0, 0x2, 0x2, 0x59a, 0x59c, 0x5, 0x414, 0x20b, 0x2, 
       0x59b, 0x59d, 0x5, 0x1c, 0xf, 0x2, 0x59c, 0x59b, 0x3, 0x2, 0x2, 0x2, 
       0x59c, 0x59d, 0x3, 0x2, 0x2, 0x2, 0x59d, 0x5a1, 0x3, 0x2, 0x2, 0x2, 
       0x59e, 0x5a0, 0x5, 0x36, 0x1c, 0x2, 0x59f, 0x59e, 0x3, 0x2, 0x2, 
       0x2, 0x5a0, 0x5a3, 0x3, 0x2, 0x2, 0x2, 0x5a1, 0x59f, 0x3, 0x2, 0x2, 
       0x2, 0x5a1, 0x5a2, 0x3, 0x2, 0x2, 0x2, 0x5a2, 0x39, 0x3, 0x2, 0x2, 
       0x2, 0x5a3, 0x5a1, 0x3, 0x2, 0x2, 0x2, 0x5a4, 0x5a5, 0x7, 0xe, 0x2, 
       0x2, 0x5a5, 0x5a6, 0x7, 0x1b0, 0x2, 0x2, 0x5a6, 0x5a7, 0x5, 0x414, 
       0x20b, 0x2, 0x5a7, 0x5a8, 0x5, 0x66, 0x34, 0x2, 0x5a8, 0x3b, 0x3, 
       0x2, 0x2, 0x2, 0x5a9, 0x5aa, 0x7, 0x78, 0x2, 0x2, 0x5aa, 0x5ab, 0x7, 
       0x160, 0x2, 0x2, 0x5ab, 0x5b2, 0x5, 0x3fc, 0x1ff, 0x2, 0x5ac, 0x5ad, 
       0x7, 0x78, 0x2, 0x2, 0x5ad, 0x5ae, 0x7, 0x160, 0x2, 0x2, 0x5ae, 0x5af, 
       0x7, 0xb1, 0x2, 0x2, 0x5af, 0x5b0, 0x7, 0x8a, 0x2, 0x2, 0x5b0, 0x5b2, 
       0x5, 0x3fc, 0x1ff, 0x2, 0x5b1, 0x5a9, 0x3, 0x2, 0x2, 0x2, 0x5b1, 
       0x5ac, 0x3, 0x2, 0x2, 0x2, 0x5b2, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x5b3, 
       0x5b4, 0x7, 0x78, 0x2, 0x2, 0x5b4, 0x5b5, 0x7, 0x1b0, 0x2, 0x2, 0x5b5, 
       0x5bc, 0x5, 0x3fc, 0x1ff, 0x2, 0x5b6, 0x5b7, 0x7, 0x78, 0x2, 0x2, 
       0x5b7, 0x5b8, 0x7, 0x1b0, 0x2, 0x2, 0x5b8, 0x5b9, 0x7, 0xb1, 0x2, 
       0x2, 0x5b9, 0x5ba, 0x7, 0x8a, 0x2, 0x2, 0x5ba, 0x5bc, 0x5, 0x3fc, 
       0x1ff, 0x2, 0x5bb, 0x5b3, 0x3, 0x2, 0x2, 0x2, 0x5bb, 0x5b6, 0x3, 
       0x2, 0x2, 0x2, 0x5bc, 0x3f, 0x3, 0x2, 0x2, 0x2, 0x5bd, 0x5be, 0x7, 
       0x4b, 0x2, 0x2, 0x5be, 0x5bf, 0x7, 0xa8, 0x2, 0x2, 0x5bf, 0x5c1, 
       0x5, 0x414, 0x20b, 0x2, 0x5c0, 0x5c2, 0x5, 0x1c, 0xf, 0x2, 0x5c1, 
       0x5c0, 0x3, 0x2, 0x2, 0x2, 0x5c1, 0x5c2, 0x3, 0x2, 0x2, 0x2, 0x5c2, 
       0x5c6, 0x3, 0x2, 0x2, 0x2, 0x5c3, 0x5c5, 0x5, 0x1e, 0x10, 0x2, 0x5c4, 
       0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5c5, 0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5c6, 
       0x5c4, 0x3, 0x2, 0x2, 0x2, 0x5c6, 0x5c7, 0x3, 0x2, 0x2, 0x2, 0x5c7, 
       0x41, 0x3, 0x2, 0x2, 0x2, 0x5c8, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x5c9, 
       0x5ca, 0x7, 0xe, 0x2, 0x2, 0x5ca, 0x5cb, 0x7, 0xa8, 0x2, 0x2, 0x5cb, 
       0x5cc, 0x5, 0x414, 0x20b, 0x2, 0x5cc, 0x5cd, 0x5, 0x44, 0x23, 0x2, 
       0x5cd, 0x5ce, 0x7, 0x1b0, 0x2, 0x2, 0x5ce, 0x5cf, 0x5, 0x3fc, 0x1ff, 
       0x2, 0x5cf, 0x43, 0x3, 0x2, 0x2, 0x2, 0x5d0, 0x5d1, 0x9, 0x3, 0x2, 
       0x2, 0x5d1, 0x45, 0x3, 0x2, 0x2, 0x2, 0x5d2, 0x5d3, 0x7, 0x78, 0x2, 
       0x2, 0x5d3, 0x5d6, 0x7, 0xa8, 0x2, 0x2, 0x5d4, 0x5d5, 0x7, 0xb1, 
       0x2, 0x2, 0x5d5, 0x5d7, 0x7, 0x8a, 0x2, 0x2, 0x5d6, 0x5d4, 0x3, 0x2, 
       0x2, 0x2, 0x5d6, 0x5d7, 0x3, 0x2, 0x2, 0x2, 0x5d7, 0x5d8, 0x3, 0x2, 
       0x2, 0x2, 0x5d8, 0x5d9, 0x5, 0x3fc, 0x1ff, 0x2, 0x5d9, 0x47, 0x3, 
       0x2, 0x2, 0x2, 0x5da, 0x5db, 0x7, 0x4b, 0x2, 0x2, 0x5db, 0x5dd, 0x7, 
       0x169, 0x2, 0x2, 0x5dc, 0x5de, 0x5, 0x4a, 0x26, 0x2, 0x5dd, 0x5dc, 
       0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5de, 0x3, 0x2, 0x2, 0x2, 0x5de, 0x5df, 
       0x3, 0x2, 0x2, 0x2, 0x5df, 0x5e0, 0x7, 0x1b, 0x2, 0x2, 0x5e0, 0x5e4, 
       0x5, 0x414, 0x20b, 0x2, 0x5e1, 0x5e3, 0x5, 0x4c, 0x27, 0x2, 0x5e2, 
       0x5e1, 0x3, 0x2, 0x2, 0x2, 0x5e3, 0x5e6, 0x3, 0x2, 0x2, 0x2, 0x5e4, 
       0x5e5, 0x3, 0x2, 0x2, 0x2, 0x5e4, 0x5e2, 0x3, 0x2, 0x2, 0x2, 0x5e5, 
       0x5f1, 0x3, 0x2, 0x2, 0x2, 0x5e6, 0x5e4, 0x3, 0x2, 0x2, 0x2, 0x5e7, 
       0x5e8, 0x7, 0x4b, 0x2, 0x2, 0x5e8, 0x5e9, 0x7, 0x169, 0x2, 0x2, 0x5e9, 
       0x5ed, 0x5, 0x41a, 0x20e, 0x2, 0x5ea, 0x5ec, 0x5, 0x4c, 0x27, 0x2, 
       0x5eb, 0x5ea, 0x3, 0x2, 0x2, 0x2, 0x5ec, 0x5ef, 0x3, 0x2, 0x2, 0x2, 
       0x5ed, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5eb, 0x3, 0x2, 0x2, 0x2, 
       0x5ee, 0x5f1, 0x3, 0x2, 0x2, 0x2, 0x5ef, 0x5ed, 0x3, 0x2, 0x2, 0x2, 
       0x5f0, 0x5da, 0x3, 0x2, 0x2, 0x2, 0x5f0, 0x5e7, 0x3, 0x2, 0x2, 0x2, 
       0x5f1, 0x49, 0x3, 0x2, 0x2, 0x2, 0x5f2, 0x5f3, 0x5, 0x41a, 0x20e, 
       0x2, 0x5f3, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x5f4, 0x5fb, 0x5, 0xa2, 0x52, 
       0x2, 0x5f5, 0x5fb, 0x5, 0x20e, 0x108, 0x2, 0x5f6, 0x5fb, 0x5, 0x156, 
       0xac, 0x2, 0x5f7, 0x5fb, 0x5, 0x18c, 0xc7, 0x2, 0x5f8, 0x5fb, 0x5, 
       0x1f0, 0xf9, 0x2, 0x5f9, 0x5fb, 0x5, 0x282, 0x142, 0x2, 0x5fa, 0x5f4, 
       0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5f6, 
       0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5f7, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5f8, 
       0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5f9, 0x3, 0x2, 0x2, 0x2, 0x5fb, 0x4d, 
       0x3, 0x2, 0x2, 0x2, 0x5fc, 0x5fe, 0x7, 0x174, 0x2, 0x2, 0x5fd, 0x5ff, 
       0x9, 0x4, 0x2, 0x2, 0x5fe, 0x5fd, 0x3, 0x2, 0x2, 0x2, 0x5fe, 0x5ff, 
       0x3, 0x2, 0x2, 0x2, 0x5ff, 0x600, 0x3, 0x2, 0x2, 0x2, 0x600, 0x601, 
       0x5, 0x50, 0x29, 0x2, 0x601, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x602, 0x603, 
       0x5, 0x52, 0x2a, 0x2, 0x603, 0x604, 0x9, 0x5, 0x2, 0x2, 0x604, 0x605, 
       0x5, 0x54, 0x2b, 0x2, 0x605, 0x606, 0x8, 0x29, 0x1, 0x2, 0x606, 0x62a, 
       0x3, 0x2, 0x2, 0x2, 0x607, 0x608, 0x5, 0x52, 0x2a, 0x2, 0x608, 0x609, 
       0x9, 0x5, 0x2, 0x2, 0x609, 0x60a, 0x7, 0x65, 0x2, 0x2, 0x60a, 0x60b, 
       0x8, 0x29, 0x1, 0x2, 0x60b, 0x62a, 0x3, 0x2, 0x2, 0x2, 0x60c, 0x60d, 
       0x5, 0x52, 0x2a, 0x2, 0x60d, 0x60e, 0x7, 0x9f, 0x2, 0x2, 0x60e, 0x60f, 
       0x7, 0x55, 0x2, 0x2, 0x60f, 0x62a, 0x3, 0x2, 0x2, 0x2, 0x610, 0x611, 
       0x7, 0x199, 0x2, 0x2, 0x611, 0x612, 0x7, 0x1d6, 0x2, 0x2, 0x612, 
       0x62a, 0x5, 0x5c, 0x2f, 0x2, 0x613, 0x614, 0x7, 0x19d, 0x2, 0x2, 
       0x614, 0x62a, 0x5, 0x280, 0x141, 0x2, 0x615, 0x616, 0x7, 0x172, 0x2, 
       0x2, 0x616, 0x617, 0x7, 0x2e, 0x2, 0x2, 0x617, 0x618, 0x7, 0x15, 
       0x2, 0x2, 0x618, 0x619, 0x7, 0x19d, 0x2, 0x2, 0x619, 0x62a, 0x5, 
       0x280, 0x141, 0x2, 0x61a, 0x61c, 0x7, 0xf8, 0x2, 0x2, 0x61b, 0x61d, 
       0x5, 0x60, 0x31, 0x2, 0x61c, 0x61b, 0x3, 0x2, 0x2, 0x2, 0x61c, 0x61d, 
       0x3, 0x2, 0x2, 0x2, 0x61d, 0x62a, 0x3, 0x2, 0x2, 0x2, 0x61e, 0x61f, 
       0x7, 0x160, 0x2, 0x2, 0x61f, 0x62a, 0x5, 0x62, 0x32, 0x2, 0x620, 
       0x621, 0x7, 0x172, 0x2, 0x2, 0x621, 0x624, 0x7, 0x1b, 0x2, 0x2, 0x622, 
       0x625, 0x5, 0x62, 0x32, 0x2, 0x623, 0x625, 0x7, 0x65, 0x2, 0x2, 0x624, 
       0x622, 0x3, 0x2, 0x2, 0x2, 0x624, 0x623, 0x3, 0x2, 0x2, 0x2, 0x625, 
       0x62a, 0x3, 0x2, 0x2, 0x2, 0x626, 0x627, 0x7, 0x1cf, 0x2, 0x2, 0x627, 
       0x628, 0x7, 0x11c, 0x2, 0x2, 0x628, 0x62a, 0x5, 0x38e, 0x1c8, 0x2, 
       0x629, 0x602, 0x3, 0x2, 0x2, 0x2, 0x629, 0x607, 0x3, 0x2, 0x2, 0x2, 
       0x629, 0x60c, 0x3, 0x2, 0x2, 0x2, 0x629, 0x610, 0x3, 0x2, 0x2, 0x2, 
       0x629, 0x613, 0x3, 0x2, 0x2, 0x2, 0x629, 0x615, 0x3, 0x2, 0x2, 0x2, 
       0x629, 0x61a, 0x3, 0x2, 0x2, 0x2, 0x629, 0x61e, 0x3, 0x2, 0x2, 0x2, 
       0x629, 0x620, 0x3, 0x2, 0x2, 0x2, 0x629, 0x626, 0x3, 0x2, 0x2, 0x2, 
       0x62a, 0x51, 0x3, 0x2, 0x2, 0x2, 0x62b, 0x62c, 0x8, 0x2a, 0x1, 0x2, 
       0x62c, 0x62d, 0x5, 0x41a, 0x20e, 0x2, 0x62d, 0x633, 0x3, 0x2, 0x2, 
       0x2, 0x62e, 0x62f, 0xc, 0x3, 0x2, 0x2, 0x62f, 0x630, 0x7, 0x1e3, 
       0x2, 0x2, 0x630, 0x632, 0x5, 0x41a, 0x20e, 0x2, 0x631, 0x62e, 0x3, 
       0x2, 0x2, 0x2, 0x632, 0x635, 0x3, 0x2, 0x2, 0x2, 0x633, 0x631, 0x3, 
       0x2, 0x2, 0x2, 0x633, 0x634, 0x3, 0x2, 0x2, 0x2, 0x634, 0x53, 0x3, 
       0x2, 0x2, 0x2, 0x635, 0x633, 0x3, 0x2, 0x2, 0x2, 0x636, 0x63b, 0x5, 
       0x56, 0x2c, 0x2, 0x637, 0x638, 0x7, 0x1df, 0x2, 0x2, 0x638, 0x63a, 
       0x5, 0x56, 0x2c, 0x2, 0x639, 0x637, 0x3, 0x2, 0x2, 0x2, 0x63a, 0x63d, 
       0x3, 0x2, 0x2, 0x2, 0x63b, 0x639, 0x3, 0x2, 0x2, 0x2, 0x63b, 0x63c, 
       0x3, 0x2, 0x2, 0x2, 0x63c, 0x55, 0x3, 0x2, 0x2, 0x2, 0x63d, 0x63b, 
       0x3, 0x2, 0x2, 0x2, 0x63e, 0x642, 0x5, 0x5a, 0x2e, 0x2, 0x63f, 0x642, 
       0x5, 0x62, 0x32, 0x2, 0x640, 0x642, 0x5, 0x15e, 0xb0, 0x2, 0x641, 
       0x63e, 0x3, 0x2, 0x2, 0x2, 0x641, 0x63f, 0x3, 0x2, 0x2, 0x2, 0x641, 
       0x640, 0x3, 0x2, 0x2, 0x2, 0x642, 0x57, 0x3, 0x2, 0x2, 0x2, 0x643, 
       0x644, 0x7, 0x147, 0x2, 0x2, 0x644, 0x649, 0x9, 0x6, 0x2, 0x2, 0x645, 
       0x646, 0x7, 0x155, 0x2, 0x2, 0x646, 0x649, 0x7, 0x147, 0x2, 0x2, 
       0x647, 0x649, 0x7, 0x171, 0x2, 0x2, 0x648, 0x643, 0x3, 0x2, 0x2, 
       0x2, 0x648, 0x645, 0x3, 0x2, 0x2, 0x2, 0x648, 0x647, 0x3, 0x2, 0x2, 
       0x2, 0x649, 0x59, 0x3, 0x2, 0x2, 0x2, 0x64a, 0x64b, 0x9, 0x7, 0x2, 
       0x2, 0x64b, 0x5b, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x65a, 0x5, 0x412, 0x20a, 
       0x2, 0x64d, 0x65a, 0x5, 0x420, 0x211, 0x2, 0x64e, 0x650, 0x5, 0x35c, 
       0x1af, 0x2, 0x64f, 0x651, 0x5, 0x5e, 0x30, 0x2, 0x650, 0x64f, 0x3, 
       0x2, 0x2, 0x2, 0x650, 0x651, 0x3, 0x2, 0x2, 0x2, 0x651, 0x652, 0x3, 
       0x2, 0x2, 0x2, 0x652, 0x654, 0x5, 0x412, 0x20a, 0x2, 0x653, 0x655, 
       0x5, 0x360, 0x1b1, 0x2, 0x654, 0x653, 0x3, 0x2, 0x2, 0x2, 0x654, 
       0x655, 0x3, 0x2, 0x2, 0x2, 0x655, 0x65a, 0x3, 0x2, 0x2, 0x2, 0x656, 
       0x65a, 0x5, 0x15e, 0xb0, 0x2, 0x657, 0x65a, 0x7, 0x65, 0x2, 0x2, 
       0x658, 0x65a, 0x7, 0xde, 0x2, 0x2, 0x659, 0x64c, 0x3, 0x2, 0x2, 0x2, 
       0x659, 0x64d, 0x3, 0x2, 0x2, 0x2, 0x659, 0x64e, 0x3, 0x2, 0x2, 0x2, 
       0x659, 0x656, 0x3, 0x2, 0x2, 0x2, 0x659, 0x657, 0x3, 0x2, 0x2, 0x2, 
       0x659, 0x658, 0x3, 0x2, 0x2, 0x2, 0x65a, 0x5d, 0x3, 0x2, 0x2, 0x2, 
       0x65b, 0x65c, 0x7, 0x1d9, 0x2, 0x2, 0x65c, 0x65d, 0x5, 0x410, 0x209, 
       0x2, 0x65d, 0x65e, 0x7, 0x1da, 0x2, 0x2, 0x65e, 0x5f, 0x3, 0x2, 0x2, 
       0x2, 0x65f, 0x662, 0x5, 0x412, 0x20a, 0x2, 0x660, 0x662, 0x7, 0x65, 
       0x2, 0x2, 0x661, 0x65f, 0x3, 0x2, 0x2, 0x2, 0x661, 0x660, 0x3, 0x2, 
       0x2, 0x2, 0x662, 0x61, 0x3, 0x2, 0x2, 0x2, 0x663, 0x666, 0x5, 0x41a, 
       0x20e, 0x2, 0x664, 0x666, 0x5, 0x412, 0x20a, 0x2, 0x665, 0x663, 0x3, 
       0x2, 0x2, 0x2, 0x665, 0x664, 0x3, 0x2, 0x2, 0x2, 0x666, 0x63, 0x3, 
       0x2, 0x2, 0x2, 0x667, 0x668, 0x7, 0x158, 0x2, 0x2, 0x668, 0x676, 
       0x5, 0x52, 0x2a, 0x2, 0x669, 0x66a, 0x7, 0x158, 0x2, 0x2, 0x66a, 
       0x66b, 0x7, 0x199, 0x2, 0x2, 0x66b, 0x676, 0x7, 0x1d6, 0x2, 0x2, 
       0x66c, 0x66d, 0x7, 0x158, 0x2, 0x2, 0x66d, 0x66e, 0x7, 0x19d, 0x2, 
       0x2, 0x66e, 0x66f, 0x7, 0xcf, 0x2, 0x2, 0x66f, 0x676, 0x7, 0xd8, 
       0x2, 0x2, 0x670, 0x671, 0x7, 0x158, 0x2, 0x2, 0x671, 0x672, 0x7, 
       0x172, 0x2, 0x2, 0x672, 0x676, 0x7, 0x1b, 0x2, 0x2, 0x673, 0x674, 
       0x7, 0x158, 0x2, 0x2, 0x674, 0x676, 0x7, 0xc, 0x2, 0x2, 0x675, 0x667, 
       0x3, 0x2, 0x2, 0x2, 0x675, 0x669, 0x3, 0x2, 0x2, 0x2, 0x675, 0x66c, 
       0x3, 0x2, 0x2, 0x2, 0x675, 0x670, 0x3, 0x2, 0x2, 0x2, 0x675, 0x673, 
       0x3, 0x2, 0x2, 0x2, 0x676, 0x65, 0x3, 0x2, 0x2, 0x2, 0x677, 0x678, 
       0x7, 0x174, 0x2, 0x2, 0x678, 0x67b, 0x5, 0x50, 0x29, 0x2, 0x679, 
       0x67b, 0x5, 0x64, 0x33, 0x2, 0x67a, 0x677, 0x3, 0x2, 0x2, 0x2, 0x67a, 
       0x679, 0x3, 0x2, 0x2, 0x2, 0x67b, 0x67, 0x3, 0x2, 0x2, 0x2, 0x67c, 
       0x67d, 0x7, 0x178, 0x2, 0x2, 0x67d, 0x68b, 0x5, 0x52, 0x2a, 0x2, 
       0x67e, 0x67f, 0x7, 0x178, 0x2, 0x2, 0x67f, 0x680, 0x7, 0x199, 0x2, 
       0x2, 0x680, 0x68b, 0x7, 0x1d6, 0x2, 0x2, 0x681, 0x682, 0x7, 0x178, 
       0x2, 0x2, 0x682, 0x683, 0x7, 0x19d, 0x2, 0x2, 0x683, 0x684, 0x7, 
       0xcf, 0x2, 0x2, 0x684, 0x68b, 0x7, 0xd8, 0x2, 0x2, 0x685, 0x686, 
       0x7, 0x178, 0x2, 0x2, 0x686, 0x687, 0x7, 0x172, 0x2, 0x2, 0x687, 
       0x68b, 0x7, 0x1b, 0x2, 0x2, 0x688, 0x689, 0x7, 0x178, 0x2, 0x2, 0x689, 
       0x68b, 0x7, 0xc, 0x2, 0x2, 0x68a, 0x67c, 0x3, 0x2, 0x2, 0x2, 0x68a, 
       0x67e, 0x3, 0x2, 0x2, 0x2, 0x68a, 0x681, 0x3, 0x2, 0x2, 0x2, 0x68a, 
       0x685, 0x3, 0x2, 0x2, 0x2, 0x68a, 0x688, 0x3, 0x2, 0x2, 0x2, 0x68b, 
       0x69, 0x3, 0x2, 0x2, 0x2, 0x68c, 0x68d, 0x7, 0x174, 0x2, 0x2, 0x68d, 
       0x68e, 0x7, 0x42, 0x2, 0x2, 0x68e, 0x68f, 0x5, 0x6c, 0x37, 0x2, 0x68f, 
       0x690, 0x5, 0x6e, 0x38, 0x2, 0x690, 0x6b, 0x3, 0x2, 0x2, 0x2, 0x691, 
       0x694, 0x7, 0xc, 0x2, 0x2, 0x692, 0x694, 0x5, 0x3f8, 0x1fd, 0x2, 
       0x693, 0x691, 0x3, 0x2, 0x2, 0x2, 0x693, 0x692, 0x3, 0x2, 0x2, 0x2, 
       0x694, 0x6d, 0x3, 0x2, 0x2, 0x2, 0x695, 0x696, 0x9, 0x8, 0x2, 0x2, 
       0x696, 0x6f, 0x3, 0x2, 0x2, 0x2, 0x697, 0x698, 0x7, 0x31, 0x2, 0x2, 
       0x698, 0x71, 0x3, 0x2, 0x2, 0x2, 0x699, 0x69a, 0x7, 0x71, 0x2, 0x2, 
       0x69a, 0x69b, 0x9, 0x9, 0x2, 0x2, 0x69b, 0x73, 0x3, 0x2, 0x2, 0x2, 
       0x69c, 0x69e, 0x7, 0xe, 0x2, 0x2, 0x69d, 0x69f, 0x7, 0x8d, 0x2, 0x2, 
       0x69e, 0x69d, 0x3, 0x2, 0x2, 0x2, 0x69e, 0x69f, 0x3, 0x2, 0x2, 0x2, 
       0x69f, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x6a0, 0x6a1, 0x7, 0x190, 0x2, 
       0x2, 0x6a1, 0x6a2, 0x5, 0x32c, 0x197, 0x2, 0x6a2, 0x6a3, 0x5, 0x76, 
       0x3c, 0x2, 0x6a3, 0x6aa, 0x3, 0x2, 0x2, 0x2, 0x6a4, 0x6a5, 0x7, 0xe, 
       0x2, 0x2, 0x6a5, 0x6a6, 0x7, 0xba, 0x2, 0x2, 0x6a6, 0x6a7, 0x5, 0x32c, 
       0x197, 0x2, 0x6a7, 0x6a8, 0x5, 0x88, 0x45, 0x2, 0x6a8, 0x6aa, 0x3, 
       0x2, 0x2, 0x2, 0x6a9, 0x69c, 0x3, 0x2, 0x2, 0x2, 0x6a9, 0x6a4, 0x3, 
       0x2, 0x2, 0x2, 0x6aa, 0x75, 0x3, 0x2, 0x2, 0x2, 0x6ab, 0x6b0, 0x5, 
       0x78, 0x3d, 0x2, 0x6ac, 0x6ad, 0x7, 0x1df, 0x2, 0x2, 0x6ad, 0x6af, 
       0x5, 0x78, 0x3d, 0x2, 0x6ae, 0x6ac, 0x3, 0x2, 0x2, 0x2, 0x6af, 0x6b2, 
       0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6ae, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b1, 
       0x3, 0x2, 0x2, 0x2, 0x6b1, 0x77, 0x3, 0x2, 0x2, 0x2, 0x6b2, 0x6b0, 
       0x3, 0x2, 0x2, 0x2, 0x6b3, 0x6b5, 0x7, 0x8, 0x2, 0x2, 0x6b4, 0x6b6, 
       0x5, 0x260, 0x131, 0x2, 0x6b5, 0x6b4, 0x3, 0x2, 0x2, 0x2, 0x6b5, 
       0x6b6, 0x3, 0x2, 0x2, 0x2, 0x6b6, 0x6b7, 0x3, 0x2, 0x2, 0x2, 0x6b7, 
       0x72e, 0x5, 0xac, 0x57, 0x2, 0x6b8, 0x6ba, 0x7, 0xe, 0x2, 0x2, 0x6b9, 
       0x6bb, 0x5, 0x260, 0x131, 0x2, 0x6ba, 0x6b9, 0x3, 0x2, 0x2, 0x2, 
       0x6ba, 0x6bb, 0x3, 0x2, 0x2, 0x2, 0x6bb, 0x6bc, 0x3, 0x2, 0x2, 0x2, 
       0x6bc, 0x6bd, 0x5, 0x41a, 0x20e, 0x2, 0x6bd, 0x6be, 0x5, 0x8c, 0x47, 
       0x2, 0x6be, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x6bf, 0x6c1, 0x7, 0xe, 0x2, 
       0x2, 0x6c0, 0x6c2, 0x5, 0x260, 0x131, 0x2, 0x6c1, 0x6c0, 0x3, 0x2, 
       0x2, 0x2, 0x6c1, 0x6c2, 0x3, 0x2, 0x2, 0x2, 0x6c2, 0x6c3, 0x3, 0x2, 
       0x2, 0x2, 0x6c3, 0x6c4, 0x5, 0x41a, 0x20e, 0x2, 0x6c4, 0x6c5, 0x7, 
       0x78, 0x2, 0x2, 0x6c5, 0x6c6, 0x7, 0x108, 0x2, 0x2, 0x6c6, 0x6c7, 
       0x7, 0x10e, 0x2, 0x2, 0x6c7, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x6c8, 0x6ca, 
       0x7, 0xe, 0x2, 0x2, 0x6c9, 0x6cb, 0x5, 0x260, 0x131, 0x2, 0x6ca, 
       0x6c9, 0x3, 0x2, 0x2, 0x2, 0x6ca, 0x6cb, 0x3, 0x2, 0x2, 0x2, 0x6cb, 
       0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6cc, 0x6cd, 0x5, 0x41a, 0x20e, 0x2, 
       0x6cd, 0x6ce, 0x7, 0x174, 0x2, 0x2, 0x6ce, 0x6cf, 0x7, 0x108, 0x2, 
       0x2, 0x6cf, 0x6d0, 0x7, 0x10e, 0x2, 0x2, 0x6d0, 0x72e, 0x3, 0x2, 
       0x2, 0x2, 0x6d1, 0x6d3, 0x7, 0xe, 0x2, 0x2, 0x6d2, 0x6d4, 0x5, 0x260, 
       0x131, 0x2, 0x6d3, 0x6d2, 0x3, 0x2, 0x2, 0x2, 0x6d3, 0x6d4, 0x3, 
       0x2, 0x2, 0x2, 0x6d4, 0x6d5, 0x3, 0x2, 0x2, 0x2, 0x6d5, 0x6d6, 0x5, 
       0x41a, 0x20e, 0x2, 0x6d6, 0x6d7, 0x7, 0x174, 0x2, 0x2, 0x6d7, 0x6d8, 
       0x7, 0x183, 0x2, 0x2, 0x6d8, 0x6d9, 0x5, 0x162, 0xb2, 0x2, 0x6d9, 
       0x72e, 0x3, 0x2, 0x2, 0x2, 0x6da, 0x6dc, 0x7, 0xe, 0x2, 0x2, 0x6db, 
       0x6dd, 0x5, 0x260, 0x131, 0x2, 0x6dc, 0x6db, 0x3, 0x2, 0x2, 0x2, 
       0x6dc, 0x6dd, 0x3, 0x2, 0x2, 0x2, 0x6dd, 0x6de, 0x3, 0x2, 0x2, 0x2, 
       0x6de, 0x6df, 0x5, 0x41a, 0x20e, 0x2, 0x6df, 0x6e0, 0x7, 0x174, 0x2, 
       0x2, 0x6e0, 0x6e1, 0x7, 0x186, 0x2, 0x2, 0x6e1, 0x6e2, 0x5, 0x41a, 
       0x20e, 0x2, 0x6e2, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x6e3, 0x6e5, 0x7, 
       0x78, 0x2, 0x2, 0x6e4, 0x6e6, 0x5, 0x260, 0x131, 0x2, 0x6e5, 0x6e4, 
       0x3, 0x2, 0x2, 0x2, 0x6e5, 0x6e6, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x6e7, 
       0x3, 0x2, 0x2, 0x2, 0x6e7, 0x6e9, 0x5, 0x41a, 0x20e, 0x2, 0x6e8, 
       0x6ea, 0x5, 0x8e, 0x48, 0x2, 0x6e9, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6e9, 
       0x6ea, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x6eb, 
       0x6ed, 0x7, 0xe, 0x2, 0x2, 0x6ec, 0x6ee, 0x5, 0x260, 0x131, 0x2, 
       0x6ed, 0x6ec, 0x3, 0x2, 0x2, 0x2, 0x6ed, 0x6ee, 0x3, 0x2, 0x2, 0x2, 
       0x6ee, 0x6ef, 0x3, 0x2, 0x2, 0x2, 0x6ef, 0x6f0, 0x5, 0x41a, 0x20e, 
       0x2, 0x6f0, 0x6f1, 0x7, 0x1a4, 0x2, 0x2, 0x6f1, 0x6f3, 0x5, 0x33a, 
       0x19e, 0x2, 0x6f2, 0x6f4, 0x5, 0x90, 0x49, 0x2, 0x6f3, 0x6f2, 0x3, 
       0x2, 0x2, 0x2, 0x6f3, 0x6f4, 0x3, 0x2, 0x2, 0x2, 0x6f4, 0x72e, 0x3, 
       0x2, 0x2, 0x2, 0x6f5, 0x6f6, 0x7, 0x8, 0x2, 0x2, 0x6f6, 0x72e, 0x5, 
       0xba, 0x5e, 0x2, 0x6f7, 0x6f8, 0x7, 0x78, 0x2, 0x2, 0x6f8, 0x6f9, 
       0x7, 0x41, 0x2, 0x2, 0x6f9, 0x6fb, 0x5, 0x3fe, 0x200, 0x2, 0x6fa, 
       0x6fc, 0x5, 0x8e, 0x48, 0x2, 0x6fb, 0x6fa, 0x3, 0x2, 0x2, 0x2, 0x6fb, 
       0x6fc, 0x3, 0x2, 0x2, 0x2, 0x6fc, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x6fd, 
       0x6fe, 0x7, 0x174, 0x2, 0x2, 0x6fe, 0x6ff, 0x7, 0x1c6, 0x2, 0x2, 
       0x6ff, 0x72e, 0x7, 0x117, 0x2, 0x2, 0x700, 0x701, 0x7, 0x34, 0x2, 
       0x2, 0x701, 0x702, 0x7, 0x119, 0x2, 0x2, 0x702, 0x72e, 0x5, 0x3fe, 
       0x200, 0x2, 0x703, 0x704, 0x7, 0x174, 0x2, 0x2, 0x704, 0x705, 0x7, 
       0x1c6, 0x2, 0x2, 0x705, 0x72e, 0x7, 0x34, 0x2, 0x2, 0x706, 0x708, 
       0x7, 0x7c, 0x2, 0x2, 0x707, 0x709, 0x9, 0xa, 0x2, 0x2, 0x708, 0x707, 
       0x3, 0x2, 0x2, 0x2, 0x708, 0x709, 0x3, 0x2, 0x2, 0x2, 0x709, 0x70a, 
       0x3, 0x2, 0x2, 0x2, 0x70a, 0x70b, 0x7, 0x19f, 0x2, 0x2, 0x70b, 0x72e, 
       0x5, 0x3fe, 0x200, 0x2, 0x70c, 0x70d, 0x7, 0x7c, 0x2, 0x2, 0x70d, 
       0x70e, 0x7, 0x19f, 0x2, 0x2, 0x70e, 0x72e, 0x9, 0xb, 0x2, 0x2, 0x70f, 
       0x710, 0x7, 0x70, 0x2, 0x2, 0x710, 0x714, 0x7, 0x19f, 0x2, 0x2, 0x711, 
       0x715, 0x5, 0x3fe, 0x200, 0x2, 0x712, 0x715, 0x7, 0xc, 0x2, 0x2, 
       0x713, 0x715, 0x7, 0x1b0, 0x2, 0x2, 0x714, 0x711, 0x3, 0x2, 0x2, 
       0x2, 0x714, 0x712, 0x3, 0x2, 0x2, 0x2, 0x714, 0x713, 0x3, 0x2, 0x2, 
       0x2, 0x715, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x716, 0x718, 0x7, 0x7c, 0x2, 
       0x2, 0x717, 0x719, 0x9, 0xa, 0x2, 0x2, 0x718, 0x717, 0x3, 0x2, 0x2, 
       0x2, 0x718, 0x719, 0x3, 0x2, 0x2, 0x2, 0x719, 0x71a, 0x3, 0x2, 0x2, 
       0x2, 0x71a, 0x71b, 0x7, 0x166, 0x2, 0x2, 0x71b, 0x72e, 0x5, 0x3fe, 
       0x200, 0x2, 0x71c, 0x71d, 0x7, 0x70, 0x2, 0x2, 0x71d, 0x71e, 0x7, 
       0x166, 0x2, 0x2, 0x71e, 0x72e, 0x5, 0x3fe, 0x200, 0x2, 0x71f, 0x721, 
       0x7, 0xfe, 0x2, 0x2, 0x720, 0x71f, 0x3, 0x2, 0x2, 0x2, 0x720, 0x721, 
       0x3, 0x2, 0x2, 0x2, 0x721, 0x722, 0x3, 0x2, 0x2, 0x2, 0x722, 0x723, 
       0x7, 0xbc, 0x2, 0x2, 0x723, 0x72e, 0x5, 0x3fa, 0x1fe, 0x2, 0x724, 
       0x726, 0x7, 0x174, 0x2, 0x2, 0x725, 0x727, 0x5, 0xe, 0x8, 0x2, 0x726, 
       0x725, 0x3, 0x2, 0x2, 0x2, 0x726, 0x727, 0x3, 0x2, 0x2, 0x2, 0x727, 
       0x728, 0x3, 0x2, 0x2, 0x2, 0x728, 0x72e, 0x5, 0xda, 0x6e, 0x2, 0x729, 
       0x72a, 0x7, 0x174, 0x2, 0x2, 0x72a, 0x72e, 0x5, 0xe, 0x8, 0x2, 0x72b, 
       0x72e, 0x5, 0x86, 0x44, 0x2, 0x72c, 0x72e, 0x5, 0x8a, 0x46, 0x2, 
       0x72d, 0x6b3, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x6b8, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x6bf, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x6c8, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x6d1, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x6da, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x6e3, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x6eb, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x6f5, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x6f7, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x6fd, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x700, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x703, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x706, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x70c, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x70f, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x716, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x71c, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x720, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x724, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x729, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x72b, 0x3, 0x2, 0x2, 0x2, 
       0x72d, 0x72c, 0x3, 0x2, 0x2, 0x2, 0x72e, 0x79, 0x3, 0x2, 0x2, 0x2, 
       0x72f, 0x730, 0x7, 0xca, 0x2, 0x2, 0x730, 0x731, 0x7, 0x1d9, 0x2, 
       0x2, 0x731, 0x732, 0x5, 0x84, 0x43, 0x2, 0x732, 0x733, 0x7, 0x1df, 
       0x2, 0x2, 0x733, 0x734, 0x5, 0x84, 0x43, 0x2, 0x734, 0x735, 0x7, 
       0x1da, 0x2, 0x2, 0x735, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x736, 0x737, 0x7, 
       0xca, 0x2, 0x2, 0x737, 0x738, 0x5, 0x84, 0x43, 0x2, 0x738, 0x7d, 
       0x3, 0x2, 0x2, 0x2, 0x739, 0x73b, 0x5, 0xf2, 0x7a, 0x2, 0x73a, 0x73c, 
       0x5, 0xf4, 0x7b, 0x2, 0x73b, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73b, 0x73c, 
       0x3, 0x2, 0x2, 0x2, 0x73c, 0x73e, 0x3, 0x2, 0x2, 0x2, 0x73d, 0x73f, 
       0x5, 0xf6, 0x7c, 0x2, 0x73e, 0x73d, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x73f, 
       0x3, 0x2, 0x2, 0x2, 0x73f, 0x748, 0x3, 0x2, 0x2, 0x2, 0x740, 0x742, 
       0x5, 0xf4, 0x7b, 0x2, 0x741, 0x743, 0x5, 0xf6, 0x7c, 0x2, 0x742, 
       0x741, 0x3, 0x2, 0x2, 0x2, 0x742, 0x743, 0x3, 0x2, 0x2, 0x2, 0x743, 
       0x748, 0x3, 0x2, 0x2, 0x2, 0x744, 0x745, 0x5, 0x44, 0x23, 0x2, 0x745, 
       0x746, 0x5, 0x100, 0x81, 0x2, 0x746, 0x748, 0x3, 0x2, 0x2, 0x2, 0x747, 
       0x739, 0x3, 0x2, 0x2, 0x2, 0x747, 0x740, 0x3, 0x2, 0x2, 0x2, 0x747, 
       0x744, 0x3, 0x2, 0x2, 0x2, 0x748, 0x7f, 0x3, 0x2, 0x2, 0x2, 0x749, 
       0x74a, 0x9, 0x2, 0x2, 0x2, 0x74a, 0x74b, 0x7, 0x1b4, 0x2, 0x2, 0x74b, 
       0x81, 0x3, 0x2, 0x2, 0x2, 0x74c, 0x759, 0x5, 0x426, 0x214, 0x2, 0x74d, 
       0x74e, 0x7, 0x99, 0x2, 0x2, 0x74e, 0x74f, 0x7, 0x1d9, 0x2, 0x2, 0x74f, 
       0x750, 0x5, 0xee, 0x78, 0x2, 0x750, 0x751, 0x7, 0x1da, 0x2, 0x2, 
       0x751, 0x759, 0x3, 0x2, 0x2, 0x2, 0x752, 0x753, 0x7, 0x99, 0x2, 0x2, 
       0x753, 0x754, 0x7, 0x1d9, 0x2, 0x2, 0x754, 0x755, 0x5, 0x40c, 0x207, 
       0x2, 0x755, 0x756, 0x5, 0x3b8, 0x1dd, 0x2, 0x756, 0x757, 0x7, 0x1da, 
       0x2, 0x2, 0x757, 0x759, 0x3, 0x2, 0x2, 0x2, 0x758, 0x74c, 0x3, 0x2, 
       0x2, 0x2, 0x758, 0x74d, 0x3, 0x2, 0x2, 0x2, 0x758, 0x752, 0x3, 0x2, 
       0x2, 0x2, 0x759, 0x83, 0x3, 0x2, 0x2, 0x2, 0x75a, 0x75b, 0x7, 0x12c, 
       0x2, 0x2, 0x75b, 0x762, 0x5, 0x82, 0x42, 0x2, 0x75c, 0x75d, 0x7, 
       0x65, 0x2, 0x2, 0x75d, 0x75e, 0x7, 0x12c, 0x2, 0x2, 0x75e, 0x762, 
       0x5, 0x82, 0x42, 0x2, 0x75f, 0x760, 0x7, 0x65, 0x2, 0x2, 0x760, 0x762, 
       0x7, 0x12c, 0x2, 0x2, 0x761, 0x75a, 0x3, 0x2, 0x2, 0x2, 0x761, 0x75c, 
       0x3, 0x2, 0x2, 0x2, 0x761, 0x75f, 0x3, 0x2, 0x2, 0x2, 0x762, 0x85, 
       0x3, 0x2, 0x2, 0x2, 0x763, 0x764, 0x7, 0x8, 0x2, 0x2, 0x764, 0x766, 
       0x7, 0x12c, 0x2, 0x2, 0x765, 0x767, 0x5, 0xf8, 0x7d, 0x2, 0x766, 
       0x765, 0x3, 0x2, 0x2, 0x2, 0x766, 0x767, 0x3, 0x2, 0x2, 0x2, 0x767, 
       0x769, 0x3, 0x2, 0x2, 0x2, 0x768, 0x76a, 0x5, 0xe0, 0x71, 0x2, 0x769, 
       0x768, 0x3, 0x2, 0x2, 0x2, 0x769, 0x76a, 0x3, 0x2, 0x2, 0x2, 0x76a, 
       0x76c, 0x3, 0x2, 0x2, 0x2, 0x76b, 0x76d, 0x5, 0xe4, 0x73, 0x2, 0x76c, 
       0x76b, 0x3, 0x2, 0x2, 0x2, 0x76c, 0x76d, 0x3, 0x2, 0x2, 0x2, 0x76d, 
       0x7e2, 0x3, 0x2, 0x2, 0x2, 0x76e, 0x76f, 0x7, 0x8, 0x2, 0x2, 0x76f, 
       0x770, 0x7, 0x65, 0x2, 0x2, 0x770, 0x771, 0x7, 0x12c, 0x2, 0x2, 0x771, 
       0x773, 0x5, 0x82, 0x42, 0x2, 0x772, 0x774, 0x5, 0xf8, 0x7d, 0x2, 
       0x773, 0x772, 0x3, 0x2, 0x2, 0x2, 0x773, 0x774, 0x3, 0x2, 0x2, 0x2, 
       0x774, 0x776, 0x3, 0x2, 0x2, 0x2, 0x775, 0x777, 0x5, 0xe0, 0x71, 
       0x2, 0x776, 0x775, 0x3, 0x2, 0x2, 0x2, 0x776, 0x777, 0x3, 0x2, 0x2, 
       0x2, 0x777, 0x779, 0x3, 0x2, 0x2, 0x2, 0x778, 0x77a, 0x5, 0xe4, 0x73, 
       0x2, 0x779, 0x778, 0x3, 0x2, 0x2, 0x2, 0x779, 0x77a, 0x3, 0x2, 0x2, 
       0x2, 0x77a, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x77b, 0x77c, 0x7, 0x8, 0x2, 
       0x2, 0x77c, 0x77d, 0x7, 0x12c, 0x2, 0x2, 0x77d, 0x77f, 0x5, 0x82, 
       0x42, 0x2, 0x77e, 0x780, 0x5, 0xf8, 0x7d, 0x2, 0x77f, 0x77e, 0x3, 
       0x2, 0x2, 0x2, 0x77f, 0x780, 0x3, 0x2, 0x2, 0x2, 0x780, 0x782, 0x3, 
       0x2, 0x2, 0x2, 0x781, 0x783, 0x5, 0xe0, 0x71, 0x2, 0x782, 0x781, 
       0x3, 0x2, 0x2, 0x2, 0x782, 0x783, 0x3, 0x2, 0x2, 0x2, 0x783, 0x785, 
       0x3, 0x2, 0x2, 0x2, 0x784, 0x786, 0x5, 0xe4, 0x73, 0x2, 0x785, 0x784, 
       0x3, 0x2, 0x2, 0x2, 0x785, 0x786, 0x3, 0x2, 0x2, 0x2, 0x786, 0x7e2, 
       0x3, 0x2, 0x2, 0x2, 0x787, 0x788, 0x7, 0xe, 0x2, 0x2, 0x788, 0x789, 
       0x5, 0x84, 0x43, 0x2, 0x789, 0x78a, 0x5, 0x78, 0x3d, 0x2, 0x78a, 
       0x7e2, 0x3, 0x2, 0x2, 0x2, 0x78b, 0x78c, 0x7, 0x35, 0x2, 0x2, 0x78c, 
       0x7e2, 0x7, 0x12c, 0x2, 0x2, 0x78d, 0x78e, 0x7, 0x35, 0x2, 0x2, 0x78e, 
       0x78f, 0x7, 0x12c, 0x2, 0x2, 0x78f, 0x7e2, 0x5, 0x82, 0x42, 0x2, 
       0x790, 0x791, 0x7, 0x78, 0x2, 0x2, 0x791, 0x792, 0x7, 0x12c, 0x2, 
       0x2, 0x792, 0x793, 0x7, 0xb1, 0x2, 0x2, 0x793, 0x794, 0x7, 0x8a, 
       0x2, 0x2, 0x794, 0x796, 0x5, 0x82, 0x42, 0x2, 0x795, 0x797, 0x5, 
       0x8e, 0x48, 0x2, 0x796, 0x795, 0x3, 0x2, 0x2, 0x2, 0x796, 0x797, 
       0x3, 0x2, 0x2, 0x2, 0x797, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x798, 0x799, 
       0x7, 0x78, 0x2, 0x2, 0x799, 0x79a, 0x7, 0x65, 0x2, 0x2, 0x79a, 0x79b, 
       0x7, 0x12c, 0x2, 0x2, 0x79b, 0x79c, 0x7, 0xb1, 0x2, 0x2, 0x79c, 0x79e, 
       0x7, 0x8a, 0x2, 0x2, 0x79d, 0x79f, 0x5, 0x8e, 0x48, 0x2, 0x79e, 0x79d, 
       0x3, 0x2, 0x2, 0x2, 0x79e, 0x79f, 0x3, 0x2, 0x2, 0x2, 0x79f, 0x7e2, 
       0x3, 0x2, 0x2, 0x2, 0x7a0, 0x7a1, 0x7, 0x78, 0x2, 0x2, 0x7a1, 0x7a3, 
       0x5, 0x84, 0x43, 0x2, 0x7a2, 0x7a4, 0x5, 0x8e, 0x48, 0x2, 0x7a3, 
       0x7a2, 0x3, 0x2, 0x2, 0x2, 0x7a3, 0x7a4, 0x3, 0x2, 0x2, 0x2, 0x7a4, 
       0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7a5, 0x7a6, 0x7, 0x78, 0x2, 0x2, 0x7a6, 
       0x7e2, 0x7, 0x12c, 0x2, 0x2, 0x7a7, 0x7a8, 0x7, 0x85, 0x2, 0x2, 0x7a8, 
       0x7a9, 0x5, 0x84, 0x43, 0x2, 0x7a9, 0x7aa, 0x7, 0x1c4, 0x2, 0x2, 
       0x7aa, 0x7ab, 0x7, 0x190, 0x2, 0x2, 0x7ab, 0x7ad, 0x5, 0x3fa, 0x1fe, 
       0x2, 0x7ac, 0x7ae, 0x5, 0x80, 0x41, 0x2, 0x7ad, 0x7ac, 0x3, 0x2, 
       0x2, 0x2, 0x7ad, 0x7ae, 0x3, 0x2, 0x2, 0x2, 0x7ae, 0x7e2, 0x3, 0x2, 
       0x2, 0x2, 0x7af, 0x7b0, 0x7, 0xed, 0x2, 0x2, 0x7b0, 0x7b1, 0x5, 0x84, 
       0x43, 0x2, 0x7b1, 0x7b2, 0x7, 0x1df, 0x2, 0x2, 0x7b2, 0x7b4, 0x5, 
       0x84, 0x43, 0x2, 0x7b3, 0x7b5, 0x5, 0x7c, 0x3f, 0x2, 0x7b4, 0x7b3, 
       0x3, 0x2, 0x2, 0x2, 0x7b4, 0x7b5, 0x3, 0x2, 0x2, 0x2, 0x7b5, 0x7e2, 
       0x3, 0x2, 0x2, 0x2, 0x7b6, 0x7b7, 0x7, 0xf3, 0x2, 0x2, 0x7b7, 0x7b8, 
       0x5, 0x84, 0x43, 0x2, 0x7b8, 0x7b9, 0x5, 0x7e, 0x40, 0x2, 0x7b9, 
       0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7ba, 0x7bb, 0x7, 0x154, 0x2, 0x2, 0x7bb, 
       0x7bc, 0x5, 0x84, 0x43, 0x2, 0x7bc, 0x7bd, 0x7, 0x19b, 0x2, 0x2, 
       0x7bd, 0x7be, 0x5, 0x420, 0x211, 0x2, 0x7be, 0x7e2, 0x3, 0x2, 0x2, 
       0x2, 0x7bf, 0x7c0, 0x7, 0x174, 0x2, 0x2, 0x7c0, 0x7c1, 0x7, 0x189, 
       0x2, 0x2, 0x7c1, 0x7c2, 0x7, 0x193, 0x2, 0x2, 0x7c2, 0x7c3, 0x7, 
       0x1d9, 0x2, 0x2, 0x7c3, 0x7c4, 0x5, 0xe8, 0x75, 0x2, 0x7c4, 0x7c5, 
       0x7, 0x1da, 0x2, 0x2, 0x7c5, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7c6, 0x7c7, 
       0x7, 0x174, 0x2, 0x2, 0x7c7, 0x7c8, 0x7, 0x189, 0x2, 0x2, 0x7c8, 
       0x7c9, 0x7, 0x193, 0x2, 0x2, 0x7c9, 0x7ca, 0x7, 0x1d9, 0x2, 0x2, 
       0x7ca, 0x7e2, 0x7, 0x1da, 0x2, 0x2, 0x7cb, 0x7cc, 0x7, 0x17d, 0x2, 
       0x2, 0x7cc, 0x7cd, 0x7, 0x65, 0x2, 0x2, 0x7cd, 0x7ce, 0x7, 0x12c, 
       0x2, 0x2, 0x7ce, 0x7cf, 0x5, 0xf2, 0x7a, 0x2, 0x7cf, 0x7d1, 0x5, 
       0xf4, 0x7b, 0x2, 0x7d0, 0x7d2, 0x5, 0x7a, 0x3e, 0x2, 0x7d1, 0x7d0, 
       0x3, 0x2, 0x2, 0x2, 0x7d1, 0x7d2, 0x3, 0x2, 0x2, 0x2, 0x7d2, 0x7e2, 
       0x3, 0x2, 0x2, 0x2, 0x7d3, 0x7d4, 0x7, 0x17d, 0x2, 0x2, 0x7d4, 0x7d5, 
       0x5, 0x84, 0x43, 0x2, 0x7d5, 0x7d6, 0x7, 0x1a, 0x2, 0x2, 0x7d6, 0x7d7, 
       0x7, 0x1d9, 0x2, 0x2, 0x7d7, 0x7d8, 0x5, 0x102, 0x82, 0x2, 0x7d8, 
       0x7da, 0x7, 0x1da, 0x2, 0x2, 0x7d9, 0x7db, 0x5, 0x7a, 0x3e, 0x2, 
       0x7da, 0x7d9, 0x3, 0x2, 0x2, 0x2, 0x7da, 0x7db, 0x3, 0x2, 0x2, 0x2, 
       0x7db, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7dc, 0x7dd, 0x7, 0x1a2, 0x2, 
       0x2, 0x7dd, 0x7df, 0x5, 0x84, 0x43, 0x2, 0x7de, 0x7e0, 0x5, 0x8e, 
       0x48, 0x2, 0x7df, 0x7de, 0x3, 0x2, 0x2, 0x2, 0x7df, 0x7e0, 0x3, 0x2, 
       0x2, 0x2, 0x7e0, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x763, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x76e, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x77b, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x787, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x78b, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x78d, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x790, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x798, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7a0, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x7a5, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7a7, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x7af, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7b6, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x7ba, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7bf, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x7c6, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7cb, 0x3, 0x2, 
       0x2, 0x2, 0x7e1, 0x7d3, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7dc, 0x3, 0x2, 
       0x2, 0x2, 0x7e2, 0x87, 0x3, 0x2, 0x2, 0x2, 0x7e3, 0x7e8, 0x5, 0x8a, 
       0x46, 0x2, 0x7e4, 0x7e5, 0x7, 0x1df, 0x2, 0x2, 0x7e5, 0x7e7, 0x5, 
       0x8a, 0x46, 0x2, 0x7e6, 0x7e4, 0x3, 0x2, 0x2, 0x2, 0x7e7, 0x7ea, 
       0x3, 0x2, 0x2, 0x2, 0x7e8, 0x7e6, 0x3, 0x2, 0x2, 0x2, 0x7e8, 0x7e9, 
       0x3, 0x2, 0x2, 0x2, 0x7e9, 0x89, 0x3, 0x2, 0x2, 0x2, 0x7ea, 0x7e8, 
       0x3, 0x2, 0x2, 0x2, 0x7eb, 0x7ec, 0x7, 0x129, 0x2, 0x2, 0x7ec, 0x7ed, 
       0x7, 0x19b, 0x2, 0x2, 0x7ed, 0x7f4, 0x5, 0x414, 0x20b, 0x2, 0x7ee, 
       0x7ef, 0x7, 0x174, 0x2, 0x2, 0x7ef, 0x7f0, 0x7, 0x191, 0x2, 0x2, 
       0x7f0, 0x7f4, 0x5, 0x3fe, 0x200, 0x2, 0x7f1, 0x7f2, 0x9, 0xc, 0x2, 
       0x2, 0x7f2, 0x7f4, 0x5, 0x1ac, 0xd7, 0x2, 0x7f3, 0x7eb, 0x3, 0x2, 
       0x2, 0x2, 0x7f3, 0x7ee, 0x3, 0x2, 0x2, 0x2, 0x7f3, 0x7f1, 0x3, 0x2, 
       0x2, 0x2, 0x7f4, 0x8b, 0x3, 0x2, 0x2, 0x2, 0x7f5, 0x7f6, 0x7, 0x174, 
       0x2, 0x2, 0x7f6, 0x7f7, 0x7, 0x65, 0x2, 0x2, 0x7f7, 0x7fb, 0x5, 0x362, 
       0x1b2, 0x2, 0x7f8, 0x7f9, 0x7, 0x78, 0x2, 0x2, 0x7f9, 0x7fb, 0x7, 
       0x65, 0x2, 0x2, 0x7fa, 0x7f5, 0x3, 0x2, 0x2, 0x2, 0x7fa, 0x7f8, 0x3, 
       0x2, 0x2, 0x2, 0x7fb, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x7fc, 0x7fd, 0x9, 
       0xd, 0x2, 0x2, 0x7fd, 0x8f, 0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7ff, 0x7, 
       0x1b1, 0x2, 0x2, 0x7ff, 0x800, 0x5, 0x362, 0x1b2, 0x2, 0x800, 0x91, 
       0x3, 0x2, 0x2, 0x2, 0x801, 0x804, 0x7, 0x33, 0x2, 0x2, 0x802, 0x805, 
       0x5, 0x3fe, 0x200, 0x2, 0x803, 0x805, 0x7, 0xc, 0x2, 0x2, 0x804, 
       0x802, 0x3, 0x2, 0x2, 0x2, 0x804, 0x803, 0x3, 0x2, 0x2, 0x2, 0x805, 
       0x93, 0x3, 0x2, 0x2, 0x2, 0x806, 0x808, 0x7, 0x47, 0x2, 0x2, 0x807, 
       0x809, 0x7, 0x21, 0x2, 0x2, 0x808, 0x807, 0x3, 0x2, 0x2, 0x2, 0x808, 
       0x809, 0x3, 0x2, 0x2, 0x2, 0x809, 0x80a, 0x3, 0x2, 0x2, 0x2, 0x80a, 
       0x80c, 0x5, 0x3fa, 0x1fe, 0x2, 0x80b, 0x80d, 0x5, 0xc0, 0x61, 0x2, 
       0x80c, 0x80b, 0x3, 0x2, 0x2, 0x2, 0x80c, 0x80d, 0x3, 0x2, 0x2, 0x2, 
       0x80d, 0x80f, 0x3, 0x2, 0x2, 0x2, 0x80e, 0x810, 0x5, 0x9e, 0x50, 
       0x2, 0x80f, 0x80e, 0x3, 0x2, 0x2, 0x2, 0x80f, 0x810, 0x3, 0x2, 0x2, 
       0x2, 0x810, 0x811, 0x3, 0x2, 0x2, 0x2, 0x811, 0x813, 0x5, 0x96, 0x4c, 
       0x2, 0x812, 0x814, 0x7, 0x140, 0x2, 0x2, 0x813, 0x812, 0x3, 0x2, 
       0x2, 0x2, 0x813, 0x814, 0x3, 0x2, 0x2, 0x2, 0x814, 0x815, 0x3, 0x2, 
       0x2, 0x2, 0x815, 0x817, 0x5, 0x9a, 0x4e, 0x2, 0x816, 0x818, 0x5, 
       0xa0, 0x51, 0x2, 0x817, 0x816, 0x3, 0x2, 0x2, 0x2, 0x817, 0x818, 
       0x3, 0x2, 0x2, 0x2, 0x818, 0x81a, 0x3, 0x2, 0x2, 0x2, 0x819, 0x81b, 
       0x5, 0x1c, 0xf, 0x2, 0x81a, 0x819, 0x3, 0x2, 0x2, 0x2, 0x81a, 0x81b, 
       0x3, 0x2, 0x2, 0x2, 0x81b, 0x81f, 0x3, 0x2, 0x2, 0x2, 0x81c, 0x81e, 
       0x5, 0x9c, 0x4f, 0x2, 0x81d, 0x81c, 0x3, 0x2, 0x2, 0x2, 0x81e, 0x821, 
       0x3, 0x2, 0x2, 0x2, 0x81f, 0x81d, 0x3, 0x2, 0x2, 0x2, 0x81f, 0x820, 
       0x3, 0x2, 0x2, 0x2, 0x820, 0x823, 0x3, 0x2, 0x2, 0x2, 0x821, 0x81f, 
       0x3, 0x2, 0x2, 0x2, 0x822, 0x824, 0x5, 0x14c, 0xa7, 0x2, 0x823, 0x822, 
       0x3, 0x2, 0x2, 0x2, 0x823, 0x824, 0x3, 0x2, 0x2, 0x2, 0x824, 0x826, 
       0x3, 0x2, 0x2, 0x2, 0x825, 0x827, 0x5, 0x98, 0x4d, 0x2, 0x826, 0x825, 
       0x3, 0x2, 0x2, 0x2, 0x826, 0x827, 0x3, 0x2, 0x2, 0x2, 0x827, 0x839, 
       0x3, 0x2, 0x2, 0x2, 0x828, 0x829, 0x7, 0x47, 0x2, 0x2, 0x829, 0x82a, 
       0x5, 0x2ec, 0x177, 0x2, 0x82a, 0x82c, 0x7, 0x19b, 0x2, 0x2, 0x82b, 
       0x82d, 0x7, 0x140, 0x2, 0x2, 0x82c, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x82c, 
       0x82d, 0x3, 0x2, 0x2, 0x2, 0x82d, 0x82e, 0x3, 0x2, 0x2, 0x2, 0x82e, 
       0x830, 0x5, 0x9a, 0x4e, 0x2, 0x82f, 0x831, 0x5, 0x1c, 0xf, 0x2, 0x830, 
       0x82f, 0x3, 0x2, 0x2, 0x2, 0x830, 0x831, 0x3, 0x2, 0x2, 0x2, 0x831, 
       0x835, 0x3, 0x2, 0x2, 0x2, 0x832, 0x834, 0x5, 0x9c, 0x4f, 0x2, 0x833, 
       0x832, 0x3, 0x2, 0x2, 0x2, 0x834, 0x837, 0x3, 0x2, 0x2, 0x2, 0x835, 
       0x833, 0x3, 0x2, 0x2, 0x2, 0x835, 0x836, 0x3, 0x2, 0x2, 0x2, 0x836, 
       0x839, 0x3, 0x2, 0x2, 0x2, 0x837, 0x835, 0x3, 0x2, 0x2, 0x2, 0x838, 
       0x806, 0x3, 0x2, 0x2, 0x2, 0x838, 0x828, 0x3, 0x2, 0x2, 0x2, 0x839, 
       0x95, 0x3, 0x2, 0x2, 0x2, 0x83a, 0x83b, 0x9, 0xe, 0x2, 0x2, 0x83b, 
       0x97, 0x3, 0x2, 0x2, 0x2, 0x83c, 0x83d, 0x7, 0xb2, 0x2, 0x2, 0x83d, 
       0x83e, 0x7, 0x8d, 0x2, 0x2, 0x83e, 0x83f, 0x7, 0x12d, 0x2, 0x2, 0x83f, 
       0x99, 0x3, 0x2, 0x2, 0x2, 0x840, 0x844, 0x5, 0x412, 0x20a, 0x2, 0x841, 
       0x844, 0x7, 0x184, 0x2, 0x2, 0x842, 0x844, 0x7, 0x185, 0x2, 0x2, 
       0x843, 0x840, 0x3, 0x2, 0x2, 0x2, 0x843, 0x841, 0x3, 0x2, 0x2, 0x2, 
       0x843, 0x842, 0x3, 0x2, 0x2, 0x2, 0x844, 0x9b, 0x3, 0x2, 0x2, 0x2, 
       0x845, 0x85b, 0x7, 0x21, 0x2, 0x2, 0x846, 0x85b, 0x7, 0x117, 0x2, 
       0x2, 0x847, 0x849, 0x9, 0xf, 0x2, 0x2, 0x848, 0x84a, 0x7, 0x15, 0x2, 
       0x2, 0x849, 0x848, 0x3, 0x2, 0x2, 0x2, 0x849, 0x84a, 0x3, 0x2, 0x2, 
       0x2, 0x84a, 0x84b, 0x3, 0x2, 0x2, 0x2, 0x84b, 0x85b, 0x5, 0x412, 
       0x20a, 0x2, 0x84c, 0x85b, 0x7, 0x51, 0x2, 0x2, 0x84d, 0x85b, 0x7, 
       0xac, 0x2, 0x2, 0x84e, 0x84f, 0x7, 0x9a, 0x2, 0x2, 0x84f, 0x850, 
       0x7, 0x144, 0x2, 0x2, 0x850, 0x85b, 0x5, 0xc2, 0x62, 0x2, 0x851, 
       0x852, 0x7, 0x9a, 0x2, 0x2, 0x852, 0x853, 0x7, 0x108, 0x2, 0x2, 0x853, 
       0x854, 0x7, 0x10e, 0x2, 0x2, 0x854, 0x85b, 0x5, 0xc2, 0x62, 0x2, 
       0x855, 0x856, 0x7, 0x94, 0x2, 0x2, 0x856, 0x857, 0x7, 0xf0, 0x2, 
       0x2, 0x857, 0x85b, 0x7, 0x92, 0x2, 0x2, 0x858, 0x859, 0x7, 0x119, 
       0x2, 0x2, 0x859, 0x85b, 0x7, 0x16e, 0x2, 0x2, 0x85a, 0x845, 0x3, 
       0x2, 0x2, 0x2, 0x85a, 0x846, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x847, 0x3, 
       0x2, 0x2, 0x2, 0x85a, 0x84c, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x84d, 0x3, 
       0x2, 0x2, 0x2, 0x85a, 0x84e, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x851, 0x3, 
       0x2, 0x2, 0x2, 0x85a, 0x855, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x858, 0x3, 
       0x2, 0x2, 0x2, 0x85b, 0x9d, 0x3, 0x2, 0x2, 0x2, 0x85c, 0x85d, 0x7, 
       0x1c4, 0x2, 0x2, 0x85d, 0x85e, 0x7, 0x117, 0x2, 0x2, 0x85e, 0x9f, 
       0x3, 0x2, 0x2, 0x2, 0x85f, 0x861, 0x7, 0x1b1, 0x2, 0x2, 0x860, 0x85f, 
       0x3, 0x2, 0x2, 0x2, 0x860, 0x861, 0x3, 0x2, 0x2, 0x2, 0x861, 0x862, 
       0x3, 0x2, 0x2, 0x2, 0x862, 0x863, 0x7, 0x6c, 0x2, 0x2, 0x863, 0x864, 
       0x5, 0x412, 0x20a, 0x2, 0x864, 0xa1, 0x3, 0x2, 0x2, 0x2, 0x865, 0x867, 
       0x7, 0x4b, 0x2, 0x2, 0x866, 0x868, 0x5, 0xa4, 0x53, 0x2, 0x867, 0x866, 
       0x3, 0x2, 0x2, 0x2, 0x867, 0x868, 0x3, 0x2, 0x2, 0x2, 0x868, 0x869, 
       0x3, 0x2, 0x2, 0x2, 0x869, 0x86a, 0x7, 0x190, 0x2, 0x2, 0x86a, 0x86b, 
       0x5, 0x3fa, 0x1fe, 0x2, 0x86b, 0x86d, 0x7, 0x1d9, 0x2, 0x2, 0x86c, 
       0x86e, 0x5, 0xa6, 0x54, 0x2, 0x86d, 0x86c, 0x3, 0x2, 0x2, 0x2, 0x86d, 
       0x86e, 0x3, 0x2, 0x2, 0x2, 0x86e, 0x86f, 0x3, 0x2, 0x2, 0x2, 0x86f, 
       0x871, 0x7, 0x1da, 0x2, 0x2, 0x870, 0x872, 0x5, 0xd0, 0x69, 0x2, 
       0x871, 0x870, 0x3, 0x2, 0x2, 0x2, 0x871, 0x872, 0x3, 0x2, 0x2, 0x2, 
       0x872, 0x874, 0x3, 0x2, 0x2, 0x2, 0x873, 0x875, 0x5, 0xd2, 0x6a, 
       0x2, 0x874, 0x873, 0x3, 0x2, 0x2, 0x2, 0x874, 0x875, 0x3, 0x2, 0x2, 
       0x2, 0x875, 0x877, 0x3, 0x2, 0x2, 0x2, 0x876, 0x878, 0x5, 0xd4, 0x6b, 
       0x2, 0x877, 0x876, 0x3, 0x2, 0x2, 0x2, 0x877, 0x878, 0x3, 0x2, 0x2, 
       0x2, 0x878, 0x87a, 0x3, 0x2, 0x2, 0x2, 0x879, 0x87b, 0x5, 0xd6, 0x6c, 
       0x2, 0x87a, 0x879, 0x3, 0x2, 0x2, 0x2, 0x87a, 0x87b, 0x3, 0x2, 0x2, 
       0x2, 0x87b, 0x87d, 0x3, 0x2, 0x2, 0x2, 0x87c, 0x87e, 0x5, 0xdc, 0x6f, 
       0x2, 0x87d, 0x87c, 0x3, 0x2, 0x2, 0x2, 0x87d, 0x87e, 0x3, 0x2, 0x2, 
       0x2, 0x87e, 0x880, 0x3, 0x2, 0x2, 0x2, 0x87f, 0x881, 0x5, 0x114, 
       0x8b, 0x2, 0x880, 0x87f, 0x3, 0x2, 0x2, 0x2, 0x880, 0x881, 0x3, 0x2, 
       0x2, 0x2, 0x881, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x882, 0x884, 0x9, 0x10, 
       0x2, 0x2, 0x883, 0x882, 0x3, 0x2, 0x2, 0x2, 0x883, 0x884, 0x3, 0x2, 
       0x2, 0x2, 0x884, 0x885, 0x3, 0x2, 0x2, 0x2, 0x885, 0x886, 0x9, 0x11, 
       0x2, 0x2, 0x886, 0xa5, 0x3, 0x2, 0x2, 0x2, 0x887, 0x88c, 0x5, 0xa8, 
       0x55, 0x2, 0x888, 0x889, 0x7, 0x1df, 0x2, 0x2, 0x889, 0x88b, 0x5, 
       0xa8, 0x55, 0x2, 0x88a, 0x888, 0x3, 0x2, 0x2, 0x2, 0x88b, 0x88e, 
       0x3, 0x2, 0x2, 0x2, 0x88c, 0x88a, 0x3, 0x2, 0x2, 0x2, 0x88c, 0x88d, 
       0x3, 0x2, 0x2, 0x2, 0x88d, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x88c, 
       0x3, 0x2, 0x2, 0x2, 0x88f, 0x894, 0x5, 0xac, 0x57, 0x2, 0x890, 0x894, 
       0x5, 0xb6, 0x5c, 0x2, 0x891, 0x894, 0x5, 0xba, 0x5e, 0x2, 0x892, 
       0x894, 0x5, 0xaa, 0x56, 0x2, 0x893, 0x88f, 0x3, 0x2, 0x2, 0x2, 0x893, 
       0x890, 0x3, 0x2, 0x2, 0x2, 0x893, 0x891, 0x3, 0x2, 0x2, 0x2, 0x893, 
       0x892, 0x3, 0x2, 0x2, 0x2, 0x894, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x895, 
       0x896, 0x7, 0x37, 0x2, 0x2, 0x896, 0x897, 0x5, 0x41a, 0x20e, 0x2, 
       0x897, 0x898, 0x7, 0x7d, 0x2, 0x2, 0x898, 0x899, 0x5, 0x1ac, 0xd7, 
       0x2, 0x899, 0x89f, 0x3, 0x2, 0x2, 0x2, 0x89a, 0x89b, 0x7, 0x65, 0x2, 
       0x2, 0x89b, 0x89c, 0x7, 0x37, 0x2, 0x2, 0x89c, 0x89d, 0x7, 0x7d, 
       0x2, 0x2, 0x89d, 0x89f, 0x5, 0x1ac, 0xd7, 0x2, 0x89e, 0x895, 0x3, 
       0x2, 0x2, 0x2, 0x89e, 0x89a, 0x3, 0x2, 0x2, 0x2, 0x89f, 0xab, 0x3, 
       0x2, 0x2, 0x2, 0x8a0, 0x8a1, 0x5, 0x41a, 0x20e, 0x2, 0x8a1, 0x8a5, 
       0x5, 0x33a, 0x19e, 0x2, 0x8a2, 0x8a4, 0x5, 0xae, 0x58, 0x2, 0x8a3, 
       0x8a2, 0x3, 0x2, 0x2, 0x2, 0x8a4, 0x8a7, 0x3, 0x2, 0x2, 0x2, 0x8a5, 
       0x8a3, 0x3, 0x2, 0x2, 0x2, 0x8a5, 0x8a6, 0x3, 0x2, 0x2, 0x2, 0x8a6, 
       0x8a9, 0x3, 0x2, 0x2, 0x2, 0x8a7, 0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a8, 
       0x8aa, 0x5, 0xb0, 0x59, 0x2, 0x8a9, 0x8a8, 0x3, 0x2, 0x2, 0x2, 0x8a9, 
       0x8aa, 0x3, 0x2, 0x2, 0x2, 0x8aa, 0xad, 0x3, 0x2, 0x2, 0x2, 0x8ab, 
       0x8ac, 0x7, 0x41, 0x2, 0x2, 0x8ac, 0x8ad, 0x5, 0x3fe, 0x200, 0x2, 
       0x8ad, 0x8ae, 0x5, 0xb2, 0x5a, 0x2, 0x8ae, 0x8b2, 0x3, 0x2, 0x2, 
       0x2, 0x8af, 0x8b2, 0x5, 0xb2, 0x5a, 0x2, 0x8b0, 0x8b2, 0x5, 0xb4, 
       0x5b, 0x2, 0x8b1, 0x8ab, 0x3, 0x2, 0x2, 0x2, 0x8b1, 0x8af, 0x3, 0x2, 
       0x2, 0x2, 0x8b1, 0x8b0, 0x3, 0x2, 0x2, 0x2, 0x8b2, 0xaf, 0x3, 0x2, 
       0x2, 0x2, 0x8b3, 0x8b4, 0x7, 0x7d, 0x2, 0x2, 0x8b4, 0x8b5, 0x5, 0x1ac, 
       0xd7, 0x2, 0x8b5, 0xb1, 0x3, 0x2, 0x2, 0x2, 0x8b6, 0x8b7, 0x7, 0x108, 
       0x2, 0x2, 0x8b7, 0x8db, 0x7, 0x10e, 0x2, 0x2, 0x8b8, 0x8db, 0x7, 
       0x10e, 0x2, 0x2, 0x8b9, 0x8bb, 0x7, 0x1aa, 0x2, 0x2, 0x8ba, 0x8bc, 
       0x5, 0xe, 0x8, 0x2, 0x8bb, 0x8ba, 0x3, 0x2, 0x2, 0x2, 0x8bb, 0x8bc, 
       0x3, 0x2, 0x2, 0x2, 0x8bc, 0x8be, 0x3, 0x2, 0x2, 0x2, 0x8bd, 0x8bf, 
       0x5, 0xd8, 0x6d, 0x2, 0x8be, 0x8bd, 0x3, 0x2, 0x2, 0x2, 0x8be, 0x8bf, 
       0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8db, 0x3, 0x2, 0x2, 0x2, 0x8c0, 0x8c1, 
       0x7, 0x13b, 0x2, 0x2, 0x8c1, 0x8c3, 0x7, 0xd1, 0x2, 0x2, 0x8c2, 0x8c4, 
       0x5, 0xe, 0x8, 0x2, 0x8c3, 0x8c2, 0x3, 0x2, 0x2, 0x2, 0x8c3, 0x8c4, 
       0x3, 0x2, 0x2, 0x2, 0x8c4, 0x8c6, 0x3, 0x2, 0x2, 0x2, 0x8c5, 0x8c7, 
       0x5, 0xd8, 0x6d, 0x2, 0x8c6, 0x8c5, 0x3, 0x2, 0x2, 0x2, 0x8c6, 0x8c7, 
       0x3, 0x2, 0x2, 0x2, 0x8c7, 0x8db, 0x3, 0x2, 0x2, 0x2, 0x8c8, 0x8c9, 
       0x7, 0x30, 0x2, 0x2, 0x8c9, 0x8ca, 0x7, 0x1d9, 0x2, 0x2, 0x8ca, 0x8cb, 
       0x5, 0x362, 0x1b2, 0x2, 0x8cb, 0x8cc, 0x7, 0x1da, 0x2, 0x2, 0x8cc, 
       0x8db, 0x3, 0x2, 0x2, 0x2, 0x8cd, 0x8ce, 0x7, 0x65, 0x2, 0x2, 0x8ce, 
       0x8db, 0x5, 0x362, 0x1b2, 0x2, 0x8cf, 0x8d0, 0x7, 0x14f, 0x2, 0x2, 
       0x8d0, 0x8d2, 0x5, 0x3fa, 0x1fe, 0x2, 0x8d1, 0x8d3, 0x5, 0xc0, 0x61, 
       0x2, 0x8d2, 0x8d1, 0x3, 0x2, 0x2, 0x2, 0x8d2, 0x8d3, 0x3, 0x2, 0x2, 
       0x2, 0x8d3, 0x8d5, 0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8d6, 0x5, 0xc6, 0x64, 
       0x2, 0x8d5, 0x8d4, 0x3, 0x2, 0x2, 0x2, 0x8d5, 0x8d6, 0x3, 0x2, 0x2, 
       0x2, 0x8d6, 0x8d8, 0x3, 0x2, 0x2, 0x2, 0x8d7, 0x8d9, 0x5, 0xc8, 0x65, 
       0x2, 0x8d8, 0x8d7, 0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d9, 0x3, 0x2, 0x2, 
       0x2, 0x8d9, 0x8db, 0x3, 0x2, 0x2, 0x2, 0x8da, 0x8b6, 0x3, 0x2, 0x2, 
       0x2, 0x8da, 0x8b8, 0x3, 0x2, 0x2, 0x2, 0x8da, 0x8b9, 0x3, 0x2, 0x2, 
       0x2, 0x8da, 0x8c0, 0x3, 0x2, 0x2, 0x2, 0x8da, 0x8c8, 0x3, 0x2, 0x2, 
       0x2, 0x8da, 0x8cd, 0x3, 0x2, 0x2, 0x2, 0x8da, 0x8cf, 0x3, 0x2, 0x2, 
       0x2, 0x8db, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x8dc, 0x8de, 0x7, 0x108, 0x2, 
       0x2, 0x8dd, 0x8dc, 0x3, 0x2, 0x2, 0x2, 0x8dd, 0x8de, 0x3, 0x2, 0x2, 
       0x2, 0x8de, 0x8df, 0x3, 0x2, 0x2, 0x2, 0x8df, 0x8e3, 0x7, 0x67, 0x2, 
       0x2, 0x8e0, 0x8e1, 0x7, 0xbe, 0x2, 0x2, 0x8e1, 0x8e3, 0x9, 0x8, 0x2, 
       0x2, 0x8e2, 0x8dd, 0x3, 0x2, 0x2, 0x2, 0x8e2, 0x8e0, 0x3, 0x2, 0x2, 
       0x2, 0x8e3, 0xb5, 0x3, 0x2, 0x2, 0x2, 0x8e4, 0x8e5, 0x7, 0xd9, 0x2, 
       0x2, 0x8e5, 0x8e9, 0x5, 0x3fa, 0x1fe, 0x2, 0x8e6, 0x8e8, 0x5, 0xb8, 
       0x5d, 0x2, 0x8e7, 0x8e6, 0x3, 0x2, 0x2, 0x2, 0x8e8, 0x8eb, 0x3, 0x2, 
       0x2, 0x2, 0x8e9, 0x8e7, 0x3, 0x2, 0x2, 0x2, 0x8e9, 0x8ea, 0x3, 0x2, 
       0x2, 0x2, 0x8ea, 0xb7, 0x3, 0x2, 0x2, 0x2, 0x8eb, 0x8e9, 0x3, 0x2, 
       0x2, 0x2, 0x8ec, 0x8ed, 0x9, 0x12, 0x2, 0x2, 0x8ed, 0x8f3, 0x7, 0x66, 
       0x2, 0x2, 0x8ee, 0x8ef, 0x9, 0x12, 0x2, 0x2, 0x8ef, 0x8f3, 0x7, 0x42, 
       0x2, 0x2, 0x8f0, 0x8f1, 0x9, 0x12, 0x2, 0x2, 0x8f1, 0x8f3, 0x7, 0xbb, 
       0x2, 0x2, 0x8f2, 0x8ec, 0x3, 0x2, 0x2, 0x2, 0x8f2, 0x8ee, 0x3, 0x2, 
       0x2, 0x2, 0x8f2, 0x8f0, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0xb9, 0x3, 0x2, 
       0x2, 0x2, 0x8f4, 0x8f5, 0x7, 0x41, 0x2, 0x2, 0x8f5, 0x8f7, 0x5, 0x3fe, 
       0x200, 0x2, 0x8f6, 0x8f4, 0x3, 0x2, 0x2, 0x2, 0x8f6, 0x8f7, 0x3, 
       0x2, 0x2, 0x2, 0x8f7, 0x8f8, 0x3, 0x2, 0x2, 0x2, 0x8f8, 0x8f9, 0x5, 
       0xbc, 0x5f, 0x2, 0x8f9, 0xbb, 0x3, 0x2, 0x2, 0x2, 0x8fa, 0x8fb, 0x7, 
       0x30, 0x2, 0x2, 0x8fb, 0x8fc, 0x7, 0x1d9, 0x2, 0x2, 0x8fc, 0x8fd, 
       0x5, 0x362, 0x1b2, 0x2, 0x8fd, 0x8fe, 0x7, 0x1da, 0x2, 0x2, 0x8fe, 
       0x91d, 0x3, 0x2, 0x2, 0x2, 0x8ff, 0x903, 0x7, 0x1aa, 0x2, 0x2, 0x900, 
       0x901, 0x7, 0x13b, 0x2, 0x2, 0x901, 0x903, 0x7, 0xd1, 0x2, 0x2, 0x902, 
       0x8ff, 0x3, 0x2, 0x2, 0x2, 0x902, 0x900, 0x3, 0x2, 0x2, 0x2, 0x903, 
       0x904, 0x3, 0x2, 0x2, 0x2, 0x904, 0x906, 0x5, 0xc0, 0x61, 0x2, 0x905, 
       0x907, 0x5, 0xe, 0x8, 0x2, 0x906, 0x905, 0x3, 0x2, 0x2, 0x2, 0x906, 
       0x907, 0x3, 0x2, 0x2, 0x2, 0x907, 0x909, 0x3, 0x2, 0x2, 0x2, 0x908, 
       0x90a, 0x5, 0xd8, 0x6d, 0x2, 0x909, 0x908, 0x3, 0x2, 0x2, 0x2, 0x909, 
       0x90a, 0x3, 0x2, 0x2, 0x2, 0x90a, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x90b, 
       0x90c, 0x7, 0x9b, 0x2, 0x2, 0x90c, 0x90d, 0x7, 0xd1, 0x2, 0x2, 0x90d, 
       0x90e, 0x5, 0xc0, 0x61, 0x2, 0x90e, 0x90f, 0x7, 0x14f, 0x2, 0x2, 
       0x90f, 0x911, 0x5, 0x3fa, 0x1fe, 0x2, 0x910, 0x912, 0x5, 0xc0, 0x61, 
       0x2, 0x911, 0x910, 0x3, 0x2, 0x2, 0x2, 0x911, 0x912, 0x3, 0x2, 0x2, 
       0x2, 0x912, 0x914, 0x3, 0x2, 0x2, 0x2, 0x913, 0x915, 0x5, 0xc6, 0x64, 
       0x2, 0x914, 0x913, 0x3, 0x2, 0x2, 0x2, 0x914, 0x915, 0x3, 0x2, 0x2, 
       0x2, 0x915, 0x917, 0x3, 0x2, 0x2, 0x2, 0x916, 0x918, 0x5, 0xc8, 0x65, 
       0x2, 0x917, 0x916, 0x3, 0x2, 0x2, 0x2, 0x917, 0x918, 0x3, 0x2, 0x2, 
       0x2, 0x918, 0x91a, 0x3, 0x2, 0x2, 0x2, 0x919, 0x91b, 0x5, 0x19e, 
       0xd0, 0x2, 0x91a, 0x919, 0x3, 0x2, 0x2, 0x2, 0x91a, 0x91b, 0x3, 0x2, 
       0x2, 0x2, 0x91b, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x8fa, 0x3, 0x2, 
       0x2, 0x2, 0x91c, 0x902, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x90b, 0x3, 0x2, 
       0x2, 0x2, 0x91d, 0xbd, 0x3, 0x2, 0x2, 0x2, 0x91e, 0x91f, 0x7, 0x1d9, 
       0x2, 0x2, 0x91f, 0x920, 0x5, 0xc4, 0x63, 0x2, 0x920, 0x921, 0x7, 
       0x1da, 0x2, 0x2, 0x921, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x922, 0x923, 0x7, 
       0x1d9, 0x2, 0x2, 0x923, 0x924, 0x5, 0xc2, 0x62, 0x2, 0x924, 0x925, 
       0x7, 0x1da, 0x2, 0x2, 0x925, 0xc1, 0x3, 0x2, 0x2, 0x2, 0x926, 0x92b, 
       0x5, 0xc4, 0x63, 0x2, 0x927, 0x928, 0x7, 0x1df, 0x2, 0x2, 0x928, 
       0x92a, 0x5, 0xc4, 0x63, 0x2, 0x929, 0x927, 0x3, 0x2, 0x2, 0x2, 0x92a, 
       0x92d, 0x3, 0x2, 0x2, 0x2, 0x92b, 0x929, 0x3, 0x2, 0x2, 0x2, 0x92b, 
       0x92c, 0x3, 0x2, 0x2, 0x2, 0x92c, 0xc3, 0x3, 0x2, 0x2, 0x2, 0x92d, 
       0x92b, 0x3, 0x2, 0x2, 0x2, 0x92e, 0x92f, 0x5, 0x41a, 0x20e, 0x2, 
       0x92f, 0xc5, 0x3, 0x2, 0x2, 0x2, 0x930, 0x931, 0x7, 0xe7, 0x2, 0x2, 
       0x931, 0x932, 0x9, 0x13, 0x2, 0x2, 0x932, 0xc7, 0x3, 0x2, 0x2, 0x2, 
       0x933, 0x93c, 0x5, 0xca, 0x66, 0x2, 0x934, 0x93c, 0x5, 0xcc, 0x67, 
       0x2, 0x935, 0x936, 0x5, 0xca, 0x66, 0x2, 0x936, 0x937, 0x5, 0xcc, 
       0x67, 0x2, 0x937, 0x93c, 0x3, 0x2, 0x2, 0x2, 0x938, 0x939, 0x5, 0xcc, 
       0x67, 0x2, 0x939, 0x93a, 0x5, 0xca, 0x66, 0x2, 0x93a, 0x93c, 0x3, 
       0x2, 0x2, 0x2, 0x93b, 0x933, 0x3, 0x2, 0x2, 0x2, 0x93b, 0x934, 0x3, 
       0x2, 0x2, 0x2, 0x93b, 0x935, 0x3, 0x2, 0x2, 0x2, 0x93b, 0x938, 0x3, 
       0x2, 0x2, 0x2, 0x93c, 0xc9, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x93e, 0x7, 
       0x119, 0x2, 0x2, 0x93e, 0x93f, 0x7, 0x1ae, 0x2, 0x2, 0x93f, 0x940, 
       0x5, 0xce, 0x68, 0x2, 0x940, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x941, 0x942, 
       0x7, 0x119, 0x2, 0x2, 0x942, 0x943, 0x7, 0x6a, 0x2, 0x2, 0x943, 0x944, 
       0x5, 0xce, 0x68, 0x2, 0x944, 0xcd, 0x3, 0x2, 0x2, 0x2, 0x945, 0x946, 
       0x7, 0xfe, 0x2, 0x2, 0x946, 0x94c, 0x7, 0x6, 0x2, 0x2, 0x947, 0x94c, 
       0x7, 0x15b, 0x2, 0x2, 0x948, 0x94c, 0x7, 0x28, 0x2, 0x2, 0x949, 0x94a, 
       0x7, 0x174, 0x2, 0x2, 0x94a, 0x94c, 0x9, 0x14, 0x2, 0x2, 0x94b, 0x945, 
       0x3, 0x2, 0x2, 0x2, 0x94b, 0x947, 0x3, 0x2, 0x2, 0x2, 0x94b, 0x948, 
       0x3, 0x2, 0x2, 0x2, 0x94b, 0x949, 0x3, 0x2, 0x2, 0x2, 0x94c, 0xcf, 
       0x3, 0x2, 0x2, 0x2, 0x94d, 0x94e, 0x7, 0xbd, 0x2, 0x2, 0x94e, 0x94f, 
       0x7, 0x1d9, 0x2, 0x2, 0x94f, 0x950, 0x5, 0x3f8, 0x1fd, 0x2, 0x950, 
       0x951, 0x7, 0x1da, 0x2, 0x2, 0x951, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x952, 
       0x953, 0x7, 0x1c4, 0x2, 0x2, 0x953, 0x957, 0x5, 0x1ac, 0xd7, 0x2, 
       0x954, 0x955, 0x9, 0x2, 0x2, 0x2, 0x955, 0x957, 0x7, 0x117, 0x2, 
       0x2, 0x956, 0x952, 0x3, 0x2, 0x2, 0x2, 0x956, 0x954, 0x3, 0x2, 0x2, 
       0x2, 0x957, 0xd3, 0x3, 0x2, 0x2, 0x2, 0x958, 0x959, 0x7, 0x119, 0x2, 
       0x2, 0x959, 0x95a, 0x7, 0x39, 0x2, 0x2, 0x95a, 0x960, 0x7, 0x78, 
       0x2, 0x2, 0x95b, 0x95c, 0x7, 0x119, 0x2, 0x2, 0x95c, 0x95d, 0x7, 
       0x39, 0x2, 0x2, 0x95d, 0x95e, 0x9, 0x15, 0x2, 0x2, 0x95e, 0x960, 
       0x7, 0x165, 0x2, 0x2, 0x95f, 0x958, 0x3, 0x2, 0x2, 0x2, 0x95f, 0x95b, 
       0x3, 0x2, 0x2, 0x2, 0x960, 0xd5, 0x3, 0x2, 0x2, 0x2, 0x961, 0x962, 
       0x7, 0x191, 0x2, 0x2, 0x962, 0x963, 0x5, 0x3fe, 0x200, 0x2, 0x963, 
       0xd7, 0x3, 0x2, 0x2, 0x2, 0x964, 0x965, 0x7, 0x1b1, 0x2, 0x2, 0x965, 
       0x966, 0x7, 0xba, 0x2, 0x2, 0x966, 0x967, 0x7, 0x191, 0x2, 0x2, 0x967, 
       0x968, 0x5, 0x3fe, 0x200, 0x2, 0x968, 0xd9, 0x3, 0x2, 0x2, 0x2, 0x969, 
       0x96a, 0x7, 0x73, 0x2, 0x2, 0x96a, 0x96b, 0x7, 0x25, 0x2, 0x2, 0x96b, 
       0x96f, 0x5, 0xc0, 0x61, 0x2, 0x96c, 0x96d, 0x7, 0x73, 0x2, 0x2, 0x96d, 
       0x96f, 0x7, 0x145, 0x2, 0x2, 0x96e, 0x969, 0x3, 0x2, 0x2, 0x2, 0x96e, 
       0x96c, 0x3, 0x2, 0x2, 0x2, 0x96f, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x970, 
       0x971, 0x5, 0xda, 0x6e, 0x2, 0x971, 0xdd, 0x3, 0x2, 0x2, 0x2, 0x972, 
       0x974, 0x5, 0xaa, 0x56, 0x2, 0x973, 0x972, 0x3, 0x2, 0x2, 0x2, 0x974, 
       0x975, 0x3, 0x2, 0x2, 0x2, 0x975, 0x973, 0x3, 0x2, 0x2, 0x2, 0x975, 
       0x976, 0x3, 0x2, 0x2, 0x2, 0x976, 0xdf, 0x3, 0x2, 0x2, 0x2, 0x977, 
       0x978, 0x7, 0x1c4, 0x2, 0x2, 0x978, 0x97b, 0x5, 0x1ac, 0xd7, 0x2, 
       0x979, 0x97a, 0x7, 0x191, 0x2, 0x2, 0x97a, 0x97c, 0x5, 0x3fe, 0x200, 
       0x2, 0x97b, 0x979, 0x3, 0x2, 0x2, 0x2, 0x97b, 0x97c, 0x3, 0x2, 0x2, 
       0x2, 0x97c, 0x980, 0x3, 0x2, 0x2, 0x2, 0x97d, 0x97e, 0x7, 0x191, 
       0x2, 0x2, 0x97e, 0x980, 0x5, 0x3fe, 0x200, 0x2, 0x97f, 0x977, 0x3, 
       0x2, 0x2, 0x2, 0x97f, 0x97d, 0x3, 0x2, 0x2, 0x2, 0x980, 0xe1, 0x3, 
       0x2, 0x2, 0x2, 0x981, 0x982, 0x7, 0x1d9, 0x2, 0x2, 0x982, 0x983, 
       0x5, 0xe6, 0x74, 0x2, 0x983, 0x984, 0x7, 0x1da, 0x2, 0x2, 0x984, 
       0xe3, 0x3, 0x2, 0x2, 0x2, 0x985, 0x986, 0x7, 0x1d9, 0x2, 0x2, 0x986, 
       0x987, 0x5, 0xe8, 0x75, 0x2, 0x987, 0x988, 0x7, 0x1da, 0x2, 0x2, 
       0x988, 0xe5, 0x3, 0x2, 0x2, 0x2, 0x989, 0x98e, 0x5, 0x104, 0x83, 
       0x2, 0x98a, 0x98b, 0x7, 0x1df, 0x2, 0x2, 0x98b, 0x98d, 0x5, 0x104, 
       0x83, 0x2, 0x98c, 0x98a, 0x3, 0x2, 0x2, 0x2, 0x98d, 0x990, 0x3, 0x2, 
       0x2, 0x2, 0x98e, 0x98c, 0x3, 0x2, 0x2, 0x2, 0x98e, 0x98f, 0x3, 0x2, 
       0x2, 0x2, 0x98f, 0xe7, 0x3, 0x2, 0x2, 0x2, 0x990, 0x98e, 0x3, 0x2, 
       0x2, 0x2, 0x991, 0x996, 0x5, 0x106, 0x84, 0x2, 0x992, 0x993, 0x7, 
       0x1df, 0x2, 0x2, 0x993, 0x995, 0x5, 0x106, 0x84, 0x2, 0x994, 0x992, 
       0x3, 0x2, 0x2, 0x2, 0x995, 0x998, 0x3, 0x2, 0x2, 0x2, 0x996, 0x994, 
       0x3, 0x2, 0x2, 0x2, 0x996, 0x997, 0x3, 0x2, 0x2, 0x2, 0x997, 0xe9, 
       0x3, 0x2, 0x2, 0x2, 0x998, 0x996, 0x3, 0x2, 0x2, 0x2, 0x999, 0x99a, 
       0x8, 0x76, 0x1, 0x2, 0x99a, 0x9a5, 0x5, 0x40e, 0x208, 0x2, 0x99b, 
       0x99c, 0x7, 0x2b, 0x2, 0x2, 0x99c, 0x99d, 0x7, 0x1d9, 0x2, 0x2, 0x99d, 
       0x99e, 0x5, 0xec, 0x77, 0x2, 0x99e, 0x99f, 0x7, 0x15, 0x2, 0x2, 0x99f, 
       0x9a0, 0x5, 0x33a, 0x19e, 0x2, 0x9a0, 0x9a1, 0x7, 0x1da, 0x2, 0x2, 
       0x9a1, 0x9a5, 0x3, 0x2, 0x2, 0x2, 0x9a2, 0x9a3, 0x7, 0x1de, 0x2, 
       0x2, 0x9a3, 0x9a5, 0x5, 0xea, 0x76, 0x3, 0x9a4, 0x999, 0x3, 0x2, 
       0x2, 0x2, 0x9a4, 0x99b, 0x3, 0x2, 0x2, 0x2, 0x9a4, 0x9a2, 0x3, 0x2, 
       0x2, 0x2, 0x9a5, 0x9ab, 0x3, 0x2, 0x2, 0x2, 0x9a6, 0x9a7, 0xc, 0x4, 
       0x2, 0x2, 0x9a7, 0x9a8, 0x7, 0x1ef, 0x2, 0x2, 0x9a8, 0x9aa, 0x5, 
       0x33a, 0x19e, 0x2, 0x9a9, 0x9a6, 0x3, 0x2, 0x2, 0x2, 0x9aa, 0x9ad, 
       0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9ac, 
       0x3, 0x2, 0x2, 0x2, 0x9ac, 0xeb, 0x3, 0x2, 0x2, 0x2, 0x9ad, 0x9ab, 
       0x3, 0x2, 0x2, 0x2, 0x9ae, 0x9ba, 0x5, 0xea, 0x76, 0x2, 0x9af, 0x9b0, 
       0x7, 0x1d9, 0x2, 0x2, 0x9b0, 0x9b1, 0x5, 0xea, 0x76, 0x2, 0x9b1, 
       0x9b2, 0x7, 0x1da, 0x2, 0x2, 0x9b2, 0x9ba, 0x3, 0x2, 0x2, 0x2, 0x9b3, 
       0x9b4, 0x7, 0x1d9, 0x2, 0x2, 0x9b4, 0x9b5, 0x5, 0xea, 0x76, 0x2, 
       0x9b5, 0x9b6, 0x7, 0x1da, 0x2, 0x2, 0x9b6, 0x9b7, 0x7, 0x1ef, 0x2, 
       0x2, 0x9b7, 0x9b8, 0x5, 0x33a, 0x19e, 0x2, 0x9b8, 0x9ba, 0x3, 0x2, 
       0x2, 0x2, 0x9b9, 0x9ae, 0x3, 0x2, 0x2, 0x2, 0x9b9, 0x9af, 0x3, 0x2, 
       0x2, 0x2, 0x9b9, 0x9b3, 0x3, 0x2, 0x2, 0x2, 0x9ba, 0xed, 0x3, 0x2, 
       0x2, 0x2, 0x9bb, 0x9c0, 0x5, 0xec, 0x77, 0x2, 0x9bc, 0x9bd, 0x7, 
       0x1df, 0x2, 0x2, 0x9bd, 0x9bf, 0x5, 0xec, 0x77, 0x2, 0x9be, 0x9bc, 
       0x3, 0x2, 0x2, 0x2, 0x9bf, 0x9c2, 0x3, 0x2, 0x2, 0x2, 0x9c0, 0x9be, 
       0x3, 0x2, 0x2, 0x2, 0x9c0, 0x9c1, 0x3, 0x2, 0x2, 0x2, 0x9c1, 0xef, 
       0x3, 0x2, 0x2, 0x2, 0x9c2, 0x9c0, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x9c4, 
       0x9, 0x16, 0x2, 0x2, 0x9c4, 0xf1, 0x3, 0x2, 0x2, 0x2, 0x9c5, 0x9c6, 
       0x7, 0x181, 0x2, 0x2, 0x9c6, 0x9c8, 0x7, 0x1d9, 0x2, 0x2, 0x9c7, 
       0x9c9, 0x5, 0xee, 0x78, 0x2, 0x9c8, 0x9c7, 0x3, 0x2, 0x2, 0x2, 0x9c8, 
       0x9c9, 0x3, 0x2, 0x2, 0x2, 0x9c9, 0x9ca, 0x3, 0x2, 0x2, 0x2, 0x9ca, 
       0x9cc, 0x7, 0x1da, 0x2, 0x2, 0x9cb, 0x9cd, 0x5, 0xf0, 0x79, 0x2, 
       0x9cc, 0x9cb, 0x3, 0x2, 0x2, 0x2, 0x9cc, 0x9cd, 0x3, 0x2, 0x2, 0x2, 
       0x9cd, 0xf3, 0x3, 0x2, 0x2, 0x2, 0x9ce, 0x9cf, 0x7, 0x7f, 0x2, 0x2, 
       0x9cf, 0x9d1, 0x7, 0x1d9, 0x2, 0x2, 0x9d0, 0x9d2, 0x5, 0xee, 0x78, 
       0x2, 0x9d1, 0x9d0, 0x3, 0x2, 0x2, 0x2, 0x9d1, 0x9d2, 0x3, 0x2, 0x2, 
       0x2, 0x9d2, 0x9d3, 0x3, 0x2, 0x2, 0x2, 0x9d3, 0x9d5, 0x7, 0x1da, 
       0x2, 0x2, 0x9d4, 0x9d6, 0x5, 0xf0, 0x79, 0x2, 0x9d5, 0x9d4, 0x3, 
       0x2, 0x2, 0x2, 0x9d5, 0x9d6, 0x3, 0x2, 0x2, 0x2, 0x9d6, 0xf5, 0x3, 
       0x2, 0x2, 0x2, 0x9d7, 0x9d8, 0x7, 0x83, 0x2, 0x2, 0x9d8, 0x9d9, 0x7, 
       0x1d9, 0x2, 0x2, 0x9d9, 0x9da, 0x5, 0xee, 0x78, 0x2, 0x9da, 0x9db, 
       0x7, 0x1da, 0x2, 0x2, 0x9db, 0xf7, 0x3, 0x2, 0x2, 0x2, 0x9dc, 0x9e9, 
       0x5, 0x100, 0x81, 0x2, 0x9dd, 0x9df, 0x5, 0xf2, 0x7a, 0x2, 0x9de, 
       0x9e0, 0x5, 0xf4, 0x7b, 0x2, 0x9df, 0x9de, 0x3, 0x2, 0x2, 0x2, 0x9df, 
       0x9e0, 0x3, 0x2, 0x2, 0x2, 0x9e0, 0x9e2, 0x3, 0x2, 0x2, 0x2, 0x9e1, 
       0x9e3, 0x5, 0xf6, 0x7c, 0x2, 0x9e2, 0x9e1, 0x3, 0x2, 0x2, 0x2, 0x9e2, 
       0x9e3, 0x3, 0x2, 0x2, 0x2, 0x9e3, 0x9e9, 0x3, 0x2, 0x2, 0x2, 0x9e4, 
       0x9e6, 0x5, 0xf4, 0x7b, 0x2, 0x9e5, 0x9e7, 0x5, 0xf6, 0x7c, 0x2, 
       0x9e6, 0x9e5, 0x3, 0x2, 0x2, 0x2, 0x9e6, 0x9e7, 0x3, 0x2, 0x2, 0x2, 
       0x9e7, 0x9e9, 0x3, 0x2, 0x2, 0x2, 0x9e8, 0x9dc, 0x3, 0x2, 0x2, 0x2, 
       0x9e8, 0x9dd, 0x3, 0x2, 0x2, 0x2, 0x9e8, 0x9e4, 0x3, 0x2, 0x2, 0x2, 
       0x9e9, 0xf9, 0x3, 0x2, 0x2, 0x2, 0x9ea, 0x9eb, 0x7, 0x1d9, 0x2, 0x2, 
       0x9eb, 0x9ec, 0x5, 0xfe, 0x80, 0x2, 0x9ec, 0x9ed, 0x7, 0x1da, 0x2, 
       0x2, 0x9ed, 0xfb, 0x3, 0x2, 0x2, 0x2, 0x9ee, 0x9f3, 0x5, 0xfa, 0x7e, 
       0x2, 0x9ef, 0x9f0, 0x7, 0x1df, 0x2, 0x2, 0x9f0, 0x9f2, 0x5, 0xfa, 
       0x7e, 0x2, 0x9f1, 0x9ef, 0x3, 0x2, 0x2, 0x2, 0x9f2, 0x9f5, 0x3, 0x2, 
       0x2, 0x2, 0x9f3, 0x9f1, 0x3, 0x2, 0x2, 0x2, 0x9f3, 0x9f4, 0x3, 0x2, 
       0x2, 0x2, 0x9f4, 0xfd, 0x3, 0x2, 0x2, 0x2, 0x9f5, 0x9f3, 0x3, 0x2, 
       0x2, 0x2, 0x9f6, 0x9fb, 0x5, 0xea, 0x76, 0x2, 0x9f7, 0x9f8, 0x7, 
       0x1df, 0x2, 0x2, 0x9f8, 0x9fa, 0x5, 0xea, 0x76, 0x2, 0x9f9, 0x9f7, 
       0x3, 0x2, 0x2, 0x2, 0x9fa, 0x9fd, 0x3, 0x2, 0x2, 0x2, 0x9fb, 0x9f9, 
       0x3, 0x2, 0x2, 0x2, 0x9fb, 0x9fc, 0x3, 0x2, 0x2, 0x2, 0x9fc, 0xff, 
       0x3, 0x2, 0x2, 0x2, 0x9fd, 0x9fb, 0x3, 0x2, 0x2, 0x2, 0x9fe, 0x9ff, 
       0x7, 0x1b7, 0x2, 0x2, 0x9ff, 0xa06, 0x5, 0xfa, 0x7e, 0x2, 0xa00, 
       0xa01, 0x7, 0x1b7, 0x2, 0x2, 0xa01, 0xa02, 0x7, 0x1d9, 0x2, 0x2, 
       0xa02, 0xa03, 0x5, 0xfc, 0x7f, 0x2, 0xa03, 0xa04, 0x7, 0x1da, 0x2, 
       0x2, 0xa04, 0xa06, 0x3, 0x2, 0x2, 0x2, 0xa05, 0x9fe, 0x3, 0x2, 0x2, 
       0x2, 0xa05, 0xa00, 0x3, 0x2, 0x2, 0x2, 0xa06, 0x101, 0x3, 0x2, 0x2, 
       0x2, 0xa07, 0xa0a, 0x5, 0xee, 0x78, 0x2, 0xa08, 0xa0a, 0x5, 0x100, 
       0x81, 0x2, 0xa09, 0xa07, 0x3, 0x2, 0x2, 0x2, 0xa09, 0xa08, 0x3, 0x2, 
       0x2, 0x2, 0xa0a, 0x103, 0x3, 0x2, 0x2, 0x2, 0xa0b, 0xa0e, 0x5, 0x10a, 
       0x86, 0x2, 0xa0c, 0xa0e, 0x5, 0x10c, 0x87, 0x2, 0xa0d, 0xa0b, 0x3, 
       0x2, 0x2, 0x2, 0xa0d, 0xa0c, 0x3, 0x2, 0x2, 0x2, 0xa0e, 0xa10, 0x3, 
       0x2, 0x2, 0x2, 0xa0f, 0xa11, 0x5, 0xf8, 0x7d, 0x2, 0xa10, 0xa0f, 
       0x3, 0x2, 0x2, 0x2, 0xa10, 0xa11, 0x3, 0x2, 0x2, 0x2, 0xa11, 0xa13, 
       0x3, 0x2, 0x2, 0x2, 0xa12, 0xa14, 0x5, 0xe0, 0x71, 0x2, 0xa13, 0xa12, 
       0x3, 0x2, 0x2, 0x2, 0xa13, 0xa14, 0x3, 0x2, 0x2, 0x2, 0xa14, 0xa16, 
       0x3, 0x2, 0x2, 0x2, 0xa15, 0xa17, 0x5, 0xde, 0x70, 0x2, 0xa16, 0xa15, 
       0x3, 0x2, 0x2, 0x2, 0xa16, 0xa17, 0x3, 0x2, 0x2, 0x2, 0xa17, 0xa19, 
       0x3, 0x2, 0x2, 0x2, 0xa18, 0xa1a, 0x5, 0xe4, 0x73, 0x2, 0xa19, 0xa18, 
       0x3, 0x2, 0x2, 0x2, 0xa19, 0xa1a, 0x3, 0x2, 0x2, 0x2, 0xa1a, 0xa1e, 
       0x3, 0x2, 0x2, 0x2, 0xa1b, 0xa1e, 0x5, 0x108, 0x85, 0x2, 0xa1c, 0xa1e, 
       0x5, 0xaa, 0x56, 0x2, 0xa1d, 0xa0d, 0x3, 0x2, 0x2, 0x2, 0xa1d, 0xa1b, 
       0x3, 0x2, 0x2, 0x2, 0xa1d, 0xa1c, 0x3, 0x2, 0x2, 0x2, 0xa1e, 0x105, 
       0x3, 0x2, 0x2, 0x2, 0xa1f, 0xa22, 0x5, 0x10e, 0x88, 0x2, 0xa20, 0xa22, 
       0x5, 0x110, 0x89, 0x2, 0xa21, 0xa1f, 0x3, 0x2, 0x2, 0x2, 0xa21, 0xa20, 
       0x3, 0x2, 0x2, 0x2, 0xa22, 0xa24, 0x3, 0x2, 0x2, 0x2, 0xa23, 0xa25, 
       0x5, 0xf8, 0x7d, 0x2, 0xa24, 0xa23, 0x3, 0x2, 0x2, 0x2, 0xa24, 0xa25, 
       0x3, 0x2, 0x2, 0x2, 0xa25, 0xa27, 0x3, 0x2, 0x2, 0x2, 0xa26, 0xa28, 
       0x5, 0xe0, 0x71, 0x2, 0xa27, 0xa26, 0x3, 0x2, 0x2, 0x2, 0xa27, 0xa28, 
       0x3, 0x2, 0x2, 0x2, 0xa28, 0xa2a, 0x3, 0x2, 0x2, 0x2, 0xa29, 0xa2b, 
       0x5, 0xde, 0x70, 0x2, 0xa2a, 0xa29, 0x3, 0x2, 0x2, 0x2, 0xa2a, 0xa2b, 
       0x3, 0x2, 0x2, 0x2, 0xa2b, 0xa2d, 0x3, 0x2, 0x2, 0x2, 0xa2c, 0xa2e, 
       0x5, 0xe4, 0x73, 0x2, 0xa2d, 0xa2c, 0x3, 0x2, 0x2, 0x2, 0xa2d, 0xa2e, 
       0x3, 0x2, 0x2, 0x2, 0xa2e, 0xa32, 0x3, 0x2, 0x2, 0x2, 0xa2f, 0xa32, 
       0x5, 0x108, 0x85, 0x2, 0xa30, 0xa32, 0x5, 0xaa, 0x56, 0x2, 0xa31, 
       0xa21, 0x3, 0x2, 0x2, 0x2, 0xa31, 0xa2f, 0x3, 0x2, 0x2, 0x2, 0xa31, 
       0xa30, 0x3, 0x2, 0x2, 0x2, 0xa32, 0x107, 0x3, 0x2, 0x2, 0x2, 0xa33, 
       0xa35, 0x5, 0xf8, 0x7d, 0x2, 0xa34, 0xa36, 0x5, 0xe0, 0x71, 0x2, 
       0xa35, 0xa34, 0x3, 0x2, 0x2, 0x2, 0xa35, 0xa36, 0x3, 0x2, 0x2, 0x2, 
       0xa36, 0xa38, 0x3, 0x2, 0x2, 0x2, 0xa37, 0xa39, 0x5, 0xde, 0x70, 
       0x2, 0xa38, 0xa37, 0x3, 0x2, 0x2, 0x2, 0xa38, 0xa39, 0x3, 0x2, 0x2, 
       0x2, 0xa39, 0xa3b, 0x3, 0x2, 0x2, 0x2, 0xa3a, 0xa3c, 0x5, 0xe4, 0x73, 
       0x2, 0xa3b, 0xa3a, 0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa3c, 0x3, 0x2, 0x2, 
       0x2, 0xa3c, 0x109, 0x3, 0x2, 0x2, 0x2, 0xa3d, 0xa3e, 0x7, 0x12c, 
       0x2, 0x2, 0xa3e, 0xa3f, 0x5, 0x426, 0x214, 0x2, 0xa3f, 0x10b, 0x3, 
       0x2, 0x2, 0x2, 0xa40, 0xa41, 0x7, 0x65, 0x2, 0x2, 0xa41, 0xa42, 0x7, 
       0x12c, 0x2, 0x2, 0xa42, 0xa43, 0x5, 0x426, 0x214, 0x2, 0xa43, 0x10d, 
       0x3, 0x2, 0x2, 0x2, 0xa44, 0xa45, 0x7, 0x189, 0x2, 0x2, 0xa45, 0xa46, 
       0x5, 0x426, 0x214, 0x2, 0xa46, 0x10f, 0x3, 0x2, 0x2, 0x2, 0xa47, 
       0xa48, 0x7, 0x65, 0x2, 0x2, 0xa48, 0xa49, 0x7, 0x189, 0x2, 0x2, 0xa49, 
       0xa4a, 0x5, 0x426, 0x214, 0x2, 0xa4a, 0x111, 0x3, 0x2, 0x2, 0x2, 
       0xa4b, 0xa4c, 0x9, 0x17, 0x2, 0x2, 0xa4c, 0x113, 0x3, 0x2, 0x2, 0x2, 
       0xa4d, 0xa4e, 0x7, 0x12c, 0x2, 0x2, 0xa4e, 0xa50, 0x7, 0x25, 0x2, 
       0x2, 0xa4f, 0xa51, 0x5, 0x112, 0x8a, 0x2, 0xa50, 0xa4f, 0x3, 0x2, 
       0x2, 0x2, 0xa50, 0xa51, 0x3, 0x2, 0x2, 0x2, 0xa51, 0xa52, 0x3, 0x2, 
       0x2, 0x2, 0xa52, 0xa54, 0x5, 0xc0, 0x61, 0x2, 0xa53, 0xa55, 0x5, 
       0x11c, 0x8f, 0x2, 0xa54, 0xa53, 0x3, 0x2, 0x2, 0x2, 0xa54, 0xa55, 
       0x3, 0x2, 0x2, 0x2, 0xa55, 0xa57, 0x3, 0x2, 0x2, 0x2, 0xa56, 0xa58, 
       0x5, 0x116, 0x8c, 0x2, 0xa57, 0xa56, 0x3, 0x2, 0x2, 0x2, 0xa57, 0xa58, 
       0x3, 0x2, 0x2, 0x2, 0xa58, 0xa5a, 0x3, 0x2, 0x2, 0x2, 0xa59, 0xa5b, 
       0x5, 0xe2, 0x72, 0x2, 0xa5a, 0xa59, 0x3, 0x2, 0x2, 0x2, 0xa5a, 0xa5b, 
       0x3, 0x2, 0x2, 0x2, 0xa5b, 0x115, 0x3, 0x2, 0x2, 0x2, 0xa5c, 0xa63, 
       0x5, 0x11a, 0x8e, 0x2, 0xa5d, 0xa5f, 0x7, 0x1df, 0x2, 0x2, 0xa5e, 
       0xa5d, 0x3, 0x2, 0x2, 0x2, 0xa5e, 0xa5f, 0x3, 0x2, 0x2, 0x2, 0xa5f, 
       0xa60, 0x3, 0x2, 0x2, 0x2, 0xa60, 0xa62, 0x5, 0x11a, 0x8e, 0x2, 0xa61, 
       0xa5e, 0x3, 0x2, 0x2, 0x2, 0xa62, 0xa65, 0x3, 0x2, 0x2, 0x2, 0xa63, 
       0xa61, 0x3, 0x2, 0x2, 0x2, 0xa63, 0xa64, 0x3, 0x2, 0x2, 0x2, 0xa64, 
       0x117, 0x3, 0x2, 0x2, 0x2, 0xa65, 0xa63, 0x3, 0x2, 0x2, 0x2, 0xa66, 
       0xa67, 0x7, 0x189, 0x2, 0x2, 0xa67, 0xa68, 0x7, 0x193, 0x2, 0x2, 
       0xa68, 0xa69, 0x7, 0x1d9, 0x2, 0x2, 0xa69, 0xa6a, 0x5, 0xe8, 0x75, 
       0x2, 0xa6a, 0xa6b, 0x7, 0x1da, 0x2, 0x2, 0xa6b, 0x119, 0x3, 0x2, 
       0x2, 0x2, 0xa6c, 0xa6d, 0x7, 0x189, 0x2, 0x2, 0xa6d, 0xa6e, 0x7, 
       0x25, 0x2, 0x2, 0xa6e, 0xa6f, 0x5, 0x112, 0x8a, 0x2, 0xa6f, 0xa71, 
       0x5, 0xc0, 0x61, 0x2, 0xa70, 0xa72, 0x5, 0x11c, 0x8f, 0x2, 0xa71, 
       0xa70, 0x3, 0x2, 0x2, 0x2, 0xa71, 0xa72, 0x3, 0x2, 0x2, 0x2, 0xa72, 
       0xa75, 0x3, 0x2, 0x2, 0x2, 0xa73, 0xa75, 0x5, 0x118, 0x8d, 0x2, 0xa74, 
       0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa74, 0xa73, 0x3, 0x2, 0x2, 0x2, 0xa75, 
       0x11b, 0x3, 0x2, 0x2, 0x2, 0xa76, 0xa77, 0x9, 0x18, 0x2, 0x2, 0xa77, 
       0xa78, 0x5, 0x162, 0xb2, 0x2, 0xa78, 0x11d, 0x3, 0x2, 0x2, 0x2, 0xa79, 
       0xa7b, 0x7, 0x4b, 0x2, 0x2, 0xa7a, 0xa7c, 0x5, 0xa4, 0x53, 0x2, 0xa7b, 
       0xa7a, 0x3, 0x2, 0x2, 0x2, 0xa7b, 0xa7c, 0x3, 0x2, 0x2, 0x2, 0xa7c, 
       0xa7d, 0x3, 0x2, 0x2, 0x2, 0xa7d, 0xa7e, 0x7, 0x190, 0x2, 0x2, 0xa7e, 
       0xa7f, 0x5, 0x120, 0x91, 0x2, 0xa7f, 0xa80, 0x7, 0x15, 0x2, 0x2, 
       0xa80, 0xa82, 0x5, 0x2e6, 0x174, 0x2, 0xa81, 0xa83, 0x5, 0x128, 0x95, 
       0x2, 0xa82, 0xa81, 0x3, 0x2, 0x2, 0x2, 0xa82, 0xa83, 0x3, 0x2, 0x2, 
       0x2, 0xa83, 0xa85, 0x3, 0x2, 0x2, 0x2, 0xa84, 0xa86, 0x5, 0xdc, 0x6f, 
       0x2, 0xa85, 0xa84, 0x3, 0x2, 0x2, 0x2, 0xa85, 0xa86, 0x3, 0x2, 0x2, 
       0x2, 0xa86, 0xa88, 0x3, 0x2, 0x2, 0x2, 0xa87, 0xa89, 0x5, 0x114, 
       0x8b, 0x2, 0xa88, 0xa87, 0x3, 0x2, 0x2, 0x2, 0xa88, 0xa89, 0x3, 0x2, 
       0x2, 0x2, 0xa89, 0x11f, 0x3, 0x2, 0x2, 0x2, 0xa8a, 0xa8c, 0x5, 0x3fa, 
       0x1fe, 0x2, 0xa8b, 0xa8d, 0x5, 0x122, 0x92, 0x2, 0xa8c, 0xa8b, 0x3, 
       0x2, 0x2, 0x2, 0xa8c, 0xa8d, 0x3, 0x2, 0x2, 0x2, 0xa8d, 0xa8f, 0x3, 
       0x2, 0x2, 0x2, 0xa8e, 0xa90, 0x5, 0xd2, 0x6a, 0x2, 0xa8f, 0xa8e, 
       0x3, 0x2, 0x2, 0x2, 0xa8f, 0xa90, 0x3, 0x2, 0x2, 0x2, 0xa90, 0xa92, 
       0x3, 0x2, 0x2, 0x2, 0xa91, 0xa93, 0x5, 0xd4, 0x6b, 0x2, 0xa92, 0xa91, 
       0x3, 0x2, 0x2, 0x2, 0xa92, 0xa93, 0x3, 0x2, 0x2, 0x2, 0xa93, 0xa95, 
       0x3, 0x2, 0x2, 0x2, 0xa94, 0xa96, 0x5, 0xd6, 0x6c, 0x2, 0xa95, 0xa94, 
       0x3, 0x2, 0x2, 0x2, 0xa95, 0xa96, 0x3, 0x2, 0x2, 0x2, 0xa96, 0x121, 
       0x3, 0x2, 0x2, 0x2, 0xa97, 0xa98, 0x7, 0x1d9, 0x2, 0x2, 0xa98, 0xa99, 
       0x5, 0x124, 0x93, 0x2, 0xa99, 0xa9a, 0x7, 0x1da, 0x2, 0x2, 0xa9a, 
       0x123, 0x3, 0x2, 0x2, 0x2, 0xa9b, 0xaa0, 0x5, 0x126, 0x94, 0x2, 0xa9c, 
       0xa9d, 0x7, 0x1df, 0x2, 0x2, 0xa9d, 0xa9f, 0x5, 0x126, 0x94, 0x2, 
       0xa9e, 0xa9c, 0x3, 0x2, 0x2, 0x2, 0xa9f, 0xaa2, 0x3, 0x2, 0x2, 0x2, 
       0xaa0, 0xa9e, 0x3, 0x2, 0x2, 0x2, 0xaa0, 0xaa1, 0x3, 0x2, 0x2, 0x2, 
       0xaa1, 0x125, 0x3, 0x2, 0x2, 0x2, 0xaa2, 0xaa0, 0x3, 0x2, 0x2, 0x2, 
       0xaa3, 0xaa4, 0x5, 0x41a, 0x20e, 0x2, 0xaa4, 0x127, 0x3, 0x2, 0x2, 
       0x2, 0xaa5, 0xaa7, 0x7, 0x1c4, 0x2, 0x2, 0xaa6, 0xaa8, 0x7, 0xfe, 
       0x2, 0x2, 0xaa7, 0xaa6, 0x3, 0x2, 0x2, 0x2, 0xaa7, 0xaa8, 0x3, 0x2, 
       0x2, 0x2, 0xaa8, 0xaa9, 0x3, 0x2, 0x2, 0x2, 0xaa9, 0xaae, 0x7, 0x5e, 
       0x2, 0x2, 0xaaa, 0xaab, 0x7, 0x1c4, 0x2, 0x2, 0xaab, 0xaac, 0x7, 
       0xfe, 0x2, 0x2, 0xaac, 0xaae, 0x7, 0x5e, 0x2, 0x2, 0xaad, 0xaa5, 
       0x3, 0x2, 0x2, 0x2, 0xaad, 0xaaa, 0x3, 0x2, 0x2, 0x2, 0xaae, 0x129, 
       0x3, 0x2, 0x2, 0x2, 0xaaf, 0xab1, 0x7, 0x4b, 0x2, 0x2, 0xab0, 0xab2, 
       0x5, 0x12c, 0x97, 0x2, 0xab1, 0xab0, 0x3, 0x2, 0x2, 0x2, 0xab1, 0xab2, 
       0x3, 0x2, 0x2, 0x2, 0xab2, 0xab3, 0x3, 0x2, 0x2, 0x2, 0xab3, 0xab5, 
       0x7, 0x8d, 0x2, 0x2, 0xab4, 0xab6, 0x7, 0x1bf, 0x2, 0x2, 0xab5, 0xab4, 
       0x3, 0x2, 0x2, 0x2, 0xab5, 0xab6, 0x3, 0x2, 0x2, 0x2, 0xab6, 0xab8, 
       0x3, 0x2, 0x2, 0x2, 0xab7, 0xab9, 0x5, 0xa4, 0x53, 0x2, 0xab8, 0xab7, 
       0x3, 0x2, 0x2, 0x2, 0xab8, 0xab9, 0x3, 0x2, 0x2, 0x2, 0xab9, 0xaba, 
       0x3, 0x2, 0x2, 0x2, 0xaba, 0xabb, 0x7, 0x190, 0x2, 0x2, 0xabb, 0xabc, 
       0x5, 0x3fa, 0x1fe, 0x2, 0xabc, 0xabe, 0x7, 0x1d9, 0x2, 0x2, 0xabd, 
       0xabf, 0x5, 0x146, 0xa4, 0x2, 0xabe, 0xabd, 0x3, 0x2, 0x2, 0x2, 0xabe, 
       0xabf, 0x3, 0x2, 0x2, 0x2, 0xabf, 0xac0, 0x3, 0x2, 0x2, 0x2, 0xac0, 
       0xac1, 0x7, 0x1da, 0x2, 0x2, 0xac1, 0xac2, 0x5, 0x12e, 0x98, 0x2, 
       0xac2, 0xac3, 0x7, 0x9c, 0x2, 0x2, 0xac3, 0xac5, 0x5, 0x412, 0x20a, 
       0x2, 0xac4, 0xac6, 0x5, 0x134, 0x9b, 0x2, 0xac5, 0xac4, 0x3, 0x2, 
       0x2, 0x2, 0xac5, 0xac6, 0x3, 0x2, 0x2, 0x2, 0xac6, 0xac8, 0x3, 0x2, 
       0x2, 0x2, 0xac7, 0xac9, 0x5, 0x13e, 0xa0, 0x2, 0xac8, 0xac7, 0x3, 
       0x2, 0x2, 0x2, 0xac8, 0xac9, 0x3, 0x2, 0x2, 0x2, 0xac9, 0xacb, 0x3, 
       0x2, 0x2, 0x2, 0xaca, 0xacc, 0x5, 0x152, 0xaa, 0x2, 0xacb, 0xaca, 
       0x3, 0x2, 0x2, 0x2, 0xacb, 0xacc, 0x3, 0x2, 0x2, 0x2, 0xacc, 0xace, 
       0x3, 0x2, 0x2, 0x2, 0xacd, 0xacf, 0x5, 0x14c, 0xa7, 0x2, 0xace, 0xacd, 
       0x3, 0x2, 0x2, 0x2, 0xace, 0xacf, 0x3, 0x2, 0x2, 0x2, 0xacf, 0xad1, 
       0x3, 0x2, 0x2, 0x2, 0xad0, 0xad2, 0x5, 0xdc, 0x6f, 0x2, 0xad1, 0xad0, 
       0x3, 0x2, 0x2, 0x2, 0xad1, 0xad2, 0x3, 0x2, 0x2, 0x2, 0xad2, 0x12b, 
       0x3, 0x2, 0x2, 0x2, 0xad3, 0xad4, 0x9, 0x19, 0x2, 0x2, 0xad4, 0x12d, 
       0x3, 0x2, 0x2, 0x2, 0xad5, 0xad6, 0x7, 0xe1, 0x2, 0x2, 0xad6, 0xad7, 
       0x7, 0x1d9, 0x2, 0x2, 0xad7, 0xad8, 0x5, 0x2bc, 0x15f, 0x2, 0xad8, 
       0xadc, 0x7, 0x1da, 0x2, 0x2, 0xad9, 0xadb, 0x5, 0x130, 0x99, 0x2, 
       0xada, 0xad9, 0x3, 0x2, 0x2, 0x2, 0xadb, 0xade, 0x3, 0x2, 0x2, 0x2, 
       0xadc, 0xada, 0x3, 0x2, 0x2, 0x2, 0xadc, 0xadd, 0x3, 0x2, 0x2, 0x2, 
       0xadd, 0xae8, 0x3, 0x2, 0x2, 0x2, 0xade, 0xadc, 0x3, 0x2, 0x2, 0x2, 
       0xadf, 0xae0, 0x7, 0x89, 0x2, 0x2, 0xae0, 0xae4, 0x5, 0x412, 0x20a, 
       0x2, 0xae1, 0xae3, 0x5, 0x130, 0x99, 0x2, 0xae2, 0xae1, 0x3, 0x2, 
       0x2, 0x2, 0xae3, 0xae6, 0x3, 0x2, 0x2, 0x2, 0xae4, 0xae2, 0x3, 0x2, 
       0x2, 0x2, 0xae4, 0xae5, 0x3, 0x2, 0x2, 0x2, 0xae5, 0xae8, 0x3, 0x2, 
       0x2, 0x2, 0xae6, 0xae4, 0x3, 0x2, 0x2, 0x2, 0xae7, 0xad5, 0x3, 0x2, 
       0x2, 0x2, 0xae7, 0xadf, 0x3, 0x2, 0x2, 0x2, 0xae8, 0x12f, 0x3, 0x2, 
       0x2, 0x2, 0xae9, 0xaea, 0x7, 0x119, 0x2, 0x2, 0xaea, 0xaf8, 0x7, 
       0xc, 0x2, 0x2, 0xaeb, 0xaec, 0x7, 0x119, 0x2, 0x2, 0xaec, 0xaee, 
       0x7, 0xae, 0x2, 0x2, 0xaed, 0xaef, 0x5, 0x412, 0x20a, 0x2, 0xaee, 
       0xaed, 0x3, 0x2, 0x2, 0x2, 0xaee, 0xaef, 0x3, 0x2, 0x2, 0x2, 0xaef, 
       0xaf8, 0x3, 0x2, 0x2, 0x2, 0xaf0, 0xaf1, 0x7, 0x119, 0x2, 0x2, 0xaf1, 
       0xaf8, 0x7, 0xe6, 0x2, 0x2, 0xaf2, 0xaf4, 0x7, 0x119, 0x2, 0x2, 0xaf3, 
       0xaf5, 0x7, 0x16e, 0x2, 0x2, 0xaf4, 0xaf3, 0x3, 0x2, 0x2, 0x2, 0xaf4, 
       0xaf5, 0x3, 0x2, 0x2, 0x2, 0xaf5, 0xaf6, 0x3, 0x2, 0x2, 0x2, 0xaf6, 
       0xaf8, 0x5, 0x410, 0x209, 0x2, 0xaf7, 0xae9, 0x3, 0x2, 0x2, 0x2, 
       0xaf7, 0xaeb, 0x3, 0x2, 0x2, 0x2, 0xaf7, 0xaf0, 0x3, 0x2, 0x2, 0x2, 
       0xaf7, 0xaf2, 0x3, 0x2, 0x2, 0x2, 0xaf8, 0x131, 0x3, 0x2, 0x2, 0x2, 
       0xaf9, 0xafa, 0x7, 0x1d9, 0x2, 0x2, 0xafa, 0xafb, 0x7, 0x1da, 0x2, 
       0x2, 0xafb, 0x133, 0x3, 0x2, 0x2, 0x2, 0xafc, 0xafd, 0x7, 0x1d9, 
       0x2, 0x2, 0xafd, 0xafe, 0x5, 0x136, 0x9c, 0x2, 0xafe, 0xaff, 0x7, 
       0x1da, 0x2, 0x2, 0xaff, 0xb06, 0x3, 0x2, 0x2, 0x2, 0xb00, 0xb01, 
       0x7, 0x1d9, 0x2, 0x2, 0xb01, 0xb02, 0x5, 0x138, 0x9d, 0x2, 0xb02, 
       0xb03, 0x7, 0x1da, 0x2, 0x2, 0xb03, 0xb06, 0x3, 0x2, 0x2, 0x2, 0xb04, 
       0xb06, 0x5, 0x132, 0x9a, 0x2, 0xb05, 0xafc, 0x3, 0x2, 0x2, 0x2, 0xb05, 
       0xb00, 0x3, 0x2, 0x2, 0x2, 0xb05, 0xb04, 0x3, 0x2, 0x2, 0x2, 0xb06, 
       0x135, 0x3, 0x2, 0x2, 0x2, 0xb07, 0xb09, 0x5, 0x13c, 0x9f, 0x2, 0xb08, 
       0xb07, 0x3, 0x2, 0x2, 0x2, 0xb09, 0xb0a, 0x3, 0x2, 0x2, 0x2, 0xb0a, 
       0xb08, 0x3, 0x2, 0x2, 0x2, 0xb0a, 0xb0b, 0x3, 0x2, 0x2, 0x2, 0xb0b, 
       0x137, 0x3, 0x2, 0x2, 0x2, 0xb0c, 0xb11, 0x5, 0x13a, 0x9e, 0x2, 0xb0d, 
       0xb0e, 0x7, 0x1df, 0x2, 0x2, 0xb0e, 0xb10, 0x5, 0x13a, 0x9e, 0x2, 
       0xb0f, 0xb0d, 0x3, 0x2, 0x2, 0x2, 0xb10, 0xb13, 0x3, 0x2, 0x2, 0x2, 
       0xb11, 0xb0f, 0x3, 0x2, 0x2, 0x2, 0xb11, 0xb12, 0x3, 0x2, 0x2, 0x2, 
       0xb12, 0x139, 0x3, 0x2, 0x2, 0x2, 0xb13, 0xb11, 0x3, 0x2, 0x2, 0x2, 
       0xb14, 0xb15, 0x5, 0x41e, 0x210, 0x2, 0xb15, 0xb16, 0x7, 0x1f1, 0x2, 
       0x2, 0xb16, 0xb17, 0x5, 0x1b2, 0xda, 0x2, 0xb17, 0xb1d, 0x3, 0x2, 
       0x2, 0x2, 0xb18, 0xb19, 0x5, 0x41e, 0x210, 0x2, 0xb19, 0xb1a, 0x7, 
       0x1f1, 0x2, 0x2, 0xb1a, 0xb1b, 0x5, 0xc0, 0x61, 0x2, 0xb1b, 0xb1d, 
       0x3, 0x2, 0x2, 0x2, 0xb1c, 0xb14, 0x3, 0x2, 0x2, 0x2, 0xb1c, 0xb18, 
       0x3, 0x2, 0x2, 0x2, 0xb1d, 0x13b, 0x3, 0x2, 0x2, 0x2, 0xb1e, 0xb20, 
       0x7, 0x6b, 0x2, 0x2, 0xb1f, 0xb21, 0x7, 0x15, 0x2, 0x2, 0xb20, 0xb1f, 
       0x3, 0x2, 0x2, 0x2, 0xb20, 0xb21, 0x3, 0x2, 0x2, 0x2, 0xb21, 0xb22, 
       0x3, 0x2, 0x2, 0x2, 0xb22, 0xb35, 0x5, 0x412, 0x20a, 0x2, 0xb23, 
       0xb25, 0x9, 0x1a, 0x2, 0x2, 0xb24, 0xb26, 0x7, 0x15, 0x2, 0x2, 0xb25, 
       0xb24, 0x3, 0x2, 0x2, 0x2, 0xb25, 0xb26, 0x3, 0x2, 0x2, 0x2, 0xb26, 
       0xb27, 0x3, 0x2, 0x2, 0x2, 0xb27, 0xb35, 0x5, 0x412, 0x20a, 0x2, 
       0xb28, 0xb35, 0x7, 0x51, 0x2, 0x2, 0xb29, 0xb35, 0x7, 0xac, 0x2, 
       0x2, 0xb2a, 0xb2e, 0x7, 0x9a, 0x2, 0x2, 0xb2b, 0xb2c, 0x7, 0x108, 
       0x2, 0x2, 0xb2c, 0xb2f, 0x7, 0x10e, 0x2, 0x2, 0xb2d, 0xb2f, 0x7, 
       0x144, 0x2, 0x2, 0xb2e, 0xb2b, 0x3, 0x2, 0x2, 0x2, 0xb2e, 0xb2d, 
       0x3, 0x2, 0x2, 0x2, 0xb2f, 0xb30, 0x3, 0x2, 0x2, 0x2, 0xb30, 0xb35, 
       0x5, 0xc2, 0x62, 0x2, 0xb31, 0xb32, 0x7, 0x94, 0x2, 0x2, 0xb32, 0xb33, 
       0x7, 0xf0, 0x2, 0x2, 0xb33, 0xb35, 0x7, 0x92, 0x2, 0x2, 0xb34, 0xb1e, 
       0x3, 0x2, 0x2, 0x2, 0xb34, 0xb23, 0x3, 0x2, 0x2, 0x2, 0xb34, 0xb28, 
       0x3, 0x2, 0x2, 0x2, 0xb34, 0xb29, 0x3, 0x2, 0x2, 0x2, 0xb34, 0xb2a, 
       0x3, 0x2, 0x2, 0x2, 0xb34, 0xb31, 0x3, 0x2, 0x2, 0x2, 0xb35, 0x13d, 
       0x3, 0x2, 0x2, 0x2, 0xb36, 0xb37, 0x7, 0x11d, 0x2, 0x2, 0xb37, 0xb38, 
       0x5, 0x140, 0xa1, 0x2, 0xb38, 0x13f, 0x3, 0x2, 0x2, 0x2, 0xb39, 0xb3a, 
       0x7, 0x1d9, 0x2, 0x2, 0xb3a, 0xb3b, 0x5, 0x142, 0xa2, 0x2, 0xb3b, 
       0xb3c, 0x7, 0x1da, 0x2, 0x2, 0xb3c, 0xb3f, 0x3, 0x2, 0x2, 0x2, 0xb3d, 
       0xb3f, 0x5, 0x132, 0x9a, 0x2, 0xb3e, 0xb39, 0x3, 0x2, 0x2, 0x2, 0xb3e, 
       0xb3d, 0x3, 0x2, 0x2, 0x2, 0xb3f, 0x141, 0x3, 0x2, 0x2, 0x2, 0xb40, 
       0xb45, 0x5, 0x144, 0xa3, 0x2, 0xb41, 0xb42, 0x7, 0x1df, 0x2, 0x2, 
       0xb42, 0xb44, 0x5, 0x144, 0xa3, 0x2, 0xb43, 0xb41, 0x3, 0x2, 0x2, 
       0x2, 0xb44, 0xb47, 0x3, 0x2, 0x2, 0x2, 0xb45, 0xb43, 0x3, 0x2, 0x2, 
       0x2, 0xb45, 0xb46, 0x3, 0x2, 0x2, 0x2, 0xb46, 0x143, 0x3, 0x2, 0x2, 
       0x2, 0xb47, 0xb45, 0x3, 0x2, 0x2, 0x2, 0xb48, 0xb49, 0x5, 0x41e, 
       0x210, 0x2, 0xb49, 0xb4a, 0x5, 0x412, 0x20a, 0x2, 0xb4a, 0x145, 0x3, 
       0x2, 0x2, 0x2, 0xb4b, 0xb50, 0x5, 0x148, 0xa5, 0x2, 0xb4c, 0xb4d, 
       0x7, 0x1df, 0x2, 0x2, 0xb4d, 0xb4f, 0x5, 0x148, 0xa5, 0x2, 0xb4e, 
       0xb4c, 0x3, 0x2, 0x2, 0x2, 0xb4f, 0xb52, 0x3, 0x2, 0x2, 0x2, 0xb50, 
       0xb4e, 0x3, 0x2, 0x2, 0x2, 0xb50, 0xb51, 0x3, 0x2, 0x2, 0x2, 0xb51, 
       0x147, 0x3, 0x2, 0x2, 0x2, 0xb52, 0xb50, 0x3, 0x2, 0x2, 0x2, 0xb53, 
       0xb56, 0x5, 0x14a, 0xa6, 0x2, 0xb54, 0xb56, 0x5, 0xb6, 0x5c, 0x2, 
       0xb55, 0xb53, 0x3, 0x2, 0x2, 0x2, 0xb55, 0xb54, 0x3, 0x2, 0x2, 0x2, 
       0xb56, 0x149, 0x3, 0x2, 0x2, 0x2, 0xb57, 0xb58, 0x5, 0x41a, 0x20e, 
       0x2, 0xb58, 0xb59, 0x5, 0x33a, 0x19e, 0x2, 0xb59, 0x14b, 0x3, 0x2, 
       0x2, 0x2, 0xb5a, 0xb5c, 0x5, 0x14e, 0xa8, 0x2, 0xb5b, 0xb5a, 0x3, 
       0x2, 0x2, 0x2, 0xb5b, 0xb5c, 0x3, 0x2, 0x2, 0x2, 0xb5c, 0xb5d, 0x3, 
       0x2, 0x2, 0x2, 0xb5d, 0xb5e, 0x7, 0x16e, 0x2, 0x2, 0xb5e, 0xb5f, 
       0x7, 0x151, 0x2, 0x2, 0xb5f, 0xb60, 0x7, 0xda, 0x2, 0x2, 0xb60, 0xb62, 
       0x5, 0x410, 0x209, 0x2, 0xb61, 0xb63, 0x5, 0x150, 0xa9, 0x2, 0xb62, 
       0xb61, 0x3, 0x2, 0x2, 0x2, 0xb62, 0xb63, 0x3, 0x2, 0x2, 0x2, 0xb63, 
       0x14d, 0x3, 0x2, 0x2, 0x2, 0xb64, 0xb65, 0x7, 0xe4, 0x2, 0x2, 0xb65, 
       0xb66, 0x7, 0x81, 0x2, 0x2, 0xb66, 0xb67, 0x7, 0xca, 0x2, 0x2, 0xb67, 
       0xb6b, 0x5, 0x3fa, 0x1fe, 0x2, 0xb68, 0xb69, 0x7, 0xe4, 0x2, 0x2, 
       0xb69, 0xb6b, 0x7, 0x81, 0x2, 0x2, 0xb6a, 0xb64, 0x3, 0x2, 0x2, 0x2, 
       0xb6a, 0xb68, 0x3, 0x2, 0x2, 0x2, 0xb6b, 0x14f, 0x3, 0x2, 0x2, 0x2, 
       0xb6c, 0xb6d, 0x9, 0x1b, 0x2, 0x2, 0xb6d, 0x151, 0x3, 0x2, 0x2, 0x2, 
       0xb6e, 0xb70, 0x5, 0x154, 0xab, 0x2, 0xb6f, 0xb6e, 0x3, 0x2, 0x2, 
       0x2, 0xb70, 0xb71, 0x3, 0x2, 0x2, 0x2, 0xb71, 0xb6f, 0x3, 0x2, 0x2, 
       0x2, 0xb71, 0xb72, 0x3, 0x2, 0x2, 0x2, 0xb72, 0x153, 0x3, 0x2, 0x2, 
       0x2, 0xb73, 0xb75, 0x7, 0x7d, 0x2, 0x2, 0xb74, 0xb76, 0x7, 0x1f1, 
       0x2, 0x2, 0xb75, 0xb74, 0x3, 0x2, 0x2, 0x2, 0xb75, 0xb76, 0x3, 0x2, 
       0x2, 0x2, 0xb76, 0xb79, 0x3, 0x2, 0x2, 0x2, 0xb77, 0xb7a, 0x5, 0x412, 
       0x20a, 0x2, 0xb78, 0xb7a, 0x5, 0x410, 0x209, 0x2, 0xb79, 0xb77, 0x3, 
       0x2, 0x2, 0x2, 0xb79, 0xb78, 0x3, 0x2, 0x2, 0x2, 0xb7a, 0x155, 0x3, 
       0x2, 0x2, 0x2, 0xb7b, 0xb7d, 0x7, 0x4b, 0x2, 0x2, 0xb7c, 0xb7e, 0x5, 
       0xa4, 0x53, 0x2, 0xb7d, 0xb7c, 0x3, 0x2, 0x2, 0x2, 0xb7d, 0xb7e, 
       0x3, 0x2, 0x2, 0x2, 0xb7e, 0xb7f, 0x3, 0x2, 0x2, 0x2, 0xb7f, 0xb80, 
       0x7, 0x170, 0x2, 0x2, 0xb80, 0xb82, 0x5, 0x3fa, 0x1fe, 0x2, 0xb81, 
       0xb83, 0x5, 0x15a, 0xae, 0x2, 0xb82, 0xb81, 0x3, 0x2, 0x2, 0x2, 0xb82, 
       0xb83, 0x3, 0x2, 0x2, 0x2, 0xb83, 0x157, 0x3, 0x2, 0x2, 0x2, 0xb84, 
       0xb85, 0x7, 0xe, 0x2, 0x2, 0xb85, 0xb86, 0x7, 0x170, 0x2, 0x2, 0xb86, 
       0xb88, 0x5, 0x3fa, 0x1fe, 0x2, 0xb87, 0xb89, 0x5, 0x15a, 0xae, 0x2, 
       0xb88, 0xb87, 0x3, 0x2, 0x2, 0x2, 0xb88, 0xb89, 0x3, 0x2, 0x2, 0x2, 
       0xb89, 0x159, 0x3, 0x2, 0x2, 0x2, 0xb8a, 0xb8c, 0x5, 0x15c, 0xaf, 
       0x2, 0xb8b, 0xb8a, 0x3, 0x2, 0x2, 0x2, 0xb8c, 0xb8d, 0x3, 0x2, 0x2, 
       0x2, 0xb8d, 0xb8b, 0x3, 0x2, 0x2, 0x2, 0xb8d, 0xb8e, 0x3, 0x2, 0x2, 
       0x2, 0xb8e, 0x15b, 0x3, 0x2, 0x2, 0x2, 0xb8f, 0xb90, 0x7, 0x26, 0x2, 
       0x2, 0xb90, 0xba9, 0x5, 0x15e, 0xb0, 0x2, 0xb91, 0xb93, 0x7, 0xfe, 
       0x2, 0x2, 0xb92, 0xb91, 0x3, 0x2, 0x2, 0x2, 0xb92, 0xb93, 0x3, 0x2, 
       0x2, 0x2, 0xb93, 0xb94, 0x3, 0x2, 0x2, 0x2, 0xb94, 0xba9, 0x7, 0x5c, 
       0x2, 0x2, 0xb95, 0xb96, 0x7, 0xfe, 0x2, 0x2, 0xb96, 0xba9, 0x7, 0x5c, 
       0x2, 0x2, 0xb97, 0xb99, 0x7, 0xb9, 0x2, 0x2, 0xb98, 0xb9a, 0x7, 0x25, 
       0x2, 0x2, 0xb99, 0xb98, 0x3, 0x2, 0x2, 0x2, 0xb99, 0xb9a, 0x3, 0x2, 
       0x2, 0x2, 0xb9a, 0xb9b, 0x3, 0x2, 0x2, 0x2, 0xb9b, 0xba9, 0x5, 0x15e, 
       0xb0, 0x2, 0xb9c, 0xb9d, 0x9, 0x1c, 0x2, 0x2, 0xb9d, 0xba9, 0x5, 
       0x15e, 0xb0, 0x2, 0xb9e, 0xb9f, 0x7, 0xfe, 0x2, 0x2, 0xb9f, 0xba9, 
       0x9, 0x1c, 0x2, 0x2, 0xba0, 0xba1, 0x7, 0x128, 0x2, 0x2, 0xba1, 0xba2, 
       0x7, 0x25, 0x2, 0x2, 0xba2, 0xba9, 0x5, 0x1dc, 0xef, 0x2, 0xba3, 
       0xba5, 0x9, 0x1d, 0x2, 0x2, 0xba4, 0xba6, 0x5, 0x1c, 0xf, 0x2, 0xba5, 
       0xba4, 0x3, 0x2, 0x2, 0x2, 0xba5, 0xba6, 0x3, 0x2, 0x2, 0x2, 0xba6, 
       0xba7, 0x3, 0x2, 0x2, 0x2, 0xba7, 0xba9, 0x5, 0x15e, 0xb0, 0x2, 0xba8, 
       0xb8f, 0x3, 0x2, 0x2, 0x2, 0xba8, 0xb92, 0x3, 0x2, 0x2, 0x2, 0xba8, 
       0xb95, 0x3, 0x2, 0x2, 0x2, 0xba8, 0xb97, 0x3, 0x2, 0x2, 0x2, 0xba8, 
       0xb9c, 0x3, 0x2, 0x2, 0x2, 0xba8, 0xb9e, 0x3, 0x2, 0x2, 0x2, 0xba8, 
       0xba0, 0x3, 0x2, 0x2, 0x2, 0xba8, 0xba3, 0x3, 0x2, 0x2, 0x2, 0xba9, 
       0x15d, 0x3, 0x2, 0x2, 0x2, 0xbaa, 0xbad, 0x5, 0x160, 0xb1, 0x2, 0xbab, 
       0xbad, 0x5, 0x162, 0xb2, 0x2, 0xbac, 0xbaa, 0x3, 0x2, 0x2, 0x2, 0xbac, 
       0xbab, 0x3, 0x2, 0x2, 0x2, 0xbad, 0x15f, 0x3, 0x2, 0x2, 0x2, 0xbae, 
       0xbb0, 0x7, 0x1de, 0x2, 0x2, 0xbaf, 0xbae, 0x3, 0x2, 0x2, 0x2, 0xbaf, 
       0xbb0, 0x3, 0x2, 0x2, 0x2, 0xbb0, 0xbb1, 0x3, 0x2, 0x2, 0x2, 0xbb1, 
       0xbb2, 0x7, 0x1fc, 0x2, 0x2, 0xbb2, 0x161, 0x3, 0x2, 0x2, 0x2, 0xbb3, 
       0xbb4, 0x5, 0x418, 0x20d, 0x2, 0xbb4, 0x163, 0x3, 0x2, 0x2, 0x2, 
       0xbb5, 0xbb7, 0x7, 0x4b, 0x2, 0x2, 0xbb6, 0xbb8, 0x7, 0x1a3, 0x2, 
       0x2, 0xbb7, 0xbb6, 0x3, 0x2, 0x2, 0x2, 0xbb7, 0xbb8, 0x3, 0x2, 0x2, 
       0x2, 0xbb8, 0xbba, 0x3, 0x2, 0x2, 0x2, 0xbb9, 0xbbb, 0x7, 0x13e, 
       0x2, 0x2, 0xbba, 0xbb9, 0x3, 0x2, 0x2, 0x2, 0xbba, 0xbbb, 0x3, 0x2, 
       0x2, 0x2, 0xbbb, 0xbbc, 0x3, 0x2, 0x2, 0x2, 0xbbc, 0xbbd, 0x7, 0xd2, 
       0x2, 0x2, 0xbbd, 0xbbf, 0x5, 0x62, 0x32, 0x2, 0xbbe, 0xbc0, 0x5, 
       0x166, 0xb4, 0x2, 0xbbf, 0xbbe, 0x3, 0x2, 0x2, 0x2, 0xbbf, 0xbc0, 
       0x3, 0x2, 0x2, 0x2, 0xbc0, 0x165, 0x3, 0x2, 0x2, 0x2, 0xbc1, 0xbc2, 
       0x7, 0xa9, 0x2, 0x2, 0xbc2, 0xbc4, 0x5, 0x168, 0xb5, 0x2, 0xbc3, 
       0xbc5, 0x5, 0x16a, 0xb6, 0x2, 0xbc4, 0xbc3, 0x3, 0x2, 0x2, 0x2, 0xbc4, 
       0xbc5, 0x3, 0x2, 0x2, 0x2, 0xbc5, 0xbc7, 0x3, 0x2, 0x2, 0x2, 0xbc6, 
       0xbc8, 0x5, 0x16e, 0xb8, 0x2, 0xbc7, 0xbc6, 0x3, 0x2, 0x2, 0x2, 0xbc7, 
       0xbc8, 0x3, 0x2, 0x2, 0x2, 0xbc8, 0x167, 0x3, 0x2, 0x2, 0x2, 0xbc9, 
       0xbce, 0x5, 0x3fe, 0x200, 0x2, 0xbca, 0xbcb, 0x5, 0x3fe, 0x200, 0x2, 
       0xbcb, 0xbcc, 0x5, 0x1de, 0xf0, 0x2, 0xbcc, 0xbce, 0x3, 0x2, 0x2, 
       0x2, 0xbcd, 0xbc9, 0x3, 0x2, 0x2, 0x2, 0xbcd, 0xbca, 0x3, 0x2, 0x2, 
       0x2, 0xbce, 0x169, 0x3, 0x2, 0x2, 0x2, 0xbcf, 0xbd0, 0x7, 0xbf, 0x2, 
       0x2, 0xbd0, 0xbd1, 0x5, 0x168, 0xb5, 0x2, 0xbd1, 0x16b, 0x3, 0x2, 
       0x2, 0x2, 0xbd2, 0xbd3, 0x7, 0x1b5, 0x2, 0x2, 0xbd3, 0xbd7, 0x5, 
       0x168, 0xb5, 0x2, 0xbd4, 0xbd5, 0x7, 0xfe, 0x2, 0x2, 0xbd5, 0xbd7, 
       0x7, 0x1b5, 0x2, 0x2, 0xbd6, 0xbd2, 0x3, 0x2, 0x2, 0x2, 0xbd6, 0xbd4, 
       0x3, 0x2, 0x2, 0x2, 0xbd7, 0x16d, 0x3, 0x2, 0x2, 0x2, 0xbd8, 0xbd9, 
       0x5, 0x16c, 0xb7, 0x2, 0xbd9, 0x16f, 0x3, 0x2, 0x2, 0x2, 0xbda, 0xbdc, 
       0x7, 0x78, 0x2, 0x2, 0xbdb, 0xbdd, 0x7, 0x13e, 0x2, 0x2, 0xbdc, 0xbdb, 
       0x3, 0x2, 0x2, 0x2, 0xbdc, 0xbdd, 0x3, 0x2, 0x2, 0x2, 0xbdd, 0xbde, 
       0x3, 0x2, 0x2, 0x2, 0xbde, 0xbe1, 0x7, 0xd2, 0x2, 0x2, 0xbdf, 0xbe0, 
       0x7, 0xb1, 0x2, 0x2, 0xbe0, 0xbe2, 0x7, 0x8a, 0x2, 0x2, 0xbe1, 0xbdf, 
       0x3, 0x2, 0x2, 0x2, 0xbe1, 0xbe2, 0x3, 0x2, 0x2, 0x2, 0xbe2, 0xbe3, 
       0x3, 0x2, 0x2, 0x2, 0xbe3, 0xbe5, 0x5, 0x62, 0x32, 0x2, 0xbe4, 0xbe6, 
       0x5, 0x8e, 0x48, 0x2, 0xbe5, 0xbe4, 0x3, 0x2, 0x2, 0x2, 0xbe5, 0xbe6, 
       0x3, 0x2, 0x2, 0x2, 0xbe6, 0x171, 0x3, 0x2, 0x2, 0x2, 0xbe7, 0xbe8, 
       0x7, 0x4b, 0x2, 0x2, 0xbe8, 0xbe9, 0x7, 0x93, 0x2, 0x2, 0xbe9, 0xbeb, 
       0x5, 0x3fe, 0x200, 0x2, 0xbea, 0xbec, 0x5, 0x178, 0xbd, 0x2, 0xbeb, 
       0xbea, 0x3, 0x2, 0x2, 0x2, 0xbeb, 0xbec, 0x3, 0x2, 0x2, 0x2, 0xbec, 
       0xbed, 0x3, 0x2, 0x2, 0x2, 0xbed, 0xbee, 0x7, 0x1d9, 0x2, 0x2, 0xbee, 
       0xbef, 0x5, 0x174, 0xbb, 0x2, 0xbef, 0xbf0, 0x7, 0x1da, 0x2, 0x2, 
       0xbf0, 0x173, 0x3, 0x2, 0x2, 0x2, 0xbf1, 0xbf6, 0x5, 0x176, 0xbc, 
       0x2, 0xbf2, 0xbf3, 0x7, 0x1df, 0x2, 0x2, 0xbf3, 0xbf5, 0x5, 0x176, 
       0xbc, 0x2, 0xbf4, 0xbf2, 0x3, 0x2, 0x2, 0x2, 0xbf5, 0xbf8, 0x3, 0x2, 
       0x2, 0x2, 0xbf6, 0xbf4, 0x3, 0x2, 0x2, 0x2, 0xbf6, 0xbf7, 0x3, 0x2, 
       0x2, 0x2, 0xbf7, 0x175, 0x3, 0x2, 0x2, 0x2, 0xbf8, 0xbf6, 0x3, 0x2, 
       0x2, 0x2, 0xbf9, 0xbfa, 0x5, 0x410, 0x209, 0x2, 0xbfa, 0xbfb, 0x7, 
       0x1ed, 0x2, 0x2, 0xbfb, 0xbfc, 0x5, 0x412, 0x20a, 0x2, 0xbfc, 0x177, 
       0x3, 0x2, 0x2, 0x2, 0xbfd, 0xbfe, 0x7, 0x129, 0x2, 0x2, 0xbfe, 0xbff, 
       0x5, 0x3fe, 0x200, 0x2, 0xbff, 0x179, 0x3, 0x2, 0x2, 0x2, 0xc00, 
       0xc01, 0x7, 0x4b, 0x2, 0x2, 0xc01, 0xc02, 0x7, 0x191, 0x2, 0x2, 0xc02, 
       0xc04, 0x5, 0x3fe, 0x200, 0x2, 0xc03, 0xc05, 0x5, 0x178, 0xbd, 0x2, 
       0xc04, 0xc03, 0x3, 0x2, 0x2, 0x2, 0xc04, 0xc05, 0x3, 0x2, 0x2, 0x2, 
       0xc05, 0xc06, 0x3, 0x2, 0x2, 0x2, 0xc06, 0xc07, 0x7, 0x93, 0x2, 0x2, 
       0xc07, 0xc08, 0x5, 0x3fe, 0x200, 0x2, 0xc08, 0x17b, 0x3, 0x2, 0x2, 
       0x2, 0xc09, 0xc0a, 0x7, 0x4b, 0x2, 0x2, 0xc0a, 0xc0e, 0x7, 0x8c, 
       0x2, 0x2, 0xc0b, 0xc0c, 0x7, 0xb1, 0x2, 0x2, 0xc0c, 0xc0d, 0x7, 0x108, 
       0x2, 0x2, 0xc0d, 0xc0f, 0x7, 0x8a, 0x2, 0x2, 0xc0e, 0xc0b, 0x3, 0x2, 
       0x2, 0x2, 0xc0e, 0xc0f, 0x3, 0x2, 0x2, 0x2, 0xc0f, 0xc10, 0x3, 0x2, 
       0x2, 0x2, 0xc10, 0xc12, 0x5, 0x3fe, 0x200, 0x2, 0xc11, 0xc13, 0x5, 
       0x1c, 0xf, 0x2, 0xc12, 0xc11, 0x3, 0x2, 0x2, 0x2, 0xc12, 0xc13, 0x3, 
       0x2, 0x2, 0x2, 0xc13, 0xc15, 0x3, 0x2, 0x2, 0x2, 0xc14, 0xc16, 0x5, 
       0x17e, 0xc0, 0x2, 0xc15, 0xc14, 0x3, 0x2, 0x2, 0x2, 0xc15, 0xc16, 
       0x3, 0x2, 0x2, 0x2, 0xc16, 0x17d, 0x3, 0x2, 0x2, 0x2, 0xc17, 0xc19, 
       0x5, 0x180, 0xc1, 0x2, 0xc18, 0xc17, 0x3, 0x2, 0x2, 0x2, 0xc19, 0xc1a, 
       0x3, 0x2, 0x2, 0x2, 0xc1a, 0xc18, 0x3, 0x2, 0x2, 0x2, 0xc1a, 0xc1b, 
       0x3, 0x2, 0x2, 0x2, 0xc1b, 0x17f, 0x3, 0x2, 0x2, 0x2, 0xc1c, 0xc1d, 
       0x7, 0x169, 0x2, 0x2, 0xc1d, 0xc23, 0x5, 0x3fe, 0x200, 0x2, 0xc1e, 
       0xc1f, 0x7, 0x1bc, 0x2, 0x2, 0xc1f, 0xc23, 0x5, 0x412, 0x20a, 0x2, 
       0xc20, 0xc21, 0x7, 0x9f, 0x2, 0x2, 0xc21, 0xc23, 0x5, 0x412, 0x20a, 
       0x2, 0xc22, 0xc1c, 0x3, 0x2, 0x2, 0x2, 0xc22, 0xc1e, 0x3, 0x2, 0x2, 
       0x2, 0xc22, 0xc20, 0x3, 0x2, 0x2, 0x2, 0xc23, 0x181, 0x3, 0x2, 0x2, 
       0x2, 0xc24, 0xc25, 0x7, 0xe, 0x2, 0x2, 0xc25, 0xc26, 0x7, 0x8c, 0x2, 
       0x2, 0xc26, 0xc27, 0x5, 0x3fe, 0x200, 0x2, 0xc27, 0xc29, 0x7, 0x1ae, 
       0x2, 0x2, 0xc28, 0xc2a, 0x5, 0x184, 0xc3, 0x2, 0xc29, 0xc28, 0x3, 
       0x2, 0x2, 0x2, 0xc29, 0xc2a, 0x3, 0x2, 0x2, 0x2, 0xc2a, 0x183, 0x3, 
       0x2, 0x2, 0x2, 0xc2b, 0xc2d, 0x5, 0x186, 0xc4, 0x2, 0xc2c, 0xc2b, 
       0x3, 0x2, 0x2, 0x2, 0xc2d, 0xc2e, 0x3, 0x2, 0x2, 0x2, 0xc2e, 0xc2c, 
       0x3, 0x2, 0x2, 0x2, 0xc2e, 0xc2f, 0x3, 0x2, 0x2, 0x2, 0xc2f, 0x185, 
       0x3, 0x2, 0x2, 0x2, 0xc30, 0xc31, 0x7, 0x19b, 0x2, 0x2, 0xc31, 0xc32, 
       0x5, 0x412, 0x20a, 0x2, 0xc32, 0x187, 0x3, 0x2, 0x2, 0x2, 0xc33, 
       0xc34, 0x7, 0xe, 0x2, 0x2, 0xc34, 0xc35, 0x7, 0x8c, 0x2, 0x2, 0xc35, 
       0xc36, 0x5, 0x3fe, 0x200, 0x2, 0xc36, 0xc37, 0x5, 0x44, 0x23, 0x2, 
       0xc37, 0xc38, 0x5, 0x18a, 0xc6, 0x2, 0xc38, 0x189, 0x3, 0x2, 0x2, 
       0x2, 0xc39, 0xc3a, 0x7, 0xb, 0x2, 0x2, 0xc3a, 0xc3b, 0x5, 0x40c, 
       0x207, 0x2, 0xc3b, 0xc3c, 0x5, 0x1b4, 0xdb, 0x2, 0xc3c, 0xc7a, 0x3, 
       0x2, 0x2, 0x2, 0xc3d, 0xc3e, 0x7, 0x2b, 0x2, 0x2, 0xc3e, 0xc3f, 0x7, 
       0x1d9, 0x2, 0x2, 0xc3f, 0xc40, 0x5, 0x33a, 0x19e, 0x2, 0xc40, 0xc41, 
       0x7, 0x15, 0x2, 0x2, 0xc41, 0xc42, 0x5, 0x33a, 0x19e, 0x2, 0xc42, 
       0xc43, 0x7, 0x1da, 0x2, 0x2, 0xc43, 0xc7a, 0x3, 0x2, 0x2, 0x2, 0xc44, 
       0xc45, 0x7, 0x46, 0x2, 0x2, 0xc45, 0xc7a, 0x5, 0x1dc, 0xef, 0x2, 
       0xc46, 0xc47, 0x7, 0x76, 0x2, 0x2, 0xc47, 0xc7a, 0x5, 0x1dc, 0xef, 
       0x2, 0xc48, 0xc49, 0x7, 0xa1, 0x2, 0x2, 0xc49, 0xc7a, 0x5, 0x204, 
       0x103, 0x2, 0xc4a, 0xc4c, 0x7, 0x13e, 0x2, 0x2, 0xc4b, 0xc4a, 0x3, 
       0x2, 0x2, 0x2, 0xc4b, 0xc4c, 0x3, 0x2, 0x2, 0x2, 0xc4c, 0xc4d, 0x3, 
       0x2, 0x2, 0x2, 0xc4d, 0xc4e, 0x7, 0xd2, 0x2, 0x2, 0xc4e, 0xc7a, 0x5, 
       0x3fe, 0x200, 0x2, 0xc4f, 0xc50, 0x7, 0x11b, 0x2, 0x2, 0xc50, 0xc51, 
       0x5, 0x24e, 0x128, 0x2, 0xc51, 0xc52, 0x5, 0x24c, 0x127, 0x2, 0xc52, 
       0xc7a, 0x3, 0x2, 0x2, 0x2, 0xc53, 0xc54, 0x7, 0x11b, 0x2, 0x2, 0xc54, 
       0xc55, 0x7, 0x32, 0x2, 0x2, 0xc55, 0xc56, 0x5, 0x1dc, 0xef, 0x2, 
       0xc56, 0xc57, 0x7, 0x1b1, 0x2, 0x2, 0xc57, 0xc58, 0x5, 0x404, 0x203, 
       0x2, 0xc58, 0xc7a, 0x3, 0x2, 0x2, 0x2, 0xc59, 0xc5a, 0x7, 0x11b, 
       0x2, 0x2, 0xc5a, 0xc5b, 0x7, 0x90, 0x2, 0x2, 0xc5b, 0xc5c, 0x5, 0x1dc, 
       0xef, 0x2, 0xc5c, 0xc5d, 0x7, 0x1b1, 0x2, 0x2, 0xc5d, 0xc5e, 0x5, 
       0x404, 0x203, 0x2, 0xc5e, 0xc7a, 0x3, 0x2, 0x2, 0x2, 0xc5f, 0xc60, 
       0x7, 0x169, 0x2, 0x2, 0xc60, 0xc7a, 0x5, 0x3fe, 0x200, 0x2, 0xc61, 
       0xc62, 0x7, 0x190, 0x2, 0x2, 0xc62, 0xc7a, 0x5, 0x1dc, 0xef, 0x2, 
       0xc63, 0xc64, 0x7, 0x195, 0x2, 0x2, 0xc64, 0xc65, 0x7, 0x16b, 0x2, 
       0x2, 0xc65, 0xc66, 0x7, 0x12a, 0x2, 0x2, 0xc66, 0xc7a, 0x5, 0x1dc, 
       0xef, 0x2, 0xc67, 0xc68, 0x7, 0x195, 0x2, 0x2, 0xc68, 0xc69, 0x7, 
       0x16b, 0x2, 0x2, 0xc69, 0xc6a, 0x7, 0x6f, 0x2, 0x2, 0xc6a, 0xc7a, 
       0x5, 0x1dc, 0xef, 0x2, 0xc6b, 0xc6c, 0x7, 0x195, 0x2, 0x2, 0xc6c, 
       0xc6d, 0x7, 0x16b, 0x2, 0x2, 0xc6d, 0xc6e, 0x7, 0x193, 0x2, 0x2, 
       0xc6e, 0xc7a, 0x5, 0x1dc, 0xef, 0x2, 0xc6f, 0xc70, 0x7, 0x195, 0x2, 
       0x2, 0xc70, 0xc71, 0x7, 0x16b, 0x2, 0x2, 0xc71, 0xc72, 0x7, 0x3e, 
       0x2, 0x2, 0xc72, 0xc7a, 0x5, 0x1dc, 0xef, 0x2, 0xc73, 0xc74, 0x7, 
       0x170, 0x2, 0x2, 0xc74, 0xc7a, 0x5, 0x1dc, 0xef, 0x2, 0xc75, 0xc76, 
       0x7, 0x1bd, 0x2, 0x2, 0xc76, 0xc7a, 0x5, 0x1dc, 0xef, 0x2, 0xc77, 
       0xc78, 0x7, 0x1a4, 0x2, 0x2, 0xc78, 0xc7a, 0x5, 0x1dc, 0xef, 0x2, 
       0xc79, 0xc39, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc3d, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc44, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc46, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc48, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc4b, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc4f, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc53, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc59, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc5f, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc61, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc63, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc67, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc6b, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc6f, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc73, 0x3, 0x2, 0x2, 0x2, 
       0xc79, 0xc75, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc77, 0x3, 0x2, 0x2, 0x2, 
       0xc7a, 0x18b, 0x3, 0x2, 0x2, 0x2, 0xc7b, 0xc7c, 0x7, 0x4b, 0x2, 0x2, 
       0xc7c, 0xc7d, 0x7, 0x19f, 0x2, 0x2, 0xc7d, 0xc7e, 0x5, 0x3fe, 0x200, 
       0x2, 0xc7e, 0xc7f, 0x5, 0x18e, 0xc8, 0x2, 0xc7f, 0xc80, 0x5, 0x190, 
       0xc9, 0x2, 0xc80, 0xc81, 0x7, 0x119, 0x2, 0x2, 0xc81, 0xc83, 0x5, 
       0x3fa, 0x1fe, 0x2, 0xc82, 0xc84, 0x5, 0x194, 0xcb, 0x2, 0xc83, 0xc82, 
       0x3, 0x2, 0x2, 0x2, 0xc83, 0xc84, 0x3, 0x2, 0x2, 0x2, 0xc84, 0xc85, 
       0x3, 0x2, 0x2, 0x2, 0xc85, 0xc86, 0x7, 0x89, 0x2, 0x2, 0xc86, 0xc87, 
       0x7, 0x13f, 0x2, 0x2, 0xc87, 0xc88, 0x5, 0x40c, 0x207, 0x2, 0xc88, 
       0xc8a, 0x7, 0x1d9, 0x2, 0x2, 0xc89, 0xc8b, 0x5, 0x198, 0xcd, 0x2, 
       0xc8a, 0xc89, 0x3, 0x2, 0x2, 0x2, 0xc8a, 0xc8b, 0x3, 0x2, 0x2, 0x2, 
       0xc8b, 0xc8c, 0x3, 0x2, 0x2, 0x2, 0xc8c, 0xc8d, 0x7, 0x1da, 0x2, 
       0x2, 0xc8d, 0xca9, 0x3, 0x2, 0x2, 0x2, 0xc8e, 0xc8f, 0x7, 0x4b, 0x2, 
       0x2, 0xc8f, 0xc90, 0x7, 0x41, 0x2, 0x2, 0xc90, 0xc91, 0x7, 0x19f, 
       0x2, 0x2, 0xc91, 0xc92, 0x5, 0x3fe, 0x200, 0x2, 0xc92, 0xc93, 0x7, 
       0xa, 0x2, 0x2, 0xc93, 0xc94, 0x5, 0x190, 0xc9, 0x2, 0xc94, 0xc95, 
       0x7, 0x119, 0x2, 0x2, 0xc95, 0xc97, 0x5, 0x3fa, 0x1fe, 0x2, 0xc96, 
       0xc98, 0x5, 0x19c, 0xcf, 0x2, 0xc97, 0xc96, 0x3, 0x2, 0x2, 0x2, 0xc97, 
       0xc98, 0x3, 0x2, 0x2, 0x2, 0xc98, 0xc9a, 0x3, 0x2, 0x2, 0x2, 0xc99, 
       0xc9b, 0x5, 0x19e, 0xd0, 0x2, 0xc9a, 0xc99, 0x3, 0x2, 0x2, 0x2, 0xc9a, 
       0xc9b, 0x3, 0x2, 0x2, 0x2, 0xc9b, 0xc9c, 0x3, 0x2, 0x2, 0x2, 0xc9c, 
       0xc9d, 0x7, 0x99, 0x2, 0x2, 0xc9d, 0xc9e, 0x7, 0x7a, 0x2, 0x2, 0xc9e, 
       0xc9f, 0x7, 0x164, 0x2, 0x2, 0xc9f, 0xca0, 0x7, 0x89, 0x2, 0x2, 0xca0, 
       0xca1, 0x7, 0x13f, 0x2, 0x2, 0xca1, 0xca2, 0x5, 0x40c, 0x207, 0x2, 
       0xca2, 0xca4, 0x7, 0x1d9, 0x2, 0x2, 0xca3, 0xca5, 0x5, 0x198, 0xcd, 
       0x2, 0xca4, 0xca3, 0x3, 0x2, 0x2, 0x2, 0xca4, 0xca5, 0x3, 0x2, 0x2, 
       0x2, 0xca5, 0xca6, 0x3, 0x2, 0x2, 0x2, 0xca6, 0xca7, 0x7, 0x1da, 
       0x2, 0x2, 0xca7, 0xca9, 0x3, 0x2, 0x2, 0x2, 0xca8, 0xc7b, 0x3, 0x2, 
       0x2, 0x2, 0xca8, 0xc8e, 0x3, 0x2, 0x2, 0x2, 0xca9, 0x18d, 0x3, 0x2, 
       0x2, 0x2, 0xcaa, 0xcab, 0x9, 0x1e, 0x2, 0x2, 0xcab, 0x18f, 0x3, 0x2, 
       0x2, 0x2, 0xcac, 0xcb1, 0x5, 0x192, 0xca, 0x2, 0xcad, 0xcae, 0x7, 
       0x11e, 0x2, 0x2, 0xcae, 0xcb0, 0x5, 0x192, 0xca, 0x2, 0xcaf, 0xcad, 
       0x3, 0x2, 0x2, 0x2, 0xcb0, 0xcb3, 0x3, 0x2, 0x2, 0x2, 0xcb1, 0xcaf, 
       0x3, 0x2, 0x2, 0x2, 0xcb1, 0xcb2, 0x3, 0x2, 0x2, 0x2, 0xcb2, 0x191, 
       0x3, 0x2, 0x2, 0x2, 0xcb3, 0xcb1, 0x3, 0x2, 0x2, 0x2, 0xcb4, 0xcb5, 
       0x9, 0x1f, 0x2, 0x2, 0xcb5, 0x193, 0x3, 0x2, 0x2, 0x2, 0xcb6, 0xcb8, 
       0x7, 0x99, 0x2, 0x2, 0xcb7, 0xcb9, 0x7, 0x7a, 0x2, 0x2, 0xcb8, 0xcb7, 
       0x3, 0x2, 0x2, 0x2, 0xcb8, 0xcb9, 0x3, 0x2, 0x2, 0x2, 0xcb9, 0xcba, 
       0x3, 0x2, 0x2, 0x2, 0xcba, 0xcbb, 0x5, 0x196, 0xcc, 0x2, 0xcbb, 0x195, 
       0x3, 0x2, 0x2, 0x2, 0xcbc, 0xcbd, 0x9, 0x20, 0x2, 0x2, 0xcbd, 0x197, 
       0x3, 0x2, 0x2, 0x2, 0xcbe, 0xcc3, 0x5, 0x19a, 0xce, 0x2, 0xcbf, 0xcc0, 
       0x7, 0x1df, 0x2, 0x2, 0xcc0, 0xcc2, 0x5, 0x19a, 0xce, 0x2, 0xcc1, 
       0xcbf, 0x3, 0x2, 0x2, 0x2, 0xcc2, 0xcc5, 0x3, 0x2, 0x2, 0x2, 0xcc3, 
       0xcc1, 0x3, 0x2, 0x2, 0x2, 0xcc3, 0xcc4, 0x3, 0x2, 0x2, 0x2, 0xcc4, 
       0x199, 0x3, 0x2, 0x2, 0x2, 0xcc5, 0xcc3, 0x3, 0x2, 0x2, 0x2, 0xcc6, 
       0xccd, 0x7, 0x1fb, 0x2, 0x2, 0xcc7, 0xccd, 0x7, 0x1fc, 0x2, 0x2, 
       0xcc8, 0xccd, 0x5, 0x412, 0x20a, 0x2, 0xcc9, 0xccd, 0x7, 0x1fd, 0x2, 
       0x2, 0xcca, 0xccd, 0x7, 0x1fe, 0x2, 0x2, 0xccb, 0xccd, 0x5, 0x41a, 
       0x20e, 0x2, 0xccc, 0xcc6, 0x3, 0x2, 0x2, 0x2, 0xccc, 0xcc7, 0x3, 
       0x2, 0x2, 0x2, 0xccc, 0xcc8, 0x3, 0x2, 0x2, 0x2, 0xccc, 0xcc9, 0x3, 
       0x2, 0x2, 0x2, 0xccc, 0xcca, 0x3, 0x2, 0x2, 0x2, 0xccc, 0xccb, 0x3, 
       0x2, 0x2, 0x2, 0xccd, 0x19b, 0x3, 0x2, 0x2, 0x2, 0xcce, 0xccf, 0x7, 
       0x9f, 0x2, 0x2, 0xccf, 0xcd0, 0x5, 0x3fa, 0x1fe, 0x2, 0xcd0, 0x19d, 
       0x3, 0x2, 0x2, 0x2, 0xcd1, 0xcd3, 0x5, 0x1a0, 0xd1, 0x2, 0xcd2, 0xcd4, 
       0x5, 0x1a2, 0xd2, 0x2, 0xcd3, 0xcd2, 0x3, 0x2, 0x2, 0x2, 0xcd3, 0xcd4, 
       0x3, 0x2, 0x2, 0x2, 0xcd4, 0xcda, 0x3, 0x2, 0x2, 0x2, 0xcd5, 0xcd7, 
       0x5, 0x1a2, 0xd2, 0x2, 0xcd6, 0xcd8, 0x5, 0x1a0, 0xd1, 0x2, 0xcd7, 
       0xcd6, 0x3, 0x2, 0x2, 0x2, 0xcd7, 0xcd8, 0x3, 0x2, 0x2, 0x2, 0xcd8, 
       0xcda, 0x3, 0x2, 0x2, 0x2, 0xcd9, 0xcd1, 0x3, 0x2, 0x2, 0x2, 0xcd9, 
       0xcd5, 0x3, 0x2, 0x2, 0x2, 0xcda, 0x19f, 0x3, 0x2, 0x2, 0x2, 0xcdb, 
       0xcdd, 0x7, 0x108, 0x2, 0x2, 0xcdc, 0xcdb, 0x3, 0x2, 0x2, 0x2, 0xcdc, 
       0xcdd, 0x3, 0x2, 0x2, 0x2, 0xcdd, 0xcde, 0x3, 0x2, 0x2, 0x2, 0xcde, 
       0xcdf, 0x7, 0x67, 0x2, 0x2, 0xcdf, 0x1a1, 0x3, 0x2, 0x2, 0x2, 0xce0, 
       0xce1, 0x7, 0xbe, 0x2, 0x2, 0xce1, 0xce2, 0x9, 0x8, 0x2, 0x2, 0xce2, 
       0x1a3, 0x3, 0x2, 0x2, 0x2, 0xce3, 0xce4, 0x7, 0x78, 0x2, 0x2, 0xce4, 
       0xce5, 0x7, 0x19f, 0x2, 0x2, 0xce5, 0xce6, 0x5, 0x3fe, 0x200, 0x2, 
       0xce6, 0xce7, 0x7, 0x119, 0x2, 0x2, 0xce7, 0xce9, 0x5, 0x3fa, 0x1fe, 
       0x2, 0xce8, 0xcea, 0x5, 0x8e, 0x48, 0x2, 0xce9, 0xce8, 0x3, 0x2, 
       0x2, 0x2, 0xce9, 0xcea, 0x3, 0x2, 0x2, 0x2, 0xcea, 0xcf6, 0x3, 0x2, 
       0x2, 0x2, 0xceb, 0xcec, 0x7, 0x78, 0x2, 0x2, 0xcec, 0xced, 0x7, 0x19f, 
       0x2, 0x2, 0xced, 0xcee, 0x7, 0xb1, 0x2, 0x2, 0xcee, 0xcef, 0x7, 0x8a, 
       0x2, 0x2, 0xcef, 0xcf0, 0x5, 0x3fe, 0x200, 0x2, 0xcf0, 0xcf1, 0x7, 
       0x119, 0x2, 0x2, 0xcf1, 0xcf3, 0x5, 0x3fa, 0x1fe, 0x2, 0xcf2, 0xcf4, 
       0x5, 0x8e, 0x48, 0x2, 0xcf3, 0xcf2, 0x3, 0x2, 0x2, 0x2, 0xcf3, 0xcf4, 
       0x3, 0x2, 0x2, 0x2, 0xcf4, 0xcf6, 0x3, 0x2, 0x2, 0x2, 0xcf5, 0xce3, 
       0x3, 0x2, 0x2, 0x2, 0xcf5, 0xceb, 0x3, 0x2, 0x2, 0x2, 0xcf6, 0x1a5, 
       0x3, 0x2, 0x2, 0x2, 0xcf7, 0xcf8, 0x7, 0x4b, 0x2, 0x2, 0xcf8, 0xcf9, 
       0x7, 0x17, 0x2, 0x2, 0xcf9, 0xcfa, 0x5, 0x3fe, 0x200, 0x2, 0xcfa, 
       0xcfb, 0x7, 0x30, 0x2, 0x2, 0xcfb, 0xcfc, 0x7, 0x1d9, 0x2, 0x2, 0xcfc, 
       0xcfd, 0x5, 0x362, 0x1b2, 0x2, 0xcfd, 0xcff, 0x7, 0x1da, 0x2, 0x2, 
       0xcfe, 0xd00, 0x5, 0x19e, 0xd0, 0x2, 0xcff, 0xcfe, 0x3, 0x2, 0x2, 
       0x2, 0xcff, 0xd00, 0x3, 0x2, 0x2, 0x2, 0xd00, 0x1a7, 0x3, 0x2, 0x2, 
       0x2, 0xd01, 0xd02, 0x7, 0x78, 0x2, 0x2, 0xd02, 0xd03, 0x7, 0x17, 
       0x2, 0x2, 0xd03, 0xd05, 0x5, 0x3fe, 0x200, 0x2, 0xd04, 0xd06, 0x5, 
       0x8e, 0x48, 0x2, 0xd05, 0xd04, 0x3, 0x2, 0x2, 0x2, 0xd05, 0xd06, 
       0x3, 0x2, 0x2, 0x2, 0xd06, 0x1a9, 0x3, 0x2, 0x2, 0x2, 0xd07, 0xd09, 
       0x7, 0x4b, 0x2, 0x2, 0xd08, 0xd0a, 0x7, 0x120, 0x2, 0x2, 0xd09, 0xd08, 
       0x3, 0x2, 0x2, 0x2, 0xd09, 0xd0a, 0x3, 0x2, 0x2, 0x2, 0xd0a, 0xd0b, 
       0x3, 0x2, 0x2, 0x2, 0xd0b, 0xd0c, 0x7, 0xb, 0x2, 0x2, 0xd0c, 0xd11, 
       0x5, 0x40c, 0x207, 0x2, 0xd0d, 0xd0e, 0x5, 0x1b4, 0xdb, 0x2, 0xd0e, 
       0xd0f, 0x5, 0x1ac, 0xd7, 0x2, 0xd0f, 0xd12, 0x3, 0x2, 0x2, 0x2, 0xd10, 
       0xd12, 0x5, 0x1b6, 0xdc, 0x2, 0xd11, 0xd0d, 0x3, 0x2, 0x2, 0x2, 0xd11, 
       0xd10, 0x3, 0x2, 0x2, 0x2, 0xd12, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd13, 
       0xd14, 0x7, 0x4b, 0x2, 0x2, 0xd14, 0xd15, 0x7, 0x11b, 0x2, 0x2, 0xd15, 
       0xd16, 0x5, 0x24e, 0x128, 0x2, 0xd16, 0xd17, 0x5, 0x1ac, 0xd7, 0x2, 
       0xd17, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd18, 0xd19, 0x7, 0x4b, 0x2, 0x2, 
       0xd19, 0xd1a, 0x7, 0x1a4, 0x2, 0x2, 0xd1a, 0xd1b, 0x5, 0x1dc, 0xef, 
       0x2, 0xd1b, 0xd1c, 0x5, 0x1ac, 0xd7, 0x2, 0xd1c, 0xd43, 0x3, 0x2, 
       0x2, 0x2, 0xd1d, 0xd1e, 0x7, 0x4b, 0x2, 0x2, 0xd1e, 0xd1f, 0x7, 0x1a4, 
       0x2, 0x2, 0xd1f, 0xd43, 0x5, 0x1dc, 0xef, 0x2, 0xd20, 0xd21, 0x7, 
       0x4b, 0x2, 0x2, 0xd21, 0xd22, 0x7, 0x1a4, 0x2, 0x2, 0xd22, 0xd23, 
       0x5, 0x1dc, 0xef, 0x2, 0xd23, 0xd24, 0x7, 0x15, 0x2, 0x2, 0xd24, 
       0xd25, 0x7, 0x1d9, 0x2, 0x2, 0xd25, 0xd26, 0x5, 0x336, 0x19c, 0x2, 
       0xd26, 0xd27, 0x7, 0x1da, 0x2, 0x2, 0xd27, 0xd43, 0x3, 0x2, 0x2, 
       0x2, 0xd28, 0xd2a, 0x7, 0x4b, 0x2, 0x2, 0xd29, 0xd2b, 0x7, 0x1a3, 
       0x2, 0x2, 0xd2a, 0xd29, 0x3, 0x2, 0x2, 0x2, 0xd2a, 0xd2b, 0x3, 0x2, 
       0x2, 0x2, 0xd2b, 0xd2c, 0x3, 0x2, 0x2, 0x2, 0xd2c, 0xd2d, 0x7, 0x141, 
       0x2, 0x2, 0xd2d, 0xd2e, 0x5, 0x3fe, 0x200, 0x2, 0xd2e, 0xd2f, 0x5, 
       0x1ac, 0xd7, 0x2, 0xd2f, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd30, 0xd31, 
       0x7, 0x4b, 0x2, 0x2, 0xd31, 0xd32, 0x7, 0x1a4, 0x2, 0x2, 0xd32, 0xd33, 
       0x5, 0x1dc, 0xef, 0x2, 0xd33, 0xd34, 0x7, 0x15, 0x2, 0x2, 0xd34, 
       0xd35, 0x7, 0x80, 0x2, 0x2, 0xd35, 0xd37, 0x7, 0x1d9, 0x2, 0x2, 0xd36, 
       0xd38, 0x5, 0x1bc, 0xdf, 0x2, 0xd37, 0xd36, 0x3, 0x2, 0x2, 0x2, 0xd37, 
       0xd38, 0x3, 0x2, 0x2, 0x2, 0xd38, 0xd39, 0x3, 0x2, 0x2, 0x2, 0xd39, 
       0xd3a, 0x7, 0x1da, 0x2, 0x2, 0xd3a, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd3b, 
       0xd3c, 0x7, 0x4b, 0x2, 0x2, 0xd3c, 0xd3d, 0x7, 0x195, 0x2, 0x2, 0xd3d, 
       0xd3e, 0x7, 0x16b, 0x2, 0x2, 0xd3e, 0xd3f, 0x9, 0x21, 0x2, 0x2, 0xd3f, 
       0xd40, 0x5, 0x1dc, 0xef, 0x2, 0xd40, 0xd41, 0x5, 0x1ac, 0xd7, 0x2, 
       0xd41, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd42, 0xd07, 0x3, 0x2, 0x2, 0x2, 
       0xd42, 0xd13, 0x3, 0x2, 0x2, 0x2, 0xd42, 0xd18, 0x3, 0x2, 0x2, 0x2, 
       0xd42, 0xd1d, 0x3, 0x2, 0x2, 0x2, 0xd42, 0xd20, 0x3, 0x2, 0x2, 0x2, 
       0xd42, 0xd28, 0x3, 0x2, 0x2, 0x2, 0xd42, 0xd30, 0x3, 0x2, 0x2, 0x2, 
       0xd42, 0xd3b, 0x3, 0x2, 0x2, 0x2, 0xd43, 0x1ab, 0x3, 0x2, 0x2, 0x2, 
       0xd44, 0xd45, 0x7, 0x1d9, 0x2, 0x2, 0xd45, 0xd46, 0x5, 0x1ae, 0xd8, 
       0x2, 0xd46, 0xd47, 0x7, 0x1da, 0x2, 0x2, 0xd47, 0x1ad, 0x3, 0x2, 
       0x2, 0x2, 0xd48, 0xd4d, 0x5, 0x1b0, 0xd9, 0x2, 0xd49, 0xd4a, 0x7, 
       0x1df, 0x2, 0x2, 0xd4a, 0xd4c, 0x5, 0x1b0, 0xd9, 0x2, 0xd4b, 0xd49, 
       0x3, 0x2, 0x2, 0x2, 0xd4c, 0xd4f, 0x3, 0x2, 0x2, 0x2, 0xd4d, 0xd4b, 
       0x3, 0x2, 0x2, 0x2, 0xd4d, 0xd4e, 0x3, 0x2, 0x2, 0x2, 0xd4e, 0x1af, 
       0x3, 0x2, 0x2, 0x2, 0xd4f, 0xd4d, 0x3, 0x2, 0x2, 0x2, 0xd50, 0xd51, 
       0x5, 0x41e, 0x210, 0x2, 0xd51, 0xd52, 0x7, 0x1f1, 0x2, 0x2, 0xd52, 
       0xd53, 0x5, 0x1b2, 0xda, 0x2, 0xd53, 0xd56, 0x3, 0x2, 0x2, 0x2, 0xd54, 
       0xd56, 0x5, 0x41e, 0x210, 0x2, 0xd55, 0xd50, 0x3, 0x2, 0x2, 0x2, 
       0xd55, 0xd54, 0x3, 0x2, 0x2, 0x2, 0xd56, 0x1b1, 0x3, 0x2, 0x2, 0x2, 
       0xd57, 0xd5f, 0x5, 0x230, 0x119, 0x2, 0xd58, 0xd5f, 0x7, 0x164, 0x2, 
       0x2, 0xd59, 0xd5f, 0x5, 0x42e, 0x218, 0x2, 0xd5a, 0xd5f, 0x5, 0x3b4, 
       0x1db, 0x2, 0xd5b, 0xd5f, 0x5, 0x15e, 0xb0, 0x2, 0xd5c, 0xd5f, 0x5, 
       0x412, 0x20a, 0x2, 0xd5d, 0xd5f, 0x7, 0x105, 0x2, 0x2, 0xd5e, 0xd57, 
       0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd58, 0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd59, 
       0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd5a, 0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd5b, 
       0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd5c, 0x3, 0x2, 0x2, 0x2, 0xd5e, 0xd5d, 
       0x3, 0x2, 0x2, 0x2, 0xd5f, 0x1b3, 0x3, 0x2, 0x2, 0x2, 0xd60, 0xd65, 
       0x5, 0x2b4, 0x15b, 0x2, 0xd61, 0xd62, 0x7, 0x1d9, 0x2, 0x2, 0xd62, 
       0xd63, 0x7, 0x1dc, 0x2, 0x2, 0xd63, 0xd65, 0x7, 0x1da, 0x2, 0x2, 
       0xd64, 0xd60, 0x3, 0x2, 0x2, 0x2, 0xd64, 0xd61, 0x3, 0x2, 0x2, 0x2, 
       0xd65, 0x1b5, 0x3, 0x2, 0x2, 0x2, 0xd66, 0xd67, 0x7, 0x1d9, 0x2, 
       0x2, 0xd67, 0xd68, 0x5, 0x1b8, 0xdd, 0x2, 0xd68, 0xd69, 0x7, 0x1da, 
       0x2, 0x2, 0xd69, 0x1b7, 0x3, 0x2, 0x2, 0x2, 0xd6a, 0xd6f, 0x5, 0x1ba, 
       0xde, 0x2, 0xd6b, 0xd6c, 0x7, 0x1df, 0x2, 0x2, 0xd6c, 0xd6e, 0x5, 
       0x1ba, 0xde, 0x2, 0xd6d, 0xd6b, 0x3, 0x2, 0x2, 0x2, 0xd6e, 0xd71, 
       0x3, 0x2, 0x2, 0x2, 0xd6f, 0xd6d, 0x3, 0x2, 0x2, 0x2, 0xd6f, 0xd70, 
       0x3, 0x2, 0x2, 0x2, 0xd70, 0x1b9, 0x3, 0x2, 0x2, 0x2, 0xd71, 0xd6f, 
       0x3, 0x2, 0x2, 0x2, 0xd72, 0xd73, 0x5, 0x420, 0x211, 0x2, 0xd73, 
       0xd74, 0x7, 0x1f1, 0x2, 0x2, 0xd74, 0xd75, 0x5, 0x1b2, 0xda, 0x2, 
       0xd75, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0xd76, 0xd7b, 0x5, 0x412, 0x20a, 
       0x2, 0xd77, 0xd78, 0x7, 0x1df, 0x2, 0x2, 0xd78, 0xd7a, 0x5, 0x412, 
       0x20a, 0x2, 0xd79, 0xd77, 0x3, 0x2, 0x2, 0x2, 0xd7a, 0xd7d, 0x3, 
       0x2, 0x2, 0x2, 0xd7b, 0xd79, 0x3, 0x2, 0x2, 0x2, 0xd7b, 0xd7c, 0x3, 
       0x2, 0x2, 0x2, 0xd7c, 0x1bd, 0x3, 0x2, 0x2, 0x2, 0xd7d, 0xd7b, 0x3, 
       0x2, 0x2, 0x2, 0xd7e, 0xd7f, 0x7, 0x4b, 0x2, 0x2, 0xd7f, 0xd80, 0x7, 
       0x11b, 0x2, 0x2, 0xd80, 0xd81, 0x7, 0x32, 0x2, 0x2, 0xd81, 0xd83, 
       0x5, 0x1dc, 0xef, 0x2, 0xd82, 0xd84, 0x7, 0x65, 0x2, 0x2, 0xd83, 
       0xd82, 0x3, 0x2, 0x2, 0x2, 0xd83, 0xd84, 0x3, 0x2, 0x2, 0x2, 0xd84, 
       0xd85, 0x3, 0x2, 0x2, 0x2, 0xd85, 0xd86, 0x7, 0x99, 0x2, 0x2, 0xd86, 
       0xd87, 0x7, 0x1a4, 0x2, 0x2, 0xd87, 0xd88, 0x5, 0x33a, 0x19e, 0x2, 
       0xd88, 0xd89, 0x7, 0x1b1, 0x2, 0x2, 0xd89, 0xd8b, 0x5, 0x404, 0x203, 
       0x2, 0xd8a, 0xd8c, 0x5, 0x1c4, 0xe3, 0x2, 0xd8b, 0xd8a, 0x3, 0x2, 
       0x2, 0x2, 0xd8b, 0xd8c, 0x3, 0x2, 0x2, 0x2, 0xd8c, 0xd8d, 0x3, 0x2, 
       0x2, 0x2, 0xd8d, 0xd8e, 0x7, 0x15, 0x2, 0x2, 0xd8e, 0xd8f, 0x5, 0x1c0, 
       0xe1, 0x2, 0xd8f, 0x1bf, 0x3, 0x2, 0x2, 0x2, 0xd90, 0xd95, 0x5, 0x1c2, 
       0xe2, 0x2, 0xd91, 0xd92, 0x7, 0x1df, 0x2, 0x2, 0xd92, 0xd94, 0x5, 
       0x1c2, 0xe2, 0x2, 0xd93, 0xd91, 0x3, 0x2, 0x2, 0x2, 0xd94, 0xd97, 
       0x3, 0x2, 0x2, 0x2, 0xd95, 0xd93, 0x3, 0x2, 0x2, 0x2, 0xd95, 0xd96, 
       0x3, 0x2, 0x2, 0x2, 0xd96, 0x1c1, 0x3, 0x2, 0x2, 0x2, 0xd97, 0xd95, 
       0x3, 0x2, 0x2, 0x2, 0xd98, 0xd99, 0x7, 0x11b, 0x2, 0x2, 0xd99, 0xd9a, 
       0x5, 0x410, 0x209, 0x2, 0xd9a, 0xd9c, 0x5, 0x24e, 0x128, 0x2, 0xd9b, 
       0xd9d, 0x5, 0x24c, 0x127, 0x2, 0xd9c, 0xd9b, 0x3, 0x2, 0x2, 0x2, 
       0xd9c, 0xd9d, 0x3, 0x2, 0x2, 0x2, 0xd9d, 0xd9f, 0x3, 0x2, 0x2, 0x2, 
       0xd9e, 0xda0, 0x7, 0x14c, 0x2, 0x2, 0xd9f, 0xd9e, 0x3, 0x2, 0x2, 
       0x2, 0xd9f, 0xda0, 0x3, 0x2, 0x2, 0x2, 0xda0, 0xdaf, 0x3, 0x2, 0x2, 
       0x2, 0xda1, 0xda2, 0x7, 0xa1, 0x2, 0x2, 0xda2, 0xda3, 0x5, 0x410, 
       0x209, 0x2, 0xda3, 0xda4, 0x5, 0x40c, 0x207, 0x2, 0xda4, 0xda5, 0x5, 
       0x21e, 0x110, 0x2, 0xda5, 0xdaf, 0x3, 0x2, 0x2, 0x2, 0xda6, 0xda7, 
       0x7, 0xa1, 0x2, 0x2, 0xda7, 0xda8, 0x5, 0x410, 0x209, 0x2, 0xda8, 
       0xda9, 0x5, 0x2b4, 0x15b, 0x2, 0xda9, 0xdaa, 0x5, 0x40c, 0x207, 0x2, 
       0xdaa, 0xdab, 0x5, 0x21e, 0x110, 0x2, 0xdab, 0xdaf, 0x3, 0x2, 0x2, 
       0x2, 0xdac, 0xdad, 0x7, 0x186, 0x2, 0x2, 0xdad, 0xdaf, 0x5, 0x33a, 
       0x19e, 0x2, 0xdae, 0xd98, 0x3, 0x2, 0x2, 0x2, 0xdae, 0xda1, 0x3, 
       0x2, 0x2, 0x2, 0xdae, 0xda6, 0x3, 0x2, 0x2, 0x2, 0xdae, 0xdac, 0x3, 
       0x2, 0x2, 0x2, 0xdaf, 0x1c3, 0x3, 0x2, 0x2, 0x2, 0xdb0, 0xdb1, 0x7, 
       0x90, 0x2, 0x2, 0xdb1, 0xdb2, 0x5, 0x1dc, 0xef, 0x2, 0xdb2, 0x1c5, 
       0x3, 0x2, 0x2, 0x2, 0xdb3, 0xdb4, 0x7, 0x4b, 0x2, 0x2, 0xdb4, 0xdb5, 
       0x7, 0x11b, 0x2, 0x2, 0xdb5, 0xdb6, 0x7, 0x90, 0x2, 0x2, 0xdb6, 0xdb7, 
       0x5, 0x1dc, 0xef, 0x2, 0xdb7, 0xdb8, 0x7, 0x1b1, 0x2, 0x2, 0xdb8, 
       0xdb9, 0x5, 0x404, 0x203, 0x2, 0xdb9, 0x1c7, 0x3, 0x2, 0x2, 0x2, 
       0xdba, 0xdbb, 0x7, 0xe, 0x2, 0x2, 0xdbb, 0xdbc, 0x7, 0x11b, 0x2, 
       0x2, 0xdbc, 0xdbd, 0x7, 0x90, 0x2, 0x2, 0xdbd, 0xdbe, 0x5, 0x1dc, 
       0xef, 0x2, 0xdbe, 0xdbf, 0x7, 0x1b1, 0x2, 0x2, 0xdbf, 0xdc0, 0x5, 
       0x404, 0x203, 0x2, 0xdc0, 0xdc1, 0x7, 0x8, 0x2, 0x2, 0xdc1, 0xdc2, 
       0x5, 0x1c0, 0xe1, 0x2, 0xdc2, 0xdcd, 0x3, 0x2, 0x2, 0x2, 0xdc3, 0xdc4, 
       0x7, 0xe, 0x2, 0x2, 0xdc4, 0xdc5, 0x7, 0x11b, 0x2, 0x2, 0xdc5, 0xdc6, 
       0x7, 0x90, 0x2, 0x2, 0xdc6, 0xdc7, 0x5, 0x1dc, 0xef, 0x2, 0xdc7, 
       0xdc8, 0x7, 0x1b1, 0x2, 0x2, 0xdc8, 0xdc9, 0x5, 0x404, 0x203, 0x2, 
       0xdc9, 0xdca, 0x7, 0x78, 0x2, 0x2, 0xdca, 0xdcb, 0x5, 0x1ca, 0xe6, 
       0x2, 0xdcb, 0xdcd, 0x3, 0x2, 0x2, 0x2, 0xdcc, 0xdba, 0x3, 0x2, 0x2, 
       0x2, 0xdcc, 0xdc3, 0x3, 0x2, 0x2, 0x2, 0xdcd, 0x1c9, 0x3, 0x2, 0x2, 
       0x2, 0xdce, 0xdd3, 0x5, 0x1cc, 0xe7, 0x2, 0xdcf, 0xdd0, 0x7, 0x1df, 
       0x2, 0x2, 0xdd0, 0xdd2, 0x5, 0x1cc, 0xe7, 0x2, 0xdd1, 0xdcf, 0x3, 
       0x2, 0x2, 0x2, 0xdd2, 0xdd5, 0x3, 0x2, 0x2, 0x2, 0xdd3, 0xdd1, 0x3, 
       0x2, 0x2, 0x2, 0xdd3, 0xdd4, 0x3, 0x2, 0x2, 0x2, 0xdd4, 0x1cb, 0x3, 
       0x2, 0x2, 0x2, 0xdd5, 0xdd3, 0x3, 0x2, 0x2, 0x2, 0xdd6, 0xdd7, 0x9, 
       0x22, 0x2, 0x2, 0xdd7, 0xdd8, 0x5, 0x410, 0x209, 0x2, 0xdd8, 0xdd9, 
       0x5, 0x2b4, 0x15b, 0x2, 0xdd9, 0x1cd, 0x3, 0x2, 0x2, 0x2, 0xdda, 
       0xddb, 0x7, 0x78, 0x2, 0x2, 0xddb, 0xddc, 0x7, 0x11b, 0x2, 0x2, 0xddc, 
       0xddf, 0x7, 0x32, 0x2, 0x2, 0xddd, 0xdde, 0x7, 0xb1, 0x2, 0x2, 0xdde, 
       0xde0, 0x7, 0x8a, 0x2, 0x2, 0xddf, 0xddd, 0x3, 0x2, 0x2, 0x2, 0xddf, 
       0xde0, 0x3, 0x2, 0x2, 0x2, 0xde0, 0xde1, 0x3, 0x2, 0x2, 0x2, 0xde1, 
       0xde2, 0x5, 0x1dc, 0xef, 0x2, 0xde2, 0xde3, 0x7, 0x1b1, 0x2, 0x2, 
       0xde3, 0xde5, 0x5, 0x404, 0x203, 0x2, 0xde4, 0xde6, 0x5, 0x8e, 0x48, 
       0x2, 0xde5, 0xde4, 0x3, 0x2, 0x2, 0x2, 0xde5, 0xde6, 0x3, 0x2, 0x2, 
       0x2, 0xde6, 0x1cf, 0x3, 0x2, 0x2, 0x2, 0xde7, 0xde8, 0x7, 0x78, 0x2, 
       0x2, 0xde8, 0xde9, 0x7, 0x11b, 0x2, 0x2, 0xde9, 0xdec, 0x7, 0x90, 
       0x2, 0x2, 0xdea, 0xdeb, 0x7, 0xb1, 0x2, 0x2, 0xdeb, 0xded, 0x7, 0x8a, 
       0x2, 0x2, 0xdec, 0xdea, 0x3, 0x2, 0x2, 0x2, 0xdec, 0xded, 0x3, 0x2, 
       0x2, 0x2, 0xded, 0xdee, 0x3, 0x2, 0x2, 0x2, 0xdee, 0xdef, 0x5, 0x1dc, 
       0xef, 0x2, 0xdef, 0xdf0, 0x7, 0x1b1, 0x2, 0x2, 0xdf0, 0xdf2, 0x5, 
       0x404, 0x203, 0x2, 0xdf1, 0xdf3, 0x5, 0x8e, 0x48, 0x2, 0xdf2, 0xdf1, 
       0x3, 0x2, 0x2, 0x2, 0xdf2, 0xdf3, 0x3, 0x2, 0x2, 0x2, 0xdf3, 0x1d1, 
       0x3, 0x2, 0x2, 0x2, 0xdf4, 0xdf5, 0x7, 0x78, 0x2, 0x2, 0xdf5, 0xdf6, 
       0x7, 0x128, 0x2, 0x2, 0xdf6, 0xdf7, 0x7, 0x25, 0x2, 0x2, 0xdf7, 0xdf9, 
       0x5, 0x3fc, 0x1ff, 0x2, 0xdf8, 0xdfa, 0x5, 0x8e, 0x48, 0x2, 0xdf9, 
       0xdf8, 0x3, 0x2, 0x2, 0x2, 0xdf9, 0xdfa, 0x3, 0x2, 0x2, 0x2, 0xdfa, 
       0x1d3, 0x3, 0x2, 0x2, 0x2, 0xdfb, 0xdfc, 0x7, 0x14b, 0x2, 0x2, 0xdfc, 
       0xdfd, 0x7, 0x128, 0x2, 0x2, 0xdfd, 0xdfe, 0x7, 0x25, 0x2, 0x2, 0xdfe, 
       0xdff, 0x5, 0x3fc, 0x1ff, 0x2, 0xdff, 0xe00, 0x7, 0x19b, 0x2, 0x2, 
       0xe00, 0xe01, 0x5, 0x3fe, 0x200, 0x2, 0xe01, 0x1d5, 0x3, 0x2, 0x2, 
       0x2, 0xe02, 0xe03, 0x7, 0x78, 0x2, 0x2, 0xe03, 0xe06, 0x5, 0x1d8, 
       0xed, 0x2, 0xe04, 0xe05, 0x7, 0xb1, 0x2, 0x2, 0xe05, 0xe07, 0x7, 
       0x8a, 0x2, 0x2, 0xe06, 0xe04, 0x3, 0x2, 0x2, 0x2, 0xe06, 0xe07, 0x3, 
       0x2, 0x2, 0x2, 0xe07, 0xe08, 0x3, 0x2, 0x2, 0x2, 0xe08, 0xe0a, 0x5, 
       0x1da, 0xee, 0x2, 0xe09, 0xe0b, 0x5, 0x8e, 0x48, 0x2, 0xe0a, 0xe09, 
       0x3, 0x2, 0x2, 0x2, 0xe0a, 0xe0b, 0x3, 0x2, 0x2, 0x2, 0xe0b, 0x1d7, 
       0x3, 0x2, 0x2, 0x2, 0xe0c, 0xe21, 0x7, 0x190, 0x2, 0x2, 0xe0d, 0xe0f, 
       0x7, 0x8d, 0x2, 0x2, 0xe0e, 0xe10, 0x7, 0x1bf, 0x2, 0x2, 0xe0f, 0xe0e, 
       0x3, 0x2, 0x2, 0x2, 0xe0f, 0xe10, 0x3, 0x2, 0x2, 0x2, 0xe10, 0xe11, 
       0x3, 0x2, 0x2, 0x2, 0xe11, 0xe21, 0x7, 0x190, 0x2, 0x2, 0xe12, 0xe21, 
       0x7, 0x170, 0x2, 0x2, 0xe13, 0xe21, 0x7, 0x1bd, 0x2, 0x2, 0xe14, 
       0xe21, 0x7, 0xba, 0x2, 0x2, 0xe15, 0xe21, 0x7, 0x1a4, 0x2, 0x2, 0xe16, 
       0xe21, 0x7, 0x76, 0x2, 0x2, 0xe17, 0xe21, 0x7, 0x46, 0x2, 0x2, 0xe18, 
       0xe21, 0x7, 0x169, 0x2, 0x2, 0xe19, 0xe21, 0x7, 0x8c, 0x2, 0x2, 0xe1a, 
       0xe1b, 0x7, 0x195, 0x2, 0x2, 0xe1b, 0xe1c, 0x7, 0x16b, 0x2, 0x2, 
       0xe1c, 0xe21, 0x9, 0x21, 0x2, 0x2, 0xe1d, 0xe21, 0x7, 0x93, 0x2, 
       0x2, 0xe1e, 0xe21, 0x7, 0x191, 0x2, 0x2, 0xe1f, 0xe21, 0x7, 0x141, 
       0x2, 0x2, 0xe20, 0xe0c, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe0d, 0x3, 0x2, 
       0x2, 0x2, 0xe20, 0xe12, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe13, 0x3, 0x2, 
       0x2, 0x2, 0xe20, 0xe14, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe15, 0x3, 0x2, 
       0x2, 0x2, 0xe20, 0xe16, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe17, 0x3, 0x2, 
       0x2, 0x2, 0xe20, 0xe18, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe19, 0x3, 0x2, 
       0x2, 0x2, 0xe20, 0xe1a, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe1d, 0x3, 0x2, 
       0x2, 0x2, 0xe20, 0xe1e, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe1f, 0x3, 0x2, 
       0x2, 0x2, 0xe21, 0x1d9, 0x3, 0x2, 0x2, 0x2, 0xe22, 0xe27, 0x5, 0x1dc, 
       0xef, 0x2, 0xe23, 0xe24, 0x7, 0x1df, 0x2, 0x2, 0xe24, 0xe26, 0x5, 
       0x1dc, 0xef, 0x2, 0xe25, 0xe23, 0x3, 0x2, 0x2, 0x2, 0xe26, 0xe29, 
       0x3, 0x2, 0x2, 0x2, 0xe27, 0xe25, 0x3, 0x2, 0x2, 0x2, 0xe27, 0xe28, 
       0x3, 0x2, 0x2, 0x2, 0xe28, 0x1db, 0x3, 0x2, 0x2, 0x2, 0xe29, 0xe27, 
       0x3, 0x2, 0x2, 0x2, 0xe2a, 0xe2c, 0x5, 0x41a, 0x20e, 0x2, 0xe2b, 
       0xe2d, 0x5, 0x1de, 0xf0, 0x2, 0xe2c, 0xe2b, 0x3, 0x2, 0x2, 0x2, 0xe2c, 
       0xe2d, 0x3, 0x2, 0x2, 0x2, 0xe2d, 0x1dd, 0x3, 0x2, 0x2, 0x2, 0xe2e, 
       0xe2f, 0x7, 0x1e3, 0x2, 0x2, 0xe2f, 0xe31, 0x5, 0x406, 0x204, 0x2, 
       0xe30, 0xe2e, 0x3, 0x2, 0x2, 0x2, 0xe31, 0xe32, 0x3, 0x2, 0x2, 0x2, 
       0xe32, 0xe30, 0x3, 0x2, 0x2, 0x2, 0xe32, 0xe33, 0x3, 0x2, 0x2, 0x2, 
       0xe33, 0x1df, 0x3, 0x2, 0x2, 0x2, 0xe34, 0xe36, 0x7, 0x1a2, 0x2, 
       0x2, 0xe35, 0xe37, 0x7, 0x190, 0x2, 0x2, 0xe36, 0xe35, 0x3, 0x2, 
       0x2, 0x2, 0xe36, 0xe37, 0x3, 0x2, 0x2, 0x2, 0xe37, 0xe38, 0x3, 0x2, 
       0x2, 0x2, 0xe38, 0xe3a, 0x5, 0x3f8, 0x1fd, 0x2, 0xe39, 0xe3b, 0x5, 
       0x8e, 0x48, 0x2, 0xe3a, 0xe39, 0x3, 0x2, 0x2, 0x2, 0xe3a, 0xe3b, 
       0x3, 0x2, 0x2, 0x2, 0xe3b, 0x1e1, 0x3, 0x2, 0x2, 0x2, 0xe3c, 0xe3d, 
       0x7, 0x38, 0x2, 0x2, 0xe3d, 0xe3e, 0x7, 0x119, 0x2, 0x2, 0xe3e, 0xe3f, 
       0x5, 0x1e4, 0xf3, 0x2, 0xe3f, 0x1e3, 0x3, 0x2, 0x2, 0x2, 0xe40, 0xe41, 
       0x5, 0x1e6, 0xf4, 0x2, 0xe41, 0xe42, 0x7, 0xcd, 0x2, 0x2, 0xe42, 
       0xe43, 0x5, 0x1ea, 0xf6, 0x2, 0xe43, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0xe44, 
       0xe45, 0x5, 0x1e8, 0xf5, 0x2, 0xe45, 0xe46, 0x5, 0x1dc, 0xef, 0x2, 
       0xe46, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe47, 0xe48, 0x7, 0xb, 0x2, 0x2, 
       0xe48, 0xe49, 0x5, 0x40c, 0x207, 0x2, 0xe49, 0xe4a, 0x5, 0x1b4, 0xdb, 
       0x2, 0xe4a, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe4b, 0xe4c, 0x7, 0xa1, 0x2, 
       0x2, 0xe4c, 0xe4d, 0x5, 0x40c, 0x207, 0x2, 0xe4d, 0xe4e, 0x5, 0x21e, 
       0x110, 0x2, 0xe4e, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe4f, 0xe50, 0x7, 
       0x11b, 0x2, 0x2, 0xe50, 0xe51, 0x5, 0x24e, 0x128, 0x2, 0xe51, 0xe52, 
       0x5, 0x24c, 0x127, 0x2, 0xe52, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe53, 
       0xe54, 0x7, 0x41, 0x2, 0x2, 0xe54, 0xe55, 0x5, 0x3fe, 0x200, 0x2, 
       0xe55, 0xe56, 0x7, 0x119, 0x2, 0x2, 0xe56, 0xe57, 0x5, 0x1dc, 0xef, 
       0x2, 0xe57, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe58, 0xe59, 0x7, 0x166, 
       0x2, 0x2, 0xe59, 0xe79, 0x5, 0x3fe, 0x200, 0x2, 0xe5a, 0xe5b, 0x9, 
       0x23, 0x2, 0x2, 0xe5b, 0xe5c, 0x5, 0x3fe, 0x200, 0x2, 0xe5c, 0xe5d, 
       0x7, 0x119, 0x2, 0x2, 0xe5d, 0xe5e, 0x5, 0x1dc, 0xef, 0x2, 0xe5e, 
       0xe79, 0x3, 0x2, 0x2, 0x2, 0xe5f, 0xe60, 0x7, 0x11b, 0x2, 0x2, 0xe60, 
       0xe61, 0x9, 0x24, 0x2, 0x2, 0xe61, 0xe62, 0x5, 0x1dc, 0xef, 0x2, 
       0xe62, 0xe63, 0x7, 0x1b1, 0x2, 0x2, 0xe63, 0xe64, 0x5, 0x404, 0x203, 
       0x2, 0xe64, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe65, 0xe66, 0x7, 0xd3, 0x2, 
       0x2, 0xe66, 0xe67, 0x7, 0x113, 0x2, 0x2, 0xe67, 0xe79, 0x5, 0x15e, 
       0xb0, 0x2, 0xe68, 0xe69, 0x7, 0x2b, 0x2, 0x2, 0xe69, 0xe6a, 0x7, 
       0x1d9, 0x2, 0x2, 0xe6a, 0xe6b, 0x5, 0x33a, 0x19e, 0x2, 0xe6b, 0xe6c, 
       0x7, 0x15, 0x2, 0x2, 0xe6c, 0xe6d, 0x5, 0x33a, 0x19e, 0x2, 0xe6d, 
       0xe6e, 0x7, 0x1da, 0x2, 0x2, 0xe6e, 0xe79, 0x3, 0x2, 0x2, 0x2, 0xe6f, 
       0xe71, 0x7, 0x13e, 0x2, 0x2, 0xe70, 0xe6f, 0x3, 0x2, 0x2, 0x2, 0xe70, 
       0xe71, 0x3, 0x2, 0x2, 0x2, 0xe71, 0xe72, 0x3, 0x2, 0x2, 0x2, 0xe72, 
       0xe73, 0x7, 0xd2, 0x2, 0x2, 0xe73, 0xe79, 0x5, 0x1dc, 0xef, 0x2, 
       0xe74, 0xe75, 0x7, 0x195, 0x2, 0x2, 0xe75, 0xe76, 0x7, 0x16b, 0x2, 
       0x2, 0xe76, 0xe77, 0x9, 0x21, 0x2, 0x2, 0xe77, 0xe79, 0x5, 0x1dc, 
       0xef, 0x2, 0xe78, 0xe44, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe47, 0x3, 0x2, 
       0x2, 0x2, 0xe78, 0xe4b, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe4f, 0x3, 0x2, 
       0x2, 0x2, 0xe78, 0xe53, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe58, 0x3, 0x2, 
       0x2, 0x2, 0xe78, 0xe5a, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe5f, 0x3, 0x2, 
       0x2, 0x2, 0xe78, 0xe65, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe68, 0x3, 0x2, 
       0x2, 0x2, 0xe78, 0xe70, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe74, 0x3, 0x2, 
       0x2, 0x2, 0xe79, 0x1e7, 0x3, 0x2, 0x2, 0x2, 0xe7a, 0xe8b, 0x7, 0x37, 
       0x2, 0x2, 0xe7b, 0xe8b, 0x7, 0x5d, 0x2, 0x2, 0xe7c, 0xe8b, 0x7, 0x169, 
       0x2, 0x2, 0xe7d, 0xe8b, 0x7, 0xba, 0x2, 0x2, 0xe7e, 0xe8b, 0x7, 0x170, 
       0x2, 0x2, 0xe7f, 0xe8b, 0x7, 0x190, 0x2, 0x2, 0xe80, 0xe8b, 0x7, 
       0x76, 0x2, 0x2, 0xe81, 0xe8b, 0x7, 0x1a4, 0x2, 0x2, 0xe82, 0xe8b, 
       0x7, 0x1bd, 0x2, 0x2, 0xe83, 0xe8b, 0x7, 0x46, 0x2, 0x2, 0xe84, 0xe8b, 
       0x7, 0x191, 0x2, 0x2, 0xe85, 0xe8b, 0x7, 0x8c, 0x2, 0x2, 0xe86, 0xe8b, 
       0x7, 0x160, 0x2, 0x2, 0xe87, 0xe8b, 0x7, 0x93, 0x2, 0x2, 0xe88, 0xe89, 
       0x7, 0x159, 0x2, 0x2, 0xe89, 0xe8b, 0x7, 0x143, 0x2, 0x2, 0xe8a, 
       0xe7a, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe7b, 0x3, 0x2, 0x2, 0x2, 0xe8a, 
       0xe7c, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe7d, 0x3, 0x2, 0x2, 0x2, 0xe8a, 
       0xe7e, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe7f, 0x3, 0x2, 0x2, 0x2, 0xe8a, 
       0xe80, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe81, 0x3, 0x2, 0x2, 0x2, 0xe8a, 
       0xe82, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe83, 0x3, 0x2, 0x2, 0x2, 0xe8a, 
       0xe84, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe85, 0x3, 0x2, 0x2, 0x2, 0xe8a, 
       0xe86, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe87, 0x3, 0x2, 0x2, 0x2, 0xe8a, 
       0xe88, 0x3, 0x2, 0x2, 0x2, 0xe8b, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0xe8c, 
       0xe8f, 0x5, 0x412, 0x20a, 0x2, 0xe8d, 0xe8f, 0x7, 0x10e, 0x2, 0x2, 
       0xe8e, 0xe8c, 0x3, 0x2, 0x2, 0x2, 0xe8e, 0xe8d, 0x3, 0x2, 0x2, 0x2, 
       0xe8f, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0xe90, 0xe95, 0x7, 0x91, 0x2, 0x2, 
       0xe91, 0xe93, 0x5, 0x1ee, 0xf8, 0x2, 0xe92, 0xe91, 0x3, 0x2, 0x2, 
       0x2, 0xe92, 0xe93, 0x3, 0x2, 0x2, 0x2, 0xe93, 0xe94, 0x3, 0x2, 0x2, 
       0x2, 0xe94, 0xe96, 0x9, 0x25, 0x2, 0x2, 0xe95, 0xe92, 0x3, 0x2, 0x2, 
       0x2, 0xe95, 0xe96, 0x3, 0x2, 0x2, 0x2, 0xe96, 0xe97, 0x3, 0x2, 0x2, 
       0x2, 0xe97, 0xe98, 0x5, 0x3fe, 0x200, 0x2, 0xe98, 0x1ed, 0x3, 0x2, 
       0x2, 0x2, 0xe99, 0xeae, 0x7, 0xfd, 0x2, 0x2, 0xe9a, 0xeae, 0x7, 0x13c, 
       0x2, 0x2, 0xe9b, 0xeae, 0x7, 0x96, 0x2, 0x2, 0xe9c, 0xeae, 0x7, 0xd4, 
       0x2, 0x2, 0xe9d, 0xe9e, 0x7, 0x4, 0x2, 0x2, 0xe9e, 0xeae, 0x5, 0x418, 
       0x20d, 0x2, 0xe9f, 0xea0, 0x7, 0x152, 0x2, 0x2, 0xea0, 0xeae, 0x5, 
       0x418, 0x20d, 0x2, 0xea1, 0xeae, 0x5, 0x418, 0x20d, 0x2, 0xea2, 0xeae, 
       0x7, 0xc, 0x2, 0x2, 0xea3, 0xeae, 0x7, 0x9d, 0x2, 0x2, 0xea4, 0xea5, 
       0x7, 0x9d, 0x2, 0x2, 0xea5, 0xeae, 0x5, 0x418, 0x20d, 0x2, 0xea6, 
       0xea7, 0x7, 0x9d, 0x2, 0x2, 0xea7, 0xeae, 0x7, 0xc, 0x2, 0x2, 0xea8, 
       0xeae, 0x7, 0x1c, 0x2, 0x2, 0xea9, 0xeaa, 0x7, 0x1c, 0x2, 0x2, 0xeaa, 
       0xeae, 0x5, 0x418, 0x20d, 0x2, 0xeab, 0xeac, 0x7, 0x1c, 0x2, 0x2, 
       0xeac, 0xeae, 0x7, 0xc, 0x2, 0x2, 0xead, 0xe99, 0x3, 0x2, 0x2, 0x2, 
       0xead, 0xe9a, 0x3, 0x2, 0x2, 0x2, 0xead, 0xe9b, 0x3, 0x2, 0x2, 0x2, 
       0xead, 0xe9c, 0x3, 0x2, 0x2, 0x2, 0xead, 0xe9d, 0x3, 0x2, 0x2, 0x2, 
       0xead, 0xe9f, 0x3, 0x2, 0x2, 0x2, 0xead, 0xea1, 0x3, 0x2, 0x2, 0x2, 
       0xead, 0xea2, 0x3, 0x2, 0x2, 0x2, 0xead, 0xea3, 0x3, 0x2, 0x2, 0x2, 
       0xead, 0xea4, 0x3, 0x2, 0x2, 0x2, 0xead, 0xea6, 0x3, 0x2, 0x2, 0x2, 
       0xead, 0xea8, 0x3, 0x2, 0x2, 0x2, 0xead, 0xea9, 0x3, 0x2, 0x2, 0x2, 
       0xead, 0xeab, 0x3, 0x2, 0x2, 0x2, 0xeae, 0x1ef, 0x3, 0x2, 0x2, 0x2, 
       0xeaf, 0xeb0, 0x7, 0xa3, 0x2, 0x2, 0xeb0, 0xeb1, 0x5, 0x1f4, 0xfb, 
       0x2, 0xeb1, 0xeb2, 0x7, 0x119, 0x2, 0x2, 0xeb2, 0xeb3, 0x5, 0x1fa, 
       0xfe, 0x2, 0xeb3, 0xeb4, 0x7, 0x19b, 0x2, 0x2, 0xeb4, 0xeb6, 0x5, 
       0x1fc, 0xff, 0x2, 0xeb5, 0xeb7, 0x5, 0x200, 0x101, 0x2, 0xeb6, 0xeb5, 
       0x3, 0x2, 0x2, 0x2, 0xeb6, 0xeb7, 0x3, 0x2, 0x2, 0x2, 0xeb7, 0x1f1, 
       0x3, 0x2, 0x2, 0x2, 0xeb8, 0xebc, 0x7, 0x15e, 0x2, 0x2, 0xeb9, 0xeba, 
       0x7, 0xa3, 0x2, 0x2, 0xeba, 0xebb, 0x7, 0x11c, 0x2, 0x2, 0xebb, 0xebd, 
       0x7, 0x99, 0x2, 0x2, 0xebc, 0xeb9, 0x3, 0x2, 0x2, 0x2, 0xebc, 0xebd, 
       0x3, 0x2, 0x2, 0x2, 0xebd, 0xebe, 0x3, 0x2, 0x2, 0x2, 0xebe, 0xebf, 
       0x5, 0x1f4, 0xfb, 0x2, 0xebf, 0xec0, 0x7, 0x119, 0x2, 0x2, 0xec0, 
       0xec1, 0x5, 0x1fa, 0xfe, 0x2, 0xec1, 0xec2, 0x7, 0x9f, 0x2, 0x2, 
       0xec2, 0xec4, 0x5, 0x1fc, 0xff, 0x2, 0xec3, 0xec5, 0x5, 0x8e, 0x48, 
       0x2, 0xec4, 0xec3, 0x3, 0x2, 0x2, 0x2, 0xec4, 0xec5, 0x3, 0x2, 0x2, 
       0x2, 0xec5, 0x1f3, 0x3, 0x2, 0x2, 0x2, 0xec6, 0xecc, 0x5, 0x1f6, 
       0xfc, 0x2, 0xec7, 0xec9, 0x7, 0xc, 0x2, 0x2, 0xec8, 0xeca, 0x7, 0x13d, 
       0x2, 0x2, 0xec9, 0xec8, 0x3, 0x2, 0x2, 0x2, 0xec9, 0xeca, 0x3, 0x2, 
       0x2, 0x2, 0xeca, 0xecc, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xec6, 0x3, 0x2, 
       0x2, 0x2, 0xecb, 0xec7, 0x3, 0x2, 0x2, 0x2, 0xecc, 0x1f5, 0x3, 0x2, 
       0x2, 0x2, 0xecd, 0xed2, 0x5, 0x1f8, 0xfd, 0x2, 0xece, 0xecf, 0x7, 
       0x1df, 0x2, 0x2, 0xecf, 0xed1, 0x5, 0x1f8, 0xfd, 0x2, 0xed0, 0xece, 
       0x3, 0x2, 0x2, 0x2, 0xed1, 0xed4, 0x3, 0x2, 0x2, 0x2, 0xed2, 0xed0, 
       0x3, 0x2, 0x2, 0x2, 0xed2, 0xed3, 0x3, 0x2, 0x2, 0x2, 0xed3, 0x1f7, 
       0x3, 0x2, 0x2, 0x2, 0xed4, 0xed2, 0x3, 0x2, 0x2, 0x2, 0xed5, 0xed6, 
       0x9, 0x26, 0x2, 0x2, 0xed6, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0xed7, 0xeeb, 
       0x5, 0x3f8, 0x1fd, 0x2, 0xed8, 0xeda, 0x7, 0x190, 0x2, 0x2, 0xed9, 
       0xed8, 0x3, 0x2, 0x2, 0x2, 0xed9, 0xeda, 0x3, 0x2, 0x2, 0x2, 0xeda, 
       0xedb, 0x3, 0x2, 0x2, 0x2, 0xedb, 0xeeb, 0x5, 0x3f8, 0x1fd, 0x2, 
       0xedc, 0xedd, 0x7, 0x170, 0x2, 0x2, 0xedd, 0xeeb, 0x5, 0x3f8, 0x1fd, 
       0x2, 0xede, 0xedf, 0x7, 0xa1, 0x2, 0x2, 0xedf, 0xeeb, 0x5, 0x202, 
       0x102, 0x2, 0xee0, 0xee1, 0x7, 0x5d, 0x2, 0x2, 0xee1, 0xeeb, 0x5, 
       0x3fc, 0x1ff, 0x2, 0xee2, 0xee3, 0x7, 0xd2, 0x2, 0x2, 0xee3, 0xeeb, 
       0x5, 0x3fc, 0x1ff, 0x2, 0xee4, 0xee5, 0x7, 0x169, 0x2, 0x2, 0xee5, 
       0xeeb, 0x5, 0x3fc, 0x1ff, 0x2, 0xee6, 0xee7, 0x7, 0x191, 0x2, 0x2, 
       0xee7, 0xeeb, 0x5, 0x3fc, 0x1ff, 0x2, 0xee8, 0xee9, 0x7, 0x141, 0x2, 
       0x2, 0xee9, 0xeeb, 0x5, 0x3fc, 0x1ff, 0x2, 0xeea, 0xed7, 0x3, 0x2, 
       0x2, 0x2, 0xeea, 0xed9, 0x3, 0x2, 0x2, 0x2, 0xeea, 0xedc, 0x3, 0x2, 
       0x2, 0x2, 0xeea, 0xede, 0x3, 0x2, 0x2, 0x2, 0xeea, 0xee0, 0x3, 0x2, 
       0x2, 0x2, 0xeea, 0xee2, 0x3, 0x2, 0x2, 0x2, 0xeea, 0xee4, 0x3, 0x2, 
       0x2, 0x2, 0xeea, 0xee6, 0x3, 0x2, 0x2, 0x2, 0xeea, 0xee8, 0x3, 0x2, 
       0x2, 0x2, 0xeeb, 0x1fb, 0x3, 0x2, 0x2, 0x2, 0xeec, 0xef1, 0x5, 0x1fe, 
       0x100, 0x2, 0xeed, 0xeee, 0x7, 0x1df, 0x2, 0x2, 0xeee, 0xef0, 0x5, 
       0x1fe, 0x100, 0x2, 0xeef, 0xeed, 0x3, 0x2, 0x2, 0x2, 0xef0, 0xef3, 
       0x3, 0x2, 0x2, 0x2, 0xef1, 0xeef, 0x3, 0x2, 0x2, 0x2, 0xef1, 0xef2, 
       0x3, 0x2, 0x2, 0x2, 0xef2, 0x1fd, 0x3, 0x2, 0x2, 0x2, 0xef3, 0xef1, 
       0x3, 0x2, 0x2, 0x2, 0xef4, 0xef7, 0x5, 0x414, 0x20b, 0x2, 0xef5, 
       0xef7, 0x7, 0x142, 0x2, 0x2, 0xef6, 0xef4, 0x3, 0x2, 0x2, 0x2, 0xef6, 
       0xef5, 0x3, 0x2, 0x2, 0x2, 0xef7, 0x1ff, 0x3, 0x2, 0x2, 0x2, 0xef8, 
       0xef9, 0x7, 0x1c4, 0x2, 0x2, 0xef9, 0xefa, 0x7, 0xa3, 0x2, 0x2, 0xefa, 
       0xefb, 0x7, 0x11c, 0x2, 0x2, 0xefb, 0x201, 0x3, 0x2, 0x2, 0x2, 0xefc, 
       0xf01, 0x5, 0x204, 0x103, 0x2, 0xefd, 0xefe, 0x7, 0x1df, 0x2, 0x2, 
       0xefe, 0xf00, 0x5, 0x204, 0x103, 0x2, 0xeff, 0xefd, 0x3, 0x2, 0x2, 
       0x2, 0xf00, 0xf03, 0x3, 0x2, 0x2, 0x2, 0xf01, 0xeff, 0x3, 0x2, 0x2, 
       0x2, 0xf01, 0xf02, 0x3, 0x2, 0x2, 0x2, 0xf02, 0x203, 0x3, 0x2, 0x2, 
       0x2, 0xf03, 0xf01, 0x3, 0x2, 0x2, 0x2, 0xf04, 0xf05, 0x5, 0x40c, 
       0x207, 0x2, 0xf05, 0xf06, 0x5, 0x21e, 0x110, 0x2, 0xf06, 0x205, 0x3, 
       0x2, 0x2, 0x2, 0xf07, 0xf08, 0x7, 0xa3, 0x2, 0x2, 0xf08, 0xf09, 0x5, 
       0x1f6, 0xfc, 0x2, 0xf09, 0xf0a, 0x7, 0x19b, 0x2, 0x2, 0xf0a, 0xf0c, 
       0x5, 0x3fc, 0x1ff, 0x2, 0xf0b, 0xf0d, 0x5, 0x20a, 0x106, 0x2, 0xf0c, 
       0xf0b, 0x3, 0x2, 0x2, 0x2, 0xf0c, 0xf0d, 0x3, 0x2, 0x2, 0x2, 0xf0d, 
       0xf0f, 0x3, 0x2, 0x2, 0x2, 0xf0e, 0xf10, 0x5, 0x20c, 0x107, 0x2, 
       0xf0f, 0xf0e, 0x3, 0x2, 0x2, 0x2, 0xf0f, 0xf10, 0x3, 0x2, 0x2, 0x2, 
       0xf10, 0x207, 0x3, 0x2, 0x2, 0x2, 0xf11, 0xf15, 0x7, 0x15e, 0x2, 
       0x2, 0xf12, 0xf13, 0x7, 0x9, 0x2, 0x2, 0xf13, 0xf14, 0x7, 0x11c, 
       0x2, 0x2, 0xf14, 0xf16, 0x7, 0x99, 0x2, 0x2, 0xf15, 0xf12, 0x3, 0x2, 
       0x2, 0x2, 0xf15, 0xf16, 0x3, 0x2, 0x2, 0x2, 0xf16, 0xf17, 0x3, 0x2, 
       0x2, 0x2, 0xf17, 0xf18, 0x5, 0x1f6, 0xfc, 0x2, 0xf18, 0xf19, 0x7, 
       0x9f, 0x2, 0x2, 0xf19, 0xf1b, 0x5, 0x3fc, 0x1ff, 0x2, 0xf1a, 0xf1c, 
       0x5, 0x20c, 0x107, 0x2, 0xf1b, 0xf1a, 0x3, 0x2, 0x2, 0x2, 0xf1b, 
       0xf1c, 0x3, 0x2, 0x2, 0x2, 0xf1c, 0xf1e, 0x3, 0x2, 0x2, 0x2, 0xf1d, 
       0xf1f, 0x5, 0x8e, 0x48, 0x2, 0xf1e, 0xf1d, 0x3, 0x2, 0x2, 0x2, 0xf1e, 
       0xf1f, 0x3, 0x2, 0x2, 0x2, 0xf1f, 0x209, 0x3, 0x2, 0x2, 0x2, 0xf20, 
       0xf21, 0x7, 0x1c4, 0x2, 0x2, 0xf21, 0xf22, 0x7, 0x9, 0x2, 0x2, 0xf22, 
       0xf23, 0x7, 0x11c, 0x2, 0x2, 0xf23, 0x20b, 0x3, 0x2, 0x2, 0x2, 0xf24, 
       0xf25, 0x7, 0xa4, 0x2, 0x2, 0xf25, 0xf26, 0x7, 0x25, 0x2, 0x2, 0xf26, 
       0xf27, 0x5, 0x414, 0x20b, 0x2, 0xf27, 0x20d, 0x3, 0x2, 0x2, 0x2, 
       0xf28, 0xf2a, 0x7, 0x4b, 0x2, 0x2, 0xf29, 0xf2b, 0x7, 0x1aa, 0x2, 
       0x2, 0xf2a, 0xf29, 0x3, 0x2, 0x2, 0x2, 0xf2a, 0xf2b, 0x3, 0x2, 0x2, 
       0x2, 0xf2b, 0xf2c, 0x3, 0x2, 0x2, 0x2, 0xf2c, 0xf2d, 0x7, 0xba, 0x2, 
       0x2, 0xf2d, 0xf2e, 0x5, 0x408, 0x205, 0x2, 0xf2e, 0xf2f, 0x7, 0x119, 
       0x2, 0x2, 0xf2f, 0xf32, 0x5, 0x3fa, 0x1fe, 0x2, 0xf30, 0xf31, 0x7, 
       0x1b1, 0x2, 0x2, 0xf31, 0xf33, 0x5, 0x404, 0x203, 0x2, 0xf32, 0xf30, 
       0x3, 0x2, 0x2, 0x2, 0xf32, 0xf33, 0x3, 0x2, 0x2, 0x2, 0xf33, 0xf34, 
       0x3, 0x2, 0x2, 0x2, 0xf34, 0xf35, 0x7, 0x1d9, 0x2, 0x2, 0xf35, 0xf36, 
       0x5, 0x210, 0x109, 0x2, 0xf36, 0xf38, 0x7, 0x1da, 0x2, 0x2, 0xf37, 
       0xf39, 0x5, 0xe, 0x8, 0x2, 0xf38, 0xf37, 0x3, 0x2, 0x2, 0x2, 0xf38, 
       0xf39, 0x3, 0x2, 0x2, 0x2, 0xf39, 0xf3b, 0x3, 0x2, 0x2, 0x2, 0xf3a, 
       0xf3c, 0x5, 0xd6, 0x6c, 0x2, 0xf3b, 0xf3a, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf3c, 0x3, 0x2, 0x2, 0x2, 0xf3c, 0xf3e, 0x3, 0x2, 0x2, 0x2, 0xf3d, 
       0xf3f, 0x5, 0x332, 0x19a, 0x2, 0xf3e, 0xf3d, 0x3, 0x2, 0x2, 0x2, 
       0xf3e, 0xf3f, 0x3, 0x2, 0x2, 0x2, 0xf3f, 0x20f, 0x3, 0x2, 0x2, 0x2, 
       0xf40, 0xf45, 0x5, 0x212, 0x10a, 0x2, 0xf41, 0xf42, 0x7, 0x1df, 0x2, 
       0x2, 0xf42, 0xf44, 0x5, 0x212, 0x10a, 0x2, 0xf43, 0xf41, 0x3, 0x2, 
       0x2, 0x2, 0xf44, 0xf47, 0x3, 0x2, 0x2, 0x2, 0xf45, 0xf43, 0x3, 0x2, 
       0x2, 0x2, 0xf45, 0xf46, 0x3, 0x2, 0x2, 0x2, 0xf46, 0x211, 0x3, 0x2, 
       0x2, 0x2, 0xf47, 0xf45, 0x3, 0x2, 0x2, 0x2, 0xf48, 0xf4a, 0x5, 0x41a, 
       0x20e, 0x2, 0xf49, 0xf4b, 0x5, 0x214, 0x10b, 0x2, 0xf4a, 0xf49, 0x3, 
       0x2, 0x2, 0x2, 0xf4a, 0xf4b, 0x3, 0x2, 0x2, 0x2, 0xf4b, 0xf4d, 0x3, 
       0x2, 0x2, 0x2, 0xf4c, 0xf4e, 0x5, 0x216, 0x10c, 0x2, 0xf4d, 0xf4c, 
       0x3, 0x2, 0x2, 0x2, 0xf4d, 0xf4e, 0x3, 0x2, 0x2, 0x2, 0xf4e, 0xf50, 
       0x3, 0x2, 0x2, 0x2, 0xf4f, 0xf51, 0x5, 0x218, 0x10d, 0x2, 0xf50, 
       0xf4f, 0x3, 0x2, 0x2, 0x2, 0xf50, 0xf51, 0x3, 0x2, 0x2, 0x2, 0xf51, 
       0xf69, 0x3, 0x2, 0x2, 0x2, 0xf52, 0xf54, 0x5, 0x382, 0x1c2, 0x2, 
       0xf53, 0xf55, 0x5, 0x214, 0x10b, 0x2, 0xf54, 0xf53, 0x3, 0x2, 0x2, 
       0x2, 0xf54, 0xf55, 0x3, 0x2, 0x2, 0x2, 0xf55, 0xf57, 0x3, 0x2, 0x2, 
       0x2, 0xf56, 0xf58, 0x5, 0x216, 0x10c, 0x2, 0xf57, 0xf56, 0x3, 0x2, 
       0x2, 0x2, 0xf57, 0xf58, 0x3, 0x2, 0x2, 0x2, 0xf58, 0xf5a, 0x3, 0x2, 
       0x2, 0x2, 0xf59, 0xf5b, 0x5, 0x218, 0x10d, 0x2, 0xf5a, 0xf59, 0x3, 
       0x2, 0x2, 0x2, 0xf5a, 0xf5b, 0x3, 0x2, 0x2, 0x2, 0xf5b, 0xf69, 0x3, 
       0x2, 0x2, 0x2, 0xf5c, 0xf5d, 0x7, 0x1d9, 0x2, 0x2, 0xf5d, 0xf5e, 
       0x5, 0x362, 0x1b2, 0x2, 0xf5e, 0xf60, 0x7, 0x1da, 0x2, 0x2, 0xf5f, 
       0xf61, 0x5, 0x214, 0x10b, 0x2, 0xf60, 0xf5f, 0x3, 0x2, 0x2, 0x2, 
       0xf60, 0xf61, 0x3, 0x2, 0x2, 0x2, 0xf61, 0xf63, 0x3, 0x2, 0x2, 0x2, 
       0xf62, 0xf64, 0x5, 0x216, 0x10c, 0x2, 0xf63, 0xf62, 0x3, 0x2, 0x2, 
       0x2, 0xf63, 0xf64, 0x3, 0x2, 0x2, 0x2, 0xf64, 0xf66, 0x3, 0x2, 0x2, 
       0x2, 0xf65, 0xf67, 0x5, 0x218, 0x10d, 0x2, 0xf66, 0xf65, 0x3, 0x2, 
       0x2, 0x2, 0xf66, 0xf67, 0x3, 0x2, 0x2, 0x2, 0xf67, 0xf69, 0x3, 0x2, 
       0x2, 0x2, 0xf68, 0xf48, 0x3, 0x2, 0x2, 0x2, 0xf68, 0xf52, 0x3, 0x2, 
       0x2, 0x2, 0xf68, 0xf5c, 0x3, 0x2, 0x2, 0x2, 0xf69, 0x213, 0x3, 0x2, 
       0x2, 0x2, 0xf6a, 0xf6c, 0x7, 0x1b1, 0x2, 0x2, 0xf6b, 0xf6a, 0x3, 
       0x2, 0x2, 0x2, 0xf6b, 0xf6c, 0x3, 0x2, 0x2, 0x2, 0xf6c, 0xf6d, 0x3, 
       0x2, 0x2, 0x2, 0xf6d, 0xf6e, 0x5, 0x1dc, 0xef, 0x2, 0xf6e, 0x215, 
       0x3, 0x2, 0x2, 0x2, 0xf6f, 0xf70, 0x9, 0x27, 0x2, 0x2, 0xf70, 0x217, 
       0x3, 0x2, 0x2, 0x2, 0xf71, 0xf72, 0x9, 0x28, 0x2, 0x2, 0xf72, 0x219, 
       0x3, 0x2, 0x2, 0x2, 0xf73, 0xf75, 0x7, 0x4b, 0x2, 0x2, 0xf74, 0xf76, 
       0x5, 0x21c, 0x10f, 0x2, 0xf75, 0xf74, 0x3, 0x2, 0x2, 0x2, 0xf75, 
       0xf76, 0x3, 0x2, 0x2, 0x2, 0xf76, 0xf77, 0x3, 0x2, 0x2, 0x2, 0xf77, 
       0xf78, 0x7, 0xa1, 0x2, 0x2, 0xf78, 0xf79, 0x5, 0x40c, 0x207, 0x2, 
       0xf79, 0xf7c, 0x5, 0x222, 0x112, 0x2, 0xf7a, 0xf7b, 0x7, 0x15d, 0x2, 
       0x2, 0xf7b, 0xf7d, 0x5, 0x22e, 0x118, 0x2, 0xf7c, 0xf7a, 0x3, 0x2, 
       0x2, 0x2, 0xf7c, 0xf7d, 0x3, 0x2, 0x2, 0x2, 0xf7d, 0xf7e, 0x3, 0x2, 
       0x2, 0x2, 0xf7e, 0xf83, 0x5, 0x236, 0x11c, 0x2, 0xf7f, 0xf80, 0x5, 
       0xe, 0x8, 0x2, 0xf80, 0xf81, 0x7, 0x1df, 0x2, 0x2, 0xf81, 0xf82, 
       0x5, 0xe, 0x8, 0x2, 0xf82, 0xf84, 0x3, 0x2, 0x2, 0x2, 0xf83, 0xf7f, 
       0x3, 0x2, 0x2, 0x2, 0xf83, 0xf84, 0x3, 0x2, 0x2, 0x2, 0xf84, 0x21b, 
       0x3, 0x2, 0x2, 0x2, 0xf85, 0xf86, 0x7, 0x11e, 0x2, 0x2, 0xf86, 0xf87, 
       0x7, 0x156, 0x2, 0x2, 0xf87, 0x21d, 0x3, 0x2, 0x2, 0x2, 0xf88, 0xf8a, 
       0x7, 0x1d9, 0x2, 0x2, 0xf89, 0xf8b, 0x5, 0x220, 0x111, 0x2, 0xf8a, 
       0xf89, 0x3, 0x2, 0x2, 0x2, 0xf8a, 0xf8b, 0x3, 0x2, 0x2, 0x2, 0xf8b, 
       0xf8c, 0x3, 0x2, 0x2, 0x2, 0xf8c, 0xf8d, 0x7, 0x1da, 0x2, 0x2, 0xf8d, 
       0x21f, 0x3, 0x2, 0x2, 0x2, 0xf8e, 0xf93, 0x5, 0x226, 0x114, 0x2, 
       0xf8f, 0xf90, 0x7, 0x1df, 0x2, 0x2, 0xf90, 0xf92, 0x5, 0x226, 0x114, 
       0x2, 0xf91, 0xf8f, 0x3, 0x2, 0x2, 0x2, 0xf92, 0xf95, 0x3, 0x2, 0x2, 
       0x2, 0xf93, 0xf91, 0x3, 0x2, 0x2, 0x2, 0xf93, 0xf94, 0x3, 0x2, 0x2, 
       0x2, 0xf94, 0x221, 0x3, 0x2, 0x2, 0x2, 0xf95, 0xf93, 0x3, 0x2, 0x2, 
       0x2, 0xf96, 0xf98, 0x7, 0x1d9, 0x2, 0x2, 0xf97, 0xf99, 0x5, 0x224, 
       0x113, 0x2, 0xf98, 0xf97, 0x3, 0x2, 0x2, 0x2, 0xf98, 0xf99, 0x3, 
       0x2, 0x2, 0x2, 0xf99, 0xf9a, 0x3, 0x2, 0x2, 0x2, 0xf9a, 0xf9b, 0x7, 
       0x1da, 0x2, 0x2, 0xf9b, 0x223, 0x3, 0x2, 0x2, 0x2, 0xf9c, 0xfa1, 
       0x5, 0x228, 0x115, 0x2, 0xf9d, 0xf9e, 0x7, 0x1df, 0x2, 0x2, 0xf9e, 
       0xfa0, 0x5, 0x228, 0x115, 0x2, 0xf9f, 0xf9d, 0x3, 0x2, 0x2, 0x2, 
       0xfa0, 0xfa3, 0x3, 0x2, 0x2, 0x2, 0xfa1, 0xf9f, 0x3, 0x2, 0x2, 0x2, 
       0xfa1, 0xfa2, 0x3, 0x2, 0x2, 0x2, 0xfa2, 0x225, 0x3, 0x2, 0x2, 0x2, 
       0xfa3, 0xfa1, 0x3, 0x2, 0x2, 0x2, 0xfa4, 0xfa6, 0x5, 0x22a, 0x116, 
       0x2, 0xfa5, 0xfa4, 0x3, 0x2, 0x2, 0x2, 0xfa5, 0xfa6, 0x3, 0x2, 0x2, 
       0x2, 0xfa6, 0xfa8, 0x3, 0x2, 0x2, 0x2, 0xfa7, 0xfa9, 0x5, 0x22c, 
       0x117, 0x2, 0xfa8, 0xfa7, 0x3, 0x2, 0x2, 0x2, 0xfa8, 0xfa9, 0x3, 
       0x2, 0x2, 0x2, 0xfa9, 0xfaa, 0x3, 0x2, 0x2, 0x2, 0xfaa, 0xfab, 0x5, 
       0x230, 0x119, 0x2, 0xfab, 0x227, 0x3, 0x2, 0x2, 0x2, 0xfac, 0xfaf, 
       0x5, 0x226, 0x114, 0x2, 0xfad, 0xfae, 0x9, 0x29, 0x2, 0x2, 0xfae, 
       0xfb0, 0x5, 0x362, 0x1b2, 0x2, 0xfaf, 0xfad, 0x3, 0x2, 0x2, 0x2, 
       0xfaf, 0xfb0, 0x3, 0x2, 0x2, 0x2, 0xfb0, 0x229, 0x3, 0x2, 0x2, 0x2, 
       0xfb1, 0xfb2, 0x9, 0x2a, 0x2, 0x2, 0xfb2, 0x22b, 0x3, 0x2, 0x2, 0x2, 
       0xfb3, 0xfb4, 0x5, 0x41c, 0x20f, 0x2, 0xfb4, 0x22d, 0x3, 0x2, 0x2, 
       0x2, 0xfb5, 0xfb6, 0x5, 0x230, 0x119, 0x2, 0xfb6, 0x22f, 0x3, 0x2, 
       0x2, 0x2, 0xfb7, 0xfb9, 0x7, 0x175, 0x2, 0x2, 0xfb8, 0xfb7, 0x3, 
       0x2, 0x2, 0x2, 0xfb8, 0xfb9, 0x3, 0x2, 0x2, 0x2, 0xfb9, 0xfba, 0x3, 
       0x2, 0x2, 0x2, 0xfba, 0xfc2, 0x5, 0x33a, 0x19e, 0x2, 0xfbb, 0xfbc, 
       0x7, 0x190, 0x2, 0x2, 0xfbc, 0xfbe, 0x7, 0x1d9, 0x2, 0x2, 0xfbd, 
       0xfbf, 0x5, 0x232, 0x11a, 0x2, 0xfbe, 0xfbd, 0x3, 0x2, 0x2, 0x2, 
       0xfbe, 0xfbf, 0x3, 0x2, 0x2, 0x2, 0xfbf, 0xfc0, 0x3, 0x2, 0x2, 0x2, 
       0xfc0, 0xfc2, 0x7, 0x1da, 0x2, 0x2, 0xfc1, 0xfb8, 0x3, 0x2, 0x2, 
       0x2, 0xfc1, 0xfbb, 0x3, 0x2, 0x2, 0x2, 0xfc2, 0x231, 0x3, 0x2, 0x2, 
       0x2, 0xfc3, 0xfc8, 0x5, 0x234, 0x11b, 0x2, 0xfc4, 0xfc5, 0x7, 0x1df, 
       0x2, 0x2, 0xfc5, 0xfc7, 0x5, 0x234, 0x11b, 0x2, 0xfc6, 0xfc4, 0x3, 
       0x2, 0x2, 0x2, 0xfc7, 0xfca, 0x3, 0x2, 0x2, 0x2, 0xfc8, 0xfc6, 0x3, 
       0x2, 0x2, 0x2, 0xfc8, 0xfc9, 0x3, 0x2, 0x2, 0x2, 0xfc9, 0x233, 0x3, 
       0x2, 0x2, 0x2, 0xfca, 0xfc8, 0x3, 0x2, 0x2, 0x2, 0xfcb, 0xfcc, 0x5, 
       0x41c, 0x20f, 0x2, 0xfcc, 0xfcd, 0x5, 0x33a, 0x19e, 0x2, 0xfcd, 0xfd1, 
       0x3, 0x2, 0x2, 0x2, 0xfce, 0xfcf, 0x7, 0xd9, 0x2, 0x2, 0xfcf, 0xfd1, 
       0x5, 0x3fe, 0x200, 0x2, 0xfd0, 0xfcb, 0x3, 0x2, 0x2, 0x2, 0xfd0, 
       0xfce, 0x3, 0x2, 0x2, 0x2, 0xfd1, 0x235, 0x3, 0x2, 0x2, 0x2, 0xfd2, 
       0xfd4, 0x5, 0x23a, 0x11e, 0x2, 0xfd3, 0xfd2, 0x3, 0x2, 0x2, 0x2, 
       0xfd4, 0xfd5, 0x3, 0x2, 0x2, 0x2, 0xfd5, 0xfd3, 0x3, 0x2, 0x2, 0x2, 
       0xfd5, 0xfd6, 0x3, 0x2, 0x2, 0x2, 0xfd6, 0x237, 0x3, 0x2, 0x2, 0x2, 
       0xfd7, 0xfd8, 0x7, 0x27, 0x2, 0x2, 0xfd8, 0xfd9, 0x7, 0x119, 0x2, 
       0x2, 0xfd9, 0xfda, 0x7, 0x10e, 0x2, 0x2, 0xfda, 0xff9, 0x7, 0xc3, 
       0x2, 0x2, 0xfdb, 0xfdc, 0x7, 0x15d, 0x2, 0x2, 0xfdc, 0xfdd, 0x7, 
       0x10e, 0x2, 0x2, 0xfdd, 0xfde, 0x7, 0x119, 0x2, 0x2, 0xfde, 0xfdf, 
       0x7, 0x10e, 0x2, 0x2, 0xfdf, 0xff9, 0x7, 0xc3, 0x2, 0x2, 0xfe0, 0xff9, 
       0x7, 0x187, 0x2, 0x2, 0xfe1, 0xff9, 0x7, 0xb5, 0x2, 0x2, 0xfe2, 0xff9, 
       0x7, 0x17f, 0x2, 0x2, 0xfe3, 0xff9, 0x7, 0x1be, 0x2, 0x2, 0xfe4, 
       0xfe6, 0x7, 0x8d, 0x2, 0x2, 0xfe5, 0xfe4, 0x3, 0x2, 0x2, 0x2, 0xfe5, 
       0xfe6, 0x3, 0x2, 0x2, 0x2, 0xfe6, 0xfe7, 0x3, 0x2, 0x2, 0x2, 0xfe7, 
       0xfe8, 0x7, 0x16d, 0x2, 0x2, 0xfe8, 0xff9, 0x9, 0x2b, 0x2, 0x2, 0xfe9, 
       0xfea, 0x7, 0x48, 0x2, 0x2, 0xfea, 0xff9, 0x5, 0x15e, 0xb0, 0x2, 
       0xfeb, 0xfec, 0x7, 0x165, 0x2, 0x2, 0xfec, 0xff9, 0x5, 0x15e, 0xb0, 
       0x2, 0xfed, 0xff9, 0x5, 0x66, 0x34, 0x2, 0xfee, 0xfef, 0x7, 0xfe, 
       0x2, 0x2, 0xfef, 0xff9, 0x7, 0x17e, 0x2, 0x2, 0xff0, 0xff1, 0x7, 
       0x43, 0x2, 0x2, 0xff1, 0xff9, 0x7, 0x17e, 0x2, 0x2, 0xff2, 0xff3, 
       0x7, 0x149, 0x2, 0x2, 0xff3, 0xff4, 0x7, 0x17e, 0x2, 0x2, 0xff4, 
       0xff9, 0x7, 0x5e, 0x2, 0x2, 0xff5, 0xff6, 0x7, 0xf2, 0x2, 0x2, 0xff6, 
       0xff7, 0x7, 0x17e, 0x2, 0x2, 0xff7, 0xff9, 0x7, 0x5e, 0x2, 0x2, 0xff8, 
       0xfd7, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xfdb, 0x3, 0x2, 0x2, 0x2, 0xff8, 
       0xfe0, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xfe1, 0x3, 0x2, 0x2, 0x2, 0xff8, 
       0xfe2, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xfe3, 0x3, 0x2, 0x2, 0x2, 0xff8, 
       0xfe5, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xfe9, 0x3, 0x2, 0x2, 0x2, 0xff8, 
       0xfeb, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xfed, 0x3, 0x2, 0x2, 0x2, 0xff8, 
       0xfee, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xff0, 0x3, 0x2, 0x2, 0x2, 0xff8, 
       0xff2, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xff5, 0x3, 0x2, 0x2, 0x2, 0xff9, 
       0x239, 0x3, 0x2, 0x2, 0x2, 0xffa, 0xffb, 0x7, 0x15, 0x2, 0x2, 0xffb, 
       0x1000, 0x5, 0x23c, 0x11f, 0x2, 0xffc, 0xffd, 0x7, 0xd2, 0x2, 0x2, 
       0xffd, 0x1000, 0x5, 0x62, 0x32, 0x2, 0xffe, 0x1000, 0x5, 0x238, 0x11d, 
       0x2, 0xfff, 0xffa, 0x3, 0x2, 0x2, 0x2, 0xfff, 0xffc, 0x3, 0x2, 0x2, 
       0x2, 0xfff, 0xffe, 0x3, 0x2, 0x2, 0x2, 0x1000, 0x23b, 0x3, 0x2, 0x2, 
       0x2, 0x1001, 0x1004, 0x5, 0x412, 0x20a, 0x2, 0x1002, 0x1003, 0x7, 
       0x1df, 0x2, 0x2, 0x1003, 0x1005, 0x5, 0x412, 0x20a, 0x2, 0x1004, 
       0x1002, 0x3, 0x2, 0x2, 0x2, 0x1004, 0x1005, 0x3, 0x2, 0x2, 0x2, 0x1005, 
       0x23d, 0x3, 0x2, 0x2, 0x2, 0x1006, 0x1007, 0x5, 0x22c, 0x117, 0x2, 
       0x1007, 0x1008, 0x5, 0x230, 0x119, 0x2, 0x1008, 0x23f, 0x3, 0x2, 
       0x2, 0x2, 0x1009, 0x100e, 0x5, 0x23e, 0x120, 0x2, 0x100a, 0x100b, 
       0x7, 0x1df, 0x2, 0x2, 0x100b, 0x100d, 0x5, 0x23e, 0x120, 0x2, 0x100c, 
       0x100a, 0x3, 0x2, 0x2, 0x2, 0x100d, 0x1010, 0x3, 0x2, 0x2, 0x2, 0x100e, 
       0x100c, 0x3, 0x2, 0x2, 0x2, 0x100e, 0x100f, 0x3, 0x2, 0x2, 0x2, 0x100f, 
       0x241, 0x3, 0x2, 0x2, 0x2, 0x1010, 0x100e, 0x3, 0x2, 0x2, 0x2, 0x1011, 
       0x1012, 0x7, 0xe, 0x2, 0x2, 0x1012, 0x1013, 0x7, 0xa1, 0x2, 0x2, 
       0x1013, 0x1014, 0x5, 0x204, 0x103, 0x2, 0x1014, 0x1016, 0x5, 0x244, 
       0x123, 0x2, 0x1015, 0x1017, 0x7, 0x15b, 0x2, 0x2, 0x1016, 0x1015, 
       0x3, 0x2, 0x2, 0x2, 0x1016, 0x1017, 0x3, 0x2, 0x2, 0x2, 0x1017, 0x243, 
       0x3, 0x2, 0x2, 0x2, 0x1018, 0x101d, 0x5, 0x238, 0x11d, 0x2, 0x1019, 
       0x101a, 0x7, 0x1df, 0x2, 0x2, 0x101a, 0x101c, 0x5, 0x238, 0x11d, 
       0x2, 0x101b, 0x1019, 0x3, 0x2, 0x2, 0x2, 0x101c, 0x101f, 0x3, 0x2, 
       0x2, 0x2, 0x101d, 0x101b, 0x3, 0x2, 0x2, 0x2, 0x101d, 0x101e, 0x3, 
       0x2, 0x2, 0x2, 0x101e, 0x102a, 0x3, 0x2, 0x2, 0x2, 0x101f, 0x101d, 
       0x3, 0x2, 0x2, 0x2, 0x1020, 0x1021, 0x7, 0x154, 0x2, 0x2, 0x1021, 
       0x1022, 0x7, 0x19b, 0x2, 0x2, 0x1022, 0x102a, 0x5, 0x3fe, 0x200, 
       0x2, 0x1023, 0x1024, 0x7, 0x129, 0x2, 0x2, 0x1024, 0x1025, 0x7, 0x19b, 
       0x2, 0x2, 0x1025, 0x102a, 0x5, 0x3fe, 0x200, 0x2, 0x1026, 0x1027, 
       0x7, 0x174, 0x2, 0x2, 0x1027, 0x1028, 0x7, 0x169, 0x2, 0x2, 0x1028, 
       0x102a, 0x5, 0x3fe, 0x200, 0x2, 0x1029, 0x1018, 0x3, 0x2, 0x2, 0x2, 
       0x1029, 0x1020, 0x3, 0x2, 0x2, 0x2, 0x1029, 0x1023, 0x3, 0x2, 0x2, 
       0x2, 0x1029, 0x1026, 0x3, 0x2, 0x2, 0x2, 0x102a, 0x245, 0x3, 0x2, 
       0x2, 0x2, 0x102b, 0x102c, 0x7, 0x78, 0x2, 0x2, 0x102c, 0x102f, 0x7, 
       0xa1, 0x2, 0x2, 0x102d, 0x102e, 0x7, 0xb1, 0x2, 0x2, 0x102e, 0x1030, 
       0x7, 0x8a, 0x2, 0x2, 0x102f, 0x102d, 0x3, 0x2, 0x2, 0x2, 0x102f, 
       0x1030, 0x3, 0x2, 0x2, 0x2, 0x1030, 0x1031, 0x3, 0x2, 0x2, 0x2, 0x1031, 
       0x1032, 0x5, 0x40c, 0x207, 0x2, 0x1032, 0x1034, 0x5, 0x21e, 0x110, 
       0x2, 0x1033, 0x1035, 0x5, 0x8e, 0x48, 0x2, 0x1034, 0x1033, 0x3, 0x2, 
       0x2, 0x2, 0x1034, 0x1035, 0x3, 0x2, 0x2, 0x2, 0x1035, 0x247, 0x3, 
       0x2, 0x2, 0x2, 0x1036, 0x1037, 0x7, 0x78, 0x2, 0x2, 0x1037, 0x103a, 
       0x7, 0xb, 0x2, 0x2, 0x1038, 0x1039, 0x7, 0xb1, 0x2, 0x2, 0x1039, 
       0x103b, 0x7, 0x8a, 0x2, 0x2, 0x103a, 0x1038, 0x3, 0x2, 0x2, 0x2, 
       0x103a, 0x103b, 0x3, 0x2, 0x2, 0x2, 0x103b, 0x103c, 0x3, 0x2, 0x2, 
       0x2, 0x103c, 0x103d, 0x5, 0x40c, 0x207, 0x2, 0x103d, 0x103f, 0x5, 
       0x1b4, 0xdb, 0x2, 0x103e, 0x1040, 0x5, 0x8e, 0x48, 0x2, 0x103f, 0x103e, 
       0x3, 0x2, 0x2, 0x2, 0x103f, 0x1040, 0x3, 0x2, 0x2, 0x2, 0x1040, 0x249, 
       0x3, 0x2, 0x2, 0x2, 0x1041, 0x1042, 0x7, 0x78, 0x2, 0x2, 0x1042, 
       0x1045, 0x7, 0x11b, 0x2, 0x2, 0x1043, 0x1044, 0x7, 0xb1, 0x2, 0x2, 
       0x1044, 0x1046, 0x7, 0x8a, 0x2, 0x2, 0x1045, 0x1043, 0x3, 0x2, 0x2, 
       0x2, 0x1045, 0x1046, 0x3, 0x2, 0x2, 0x2, 0x1046, 0x1047, 0x3, 0x2, 
       0x2, 0x2, 0x1047, 0x1048, 0x5, 0x24e, 0x128, 0x2, 0x1048, 0x104a, 
       0x5, 0x24c, 0x127, 0x2, 0x1049, 0x104b, 0x5, 0x8e, 0x48, 0x2, 0x104a, 
       0x1049, 0x3, 0x2, 0x2, 0x2, 0x104a, 0x104b, 0x3, 0x2, 0x2, 0x2, 0x104b, 
       0x24b, 0x3, 0x2, 0x2, 0x2, 0x104c, 0x104d, 0x7, 0x1d9, 0x2, 0x2, 
       0x104d, 0x1050, 0x5, 0x33a, 0x19e, 0x2, 0x104e, 0x104f, 0x7, 0x1df, 
       0x2, 0x2, 0x104f, 0x1051, 0x5, 0x33a, 0x19e, 0x2, 0x1050, 0x104e, 
       0x3, 0x2, 0x2, 0x2, 0x1050, 0x1051, 0x3, 0x2, 0x2, 0x2, 0x1051, 0x1052, 
       0x3, 0x2, 0x2, 0x2, 0x1052, 0x1053, 0x7, 0x1da, 0x2, 0x2, 0x1053, 
       0x1061, 0x3, 0x2, 0x2, 0x2, 0x1054, 0x1055, 0x7, 0x1d9, 0x2, 0x2, 
       0x1055, 0x1056, 0x7, 0x105, 0x2, 0x2, 0x1056, 0x1057, 0x7, 0x1df, 
       0x2, 0x2, 0x1057, 0x1058, 0x5, 0x33a, 0x19e, 0x2, 0x1058, 0x1059, 
       0x7, 0x1da, 0x2, 0x2, 0x1059, 0x1061, 0x3, 0x2, 0x2, 0x2, 0x105a, 
       0x105b, 0x7, 0x1d9, 0x2, 0x2, 0x105b, 0x105c, 0x5, 0x33a, 0x19e, 
       0x2, 0x105c, 0x105d, 0x7, 0x1df, 0x2, 0x2, 0x105d, 0x105e, 0x7, 0x105, 
       0x2, 0x2, 0x105e, 0x105f, 0x7, 0x1da, 0x2, 0x2, 0x105f, 0x1061, 0x3, 
       0x2, 0x2, 0x2, 0x1060, 0x104c, 0x3, 0x2, 0x2, 0x2, 0x1060, 0x1054, 
       0x3, 0x2, 0x2, 0x2, 0x1060, 0x105a, 0x3, 0x2, 0x2, 0x2, 0x1061, 0x24d, 
       0x3, 0x2, 0x2, 0x2, 0x1062, 0x1068, 0x5, 0x3b0, 0x1d9, 0x2, 0x1063, 
       0x1064, 0x5, 0x41a, 0x20e, 0x2, 0x1064, 0x1065, 0x7, 0x1e3, 0x2, 
       0x2, 0x1065, 0x1066, 0x5, 0x24e, 0x128, 0x2, 0x1066, 0x1068, 0x3, 
       0x2, 0x2, 0x2, 0x1067, 0x1062, 0x3, 0x2, 0x2, 0x2, 0x1067, 0x1063, 
       0x3, 0x2, 0x2, 0x2, 0x1068, 0x24f, 0x3, 0x2, 0x2, 0x2, 0x1069, 0x106b, 
       0x7, 0x74, 0x2, 0x2, 0x106a, 0x106c, 0x5, 0x252, 0x12a, 0x2, 0x106b, 
       0x106a, 0x3, 0x2, 0x2, 0x2, 0x106c, 0x106d, 0x3, 0x2, 0x2, 0x2, 0x106d, 
       0x106b, 0x3, 0x2, 0x2, 0x2, 0x106d, 0x106e, 0x3, 0x2, 0x2, 0x2, 0x106e, 
       0x251, 0x3, 0x2, 0x2, 0x2, 0x106f, 0x1071, 0x7, 0xd2, 0x2, 0x2, 0x1070, 
       0x106f, 0x3, 0x2, 0x2, 0x2, 0x1070, 0x1071, 0x3, 0x2, 0x2, 0x2, 0x1071, 
       0x1072, 0x3, 0x2, 0x2, 0x2, 0x1072, 0x1073, 0x5, 0x62, 0x32, 0x2, 
       0x1073, 0x253, 0x3, 0x2, 0x2, 0x2, 0x1074, 0x1075, 0x7, 0x4b, 0x2, 
       0x2, 0x1075, 0x1076, 0x7, 0x2b, 0x2, 0x2, 0x1076, 0x1077, 0x7, 0x1d9, 
       0x2, 0x2, 0x1077, 0x1078, 0x5, 0x33a, 0x19e, 0x2, 0x1078, 0x1079, 
       0x7, 0x15, 0x2, 0x2, 0x1079, 0x107a, 0x5, 0x33a, 0x19e, 0x2, 0x107a, 
       0x107b, 0x7, 0x1da, 0x2, 0x2, 0x107b, 0x107c, 0x7, 0x1c4, 0x2, 0x2, 
       0x107c, 0x107e, 0x7, 0xa1, 0x2, 0x2, 0x107d, 0x107f, 0x5, 0x204, 
       0x103, 0x2, 0x107e, 0x107d, 0x3, 0x2, 0x2, 0x2, 0x107e, 0x107f, 0x3, 
       0x2, 0x2, 0x2, 0x107f, 0x1081, 0x3, 0x2, 0x2, 0x2, 0x1080, 0x1082, 
       0x5, 0x256, 0x12c, 0x2, 0x1081, 0x1080, 0x3, 0x2, 0x2, 0x2, 0x1081, 
       0x1082, 0x3, 0x2, 0x2, 0x2, 0x1082, 0x255, 0x3, 0x2, 0x2, 0x2, 0x1083, 
       0x1084, 0x7, 0x15, 0x2, 0x2, 0x1084, 0x1088, 0x7, 0xb6, 0x2, 0x2, 
       0x1085, 0x1086, 0x7, 0x15, 0x2, 0x2, 0x1086, 0x1088, 0x7, 0x18, 0x2, 
       0x2, 0x1087, 0x1083, 0x3, 0x2, 0x2, 0x2, 0x1087, 0x1085, 0x3, 0x2, 
       0x2, 0x2, 0x1088, 0x257, 0x3, 0x2, 0x2, 0x2, 0x1089, 0x108a, 0x7, 
       0x78, 0x2, 0x2, 0x108a, 0x108d, 0x7, 0x2b, 0x2, 0x2, 0x108b, 0x108c, 
       0x7, 0xb1, 0x2, 0x2, 0x108c, 0x108e, 0x7, 0x8a, 0x2, 0x2, 0x108d, 
       0x108b, 0x3, 0x2, 0x2, 0x2, 0x108d, 0x108e, 0x3, 0x2, 0x2, 0x2, 0x108e, 
       0x108f, 0x3, 0x2, 0x2, 0x2, 0x108f, 0x1090, 0x7, 0x1d9, 0x2, 0x2, 
       0x1090, 0x1091, 0x5, 0x33a, 0x19e, 0x2, 0x1091, 0x1092, 0x7, 0x15, 
       0x2, 0x2, 0x1092, 0x1093, 0x5, 0x33a, 0x19e, 0x2, 0x1093, 0x1095, 
       0x7, 0x1da, 0x2, 0x2, 0x1094, 0x1096, 0x5, 0x8e, 0x48, 0x2, 0x1095, 
       0x1094, 0x3, 0x2, 0x2, 0x2, 0x1095, 0x1096, 0x3, 0x2, 0x2, 0x2, 0x1096, 
       0x259, 0x3, 0x2, 0x2, 0x2, 0x1097, 0x1098, 0x7, 0x150, 0x2, 0x2, 
       0x1098, 0x1099, 0x9, 0x2c, 0x2, 0x2, 0x1099, 0x109b, 0x5, 0x3fa, 
       0x1fe, 0x2, 0x109a, 0x109c, 0x7, 0x9a, 0x2, 0x2, 0x109b, 0x109a, 
       0x3, 0x2, 0x2, 0x2, 0x109b, 0x109c, 0x3, 0x2, 0x2, 0x2, 0x109c, 0x25b, 
       0x3, 0x2, 0x2, 0x2, 0x109d, 0x109e, 0x7, 0xe, 0x2, 0x2, 0x109e, 0x109f, 
       0x7, 0x1a4, 0x2, 0x2, 0x109f, 0x10a0, 0x5, 0x33e, 0x1a0, 0x2, 0x10a0, 
       0x10a1, 0x7, 0x174, 0x2, 0x2, 0x10a1, 0x10a2, 0x7, 0x65, 0x2, 0x2, 
       0x10a2, 0x10a3, 0x7, 0x7d, 0x2, 0x2, 0x10a3, 0x10a4, 0x5, 0x1ac, 
       0xd7, 0x2, 0x10a4, 0x25d, 0x3, 0x2, 0x2, 0x2, 0x10a5, 0x10a6, 0x7, 
       0xe, 0x2, 0x2, 0x10a6, 0x10a7, 0x7, 0xb, 0x2, 0x2, 0x10a7, 0x10a8, 
       0x5, 0x40c, 0x207, 0x2, 0x10a8, 0x10a9, 0x5, 0x1b4, 0xdb, 0x2, 0x10a9, 
       0x10aa, 0x7, 0x154, 0x2, 0x2, 0x10aa, 0x10ab, 0x7, 0x19b, 0x2, 0x2, 
       0x10ab, 0x10ac, 0x5, 0x3fe, 0x200, 0x2, 0x10ac, 0x1125, 0x3, 0x2, 
       0x2, 0x2, 0x10ad, 0x10ae, 0x7, 0xe, 0x2, 0x2, 0x10ae, 0x10af, 0x7, 
       0x46, 0x2, 0x2, 0x10af, 0x10b0, 0x5, 0x1dc, 0xef, 0x2, 0x10b0, 0x10b1, 
       0x7, 0x154, 0x2, 0x2, 0x10b1, 0x10b2, 0x7, 0x19b, 0x2, 0x2, 0x10b2, 
       0x10b3, 0x5, 0x3fe, 0x200, 0x2, 0x10b3, 0x1125, 0x3, 0x2, 0x2, 0x2, 
       0x10b4, 0x10b5, 0x7, 0xe, 0x2, 0x2, 0x10b5, 0x10b6, 0x7, 0x5d, 0x2, 
       0x2, 0x10b6, 0x10b7, 0x5, 0x402, 0x202, 0x2, 0x10b7, 0x10b8, 0x7, 
       0x154, 0x2, 0x2, 0x10b8, 0x10b9, 0x7, 0x19b, 0x2, 0x2, 0x10b9, 0x10ba, 
       0x5, 0x402, 0x202, 0x2, 0x10ba, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x10bb, 
       0x10bc, 0x7, 0xe, 0x2, 0x2, 0x10bc, 0x10bd, 0x7, 0x93, 0x2, 0x2, 
       0x10bd, 0x10be, 0x5, 0x3fe, 0x200, 0x2, 0x10be, 0x10bf, 0x7, 0x154, 
       0x2, 0x2, 0x10bf, 0x10c0, 0x7, 0x19b, 0x2, 0x2, 0x10c0, 0x10c1, 0x5, 
       0x3fe, 0x200, 0x2, 0x10c1, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x10c2, 0x10c3, 
       0x7, 0xe, 0x2, 0x2, 0x10c3, 0x10c4, 0x7, 0xa1, 0x2, 0x2, 0x10c4, 
       0x10c5, 0x5, 0x204, 0x103, 0x2, 0x10c5, 0x10c6, 0x7, 0x154, 0x2, 
       0x2, 0x10c6, 0x10c7, 0x7, 0x19b, 0x2, 0x2, 0x10c7, 0x10c8, 0x5, 0x3fe, 
       0x200, 0x2, 0x10c8, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x10c9, 0x10ca, 0x7, 
       0xe, 0x2, 0x2, 0x10ca, 0x10cb, 0x7, 0xa8, 0x2, 0x2, 0x10cb, 0x10cc, 
       0x5, 0x414, 0x20b, 0x2, 0x10cc, 0x10cd, 0x7, 0x154, 0x2, 0x2, 0x10cd, 
       0x10ce, 0x7, 0x19b, 0x2, 0x2, 0x10ce, 0x10cf, 0x5, 0x414, 0x20b, 
       0x2, 0x10cf, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x10d0, 0x10d2, 0x7, 0xe, 
       0x2, 0x2, 0x10d1, 0x10d3, 0x7, 0x13e, 0x2, 0x2, 0x10d2, 0x10d1, 0x3, 
       0x2, 0x2, 0x2, 0x10d2, 0x10d3, 0x3, 0x2, 0x2, 0x2, 0x10d3, 0x10d4, 
       0x3, 0x2, 0x2, 0x2, 0x10d4, 0x10d5, 0x7, 0xd2, 0x2, 0x2, 0x10d5, 
       0x10d6, 0x5, 0x3fe, 0x200, 0x2, 0x10d6, 0x10d7, 0x7, 0x154, 0x2, 
       0x2, 0x10d7, 0x10d8, 0x7, 0x19b, 0x2, 0x2, 0x10d8, 0x10d9, 0x5, 0x3fe, 
       0x200, 0x2, 0x10d9, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x10da, 0x10db, 0x7, 
       0xe, 0x2, 0x2, 0x10db, 0x10dc, 0x7, 0x11b, 0x2, 0x2, 0x10dc, 0x10dd, 
       0x9, 0x24, 0x2, 0x2, 0x10dd, 0x10de, 0x5, 0x1dc, 0xef, 0x2, 0x10de, 
       0x10df, 0x7, 0x1b1, 0x2, 0x2, 0x10df, 0x10e0, 0x5, 0x404, 0x203, 
       0x2, 0x10e0, 0x10e1, 0x7, 0x154, 0x2, 0x2, 0x10e1, 0x10e2, 0x7, 0x19b, 
       0x2, 0x2, 0x10e2, 0x10e3, 0x5, 0x3fe, 0x200, 0x2, 0x10e3, 0x1125, 
       0x3, 0x2, 0x2, 0x2, 0x10e4, 0x10e5, 0x7, 0xe, 0x2, 0x2, 0x10e5, 0x10e6, 
       0x7, 0x169, 0x2, 0x2, 0x10e6, 0x10e7, 0x5, 0x3fe, 0x200, 0x2, 0x10e7, 
       0x10e8, 0x7, 0x154, 0x2, 0x2, 0x10e8, 0x10e9, 0x7, 0x19b, 0x2, 0x2, 
       0x10e9, 0x10ea, 0x5, 0x3fe, 0x200, 0x2, 0x10ea, 0x1125, 0x3, 0x2, 
       0x2, 0x2, 0x10eb, 0x10ec, 0x7, 0xe, 0x2, 0x2, 0x10ec, 0x10ed, 0x9, 
       0x2d, 0x2, 0x2, 0x10ed, 0x10ee, 0x5, 0x32c, 0x197, 0x2, 0x10ee, 0x10ef, 
       0x7, 0x154, 0x2, 0x2, 0x10ef, 0x10f0, 0x7, 0x19b, 0x2, 0x2, 0x10f0, 
       0x10f1, 0x5, 0x3fe, 0x200, 0x2, 0x10f1, 0x1125, 0x3, 0x2, 0x2, 0x2, 
       0x10f2, 0x10f3, 0x7, 0xe, 0x2, 0x2, 0x10f3, 0x10f4, 0x7, 0x190, 0x2, 
       0x2, 0x10f4, 0x10f5, 0x5, 0x32c, 0x197, 0x2, 0x10f5, 0x10f7, 0x7, 
       0x154, 0x2, 0x2, 0x10f6, 0x10f8, 0x5, 0x260, 0x131, 0x2, 0x10f7, 
       0x10f6, 0x3, 0x2, 0x2, 0x2, 0x10f7, 0x10f8, 0x3, 0x2, 0x2, 0x2, 0x10f8, 
       0x10f9, 0x3, 0x2, 0x2, 0x2, 0x10f9, 0x10fa, 0x5, 0x3fe, 0x200, 0x2, 
       0x10fa, 0x10fb, 0x7, 0x19b, 0x2, 0x2, 0x10fb, 0x10fc, 0x5, 0x3fe, 
       0x200, 0x2, 0x10fc, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x10fd, 0x10fe, 0x7, 
       0xe, 0x2, 0x2, 0x10fe, 0x10ff, 0x7, 0x19f, 0x2, 0x2, 0x10ff, 0x1100, 
       0x5, 0x3fe, 0x200, 0x2, 0x1100, 0x1101, 0x7, 0x119, 0x2, 0x2, 0x1101, 
       0x1102, 0x5, 0x32c, 0x197, 0x2, 0x1102, 0x1103, 0x7, 0x154, 0x2, 
       0x2, 0x1103, 0x1104, 0x7, 0x19b, 0x2, 0x2, 0x1104, 0x1105, 0x5, 0x3fe, 
       0x200, 0x2, 0x1105, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x1106, 0x1107, 0x7, 
       0xe, 0x2, 0x2, 0x1107, 0x1108, 0x9, 0x2e, 0x2, 0x2, 0x1108, 0x1109, 
       0x5, 0x414, 0x20b, 0x2, 0x1109, 0x110a, 0x7, 0x154, 0x2, 0x2, 0x110a, 
       0x110b, 0x7, 0x19b, 0x2, 0x2, 0x110b, 0x110c, 0x5, 0x414, 0x20b, 
       0x2, 0x110c, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x110d, 0x110e, 0x7, 0xe, 
       0x2, 0x2, 0x110e, 0x110f, 0x7, 0x191, 0x2, 0x2, 0x110f, 0x1110, 0x5, 
       0x3fe, 0x200, 0x2, 0x1110, 0x1111, 0x7, 0x154, 0x2, 0x2, 0x1111, 
       0x1112, 0x7, 0x19b, 0x2, 0x2, 0x1112, 0x1113, 0x5, 0x3fe, 0x200, 
       0x2, 0x1113, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x1114, 0x1115, 0x7, 0xe, 
       0x2, 0x2, 0x1115, 0x1116, 0x7, 0x195, 0x2, 0x2, 0x1116, 0x1117, 0x7, 
       0x16b, 0x2, 0x2, 0x1117, 0x1118, 0x9, 0x21, 0x2, 0x2, 0x1118, 0x1119, 
       0x5, 0x1dc, 0xef, 0x2, 0x1119, 0x111a, 0x7, 0x154, 0x2, 0x2, 0x111a, 
       0x111b, 0x7, 0x19b, 0x2, 0x2, 0x111b, 0x111c, 0x5, 0x3fe, 0x200, 
       0x2, 0x111c, 0x1125, 0x3, 0x2, 0x2, 0x2, 
  };
  static uint16_t serializedATNSegment2[] = {
    0x111d, 0x111e, 0x7, 0xe, 0x2, 0x2, 0x111e, 0x111f, 0x7, 0x141, 0x2, 
       0x2, 0x111f, 0x1120, 0x5, 0x3fe, 0x200, 0x2, 0x1120, 0x1121, 0x7, 
       0x154, 0x2, 0x2, 0x1121, 0x1122, 0x7, 0x19b, 0x2, 0x2, 0x1122, 0x1123, 
       0x5, 0x3fe, 0x200, 0x2, 0x1123, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x10a5, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x10ad, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x10b4, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x10bb, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x10c2, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x10c9, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x10d0, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x10da, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x10e4, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x10eb, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x10f2, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x10fd, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x1106, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x110d, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x1114, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x111d, 0x3, 0x2, 0x2, 0x2, 0x1125, 
       0x25f, 0x3, 0x2, 0x2, 0x2, 0x1126, 0x1127, 0x7, 0x37, 0x2, 0x2, 0x1127, 
       0x261, 0x3, 0x2, 0x2, 0x2, 0x1128, 0x1129, 0x7, 0xe, 0x2, 0x2, 0x1129, 
       0x112a, 0x7, 0xb, 0x2, 0x2, 0x112a, 0x112b, 0x5, 0x40c, 0x207, 0x2, 
       0x112b, 0x112c, 0x5, 0x1b4, 0xdb, 0x2, 0x112c, 0x112d, 0x7, 0x174, 
       0x2, 0x2, 0x112d, 0x112e, 0x7, 0x169, 0x2, 0x2, 0x112e, 0x112f, 0x5, 
       0x3fe, 0x200, 0x2, 0x112f, 0x114d, 0x3, 0x2, 0x2, 0x2, 0x1130, 0x1131, 
       0x7, 0xe, 0x2, 0x2, 0x1131, 0x1132, 0x9, 0x2f, 0x2, 0x2, 0x1132, 
       0x1133, 0x5, 0x1dc, 0xef, 0x2, 0x1133, 0x1134, 0x7, 0x174, 0x2, 0x2, 
       0x1134, 0x1135, 0x7, 0x169, 0x2, 0x2, 0x1135, 0x1136, 0x5, 0x3fe, 
       0x200, 0x2, 0x1136, 0x114d, 0x3, 0x2, 0x2, 0x2, 0x1137, 0x1138, 0x7, 
       0xe, 0x2, 0x2, 0x1138, 0x1139, 0x7, 0xa1, 0x2, 0x2, 0x1139, 0x113a, 
       0x5, 0x204, 0x103, 0x2, 0x113a, 0x113b, 0x7, 0x174, 0x2, 0x2, 0x113b, 
       0x113c, 0x7, 0x169, 0x2, 0x2, 0x113c, 0x113d, 0x5, 0x3fe, 0x200, 
       0x2, 0x113d, 0x114d, 0x3, 0x2, 0x2, 0x2, 0x113e, 0x113f, 0x7, 0xe, 
       0x2, 0x2, 0x113f, 0x1140, 0x9, 0x30, 0x2, 0x2, 0x1140, 0x1141, 0x5, 
       0x32c, 0x197, 0x2, 0x1141, 0x1142, 0x7, 0x174, 0x2, 0x2, 0x1142, 
       0x1143, 0x7, 0x169, 0x2, 0x2, 0x1143, 0x1144, 0x5, 0x3fe, 0x200, 
       0x2, 0x1144, 0x114d, 0x3, 0x2, 0x2, 0x2, 0x1145, 0x1146, 0x7, 0xe, 
       0x2, 0x2, 0x1146, 0x1147, 0x7, 0x1a4, 0x2, 0x2, 0x1147, 0x1148, 0x5, 
       0x33e, 0x1a0, 0x2, 0x1148, 0x1149, 0x7, 0x174, 0x2, 0x2, 0x1149, 
       0x114a, 0x7, 0x169, 0x2, 0x2, 0x114a, 0x114b, 0x5, 0x3fe, 0x200, 
       0x2, 0x114b, 0x114d, 0x3, 0x2, 0x2, 0x2, 0x114c, 0x1128, 0x3, 0x2, 
       0x2, 0x2, 0x114c, 0x1130, 0x3, 0x2, 0x2, 0x2, 0x114c, 0x1137, 0x3, 
       0x2, 0x2, 0x2, 0x114c, 0x113e, 0x3, 0x2, 0x2, 0x2, 0x114c, 0x1145, 
       0x3, 0x2, 0x2, 0x2, 0x114d, 0x263, 0x3, 0x2, 0x2, 0x2, 0x114e, 0x114f, 
       0x7, 0xe, 0x2, 0x2, 0x114f, 0x1150, 0x7, 0xb, 0x2, 0x2, 0x1150, 0x1151, 
       0x5, 0x40c, 0x207, 0x2, 0x1151, 0x1152, 0x5, 0x1b4, 0xdb, 0x2, 0x1152, 
       0x1153, 0x7, 0x129, 0x2, 0x2, 0x1153, 0x1154, 0x7, 0x19b, 0x2, 0x2, 
       0x1154, 0x1155, 0x5, 0x414, 0x20b, 0x2, 0x1155, 0x1198, 0x3, 0x2, 
       0x2, 0x2, 0x1156, 0x1157, 0x7, 0xe, 0x2, 0x2, 0x1157, 0x1158, 0x9, 
       0x31, 0x2, 0x2, 0x1158, 0x1159, 0x5, 0x1dc, 0xef, 0x2, 0x1159, 0x115a, 
       0x7, 0x129, 0x2, 0x2, 0x115a, 0x115b, 0x7, 0x19b, 0x2, 0x2, 0x115b, 
       0x115c, 0x5, 0x414, 0x20b, 0x2, 0x115c, 0x1198, 0x3, 0x2, 0x2, 0x2, 
       0x115d, 0x115e, 0x7, 0xe, 0x2, 0x2, 0x115e, 0x115f, 0x9, 0x32, 0x2, 
       0x2, 0x115f, 0x1160, 0x5, 0x3fe, 0x200, 0x2, 0x1160, 0x1161, 0x7, 
       0x129, 0x2, 0x2, 0x1161, 0x1162, 0x7, 0x19b, 0x2, 0x2, 0x1162, 0x1163, 
       0x5, 0x414, 0x20b, 0x2, 0x1163, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x1164, 
       0x1165, 0x7, 0xe, 0x2, 0x2, 0x1165, 0x1166, 0x7, 0xa1, 0x2, 0x2, 
       0x1166, 0x1167, 0x5, 0x204, 0x103, 0x2, 0x1167, 0x1168, 0x7, 0x129, 
       0x2, 0x2, 0x1168, 0x1169, 0x7, 0x19b, 0x2, 0x2, 0x1169, 0x116a, 0x5, 
       0x414, 0x20b, 0x2, 0x116a, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x116b, 0x116d, 
       0x7, 0xe, 0x2, 0x2, 0x116c, 0x116e, 0x7, 0x13e, 0x2, 0x2, 0x116d, 
       0x116c, 0x3, 0x2, 0x2, 0x2, 0x116d, 0x116e, 0x3, 0x2, 0x2, 0x2, 0x116e, 
       0x116f, 0x3, 0x2, 0x2, 0x2, 0x116f, 0x1170, 0x7, 0xd2, 0x2, 0x2, 
       0x1170, 0x1171, 0x5, 0x3fe, 0x200, 0x2, 0x1171, 0x1172, 0x7, 0x129, 
       0x2, 0x2, 0x1172, 0x1173, 0x7, 0x19b, 0x2, 0x2, 0x1173, 0x1174, 0x5, 
       0x414, 0x20b, 0x2, 0x1174, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x1175, 0x1176, 
       0x7, 0xe, 0x2, 0x2, 0x1176, 0x1177, 0x7, 0x11b, 0x2, 0x2, 0x1177, 
       0x1178, 0x5, 0x24e, 0x128, 0x2, 0x1178, 0x1179, 0x5, 0x24c, 0x127, 
       0x2, 0x1179, 0x117a, 0x7, 0x129, 0x2, 0x2, 0x117a, 0x117b, 0x7, 0x19b, 
       0x2, 0x2, 0x117b, 0x117c, 0x5, 0x414, 0x20b, 0x2, 0x117c, 0x1198, 
       0x3, 0x2, 0x2, 0x2, 0x117d, 0x117e, 0x7, 0xe, 0x2, 0x2, 0x117e, 0x117f, 
       0x7, 0x11b, 0x2, 0x2, 0x117f, 0x1180, 0x9, 0x24, 0x2, 0x2, 0x1180, 
       0x1181, 0x5, 0x1dc, 0xef, 0x2, 0x1181, 0x1182, 0x7, 0x1b1, 0x2, 0x2, 
       0x1182, 0x1183, 0x5, 0x404, 0x203, 0x2, 0x1183, 0x1184, 0x7, 0x129, 
       0x2, 0x2, 0x1184, 0x1185, 0x7, 0x19b, 0x2, 0x2, 0x1185, 0x1186, 0x5, 
       0x414, 0x20b, 0x2, 0x1186, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x1187, 0x1188, 
       0x7, 0xe, 0x2, 0x2, 0x1188, 0x1189, 0x7, 0x1a4, 0x2, 0x2, 0x1189, 
       0x118a, 0x5, 0x33e, 0x1a0, 0x2, 0x118a, 0x118b, 0x7, 0x129, 0x2, 
       0x2, 0x118b, 0x118c, 0x7, 0x19b, 0x2, 0x2, 0x118c, 0x118d, 0x5, 0x414, 
       0x20b, 0x2, 0x118d, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x118e, 0x118f, 0x7, 
       0xe, 0x2, 0x2, 0x118f, 0x1190, 0x7, 0x195, 0x2, 0x2, 0x1190, 0x1191, 
       0x7, 0x16b, 0x2, 0x2, 0x1191, 0x1192, 0x9, 0x33, 0x2, 0x2, 0x1192, 
       0x1193, 0x5, 0x1dc, 0xef, 0x2, 0x1193, 0x1194, 0x7, 0x129, 0x2, 0x2, 
       0x1194, 0x1195, 0x7, 0x19b, 0x2, 0x2, 0x1195, 0x1196, 0x5, 0x414, 
       0x20b, 0x2, 0x1196, 0x1198, 0x3, 0x2, 0x2, 0x2, 0x1197, 0x114e, 0x3, 
       0x2, 0x2, 0x2, 0x1197, 0x1156, 0x3, 0x2, 0x2, 0x2, 0x1197, 0x115d, 
       0x3, 0x2, 0x2, 0x2, 0x1197, 0x1164, 0x3, 0x2, 0x2, 0x2, 0x1197, 0x116b, 
       0x3, 0x2, 0x2, 0x2, 0x1197, 0x1175, 0x3, 0x2, 0x2, 0x2, 0x1197, 0x117d, 
       0x3, 0x2, 0x2, 0x2, 0x1197, 0x1187, 0x3, 0x2, 0x2, 0x2, 0x1197, 0x118e, 
       0x3, 0x2, 0x2, 0x2, 0x1198, 0x265, 0x3, 0x2, 0x2, 0x2, 0x1199, 0x119b, 
       0x7, 0x4b, 0x2, 0x2, 0x119a, 0x119c, 0x5, 0x21c, 0x10f, 0x2, 0x119b, 
       0x119a, 0x3, 0x2, 0x2, 0x2, 0x119b, 0x119c, 0x3, 0x2, 0x2, 0x2, 0x119c, 
       0x119d, 0x3, 0x2, 0x2, 0x2, 0x119d, 0x119e, 0x7, 0x166, 0x2, 0x2, 
       0x119e, 0x119f, 0x5, 0x3fe, 0x200, 0x2, 0x119f, 0x11a0, 0x7, 0x15, 
       0x2, 0x2, 0x11a0, 0x11a1, 0x7, 0x119, 0x2, 0x2, 0x11a1, 0x11a2, 0x5, 
       0x26e, 0x138, 0x2, 0x11a2, 0x11a3, 0x7, 0x19b, 0x2, 0x2, 0x11a3, 
       0x11a5, 0x5, 0x3fa, 0x1fe, 0x2, 0x11a4, 0x11a6, 0x5, 0x332, 0x19a, 
       0x2, 0x11a5, 0x11a4, 0x3, 0x2, 0x2, 0x2, 0x11a5, 0x11a6, 0x3, 0x2, 
       0x2, 0x2, 0x11a6, 0x11a7, 0x3, 0x2, 0x2, 0x2, 0x11a7, 0x11a9, 0x7, 
       0x74, 0x2, 0x2, 0x11a8, 0x11aa, 0x5, 0x270, 0x139, 0x2, 0x11a9, 0x11a8, 
       0x3, 0x2, 0x2, 0x2, 0x11a9, 0x11aa, 0x3, 0x2, 0x2, 0x2, 0x11aa, 0x11ab, 
       0x3, 0x2, 0x2, 0x2, 0x11ab, 0x11ac, 0x5, 0x268, 0x135, 0x2, 0x11ac, 
       0x267, 0x3, 0x2, 0x2, 0x2, 0x11ad, 0x11b5, 0x7, 0x109, 0x2, 0x2, 
       0x11ae, 0x11b5, 0x5, 0x26c, 0x137, 0x2, 0x11af, 0x11b1, 0x7, 0x1d9, 
       0x2, 0x2, 0x11b0, 0x11b2, 0x5, 0x26a, 0x136, 0x2, 0x11b1, 0x11b0, 
       0x3, 0x2, 0x2, 0x2, 0x11b1, 0x11b2, 0x3, 0x2, 0x2, 0x2, 0x11b2, 0x11b3, 
       0x3, 0x2, 0x2, 0x2, 0x11b3, 0x11b5, 0x7, 0x1da, 0x2, 0x2, 0x11b4, 
       0x11ad, 0x3, 0x2, 0x2, 0x2, 0x11b4, 0x11ae, 0x3, 0x2, 0x2, 0x2, 0x11b4, 
       0x11af, 0x3, 0x2, 0x2, 0x2, 0x11b5, 0x269, 0x3, 0x2, 0x2, 0x2, 0x11b6, 
       0x11bb, 0x5, 0x26c, 0x137, 0x2, 0x11b7, 0x11b8, 0x7, 0x1ed, 0x2, 
       0x2, 0x11b8, 0x11ba, 0x5, 0x26c, 0x137, 0x2, 0x11b9, 0x11b7, 0x3, 
       0x2, 0x2, 0x2, 0x11ba, 0x11bd, 0x3, 0x2, 0x2, 0x2, 0x11bb, 0x11b9, 
       0x3, 0x2, 0x2, 0x2, 0x11bb, 0x11bc, 0x3, 0x2, 0x2, 0x2, 0x11bc, 0x26b, 
       0x3, 0x2, 0x2, 0x2, 0x11bd, 0x11bb, 0x3, 0x2, 0x2, 0x2, 0x11be, 0x11c4, 
       0x5, 0x2e6, 0x174, 0x2, 0x11bf, 0x11c4, 0x5, 0x2c0, 0x161, 0x2, 0x11c0, 
       0x11c4, 0x5, 0x2d2, 0x16a, 0x2, 0x11c1, 0x11c4, 0x5, 0x2ca, 0x166, 
       0x2, 0x11c2, 0x11c4, 0x5, 0x274, 0x13b, 0x2, 0x11c3, 0x11be, 0x3, 
       0x2, 0x2, 0x2, 0x11c3, 0x11bf, 0x3, 0x2, 0x2, 0x2, 0x11c3, 0x11c0, 
       0x3, 0x2, 0x2, 0x2, 0x11c3, 0x11c1, 0x3, 0x2, 0x2, 0x2, 0x11c3, 0x11c2, 
       0x3, 0x2, 0x2, 0x2, 0x11c4, 0x26d, 0x3, 0x2, 0x2, 0x2, 0x11c5, 0x11c6, 
       0x9, 0x34, 0x2, 0x2, 0x11c6, 0x26f, 0x3, 0x2, 0x2, 0x2, 0x11c7, 0x11c8, 
       0x9, 0x35, 0x2, 0x2, 0x11c8, 0x271, 0x3, 0x2, 0x2, 0x2, 0x11c9, 0x11ca, 
       0x7, 0x78, 0x2, 0x2, 0x11ca, 0x11cd, 0x7, 0x166, 0x2, 0x2, 0x11cb, 
       0x11cc, 0x7, 0xb1, 0x2, 0x2, 0x11cc, 0x11ce, 0x7, 0x8a, 0x2, 0x2, 
       0x11cd, 0x11cb, 0x3, 0x2, 0x2, 0x2, 0x11cd, 0x11ce, 0x3, 0x2, 0x2, 
       0x2, 0x11ce, 0x11cf, 0x3, 0x2, 0x2, 0x2, 0x11cf, 0x11d0, 0x5, 0x3fe, 
       0x200, 0x2, 0x11d0, 0x11d1, 0x7, 0x119, 0x2, 0x2, 0x11d1, 0x11d3, 
       0x5, 0x3fa, 0x1fe, 0x2, 0x11d2, 0x11d4, 0x5, 0x8e, 0x48, 0x2, 0x11d3, 
       0x11d2, 0x3, 0x2, 0x2, 0x2, 0x11d3, 0x11d4, 0x3, 0x2, 0x2, 0x2, 0x11d4, 
       0x273, 0x3, 0x2, 0x2, 0x2, 0x11d5, 0x11d6, 0x7, 0x10a, 0x2, 0x2, 
       0x11d6, 0x11d7, 0x5, 0x41a, 0x20e, 0x2, 0x11d7, 0x275, 0x3, 0x2, 
       0x2, 0x2, 0x11d8, 0x11d9, 0x7, 0xdc, 0x2, 0x2, 0x11d9, 0x11da, 0x5, 
       0x41a, 0x20e, 0x2, 0x11da, 0x277, 0x3, 0x2, 0x2, 0x2, 0x11db, 0x11dc, 
       0x7, 0x1ac, 0x2, 0x2, 0x11dc, 0x11e0, 0x5, 0x41a, 0x20e, 0x2, 0x11dd, 
       0x11de, 0x7, 0x1ac, 0x2, 0x2, 0x11de, 0x11e0, 0x7, 0x1dc, 0x2, 0x2, 
       0x11df, 0x11db, 0x3, 0x2, 0x2, 0x2, 0x11df, 0x11dd, 0x3, 0x2, 0x2, 
       0x2, 0x11e0, 0x279, 0x3, 0x2, 0x2, 0x2, 0x11e1, 0x11e3, 0x9, 0x36, 
       0x2, 0x2, 0x11e2, 0x11e4, 0x5, 0x27c, 0x13f, 0x2, 0x11e3, 0x11e2, 
       0x3, 0x2, 0x2, 0x2, 0x11e3, 0x11e4, 0x3, 0x2, 0x2, 0x2, 0x11e4, 0x1208, 
       0x3, 0x2, 0x2, 0x2, 0x11e5, 0x11e7, 0x7, 0x1e, 0x2, 0x2, 0x11e6, 
       0x11e8, 0x5, 0x27c, 0x13f, 0x2, 0x11e7, 0x11e6, 0x3, 0x2, 0x2, 0x2, 
       0x11e7, 0x11e8, 0x3, 0x2, 0x2, 0x2, 0x11e8, 0x11ea, 0x3, 0x2, 0x2, 
       0x2, 0x11e9, 0x11eb, 0x5, 0x280, 0x141, 0x2, 0x11ea, 0x11e9, 0x3, 
       0x2, 0x2, 0x2, 0x11ea, 0x11eb, 0x3, 0x2, 0x2, 0x2, 0x11eb, 0x1208, 
       0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11ed, 0x7, 0x181, 0x2, 0x2, 0x11ed, 
       0x11ef, 0x7, 0x19d, 0x2, 0x2, 0x11ee, 0x11f0, 0x5, 0x280, 0x141, 
       0x2, 0x11ef, 0x11ee, 0x3, 0x2, 0x2, 0x2, 0x11ef, 0x11f0, 0x3, 0x2, 
       0x2, 0x2, 0x11f0, 0x1208, 0x3, 0x2, 0x2, 0x2, 0x11f1, 0x11f2, 0x7, 
       0x167, 0x2, 0x2, 0x11f2, 0x1208, 0x5, 0x41a, 0x20e, 0x2, 0x11f3, 
       0x11f5, 0x7, 0x153, 0x2, 0x2, 0x11f4, 0x11f6, 0x7, 0x167, 0x2, 0x2, 
       0x11f5, 0x11f4, 0x3, 0x2, 0x2, 0x2, 0x11f5, 0x11f6, 0x3, 0x2, 0x2, 
       0x2, 0x11f6, 0x11f7, 0x3, 0x2, 0x2, 0x2, 0x11f7, 0x1208, 0x5, 0x41a, 
       0x20e, 0x2, 0x11f8, 0x11fa, 0x7, 0x161, 0x2, 0x2, 0x11f9, 0x11fb, 
       0x5, 0x27c, 0x13f, 0x2, 0x11fa, 0x11f9, 0x3, 0x2, 0x2, 0x2, 0x11fa, 
       0x11fb, 0x3, 0x2, 0x2, 0x2, 0x11fb, 0x11fc, 0x3, 0x2, 0x2, 0x2, 0x11fc, 
       0x11fe, 0x7, 0x19b, 0x2, 0x2, 0x11fd, 0x11ff, 0x7, 0x167, 0x2, 0x2, 
       0x11fe, 0x11fd, 0x3, 0x2, 0x2, 0x2, 0x11fe, 0x11ff, 0x3, 0x2, 0x2, 
       0x2, 0x11ff, 0x1200, 0x3, 0x2, 0x2, 0x2, 0x1200, 0x1208, 0x5, 0x41a, 
       0x20e, 0x2, 0x1201, 0x1202, 0x7, 0x138, 0x2, 0x2, 0x1202, 0x1203, 
       0x7, 0x19d, 0x2, 0x2, 0x1203, 0x1208, 0x5, 0x412, 0x20a, 0x2, 0x1204, 
       0x1205, 0x9, 0x37, 0x2, 0x2, 0x1205, 0x1206, 0x7, 0x139, 0x2, 0x2, 
       0x1206, 0x1208, 0x5, 0x412, 0x20a, 0x2, 0x1207, 0x11e1, 0x3, 0x2, 
       0x2, 0x2, 0x1207, 0x11e5, 0x3, 0x2, 0x2, 0x2, 0x1207, 0x11ec, 0x3, 
       0x2, 0x2, 0x2, 0x1207, 0x11f1, 0x3, 0x2, 0x2, 0x2, 0x1207, 0x11f3, 
       0x3, 0x2, 0x2, 0x2, 0x1207, 0x11f8, 0x3, 0x2, 0x2, 0x2, 0x1207, 0x1201, 
       0x3, 0x2, 0x2, 0x2, 0x1207, 0x1204, 0x3, 0x2, 0x2, 0x2, 0x1208, 0x27b, 
       0x3, 0x2, 0x2, 0x2, 0x1209, 0x120a, 0x9, 0x38, 0x2, 0x2, 0x120a, 
       0x27d, 0x3, 0x2, 0x2, 0x2, 0x120b, 0x120c, 0x7, 0xcf, 0x2, 0x2, 0x120c, 
       0x120d, 0x7, 0xd8, 0x2, 0x2, 0x120d, 0x1211, 0x5, 0x58, 0x2d, 0x2, 
       0x120e, 0x120f, 0x7, 0x147, 0x2, 0x2, 0x120f, 0x1211, 0x9, 0x39, 
       0x2, 0x2, 0x1210, 0x120b, 0x3, 0x2, 0x2, 0x2, 0x1210, 0x120e, 0x3, 
       0x2, 0x2, 0x2, 0x1211, 0x27f, 0x3, 0x2, 0x2, 0x2, 0x1212, 0x1217, 
       0x5, 0x27e, 0x140, 0x2, 0x1213, 0x1214, 0x7, 0x1df, 0x2, 0x2, 0x1214, 
       0x1216, 0x5, 0x27e, 0x140, 0x2, 0x1215, 0x1213, 0x3, 0x2, 0x2, 0x2, 
       0x1216, 0x1219, 0x3, 0x2, 0x2, 0x2, 0x1217, 0x1215, 0x3, 0x2, 0x2, 
       0x2, 0x1217, 0x1218, 0x3, 0x2, 0x2, 0x2, 0x1218, 0x1220, 0x3, 0x2, 
       0x2, 0x2, 0x1219, 0x1217, 0x3, 0x2, 0x2, 0x2, 0x121a, 0x121c, 0x5, 
       0x27e, 0x140, 0x2, 0x121b, 0x121a, 0x3, 0x2, 0x2, 0x2, 0x121c, 0x121d, 
       0x3, 0x2, 0x2, 0x2, 0x121d, 0x121b, 0x3, 0x2, 0x2, 0x2, 0x121d, 0x121e, 
       0x3, 0x2, 0x2, 0x2, 0x121e, 0x1220, 0x3, 0x2, 0x2, 0x2, 0x121f, 0x1212, 
       0x3, 0x2, 0x2, 0x2, 0x121f, 0x121b, 0x3, 0x2, 0x2, 0x2, 0x1220, 0x281, 
       0x3, 0x2, 0x2, 0x2, 0x1221, 0x1224, 0x7, 0x4b, 0x2, 0x2, 0x1222, 
       0x1223, 0x7, 0x11e, 0x2, 0x2, 0x1223, 0x1225, 0x7, 0x156, 0x2, 0x2, 
       0x1224, 0x1222, 0x3, 0x2, 0x2, 0x2, 0x1224, 0x1225, 0x3, 0x2, 0x2, 
       0x2, 0x1225, 0x1227, 0x3, 0x2, 0x2, 0x2, 0x1226, 0x1228, 0x5, 0xa4, 
       0x53, 0x2, 0x1227, 0x1226, 0x3, 0x2, 0x2, 0x2, 0x1227, 0x1228, 0x3, 
       0x2, 0x2, 0x2, 0x1228, 0x1229, 0x3, 0x2, 0x2, 0x2, 0x1229, 0x122a, 
       0x7, 0x1bd, 0x2, 0x2, 0x122a, 0x122c, 0x5, 0x3fa, 0x1fe, 0x2, 0x122b, 
       0x122d, 0x5, 0xc0, 0x61, 0x2, 0x122c, 0x122b, 0x3, 0x2, 0x2, 0x2, 
       0x122c, 0x122d, 0x3, 0x2, 0x2, 0x2, 0x122d, 0x122e, 0x3, 0x2, 0x2, 
       0x2, 0x122e, 0x122f, 0x7, 0x15, 0x2, 0x2, 0x122f, 0x1231, 0x5, 0x2e6, 
       0x174, 0x2, 0x1230, 0x1232, 0x5, 0x284, 0x143, 0x2, 0x1231, 0x1230, 
       0x3, 0x2, 0x2, 0x2, 0x1231, 0x1232, 0x3, 0x2, 0x2, 0x2, 0x1232, 0x283, 
       0x3, 0x2, 0x2, 0x2, 0x1233, 0x1235, 0x9, 0x3a, 0x2, 0x2, 0x1234, 
       0x1233, 0x3, 0x2, 0x2, 0x2, 0x1234, 0x1235, 0x3, 0x2, 0x2, 0x2, 0x1235, 
       0x1236, 0x3, 0x2, 0x2, 0x2, 0x1236, 0x1237, 0x7, 0x30, 0x2, 0x2, 
       0x1237, 0x1238, 0x7, 0x11c, 0x2, 0x2, 0x1238, 0x285, 0x3, 0x2, 0x2, 
       0x2, 0x1239, 0x123a, 0x7, 0xdd, 0x2, 0x2, 0x123a, 0x123b, 0x5, 0x40a, 
       0x206, 0x2, 0x123b, 0x287, 0x3, 0x2, 0x2, 0x2, 0x123c, 0x123d, 0x7, 
       0x4b, 0x2, 0x2, 0x123d, 0x123e, 0x7, 0x5d, 0x2, 0x2, 0x123e, 0x1240, 
       0x5, 0x402, 0x202, 0x2, 0x123f, 0x1241, 0x5, 0x1c, 0xf, 0x2, 0x1240, 
       0x123f, 0x3, 0x2, 0x2, 0x2, 0x1240, 0x1241, 0x3, 0x2, 0x2, 0x2, 0x1241, 
       0x1245, 0x3, 0x2, 0x2, 0x2, 0x1242, 0x1244, 0x5, 0x28a, 0x146, 0x2, 
       0x1243, 0x1242, 0x3, 0x2, 0x2, 0x2, 0x1244, 0x1247, 0x3, 0x2, 0x2, 
       0x2, 0x1245, 0x1243, 0x3, 0x2, 0x2, 0x2, 0x1245, 0x1246, 0x3, 0x2, 
       0x2, 0x2, 0x1246, 0x289, 0x3, 0x2, 0x2, 0x2, 0x1247, 0x1245, 0x3, 
       0x2, 0x2, 0x2, 0x1248, 0x124a, 0x7, 0x191, 0x2, 0x2, 0x1249, 0x124b, 
       0x7, 0x1f1, 0x2, 0x2, 0x124a, 0x1249, 0x3, 0x2, 0x2, 0x2, 0x124a, 
       0x124b, 0x3, 0x2, 0x2, 0x2, 0x124b, 0x124e, 0x3, 0x2, 0x2, 0x2, 0x124c, 
       0x124f, 0x5, 0x3fe, 0x200, 0x2, 0x124d, 0x124f, 0x7, 0x65, 0x2, 0x2, 
       0x124e, 0x124c, 0x3, 0x2, 0x2, 0x2, 0x124e, 0x124d, 0x3, 0x2, 0x2, 
       0x2, 0x124f, 0x1278, 0x3, 0x2, 0x2, 0x2, 0x1250, 0x1252, 0x7, 0xe1, 
       0x2, 0x2, 0x1251, 0x1253, 0x7, 0x1f1, 0x2, 0x2, 0x1252, 0x1251, 0x3, 
       0x2, 0x2, 0x2, 0x1252, 0x1253, 0x3, 0x2, 0x2, 0x2, 0x1253, 0x1256, 
       0x3, 0x2, 0x2, 0x2, 0x1254, 0x1257, 0x5, 0x412, 0x20a, 0x2, 0x1255, 
       0x1257, 0x7, 0x65, 0x2, 0x2, 0x1256, 0x1254, 0x3, 0x2, 0x2, 0x2, 
       0x1256, 0x1255, 0x3, 0x2, 0x2, 0x2, 0x1257, 0x1278, 0x3, 0x2, 0x2, 
       0x2, 0x1258, 0x125a, 0x7, 0x193, 0x2, 0x2, 0x1259, 0x125b, 0x7, 0x1f1, 
       0x2, 0x2, 0x125a, 0x1259, 0x3, 0x2, 0x2, 0x2, 0x125a, 0x125b, 0x3, 
       0x2, 0x2, 0x2, 0x125b, 0x125e, 0x3, 0x2, 0x2, 0x2, 0x125c, 0x125f, 
       0x5, 0x3fe, 0x200, 0x2, 0x125d, 0x125f, 0x7, 0x65, 0x2, 0x2, 0x125e, 
       0x125c, 0x3, 0x2, 0x2, 0x2, 0x125e, 0x125d, 0x3, 0x2, 0x2, 0x2, 0x125f, 
       0x1278, 0x3, 0x2, 0x2, 0x2, 0x1260, 0x1262, 0x7, 0x7d, 0x2, 0x2, 
       0x1261, 0x1263, 0x7, 0x1f1, 0x2, 0x2, 0x1262, 0x1261, 0x3, 0x2, 0x2, 
       0x2, 0x1262, 0x1263, 0x3, 0x2, 0x2, 0x2, 0x1263, 0x1267, 0x3, 0x2, 
       0x2, 0x2, 0x1264, 0x1268, 0x5, 0x412, 0x20a, 0x2, 0x1265, 0x1268, 
       0x5, 0x410, 0x209, 0x2, 0x1266, 0x1268, 0x7, 0x65, 0x2, 0x2, 0x1267, 
       0x1264, 0x3, 0x2, 0x2, 0x2, 0x1267, 0x1265, 0x3, 0x2, 0x2, 0x2, 0x1267, 
       0x1266, 0x3, 0x2, 0x2, 0x2, 0x1268, 0x1278, 0x3, 0x2, 0x2, 0x2, 0x1269, 
       0x126a, 0x7, 0x40, 0x2, 0x2, 0x126a, 0x126c, 0x7, 0xda, 0x2, 0x2, 
       0x126b, 0x126d, 0x7, 0x1f1, 0x2, 0x2, 0x126c, 0x126b, 0x3, 0x2, 0x2, 
       0x2, 0x126c, 0x126d, 0x3, 0x2, 0x2, 0x2, 0x126d, 0x126e, 0x3, 0x2, 
       0x2, 0x2, 0x126e, 0x1278, 0x5, 0x418, 0x20d, 0x2, 0x126f, 0x1271, 
       0x7, 0x129, 0x2, 0x2, 0x1270, 0x1272, 0x7, 0x1f1, 0x2, 0x2, 0x1271, 
       0x1270, 0x3, 0x2, 0x2, 0x2, 0x1271, 0x1272, 0x3, 0x2, 0x2, 0x2, 0x1272, 
       0x1275, 0x3, 0x2, 0x2, 0x2, 0x1273, 0x1276, 0x5, 0x3fe, 0x200, 0x2, 
       0x1274, 0x1276, 0x7, 0x65, 0x2, 0x2, 0x1275, 0x1273, 0x3, 0x2, 0x2, 
       0x2, 0x1275, 0x1274, 0x3, 0x2, 0x2, 0x2, 0x1276, 0x1278, 0x3, 0x2, 
       0x2, 0x2, 0x1277, 0x1248, 0x3, 0x2, 0x2, 0x2, 0x1277, 0x1250, 0x3, 
       0x2, 0x2, 0x2, 0x1277, 0x1258, 0x3, 0x2, 0x2, 0x2, 0x1277, 0x1260, 
       0x3, 0x2, 0x2, 0x2, 0x1277, 0x1269, 0x3, 0x2, 0x2, 0x2, 0x1277, 0x126f, 
       0x3, 0x2, 0x2, 0x2, 0x1278, 0x28b, 0x3, 0x2, 0x2, 0x2, 0x1279, 0x127a, 
       0x7, 0xe, 0x2, 0x2, 0x127a, 0x127b, 0x7, 0x5d, 0x2, 0x2, 0x127b, 
       0x127d, 0x5, 0x402, 0x202, 0x2, 0x127c, 0x127e, 0x5, 0x1c, 0xf, 0x2, 
       0x127d, 0x127c, 0x3, 0x2, 0x2, 0x2, 0x127d, 0x127e, 0x3, 0x2, 0x2, 
       0x2, 0x127e, 0x1282, 0x3, 0x2, 0x2, 0x2, 0x127f, 0x1281, 0x5, 0x290, 
       0x149, 0x2, 0x1280, 0x127f, 0x3, 0x2, 0x2, 0x2, 0x1281, 0x1284, 0x3, 
       0x2, 0x2, 0x2, 0x1282, 0x1280, 0x3, 0x2, 0x2, 0x2, 0x1282, 0x1283, 
       0x3, 0x2, 0x2, 0x2, 0x1283, 0x28d, 0x3, 0x2, 0x2, 0x2, 0x1284, 0x1282, 
       0x3, 0x2, 0x2, 0x2, 0x1285, 0x1286, 0x7, 0xe, 0x2, 0x2, 0x1286, 0x1287, 
       0x7, 0x5d, 0x2, 0x2, 0x1287, 0x1288, 0x5, 0x402, 0x202, 0x2, 0x1288, 
       0x1289, 0x5, 0x66, 0x34, 0x2, 0x1289, 0x28f, 0x3, 0x2, 0x2, 0x2, 
       0x128a, 0x128b, 0x7, 0x40, 0x2, 0x2, 0x128b, 0x128d, 0x7, 0xda, 0x2, 
       0x2, 0x128c, 0x128e, 0x7, 0x1f1, 0x2, 0x2, 0x128d, 0x128c, 0x3, 0x2, 
       0x2, 0x2, 0x128d, 0x128e, 0x3, 0x2, 0x2, 0x2, 0x128e, 0x128f, 0x3, 
       0x2, 0x2, 0x2, 0x128f, 0x1290, 0x5, 0x418, 0x20d, 0x2, 0x1290, 0x291, 
       0x3, 0x2, 0x2, 0x2, 0x1291, 0x1292, 0x7, 0x78, 0x2, 0x2, 0x1292, 
       0x1295, 0x7, 0x5d, 0x2, 0x2, 0x1293, 0x1294, 0x7, 0xb1, 0x2, 0x2, 
       0x1294, 0x1296, 0x7, 0x8a, 0x2, 0x2, 0x1295, 0x1293, 0x3, 0x2, 0x2, 
       0x2, 0x1295, 0x1296, 0x3, 0x2, 0x2, 0x2, 0x1296, 0x1297, 0x3, 0x2, 
       0x2, 0x2, 0x1297, 0x1298, 0x5, 0x402, 0x202, 0x2, 0x1298, 0x293, 
       0x3, 0x2, 0x2, 0x2, 0x1299, 0x129a, 0x7, 0x4b, 0x2, 0x2, 0x129a, 
       0x129b, 0x7, 0x76, 0x2, 0x2, 0x129b, 0x129d, 0x5, 0x1dc, 0xef, 0x2, 
       0x129c, 0x129e, 0x7, 0x15, 0x2, 0x2, 0x129d, 0x129c, 0x3, 0x2, 0x2, 
       0x2, 0x129d, 0x129e, 0x3, 0x2, 0x2, 0x2, 0x129e, 0x129f, 0x3, 0x2, 
       0x2, 0x2, 0x129f, 0x12a3, 0x5, 0x33a, 0x19e, 0x2, 0x12a0, 0x12a2, 
       0x5, 0xae, 0x58, 0x2, 0x12a1, 0x12a0, 0x3, 0x2, 0x2, 0x2, 0x12a2, 
       0x12a5, 0x3, 0x2, 0x2, 0x2, 0x12a3, 0x12a1, 0x3, 0x2, 0x2, 0x2, 0x12a3, 
       0x12a4, 0x3, 0x2, 0x2, 0x2, 0x12a4, 0x295, 0x3, 0x2, 0x2, 0x2, 0x12a5, 
       0x12a3, 0x3, 0x2, 0x2, 0x2, 0x12a6, 0x12a7, 0x7, 0xe, 0x2, 0x2, 0x12a7, 
       0x12a8, 0x7, 0x76, 0x2, 0x2, 0x12a8, 0x12a9, 0x5, 0x1dc, 0xef, 0x2, 
       0x12a9, 0x12aa, 0x5, 0x298, 0x14d, 0x2, 0x12aa, 0x297, 0x3, 0x2, 
       0x2, 0x2, 0x12ab, 0x12b8, 0x5, 0x8c, 0x47, 0x2, 0x12ac, 0x12ad, 0x9, 
       0x3b, 0x2, 0x2, 0x12ad, 0x12ae, 0x7, 0x108, 0x2, 0x2, 0x12ae, 0x12b8, 
       0x7, 0x10e, 0x2, 0x2, 0x12af, 0x12b0, 0x7, 0x8, 0x2, 0x2, 0x12b0, 
       0x12b8, 0x5, 0xba, 0x5e, 0x2, 0x12b1, 0x12b2, 0x7, 0x78, 0x2, 0x2, 
       0x12b2, 0x12b3, 0x7, 0x41, 0x2, 0x2, 0x12b3, 0x12b5, 0x5, 0x3fe, 
       0x200, 0x2, 0x12b4, 0x12b6, 0x5, 0x8e, 0x48, 0x2, 0x12b5, 0x12b4, 
       0x3, 0x2, 0x2, 0x2, 0x12b5, 0x12b6, 0x3, 0x2, 0x2, 0x2, 0x12b6, 0x12b8, 
       0x3, 0x2, 0x2, 0x2, 0x12b7, 0x12ab, 0x3, 0x2, 0x2, 0x2, 0x12b7, 0x12ac, 
       0x3, 0x2, 0x2, 0x2, 0x12b7, 0x12af, 0x3, 0x2, 0x2, 0x2, 0x12b7, 0x12b1, 
       0x3, 0x2, 0x2, 0x2, 0x12b8, 0x299, 0x3, 0x2, 0x2, 0x2, 0x12b9, 0x12ba, 
       0x7, 0xe, 0x2, 0x2, 0x12ba, 0x12bb, 0x7, 0x195, 0x2, 0x2, 0x12bb, 
       0x12bc, 0x7, 0x16b, 0x2, 0x2, 0x12bc, 0x12bd, 0x7, 0x6f, 0x2, 0x2, 
       0x12bd, 0x12be, 0x5, 0x1dc, 0xef, 0x2, 0x12be, 0x12bf, 0x5, 0x1ac, 
       0xd7, 0x2, 0x12bf, 0x29b, 0x3, 0x2, 0x2, 0x2, 0x12c0, 0x12c1, 0x7, 
       0xe, 0x2, 0x2, 0x12c1, 0x12c2, 0x7, 0x195, 0x2, 0x2, 0x12c2, 0x12c3, 
       0x7, 0x16b, 0x2, 0x2, 0x12c3, 0x12c4, 0x7, 0x3e, 0x2, 0x2, 0x12c4, 
       0x12c5, 0x5, 0x1dc, 0xef, 0x2, 0x12c5, 0x12c6, 0x5, 0x29e, 0x150, 
       0x2, 0x12c6, 0x29d, 0x3, 0x2, 0x2, 0x2, 0x12c7, 0x12c8, 0x9, 0x3c, 
       0x2, 0x2, 0x12c8, 0x12c9, 0x7, 0xe5, 0x2, 0x2, 0x12c9, 0x12ca, 0x7, 
       0x99, 0x2, 0x2, 0x12ca, 0x12cb, 0x5, 0x3fc, 0x1ff, 0x2, 0x12cb, 0x12cc, 
       0x7, 0x1c4, 0x2, 0x2, 0x12cc, 0x12cd, 0x5, 0x1da, 0xee, 0x2, 0x12cd, 
       0x12e2, 0x3, 0x2, 0x2, 0x2, 0x12ce, 0x12cf, 0x7, 0xe, 0x2, 0x2, 0x12cf, 
       0x12d2, 0x7, 0xe5, 0x2, 0x2, 0x12d0, 0x12d1, 0x7, 0x99, 0x2, 0x2, 
       0x12d1, 0x12d3, 0x5, 0x3fc, 0x1ff, 0x2, 0x12d2, 0x12d0, 0x3, 0x2, 
       0x2, 0x2, 0x12d2, 0x12d3, 0x3, 0x2, 0x2, 0x2, 0x12d3, 0x12d4, 0x3, 
       0x2, 0x2, 0x2, 0x12d4, 0x12d5, 0x7, 0x156, 0x2, 0x2, 0x12d5, 0x12d6, 
       0x5, 0x1dc, 0xef, 0x2, 0x12d6, 0x12d7, 0x7, 0x1c4, 0x2, 0x2, 0x12d7, 
       0x12d8, 0x5, 0x1dc, 0xef, 0x2, 0x12d8, 0x12e2, 0x3, 0x2, 0x2, 0x2, 
       0x12d9, 0x12da, 0x7, 0x78, 0x2, 0x2, 0x12da, 0x12dd, 0x7, 0xe5, 0x2, 
       0x2, 0x12db, 0x12dc, 0x7, 0xb1, 0x2, 0x2, 0x12dc, 0x12de, 0x7, 0x8a, 
       0x2, 0x2, 0x12dd, 0x12db, 0x3, 0x2, 0x2, 0x2, 0x12dd, 0x12de, 0x3, 
       0x2, 0x2, 0x2, 0x12de, 0x12df, 0x3, 0x2, 0x2, 0x2, 0x12df, 0x12e0, 
       0x7, 0x99, 0x2, 0x2, 0x12e0, 0x12e2, 0x5, 0x3fc, 0x1ff, 0x2, 0x12e1, 
       0x12c7, 0x3, 0x2, 0x2, 0x2, 0x12e1, 0x12ce, 0x3, 0x2, 0x2, 0x2, 0x12e1, 
       0x12d9, 0x3, 0x2, 0x2, 0x2, 0x12e2, 0x29f, 0x3, 0x2, 0x2, 0x2, 0x12e3, 
       0x12e5, 0x7, 0x4b, 0x2, 0x2, 0x12e4, 0x12e6, 0x7, 0x65, 0x2, 0x2, 
       0x12e5, 0x12e4, 0x3, 0x2, 0x2, 0x2, 0x12e5, 0x12e6, 0x3, 0x2, 0x2, 
       0x2, 0x12e6, 0x12e7, 0x3, 0x2, 0x2, 0x2, 0x12e7, 0x12e8, 0x7, 0x46, 
       0x2, 0x2, 0x12e8, 0x12e9, 0x5, 0x1dc, 0xef, 0x2, 0x12e9, 0x12ea, 
       0x7, 0x99, 0x2, 0x2, 0x12ea, 0x12eb, 0x5, 0x412, 0x20a, 0x2, 0x12eb, 
       0x12ec, 0x7, 0x19b, 0x2, 0x2, 0x12ec, 0x12ed, 0x5, 0x412, 0x20a, 
       0x2, 0x12ed, 0x12ee, 0x7, 0x9f, 0x2, 0x2, 0x12ee, 0x12ef, 0x5, 0x1dc, 
       0xef, 0x2, 0x12ef, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x12f0, 0x12f2, 0x7, 
       0x34, 0x2, 0x2, 0x12f1, 0x12f3, 0x5, 0x2a4, 0x153, 0x2, 0x12f2, 0x12f1, 
       0x3, 0x2, 0x2, 0x2, 0x12f2, 0x12f3, 0x3, 0x2, 0x2, 0x2, 0x12f3, 0x2a3, 
       0x3, 0x2, 0x2, 0x2, 0x12f4, 0x12f7, 0x5, 0x3fa, 0x1fe, 0x2, 0x12f5, 
       0x12f6, 0x7, 0x1b1, 0x2, 0x2, 0x12f6, 0x12f8, 0x5, 0x408, 0x205, 
       0x2, 0x12f7, 0x12f5, 0x3, 0x2, 0x2, 0x2, 0x12f7, 0x12f8, 0x3, 0x2, 
       0x2, 0x2, 0x12f8, 0x12fe, 0x3, 0x2, 0x2, 0x2, 0x12f9, 0x12fa, 0x5, 
       0x408, 0x205, 0x2, 0x12fa, 0x12fb, 0x7, 0x119, 0x2, 0x2, 0x12fb, 
       0x12fc, 0x5, 0x3fa, 0x1fe, 0x2, 0x12fc, 0x12fe, 0x3, 0x2, 0x2, 0x2, 
       0x12fd, 0x12f4, 0x3, 0x2, 0x2, 0x2, 0x12fd, 0x12f9, 0x3, 0x2, 0x2, 
       0x2, 0x12fe, 0x2a5, 0x3, 0x2, 0x2, 0x2, 0x12ff, 0x1301, 0x7, 0x1b2, 
       0x2, 0x2, 0x1300, 0x1302, 0x7, 0xa0, 0x2, 0x2, 0x1301, 0x1300, 0x3, 
       0x2, 0x2, 0x2, 0x1301, 0x1302, 0x3, 0x2, 0x2, 0x2, 0x1302, 0x1304, 
       0x3, 0x2, 0x2, 0x2, 0x1303, 0x1305, 0x7, 0x9e, 0x2, 0x2, 0x1304, 
       0x1303, 0x3, 0x2, 0x2, 0x2, 0x1304, 0x1305, 0x3, 0x2, 0x2, 0x2, 0x1305, 
       0x1307, 0x3, 0x2, 0x2, 0x2, 0x1306, 0x1308, 0x7, 0x1bb, 0x2, 0x2, 
       0x1307, 0x1306, 0x3, 0x2, 0x2, 0x2, 0x1307, 0x1308, 0x3, 0x2, 0x2, 
       0x2, 0x1308, 0x130a, 0x3, 0x2, 0x2, 0x2, 0x1309, 0x130b, 0x5, 0x3fa, 
       0x1fe, 0x2, 0x130a, 0x1309, 0x3, 0x2, 0x2, 0x2, 0x130a, 0x130b, 0x3, 
       0x2, 0x2, 0x2, 0x130b, 0x1318, 0x3, 0x2, 0x2, 0x2, 0x130c, 0x130e, 
       0x7, 0x1b2, 0x2, 0x2, 0x130d, 0x130f, 0x7, 0xa0, 0x2, 0x2, 0x130e, 
       0x130d, 0x3, 0x2, 0x2, 0x2, 0x130e, 0x130f, 0x3, 0x2, 0x2, 0x2, 0x130f, 
       0x1311, 0x3, 0x2, 0x2, 0x2, 0x1310, 0x1312, 0x7, 0x9e, 0x2, 0x2, 
       0x1311, 0x1310, 0x3, 0x2, 0x2, 0x2, 0x1311, 0x1312, 0x3, 0x2, 0x2, 
       0x2, 0x1312, 0x1314, 0x3, 0x2, 0x2, 0x2, 0x1313, 0x1315, 0x7, 0x1bb, 
       0x2, 0x2, 0x1314, 0x1313, 0x3, 0x2, 0x2, 0x2, 0x1314, 0x1315, 0x3, 
       0x2, 0x2, 0x2, 0x1315, 0x1316, 0x3, 0x2, 0x2, 0x2, 0x1316, 0x1318, 
       0x5, 0x2a8, 0x155, 0x2, 0x1317, 0x12ff, 0x3, 0x2, 0x2, 0x2, 0x1317, 
       0x130c, 0x3, 0x2, 0x2, 0x2, 0x1318, 0x2a7, 0x3, 0x2, 0x2, 0x2, 0x1319, 
       0x131b, 0x5, 0x2aa, 0x156, 0x2, 0x131a, 0x131c, 0x7, 0x1bb, 0x2, 
       0x2, 0x131b, 0x131a, 0x3, 0x2, 0x2, 0x2, 0x131b, 0x131c, 0x3, 0x2, 
       0x2, 0x2, 0x131c, 0x131f, 0x3, 0x2, 0x2, 0x2, 0x131d, 0x131e, 0x7, 
       0x163, 0x2, 0x2, 0x131e, 0x1320, 0x7, 0xc, 0x2, 0x2, 0x131f, 0x131d, 
       0x3, 0x2, 0x2, 0x2, 0x131f, 0x1320, 0x3, 0x2, 0x2, 0x2, 0x1320, 0x132f, 
       0x3, 0x2, 0x2, 0x2, 0x1321, 0x1323, 0x5, 0x2aa, 0x156, 0x2, 0x1322, 
       0x1324, 0x7, 0x1bb, 0x2, 0x2, 0x1323, 0x1322, 0x3, 0x2, 0x2, 0x2, 
       0x1323, 0x1324, 0x3, 0x2, 0x2, 0x2, 0x1324, 0x1326, 0x3, 0x2, 0x2, 
       0x2, 0x1325, 0x1327, 0x7, 0x163, 0x2, 0x2, 0x1326, 0x1325, 0x3, 0x2, 
       0x2, 0x2, 0x1326, 0x1327, 0x3, 0x2, 0x2, 0x2, 0x1327, 0x132c, 0x3, 
       0x2, 0x2, 0x2, 0x1328, 0x132a, 0x5, 0x3fa, 0x1fe, 0x2, 0x1329, 0x132b, 
       0x5, 0x2ac, 0x157, 0x2, 0x132a, 0x1329, 0x3, 0x2, 0x2, 0x2, 0x132a, 
       0x132b, 0x3, 0x2, 0x2, 0x2, 0x132b, 0x132d, 0x3, 0x2, 0x2, 0x2, 0x132c, 
       0x1328, 0x3, 0x2, 0x2, 0x2, 0x132c, 0x132d, 0x3, 0x2, 0x2, 0x2, 0x132d, 
       0x132f, 0x3, 0x2, 0x2, 0x2, 0x132e, 0x1319, 0x3, 0x2, 0x2, 0x2, 0x132e, 
       0x1321, 0x3, 0x2, 0x2, 0x2, 0x132f, 0x2a9, 0x3, 0x2, 0x2, 0x2, 0x1330, 
       0x1331, 0x9, 0x3d, 0x2, 0x2, 0x1331, 0x2ab, 0x3, 0x2, 0x2, 0x2, 0x1332, 
       0x1333, 0x7, 0x1d9, 0x2, 0x2, 0x1333, 0x1334, 0x5, 0x3fc, 0x1ff, 
       0x2, 0x1334, 0x1335, 0x7, 0x1da, 0x2, 0x2, 0x1335, 0x2ad, 0x3, 0x2, 
       0x2, 0x2, 0x1336, 0x1338, 0x7, 0x8b, 0x2, 0x2, 0x1337, 0x1339, 0x5, 
       0x2aa, 0x156, 0x2, 0x1338, 0x1337, 0x3, 0x2, 0x2, 0x2, 0x1338, 0x1339, 
       0x3, 0x2, 0x2, 0x2, 0x1339, 0x133b, 0x3, 0x2, 0x2, 0x2, 0x133a, 0x133c, 
       0x7, 0x1bb, 0x2, 0x2, 0x133b, 0x133a, 0x3, 0x2, 0x2, 0x2, 0x133b, 
       0x133c, 0x3, 0x2, 0x2, 0x2, 0x133c, 0x133e, 0x3, 0x2, 0x2, 0x2, 0x133d, 
       0x133f, 0x7, 0x79, 0x2, 0x2, 0x133e, 0x133d, 0x3, 0x2, 0x2, 0x2, 
       0x133e, 0x133f, 0x3, 0x2, 0x2, 0x2, 0x133f, 0x1341, 0x3, 0x2, 0x2, 
       0x2, 0x1340, 0x1342, 0x7, 0x9a, 0x2, 0x2, 0x1341, 0x1340, 0x3, 0x2, 
       0x2, 0x2, 0x1341, 0x1342, 0x3, 0x2, 0x2, 0x2, 0x1342, 0x1343, 0x3, 
       0x2, 0x2, 0x2, 0x1343, 0x1344, 0x5, 0x2b0, 0x159, 0x2, 0x1344, 0x2af, 
       0x3, 0x2, 0x2, 0x2, 0x1345, 0x134e, 0x5, 0x2e6, 0x174, 0x2, 0x1346, 
       0x134e, 0x5, 0x2c0, 0x161, 0x2, 0x1347, 0x134e, 0x5, 0x2d2, 0x16a, 
       0x2, 0x1348, 0x134e, 0x5, 0x2ca, 0x166, 0x2, 0x1349, 0x134e, 0x5, 
       0x2e0, 0x171, 0x2, 0x134a, 0x134e, 0x5, 0x2b8, 0x15d, 0x2, 0x134b, 
       0x134e, 0x5, 0x11e, 0x90, 0x2, 0x134c, 0x134e, 0x5, 0xa2, 0x52, 0x2, 
       0x134d, 0x1345, 0x3, 0x2, 0x2, 0x2, 0x134d, 0x1346, 0x3, 0x2, 0x2, 
       0x2, 0x134d, 0x1347, 0x3, 0x2, 0x2, 0x2, 0x134d, 0x1348, 0x3, 0x2, 
       0x2, 0x2, 0x134d, 0x1349, 0x3, 0x2, 0x2, 0x2, 0x134d, 0x134a, 0x3, 
       0x2, 0x2, 0x2, 0x134d, 0x134b, 0x3, 0x2, 0x2, 0x2, 0x134d, 0x134c, 
       0x3, 0x2, 0x2, 0x2, 0x134e, 0x2b1, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1350, 
       0x7, 0x138, 0x2, 0x2, 0x1350, 0x1352, 0x5, 0x3fe, 0x200, 0x2, 0x1351, 
       0x1353, 0x5, 0x2b4, 0x15b, 0x2, 0x1352, 0x1351, 0x3, 0x2, 0x2, 0x2, 
       0x1352, 0x1353, 0x3, 0x2, 0x2, 0x2, 0x1353, 0x1354, 0x3, 0x2, 0x2, 
       0x2, 0x1354, 0x1355, 0x7, 0x15, 0x2, 0x2, 0x1355, 0x1356, 0x5, 0x2b6, 
       0x15c, 0x2, 0x1356, 0x2b3, 0x3, 0x2, 0x2, 0x2, 0x1357, 0x1358, 0x7, 
       0x1d9, 0x2, 0x2, 0x1358, 0x1359, 0x5, 0x3bc, 0x1df, 0x2, 0x1359, 
       0x135a, 0x7, 0x1da, 0x2, 0x2, 0x135a, 0x2b5, 0x3, 0x2, 0x2, 0x2, 
       0x135b, 0x1360, 0x5, 0x2e6, 0x174, 0x2, 0x135c, 0x1360, 0x5, 0x2c0, 
       0x161, 0x2, 0x135d, 0x1360, 0x5, 0x2d2, 0x16a, 0x2, 0x135e, 0x1360, 
       0x5, 0x2ca, 0x166, 0x2, 0x135f, 0x135b, 0x3, 0x2, 0x2, 0x2, 0x135f, 
       0x135c, 0x3, 0x2, 0x2, 0x2, 0x135f, 0x135d, 0x3, 0x2, 0x2, 0x2, 0x135f, 
       0x135e, 0x3, 0x2, 0x2, 0x2, 0x1360, 0x2b7, 0x3, 0x2, 0x2, 0x2, 0x1361, 
       0x1363, 0x7, 0x4b, 0x2, 0x2, 0x1362, 0x1364, 0x5, 0xa4, 0x53, 0x2, 
       0x1363, 0x1362, 0x3, 0x2, 0x2, 0x2, 0x1363, 0x1364, 0x3, 0x2, 0x2, 
       0x2, 0x1364, 0x1365, 0x3, 0x2, 0x2, 0x2, 0x1365, 0x1366, 0x7, 0x190, 
       0x2, 0x2, 0x1366, 0x1367, 0x5, 0x120, 0x91, 0x2, 0x1367, 0x1368, 
       0x7, 0x15, 0x2, 0x2, 0x1368, 0x136a, 0x3, 0x2, 0x2, 0x2, 0x1369, 
       0x1361, 0x3, 0x2, 0x2, 0x2, 0x1369, 0x136a, 0x3, 0x2, 0x2, 0x2, 0x136a, 
       0x136b, 0x3, 0x2, 0x2, 0x2, 0x136b, 0x136c, 0x7, 0x89, 0x2, 0x2, 
       0x136c, 0x136e, 0x5, 0x3fe, 0x200, 0x2, 0x136d, 0x136f, 0x5, 0x3b8, 
       0x1dd, 0x2, 0x136e, 0x136d, 0x3, 0x2, 0x2, 0x2, 0x136e, 0x136f, 0x3, 
       0x2, 0x2, 0x2, 0x136f, 0x2b9, 0x3, 0x2, 0x2, 0x2, 0x1370, 0x1372, 
       0x7, 0x60, 0x2, 0x2, 0x1371, 0x1373, 0x7, 0x138, 0x2, 0x2, 0x1372, 
       0x1371, 0x3, 0x2, 0x2, 0x2, 0x1372, 0x1373, 0x3, 0x2, 0x2, 0x2, 0x1373, 
       0x1376, 0x3, 0x2, 0x2, 0x2, 0x1374, 0x1377, 0x5, 0x3fe, 0x200, 0x2, 
       0x1375, 0x1377, 0x7, 0xc, 0x2, 0x2, 0x1376, 0x1374, 0x3, 0x2, 0x2, 
       0x2, 0x1376, 0x1375, 0x3, 0x2, 0x2, 0x2, 0x1377, 0x2bb, 0x3, 0x2, 
       0x2, 0x2, 0x1378, 0x137d, 0x5, 0x2be, 0x160, 0x2, 0x1379, 0x137a, 
       0x7, 0x1df, 0x2, 0x2, 0x137a, 0x137c, 0x5, 0x2be, 0x160, 0x2, 0x137b, 
       0x1379, 0x3, 0x2, 0x2, 0x2, 0x137c, 0x137f, 0x3, 0x2, 0x2, 0x2, 0x137d, 
       0x137b, 0x3, 0x2, 0x2, 0x2, 0x137d, 0x137e, 0x3, 0x2, 0x2, 0x2, 0x137e, 
       0x2bd, 0x3, 0x2, 0x2, 0x2, 0x137f, 0x137d, 0x3, 0x2, 0x2, 0x2, 0x1380, 
       0x1381, 0x5, 0x412, 0x20a, 0x2, 0x1381, 0x2bf, 0x3, 0x2, 0x2, 0x2, 
       0x1382, 0x1383, 0x7, 0xc5, 0x2, 0x2, 0x1383, 0x1384, 0x7, 0xca, 0x2, 
       0x2, 0x1384, 0x1386, 0x5, 0x3fa, 0x1fe, 0x2, 0x1385, 0x1387, 0x5, 
       0xc0, 0x61, 0x2, 0x1386, 0x1385, 0x3, 0x2, 0x2, 0x2, 0x1386, 0x1387, 
       0x3, 0x2, 0x2, 0x2, 0x1387, 0x1388, 0x3, 0x2, 0x2, 0x2, 0x1388, 0x138a, 
       0x5, 0x2c2, 0x162, 0x2, 0x1389, 0x138b, 0x5, 0x2c8, 0x165, 0x2, 0x138a, 
       0x1389, 0x3, 0x2, 0x2, 0x2, 0x138a, 0x138b, 0x3, 0x2, 0x2, 0x2, 0x138b, 
       0x2c1, 0x3, 0x2, 0x2, 0x2, 0x138c, 0x1395, 0x5, 0x2e6, 0x174, 0x2, 
       0x138d, 0x138e, 0x7, 0x1b7, 0x2, 0x2, 0x138e, 0x138f, 0x7, 0x1d9, 
       0x2, 0x2, 0x138f, 0x1390, 0x5, 0x2c4, 0x163, 0x2, 0x1390, 0x1391, 
       0x7, 0x1da, 0x2, 0x2, 0x1391, 0x1395, 0x3, 0x2, 0x2, 0x2, 0x1392, 
       0x1393, 0x7, 0x65, 0x2, 0x2, 0x1393, 0x1395, 0x7, 0x1b7, 0x2, 0x2, 
       0x1394, 0x138c, 0x3, 0x2, 0x2, 0x2, 0x1394, 0x138d, 0x3, 0x2, 0x2, 
       0x2, 0x1394, 0x1392, 0x3, 0x2, 0x2, 0x2, 0x1395, 0x2c3, 0x3, 0x2, 
       0x2, 0x2, 0x1396, 0x139b, 0x5, 0x2c6, 0x164, 0x2, 0x1397, 0x1398, 
       0x7, 0x1df, 0x2, 0x2, 0x1398, 0x139a, 0x5, 0x2c6, 0x164, 0x2, 0x1399, 
       0x1397, 0x3, 0x2, 0x2, 0x2, 0x139a, 0x139d, 0x3, 0x2, 0x2, 0x2, 0x139b, 
       0x1399, 0x3, 0x2, 0x2, 0x2, 0x139b, 0x139c, 0x3, 0x2, 0x2, 0x2, 0x139c, 
       0x2c5, 0x3, 0x2, 0x2, 0x2, 0x139d, 0x139b, 0x3, 0x2, 0x2, 0x2, 0x139e, 
       0x13a0, 0x5, 0x41a, 0x20e, 0x2, 0x139f, 0x13a1, 0x5, 0x3ea, 0x1f6, 
       0x2, 0x13a0, 0x139f, 0x3, 0x2, 0x2, 0x2, 0x13a0, 0x13a1, 0x3, 0x2, 
       0x2, 0x2, 0x13a1, 0x13a4, 0x3, 0x2, 0x2, 0x2, 0x13a2, 0x13a4, 0x7, 
       0x65, 0x2, 0x2, 0x13a3, 0x139e, 0x3, 0x2, 0x2, 0x2, 0x13a3, 0x13a2, 
       0x3, 0x2, 0x2, 0x2, 0x13a4, 0x2c7, 0x3, 0x2, 0x2, 0x2, 0x13a5, 0x13a6, 
       0x7, 0x15c, 0x2, 0x2, 0x13a6, 0x13a7, 0x5, 0x3f2, 0x1fa, 0x2, 0x13a7, 
       0x2c9, 0x3, 0x2, 0x2, 0x2, 0x13a8, 0x13a9, 0x7, 0x6a, 0x2, 0x2, 0x13a9, 
       0x13ab, 0x7, 0x9f, 0x2, 0x2, 0x13aa, 0x13ac, 0x7, 0x11a, 0x2, 0x2, 
       0x13ab, 0x13aa, 0x3, 0x2, 0x2, 0x2, 0x13ab, 0x13ac, 0x3, 0x2, 0x2, 
       0x2, 0x13ac, 0x13ad, 0x3, 0x2, 0x2, 0x2, 0x13ad, 0x13b0, 0x5, 0x32e, 
       0x198, 0x2, 0x13ae, 0x13af, 0x7, 0x1b1, 0x2, 0x2, 0x13af, 0x13b1, 
       0x5, 0x324, 0x193, 0x2, 0x13b0, 0x13ae, 0x3, 0x2, 0x2, 0x2, 0x13b0, 
       0x13b1, 0x3, 0x2, 0x2, 0x2, 0x13b1, 0x13b3, 0x3, 0x2, 0x2, 0x2, 0x13b2, 
       0x13b4, 0x5, 0x334, 0x19b, 0x2, 0x13b3, 0x13b2, 0x3, 0x2, 0x2, 0x2, 
       0x13b3, 0x13b4, 0x3, 0x2, 0x2, 0x2, 0x13b4, 0x13b6, 0x3, 0x2, 0x2, 
       0x2, 0x13b5, 0x13b7, 0x5, 0x2c8, 0x165, 0x2, 0x13b6, 0x13b5, 0x3, 
       0x2, 0x2, 0x2, 0x13b6, 0x13b7, 0x3, 0x2, 0x2, 0x2, 0x13b7, 0x2cb, 
       0x3, 0x2, 0x2, 0x2, 0x13b8, 0x13ba, 0x7, 0xe2, 0x2, 0x2, 0x13b9, 
       0x13bb, 0x7, 0x190, 0x2, 0x2, 0x13ba, 0x13b9, 0x3, 0x2, 0x2, 0x2, 
       0x13ba, 0x13bb, 0x3, 0x2, 0x2, 0x2, 0x13bb, 0x13bc, 0x3, 0x2, 0x2, 
       0x2, 0x13bc, 0x13be, 0x5, 0x3f8, 0x1fd, 0x2, 0x13bd, 0x13bf, 0x5, 
       0x2ce, 0x168, 0x2, 0x13be, 0x13bd, 0x3, 0x2, 0x2, 0x2, 0x13be, 0x13bf, 
       0x3, 0x2, 0x2, 0x2, 0x13bf, 0x13c1, 0x3, 0x2, 0x2, 0x2, 0x13c0, 0x13c2, 
       0x7, 0x10c, 0x2, 0x2, 0x13c1, 0x13c0, 0x3, 0x2, 0x2, 0x2, 0x13c1, 
       0x13c2, 0x3, 0x2, 0x2, 0x2, 0x13c2, 0x2cd, 0x3, 0x2, 0x2, 0x2, 0x13c3, 
       0x13c4, 0x7, 0xc2, 0x2, 0x2, 0x13c4, 0x13c5, 0x5, 0x2d0, 0x169, 0x2, 
       0x13c5, 0x13c6, 0x7, 0xf1, 0x2, 0x2, 0x13c6, 0x2cf, 0x3, 0x2, 0x2, 
       0x2, 0x13c7, 0x13c9, 0x9, 0x3e, 0x2, 0x2, 0x13c8, 0x13c7, 0x3, 0x2, 
       0x2, 0x2, 0x13c8, 0x13c9, 0x3, 0x2, 0x2, 0x2, 0x13c9, 0x13ca, 0x3, 
       0x2, 0x2, 0x2, 0x13ca, 0x13d3, 0x7, 0x177, 0x2, 0x2, 0x13cb, 0x13d0, 
       0x7, 0x164, 0x2, 0x2, 0x13cc, 0x13cd, 0x7, 0x177, 0x2, 0x2, 0x13cd, 
       0x13d0, 0x9, 0x3f, 0x2, 0x2, 0x13ce, 0x13d0, 0x7, 0x5, 0x2, 0x2, 
       0x13cf, 0x13cb, 0x3, 0x2, 0x2, 0x2, 0x13cf, 0x13cc, 0x3, 0x2, 0x2, 
       0x2, 0x13cf, 0x13ce, 0x3, 0x2, 0x2, 0x2, 0x13cf, 0x13d0, 0x3, 0x2, 
       0x2, 0x2, 0x13d0, 0x13d1, 0x3, 0x2, 0x2, 0x2, 0x13d1, 0x13d3, 0x7, 
       0x88, 0x2, 0x2, 0x13d2, 0x13c8, 0x3, 0x2, 0x2, 0x2, 0x13d2, 0x13cf, 
       0x3, 0x2, 0x2, 0x2, 0x13d3, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x13d4, 0x13d6, 
       0x7, 0x1ae, 0x2, 0x2, 0x13d5, 0x13d7, 0x7, 0x11a, 0x2, 0x2, 0x13d6, 
       0x13d5, 0x3, 0x2, 0x2, 0x2, 0x13d6, 0x13d7, 0x3, 0x2, 0x2, 0x2, 0x13d7, 
       0x13d8, 0x3, 0x2, 0x2, 0x2, 0x13d8, 0x13d9, 0x5, 0x32e, 0x198, 0x2, 
       0x13d9, 0x13da, 0x7, 0x174, 0x2, 0x2, 0x13da, 0x13dc, 0x5, 0x2d4, 
       0x16b, 0x2, 0x13db, 0x13dd, 0x5, 0x322, 0x192, 0x2, 0x13dc, 0x13db, 
       0x3, 0x2, 0x2, 0x2, 0x13dc, 0x13dd, 0x3, 0x2, 0x2, 0x2, 0x13dd, 0x13df, 
       0x3, 0x2, 0x2, 0x2, 0x13de, 0x13e0, 0x5, 0x334, 0x19b, 0x2, 0x13df, 
       0x13de, 0x3, 0x2, 0x2, 0x2, 0x13df, 0x13e0, 0x3, 0x2, 0x2, 0x2, 0x13e0, 
       0x13e2, 0x3, 0x2, 0x2, 0x2, 0x13e1, 0x13e3, 0x5, 0x2c8, 0x165, 0x2, 
       0x13e2, 0x13e1, 0x3, 0x2, 0x2, 0x2, 0x13e2, 0x13e3, 0x3, 0x2, 0x2, 
       0x2, 0x13e3, 0x2d3, 0x3, 0x2, 0x2, 0x2, 0x13e4, 0x13e9, 0x5, 0x2d6, 
       0x16c, 0x2, 0x13e5, 0x13e6, 0x7, 0x1df, 0x2, 0x2, 0x13e6, 0x13e8, 
       0x5, 0x2d6, 0x16c, 0x2, 0x13e7, 0x13e5, 0x3, 0x2, 0x2, 0x2, 0x13e8, 
       0x13eb, 0x3, 0x2, 0x2, 0x2, 0x13e9, 0x13e7, 0x3, 0x2, 0x2, 0x2, 0x13e9, 
       0x13ea, 0x3, 0x2, 0x2, 0x2, 0x13ea, 0x2d5, 0x3, 0x2, 0x2, 0x2, 0x13eb, 
       0x13e9, 0x3, 0x2, 0x2, 0x2, 0x13ec, 0x13ef, 0x5, 0x2d8, 0x16d, 0x2, 
       0x13ed, 0x13ef, 0x5, 0x2da, 0x16e, 0x2, 0x13ee, 0x13ec, 0x3, 0x2, 
       0x2, 0x2, 0x13ee, 0x13ed, 0x3, 0x2, 0x2, 0x2, 0x13ef, 0x2d7, 0x3, 
       0x2, 0x2, 0x2, 0x13f0, 0x13f1, 0x5, 0x2dc, 0x16f, 0x2, 0x13f1, 0x13f2, 
       0x7, 0x1f1, 0x2, 0x2, 0x13f2, 0x13f3, 0x5, 0x3ec, 0x1f7, 0x2, 0x13f3, 
       0x2d9, 0x3, 0x2, 0x2, 0x2, 0x13f4, 0x13f5, 0x7, 0x1d9, 0x2, 0x2, 
       0x13f5, 0x13f6, 0x5, 0x2de, 0x170, 0x2, 0x13f6, 0x13f7, 0x7, 0x1da, 
       0x2, 0x2, 0x13f7, 0x13f8, 0x7, 0x1f1, 0x2, 0x2, 0x13f8, 0x13f9, 0x5, 
       0x3f0, 0x1f9, 0x2, 0x13f9, 0x2db, 0x3, 0x2, 0x2, 0x2, 0x13fa, 0x13fc, 
       0x5, 0x41a, 0x20e, 0x2, 0x13fb, 0x13fd, 0x5, 0x3ea, 0x1f6, 0x2, 0x13fc, 
       0x13fb, 0x3, 0x2, 0x2, 0x2, 0x13fc, 0x13fd, 0x3, 0x2, 0x2, 0x2, 0x13fd, 
       0x2dd, 0x3, 0x2, 0x2, 0x2, 0x13fe, 0x1403, 0x5, 0x2dc, 0x16f, 0x2, 
       0x13ff, 0x1400, 0x7, 0x1df, 0x2, 0x2, 0x1400, 0x1402, 0x5, 0x2dc, 
       0x16f, 0x2, 0x1401, 0x13ff, 0x3, 0x2, 0x2, 0x2, 0x1402, 0x1405, 0x3, 
       0x2, 0x2, 0x2, 0x1403, 0x1401, 0x3, 0x2, 0x2, 0x2, 0x1403, 0x1404, 
       0x3, 0x2, 0x2, 0x2, 0x1404, 0x2df, 0x3, 0x2, 0x2, 0x2, 0x1405, 0x1403, 
       0x3, 0x2, 0x2, 0x2, 0x1406, 0x1407, 0x7, 0x63, 0x2, 0x2, 0x1407, 
       0x140b, 0x5, 0x3fe, 0x200, 0x2, 0x1408, 0x140a, 0x5, 0x2e2, 0x172, 
       0x2, 0x1409, 0x1408, 0x3, 0x2, 0x2, 0x2, 0x140a, 0x140d, 0x3, 0x2, 
       0x2, 0x2, 0x140b, 0x1409, 0x3, 0x2, 0x2, 0x2, 0x140b, 0x140c, 0x3, 
       0x2, 0x2, 0x2, 0x140c, 0x140e, 0x3, 0x2, 0x2, 0x2, 0x140d, 0x140b, 
       0x3, 0x2, 0x2, 0x2, 0x140e, 0x1410, 0x7, 0x5b, 0x2, 0x2, 0x140f, 
       0x1411, 0x5, 0x2e4, 0x173, 0x2, 0x1410, 0x140f, 0x3, 0x2, 0x2, 0x2, 
       0x1410, 0x1411, 0x3, 0x2, 0x2, 0x2, 0x1411, 0x1412, 0x3, 0x2, 0x2, 
       0x2, 0x1412, 0x1413, 0x7, 0x99, 0x2, 0x2, 0x1413, 0x1414, 0x5, 0x2e6, 
       0x174, 0x2, 0x1414, 0x2e1, 0x3, 0x2, 0x2, 0x2, 0x1415, 0x1417, 0x7, 
       0xfe, 0x2, 0x2, 0x1416, 0x1415, 0x3, 0x2, 0x2, 0x2, 0x1416, 0x1417, 
       0x3, 0x2, 0x2, 0x2, 0x1417, 0x1418, 0x3, 0x2, 0x2, 0x2, 0x1418, 0x141c, 
       0x7, 0x16a, 0x2, 0x2, 0x1419, 0x141c, 0x7, 0x21, 0x2, 0x2, 0x141a, 
       0x141c, 0x7, 0xc4, 0x2, 0x2, 0x141b, 0x1416, 0x3, 0x2, 0x2, 0x2, 
       0x141b, 0x1419, 0x3, 0x2, 0x2, 0x2, 0x141b, 0x141a, 0x3, 0x2, 0x2, 
       0x2, 0x141c, 0x2e3, 0x3, 0x2, 0x2, 0x2, 0x141d, 0x141e, 0x9, 0x2, 
       0x2, 0x2, 0x141e, 0x141f, 0x7, 0xad, 0x2, 0x2, 0x141f, 0x2e5, 0x3, 
       0x2, 0x2, 0x2, 0x1420, 0x1424, 0x5, 0x2e8, 0x175, 0x2, 0x1421, 0x1423, 
       0x5, 0x2ea, 0x176, 0x2, 0x1422, 0x1421, 0x3, 0x2, 0x2, 0x2, 0x1423, 
       0x1426, 0x3, 0x2, 0x2, 0x2, 0x1424, 0x1422, 0x3, 0x2, 0x2, 0x2, 0x1424, 
       0x1425, 0x3, 0x2, 0x2, 0x2, 0x1425, 0x2e7, 0x3, 0x2, 0x2, 0x2, 0x1426, 
       0x1424, 0x3, 0x2, 0x2, 0x2, 0x1427, 0x142a, 0x5, 0x2ee, 0x178, 0x2, 
       0x1428, 0x142a, 0x5, 0x2ec, 0x177, 0x2, 0x1429, 0x1427, 0x3, 0x2, 
       0x2, 0x2, 0x1429, 0x1428, 0x3, 0x2, 0x2, 0x2, 0x142a, 0x2e9, 0x3, 
       0x2, 0x2, 0x2, 0x142b, 0x142d, 0x9, 0x40, 0x2, 0x2, 0x142c, 0x142e, 
       0x7, 0xc, 0x2, 0x2, 0x142d, 0x142c, 0x3, 0x2, 0x2, 0x2, 0x142d, 0x142e, 
       0x3, 0x2, 0x2, 0x2, 0x142e, 0x142f, 0x3, 0x2, 0x2, 0x2, 0x142f, 0x1430, 
       0x5, 0x2e8, 0x175, 0x2, 0x1430, 0x2eb, 0x3, 0x2, 0x2, 0x2, 0x1431, 
       0x1432, 0x7, 0x1d9, 0x2, 0x2, 0x1432, 0x1433, 0x5, 0x2e6, 0x174, 
       0x2, 0x1433, 0x1434, 0x7, 0x1da, 0x2, 0x2, 0x1434, 0x2ed, 0x3, 0x2, 
       0x2, 0x2, 0x1435, 0x1437, 0x5, 0x2f2, 0x17a, 0x2, 0x1436, 0x1435, 
       0x3, 0x2, 0x2, 0x2, 0x1436, 0x1437, 0x3, 0x2, 0x2, 0x2, 0x1437, 0x1438, 
       0x3, 0x2, 0x2, 0x2, 0x1438, 0x143a, 0x5, 0x2f0, 0x179, 0x2, 0x1439, 
       0x143b, 0x5, 0x2fe, 0x180, 0x2, 0x143a, 0x1439, 0x3, 0x2, 0x2, 0x2, 
       0x143a, 0x143b, 0x3, 0x2, 0x2, 0x2, 0x143b, 0x143d, 0x3, 0x2, 0x2, 
       0x2, 0x143c, 0x143e, 0x5, 0x304, 0x183, 0x2, 0x143d, 0x143c, 0x3, 
       0x2, 0x2, 0x2, 0x143d, 0x143e, 0x3, 0x2, 0x2, 0x2, 0x143e, 0x1440, 
       0x3, 0x2, 0x2, 0x2, 0x143f, 0x1441, 0x5, 0x31a, 0x18e, 0x2, 0x1440, 
       0x143f, 0x3, 0x2, 0x2, 0x2, 0x1440, 0x1441, 0x3, 0x2, 0x2, 0x2, 0x1441, 
       0x2ef, 0x3, 0x2, 0x2, 0x2, 0x1442, 0x1444, 0x7, 0x16f, 0x2, 0x2, 
       0x1443, 0x1445, 0x5, 0x2fc, 0x17f, 0x2, 0x1444, 0x1443, 0x3, 0x2, 
       0x2, 0x2, 0x1444, 0x1445, 0x3, 0x2, 0x2, 0x2, 0x1445, 0x1446, 0x3, 
       0x2, 0x2, 0x2, 0x1446, 0x1448, 0x5, 0x3f2, 0x1fa, 0x2, 0x1447, 0x1449, 
       0x5, 0x2f8, 0x17d, 0x2, 0x1448, 0x1447, 0x3, 0x2, 0x2, 0x2, 0x1448, 
       0x1449, 0x3, 0x2, 0x2, 0x2, 0x1449, 0x144b, 0x3, 0x2, 0x2, 0x2, 0x144a, 
       0x144c, 0x5, 0x322, 0x192, 0x2, 0x144b, 0x144a, 0x3, 0x2, 0x2, 0x2, 
       0x144b, 0x144c, 0x3, 0x2, 0x2, 0x2, 0x144c, 0x144e, 0x3, 0x2, 0x2, 
       0x2, 0x144d, 0x144f, 0x5, 0x332, 0x19a, 0x2, 0x144e, 0x144d, 0x3, 
       0x2, 0x2, 0x2, 0x144e, 0x144f, 0x3, 0x2, 0x2, 0x2, 0x144f, 0x1451, 
       0x3, 0x2, 0x2, 0x2, 0x1450, 0x1452, 0x5, 0x312, 0x18a, 0x2, 0x1451, 
       0x1450, 0x3, 0x2, 0x2, 0x2, 0x1451, 0x1452, 0x3, 0x2, 0x2, 0x2, 0x1452, 
       0x1454, 0x3, 0x2, 0x2, 0x2, 0x1453, 0x1455, 0x5, 0x318, 0x18d, 0x2, 
       0x1454, 0x1453, 0x3, 0x2, 0x2, 0x2, 0x1454, 0x1455, 0x3, 0x2, 0x2, 
       0x2, 0x1455, 0x1457, 0x3, 0x2, 0x2, 0x2, 0x1456, 0x1458, 0x5, 0x394, 
       0x1cb, 0x2, 0x1457, 0x1456, 0x3, 0x2, 0x2, 0x2, 0x1457, 0x1458, 0x3, 
       0x2, 0x2, 0x2, 0x1458, 0x145b, 0x3, 0x2, 0x2, 0x2, 0x1459, 0x145b, 
       0x5, 0x320, 0x191, 0x2, 0x145a, 0x1442, 0x3, 0x2, 0x2, 0x2, 0x145a, 
       0x1459, 0x3, 0x2, 0x2, 0x2, 0x145b, 0x2f1, 0x3, 0x2, 0x2, 0x2, 0x145c, 
       0x145e, 0x7, 0x1c4, 0x2, 0x2, 0x145d, 0x145f, 0x7, 0x14d, 0x2, 0x2, 
       0x145e, 0x145d, 0x3, 0x2, 0x2, 0x2, 0x145e, 0x145f, 0x3, 0x2, 0x2, 
       0x2, 0x145f, 0x1460, 0x3, 0x2, 0x2, 0x2, 0x1460, 0x1461, 0x5, 0x2f4, 
       0x17b, 0x2, 0x1461, 0x2f3, 0x3, 0x2, 0x2, 0x2, 0x1462, 0x1467, 0x5, 
       0x2f6, 0x17c, 0x2, 0x1463, 0x1464, 0x7, 0x1df, 0x2, 0x2, 0x1464, 
       0x1466, 0x5, 0x2f6, 0x17c, 0x2, 0x1465, 0x1463, 0x3, 0x2, 0x2, 0x2, 
       0x1466, 0x1469, 0x3, 0x2, 0x2, 0x2, 0x1467, 0x1465, 0x3, 0x2, 0x2, 
       0x2, 0x1467, 0x1468, 0x3, 0x2, 0x2, 0x2, 0x1468, 0x2f5, 0x3, 0x2, 
       0x2, 0x2, 0x1469, 0x1467, 0x3, 0x2, 0x2, 0x2, 0x146a, 0x146c, 0x5, 
       0x400, 0x201, 0x2, 0x146b, 0x146d, 0x5, 0x2ac, 0x157, 0x2, 0x146c, 
       0x146b, 0x3, 0x2, 0x2, 0x2, 0x146c, 0x146d, 0x3, 0x2, 0x2, 0x2, 0x146d, 
       0x146e, 0x3, 0x2, 0x2, 0x2, 0x146e, 0x146f, 0x7, 0x15, 0x2, 0x2, 
       0x146f, 0x1470, 0x5, 0x2ec, 0x177, 0x2, 0x1470, 0x2f7, 0x3, 0x2, 
       0x2, 0x2, 0x1471, 0x1473, 0x7, 0xca, 0x2, 0x2, 0x1472, 0x1474, 0x5, 
       0x2fa, 0x17e, 0x2, 0x1473, 0x1472, 0x3, 0x2, 0x2, 0x2, 0x1473, 0x1474, 
       0x3, 0x2, 0x2, 0x2, 0x1474, 0x2f9, 0x3, 0x2, 0x2, 0x2, 0x1475, 0x1477, 
       0x9, 0x10, 0x2, 0x2, 0x1476, 0x1475, 0x3, 0x2, 0x2, 0x2, 0x1476, 
       0x1477, 0x3, 0x2, 0x2, 0x2, 0x1477, 0x1478, 0x3, 0x2, 0x2, 0x2, 0x1478, 
       0x147a, 0x9, 0x11, 0x2, 0x2, 0x1479, 0x1476, 0x3, 0x2, 0x2, 0x2, 
       0x1479, 0x147a, 0x3, 0x2, 0x2, 0x2, 0x147a, 0x147c, 0x3, 0x2, 0x2, 
       0x2, 0x147b, 0x147d, 0x7, 0x190, 0x2, 0x2, 0x147c, 0x147b, 0x3, 0x2, 
       0x2, 0x2, 0x147c, 0x147d, 0x3, 0x2, 0x2, 0x2, 0x147d, 0x147e, 0x3, 
       0x2, 0x2, 0x2, 0x147e, 0x147f, 0x5, 0x3fa, 0x1fe, 0x2, 0x147f, 0x2fb, 
       0x3, 0x2, 0x2, 0x2, 0x1480, 0x1483, 0x7, 0x72, 0x2, 0x2, 0x1481, 
       0x1482, 0x7, 0x119, 0x2, 0x2, 0x1482, 0x1484, 0x5, 0x3b8, 0x1dd, 
       0x2, 0x1483, 0x1481, 0x3, 0x2, 0x2, 0x2, 0x1483, 0x1484, 0x3, 0x2, 
       0x2, 0x2, 0x1484, 0x1487, 0x3, 0x2, 0x2, 0x2, 0x1485, 0x1487, 0x7, 
       0xc, 0x2, 0x2, 0x1486, 0x1480, 0x3, 0x2, 0x2, 0x2, 0x1486, 0x1485, 
       0x3, 0x2, 0x2, 0x2, 0x1487, 0x2fd, 0x3, 0x2, 0x2, 0x2, 0x1488, 0x1489, 
       0x7, 0x11f, 0x2, 0x2, 0x1489, 0x148a, 0x7, 0x25, 0x2, 0x2, 0x148a, 
       0x148b, 0x5, 0x300, 0x181, 0x2, 0x148b, 0x2ff, 0x3, 0x2, 0x2, 0x2, 
       0x148c, 0x1491, 0x5, 0x302, 0x182, 0x2, 0x148d, 0x148e, 0x7, 0x1df, 
       0x2, 0x2, 0x148e, 0x1490, 0x5, 0x302, 0x182, 0x2, 0x148f, 0x148d, 
       0x3, 0x2, 0x2, 0x2, 0x1490, 0x1493, 0x3, 0x2, 0x2, 0x2, 0x1491, 0x148f, 
       0x3, 0x2, 0x2, 0x2, 0x1491, 0x1492, 0x3, 0x2, 0x2, 0x2, 0x1492, 0x301, 
       0x3, 0x2, 0x2, 0x2, 0x1493, 0x1491, 0x3, 0x2, 0x2, 0x2, 0x1494, 0x1495, 
       0x5, 0x362, 0x1b2, 0x2, 0x1495, 0x1496, 0x7, 0x1b1, 0x2, 0x2, 0x1496, 
       0x1498, 0x5, 0x3b4, 0x1db, 0x2, 0x1497, 0x1499, 0x5, 0x218, 0x10d, 
       0x2, 0x1498, 0x1497, 0x3, 0x2, 0x2, 0x2, 0x1498, 0x1499, 0x3, 0x2, 
       0x2, 0x2, 0x1499, 0x14a2, 0x3, 0x2, 0x2, 0x2, 0x149a, 0x149c, 0x5, 
       0x362, 0x1b2, 0x2, 0x149b, 0x149d, 0x5, 0x216, 0x10c, 0x2, 0x149c, 
       0x149b, 0x3, 0x2, 0x2, 0x2, 0x149c, 0x149d, 0x3, 0x2, 0x2, 0x2, 0x149d, 
       0x149f, 0x3, 0x2, 0x2, 0x2, 0x149e, 0x14a0, 0x5, 0x218, 0x10d, 0x2, 
       0x149f, 0x149e, 0x3, 0x2, 0x2, 0x2, 0x149f, 0x14a0, 0x3, 0x2, 0x2, 
       0x2, 0x14a0, 0x14a2, 0x3, 0x2, 0x2, 0x2, 0x14a1, 0x1494, 0x3, 0x2, 
       0x2, 0x2, 0x14a1, 0x149a, 0x3, 0x2, 0x2, 0x2, 0x14a2, 0x303, 0x3, 
       0x2, 0x2, 0x2, 0x14a3, 0x14a4, 0x7, 0xda, 0x2, 0x2, 0x14a4, 0x14a5, 
       0x5, 0x306, 0x184, 0x2, 0x14a5, 0x14a6, 0x7, 0x116, 0x2, 0x2, 0x14a6, 
       0x14a7, 0x5, 0x30a, 0x186, 0x2, 0x14a7, 0x14ce, 0x3, 0x2, 0x2, 0x2, 
       0x14a8, 0x14a9, 0x7, 0x116, 0x2, 0x2, 0x14a9, 0x14aa, 0x5, 0x30a, 
       0x186, 0x2, 0x14aa, 0x14ab, 0x7, 0xda, 0x2, 0x2, 0x14ab, 0x14ac, 
       0x5, 0x306, 0x184, 0x2, 0x14ac, 0x14ce, 0x3, 0x2, 0x2, 0x2, 0x14ad, 
       0x14ae, 0x7, 0xda, 0x2, 0x2, 0x14ae, 0x14ce, 0x5, 0x306, 0x184, 0x2, 
       0x14af, 0x14b0, 0x7, 0x116, 0x2, 0x2, 0x14b0, 0x14ce, 0x5, 0x30a, 
       0x186, 0x2, 0x14b1, 0x14b2, 0x7, 0xda, 0x2, 0x2, 0x14b2, 0x14b3, 
       0x5, 0x306, 0x184, 0x2, 0x14b3, 0x14b4, 0x7, 0x1df, 0x2, 0x2, 0x14b4, 
       0x14b5, 0x5, 0x30a, 0x186, 0x2, 0x14b5, 0x14ce, 0x3, 0x2, 0x2, 0x2, 
       0x14b6, 0x14b7, 0x7, 0x116, 0x2, 0x2, 0x14b7, 0x14b8, 0x5, 0x30c, 
       0x187, 0x2, 0x14b8, 0x14b9, 0x5, 0x30e, 0x188, 0x2, 0x14b9, 0x14ce, 
       0x3, 0x2, 0x2, 0x2, 0x14ba, 0x14bb, 0x7, 0x91, 0x2, 0x2, 0x14bb, 
       0x14bd, 0x5, 0x310, 0x189, 0x2, 0x14bc, 0x14be, 0x5, 0x308, 0x185, 
       0x2, 0x14bd, 0x14bc, 0x3, 0x2, 0x2, 0x2, 0x14bd, 0x14be, 0x3, 0x2, 
       0x2, 0x2, 0x14be, 0x14bf, 0x3, 0x2, 0x2, 0x2, 0x14bf, 0x14c0, 0x5, 
       0x30e, 0x188, 0x2, 0x14c0, 0x14c1, 0x7, 0x11a, 0x2, 0x2, 0x14c1, 
       0x14ce, 0x3, 0x2, 0x2, 0x2, 0x14c2, 0x14c3, 0x7, 0x116, 0x2, 0x2, 
       0x14c3, 0x14c4, 0x5, 0x30c, 0x187, 0x2, 0x14c4, 0x14c5, 0x5, 0x30e, 
       0x188, 0x2, 0x14c5, 0x14c6, 0x7, 0x91, 0x2, 0x2, 0x14c6, 0x14c8, 
       0x5, 0x310, 0x189, 0x2, 0x14c7, 0x14c9, 0x5, 0x308, 0x185, 0x2, 0x14c8, 
       0x14c7, 0x3, 0x2, 0x2, 0x2, 0x14c8, 0x14c9, 0x3, 0x2, 0x2, 0x2, 0x14c9, 
       0x14ca, 0x3, 0x2, 0x2, 0x2, 0x14ca, 0x14cb, 0x5, 0x30e, 0x188, 0x2, 
       0x14cb, 0x14cc, 0x7, 0x11a, 0x2, 0x2, 0x14cc, 0x14ce, 0x3, 0x2, 0x2, 
       0x2, 0x14cd, 0x14a3, 0x3, 0x2, 0x2, 0x2, 0x14cd, 0x14a8, 0x3, 0x2, 
       0x2, 0x2, 0x14cd, 0x14ad, 0x3, 0x2, 0x2, 0x2, 0x14cd, 0x14af, 0x3, 
       0x2, 0x2, 0x2, 0x14cd, 0x14b1, 0x3, 0x2, 0x2, 0x2, 0x14cd, 0x14b6, 
       0x3, 0x2, 0x2, 0x2, 0x14cd, 0x14ba, 0x3, 0x2, 0x2, 0x2, 0x14cd, 0x14c2, 
       0x3, 0x2, 0x2, 0x2, 0x14ce, 0x305, 0x3, 0x2, 0x2, 0x2, 0x14cf, 0x14d2, 
       0x5, 0x362, 0x1b2, 0x2, 0x14d0, 0x14d2, 0x7, 0xc, 0x2, 0x2, 0x14d1, 
       0x14cf, 0x3, 0x2, 0x2, 0x2, 0x14d1, 0x14d0, 0x3, 0x2, 0x2, 0x2, 0x14d2, 
       0x307, 0x3, 0x2, 0x2, 0x2, 0x14d3, 0x14d9, 0x5, 0x418, 0x20d, 0x2, 
       0x14d4, 0x14d5, 0x7, 0x1d9, 0x2, 0x2, 0x14d5, 0x14d6, 0x5, 0x362, 
       0x1b2, 0x2, 0x14d6, 0x14d7, 0x7, 0x1da, 0x2, 0x2, 0x14d7, 0x14d9, 
       0x3, 0x2, 0x2, 0x2, 0x14d8, 0x14d3, 0x3, 0x2, 0x2, 0x2, 0x14d8, 0x14d4, 
       0x3, 0x2, 0x2, 0x2, 0x14d9, 0x309, 0x3, 0x2, 0x2, 0x2, 0x14da, 0x14db, 
       0x5, 0x362, 0x1b2, 0x2, 0x14db, 0x30b, 0x3, 0x2, 0x2, 0x2, 0x14dc, 
       0x14dd, 0x5, 0x378, 0x1bd, 0x2, 0x14dd, 0x30d, 0x3, 0x2, 0x2, 0x2, 
       0x14de, 0x14df, 0x9, 0x41, 0x2, 0x2, 0x14df, 0x30f, 0x3, 0x2, 0x2, 
       0x2, 0x14e0, 0x14e1, 0x9, 0x42, 0x2, 0x2, 0x14e1, 0x311, 0x3, 0x2, 
       0x2, 0x2, 0x14e2, 0x14e3, 0x7, 0xa8, 0x2, 0x2, 0x14e3, 0x14e4, 0x7, 
       0x25, 0x2, 0x2, 0x14e4, 0x14e5, 0x5, 0x314, 0x18b, 0x2, 0x14e5, 0x313, 
       0x3, 0x2, 0x2, 0x2, 0x14e6, 0x14eb, 0x5, 0x316, 0x18c, 0x2, 0x14e7, 
       0x14e8, 0x7, 0x1df, 0x2, 0x2, 0x14e8, 0x14ea, 0x5, 0x316, 0x18c, 
       0x2, 0x14e9, 0x14e7, 0x3, 0x2, 0x2, 0x2, 0x14ea, 0x14ed, 0x3, 0x2, 
       0x2, 0x2, 0x14eb, 0x14e9, 0x3, 0x2, 0x2, 0x2, 0x14eb, 0x14ec, 0x3, 
       0x2, 0x2, 0x2, 0x14ec, 0x315, 0x3, 0x2, 0x2, 0x2, 0x14ed, 0x14eb, 
       0x3, 0x2, 0x2, 0x2, 0x14ee, 0x14fb, 0x5, 0x362, 0x1b2, 0x2, 0x14ef, 
       0x14f0, 0x7, 0x162, 0x2, 0x2, 0x14f0, 0x14fb, 0x5, 0x3b8, 0x1dd, 
       0x2, 0x14f1, 0x14f2, 0x7, 0x52, 0x2, 0x2, 0x14f2, 0x14fb, 0x5, 0x3b8, 
       0x1dd, 0x2, 0x14f3, 0x14f4, 0x7, 0xa7, 0x2, 0x2, 0x14f4, 0x14f5, 
       0x7, 0x176, 0x2, 0x2, 0x14f5, 0x14f6, 0x7, 0x1d9, 0x2, 0x2, 0x14f6, 
       0x14f7, 0x5, 0x314, 0x18b, 0x2, 0x14f7, 0x14f8, 0x7, 0x1da, 0x2, 
       0x2, 0x14f8, 0x14fb, 0x3, 0x2, 0x2, 0x2, 0x14f9, 0x14fb, 0x5, 0x132, 
       0x9a, 0x2, 0x14fa, 0x14ee, 0x3, 0x2, 0x2, 0x2, 0x14fa, 0x14ef, 0x3, 
       0x2, 0x2, 0x2, 0x14fa, 0x14f1, 0x3, 0x2, 0x2, 0x2, 0x14fa, 0x14f3, 
       0x3, 0x2, 0x2, 0x2, 0x14fa, 0x14f9, 0x3, 0x2, 0x2, 0x2, 0x14fb, 0x317, 
       0x3, 0x2, 0x2, 0x2, 0x14fc, 0x14fd, 0x7, 0xab, 0x2, 0x2, 0x14fd, 
       0x14fe, 0x5, 0x362, 0x1b2, 0x2, 0x14fe, 0x319, 0x3, 0x2, 0x2, 0x2, 
       0x14ff, 0x1501, 0x5, 0x31c, 0x18f, 0x2, 0x1500, 0x14ff, 0x3, 0x2, 
       0x2, 0x2, 0x1501, 0x1502, 0x3, 0x2, 0x2, 0x2, 0x1502, 0x1500, 0x3, 
       0x2, 0x2, 0x2, 0x1502, 0x1503, 0x3, 0x2, 0x2, 0x2, 0x1503, 0x1508, 
       0x3, 0x2, 0x2, 0x2, 0x1504, 0x1505, 0x7, 0x99, 0x2, 0x2, 0x1505, 
       0x1506, 0x7, 0x147, 0x2, 0x2, 0x1506, 0x1508, 0x7, 0x11a, 0x2, 0x2, 
       0x1507, 0x1500, 0x3, 0x2, 0x2, 0x2, 0x1507, 0x1504, 0x3, 0x2, 0x2, 
       0x2, 0x1508, 0x31b, 0x3, 0x2, 0x2, 0x2, 0x1509, 0x150a, 0x7, 0x99, 
       0x2, 0x2, 0x150a, 0x150c, 0x9, 0x43, 0x2, 0x2, 0x150b, 0x150d, 0x5, 
       0x31e, 0x190, 0x2, 0x150c, 0x150b, 0x3, 0x2, 0x2, 0x2, 0x150c, 0x150d, 
       0x3, 0x2, 0x2, 0x2, 0x150d, 0x150f, 0x3, 0x2, 0x2, 0x2, 0x150e, 0x1510, 
       0x7, 0x10c, 0x2, 0x2, 0x150f, 0x150e, 0x3, 0x2, 0x2, 0x2, 0x150f, 
       0x1510, 0x3, 0x2, 0x2, 0x2, 0x1510, 0x31d, 0x3, 0x2, 0x2, 0x2, 0x1511, 
       0x1512, 0x7, 0x114, 0x2, 0x2, 0x1512, 0x1513, 0x5, 0x3fc, 0x1ff, 
       0x2, 0x1513, 0x31f, 0x3, 0x2, 0x2, 0x2, 0x1514, 0x1515, 0x8, 0x191, 
       0x1, 0x2, 0x1515, 0x1516, 0x7, 0x1b7, 0x2, 0x2, 0x1516, 0x1517, 0x5, 
       0x3f0, 0x1f9, 0x2, 0x1517, 0x151d, 0x3, 0x2, 0x2, 0x2, 0x1518, 0x1519, 
       0xc, 0x3, 0x2, 0x2, 0x1519, 0x151a, 0x7, 0x1df, 0x2, 0x2, 0x151a, 
       0x151c, 0x5, 0x3f0, 0x1f9, 0x2, 0x151b, 0x1518, 0x3, 0x2, 0x2, 0x2, 
       0x151c, 0x151f, 0x3, 0x2, 0x2, 0x2, 0x151d, 0x151b, 0x3, 0x2, 0x2, 
       0x2, 0x151d, 0x151e, 0x3, 0x2, 0x2, 0x2, 0x151e, 0x321, 0x3, 0x2, 
       0x2, 0x2, 0x151f, 0x151d, 0x3, 0x2, 0x2, 0x2, 0x1520, 0x1521, 0x7, 
       0x9f, 0x2, 0x2, 0x1521, 0x1522, 0x5, 0x324, 0x193, 0x2, 0x1522, 0x323, 
       0x3, 0x2, 0x2, 0x2, 0x1523, 0x1528, 0x5, 0x326, 0x194, 0x2, 0x1524, 
       0x1525, 0x7, 0x1df, 0x2, 0x2, 0x1525, 0x1527, 0x5, 0x326, 0x194, 
       0x2, 0x1526, 0x1524, 0x3, 0x2, 0x2, 0x2, 0x1527, 0x152a, 0x3, 0x2, 
       0x2, 0x2, 0x1528, 0x1526, 0x3, 0x2, 0x2, 0x2, 0x1528, 0x1529, 0x3, 
       0x2, 0x2, 0x2, 0x1529, 0x325, 0x3, 0x2, 0x2, 0x2, 0x152a, 0x1528, 
       0x3, 0x2, 0x2, 0x2, 0x152b, 0x152c, 0x8, 0x194, 0x1, 0x2, 0x152c, 
       0x1534, 0x5, 0x32c, 0x197, 0x2, 0x152d, 0x152f, 0x7, 0x15, 0x2, 0x2, 
       0x152e, 0x152d, 0x3, 0x2, 0x2, 0x2, 0x152e, 0x152f, 0x3, 0x2, 0x2, 
       0x2, 0x152f, 0x1530, 0x3, 0x2, 0x2, 0x2, 0x1530, 0x1532, 0x5, 0x41a, 
       0x20e, 0x2, 0x1531, 0x1533, 0x5, 0x2ac, 0x157, 0x2, 0x1532, 0x1531, 
       0x3, 0x2, 0x2, 0x2, 0x1532, 0x1533, 0x3, 0x2, 0x2, 0x2, 0x1533, 0x1535, 
       0x3, 0x2, 0x2, 0x2, 0x1534, 0x152e, 0x3, 0x2, 0x2, 0x2, 0x1534, 0x1535, 
       0x3, 0x2, 0x2, 0x2, 0x1535, 0x1562, 0x3, 0x2, 0x2, 0x2, 0x1536, 0x153e, 
       0x5, 0x330, 0x199, 0x2, 0x1537, 0x1539, 0x7, 0x15, 0x2, 0x2, 0x1538, 
       0x1537, 0x3, 0x2, 0x2, 0x2, 0x1538, 0x1539, 0x3, 0x2, 0x2, 0x2, 0x1539, 
       0x153a, 0x3, 0x2, 0x2, 0x2, 0x153a, 0x153c, 0x5, 0x41a, 0x20e, 0x2, 
       0x153b, 0x153d, 0x5, 0x2ac, 0x157, 0x2, 0x153c, 0x153b, 0x3, 0x2, 
       0x2, 0x2, 0x153c, 0x153d, 0x3, 0x2, 0x2, 0x2, 0x153d, 0x153f, 0x3, 
       0x2, 0x2, 0x2, 0x153e, 0x1538, 0x3, 0x2, 0x2, 0x2, 0x153e, 0x153f, 
       0x3, 0x2, 0x2, 0x2, 0x153f, 0x1562, 0x3, 0x2, 0x2, 0x2, 0x1540, 0x1542, 
       0x5, 0x330, 0x199, 0x2, 0x1541, 0x1543, 0x7, 0x15, 0x2, 0x2, 0x1542, 
       0x1541, 0x3, 0x2, 0x2, 0x2, 0x1542, 0x1543, 0x3, 0x2, 0x2, 0x2, 0x1543, 
       0x1545, 0x3, 0x2, 0x2, 0x2, 0x1544, 0x1546, 0x5, 0x41a, 0x20e, 0x2, 
       0x1545, 0x1544, 0x3, 0x2, 0x2, 0x2, 0x1545, 0x1546, 0x3, 0x2, 0x2, 
       0x2, 0x1546, 0x1547, 0x3, 0x2, 0x2, 0x2, 0x1547, 0x1548, 0x7, 0x1d9, 
       0x2, 0x2, 0x1548, 0x1549, 0x5, 0x336, 0x19c, 0x2, 0x1549, 0x154a, 
       0x7, 0x1da, 0x2, 0x2, 0x154a, 0x1562, 0x3, 0x2, 0x2, 0x2, 0x154b, 
       0x1553, 0x5, 0x2ec, 0x177, 0x2, 0x154c, 0x154e, 0x7, 0x15, 0x2, 0x2, 
       0x154d, 0x154c, 0x3, 0x2, 0x2, 0x2, 0x154d, 0x154e, 0x3, 0x2, 0x2, 
       0x2, 0x154e, 0x154f, 0x3, 0x2, 0x2, 0x2, 0x154f, 0x1551, 0x5, 0x41a, 
       0x20e, 0x2, 0x1550, 0x1552, 0x5, 0x2ac, 0x157, 0x2, 0x1551, 0x1550, 
       0x3, 0x2, 0x2, 0x2, 0x1551, 0x1552, 0x3, 0x2, 0x2, 0x2, 0x1552, 0x1554, 
       0x3, 0x2, 0x2, 0x2, 0x1553, 0x154d, 0x3, 0x2, 0x2, 0x2, 0x1553, 0x1554, 
       0x3, 0x2, 0x2, 0x2, 0x1554, 0x1562, 0x3, 0x2, 0x2, 0x2, 0x1555, 0x1556, 
       0x7, 0x1d9, 0x2, 0x2, 0x1556, 0x1557, 0x5, 0x326, 0x194, 0x2, 0x1557, 
       0x155f, 0x7, 0x1da, 0x2, 0x2, 0x1558, 0x155a, 0x7, 0x15, 0x2, 0x2, 
       0x1559, 0x1558, 0x3, 0x2, 0x2, 0x2, 0x1559, 0x155a, 0x3, 0x2, 0x2, 
       0x2, 0x155a, 0x155b, 0x3, 0x2, 0x2, 0x2, 0x155b, 0x155d, 0x5, 0x41a, 
       0x20e, 0x2, 0x155c, 0x155e, 0x5, 0x2ac, 0x157, 0x2, 0x155d, 0x155c, 
       0x3, 0x2, 0x2, 0x2, 0x155d, 0x155e, 0x3, 0x2, 0x2, 0x2, 0x155e, 0x1560, 
       0x3, 0x2, 0x2, 0x2, 0x155f, 0x1559, 0x3, 0x2, 0x2, 0x2, 0x155f, 0x1560, 
       0x3, 0x2, 0x2, 0x2, 0x1560, 0x1562, 0x3, 0x2, 0x2, 0x2, 0x1561, 0x152b, 
       0x3, 0x2, 0x2, 0x2, 0x1561, 0x1536, 0x3, 0x2, 0x2, 0x2, 0x1561, 0x1540, 
       0x3, 0x2, 0x2, 0x2, 0x1561, 0x154b, 0x3, 0x2, 0x2, 0x2, 0x1561, 0x1555, 
       0x3, 0x2, 0x2, 0x2, 0x1562, 0x1571, 0x3, 0x2, 0x2, 0x2, 0x1563, 0x1565, 
       0xc, 0x3, 0x2, 0x2, 0x1564, 0x1566, 0x7, 0xfa, 0x2, 0x2, 0x1565, 
       0x1564, 0x3, 0x2, 0x2, 0x2, 0x1565, 0x1566, 0x3, 0x2, 0x2, 0x2, 0x1566, 
       0x1568, 0x3, 0x2, 0x2, 0x2, 0x1567, 0x1569, 0x5, 0x328, 0x195, 0x2, 
       0x1568, 0x1567, 0x3, 0x2, 0x2, 0x2, 0x1568, 0x1569, 0x3, 0x2, 0x2, 
       0x2, 0x1569, 0x156a, 0x3, 0x2, 0x2, 0x2, 0x156a, 0x156b, 0x7, 0xd0, 
       0x2, 0x2, 0x156b, 0x156d, 0x5, 0x326, 0x194, 0x2, 0x156c, 0x156e, 
       0x5, 0x32a, 0x196, 0x2, 0x156d, 0x156c, 0x3, 0x2, 0x2, 0x2, 0x156d, 
       0x156e, 0x3, 0x2, 0x2, 0x2, 0x156e, 0x1570, 0x3, 0x2, 0x2, 0x2, 0x156f, 
       0x1563, 0x3, 0x2, 0x2, 0x2, 0x1570, 0x1573, 0x3, 0x2, 0x2, 0x2, 0x1571, 
       0x156f, 0x3, 0x2, 0x2, 0x2, 0x1571, 0x1572, 0x3, 0x2, 0x2, 0x2, 0x1572, 
       0x327, 0x3, 0x2, 0x2, 0x2, 0x1573, 0x1571, 0x3, 0x2, 0x2, 0x2, 0x1574, 
       0x1576, 0x9, 0x44, 0x2, 0x2, 0x1575, 0x1577, 0x7, 0x122, 0x2, 0x2, 
       0x1576, 0x1575, 0x3, 0x2, 0x2, 0x2, 0x1576, 0x1577, 0x3, 0x2, 0x2, 
       0x2, 0x1577, 0x157b, 0x3, 0x2, 0x2, 0x2, 0x1578, 0x157b, 0x7, 0xc0, 
       0x2, 0x2, 0x1579, 0x157b, 0x7, 0x50, 0x2, 0x2, 0x157a, 0x1574, 0x3, 
       0x2, 0x2, 0x2, 0x157a, 0x1578, 0x3, 0x2, 0x2, 0x2, 0x157a, 0x1579, 
       0x3, 0x2, 0x2, 0x2, 0x157b, 0x329, 0x3, 0x2, 0x2, 0x2, 0x157c, 0x157d, 
       0x7, 0x1b1, 0x2, 0x2, 0x157d, 0x1581, 0x5, 0x2ac, 0x157, 0x2, 0x157e, 
       0x157f, 0x7, 0x119, 0x2, 0x2, 0x157f, 0x1581, 0x5, 0x362, 0x1b2, 
       0x2, 0x1580, 0x157c, 0x3, 0x2, 0x2, 0x2, 0x1580, 0x157e, 0x3, 0x2, 
       0x2, 0x2, 0x1581, 0x32b, 0x3, 0x2, 0x2, 0x2, 0x1582, 0x1584, 0x5, 
       0x3fa, 0x1fe, 0x2, 0x1583, 0x1585, 0x7, 0x1dc, 0x2, 0x2, 0x1584, 
       0x1583, 0x3, 0x2, 0x2, 0x2, 0x1584, 0x1585, 0x3, 0x2, 0x2, 0x2, 0x1585, 
       0x158e, 0x3, 0x2, 0x2, 0x2, 0x1586, 0x1587, 0x7, 0x11a, 0x2, 0x2, 
       0x1587, 0x158e, 0x5, 0x3fa, 0x1fe, 0x2, 0x1588, 0x1589, 0x7, 0x11a, 
       0x2, 0x2, 0x1589, 0x158a, 0x7, 0x1d9, 0x2, 0x2, 0x158a, 0x158b, 0x5, 
       0x3fa, 0x1fe, 0x2, 0x158b, 0x158c, 0x7, 0x1da, 0x2, 0x2, 0x158c, 
       0x158e, 0x3, 0x2, 0x2, 0x2, 0x158d, 0x1582, 0x3, 0x2, 0x2, 0x2, 0x158d, 
       0x1586, 0x3, 0x2, 0x2, 0x2, 0x158d, 0x1588, 0x3, 0x2, 0x2, 0x2, 0x158e, 
       0x32d, 0x3, 0x2, 0x2, 0x2, 0x158f, 0x1594, 0x5, 0x32c, 0x197, 0x2, 
       0x1590, 0x1592, 0x7, 0x15, 0x2, 0x2, 0x1591, 0x1590, 0x3, 0x2, 0x2, 
       0x2, 0x1591, 0x1592, 0x3, 0x2, 0x2, 0x2, 0x1592, 0x1593, 0x3, 0x2, 
       0x2, 0x2, 0x1593, 0x1595, 0x5, 0x41a, 0x20e, 0x2, 0x1594, 0x1591, 
       0x3, 0x2, 0x2, 0x2, 0x1594, 0x1595, 0x3, 0x2, 0x2, 0x2, 0x1595, 0x32f, 
       0x3, 0x2, 0x2, 0x2, 0x1596, 0x1597, 0x5, 0x382, 0x1c2, 0x2, 0x1597, 
       0x331, 0x3, 0x2, 0x2, 0x2, 0x1598, 0x1599, 0x7, 0x1c1, 0x2, 0x2, 
       0x1599, 0x159a, 0x5, 0x362, 0x1b2, 0x2, 0x159a, 0x333, 0x3, 0x2, 
       0x2, 0x2, 0x159b, 0x159c, 0x7, 0x1c1, 0x2, 0x2, 0x159c, 0x15a5, 0x5, 
       0x362, 0x1b2, 0x2, 0x159d, 0x159e, 0x7, 0x1c1, 0x2, 0x2, 0x159e, 
       0x159f, 0x7, 0x55, 0x2, 0x2, 0x159f, 0x15a2, 0x7, 0x114, 0x2, 0x2, 
       0x15a0, 0x15a3, 0x5, 0x3fe, 0x200, 0x2, 0x15a1, 0x15a3, 0x7, 0x1ff, 
       0x2, 0x2, 0x15a2, 0x15a0, 0x3, 0x2, 0x2, 0x2, 0x15a2, 0x15a1, 0x3, 
       0x2, 0x2, 0x2, 0x15a3, 0x15a5, 0x3, 0x2, 0x2, 0x2, 0x15a4, 0x159b, 
       0x3, 0x2, 0x2, 0x2, 0x15a4, 0x159d, 0x3, 0x2, 0x2, 0x2, 0x15a5, 0x335, 
       0x3, 0x2, 0x2, 0x2, 0x15a6, 0x15ab, 0x5, 0x338, 0x19d, 0x2, 0x15a7, 
       0x15a8, 0x7, 0x1df, 0x2, 0x2, 0x15a8, 0x15aa, 0x5, 0x338, 0x19d, 
       0x2, 0x15a9, 0x15a7, 0x3, 0x2, 0x2, 0x2, 0x15aa, 0x15ad, 0x3, 0x2, 
       0x2, 0x2, 0x15ab, 0x15a9, 0x3, 0x2, 0x2, 0x2, 0x15ab, 0x15ac, 0x3, 
       0x2, 0x2, 0x2, 0x15ac, 0x337, 0x3, 0x2, 0x2, 0x2, 0x15ad, 0x15ab, 
       0x3, 0x2, 0x2, 0x2, 0x15ae, 0x15af, 0x5, 0x41a, 0x20e, 0x2, 0x15af, 
       0x15b0, 0x5, 0x33a, 0x19e, 0x2, 0x15b0, 0x339, 0x3, 0x2, 0x2, 0x2, 
       0x15b1, 0x15b5, 0x5, 0x33e, 0x1a0, 0x2, 0x15b2, 0x15b4, 0x5, 0x33c, 
       0x19f, 0x2, 0x15b3, 0x15b2, 0x3, 0x2, 0x2, 0x2, 0x15b4, 0x15b7, 0x3, 
       0x2, 0x2, 0x2, 0x15b5, 0x15b3, 0x3, 0x2, 0x2, 0x2, 0x15b5, 0x15b6, 
       0x3, 0x2, 0x2, 0x2, 0x15b6, 0x15ce, 0x3, 0x2, 0x2, 0x2, 0x15b7, 0x15b5, 
       0x3, 0x2, 0x2, 0x2, 0x15b8, 0x15b9, 0x7, 0x175, 0x2, 0x2, 0x15b9, 
       0x15bd, 0x5, 0x33e, 0x1a0, 0x2, 0x15ba, 0x15bc, 0x5, 0x33c, 0x19f, 
       0x2, 0x15bb, 0x15ba, 0x3, 0x2, 0x2, 0x2, 0x15bc, 0x15bf, 0x3, 0x2, 
       0x2, 0x2, 0x15bd, 0x15bb, 0x3, 0x2, 0x2, 0x2, 0x15bd, 0x15be, 0x3, 
       0x2, 0x2, 0x2, 0x15be, 0x15ce, 0x3, 0x2, 0x2, 0x2, 0x15bf, 0x15bd, 
       0x3, 0x2, 0x2, 0x2, 0x15c0, 0x15c1, 0x5, 0x33e, 0x1a0, 0x2, 0x15c1, 
       0x15c2, 0x7, 0x14, 0x2, 0x2, 0x15c2, 0x15c3, 0x7, 0x1f2, 0x2, 0x2, 
       0x15c3, 0x15c4, 0x5, 0x410, 0x209, 0x2, 0x15c4, 0x15c5, 0x7, 0x1f3, 
       0x2, 0x2, 0x15c5, 0x15ce, 0x3, 0x2, 0x2, 0x2, 0x15c6, 0x15c7, 0x7, 
       0x175, 0x2, 0x2, 0x15c7, 0x15c8, 0x5, 0x33e, 0x1a0, 0x2, 0x15c8, 
       0x15c9, 0x7, 0x14, 0x2, 0x2, 0x15c9, 0x15ca, 0x7, 0x1f2, 0x2, 0x2, 
       0x15ca, 0x15cb, 0x5, 0x410, 0x209, 0x2, 0x15cb, 0x15cc, 0x7, 0x1f3, 
       0x2, 0x2, 0x15cc, 0x15ce, 0x3, 0x2, 0x2, 0x2, 0x15cd, 0x15b1, 0x3, 
       0x2, 0x2, 0x2, 0x15cd, 0x15b8, 0x3, 0x2, 0x2, 0x2, 0x15cd, 0x15c0, 
       0x3, 0x2, 0x2, 0x2, 0x15cd, 0x15c6, 0x3, 0x2, 0x2, 0x2, 0x15ce, 0x33b, 
       0x3, 0x2, 0x2, 0x2, 0x15cf, 0x15d0, 0x7, 0x1f2, 0x2, 0x2, 0x15d0, 
       0x15d6, 0x7, 0x1f3, 0x2, 0x2, 0x15d1, 0x15d2, 0x7, 0x1f2, 0x2, 0x2, 
       0x15d2, 0x15d3, 0x5, 0x410, 0x209, 0x2, 0x15d3, 0x15d4, 0x7, 0x1f3, 
       0x2, 0x2, 0x15d4, 0x15d6, 0x3, 0x2, 0x2, 0x2, 0x15d5, 0x15cf, 0x3, 
       0x2, 0x2, 0x2, 0x15d5, 0x15d1, 0x3, 0x2, 0x2, 0x2, 0x15d6, 0x33d, 
       0x3, 0x2, 0x2, 0x2, 0x15d7, 0x15e4, 0x5, 0x342, 0x1a2, 0x2, 0x15d8, 
       0x15e4, 0x5, 0x344, 0x1a3, 0x2, 0x15d9, 0x15e4, 0x5, 0x346, 0x1a4, 
       0x2, 0x15da, 0x15e4, 0x5, 0x34e, 0x1a8, 0x2, 0x15db, 0x15e4, 0x5, 
       0x35a, 0x1ae, 0x2, 0x15dc, 0x15de, 0x5, 0x35c, 0x1af, 0x2, 0x15dd, 
       0x15df, 0x5, 0x5e, 0x30, 0x2, 0x15de, 0x15dd, 0x3, 0x2, 0x2, 0x2, 
       0x15de, 0x15df, 0x3, 0x2, 0x2, 0x2, 0x15df, 0x15e1, 0x3, 0x2, 0x2, 
       0x2, 0x15e0, 0x15e2, 0x5, 0x360, 0x1b1, 0x2, 0x15e1, 0x15e0, 0x3, 
       0x2, 0x2, 0x2, 0x15e1, 0x15e2, 0x3, 0x2, 0x2, 0x2, 0x15e2, 0x15e4, 
       0x3, 0x2, 0x2, 0x2, 0x15e3, 0x15d7, 0x3, 0x2, 0x2, 0x2, 0x15e3, 0x15d8, 
       0x3, 0x2, 0x2, 0x2, 0x15e3, 0x15d9, 0x3, 0x2, 0x2, 0x2, 0x15e3, 0x15da, 
       0x3, 0x2, 0x2, 0x2, 0x15e3, 0x15db, 0x3, 0x2, 0x2, 0x2, 0x15e3, 0x15dc, 
       0x3, 0x2, 0x2, 0x2, 0x15e4, 0x33f, 0x3, 0x2, 0x2, 0x2, 0x15e5, 0x15ea, 
       0x5, 0x344, 0x1a3, 0x2, 0x15e6, 0x15ea, 0x5, 0x348, 0x1a5, 0x2, 0x15e7, 
       0x15ea, 0x5, 0x350, 0x1a9, 0x2, 0x15e8, 0x15ea, 0x5, 0x35a, 0x1ae, 
       0x2, 0x15e9, 0x15e5, 0x3, 0x2, 0x2, 0x2, 0x15e9, 0x15e6, 0x3, 0x2, 
       0x2, 0x2, 0x15e9, 0x15e7, 0x3, 0x2, 0x2, 0x2, 0x15e9, 0x15e8, 0x3, 
       0x2, 0x2, 0x2, 0x15ea, 0x341, 0x3, 0x2, 0x2, 0x2, 0x15eb, 0x15ed, 
       0x5, 0x41c, 0x20f, 0x2, 0x15ec, 0x15ee, 0x5, 0x1de, 0xf0, 0x2, 0x15ed, 
       0x15ec, 0x3, 0x2, 0x2, 0x2, 0x15ed, 0x15ee, 0x3, 0x2, 0x2, 0x2, 0x15ee, 
       0x15f0, 0x3, 0x2, 0x2, 0x2, 0x15ef, 0x15f1, 0x5, 0x3b8, 0x1dd, 0x2, 
       0x15f0, 0x15ef, 0x3, 0x2, 0x2, 0x2, 0x15f0, 0x15f1, 0x3, 0x2, 0x2, 
       0x2, 0x15f1, 0x343, 0x3, 0x2, 0x2, 0x2, 0x15f2, 0x160b, 0x7, 0xcb, 
       0x2, 0x2, 0x15f3, 0x160b, 0x7, 0xc7, 0x2, 0x2, 0x15f4, 0x160b, 0x7, 
       0x17b, 0x2, 0x2, 0x15f5, 0x160b, 0x7, 0x20, 0x2, 0x2, 0x15f6, 0x160b, 
       0x7, 0x14a, 0x2, 0x2, 0x15f7, 0x15f9, 0x7, 0x97, 0x2, 0x2, 0x15f8, 
       0x15fa, 0x5, 0x5e, 0x30, 0x2, 0x15f9, 0x15f8, 0x3, 0x2, 0x2, 0x2, 
       0x15f9, 0x15fa, 0x3, 0x2, 0x2, 0x2, 0x15fa, 0x160b, 0x3, 0x2, 0x2, 
       0x2, 0x15fb, 0x15fc, 0x7, 0x77, 0x2, 0x2, 0x15fc, 0x160b, 0x7, 0x137, 
       0x2, 0x2, 0x15fd, 0x15ff, 0x7, 0x62, 0x2, 0x2, 0x15fe, 0x1600, 0x5, 
       0x3b8, 0x1dd, 0x2, 0x15ff, 0x15fe, 0x3, 0x2, 0x2, 0x2, 0x15ff, 0x1600, 
       0x3, 0x2, 0x2, 0x2, 0x1600, 0x160b, 0x3, 0x2, 0x2, 0x2, 0x1601, 0x1603, 
       0x7, 0x61, 0x2, 0x2, 0x1602, 0x1604, 0x5, 0x3b8, 0x1dd, 0x2, 0x1603, 
       0x1602, 0x3, 0x2, 0x2, 0x2, 0x1603, 0x1604, 0x3, 0x2, 0x2, 0x2, 0x1604, 
       0x160b, 0x3, 0x2, 0x2, 0x2, 0x1605, 0x1607, 0x7, 0x112, 0x2, 0x2, 
       0x1606, 0x1608, 0x5, 0x3b8, 0x1dd, 0x2, 0x1607, 0x1606, 0x3, 0x2, 
       0x2, 0x2, 0x1607, 0x1608, 0x3, 0x2, 0x2, 0x2, 0x1608, 0x160b, 0x3, 
       0x2, 0x2, 0x2, 0x1609, 0x160b, 0x7, 0x23, 0x2, 0x2, 0x160a, 0x15f2, 
       0x3, 0x2, 0x2, 0x2, 0x160a, 0x15f3, 0x3, 0x2, 0x2, 0x2, 0x160a, 0x15f4, 
       0x3, 0x2, 0x2, 0x2, 0x160a, 0x15f5, 0x3, 0x2, 0x2, 0x2, 0x160a, 0x15f6, 
       0x3, 0x2, 0x2, 0x2, 0x160a, 0x15f7, 0x3, 0x2, 0x2, 0x2, 0x160a, 0x15fb, 
       0x3, 0x2, 0x2, 0x2, 0x160a, 0x15fd, 0x3, 0x2, 0x2, 0x2, 0x160a, 0x1601, 
       0x3, 0x2, 0x2, 0x2, 0x160a, 0x1605, 0x3, 0x2, 0x2, 0x2, 0x160a, 0x1609, 
       0x3, 0x2, 0x2, 0x2, 0x160b, 0x345, 0x3, 0x2, 0x2, 0x2, 0x160c, 0x160f, 
       0x5, 0x34a, 0x1a6, 0x2, 0x160d, 0x160f, 0x5, 0x34c, 0x1a7, 0x2, 0x160e, 
       0x160c, 0x3, 0x2, 0x2, 0x2, 0x160e, 0x160d, 0x3, 0x2, 0x2, 0x2, 0x160f, 
       0x347, 0x3, 0x2, 0x2, 0x2, 0x1610, 0x1613, 0x5, 0x34a, 0x1a6, 0x2, 
       0x1611, 0x1613, 0x5, 0x34c, 0x1a7, 0x2, 0x1612, 0x1610, 0x3, 0x2, 
       0x2, 0x2, 0x1612, 0x1611, 0x3, 0x2, 0x2, 0x2, 0x1613, 0x349, 0x3, 
       0x2, 0x2, 0x2, 0x1614, 0x1616, 0x7, 0x22, 0x2, 0x2, 0x1615, 0x1617, 
       0x7, 0x1ba, 0x2, 0x2, 0x1616, 0x1615, 0x3, 0x2, 0x2, 0x2, 0x1616, 
       0x1617, 0x3, 0x2, 0x2, 0x2, 0x1617, 0x1618, 0x3, 0x2, 0x2, 0x2, 0x1618, 
       0x1619, 0x5, 0x3b8, 0x1dd, 0x2, 0x1619, 0x34b, 0x3, 0x2, 0x2, 0x2, 
       0x161a, 0x161c, 0x7, 0x22, 0x2, 0x2, 0x161b, 0x161d, 0x7, 0x1ba, 
       0x2, 0x2, 0x161c, 0x161b, 0x3, 0x2, 0x2, 0x2, 0x161c, 0x161d, 0x3, 
       0x2, 0x2, 0x2, 0x161d, 0x34d, 0x3, 0x2, 0x2, 0x2, 0x161e, 0x1621, 
       0x5, 0x352, 0x1aa, 0x2, 0x161f, 0x1621, 0x5, 0x354, 0x1ab, 0x2, 0x1620, 
       0x161e, 0x3, 0x2, 0x2, 0x2, 0x1620, 0x161f, 0x3, 0x2, 0x2, 0x2, 0x1621, 
       0x34f, 0x3, 0x2, 0x2, 0x2, 0x1622, 0x1625, 0x5, 0x352, 0x1aa, 0x2, 
       0x1623, 0x1625, 0x5, 0x354, 0x1ab, 0x2, 0x1624, 0x1622, 0x3, 0x2, 
       0x2, 0x2, 0x1624, 0x1623, 0x3, 0x2, 0x2, 0x2, 0x1625, 0x351, 0x3, 
       0x2, 0x2, 0x2, 0x1626, 0x1627, 0x5, 0x356, 0x1ac, 0x2, 0x1627, 0x1629, 
       0x5, 0x5e, 0x30, 0x2, 0x1628, 0x162a, 0x5, 0x358, 0x1ad, 0x2, 0x1629, 
       0x1628, 0x3, 0x2, 0x2, 0x2, 0x1629, 0x162a, 0x3, 0x2, 0x2, 0x2, 0x162a, 
       0x353, 0x3, 0x2, 0x2, 0x2, 0x162b, 0x162d, 0x5, 0x356, 0x1ac, 0x2, 
       0x162c, 0x162e, 0x5, 0x358, 0x1ad, 0x2, 0x162d, 0x162c, 0x3, 0x2, 
       0x2, 0x2, 0x162d, 0x162e, 0x3, 0x2, 0x2, 0x2, 0x162e, 0x355, 0x3, 
       0x2, 0x2, 0x2, 0x162f, 0x1631, 0x9, 0x45, 0x2, 0x2, 0x1630, 0x1632, 
       0x7, 0x1ba, 0x2, 0x2, 0x1631, 0x1630, 0x3, 0x2, 0x2, 0x2, 0x1631, 
       0x1632, 0x3, 0x2, 0x2, 0x2, 0x1632, 0x163a, 0x3, 0x2, 0x2, 0x2, 0x1633, 
       0x163a, 0x7, 0x1b8, 0x2, 0x2, 0x1634, 0x1635, 0x7, 0xf9, 0x2, 0x2, 
       0x1635, 0x1637, 0x9, 0x46, 0x2, 0x2, 0x1636, 0x1638, 0x7, 0x1ba, 
       0x2, 0x2, 0x1637, 0x1636, 0x3, 0x2, 0x2, 0x2, 0x1637, 0x1638, 0x3, 
       0x2, 0x2, 0x2, 0x1638, 0x163a, 0x3, 0x2, 0x2, 0x2, 0x1639, 0x162f, 
       0x3, 0x2, 0x2, 0x2, 0x1639, 0x1633, 0x3, 0x2, 0x2, 0x2, 0x1639, 0x1634, 
       0x3, 0x2, 0x2, 0x2, 0x163a, 0x357, 0x3, 0x2, 0x2, 0x2, 0x163b, 0x163c, 
       0x7, 0x2d, 0x2, 0x2, 0x163c, 0x163d, 0x7, 0x174, 0x2, 0x2, 0x163d, 
       0x163e, 0x5, 0x41a, 0x20e, 0x2, 0x163e, 0x359, 0x3, 0x2, 0x2, 0x2, 
       0x163f, 0x1641, 0x9, 0x47, 0x2, 0x2, 0x1640, 0x1642, 0x5, 0x5e, 0x30, 
       0x2, 0x1641, 0x1640, 0x3, 0x2, 0x2, 0x2, 0x1641, 0x1642, 0x3, 0x2, 
       0x2, 0x2, 0x1642, 0x1644, 0x3, 0x2, 0x2, 0x2, 0x1643, 0x1645, 0x5, 
       0x35e, 0x1b0, 0x2, 0x1644, 0x1643, 0x3, 0x2, 0x2, 0x2, 0x1644, 0x1645, 
       0x3, 0x2, 0x2, 0x2, 0x1645, 0x35b, 0x3, 0x2, 0x2, 0x2, 0x1646, 0x1647, 
       0x7, 0xc9, 0x2, 0x2, 0x1647, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x1648, 0x1649, 
       0x9, 0x2, 0x2, 0x2, 0x1649, 0x164a, 0x7, 0x199, 0x2, 0x2, 0x164a, 
       0x164b, 0x7, 0x1d6, 0x2, 0x2, 0x164b, 0x35f, 0x3, 0x2, 0x2, 0x2, 
       0x164c, 0x1668, 0x7, 0x1d4, 0x2, 0x2, 0x164d, 0x1668, 0x7, 0xf4, 
       0x2, 0x2, 0x164e, 0x1668, 0x7, 0x5f, 0x2, 0x2, 0x164f, 0x1668, 0x7, 
       0xaf, 0x2, 0x2, 0x1650, 0x1668, 0x7, 0xee, 0x2, 0x2, 0x1651, 0x1668, 
       0x7, 0x16c, 0x2, 0x2, 0x1652, 0x1653, 0x7, 0x1d4, 0x2, 0x2, 0x1653, 
       0x1654, 0x7, 0x19b, 0x2, 0x2, 0x1654, 0x1668, 0x7, 0xf4, 0x2, 0x2, 
       0x1655, 0x1656, 0x7, 0x5f, 0x2, 0x2, 0x1656, 0x1657, 0x7, 0x19b, 
       0x2, 0x2, 0x1657, 0x1668, 0x7, 0xaf, 0x2, 0x2, 0x1658, 0x1659, 0x7, 
       0x5f, 0x2, 0x2, 0x1659, 0x165a, 0x7, 0x19b, 0x2, 0x2, 0x165a, 0x1668, 
       0x7, 0xee, 0x2, 0x2, 0x165b, 0x165c, 0x7, 0x5f, 0x2, 0x2, 0x165c, 
       0x165d, 0x7, 0x19b, 0x2, 0x2, 0x165d, 0x1668, 0x7, 0x16c, 0x2, 0x2, 
       0x165e, 0x165f, 0x7, 0xaf, 0x2, 0x2, 0x165f, 0x1660, 0x7, 0x19b, 
       0x2, 0x2, 0x1660, 0x1668, 0x7, 0xee, 0x2, 0x2, 0x1661, 0x1662, 0x7, 
       0xaf, 0x2, 0x2, 0x1662, 0x1663, 0x7, 0x19b, 0x2, 0x2, 0x1663, 0x1668, 
       0x7, 0x16c, 0x2, 0x2, 0x1664, 0x1665, 0x7, 0xee, 0x2, 0x2, 0x1665, 
       0x1666, 0x7, 0x19b, 0x2, 0x2, 0x1666, 0x1668, 0x7, 0x16c, 0x2, 0x2, 
       0x1667, 0x164c, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x164d, 0x3, 0x2, 0x2, 
       0x2, 0x1667, 0x164e, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x164f, 0x3, 0x2, 
       0x2, 0x2, 0x1667, 0x1650, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x1651, 0x3, 
       0x2, 0x2, 0x2, 0x1667, 0x1652, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x1655, 
       0x3, 0x2, 0x2, 0x2, 0x1667, 0x1658, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x165b, 
       0x3, 0x2, 0x2, 0x2, 0x1667, 0x165e, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x1661, 
       0x3, 0x2, 0x2, 0x2, 0x1667, 0x1664, 0x3, 0x2, 0x2, 0x2, 0x1668, 0x361, 
       0x3, 0x2, 0x2, 0x2, 0x1669, 0x166a, 0x5, 0x364, 0x1b3, 0x2, 0x166a, 
       0x363, 0x3, 0x2, 0x2, 0x2, 0x166b, 0x166c, 0x8, 0x1b3, 0x1, 0x2, 
       0x166c, 0x1680, 0x5, 0x366, 0x1b4, 0x2, 0x166d, 0x166f, 0x7, 0xcd, 
       0x2, 0x2, 0x166e, 0x1670, 0x7, 0x108, 0x2, 0x2, 0x166f, 0x166e, 0x3, 
       0x2, 0x2, 0x2, 0x166f, 0x1670, 0x3, 0x2, 0x2, 0x2, 0x1670, 0x167e, 
       0x3, 0x2, 0x2, 0x2, 0x1671, 0x167f, 0x7, 0x10e, 0x2, 0x2, 0x1672, 
       0x1673, 0x7, 0x72, 0x2, 0x2, 0x1673, 0x1674, 0x7, 0x9f, 0x2, 0x2, 
       0x1674, 0x167f, 0x5, 0x364, 0x1b3, 0x2, 0x1675, 0x1676, 0x7, 0x114, 
       0x2, 0x2, 0x1676, 0x1677, 0x7, 0x1d9, 0x2, 0x2, 0x1677, 0x1678, 0x5, 
       0x3bc, 0x1df, 0x2, 0x1678, 0x1679, 0x7, 0x1da, 0x2, 0x2, 0x1679, 
       0x167f, 0x3, 0x2, 0x2, 0x2, 0x167a, 0x167f, 0x7, 0x75, 0x2, 0x2, 
       0x167b, 0x167f, 0x7, 0x1a1, 0x2, 0x2, 0x167c, 0x167f, 0x7, 0x8f, 
       0x2, 0x2, 0x167d, 0x167f, 0x7, 0x1ab, 0x2, 0x2, 0x167e, 0x1671, 0x3, 
       0x2, 0x2, 0x2, 0x167e, 0x1672, 0x3, 0x2, 0x2, 0x2, 0x167e, 0x1675, 
       0x3, 0x2, 0x2, 0x2, 0x167e, 0x167a, 0x3, 0x2, 0x2, 0x2, 0x167e, 0x167b, 
       0x3, 0x2, 0x2, 0x2, 0x167e, 0x167c, 0x3, 0x2, 0x2, 0x2, 0x167e, 0x167d, 
       0x3, 0x2, 0x2, 0x2, 0x167f, 0x1681, 0x3, 0x2, 0x2, 0x2, 0x1680, 0x166d, 
       0x3, 0x2, 0x2, 0x2, 0x1680, 0x1681, 0x3, 0x2, 0x2, 0x2, 0x1681, 0x1688, 
       0x3, 0x2, 0x2, 0x2, 0x1682, 0x1683, 0x5, 0x366, 0x1b4, 0x2, 0x1683, 
       0x1684, 0x9, 0x48, 0x2, 0x2, 0x1684, 0x1688, 0x3, 0x2, 0x2, 0x2, 
       0x1685, 0x1686, 0x7, 0x108, 0x2, 0x2, 0x1686, 0x1688, 0x5, 0x364, 
       0x1b3, 0x5, 0x1687, 0x166b, 0x3, 0x2, 0x2, 0x2, 0x1687, 0x1682, 0x3, 
       0x2, 0x2, 0x2, 0x1687, 0x1685, 0x3, 0x2, 0x2, 0x2, 0x1688, 0x1691, 
       0x3, 0x2, 0x2, 0x2, 0x1689, 0x168a, 0xc, 0x4, 0x2, 0x2, 0x168a, 0x168b, 
       0x7, 0x12, 0x2, 0x2, 0x168b, 0x1690, 0x5, 0x364, 0x1b3, 0x5, 0x168c, 
       0x168d, 0xc, 0x3, 0x2, 0x2, 0x168d, 0x168e, 0x7, 0x11e, 0x2, 0x2, 
       0x168e, 0x1690, 0x5, 0x364, 0x1b3, 0x4, 0x168f, 0x1689, 0x3, 0x2, 
       0x2, 0x2, 0x168f, 0x168c, 0x3, 0x2, 0x2, 0x2, 0x1690, 0x1693, 0x3, 
       0x2, 0x2, 0x2, 0x1691, 0x168f, 0x3, 0x2, 0x2, 0x2, 0x1691, 0x1692, 
       0x3, 0x2, 0x2, 0x2, 0x1692, 0x365, 0x3, 0x2, 0x2, 0x2, 0x1693, 0x1691, 
       0x3, 0x2, 0x2, 0x2, 0x1694, 0x1695, 0x5, 0x368, 0x1b5, 0x2, 0x1695, 
       0x367, 0x3, 0x2, 0x2, 0x2, 0x1696, 0x1697, 0x8, 0x1b5, 0x1, 0x2, 
       0x1697, 0x1698, 0x5, 0x36c, 0x1b7, 0x2, 0x1698, 0x169f, 0x3, 0x2, 
       0x2, 0x2, 0x1699, 0x169a, 0xc, 0x4, 0x2, 0x2, 0x169a, 0x169b, 0x5, 
       0x36a, 0x1b6, 0x2, 0x169b, 0x169c, 0x5, 0x368, 0x1b5, 0x5, 0x169c, 
       0x169e, 0x3, 0x2, 0x2, 0x2, 0x169d, 0x1699, 0x3, 0x2, 0x2, 0x2, 0x169e, 
       0x16a1, 0x3, 0x2, 0x2, 0x2, 0x169f, 0x169d, 0x3, 0x2, 0x2, 0x2, 0x169f, 
       0x16a0, 0x3, 0x2, 0x2, 0x2, 0x16a0, 0x369, 0x3, 0x2, 0x2, 0x2, 0x16a1, 
       0x169f, 0x3, 0x2, 0x2, 0x2, 0x16a2, 0x16a4, 0x9, 0x49, 0x2, 0x2, 
       0x16a3, 0x16a5, 0x7, 0x1f1, 0x2, 0x2, 0x16a4, 0x16a3, 0x3, 0x2, 0x2, 
       0x2, 0x16a4, 0x16a5, 0x3, 0x2, 0x2, 0x2, 0x16a5, 0x16a9, 0x3, 0x2, 
       0x2, 0x2, 0x16a6, 0x16a9, 0x7, 0x1f1, 0x2, 0x2, 0x16a7, 0x16a9, 0x7, 
       0x1e6, 0x2, 0x2, 0x16a8, 0x16a2, 0x3, 0x2, 0x2, 0x2, 0x16a8, 0x16a6, 
       0x3, 0x2, 0x2, 0x2, 0x16a8, 0x16a7, 0x3, 0x2, 0x2, 0x2, 0x16a9, 0x36b, 
       0x3, 0x2, 0x2, 0x2, 0x16aa, 0x16c5, 0x5, 0x372, 0x1ba, 0x2, 0x16ab, 
       0x16ad, 0x7, 0x108, 0x2, 0x2, 0x16ac, 0x16ab, 0x3, 0x2, 0x2, 0x2, 
       0x16ac, 0x16ad, 0x3, 0x2, 0x2, 0x2, 0x16ad, 0x16c3, 0x3, 0x2, 0x2, 
       0x2, 0x16ae, 0x16af, 0x7, 0xc2, 0x2, 0x2, 0x16af, 0x16c4, 0x5, 0x3d4, 
       0x1eb, 0x2, 0x16b0, 0x16b5, 0x7, 0x1f, 0x2, 0x2, 0x16b1, 0x16b3, 
       0x7, 0x19, 0x2, 0x2, 0x16b2, 0x16b1, 0x3, 0x2, 0x2, 0x2, 0x16b2, 
       0x16b3, 0x3, 0x2, 0x2, 0x2, 0x16b3, 0x16b6, 0x3, 0x2, 0x2, 0x2, 0x16b4, 
       0x16b6, 0x7, 0x18d, 0x2, 0x2, 0x16b5, 0x16b2, 0x3, 0x2, 0x2, 0x2, 
       0x16b5, 0x16b4, 0x3, 0x2, 0x2, 0x2, 0x16b6, 0x16b7, 0x3, 0x2, 0x2, 
       0x2, 0x16b7, 0x16c4, 0x5, 0x36e, 0x1b8, 0x2, 0x16b8, 0x16bd, 0x7, 
       0xd9, 0x2, 0x2, 0x16b9, 0x16bd, 0x7, 0xb3, 0x2, 0x2, 0x16ba, 0x16bb, 
       0x7, 0x179, 0x2, 0x2, 0x16bb, 0x16bd, 0x7, 0x19b, 0x2, 0x2, 0x16bc, 
       0x16b8, 0x3, 0x2, 0x2, 0x2, 0x16bc, 0x16b9, 0x3, 0x2, 0x2, 0x2, 0x16bc, 
       0x16ba, 0x3, 0x2, 0x2, 0x2, 0x16bd, 0x16be, 0x3, 0x2, 0x2, 0x2, 0x16be, 
       0x16c1, 0x5, 0x372, 0x1ba, 0x2, 0x16bf, 0x16c0, 0x7, 0x82, 0x2, 0x2, 
       0x16c0, 0x16c2, 0x5, 0x362, 0x1b2, 0x2, 0x16c1, 0x16bf, 0x3, 0x2, 
       0x2, 0x2, 0x16c1, 0x16c2, 0x3, 0x2, 0x2, 0x2, 0x16c2, 0x16c4, 0x3, 
       0x2, 0x2, 0x2, 0x16c3, 0x16ae, 0x3, 0x2, 0x2, 0x2, 0x16c3, 0x16b0, 
       0x3, 0x2, 0x2, 0x2, 0x16c3, 0x16bc, 0x3, 0x2, 0x2, 0x2, 0x16c4, 0x16c6, 
       0x3, 0x2, 0x2, 0x2, 0x16c5, 0x16ac, 0x3, 0x2, 0x2, 0x2, 0x16c5, 0x16c6, 
       0x3, 0x2, 0x2, 0x2, 0x16c6, 0x16cc, 0x3, 0x2, 0x2, 0x2, 0x16c7, 0x16c8, 
       0x5, 0x370, 0x1b9, 0x2, 0x16c8, 0x16c9, 0x7, 0x126, 0x2, 0x2, 0x16c9, 
       0x16ca, 0x5, 0x370, 0x1b9, 0x2, 0x16ca, 0x16cc, 0x3, 0x2, 0x2, 0x2, 
       0x16cb, 0x16aa, 0x3, 0x2, 0x2, 0x2, 0x16cb, 0x16c7, 0x3, 0x2, 0x2, 
       0x2, 0x16cc, 0x36d, 0x3, 0x2, 0x2, 0x2, 0x16cd, 0x16ce, 0x5, 0x372, 
       0x1ba, 0x2, 0x16ce, 0x16cf, 0x7, 0x12, 0x2, 0x2, 0x16cf, 0x16d0, 
       0x5, 0x372, 0x1ba, 0x2, 0x16d0, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x16d1, 
       0x16d2, 0x7, 0x1d9, 0x2, 0x2, 0x16d2, 0x16d7, 0x5, 0x372, 0x1ba, 
       0x2, 0x16d3, 0x16d4, 0x7, 0x1df, 0x2, 0x2, 0x16d4, 0x16d6, 0x5, 0x372, 
       0x1ba, 0x2, 0x16d5, 0x16d3, 0x3, 0x2, 0x2, 0x2, 0x16d6, 0x16d9, 0x3, 
       0x2, 0x2, 0x2, 0x16d7, 0x16d5, 0x3, 0x2, 0x2, 0x2, 0x16d7, 0x16d8, 
       0x3, 0x2, 0x2, 0x2, 0x16d8, 0x16da, 0x3, 0x2, 0x2, 0x2, 0x16d9, 0x16d7, 
       0x3, 0x2, 0x2, 0x2, 0x16da, 0x16db, 0x7, 0x1da, 0x2, 0x2, 0x16db, 
       0x371, 0x3, 0x2, 0x2, 0x2, 0x16dc, 0x16dd, 0x8, 0x1ba, 0x1, 0x2, 
       0x16dd, 0x16e2, 0x5, 0x374, 0x1bb, 0x2, 0x16de, 0x16df, 0x7, 0x1a, 
       0x2, 0x2, 0x16df, 0x16e0, 0x7, 0x199, 0x2, 0x2, 0x16e0, 0x16e1, 0x7, 
       0x1d6, 0x2, 0x2, 0x16e1, 0x16e3, 0x5, 0x372, 0x1ba, 0x2, 0x16e2, 
       0x16de, 0x3, 0x2, 0x2, 0x2, 0x16e2, 0x16e3, 0x3, 0x2, 0x2, 0x2, 0x16e3, 
       0x16f3, 0x3, 0x2, 0x2, 0x2, 0x16e4, 0x16e5, 0xc, 0x6, 0x2, 0x2, 0x16e5, 
       0x16e6, 0x7, 0x1e7, 0x2, 0x2, 0x16e6, 0x16f2, 0x5, 0x372, 0x1ba, 
       0x7, 0x16e7, 0x16e8, 0xc, 0x5, 0x2, 0x2, 0x16e8, 0x16e9, 0x9, 0x4a, 
       0x2, 0x2, 0x16e9, 0x16f2, 0x5, 0x372, 0x1ba, 0x6, 0x16ea, 0x16eb, 
       0xc, 0x4, 0x2, 0x2, 0x16eb, 0x16ec, 0x9, 0x4b, 0x2, 0x2, 0x16ec, 
       0x16f2, 0x5, 0x372, 0x1ba, 0x5, 0x16ed, 0x16ee, 0xc, 0x3, 0x2, 0x2, 
       0x16ee, 0x16ef, 0x7, 0x1f0, 0x2, 0x2, 0x16ef, 0x16f0, 0x7, 0x1f0, 
       0x2, 0x2, 0x16f0, 0x16f2, 0x5, 0x372, 0x1ba, 0x4, 0x16f1, 0x16e4, 
       0x3, 0x2, 0x2, 0x2, 0x16f1, 0x16e7, 0x3, 0x2, 0x2, 0x2, 0x16f1, 0x16ea, 
       0x3, 0x2, 0x2, 0x2, 0x16f1, 0x16ed, 0x3, 0x2, 0x2, 0x2, 0x16f2, 0x16f5, 
       0x3, 0x2, 0x2, 0x2, 0x16f3, 0x16f1, 0x3, 0x2, 0x2, 0x2, 0x16f3, 0x16f4, 
       0x3, 0x2, 0x2, 0x2, 0x16f4, 0x373, 0x3, 0x2, 0x2, 0x2, 0x16f5, 0x16f3, 
       0x3, 0x2, 0x2, 0x2, 0x16f6, 0x16f7, 0x5, 0x376, 0x1bc, 0x2, 0x16f7, 
       0x375, 0x3, 0x2, 0x2, 0x2, 0x16f8, 0x16f9, 0x8, 0x1bc, 0x1, 0x2, 
       0x16f9, 0x16fd, 0x5, 0x378, 0x1bd, 0x2, 0x16fa, 0x16fb, 0x9, 0x4b, 
       0x2, 0x2, 0x16fb, 0x16fd, 0x5, 0x376, 0x1bc, 0x3, 0x16fc, 0x16f8, 
       0x3, 0x2, 0x2, 0x2, 0x16fc, 0x16fa, 0x3, 0x2, 0x2, 0x2, 0x16fd, 0x1703, 
       0x3, 0x2, 0x2, 0x2, 0x16fe, 0x16ff, 0xc, 0x4, 0x2, 0x2, 0x16ff, 0x1700, 
       0x7, 0x1ef, 0x2, 0x2, 0x1700, 0x1702, 0x5, 0x33a, 0x19e, 0x2, 0x1701, 
       0x16fe, 0x3, 0x2, 0x2, 0x2, 0x1702, 0x1705, 0x3, 0x2, 0x2, 0x2, 0x1703, 
       0x1701, 0x3, 0x2, 0x2, 0x2, 0x1703, 0x1704, 0x3, 0x2, 0x2, 0x2, 0x1704, 
       0x377, 0x3, 0x2, 0x2, 0x2, 0x1705, 0x1703, 0x3, 0x2, 0x2, 0x2, 0x1706, 
       0x1707, 0x7, 0x1d9, 0x2, 0x2, 0x1707, 0x1708, 0x5, 0x362, 0x1b2, 
       0x2, 0x1708, 0x170a, 0x7, 0x1da, 0x2, 0x2, 0x1709, 0x170b, 0x5, 0x3ea, 
       0x1f6, 0x2, 0x170a, 0x1709, 0x3, 0x2, 0x2, 0x2, 0x170a, 0x170b, 0x3, 
       0x2, 0x2, 0x2, 0x170b, 0x172b, 0x3, 0x2, 0x2, 0x2, 0x170c, 0x170e, 
       0x7, 0x1aa, 0x2, 0x2, 0x170d, 0x170c, 0x3, 0x2, 0x2, 0x2, 0x170d, 
       0x170e, 0x3, 0x2, 0x2, 0x2, 0x170e, 0x170f, 0x3, 0x2, 0x2, 0x2, 0x170f, 
       0x1711, 0x5, 0x2ec, 0x177, 0x2, 0x1710, 0x1712, 0x5, 0x3ea, 0x1f6, 
       0x2, 0x1711, 0x1710, 0x3, 0x2, 0x2, 0x2, 0x1711, 0x1712, 0x3, 0x2, 
       0x2, 0x2, 0x1712, 0x172b, 0x3, 0x2, 0x2, 0x2, 0x1713, 0x1714, 0x7, 
       0x8a, 0x2, 0x2, 0x1714, 0x172b, 0x5, 0x2e6, 0x174, 0x2, 0x1715, 0x172b, 
       0x5, 0x3e6, 0x1f4, 0x2, 0x1716, 0x1719, 0x5, 0x382, 0x1c2, 0x2, 0x1717, 
       0x1718, 0x7, 0x124, 0x2, 0x2, 0x1718, 0x171a, 0x5, 0x39a, 0x1ce, 
       0x2, 0x1719, 0x1717, 0x3, 0x2, 0x2, 0x2, 0x1719, 0x171a, 0x3, 0x2, 
       0x2, 0x2, 0x171a, 0x172b, 0x3, 0x2, 0x2, 0x2, 0x171b, 0x172b, 0x5, 
       0x40e, 0x208, 0x2, 0x171c, 0x171e, 0x7, 0x1ff, 0x2, 0x2, 0x171d, 
       0x171f, 0x5, 0x3ea, 0x1f6, 0x2, 0x171e, 0x171d, 0x3, 0x2, 0x2, 0x2, 
       0x171e, 0x171f, 0x3, 0x2, 0x2, 0x2, 0x171f, 0x172b, 0x3, 0x2, 0x2, 
       0x2, 0x1720, 0x172b, 0x5, 0x3d6, 0x1ec, 0x2, 0x1721, 0x172b, 0x5, 
       0x3e0, 0x1f1, 0x2, 0x1722, 0x1723, 0x7, 0x14, 0x2, 0x2, 0x1723, 0x172b, 
       0x5, 0x3be, 0x1e0, 0x2, 0x1724, 0x1725, 0x7, 0x190, 0x2, 0x2, 0x1725, 
       0x1726, 0x7, 0x1d9, 0x2, 0x2, 0x1726, 0x1727, 0x5, 0x37c, 0x1bf, 
       0x2, 0x1727, 0x1728, 0x7, 0x1da, 0x2, 0x2, 0x1728, 0x172b, 0x3, 0x2, 
       0x2, 0x2, 0x1729, 0x172b, 0x5, 0x3ac, 0x1d7, 0x2, 0x172a, 0x1706, 
       0x3, 0x2, 0x2, 0x2, 0x172a, 0x170d, 0x3, 0x2, 0x2, 0x2, 0x172a, 0x1713, 
       0x3, 0x2, 0x2, 0x2, 0x172a, 0x1715, 0x3, 0x2, 0x2, 0x2, 0x172a, 0x1716, 
       0x3, 0x2, 0x2, 0x2, 0x172a, 0x171b, 0x3, 0x2, 0x2, 0x2, 0x172a, 0x171c, 
       0x3, 0x2, 0x2, 0x2, 0x172a, 0x1720, 0x3, 0x2, 0x2, 0x2, 0x172a, 0x1721, 
       0x3, 0x2, 0x2, 0x2, 0x172a, 0x1722, 0x3, 0x2, 0x2, 0x2, 0x172a, 0x1724, 
       0x3, 0x2, 0x2, 0x2, 0x172a, 0x1729, 0x3, 0x2, 0x2, 0x2, 0x172b, 0x379, 
       0x3, 0x2, 0x2, 0x2, 0x172c, 0x1730, 0x7, 0x168, 0x2, 0x2, 0x172d, 
       0x1731, 0x7, 0x145, 0x2, 0x2, 0x172e, 0x172f, 0x7, 0x25, 0x2, 0x2, 
       0x172f, 0x1731, 0x5, 0x3ba, 0x1de, 0x2, 0x1730, 0x172d, 0x3, 0x2, 
       0x2, 0x2, 0x1730, 0x172e, 0x3, 0x2, 0x2, 0x2, 0x1731, 0x37b, 0x3, 
       0x2, 0x2, 0x2, 0x1732, 0x1734, 0x5, 0x2e6, 0x174, 0x2, 0x1733, 0x1735, 
       0x5, 0x37a, 0x1be, 0x2, 0x1734, 0x1733, 0x3, 0x2, 0x2, 0x2, 0x1734, 
       0x1735, 0x3, 0x2, 0x2, 0x2, 0x1735, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x1736, 
       0x1737, 0x5, 0x40c, 0x207, 0x2, 0x1737, 0x1738, 0x5, 0x380, 0x1c1, 
       0x2, 0x1738, 0x37f, 0x3, 0x2, 0x2, 0x2, 0x1739, 0x173b, 0x7, 0x1d9, 
       0x2, 0x2, 0x173a, 0x173c, 0x7, 0x1dc, 0x2, 0x2, 0x173b, 0x173a, 0x3, 
       0x2, 0x2, 0x2, 0x173b, 0x173c, 0x3, 0x2, 0x2, 0x2, 0x173c, 0x173d, 
       0x3, 0x2, 0x2, 0x2, 0x173d, 0x1756, 0x7, 0x1da, 0x2, 0x2, 0x173e, 
       0x1756, 0x5, 0x3b8, 0x1dd, 0x2, 0x173f, 0x1740, 0x7, 0x1d9, 0x2, 
       0x2, 0x1740, 0x1741, 0x7, 0x1b9, 0x2, 0x2, 0x1741, 0x1742, 0x5, 0x362, 
       0x1b2, 0x2, 0x1742, 0x1743, 0x7, 0x1da, 0x2, 0x2, 0x1743, 0x1756, 
       0x3, 0x2, 0x2, 0x2, 0x1744, 0x1745, 0x7, 0x1d9, 0x2, 0x2, 0x1745, 
       0x1746, 0x5, 0x3ba, 0x1de, 0x2, 0x1746, 0x1747, 0x7, 0x1df, 0x2, 
       0x2, 0x1747, 0x1748, 0x7, 0x1b9, 0x2, 0x2, 0x1748, 0x1749, 0x5, 0x362, 
       0x1b2, 0x2, 0x1749, 0x174a, 0x7, 0x1da, 0x2, 0x2, 0x174a, 0x1756, 
       0x3, 0x2, 0x2, 0x2, 0x174b, 0x174d, 0x7, 0x1d9, 0x2, 0x2, 0x174c, 
       0x174e, 0x5, 0x2fc, 0x17f, 0x2, 0x174d, 0x174c, 0x3, 0x2, 0x2, 0x2, 
       0x174d, 0x174e, 0x3, 0x2, 0x2, 0x2, 0x174e, 0x174f, 0x3, 0x2, 0x2, 
       0x2, 0x174f, 0x1751, 0x5, 0x3ba, 0x1de, 0x2, 0x1750, 0x1752, 0x5, 
       0x2fe, 0x180, 0x2, 0x1751, 0x1750, 0x3, 0x2, 0x2, 0x2, 0x1751, 0x1752, 
       0x3, 0x2, 0x2, 0x2, 0x1752, 0x1753, 0x3, 0x2, 0x2, 0x2, 0x1753, 0x1754, 
       0x7, 0x1da, 0x2, 0x2, 0x1754, 0x1756, 0x3, 0x2, 0x2, 0x2, 0x1755, 
       0x1739, 0x3, 0x2, 0x2, 0x2, 0x1755, 0x173e, 0x3, 0x2, 0x2, 0x2, 0x1755, 
       0x173f, 0x3, 0x2, 0x2, 0x2, 0x1755, 0x1744, 0x3, 0x2, 0x2, 0x2, 0x1755, 
       0x174b, 0x3, 0x2, 0x2, 0x2, 0x1756, 0x381, 0x3, 0x2, 0x2, 0x2, 0x1757, 
       0x1758, 0x5, 0x37e, 0x1c0, 0x2, 0x1758, 0x1759, 0x7, 0x95, 0x2, 0x2, 
       0x1759, 0x175a, 0x7, 0x1d9, 0x2, 0x2, 0x175a, 0x175b, 0x7, 0x1c1, 
       0x2, 0x2, 0x175b, 0x175c, 0x5, 0x362, 0x1b2, 0x2, 0x175c, 0x175d, 
       0x7, 0x1da, 0x2, 0x2, 0x175d, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x175e, 
       0x1839, 0x5, 0x37e, 0x1c0, 0x2, 0x175f, 0x1839, 0x7, 0x54, 0x2, 0x2, 
       0x1760, 0x1762, 0x9, 0x4c, 0x2, 0x2, 0x1761, 0x1763, 0x5, 0x5e, 0x30, 
       0x2, 0x1762, 0x1761, 0x3, 0x2, 0x2, 0x2, 0x1762, 0x1763, 0x3, 0x2, 
       0x2, 0x2, 0x1763, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x1764, 0x1839, 0x7, 
       0x56, 0x2, 0x2, 0x1765, 0x1839, 0x7, 0x5a, 0x2, 0x2, 0x1766, 0x1839, 
       0x7, 0x173, 0x2, 0x2, 0x1767, 0x1839, 0x7, 0x1b0, 0x2, 0x2, 0x1768, 
       0x1839, 0x7, 0x53, 0x2, 0x2, 0x1769, 0x1839, 0x7, 0x57, 0x2, 0x2, 
       0x176a, 0x176b, 0x7, 0x2b, 0x2, 0x2, 0x176b, 0x176c, 0x7, 0x1d9, 
       0x2, 0x2, 0x176c, 0x176d, 0x5, 0x362, 0x1b2, 0x2, 0x176d, 0x176e, 
       0x7, 0x15, 0x2, 0x2, 0x176e, 0x176f, 0x5, 0x33a, 0x19e, 0x2, 0x176f, 
       0x1770, 0x7, 0x1da, 0x2, 0x2, 0x1770, 0x1839, 0x3, 0x2, 0x2, 0x2, 
       0x1771, 0x1772, 0x7, 0x8e, 0x2, 0x2, 0x1772, 0x1774, 0x7, 0x1d9, 
       0x2, 0x2, 0x1773, 0x1775, 0x5, 0x3c2, 0x1e2, 0x2, 0x1774, 0x1773, 
       0x3, 0x2, 0x2, 0x2, 0x1774, 0x1775, 0x3, 0x2, 0x2, 0x2, 0x1775, 0x1776, 
       0x3, 0x2, 0x2, 0x2, 0x1776, 0x1839, 0x7, 0x1da, 0x2, 0x2, 0x1777, 
       0x1778, 0x7, 0x127, 0x2, 0x2, 0x1778, 0x1779, 0x7, 0x1d9, 0x2, 0x2, 
       0x1779, 0x177a, 0x5, 0x3c6, 0x1e4, 0x2, 0x177a, 0x177b, 0x7, 0x1da, 
       0x2, 0x2, 0x177b, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x177c, 0x177d, 0x7, 
       0x135, 0x2, 0x2, 0x177d, 0x177f, 0x7, 0x1d9, 0x2, 0x2, 0x177e, 0x1780, 
       0x5, 0x3ca, 0x1e6, 0x2, 0x177f, 0x177e, 0x3, 0x2, 0x2, 0x2, 0x177f, 
       0x1780, 0x3, 0x2, 0x2, 0x2, 0x1780, 0x1781, 0x3, 0x2, 0x2, 0x2, 0x1781, 
       0x1839, 0x7, 0x1da, 0x2, 0x2, 0x1782, 0x1783, 0x7, 0x18b, 0x2, 0x2, 
       0x1783, 0x1785, 0x7, 0x1d9, 0x2, 0x2, 0x1784, 0x1786, 0x5, 0x3cc, 
       0x1e7, 0x2, 0x1785, 0x1784, 0x3, 0x2, 0x2, 0x2, 0x1785, 0x1786, 0x3, 
       0x2, 0x2, 0x2, 0x1786, 0x1787, 0x3, 0x2, 0x2, 0x2, 0x1787, 0x1839, 
       0x7, 0x1da, 0x2, 0x2, 0x1788, 0x1789, 0x7, 0x19e, 0x2, 0x2, 0x1789, 
       0x178a, 0x7, 0x1d9, 0x2, 0x2, 0x178a, 0x178b, 0x5, 0x362, 0x1b2, 
       0x2, 0x178b, 0x178c, 0x7, 0x15, 0x2, 0x2, 0x178c, 0x178d, 0x5, 0x33a, 
       0x19e, 0x2, 0x178d, 0x178e, 0x7, 0x1da, 0x2, 0x2, 0x178e, 0x1839, 
       0x3, 0x2, 0x2, 0x2, 0x178f, 0x1790, 0x7, 0x1a0, 0x2, 0x2, 0x1790, 
       0x1791, 0x7, 0x1d9, 0x2, 0x2, 0x1791, 0x1792, 0x7, 0x24, 0x2, 0x2, 
       0x1792, 0x1793, 0x5, 0x3d2, 0x1ea, 0x2, 0x1793, 0x1794, 0x7, 0x1da, 
       0x2, 0x2, 0x1794, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x1795, 0x1796, 0x7, 
       0x1a0, 0x2, 0x2, 0x1796, 0x1797, 0x7, 0x1d9, 0x2, 0x2, 0x1797, 0x1798, 
       0x7, 0xd5, 0x2, 0x2, 0x1798, 0x1799, 0x5, 0x3d2, 0x1ea, 0x2, 0x1799, 
       0x179a, 0x7, 0x1da, 0x2, 0x2, 0x179a, 0x1839, 0x3, 0x2, 0x2, 0x2, 
       0x179b, 0x179c, 0x7, 0x1a0, 0x2, 0x2, 0x179c, 0x179d, 0x7, 0x1d9, 
       0x2, 0x2, 0x179d, 0x179e, 0x7, 0x19c, 0x2, 0x2, 0x179e, 0x179f, 0x5, 
       0x3d2, 0x1ea, 0x2, 0x179f, 0x17a0, 0x7, 0x1da, 0x2, 0x2, 0x17a0, 
       0x1839, 0x3, 0x2, 0x2, 0x2, 0x17a1, 0x17a2, 0x7, 0x1a0, 0x2, 0x2, 
       0x17a2, 0x17a3, 0x7, 0x1d9, 0x2, 0x2, 0x17a3, 0x17a4, 0x5, 0x3d2, 
       0x1ea, 0x2, 0x17a4, 0x17a5, 0x7, 0x1da, 0x2, 0x2, 0x17a5, 0x1839, 
       0x3, 0x2, 0x2, 0x2, 0x17a6, 0x17a7, 0x7, 0x10d, 0x2, 0x2, 0x17a7, 
       0x17a8, 0x7, 0x1d9, 0x2, 0x2, 0x17a8, 0x17a9, 0x5, 0x362, 0x1b2, 
       0x2, 0x17a9, 0x17aa, 0x7, 0x1df, 0x2, 0x2, 0x17aa, 0x17ab, 0x5, 0x362, 
       0x1b2, 0x2, 0x17ab, 0x17ac, 0x7, 0x1da, 0x2, 0x2, 0x17ac, 0x1839, 
       0x3, 0x2, 0x2, 0x2, 0x17ad, 0x17ae, 0x7, 0x35, 0x2, 0x2, 0x17ae, 
       0x1839, 0x5, 0x3b8, 0x1dd, 0x2, 0x17af, 0x17b0, 0x7, 0xa5, 0x2, 0x2, 
       0x17b0, 0x1839, 0x5, 0x3b8, 0x1dd, 0x2, 0x17b1, 0x17b2, 0x7, 0xd6, 
       0x2, 0x2, 0x17b2, 0x1839, 0x5, 0x3b8, 0x1dd, 0x2, 0x17b3, 0x17b4, 
       0x7, 0xa7, 0x2, 0x2, 0x17b4, 0x1839, 0x5, 0x3b8, 0x1dd, 0x2, 0x17b5, 
       0x17b6, 0x7, 0xa6, 0x2, 0x2, 0x17b6, 0x1839, 0x5, 0x132, 0x9a, 0x2, 
       0x17b7, 0x17b8, 0x7, 0xe9, 0x2, 0x2, 0x17b8, 0x17b9, 0x7, 0x1d9, 
       0x2, 0x2, 0x17b9, 0x17ba, 0x5, 0x362, 0x1b2, 0x2, 0x17ba, 0x17bb, 
       0x7, 0x1da, 0x2, 0x2, 0x17bb, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x17bc, 
       0x17bd, 0x7, 0x131, 0x2, 0x2, 0x17bd, 0x17be, 0x7, 0x1d9, 0x2, 0x2, 
       0x17be, 0x17bf, 0x5, 0x362, 0x1b2, 0x2, 0x17bf, 0x17c0, 0x7, 0x1da, 
       0x2, 0x2, 0x17c0, 0x17c1, 0x7, 0x1c5, 0x2, 0x2, 0x17c1, 0x17c2, 0x7, 
       0xa8, 0x2, 0x2, 0x17c2, 0x17c3, 0x7, 0x1d9, 0x2, 0x2, 0x17c3, 0x17c4, 
       0x7, 0x11f, 0x2, 0x2, 0x17c4, 0x17c5, 0x7, 0x25, 0x2, 0x2, 0x17c5, 
       0x17c6, 0x5, 0x300, 0x181, 0x2, 0x17c6, 0x17c7, 0x7, 0x1da, 0x2, 
       0x2, 0x17c7, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x17c8, 0x17c9, 0x7, 0x132, 
       0x2, 0x2, 0x17c9, 0x17ca, 0x7, 0x1d9, 0x2, 0x2, 0x17ca, 0x17cb, 0x5, 
       0x362, 0x1b2, 0x2, 0x17cb, 0x17cc, 0x7, 0x1da, 0x2, 0x2, 0x17cc, 
       0x17cd, 0x7, 0x1c5, 0x2, 0x2, 0x17cd, 0x17ce, 0x7, 0xa8, 0x2, 0x2, 
       0x17ce, 0x17cf, 0x7, 0x1d9, 0x2, 0x2, 0x17cf, 0x17d0, 0x7, 0x11f, 
       0x2, 0x2, 0x17d0, 0x17d1, 0x7, 0x25, 0x2, 0x2, 0x17d1, 0x17d2, 0x5, 
       0x300, 0x181, 0x2, 0x17d2, 0x17d3, 0x7, 0x1da, 0x2, 0x2, 0x17d3, 
       0x1839, 0x3, 0x2, 0x2, 0x2, 0x17d4, 0x17d5, 0x7, 0x64, 0x2, 0x2, 
       0x17d5, 0x17d6, 0x7, 0x1d9, 0x2, 0x2, 0x17d6, 0x17d7, 0x5, 0x362, 
       0x1b2, 0x2, 0x17d7, 0x17d8, 0x7, 0x1df, 0x2, 0x2, 0x17d8, 0x17d9, 
       0x5, 0x362, 0x1b2, 0x2, 0x17d9, 0x17da, 0x7, 0x1da, 0x2, 0x2, 0x17da, 
       0x1839, 0x3, 0x2, 0x2, 0x2, 0x17db, 0x17dc, 0x7, 0x1cb, 0x2, 0x2, 
       0x17dc, 0x1839, 0x5, 0x3b8, 0x1dd, 0x2, 0x17dd, 0x17de, 0x7, 0x1cc, 
       0x2, 0x2, 0x17de, 0x17df, 0x7, 0x1d9, 0x2, 0x2, 0x17df, 0x17e0, 0x7, 
       0xf7, 0x2, 0x2, 0x17e0, 0x17e1, 0x5, 0x41e, 0x210, 0x2, 0x17e1, 0x17e2, 
       0x7, 0x1da, 0x2, 0x2, 0x17e2, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x17e3, 
       0x17e4, 0x7, 0x1cc, 0x2, 0x2, 0x17e4, 0x17e5, 0x7, 0x1d9, 0x2, 0x2, 
       0x17e5, 0x17e6, 0x7, 0xf7, 0x2, 0x2, 0x17e6, 0x17e7, 0x5, 0x41e, 
       0x210, 0x2, 0x17e7, 0x17e8, 0x7, 0x1df, 0x2, 0x2, 0x17e8, 0x17e9, 
       0x5, 0x388, 0x1c5, 0x2, 0x17e9, 0x17ea, 0x7, 0x1da, 0x2, 0x2, 0x17ea, 
       0x1839, 0x3, 0x2, 0x2, 0x2, 0x17eb, 0x17ec, 0x7, 0x1cc, 0x2, 0x2, 
       0x17ec, 0x17ed, 0x7, 0x1d9, 0x2, 0x2, 0x17ed, 0x17ee, 0x7, 0xf7, 
       0x2, 0x2, 0x17ee, 0x17ef, 0x5, 0x41e, 0x210, 0x2, 0x17ef, 0x17f0, 
       0x7, 0x1df, 0x2, 0x2, 0x17f0, 0x17f1, 0x5, 0x3ba, 0x1de, 0x2, 0x17f1, 
       0x17f2, 0x7, 0x1da, 0x2, 0x2, 0x17f2, 0x1839, 0x3, 0x2, 0x2, 0x2, 
       0x17f3, 0x17f4, 0x7, 0x1cc, 0x2, 0x2, 0x17f4, 0x17f5, 0x7, 0x1d9, 
       0x2, 0x2, 0x17f5, 0x17f6, 0x7, 0xf7, 0x2, 0x2, 0x17f6, 0x17f7, 0x5, 
       0x41e, 0x210, 0x2, 0x17f7, 0x17f8, 0x7, 0x1df, 0x2, 0x2, 0x17f8, 
       0x17f9, 0x5, 0x388, 0x1c5, 0x2, 0x17f9, 0x17fa, 0x7, 0x1df, 0x2, 
       0x2, 0x17fa, 0x17fb, 0x5, 0x3ba, 0x1de, 0x2, 0x17fb, 0x17fc, 0x7, 
       0x1da, 0x2, 0x2, 0x17fc, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x17fd, 0x17fe, 
       0x7, 0x1cd, 0x2, 0x2, 0x17fe, 0x17ff, 0x7, 0x1d9, 0x2, 0x2, 0x17ff, 
       0x1800, 0x5, 0x378, 0x1bd, 0x2, 0x1800, 0x1801, 0x5, 0x392, 0x1ca, 
       0x2, 0x1801, 0x1802, 0x7, 0x1da, 0x2, 0x2, 0x1802, 0x1839, 0x3, 0x2, 
       0x2, 0x2, 0x1803, 0x1804, 0x7, 0x1cd, 0x2, 0x2, 0x1804, 0x1805, 0x7, 
       0x1d9, 0x2, 0x2, 0x1805, 0x1806, 0x5, 0x362, 0x1b2, 0x2, 0x1806, 
       0x1807, 0x7, 0x1df, 0x2, 0x2, 0x1807, 0x1808, 0x5, 0x362, 0x1b2, 
       0x2, 0x1808, 0x1809, 0x7, 0x1da, 0x2, 0x2, 0x1809, 0x1839, 0x3, 0x2, 
       0x2, 0x2, 0x180a, 0x180b, 0x7, 0x1ce, 0x2, 0x2, 0x180b, 0x180c, 0x7, 
       0x1d9, 0x2, 0x2, 0x180c, 0x180d, 0x5, 0x38a, 0x1c6, 0x2, 0x180d, 
       0x180e, 0x7, 0x1da, 0x2, 0x2, 0x180e, 0x1839, 0x3, 0x2, 0x2, 0x2, 
       0x180f, 0x1810, 0x7, 0x1d0, 0x2, 0x2, 0x1810, 0x1811, 0x7, 0x1d9, 
       0x2, 0x2, 0x1811, 0x1812, 0x5, 0x38e, 0x1c8, 0x2, 0x1812, 0x1814, 
       0x5, 0x362, 0x1b2, 0x2, 0x1813, 0x1815, 0x5, 0x390, 0x1c9, 0x2, 0x1814, 
       0x1813, 0x3, 0x2, 0x2, 0x2, 0x1814, 0x1815, 0x3, 0x2, 0x2, 0x2, 0x1815, 
       0x1816, 0x3, 0x2, 0x2, 0x2, 0x1816, 0x1817, 0x7, 0x1da, 0x2, 0x2, 
       0x1817, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x1818, 0x1819, 0x7, 0x1d1, 0x2, 
       0x2, 0x1819, 0x181a, 0x7, 0x1d9, 0x2, 0x2, 0x181a, 0x181b, 0x7, 0xf7, 
       0x2, 0x2, 0x181b, 0x181c, 0x5, 0x41e, 0x210, 0x2, 0x181c, 0x181d, 
       0x7, 0x1da, 0x2, 0x2, 0x181d, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x181e, 
       0x181f, 0x7, 0x1d1, 0x2, 0x2, 0x181f, 0x1820, 0x7, 0x1d9, 0x2, 0x2, 
       0x1820, 0x1821, 0x7, 0xf7, 0x2, 0x2, 0x1821, 0x1822, 0x5, 0x41e, 
       0x210, 0x2, 0x1822, 0x1823, 0x7, 0x1df, 0x2, 0x2, 0x1823, 0x1824, 
       0x5, 0x362, 0x1b2, 0x2, 0x1824, 0x1825, 0x7, 0x1da, 0x2, 0x2, 0x1825, 
       0x1839, 0x3, 0x2, 0x2, 0x2, 0x1826, 0x1827, 0x7, 0x1d2, 0x2, 0x2, 
       0x1827, 0x1828, 0x7, 0x1d9, 0x2, 0x2, 0x1828, 0x1829, 0x5, 0x362, 
       0x1b2, 0x2, 0x1829, 0x182a, 0x7, 0x1df, 0x2, 0x2, 0x182a, 0x182c, 
       0x5, 0x384, 0x1c3, 0x2, 0x182b, 0x182d, 0x5, 0x386, 0x1c4, 0x2, 0x182c, 
       0x182b, 0x3, 0x2, 0x2, 0x2, 0x182c, 0x182d, 0x3, 0x2, 0x2, 0x2, 0x182d, 
       0x182e, 0x3, 0x2, 0x2, 0x2, 0x182e, 0x182f, 0x7, 0x1da, 0x2, 0x2, 
       0x182f, 0x1839, 0x3, 0x2, 0x2, 0x2, 0x1830, 0x1831, 0x7, 0x1d3, 0x2, 
       0x2, 0x1831, 0x1832, 0x7, 0x1d9, 0x2, 0x2, 0x1832, 0x1833, 0x5, 0x38e, 
       0x1c8, 0x2, 0x1833, 0x1834, 0x5, 0x362, 0x1b2, 0x2, 0x1834, 0x1835, 
       0x7, 0x15, 0x2, 0x2, 0x1835, 0x1836, 0x5, 0x33e, 0x1a0, 0x2, 0x1836, 
       0x1837, 0x7, 0x1da, 0x2, 0x2, 0x1837, 0x1839, 0x3, 0x2, 0x2, 0x2, 
       0x1838, 0x1757, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x175e, 0x3, 0x2, 0x2, 
       0x2, 0x1838, 0x175f, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1760, 0x3, 0x2, 
       0x2, 0x2, 0x1838, 0x1764, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1765, 0x3, 
       0x2, 0x2, 0x2, 0x1838, 0x1766, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1767, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x1768, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1769, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x176a, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1771, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x1777, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x177c, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x1782, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1788, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x178f, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1795, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x179b, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17a1, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17a6, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17ad, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17af, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17b1, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17b3, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17b5, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17b7, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17bc, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17c8, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17d4, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17db, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17dd, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17e3, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17eb, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x17f3, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x17fd, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x1803, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x180a, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x180f, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1818, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x181e, 0x3, 0x2, 0x2, 0x2, 0x1838, 0x1826, 
       0x3, 0x2, 0x2, 0x2, 0x1838, 0x1830, 0x3, 0x2, 0x2, 0x2, 0x1839, 0x383, 
       0x3, 0x2, 0x2, 0x2, 0x183a, 0x183b, 0x7, 0x1bc, 0x2, 0x2, 0x183b, 
       0x1840, 0x5, 0x362, 0x1b2, 0x2, 0x183c, 0x183d, 0x7, 0x1bc, 0x2, 
       0x2, 0x183d, 0x183e, 0x7, 0xfe, 0x2, 0x2, 0x183e, 0x1840, 0x7, 0x1b6, 
       0x2, 0x2, 0x183f, 0x183a, 0x3, 0x2, 0x2, 0x2, 0x183f, 0x183c, 0x3, 
       0x2, 0x2, 0x2, 0x1840, 0x385, 0x3, 0x2, 0x2, 0x2, 0x1841, 0x1842, 
       0x7, 0x1df, 0x2, 0x2, 0x1842, 0x1848, 0x7, 0x180, 0x2, 0x2, 0x1843, 
       0x1849, 0x7, 0x1d5, 0x2, 0x2, 0x1844, 0x1846, 0x7, 0xfe, 0x2, 0x2, 
       0x1845, 0x1847, 0x7, 0x1b6, 0x2, 0x2, 0x1846, 0x1845, 0x3, 0x2, 0x2, 
       0x2, 0x1846, 0x1847, 0x3, 0x2, 0x2, 0x2, 0x1847, 0x1849, 0x3, 0x2, 
       0x2, 0x2, 0x1848, 0x1843, 0x3, 0x2, 0x2, 0x2, 0x1848, 0x1844, 0x3, 
       0x2, 0x2, 0x2, 0x1849, 0x387, 0x3, 0x2, 0x2, 0x2, 0x184a, 0x184b, 
       0x7, 0x1ca, 0x2, 0x2, 0x184b, 0x184c, 0x7, 0x1d9, 0x2, 0x2, 0x184c, 
       0x184d, 0x5, 0x38a, 0x1c6, 0x2, 0x184d, 0x184e, 0x7, 0x1da, 0x2, 
       0x2, 0x184e, 0x389, 0x3, 0x2, 0x2, 0x2, 0x184f, 0x1854, 0x5, 0x38c, 
       0x1c7, 0x2, 0x1850, 0x1851, 0x7, 0x1df, 0x2, 0x2, 0x1851, 0x1853, 
       0x5, 0x38c, 0x1c7, 0x2, 0x1852, 0x1850, 0x3, 0x2, 0x2, 0x2, 0x1853, 
       0x1856, 0x3, 0x2, 0x2, 0x2, 0x1854, 0x1852, 0x3, 0x2, 0x2, 0x2, 0x1854, 
       0x1855, 0x3, 0x2, 0x2, 0x2, 0x1855, 0x38b, 0x3, 0x2, 0x2, 0x2, 0x1856, 
       0x1854, 0x3, 0x2, 0x2, 0x2, 0x1857, 0x185a, 0x5, 0x362, 0x1b2, 0x2, 
       0x1858, 0x1859, 0x7, 0x15, 0x2, 0x2, 0x1859, 0x185b, 0x5, 0x41e, 
       0x210, 0x2, 0x185a, 0x1858, 0x3, 0x2, 0x2, 0x2, 0x185a, 0x185b, 0x3, 
       0x2, 0x2, 0x2, 0x185b, 0x185e, 0x3, 0x2, 0x2, 0x2, 0x185c, 0x185e, 
       0x5, 0x362, 0x1b2, 0x2, 0x185d, 0x1857, 0x3, 0x2, 0x2, 0x2, 0x185d, 
       0x185c, 0x3, 0x2, 0x2, 0x2, 0x185e, 0x38d, 0x3, 0x2, 0x2, 0x2, 0x185f, 
       0x1860, 0x9, 0x4d, 0x2, 0x2, 0x1860, 0x38f, 0x3, 0x2, 0x2, 0x2, 0x1861, 
       0x1862, 0x9, 0x4e, 0x2, 0x2, 0x1862, 0x1863, 0x7, 0x1c2, 0x2, 0x2, 
       0x1863, 0x391, 0x3, 0x2, 0x2, 0x2, 0x1864, 0x1865, 0x7, 0x12e, 0x2, 
       0x2, 0x1865, 0x1868, 0x5, 0x378, 0x1bd, 0x2, 0x1866, 0x1867, 0x7, 
       0x25, 0x2, 0x2, 0x1867, 0x1869, 0x7, 0x14e, 0x2, 0x2, 0x1868, 0x1866, 
       0x3, 0x2, 0x2, 0x2, 0x1868, 0x1869, 0x3, 0x2, 0x2, 0x2, 0x1869, 0x1873, 
       0x3, 0x2, 0x2, 0x2, 0x186a, 0x186b, 0x7, 0x12e, 0x2, 0x2, 0x186b, 
       0x186c, 0x7, 0x25, 0x2, 0x2, 0x186c, 0x186d, 0x7, 0x14e, 0x2, 0x2, 
       0x186d, 0x1870, 0x5, 0x378, 0x1bd, 0x2, 0x186e, 0x186f, 0x7, 0x25, 
       0x2, 0x2, 0x186f, 0x1871, 0x7, 0x14e, 0x2, 0x2, 0x1870, 0x186e, 0x3, 
       0x2, 0x2, 0x2, 0x1870, 0x1871, 0x3, 0x2, 0x2, 0x2, 0x1871, 0x1873, 
       0x3, 0x2, 0x2, 0x2, 0x1872, 0x1864, 0x3, 0x2, 0x2, 0x2, 0x1872, 0x186a, 
       0x3, 0x2, 0x2, 0x2, 0x1873, 0x393, 0x3, 0x2, 0x2, 0x2, 0x1874, 0x1875, 
       0x7, 0x1c3, 0x2, 0x2, 0x1875, 0x1876, 0x5, 0x396, 0x1cc, 0x2, 0x1876, 
       0x395, 0x3, 0x2, 0x2, 0x2, 0x1877, 0x187c, 0x5, 0x398, 0x1cd, 0x2, 
       0x1878, 0x1879, 0x7, 0x1df, 0x2, 0x2, 0x1879, 0x187b, 0x5, 0x398, 
       0x1cd, 0x2, 0x187a, 0x1878, 0x3, 0x2, 0x2, 0x2, 0x187b, 0x187e, 0x3, 
       0x2, 0x2, 0x2, 0x187c, 0x187a, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x187d, 
       0x3, 0x2, 0x2, 0x2, 0x187d, 0x397, 0x3, 0x2, 0x2, 0x2, 0x187e, 0x187c, 
       0x3, 0x2, 0x2, 0x2, 0x187f, 0x1880, 0x5, 0x41a, 0x20e, 0x2, 0x1880, 
       0x1881, 0x7, 0x15, 0x2, 0x2, 0x1881, 0x1882, 0x5, 0x39a, 0x1ce, 0x2, 
       0x1882, 0x399, 0x3, 0x2, 0x2, 0x2, 0x1883, 0x1885, 0x7, 0x1d9, 0x2, 
       0x2, 0x1884, 0x1886, 0x5, 0x41a, 0x20e, 0x2, 0x1885, 0x1884, 0x3, 
       0x2, 0x2, 0x2, 0x1885, 0x1886, 0x3, 0x2, 0x2, 0x2, 0x1886, 0x1888, 
       0x3, 0x2, 0x2, 0x2, 0x1887, 0x1889, 0x5, 0x39c, 0x1cf, 0x2, 0x1888, 
       0x1887, 0x3, 0x2, 0x2, 0x2, 0x1888, 0x1889, 0x3, 0x2, 0x2, 0x2, 0x1889, 
       0x188b, 0x3, 0x2, 0x2, 0x2, 0x188a, 0x188c, 0x5, 0x2fe, 0x180, 0x2, 
       0x188b, 0x188a, 0x3, 0x2, 0x2, 0x2, 0x188b, 0x188c, 0x3, 0x2, 0x2, 
       0x2, 0x188c, 0x188e, 0x3, 0x2, 0x2, 0x2, 0x188d, 0x188f, 0x5, 0x39e, 
       0x1d0, 0x2, 0x188e, 0x188d, 0x3, 0x2, 0x2, 0x2, 0x188e, 0x188f, 0x3, 
       0x2, 0x2, 0x2, 0x188f, 0x1890, 0x3, 0x2, 0x2, 0x2, 0x1890, 0x1891, 
       0x7, 0x1da, 0x2, 0x2, 0x1891, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x1892, 
       0x1893, 0x7, 0x12c, 0x2, 0x2, 0x1893, 0x1894, 0x7, 0x25, 0x2, 0x2, 
       0x1894, 0x1895, 0x5, 0x300, 0x181, 0x2, 0x1895, 0x39d, 0x3, 0x2, 
       0x2, 0x2, 0x1896, 0x1897, 0x5, 0x3a0, 0x1d1, 0x2, 0x1897, 0x1899, 
       0x5, 0x3a2, 0x1d2, 0x2, 0x1898, 0x189a, 0x5, 0x3aa, 0x1d6, 0x2, 0x1899, 
       0x1898, 0x3, 0x2, 0x2, 0x2, 0x1899, 0x189a, 0x3, 0x2, 0x2, 0x2, 0x189a, 
       0x39f, 0x3, 0x2, 0x2, 0x2, 0x189b, 0x189c, 0x9, 0x4f, 0x2, 0x2, 0x189c, 
       0x3a1, 0x3, 0x2, 0x2, 0x2, 0x189d, 0x18a0, 0x5, 0x3a4, 0x1d3, 0x2, 
       0x189e, 0x18a0, 0x5, 0x3a6, 0x1d4, 0x2, 0x189f, 0x189d, 0x3, 0x2, 
       0x2, 0x2, 0x189f, 0x189e, 0x3, 0x2, 0x2, 0x2, 0x18a0, 0x3a3, 0x3, 
       0x2, 0x2, 0x2, 0x18a1, 0x18a2, 0x7, 0x1a6, 0x2, 0x2, 0x18a2, 0x18a9, 
       0x7, 0x136, 0x2, 0x2, 0x18a3, 0x18a4, 0x5, 0x362, 0x1b2, 0x2, 0x18a4, 
       0x18a5, 0x7, 0x136, 0x2, 0x2, 0x18a5, 0x18a9, 0x3, 0x2, 0x2, 0x2, 
       0x18a6, 0x18a7, 0x7, 0x55, 0x2, 0x2, 0x18a7, 0x18a9, 0x7, 0x164, 
       0x2, 0x2, 0x18a8, 0x18a1, 0x3, 0x2, 0x2, 0x2, 0x18a8, 0x18a3, 0x3, 
       0x2, 0x2, 0x2, 0x18a8, 0x18a6, 0x3, 0x2, 0x2, 0x2, 0x18a9, 0x3a5, 
       0x3, 0x2, 0x2, 0x2, 0x18aa, 0x18ab, 0x7, 0x1f, 0x2, 0x2, 0x18ab, 
       0x18ac, 0x5, 0x3a8, 0x1d5, 0x2, 0x18ac, 0x18ad, 0x7, 0x12, 0x2, 0x2, 
       0x18ad, 0x18ae, 0x5, 0x3a8, 0x1d5, 0x2, 0x18ae, 0x3a7, 0x3, 0x2, 
       0x2, 0x2, 0x18af, 0x18b6, 0x5, 0x3a4, 0x1d3, 0x2, 0x18b0, 0x18b1, 
       0x7, 0x1a6, 0x2, 0x2, 0x18b1, 0x18b6, 0x7, 0x98, 0x2, 0x2, 0x18b2, 
       0x18b3, 0x5, 0x362, 0x1b2, 0x2, 0x18b3, 0x18b4, 0x7, 0x98, 0x2, 0x2, 
       0x18b4, 0x18b6, 0x3, 0x2, 0x2, 0x2, 0x18b5, 0x18af, 0x3, 0x2, 0x2, 
       0x2, 0x18b5, 0x18b0, 0x3, 0x2, 0x2, 0x2, 0x18b5, 0x18b2, 0x3, 0x2, 
       0x2, 0x2, 0x18b6, 0x3a9, 0x3, 0x2, 0x2, 0x2, 0x18b7, 0x18b8, 0x7, 
       0x86, 0x2, 0x2, 0x18b8, 0x18b9, 0x7, 0x55, 0x2, 0x2, 0x18b9, 0x18c2, 
       0x7, 0x164, 0x2, 0x2, 0x18ba, 0x18bb, 0x7, 0x86, 0x2, 0x2, 0x18bb, 
       0x18c2, 0x7, 0xa8, 0x2, 0x2, 0x18bc, 0x18bd, 0x7, 0x86, 0x2, 0x2, 
       0x18bd, 0x18c2, 0x7, 0x198, 0x2, 0x2, 0x18be, 0x18bf, 0x7, 0x86, 
       0x2, 0x2, 0x18bf, 0x18c0, 0x7, 0xfe, 0x2, 0x2, 0x18c0, 0x18c2, 0x7, 
       0x121, 0x2, 0x2, 0x18c1, 0x18b7, 0x3, 0x2, 0x2, 0x2, 0x18c1, 0x18ba, 
       0x3, 0x2, 0x2, 0x2, 0x18c1, 0x18bc, 0x3, 0x2, 0x2, 0x2, 0x18c1, 0x18be, 
       0x3, 0x2, 0x2, 0x2, 0x18c2, 0x3ab, 0x3, 0x2, 0x2, 0x2, 0x18c3, 0x18c5, 
       0x7, 0x1d9, 0x2, 0x2, 0x18c4, 0x18c6, 0x5, 0x3ba, 0x1de, 0x2, 0x18c5, 
       0x18c4, 0x3, 0x2, 0x2, 0x2, 0x18c5, 0x18c6, 0x3, 0x2, 0x2, 0x2, 0x18c6, 
       0x18c7, 0x3, 0x2, 0x2, 0x2, 0x18c7, 0x18c8, 0x7, 0x1da, 0x2, 0x2, 
       0x18c8, 0x3ad, 0x3, 0x2, 0x2, 0x2, 0x18c9, 0x18cb, 0x7, 0x200, 0x2, 
       0x2, 0x18ca, 0x18c9, 0x3, 0x2, 0x2, 0x2, 0x18cb, 0x18cc, 0x3, 0x2, 
       0x2, 0x2, 0x18cc, 0x18ca, 0x3, 0x2, 0x2, 0x2, 0x18cc, 0x18cd, 0x3, 
       0x2, 0x2, 0x2, 0x18cd, 0x3af, 0x3, 0x2, 0x2, 0x2, 0x18ce, 0x18cf, 
       0x5, 0x3ae, 0x1d8, 0x2, 0x18cf, 0x3b1, 0x3, 0x2, 0x2, 0x2, 0x18d0, 
       0x18d7, 0x5, 0x3ae, 0x1d8, 0x2, 0x18d1, 0x18d2, 0x7, 0x11b, 0x2, 
       0x2, 0x18d2, 0x18d3, 0x7, 0x1d9, 0x2, 0x2, 0x18d3, 0x18d4, 0x5, 0x24e, 
       0x128, 0x2, 0x18d4, 0x18d5, 0x7, 0x1da, 0x2, 0x2, 0x18d5, 0x18d7, 
       0x3, 0x2, 0x2, 0x2, 0x18d6, 0x18d0, 0x3, 0x2, 0x2, 0x2, 0x18d6, 0x18d1, 
       0x3, 0x2, 0x2, 0x2, 0x18d7, 0x3b3, 0x3, 0x2, 0x2, 0x2, 0x18d8, 0x18df, 
       0x5, 0x3b0, 0x1d9, 0x2, 0x18d9, 0x18da, 0x7, 0x11b, 0x2, 0x2, 0x18da, 
       0x18db, 0x7, 0x1d9, 0x2, 0x2, 0x18db, 0x18dc, 0x5, 0x24e, 0x128, 
       0x2, 0x18dc, 0x18dd, 0x7, 0x1da, 0x2, 0x2, 0x18dd, 0x18df, 0x3, 0x2, 
       0x2, 0x2, 0x18de, 0x18d8, 0x3, 0x2, 0x2, 0x2, 0x18de, 0x18d9, 0x3, 
       0x2, 0x2, 0x2, 0x18df, 0x3b5, 0x3, 0x2, 0x2, 0x2, 0x18e0, 0x18ef, 
       0x5, 0x3b0, 0x1d9, 0x2, 0x18e1, 0x18e2, 0x7, 0x11b, 0x2, 0x2, 0x18e2, 
       0x18e3, 0x7, 0x1d9, 0x2, 0x2, 0x18e3, 0x18e4, 0x5, 0x24e, 0x128, 
       0x2, 0x18e4, 0x18e5, 0x7, 0x1da, 0x2, 0x2, 0x18e5, 0x18ef, 0x3, 0x2, 
       0x2, 0x2, 0x18e6, 0x18e8, 0x7, 0x108, 0x2, 0x2, 0x18e7, 0x18e6, 0x3, 
       0x2, 0x2, 0x2, 0x18e7, 0x18e8, 0x3, 0x2, 0x2, 0x2, 0x18e8, 0x18e9, 
       0x3, 0x2, 0x2, 0x2, 0x18e9, 0x18ef, 0x7, 0xd9, 0x2, 0x2, 0x18ea, 
       0x18ec, 0x7, 0x108, 0x2, 0x2, 0x18eb, 0x18ea, 0x3, 0x2, 0x2, 0x2, 
       0x18eb, 0x18ec, 0x3, 0x2, 0x2, 0x2, 0x18ec, 0x18ed, 0x3, 0x2, 0x2, 
       0x2, 0x18ed, 0x18ef, 0x7, 0xb3, 0x2, 0x2, 0x18ee, 0x18e0, 0x3, 0x2, 
       0x2, 0x2, 0x18ee, 0x18e1, 0x3, 0x2, 0x2, 0x2, 0x18ee, 0x18e7, 0x3, 
       0x2, 0x2, 0x2, 0x18ee, 0x18eb, 0x3, 0x2, 0x2, 0x2, 0x18ef, 0x3b7, 
       0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18f1, 0x7, 0x1d9, 0x2, 0x2, 0x18f1, 
       0x18f2, 0x5, 0x3ba, 0x1de, 0x2, 0x18f2, 0x18f3, 0x7, 0x1da, 0x2, 
       0x2, 0x18f3, 0x3b9, 0x3, 0x2, 0x2, 0x2, 0x18f4, 0x18f9, 0x5, 0x362, 
       0x1b2, 0x2, 0x18f5, 0x18f6, 0x7, 0x1df, 0x2, 0x2, 0x18f6, 0x18f8, 
       0x5, 0x362, 0x1b2, 0x2, 0x18f7, 0x18f5, 0x3, 0x2, 0x2, 0x2, 0x18f8, 
       0x18fb, 0x3, 0x2, 0x2, 0x2, 0x18f9, 0x18f7, 0x3, 0x2, 0x2, 0x2, 0x18f9, 
       0x18fa, 0x3, 0x2, 0x2, 0x2, 0x18fa, 0x3bb, 0x3, 0x2, 0x2, 0x2, 0x18fb, 
       0x18f9, 0x3, 0x2, 0x2, 0x2, 0x18fc, 0x1901, 0x5, 0x33a, 0x19e, 0x2, 
       0x18fd, 0x18fe, 0x7, 0x1df, 0x2, 0x2, 0x18fe, 0x1900, 0x5, 0x33a, 
       0x19e, 0x2, 0x18ff, 0x18fd, 0x3, 0x2, 0x2, 0x2, 0x1900, 0x1903, 0x3, 
       0x2, 0x2, 0x2, 0x1901, 0x18ff, 0x3, 0x2, 0x2, 0x2, 0x1901, 0x1902, 
       0x3, 0x2, 0x2, 0x2, 0x1902, 0x3bd, 0x3, 0x2, 0x2, 0x2, 0x1903, 0x1901, 
       0x3, 0x2, 0x2, 0x2, 0x1904, 0x1906, 0x7, 0x1f2, 0x2, 0x2, 0x1905, 
       0x1907, 0x5, 0x3ba, 0x1de, 0x2, 0x1906, 0x1905, 0x3, 0x2, 0x2, 0x2, 
       0x1906, 0x1907, 0x3, 0x2, 0x2, 0x2, 0x1907, 0x1908, 0x3, 0x2, 0x2, 
       0x2, 0x1908, 0x190e, 0x7, 0x1f3, 0x2, 0x2, 0x1909, 0x190a, 0x7, 0x1f2, 
       0x2, 0x2, 0x190a, 0x190b, 0x5, 0x3c0, 0x1e1, 0x2, 0x190b, 0x190c, 
       0x7, 0x1f3, 0x2, 0x2, 0x190c, 0x190e, 0x3, 0x2, 0x2, 0x2, 0x190d, 
       0x1904, 0x3, 0x2, 0x2, 0x2, 0x190d, 0x1909, 0x3, 0x2, 0x2, 0x2, 0x190e, 
       0x3bf, 0x3, 0x2, 0x2, 0x2, 0x190f, 0x1914, 0x5, 0x3be, 0x1e0, 0x2, 
       0x1910, 0x1911, 0x7, 0x1df, 0x2, 0x2, 0x1911, 0x1913, 0x5, 0x3be, 
       0x1e0, 0x2, 0x1912, 0x1910, 0x3, 0x2, 0x2, 0x2, 0x1913, 0x1916, 0x3, 
       0x2, 0x2, 0x2, 0x1914, 0x1912, 0x3, 0x2, 0x2, 0x2, 0x1914, 0x1915, 
       0x3, 0x2, 0x2, 0x2, 0x1915, 0x3c1, 0x3, 0x2, 0x2, 0x2, 0x1916, 0x1914, 
       0x3, 0x2, 0x2, 0x2, 0x1917, 0x1918, 0x5, 0x3c4, 0x1e3, 0x2, 0x1918, 
       0x1919, 0x7, 0x9f, 0x2, 0x2, 0x1919, 0x191a, 0x5, 0x362, 0x1b2, 0x2, 
       0x191a, 0x3c3, 0x3, 0x2, 0x2, 0x2, 0x191b, 0x1924, 0x5, 0x420, 0x211, 
       0x2, 0x191c, 0x1924, 0x7, 0x1d4, 0x2, 0x2, 0x191d, 0x1924, 0x7, 0xf4, 
       0x2, 0x2, 0x191e, 0x1924, 0x7, 0x5f, 0x2, 0x2, 0x191f, 0x1924, 0x7, 
       0xaf, 0x2, 0x2, 0x1920, 0x1924, 0x7, 0xee, 0x2, 0x2, 0x1921, 0x1924, 
       0x7, 0x16c, 0x2, 0x2, 0x1922, 0x1924, 0x7, 0x1f9, 0x2, 0x2, 0x1923, 
       0x191b, 0x3, 0x2, 0x2, 0x2, 0x1923, 0x191c, 0x3, 0x2, 0x2, 0x2, 0x1923, 
       0x191d, 0x3, 0x2, 0x2, 0x2, 0x1923, 0x191e, 0x3, 0x2, 0x2, 0x2, 0x1923, 
       0x191f, 0x3, 0x2, 0x2, 0x2, 0x1923, 0x1920, 0x3, 0x2, 0x2, 0x2, 0x1923, 
       0x1921, 0x3, 0x2, 0x2, 0x2, 0x1923, 0x1922, 0x3, 0x2, 0x2, 0x2, 0x1924, 
       0x3c5, 0x3, 0x2, 0x2, 0x2, 0x1925, 0x1926, 0x5, 0x362, 0x1b2, 0x2, 
       0x1926, 0x1927, 0x5, 0x3c8, 0x1e5, 0x2, 0x1927, 0x1929, 0x5, 0x3ce, 
       0x1e8, 0x2, 0x1928, 0x192a, 0x5, 0x3d0, 0x1e9, 0x2, 0x1929, 0x1928, 
       0x3, 0x2, 0x2, 0x2, 0x1929, 0x192a, 0x3, 0x2, 0x2, 0x2, 0x192a, 0x3c7, 
       0x3, 0x2, 0x2, 0x2, 0x192b, 0x192c, 0x7, 0x133, 0x2, 0x2, 0x192c, 
       0x192d, 0x5, 0x362, 0x1b2, 0x2, 0x192d, 0x3c9, 0x3, 0x2, 0x2, 0x2, 
       0x192e, 0x192f, 0x5, 0x362, 0x1b2, 0x2, 0x192f, 0x1930, 0x7, 0xc2, 
       0x2, 0x2, 0x1930, 0x1931, 0x5, 0x362, 0x1b2, 0x2, 0x1931, 0x3cb, 
       0x3, 0x2, 0x2, 0x2, 0x1932, 0x1933, 0x5, 0x362, 0x1b2, 0x2, 0x1933, 
       0x1934, 0x5, 0x3ce, 0x1e8, 0x2, 0x1934, 0x1935, 0x5, 0x3d0, 0x1e9, 
       0x2, 0x1935, 0x1942, 0x3, 0x2, 0x2, 0x2, 0x1936, 0x1937, 0x5, 0x362, 
       0x1b2, 0x2, 0x1937, 0x1938, 0x5, 0x3d0, 0x1e9, 0x2, 0x1938, 0x1939, 
       0x5, 0x3ce, 0x1e8, 0x2, 0x1939, 0x1942, 0x3, 0x2, 0x2, 0x2, 0x193a, 
       0x193b, 0x5, 0x362, 0x1b2, 0x2, 0x193b, 0x193c, 0x5, 0x3ce, 0x1e8, 
       0x2, 0x193c, 0x1942, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x193e, 0x5, 0x362, 
       0x1b2, 0x2, 0x193e, 0x193f, 0x5, 0x3d0, 0x1e9, 0x2, 0x193f, 0x1942, 
       0x3, 0x2, 0x2, 0x2, 0x1940, 0x1942, 0x5, 0x3ba, 0x1de, 0x2, 0x1941, 
       0x1932, 0x3, 0x2, 0x2, 0x2, 0x1941, 0x1936, 0x3, 0x2, 0x2, 0x2, 0x1941, 
       0x193a, 0x3, 0x2, 0x2, 0x2, 0x1941, 0x193d, 0x3, 0x2, 0x2, 0x2, 0x1941, 
       0x1940, 0x3, 0x2, 0x2, 0x2, 0x1942, 0x3cd, 0x3, 0x2, 0x2, 0x2, 0x1943, 
       0x1944, 0x7, 0x9f, 0x2, 0x2, 0x1944, 0x1945, 0x5, 0x362, 0x1b2, 0x2, 
       0x1945, 0x3cf, 0x3, 0x2, 0x2, 0x2, 0x1946, 0x1947, 0x7, 0x99, 0x2, 
       0x2, 0x1947, 0x1948, 0x5, 0x362, 0x1b2, 0x2, 0x1948, 0x3d1, 0x3, 
       0x2, 0x2, 0x2, 0x1949, 0x194a, 0x5, 0x362, 0x1b2, 0x2, 0x194a, 0x194b, 
       0x7, 0x9f, 0x2, 0x2, 0x194b, 0x194c, 0x5, 0x3ba, 0x1de, 0x2, 0x194c, 
       0x1951, 0x3, 0x2, 0x2, 0x2, 0x194d, 0x194e, 0x7, 0x9f, 0x2, 0x2, 
       0x194e, 0x1951, 0x5, 0x3ba, 0x1de, 0x2, 0x194f, 0x1951, 0x5, 0x3ba, 
       0x1de, 0x2, 0x1950, 0x1949, 0x3, 0x2, 0x2, 0x2, 0x1950, 0x194d, 0x3, 
       0x2, 0x2, 0x2, 0x1950, 0x194f, 0x3, 0x2, 0x2, 0x2, 0x1951, 0x3d3, 
       0x3, 0x2, 0x2, 0x2, 0x1952, 0x1955, 0x5, 0x2ec, 0x177, 0x2, 0x1953, 
       0x1955, 0x5, 0x3b8, 0x1dd, 0x2, 0x1954, 0x1952, 0x3, 0x2, 0x2, 0x2, 
       0x1954, 0x1953, 0x3, 0x2, 0x2, 0x2, 0x1955, 0x3d5, 0x3, 0x2, 0x2, 
       0x2, 0x1956, 0x1958, 0x7, 0x2a, 0x2, 0x2, 0x1957, 0x1959, 0x5, 0x3de, 
       0x1f0, 0x2, 0x1958, 0x1957, 0x3, 0x2, 0x2, 0x2, 0x1958, 0x1959, 0x3, 
       0x2, 0x2, 0x2, 0x1959, 0x195b, 0x3, 0x2, 0x2, 0x2, 0x195a, 0x195c, 
       0x5, 0x3d8, 0x1ed, 0x2, 0x195b, 0x195a, 0x3, 0x2, 0x2, 0x2, 0x195c, 
       0x195d, 0x3, 0x2, 0x2, 0x2, 0x195d, 0x195b, 0x3, 0x2, 0x2, 0x2, 0x195d, 
       0x195e, 0x3, 0x2, 0x2, 0x2, 0x195e, 0x1960, 0x3, 0x2, 0x2, 0x2, 0x195f, 
       0x1961, 0x5, 0x3dc, 0x1ef, 0x2, 0x1960, 0x195f, 0x3, 0x2, 0x2, 0x2, 
       0x1960, 0x1961, 0x3, 0x2, 0x2, 0x2, 0x1961, 0x1962, 0x3, 0x2, 0x2, 
       0x2, 0x1962, 0x1963, 0x7, 0x7f, 0x2, 0x2, 0x1963, 0x3d7, 0x3, 0x2, 
       0x2, 0x2, 0x1964, 0x1965, 0x7, 0x1c0, 0x2, 0x2, 0x1965, 0x1966, 0x5, 
       0x3da, 0x1ee, 0x2, 0x1966, 0x1967, 0x7, 0x196, 0x2, 0x2, 0x1967, 
       0x1968, 0x5, 0x362, 0x1b2, 0x2, 0x1968, 0x3d9, 0x3, 0x2, 0x2, 0x2, 
       0x1969, 0x1970, 0x5, 0x362, 0x1b2, 0x2, 0x196a, 0x196b, 0x7, 0xcd, 
       0x2, 0x2, 0x196b, 0x196c, 0x7, 0x108, 0x2, 0x2, 0x196c, 0x196d, 0x7, 
       0x72, 0x2, 0x2, 0x196d, 0x196e, 0x7, 0x9f, 0x2, 0x2, 0x196e, 0x1970, 
       0x5, 0x362, 0x1b2, 0x2, 0x196f, 0x1969, 0x3, 0x2, 0x2, 0x2, 0x196f, 
       0x196a, 0x3, 0x2, 0x2, 0x2, 0x1970, 0x3db, 0x3, 0x2, 0x2, 0x2, 0x1971, 
       0x1972, 0x7, 0x7b, 0x2, 0x2, 0x1972, 0x1973, 0x5, 0x362, 0x1b2, 0x2, 
       0x1973, 0x3dd, 0x3, 0x2, 0x2, 0x2, 0x1974, 0x1975, 0x5, 0x362, 0x1b2, 
       0x2, 0x1975, 0x3df, 0x3, 0x2, 0x2, 0x2, 0x1976, 0x1977, 0x7, 0x64, 
       0x2, 0x2, 0x1977, 0x1978, 0x7, 0x1d9, 0x2, 0x2, 0x1978, 0x197a, 0x5, 
       0x362, 0x1b2, 0x2, 0x1979, 0x197b, 0x5, 0x3e2, 0x1f2, 0x2, 0x197a, 
       0x1979, 0x3, 0x2, 0x2, 0x2, 0x197b, 0x197c, 0x3, 0x2, 0x2, 0x2, 0x197c, 
       0x197a, 0x3, 0x2, 0x2, 0x2, 0x197c, 0x197d, 0x3, 0x2, 0x2, 0x2, 0x197d, 
       0x197f, 0x3, 0x2, 0x2, 0x2, 0x197e, 0x1980, 0x5, 0x3e4, 0x1f3, 0x2, 
       0x197f, 0x197e, 0x3, 0x2, 0x2, 0x2, 0x197f, 0x1980, 0x3, 0x2, 0x2, 
       0x2, 0x1980, 0x1981, 0x3, 0x2, 0x2, 0x2, 0x1981, 0x1982, 0x7, 0x1da, 
       0x2, 0x2, 0x1982, 0x3e1, 0x3, 0x2, 0x2, 0x2, 0x1983, 0x1984, 0x7, 
       0x1df, 0x2, 0x2, 0x1984, 0x1985, 0x5, 0x362, 0x1b2, 0x2, 0x1985, 
       0x1986, 0x7, 0x1df, 0x2, 0x2, 0x1986, 0x1987, 0x5, 0x362, 0x1b2, 
       0x2, 0x1987, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x1988, 0x1989, 0x7, 0x1df, 
       0x2, 0x2, 0x1989, 0x198a, 0x5, 0x362, 0x1b2, 0x2, 0x198a, 0x3e5, 
       0x3, 0x2, 0x2, 0x2, 0x198b, 0x198d, 0x5, 0x3f6, 0x1fc, 0x2, 0x198c, 
       0x198e, 0x5, 0x3ea, 0x1f6, 0x2, 0x198d, 0x198c, 0x3, 0x2, 0x2, 0x2, 
       0x198d, 0x198e, 0x3, 0x2, 0x2, 0x2, 0x198e, 0x3e7, 0x3, 0x2, 0x2, 
       0x2, 0x198f, 0x1990, 0x7, 0x1e3, 0x2, 0x2, 0x1990, 0x199e, 0x5, 0x406, 
       0x204, 0x2, 0x1991, 0x1992, 0x7, 0x1e3, 0x2, 0x2, 0x1992, 0x199e, 
       0x7, 0x1dc, 0x2, 0x2, 0x1993, 0x1994, 0x7, 0x1f2, 0x2, 0x2, 0x1994, 
       0x1995, 0x5, 0x362, 0x1b2, 0x2, 0x1995, 0x1996, 0x7, 0x1f3, 0x2, 
       0x2, 0x1996, 0x199e, 0x3, 0x2, 0x2, 0x2, 0x1997, 0x1998, 0x7, 0x1f2, 
       0x2, 0x2, 0x1998, 0x1999, 0x5, 0x362, 0x1b2, 0x2, 0x1999, 0x199a, 
       0x7, 0x1ed, 0x2, 0x2, 0x199a, 0x199b, 0x5, 0x362, 0x1b2, 0x2, 0x199b, 
       0x199c, 0x7, 0x1f3, 0x2, 0x2, 0x199c, 0x199e, 0x3, 0x2, 0x2, 0x2, 
       0x199d, 0x198f, 0x3, 0x2, 0x2, 0x2, 0x199d, 0x1991, 0x3, 0x2, 0x2, 
       0x2, 0x199d, 0x1993, 0x3, 0x2, 0x2, 0x2, 0x199d, 0x1997, 0x3, 0x2, 
       0x2, 0x2, 0x199e, 0x3e9, 0x3, 0x2, 0x2, 0x2, 0x199f, 0x19a1, 0x5, 
       0x3e8, 0x1f5, 0x2, 0x19a0, 0x199f, 0x3, 0x2, 0x2, 0x2, 0x19a1, 0x19a2, 
       0x3, 0x2, 0x2, 0x2, 0x19a2, 0x19a0, 0x3, 0x2, 0x2, 0x2, 0x19a2, 0x19a3, 
       0x3, 0x2, 0x2, 0x2, 0x19a3, 0x3eb, 0x3, 0x2, 0x2, 0x2, 0x19a4, 0x19a7, 
       0x5, 0x362, 0x1b2, 0x2, 0x19a5, 0x19a7, 0x7, 0x65, 0x2, 0x2, 0x19a6, 
       0x19a4, 0x3, 0x2, 0x2, 0x2, 0x19a6, 0x19a5, 0x3, 0x2, 0x2, 0x2, 0x19a7, 
       0x3ed, 0x3, 0x2, 0x2, 0x2, 0x19a8, 0x19ad, 0x5, 0x3ec, 0x1f7, 0x2, 
       0x19a9, 0x19aa, 0x7, 0x1df, 0x2, 0x2, 0x19aa, 0x19ac, 0x5, 0x3ec, 
       0x1f7, 0x2, 0x19ab, 0x19a9, 0x3, 0x2, 0x2, 0x2, 0x19ac, 0x19af, 0x3, 
       0x2, 0x2, 0x2, 0x19ad, 0x19ab, 0x3, 0x2, 0x2, 0x2, 0x19ad, 0x19ae, 
       0x3, 0x2, 0x2, 0x2, 0x19ae, 0x3ef, 0x3, 0x2, 0x2, 0x2, 0x19af, 0x19ad, 
       0x3, 0x2, 0x2, 0x2, 0x19b0, 0x19b1, 0x7, 0x1d9, 0x2, 0x2, 0x19b1, 
       0x19b2, 0x5, 0x3ee, 0x1f8, 0x2, 0x19b2, 0x19b3, 0x7, 0x1da, 0x2, 
       0x2, 0x19b3, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x19b4, 0x19b9, 0x5, 0x3f4, 
       0x1fb, 0x2, 0x19b5, 0x19b6, 0x7, 0x1df, 0x2, 0x2, 0x19b6, 0x19b8, 
       0x5, 0x3f4, 0x1fb, 0x2, 0x19b7, 0x19b5, 0x3, 0x2, 0x2, 0x2, 0x19b8, 
       0x19bb, 0x3, 0x2, 0x2, 0x2, 0x19b9, 0x19b7, 0x3, 0x2, 0x2, 0x2, 0x19b9, 
       0x19ba, 0x3, 0x2, 0x2, 0x2, 0x19ba, 0x3f3, 0x3, 0x2, 0x2, 0x2, 0x19bb, 
       0x19b9, 0x3, 0x2, 0x2, 0x2, 0x19bc, 0x19bf, 0x5, 0x3e6, 0x1f4, 0x2, 
       0x19bd, 0x19bf, 0x5, 0x362, 0x1b2, 0x2, 0x19be, 0x19bc, 0x3, 0x2, 
       0x2, 0x2, 0x19be, 0x19bd, 0x3, 0x2, 0x2, 0x2, 0x19bf, 0x19c4, 0x3, 
       0x2, 0x2, 0x2, 0x19c0, 0x19c2, 0x7, 0x15, 0x2, 0x2, 0x19c1, 0x19c0, 
       0x3, 0x2, 0x2, 0x2, 0x19c1, 0x19c2, 0x3, 0x2, 0x2, 0x2, 0x19c2, 0x19c3, 
       0x3, 0x2, 0x2, 0x2, 0x19c3, 0x19c5, 0x5, 0x41e, 0x210, 0x2, 0x19c4, 
       0x19c1, 0x3, 0x2, 0x2, 0x2, 0x19c4, 0x19c5, 0x3, 0x2, 0x2, 0x2, 0x19c5, 
       0x19c8, 0x3, 0x2, 0x2, 0x2, 0x19c6, 0x19c8, 0x7, 0x1dc, 0x2, 0x2, 
       0x19c7, 0x19be, 0x3, 0x2, 0x2, 0x2, 0x19c7, 0x19c6, 0x3, 0x2, 0x2, 
       0x2, 0x19c8, 0x3f5, 0x3, 0x2, 0x2, 0x2, 0x19c9, 0x19cc, 0x5, 0x430, 
       0x219, 0x2, 0x19ca, 0x19cc, 0x5, 0x41a, 0x20e, 0x2, 0x19cb, 0x19c9, 
       0x3, 0x2, 0x2, 0x2, 0x19cb, 0x19ca, 0x3, 0x2, 0x2, 0x2, 0x19cc, 0x3f7, 
       0x3, 0x2, 0x2, 0x2, 0x19cd, 0x19d2, 0x5, 0x3fa, 0x1fe, 0x2, 0x19ce, 
       0x19cf, 0x7, 0x1df, 0x2, 0x2, 0x19cf, 0x19d1, 0x5, 0x3fa, 0x1fe, 
       0x2, 0x19d0, 0x19ce, 0x3, 0x2, 0x2, 0x2, 0x19d1, 0x19d4, 0x3, 0x2, 
       0x2, 0x2, 0x19d2, 0x19d0, 0x3, 0x2, 0x2, 0x2, 0x19d2, 0x19d3, 0x3, 
       0x2, 0x2, 0x2, 0x19d3, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x19d4, 0x19d2, 
       0x3, 0x2, 0x2, 0x2, 0x19d5, 0x19d7, 0x5, 0x3f6, 0x1fc, 0x2, 0x19d6, 
       0x19d8, 0x5, 0x3ea, 0x1f6, 0x2, 0x19d7, 0x19d6, 0x3, 0x2, 0x2, 0x2, 
       0x19d7, 0x19d8, 0x3, 0x2, 0x2, 0x2, 0x19d8, 0x3fb, 0x3, 0x2, 0x2, 
       0x2, 0x19d9, 0x19de, 0x5, 0x3fe, 0x200, 0x2, 0x19da, 0x19db, 0x7, 
       0x1df, 0x2, 0x2, 0x19db, 0x19dd, 0x5, 0x3fe, 0x200, 0x2, 0x19dc, 
       0x19da, 0x3, 0x2, 0x2, 0x2, 0x19dd, 0x19e0, 0x3, 0x2, 0x2, 0x2, 0x19de, 
       0x19dc, 0x3, 0x2, 0x2, 0x2, 0x19de, 0x19df, 0x3, 0x2, 0x2, 0x2, 0x19df, 
       0x3fd, 0x3, 0x2, 0x2, 0x2, 0x19e0, 0x19de, 0x3, 0x2, 0x2, 0x2, 0x19e1, 
       0x19e2, 0x5, 0x41a, 0x20e, 0x2, 0x19e2, 0x3ff, 0x3, 0x2, 0x2, 0x2, 
       0x19e3, 0x19e4, 0x5, 0x41a, 0x20e, 0x2, 0x19e4, 0x401, 0x3, 0x2, 
       0x2, 0x2, 0x19e5, 0x19e6, 0x5, 0x41a, 0x20e, 0x2, 0x19e6, 0x403, 
       0x3, 0x2, 0x2, 0x2, 0x19e7, 0x19e8, 0x5, 0x41a, 0x20e, 0x2, 0x19e8, 
       0x405, 0x3, 0x2, 0x2, 0x2, 0x19e9, 0x19ea, 0x5, 0x41e, 0x210, 0x2, 
       0x19ea, 0x407, 0x3, 0x2, 0x2, 0x2, 0x19eb, 0x19ec, 0x5, 0x41a, 0x20e, 
       0x2, 0x19ec, 0x409, 0x3, 0x2, 0x2, 0x2, 0x19ed, 0x19ee, 0x5, 0x412, 
       0x20a, 0x2, 0x19ee, 0x40b, 0x3, 0x2, 0x2, 0x2, 0x19ef, 0x19f5, 0x5, 
       0x41c, 0x20f, 0x2, 0x19f0, 0x19f2, 0x5, 0x3f6, 0x1fc, 0x2, 0x19f1, 
       0x19f3, 0x5, 0x3ea, 0x1f6, 0x2, 0x19f2, 0x19f1, 0x3, 0x2, 0x2, 0x2, 
       0x19f2, 0x19f3, 0x3, 0x2, 0x2, 0x2, 0x19f3, 0x19f5, 0x3, 0x2, 0x2, 
       0x2, 0x19f4, 0x19ef, 0x3, 0x2, 0x2, 0x2, 0x19f4, 0x19f0, 0x3, 0x2, 
       0x2, 0x2, 0x19f5, 0x40d, 0x3, 0x2, 0x2, 0x2, 0x19f6, 0x1a10, 0x5, 
       0x410, 0x209, 0x2, 0x19f7, 0x1a10, 0x7, 0x1fc, 0x2, 0x2, 0x19f8, 
       0x1a10, 0x5, 0x412, 0x20a, 0x2, 0x19f9, 0x1a10, 0x7, 0x1fd, 0x2, 
       0x2, 0x19fa, 0x1a10, 0x7, 0x1fe, 0x2, 0x2, 0x19fb, 0x19fd, 0x5, 0x40c, 
       0x207, 0x2, 0x19fc, 0x19fe, 0x5, 0x3b8, 0x1dd, 0x2, 0x19fd, 0x19fc, 
       0x3, 0x2, 0x2, 0x2, 0x19fd, 0x19fe, 0x3, 0x2, 0x2, 0x2, 0x19fe, 0x19ff, 
       0x3, 0x2, 0x2, 0x2, 0x19ff, 0x1a00, 0x5, 0x412, 0x20a, 0x2, 0x1a00, 
       0x1a10, 0x3, 0x2, 0x2, 0x2, 0x1a01, 0x1a02, 0x5, 0x340, 0x1a1, 0x2, 
       0x1a02, 0x1a03, 0x5, 0x412, 0x20a, 0x2, 0x1a03, 0x1a10, 0x3, 0x2, 
       0x2, 0x2, 0x1a04, 0x1a06, 0x5, 0x35c, 0x1af, 0x2, 0x1a05, 0x1a07, 
       0x5, 0x5e, 0x30, 0x2, 0x1a06, 0x1a05, 0x3, 0x2, 0x2, 0x2, 0x1a06, 
       0x1a07, 0x3, 0x2, 0x2, 0x2, 0x1a07, 0x1a08, 0x3, 0x2, 0x2, 0x2, 0x1a08, 
       0x1a0a, 0x5, 0x412, 0x20a, 0x2, 0x1a09, 0x1a0b, 0x5, 0x360, 0x1b1, 
       0x2, 0x1a0a, 0x1a09, 0x3, 0x2, 0x2, 0x2, 0x1a0a, 0x1a0b, 0x3, 0x2, 
       0x2, 0x2, 0x1a0b, 0x1a10, 0x3, 0x2, 0x2, 0x2, 0x1a0c, 0x1a10, 0x7, 
       0x1a1, 0x2, 0x2, 0x1a0d, 0x1a10, 0x7, 0x8f, 0x2, 0x2, 0x1a0e, 0x1a10, 
       0x7, 0x10e, 0x2, 0x2, 0x1a0f, 0x19f6, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 
       0x19f7, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 0x19f8, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 
       0x19f9, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 0x19fa, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 
       0x19fb, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 0x1a01, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 
       0x1a04, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 0x1a0c, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 
       0x1a0d, 0x3, 0x2, 0x2, 0x2, 0x1a0f, 0x1a0e, 0x3, 0x2, 0x2, 0x2, 0x1a10, 
       0x40f, 0x3, 0x2, 0x2, 0x2, 0x1a11, 0x1a12, 0x7, 0x1fb, 0x2, 0x2, 
       0x1a12, 0x411, 0x3, 0x2, 0x2, 0x2, 0x1a13, 0x1a14, 0x9, 0x50, 0x2, 
       0x2, 0x1a14, 0x413, 0x3, 0x2, 0x2, 0x2, 0x1a15, 0x1a16, 0x5, 0x41a, 
       0x20e, 0x2, 0x1a16, 0x415, 0x3, 0x2, 0x2, 0x2, 0x1a17, 0x1a18, 0x5, 
       0x41a, 0x20e, 0x2, 0x1a18, 0x417, 0x3, 0x2, 0x2, 0x2, 0x1a19, 0x1a1b, 
       0x9, 0x4b, 0x2, 0x2, 0x1a1a, 0x1a19, 0x3, 0x2, 0x2, 0x2, 0x1a1a, 
       0x1a1b, 0x3, 0x2, 0x2, 0x2, 0x1a1b, 0x1a1c, 0x3, 0x2, 0x2, 0x2, 0x1a1c, 
       0x1a1d, 0x7, 0x1fb, 0x2, 0x2, 0x1a1d, 0x419, 0x3, 0x2, 0x2, 0x2, 
       0x1a1e, 0x1a20, 0x7, 0x1ec, 0x2, 0x2, 0x1a1f, 0x1a1e, 0x3, 0x2, 0x2, 
       0x2, 0x1a1f, 0x1a20, 0x3, 0x2, 0x2, 0x2, 0x1a20, 0x1a21, 0x3, 0x2, 
       0x2, 0x2, 0x1a21, 0x1a25, 0x5, 0x420, 0x211, 0x2, 0x1a22, 0x1a25, 
       0x5, 0x422, 0x212, 0x2, 0x1a23, 0x1a25, 0x7, 0x1fa, 0x2, 0x2, 0x1a24, 
       0x1a1f, 0x3, 0x2, 0x2, 0x2, 0x1a24, 0x1a22, 0x3, 0x2, 0x2, 0x2, 0x1a24, 
       0x1a23, 0x3, 0x2, 0x2, 0x2, 0x1a25, 0x41b, 0x3, 0x2, 0x2, 0x2, 0x1a26, 
       0x1a2a, 0x5, 0x420, 0x211, 0x2, 0x1a27, 0x1a2a, 0x5, 0x422, 0x212, 
       0x2, 0x1a28, 0x1a2a, 0x5, 0x42c, 0x217, 0x2, 0x1a29, 0x1a26, 0x3, 
       0x2, 0x2, 0x2, 0x1a29, 0x1a27, 0x3, 0x2, 0x2, 0x2, 0x1a29, 0x1a28, 
       0x3, 0x2, 0x2, 0x2, 0x1a2a, 0x41d, 0x3, 0x2, 0x2, 0x2, 0x1a2b, 0x1a32, 
       0x5, 0x420, 0x211, 0x2, 0x1a2c, 0x1a32, 0x5, 0x422, 0x212, 0x2, 0x1a2d, 
       0x1a32, 0x5, 0x42a, 0x216, 0x2, 0x1a2e, 0x1a32, 0x5, 0x42c, 0x217, 
       0x2, 0x1a2f, 0x1a32, 0x5, 0x42e, 0x218, 0x2, 0x1a30, 0x1a32, 0x7, 
       0x1fa, 0x2, 0x2, 0x1a31, 0x1a2b, 0x3, 0x2, 0x2, 0x2, 0x1a31, 0x1a2c, 
       0x3, 0x2, 0x2, 0x2, 0x1a31, 0x1a2d, 0x3, 0x2, 0x2, 0x2, 0x1a31, 0x1a2e, 
       0x3, 0x2, 0x2, 0x2, 0x1a31, 0x1a2f, 0x3, 0x2, 0x2, 0x2, 0x1a31, 0x1a30, 
       0x3, 0x2, 0x2, 0x2, 0x1a32, 0x41f, 0x3, 0x2, 0x2, 0x2, 0x1a33, 0x1a34, 
       0x9, 0x51, 0x2, 0x2, 0x1a34, 0x421, 0x3, 0x2, 0x2, 0x2, 0x1a35, 0x1a36, 
       0x9, 0x52, 0x2, 0x2, 0x1a36, 0x423, 0x3, 0x2, 0x2, 0x2, 0x1a37, 0x1a3d, 
       0x5, 0x428, 0x215, 0x2, 0x1a38, 0x1a3d, 0x7, 0x191, 0x2, 0x2, 0x1a39, 
       0x1a3d, 0x7, 0x8, 0x2, 0x2, 0x1a3a, 0x1a3d, 0x7, 0xe, 0x2, 0x2, 0x1a3b, 
       0x1a3d, 0x7, 0x1a, 0x2, 0x2, 0x1a3c, 0x1a37, 0x3, 0x2, 0x2, 0x2, 
       0x1a3c, 0x1a38, 0x3, 0x2, 0x2, 0x2, 0x1a3c, 0x1a39, 0x3, 0x2, 0x2, 
       0x2, 0x1a3c, 0x1a3a, 0x3, 0x2, 0x2, 0x2, 0x1a3c, 0x1a3b, 0x3, 0x2, 
       0x2, 0x2, 0x1a3d, 0x425, 0x3, 0x2, 0x2, 0x2, 0x1a3e, 0x1a41, 0x5, 
       0x428, 0x215, 0x2, 0x1a3f, 0x1a41, 0x5, 0x420, 0x211, 0x2, 0x1a40, 
       0x1a3e, 0x3, 0x2, 0x2, 0x2, 0x1a40, 0x1a3f, 0x3, 0x2, 0x2, 0x2, 0x1a41, 
       0x427, 0x3, 0x2, 0x2, 0x2, 0x1a42, 0x1a43, 0x9, 0x53, 0x2, 0x2, 0x1a43, 
       0x429, 0x3, 0x2, 0x2, 0x2, 0x1a44, 0x1a45, 0x9, 0x54, 0x2, 0x2, 0x1a45, 
       0x42b, 0x3, 0x2, 0x2, 0x2, 0x1a46, 0x1a47, 0x9, 0x55, 0x2, 0x2, 0x1a47, 
       0x42d, 0x3, 0x2, 0x2, 0x2, 0x1a48, 0x1a49, 0x9, 0x56, 0x2, 0x2, 0x1a49, 
       0x42f, 0x3, 0x2, 0x2, 0x2, 0x1a4a, 0x1a4b, 0x9, 0x57, 0x2, 0x2, 0x1a4b, 
       0x431, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x434, 0x43d, 0x4a8, 0x4b1, 0x4bb, 
       0x4c1, 0x4ce, 0x4d7, 0x4dd, 0x4f9, 0x507, 0x50d, 0x512, 0x54c, 0x552, 
       0x55b, 0x56d, 0x578, 0x57d, 0x584, 0x589, 0x596, 0x59c, 0x5a1, 0x5b1, 
       0x5bb, 0x5c1, 0x5c6, 0x5d6, 0x5dd, 0x5e4, 0x5ed, 0x5f0, 0x5fa, 0x5fe, 
       0x61c, 0x624, 0x629, 0x633, 0x63b, 0x641, 0x648, 0x650, 0x654, 0x659, 
       0x661, 0x665, 0x675, 0x67a, 0x68a, 0x693, 0x69e, 0x6a9, 0x6b0, 0x6b5, 
       0x6ba, 0x6c1, 0x6ca, 0x6d3, 0x6dc, 0x6e5, 0x6e9, 0x6ed, 0x6f3, 0x6fb, 
       0x708, 0x714, 0x718, 0x720, 0x726, 0x72d, 0x73b, 0x73e, 0x742, 0x747, 
       0x758, 0x761, 0x766, 0x769, 0x76c, 0x773, 0x776, 0x779, 0x77f, 0x782, 
       0x785, 0x796, 0x79e, 0x7a3, 0x7ad, 0x7b4, 0x7d1, 0x7da, 0x7df, 0x7e1, 
       0x7e8, 0x7f3, 0x7fa, 0x804, 0x808, 0x80c, 0x80f, 0x813, 0x817, 0x81a, 
       0x81f, 0x823, 0x826, 0x82c, 0x830, 0x835, 0x838, 0x843, 0x849, 0x85a, 
       0x860, 0x867, 0x86d, 0x871, 0x874, 0x877, 0x87a, 0x87d, 0x880, 0x883, 
       0x88c, 0x893, 0x89e, 0x8a5, 0x8a9, 0x8b1, 0x8bb, 0x8be, 0x8c3, 0x8c6, 
       0x8d2, 0x8d5, 0x8d8, 0x8da, 0x8dd, 0x8e2, 0x8e9, 0x8f2, 0x8f6, 0x902, 
       0x906, 0x909, 0x911, 0x914, 0x917, 0x91a, 0x91c, 0x92b, 0x93b, 0x94b, 
       0x956, 0x95f, 0x96e, 0x975, 0x97b, 0x97f, 0x98e, 0x996, 0x9a4, 0x9ab, 
       0x9b9, 0x9c0, 0x9c8, 0x9cc, 0x9d1, 0x9d5, 0x9df, 0x9e2, 0x9e6, 0x9e8, 
       0x9f3, 0x9fb, 0xa05, 0xa09, 0xa0d, 0xa10, 0xa13, 0xa16, 0xa19, 0xa1d, 
       0xa21, 0xa24, 0xa27, 0xa2a, 0xa2d, 0xa31, 0xa35, 0xa38, 0xa3b, 0xa50, 
       0xa54, 0xa57, 0xa5a, 0xa5e, 0xa63, 0xa71, 0xa74, 0xa7b, 0xa82, 0xa85, 
       0xa88, 0xa8c, 0xa8f, 0xa92, 0xa95, 0xaa0, 0xaa7, 0xaad, 0xab1, 0xab5, 
       0xab8, 0xabe, 0xac5, 0xac8, 0xacb, 0xace, 0xad1, 0xadc, 0xae4, 0xae7, 
       0xaee, 0xaf4, 0xaf7, 0xb05, 0xb0a, 0xb11, 0xb1c, 0xb20, 0xb25, 0xb2e, 
       0xb34, 0xb3e, 0xb45, 0xb50, 0xb55, 0xb5b, 0xb62, 0xb6a, 0xb71, 0xb75, 
       0xb79, 0xb7d, 0xb82, 0xb88, 0xb8d, 0xb92, 0xb99, 0xba5, 0xba8, 0xbac, 
       0xbaf, 0xbb7, 0xbba, 0xbbf, 0xbc4, 0xbc7, 0xbcd, 0xbd6, 0xbdc, 0xbe1, 
       0xbe5, 0xbeb, 0xbf6, 0xc04, 0xc0e, 0xc12, 0xc15, 0xc1a, 0xc22, 0xc29, 
       0xc2e, 0xc4b, 0xc79, 0xc83, 0xc8a, 0xc97, 0xc9a, 0xca4, 0xca8, 0xcb1, 
       0xcb8, 0xcc3, 0xccc, 0xcd3, 0xcd7, 0xcd9, 0xcdc, 0xce9, 0xcf3, 0xcf5, 
       0xcff, 0xd05, 0xd09, 0xd11, 0xd2a, 0xd37, 0xd42, 0xd4d, 0xd55, 0xd5e, 
       0xd64, 0xd6f, 0xd7b, 0xd83, 0xd8b, 0xd95, 0xd9c, 0xd9f, 0xdae, 0xdcc, 
       0xdd3, 0xddf, 0xde5, 0xdec, 0xdf2, 0xdf9, 0xe06, 0xe0a, 0xe0f, 0xe20, 
       0xe27, 0xe2c, 0xe32, 0xe36, 0xe3a, 0xe70, 0xe78, 0xe8a, 0xe8e, 0xe92, 
       0xe95, 0xead, 0xeb6, 0xebc, 0xec4, 0xec9, 0xecb, 0xed2, 0xed9, 0xeea, 
       0xef1, 0xef6, 0xf01, 0xf0c, 0xf0f, 0xf15, 0xf1b, 0xf1e, 0xf2a, 0xf32, 
       0xf38, 0xf3b, 0xf3e, 0xf45, 0xf4a, 0xf4d, 0xf50, 0xf54, 0xf57, 0xf5a, 
       0xf60, 0xf63, 0xf66, 0xf68, 0xf6b, 0xf75, 0xf7c, 0xf83, 0xf8a, 0xf93, 
       0xf98, 0xfa1, 0xfa5, 0xfa8, 0xfaf, 0xfb8, 0xfbe, 0xfc1, 0xfc8, 0xfd0, 
       0xfd5, 0xfe5, 0xff8, 0xfff, 0x1004, 0x100e, 0x1016, 0x101d, 0x1029, 
       0x102f, 0x1034, 0x103a, 0x103f, 0x1045, 0x104a, 0x1050, 0x1060, 0x1067, 
       0x106d, 0x1070, 0x107e, 0x1081, 0x1087, 0x108d, 0x1095, 0x109b, 0x10d2, 
       0x10f7, 0x1124, 0x114c, 0x116d, 0x1197, 0x119b, 0x11a5, 0x11a9, 0x11b1, 
       0x11b4, 0x11bb, 0x11c3, 0x11cd, 0x11d3, 0x11df, 0x11e3, 0x11e7, 0x11ea, 
       0x11ef, 0x11f5, 0x11fa, 0x11fe, 0x1207, 0x1210, 0x1217, 0x121d, 0x121f, 
       0x1224, 0x1227, 0x122c, 0x1231, 0x1234, 0x1240, 0x1245, 0x124a, 0x124e, 
       0x1252, 0x1256, 0x125a, 0x125e, 0x1262, 0x1267, 0x126c, 0x1271, 0x1275, 
       0x1277, 0x127d, 0x1282, 0x128d, 0x1295, 0x129d, 0x12a3, 0x12b5, 0x12b7, 
       0x12d2, 0x12dd, 0x12e1, 0x12e5, 0x12f2, 0x12f7, 0x12fd, 0x1301, 0x1304, 
       0x1307, 0x130a, 0x130e, 0x1311, 0x1314, 0x1317, 0x131b, 0x131f, 0x1323, 
       0x1326, 0x132a, 0x132c, 0x132e, 0x1338, 0x133b, 0x133e, 0x1341, 0x134d, 
       0x1352, 0x135f, 0x1363, 0x1369, 0x136e, 0x1372, 0x1376, 0x137d, 0x1386, 
       0x138a, 0x1394, 0x139b, 0x13a0, 0x13a3, 0x13ab, 0x13b0, 0x13b3, 0x13b6, 
       0x13ba, 0x13be, 0x13c1, 0x13c8, 0x13cf, 0x13d2, 0x13d6, 0x13dc, 0x13df, 
       0x13e2, 0x13e9, 0x13ee, 0x13fc, 0x1403, 0x140b, 0x1410, 0x1416, 0x141b, 
       0x1424, 0x1429, 0x142d, 0x1436, 0x143a, 0x143d, 0x1440, 0x1444, 0x1448, 
       0x144b, 0x144e, 0x1451, 0x1454, 0x1457, 0x145a, 0x145e, 0x1467, 0x146c, 
       0x1473, 0x1476, 0x1479, 0x147c, 0x1483, 0x1486, 0x1491, 0x1498, 0x149c, 
       0x149f, 0x14a1, 0x14bd, 0x14c8, 0x14cd, 0x14d1, 0x14d8, 0x14eb, 0x14fa, 
       0x1502, 0x1507, 0x150c, 0x150f, 0x151d, 0x1528, 0x152e, 0x1532, 0x1534, 
       0x1538, 0x153c, 0x153e, 0x1542, 0x1545, 0x154d, 0x1551, 0x1553, 0x1559, 
       0x155d, 0x155f, 0x1561, 0x1565, 0x1568, 0x156d, 0x1571, 0x1576, 0x157a, 
       0x1580, 0x1584, 0x158d, 0x1591, 0x1594, 0x15a2, 0x15a4, 0x15ab, 0x15b5, 
       0x15bd, 0x15cd, 0x15d5, 0x15de, 0x15e1, 0x15e3, 0x15e9, 0x15ed, 0x15f0, 
       0x15f9, 0x15ff, 0x1603, 0x1607, 0x160a, 0x160e, 0x1612, 0x1616, 0x161c, 
       0x1620, 0x1624, 0x1629, 0x162d, 0x1631, 0x1637, 0x1639, 0x1641, 0x1644, 
       0x1667, 0x166f, 0x167e, 0x1680, 0x1687, 0x168f, 0x1691, 0x169f, 0x16a4, 
       0x16a8, 0x16ac, 0x16b2, 0x16b5, 0x16bc, 0x16c1, 0x16c3, 0x16c5, 0x16cb, 
       0x16d7, 0x16e2, 0x16f1, 0x16f3, 0x16fc, 0x1703, 0x170a, 0x170d, 0x1711, 
       0x1719, 0x171e, 0x172a, 0x1730, 0x1734, 0x173b, 0x174d, 0x1751, 0x1755, 
       0x1762, 0x1774, 0x177f, 0x1785, 0x1814, 0x182c, 0x1838, 0x183f, 0x1846, 
       0x1848, 0x1854, 0x185a, 0x185d, 0x1868, 0x1870, 0x1872, 0x187c, 0x1885, 
       0x1888, 0x188b, 0x188e, 0x1899, 0x189f, 0x18a8, 0x18b5, 0x18c1, 0x18c5, 
       0x18cc, 0x18d6, 0x18de, 0x18e7, 0x18eb, 0x18ee, 0x18f9, 0x1901, 0x1906, 
       0x190d, 0x1914, 0x1923, 0x1929, 0x1941, 0x1950, 0x1954, 0x1958, 0x195d, 
       0x1960, 0x196f, 0x197c, 0x197f, 0x198d, 0x199d, 0x19a2, 0x19a6, 0x19ad, 
       0x19b9, 0x19be, 0x19c1, 0x19c4, 0x19c7, 0x19cb, 0x19d2, 0x19d7, 0x19de, 
       0x19f2, 0x19f4, 0x19fd, 0x1a06, 0x1a0a, 0x1a0f, 0x1a1a, 0x1a1f, 0x1a24, 
       0x1a29, 0x1a31, 0x1a3c, 0x1a40, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment2,
    serializedATNSegment2 + sizeof(serializedATNSegment2) / sizeof(serializedATNSegment2[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

GreenPlumParser::Initializer GreenPlumParser::_init;
