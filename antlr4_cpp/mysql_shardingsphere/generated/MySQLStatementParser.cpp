
// Generated from MySQLStatementParser.g4 by ANTLR 4.7.1


#include "MySQLStatementParserListener.h"
#include "MySQLStatementParserVisitor.h"

#include "MySQLStatementParser.h"


using namespace antlrcpp;
using namespace antlr4;

MySQLStatementParser::MySQLStatementParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

MySQLStatementParser::~MySQLStatementParser() {
  delete _interpreter;
}

std::string MySQLStatementParser::getGrammarFileName() const {
  return "MySQLStatementParser.g4";
}

const std::vector<std::string>& MySQLStatementParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& MySQLStatementParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- ExecuteContext ------------------------------------------------------------------

MySQLStatementParser::ExecuteContext::ExecuteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SelectContext* MySQLStatementParser::ExecuteContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

MySQLStatementParser::InsertContext* MySQLStatementParser::ExecuteContext::insert() {
  return getRuleContext<MySQLStatementParser::InsertContext>(0);
}

MySQLStatementParser::UpdateContext* MySQLStatementParser::ExecuteContext::update() {
  return getRuleContext<MySQLStatementParser::UpdateContext>(0);
}

MySQLStatementParser::Delete_stmtContext* MySQLStatementParser::ExecuteContext::delete_stmt() {
  return getRuleContext<MySQLStatementParser::Delete_stmtContext>(0);
}

MySQLStatementParser::ReplaceContext* MySQLStatementParser::ExecuteContext::replace() {
  return getRuleContext<MySQLStatementParser::ReplaceContext>(0);
}

MySQLStatementParser::BinlogContext* MySQLStatementParser::ExecuteContext::binlog() {
  return getRuleContext<MySQLStatementParser::BinlogContext>(0);
}

MySQLStatementParser::CreateTableContext* MySQLStatementParser::ExecuteContext::createTable() {
  return getRuleContext<MySQLStatementParser::CreateTableContext>(0);
}

MySQLStatementParser::AlterStatementContext* MySQLStatementParser::ExecuteContext::alterStatement() {
  return getRuleContext<MySQLStatementParser::AlterStatementContext>(0);
}

MySQLStatementParser::RepairTableContext* MySQLStatementParser::ExecuteContext::repairTable() {
  return getRuleContext<MySQLStatementParser::RepairTableContext>(0);
}

MySQLStatementParser::DropTableContext* MySQLStatementParser::ExecuteContext::dropTable() {
  return getRuleContext<MySQLStatementParser::DropTableContext>(0);
}

MySQLStatementParser::TruncateTableContext* MySQLStatementParser::ExecuteContext::truncateTable() {
  return getRuleContext<MySQLStatementParser::TruncateTableContext>(0);
}

MySQLStatementParser::CreateIndexContext* MySQLStatementParser::ExecuteContext::createIndex() {
  return getRuleContext<MySQLStatementParser::CreateIndexContext>(0);
}

MySQLStatementParser::DropIndexContext* MySQLStatementParser::ExecuteContext::dropIndex() {
  return getRuleContext<MySQLStatementParser::DropIndexContext>(0);
}

MySQLStatementParser::CreateProcedureContext* MySQLStatementParser::ExecuteContext::createProcedure() {
  return getRuleContext<MySQLStatementParser::CreateProcedureContext>(0);
}

MySQLStatementParser::DropProcedureContext* MySQLStatementParser::ExecuteContext::dropProcedure() {
  return getRuleContext<MySQLStatementParser::DropProcedureContext>(0);
}

MySQLStatementParser::CreateFunctionContext* MySQLStatementParser::ExecuteContext::createFunction() {
  return getRuleContext<MySQLStatementParser::CreateFunctionContext>(0);
}

MySQLStatementParser::DropFunctionContext* MySQLStatementParser::ExecuteContext::dropFunction() {
  return getRuleContext<MySQLStatementParser::DropFunctionContext>(0);
}

MySQLStatementParser::CreateDatabaseContext* MySQLStatementParser::ExecuteContext::createDatabase() {
  return getRuleContext<MySQLStatementParser::CreateDatabaseContext>(0);
}

MySQLStatementParser::DropDatabaseContext* MySQLStatementParser::ExecuteContext::dropDatabase() {
  return getRuleContext<MySQLStatementParser::DropDatabaseContext>(0);
}

MySQLStatementParser::CreateEventContext* MySQLStatementParser::ExecuteContext::createEvent() {
  return getRuleContext<MySQLStatementParser::CreateEventContext>(0);
}

MySQLStatementParser::DropEventContext* MySQLStatementParser::ExecuteContext::dropEvent() {
  return getRuleContext<MySQLStatementParser::DropEventContext>(0);
}

MySQLStatementParser::CreateLogfileGroupContext* MySQLStatementParser::ExecuteContext::createLogfileGroup() {
  return getRuleContext<MySQLStatementParser::CreateLogfileGroupContext>(0);
}

MySQLStatementParser::DropLogfileGroupContext* MySQLStatementParser::ExecuteContext::dropLogfileGroup() {
  return getRuleContext<MySQLStatementParser::DropLogfileGroupContext>(0);
}

MySQLStatementParser::CreateServerContext* MySQLStatementParser::ExecuteContext::createServer() {
  return getRuleContext<MySQLStatementParser::CreateServerContext>(0);
}

MySQLStatementParser::DropServerContext* MySQLStatementParser::ExecuteContext::dropServer() {
  return getRuleContext<MySQLStatementParser::DropServerContext>(0);
}

MySQLStatementParser::CreateViewContext* MySQLStatementParser::ExecuteContext::createView() {
  return getRuleContext<MySQLStatementParser::CreateViewContext>(0);
}

MySQLStatementParser::DropViewContext* MySQLStatementParser::ExecuteContext::dropView() {
  return getRuleContext<MySQLStatementParser::DropViewContext>(0);
}

MySQLStatementParser::CreateTriggerContext* MySQLStatementParser::ExecuteContext::createTrigger() {
  return getRuleContext<MySQLStatementParser::CreateTriggerContext>(0);
}

MySQLStatementParser::DropTriggerContext* MySQLStatementParser::ExecuteContext::dropTrigger() {
  return getRuleContext<MySQLStatementParser::DropTriggerContext>(0);
}

MySQLStatementParser::AlterResourceGroupContext* MySQLStatementParser::ExecuteContext::alterResourceGroup() {
  return getRuleContext<MySQLStatementParser::AlterResourceGroupContext>(0);
}

MySQLStatementParser::CreateResourceGroupContext* MySQLStatementParser::ExecuteContext::createResourceGroup() {
  return getRuleContext<MySQLStatementParser::CreateResourceGroupContext>(0);
}

MySQLStatementParser::DropResourceGroupContext* MySQLStatementParser::ExecuteContext::dropResourceGroup() {
  return getRuleContext<MySQLStatementParser::DropResourceGroupContext>(0);
}

MySQLStatementParser::PreparedStatementContext* MySQLStatementParser::ExecuteContext::preparedStatement() {
  return getRuleContext<MySQLStatementParser::PreparedStatementContext>(0);
}

MySQLStatementParser::SetTransactionContext* MySQLStatementParser::ExecuteContext::setTransaction() {
  return getRuleContext<MySQLStatementParser::SetTransactionContext>(0);
}

MySQLStatementParser::BeginTransactionContext* MySQLStatementParser::ExecuteContext::beginTransaction() {
  return getRuleContext<MySQLStatementParser::BeginTransactionContext>(0);
}

MySQLStatementParser::SetAutoCommitContext* MySQLStatementParser::ExecuteContext::setAutoCommit() {
  return getRuleContext<MySQLStatementParser::SetAutoCommitContext>(0);
}

MySQLStatementParser::CommitContext* MySQLStatementParser::ExecuteContext::commit() {
  return getRuleContext<MySQLStatementParser::CommitContext>(0);
}

MySQLStatementParser::RollbackContext* MySQLStatementParser::ExecuteContext::rollback() {
  return getRuleContext<MySQLStatementParser::RollbackContext>(0);
}

MySQLStatementParser::SavepointContext* MySQLStatementParser::ExecuteContext::savepoint() {
  return getRuleContext<MySQLStatementParser::SavepointContext>(0);
}

MySQLStatementParser::GrantContext* MySQLStatementParser::ExecuteContext::grant() {
  return getRuleContext<MySQLStatementParser::GrantContext>(0);
}

MySQLStatementParser::RevokeContext* MySQLStatementParser::ExecuteContext::revoke() {
  return getRuleContext<MySQLStatementParser::RevokeContext>(0);
}

MySQLStatementParser::CreateUserContext* MySQLStatementParser::ExecuteContext::createUser() {
  return getRuleContext<MySQLStatementParser::CreateUserContext>(0);
}

MySQLStatementParser::DropUserContext* MySQLStatementParser::ExecuteContext::dropUser() {
  return getRuleContext<MySQLStatementParser::DropUserContext>(0);
}

MySQLStatementParser::AlterUserContext* MySQLStatementParser::ExecuteContext::alterUser() {
  return getRuleContext<MySQLStatementParser::AlterUserContext>(0);
}

MySQLStatementParser::RenameUserContext* MySQLStatementParser::ExecuteContext::renameUser() {
  return getRuleContext<MySQLStatementParser::RenameUserContext>(0);
}

MySQLStatementParser::CreateRoleContext* MySQLStatementParser::ExecuteContext::createRole() {
  return getRuleContext<MySQLStatementParser::CreateRoleContext>(0);
}

MySQLStatementParser::DropRoleContext* MySQLStatementParser::ExecuteContext::dropRole() {
  return getRuleContext<MySQLStatementParser::DropRoleContext>(0);
}

MySQLStatementParser::SetDefaultRoleContext* MySQLStatementParser::ExecuteContext::setDefaultRole() {
  return getRuleContext<MySQLStatementParser::SetDefaultRoleContext>(0);
}

MySQLStatementParser::SetRoleContext* MySQLStatementParser::ExecuteContext::setRole() {
  return getRuleContext<MySQLStatementParser::SetRoleContext>(0);
}

MySQLStatementParser::CreateTablespaceInnodbContext* MySQLStatementParser::ExecuteContext::createTablespaceInnodb() {
  return getRuleContext<MySQLStatementParser::CreateTablespaceInnodbContext>(0);
}

MySQLStatementParser::CreateTablespaceNdbContext* MySQLStatementParser::ExecuteContext::createTablespaceNdb() {
  return getRuleContext<MySQLStatementParser::CreateTablespaceNdbContext>(0);
}

MySQLStatementParser::DropTablespaceContext* MySQLStatementParser::ExecuteContext::dropTablespace() {
  return getRuleContext<MySQLStatementParser::DropTablespaceContext>(0);
}

MySQLStatementParser::CreateSRSStatementContext* MySQLStatementParser::ExecuteContext::createSRSStatement() {
  return getRuleContext<MySQLStatementParser::CreateSRSStatementContext>(0);
}

MySQLStatementParser::DropSRSStatementContext* MySQLStatementParser::ExecuteContext::dropSRSStatement() {
  return getRuleContext<MySQLStatementParser::DropSRSStatementContext>(0);
}

MySQLStatementParser::FlushContext* MySQLStatementParser::ExecuteContext::flush() {
  return getRuleContext<MySQLStatementParser::FlushContext>(0);
}

MySQLStatementParser::GetDiagnosticsStatementContext* MySQLStatementParser::ExecuteContext::getDiagnosticsStatement() {
  return getRuleContext<MySQLStatementParser::GetDiagnosticsStatementContext>(0);
}

MySQLStatementParser::GroupReplicationContext* MySQLStatementParser::ExecuteContext::groupReplication() {
  return getRuleContext<MySQLStatementParser::GroupReplicationContext>(0);
}

MySQLStatementParser::HandlerStatementContext* MySQLStatementParser::ExecuteContext::handlerStatement() {
  return getRuleContext<MySQLStatementParser::HandlerStatementContext>(0);
}

MySQLStatementParser::HelpContext* MySQLStatementParser::ExecuteContext::help() {
  return getRuleContext<MySQLStatementParser::HelpContext>(0);
}

MySQLStatementParser::ImportStatementContext* MySQLStatementParser::ExecuteContext::importStatement() {
  return getRuleContext<MySQLStatementParser::ImportStatementContext>(0);
}

MySQLStatementParser::InstallContext* MySQLStatementParser::ExecuteContext::install() {
  return getRuleContext<MySQLStatementParser::InstallContext>(0);
}

MySQLStatementParser::KillContext* MySQLStatementParser::ExecuteContext::kill() {
  return getRuleContext<MySQLStatementParser::KillContext>(0);
}

MySQLStatementParser::LoadStatementContext* MySQLStatementParser::ExecuteContext::loadStatement() {
  return getRuleContext<MySQLStatementParser::LoadStatementContext>(0);
}

MySQLStatementParser::LockContext* MySQLStatementParser::ExecuteContext::lock() {
  return getRuleContext<MySQLStatementParser::LockContext>(0);
}

MySQLStatementParser::CacheIndexContext* MySQLStatementParser::ExecuteContext::cacheIndex() {
  return getRuleContext<MySQLStatementParser::CacheIndexContext>(0);
}

MySQLStatementParser::LoadIndexInfoContext* MySQLStatementParser::ExecuteContext::loadIndexInfo() {
  return getRuleContext<MySQLStatementParser::LoadIndexInfoContext>(0);
}

MySQLStatementParser::OptimizeTableContext* MySQLStatementParser::ExecuteContext::optimizeTable() {
  return getRuleContext<MySQLStatementParser::OptimizeTableContext>(0);
}

MySQLStatementParser::PurgeBinaryLogContext* MySQLStatementParser::ExecuteContext::purgeBinaryLog() {
  return getRuleContext<MySQLStatementParser::PurgeBinaryLogContext>(0);
}

MySQLStatementParser::ReleaseSavepointContext* MySQLStatementParser::ExecuteContext::releaseSavepoint() {
  return getRuleContext<MySQLStatementParser::ReleaseSavepointContext>(0);
}

MySQLStatementParser::ResetStatementContext* MySQLStatementParser::ExecuteContext::resetStatement() {
  return getRuleContext<MySQLStatementParser::ResetStatementContext>(0);
}

MySQLStatementParser::SetPasswordContext* MySQLStatementParser::ExecuteContext::setPassword() {
  return getRuleContext<MySQLStatementParser::SetPasswordContext>(0);
}

MySQLStatementParser::SetResourceGroupContext* MySQLStatementParser::ExecuteContext::setResourceGroup() {
  return getRuleContext<MySQLStatementParser::SetResourceGroupContext>(0);
}

MySQLStatementParser::ResignalStatementContext* MySQLStatementParser::ExecuteContext::resignalStatement() {
  return getRuleContext<MySQLStatementParser::ResignalStatementContext>(0);
}

MySQLStatementParser::SignalStatementContext* MySQLStatementParser::ExecuteContext::signalStatement() {
  return getRuleContext<MySQLStatementParser::SignalStatementContext>(0);
}

MySQLStatementParser::RestartContext* MySQLStatementParser::ExecuteContext::restart() {
  return getRuleContext<MySQLStatementParser::RestartContext>(0);
}

MySQLStatementParser::ShutdownContext* MySQLStatementParser::ExecuteContext::shutdown() {
  return getRuleContext<MySQLStatementParser::ShutdownContext>(0);
}

MySQLStatementParser::BeginContext* MySQLStatementParser::ExecuteContext::begin() {
  return getRuleContext<MySQLStatementParser::BeginContext>(0);
}

MySQLStatementParser::UseContext* MySQLStatementParser::ExecuteContext::use() {
  return getRuleContext<MySQLStatementParser::UseContext>(0);
}

MySQLStatementParser::ExplainContext* MySQLStatementParser::ExecuteContext::explain() {
  return getRuleContext<MySQLStatementParser::ExplainContext>(0);
}

MySQLStatementParser::DoStatementContext* MySQLStatementParser::ExecuteContext::doStatement() {
  return getRuleContext<MySQLStatementParser::DoStatementContext>(0);
}

MySQLStatementParser::ShowContext* MySQLStatementParser::ExecuteContext::show() {
  return getRuleContext<MySQLStatementParser::ShowContext>(0);
}

MySQLStatementParser::SetVariableContext* MySQLStatementParser::ExecuteContext::setVariable() {
  return getRuleContext<MySQLStatementParser::SetVariableContext>(0);
}

MySQLStatementParser::SetNameContext* MySQLStatementParser::ExecuteContext::setName() {
  return getRuleContext<MySQLStatementParser::SetNameContext>(0);
}

MySQLStatementParser::SetCharacterContext* MySQLStatementParser::ExecuteContext::setCharacter() {
  return getRuleContext<MySQLStatementParser::SetCharacterContext>(0);
}

MySQLStatementParser::CallContext* MySQLStatementParser::ExecuteContext::call() {
  return getRuleContext<MySQLStatementParser::CallContext>(0);
}

MySQLStatementParser::ChangeContext* MySQLStatementParser::ExecuteContext::change() {
  return getRuleContext<MySQLStatementParser::ChangeContext>(0);
}

MySQLStatementParser::CheckTableContext* MySQLStatementParser::ExecuteContext::checkTable() {
  return getRuleContext<MySQLStatementParser::CheckTableContext>(0);
}

MySQLStatementParser::ChecksumTableContext* MySQLStatementParser::ExecuteContext::checksumTable() {
  return getRuleContext<MySQLStatementParser::ChecksumTableContext>(0);
}

MySQLStatementParser::CloneContext* MySQLStatementParser::ExecuteContext::clone() {
  return getRuleContext<MySQLStatementParser::CloneContext>(0);
}

MySQLStatementParser::StartSlaveContext* MySQLStatementParser::ExecuteContext::startSlave() {
  return getRuleContext<MySQLStatementParser::StartSlaveContext>(0);
}

MySQLStatementParser::StopSlaveContext* MySQLStatementParser::ExecuteContext::stopSlave() {
  return getRuleContext<MySQLStatementParser::StopSlaveContext>(0);
}

MySQLStatementParser::AnalyzeTableContext* MySQLStatementParser::ExecuteContext::analyzeTable() {
  return getRuleContext<MySQLStatementParser::AnalyzeTableContext>(0);
}

MySQLStatementParser::RenameTableContext* MySQLStatementParser::ExecuteContext::renameTable() {
  return getRuleContext<MySQLStatementParser::RenameTableContext>(0);
}

MySQLStatementParser::UninstallContext* MySQLStatementParser::ExecuteContext::uninstall() {
  return getRuleContext<MySQLStatementParser::UninstallContext>(0);
}

MySQLStatementParser::UnlockContext* MySQLStatementParser::ExecuteContext::unlock() {
  return getRuleContext<MySQLStatementParser::UnlockContext>(0);
}

MySQLStatementParser::XaContext* MySQLStatementParser::ExecuteContext::xa() {
  return getRuleContext<MySQLStatementParser::XaContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ExecuteContext::SEMI_() {
  return getToken(MySQLStatementParser::SEMI_, 0);
}

tree::TerminalNode* MySQLStatementParser::ExecuteContext::EOF() {
  return getToken(MySQLStatementParser::EOF, 0);
}


size_t MySQLStatementParser::ExecuteContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExecute;
}

void MySQLStatementParser::ExecuteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecute(this);
}

void MySQLStatementParser::ExecuteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecute(this);
}


antlrcpp::Any MySQLStatementParser::ExecuteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExecute(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExecuteContext* MySQLStatementParser::execute() {
  ExecuteContext *_localctx = _tracker.createInstance<ExecuteContext>(_ctx, getState());
  enterRule(_localctx, 0, MySQLStatementParser::RuleExecute);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1217);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      setState(1120);
      select();
      break;
    }

    case 2: {
      setState(1121);
      insert();
      break;
    }

    case 3: {
      setState(1122);
      update();
      break;
    }

    case 4: {
      setState(1123);
      delete_stmt();
      break;
    }

    case 5: {
      setState(1124);
      replace();
      break;
    }

    case 6: {
      setState(1125);
      binlog();
      break;
    }

    case 7: {
      setState(1126);
      createTable();
      break;
    }

    case 8: {
      setState(1127);
      alterStatement();
      break;
    }

    case 9: {
      setState(1128);
      repairTable();
      break;
    }

    case 10: {
      setState(1129);
      dropTable();
      break;
    }

    case 11: {
      setState(1130);
      truncateTable();
      break;
    }

    case 12: {
      setState(1131);
      createIndex();
      break;
    }

    case 13: {
      setState(1132);
      dropIndex();
      break;
    }

    case 14: {
      setState(1133);
      createProcedure();
      break;
    }

    case 15: {
      setState(1134);
      dropProcedure();
      break;
    }

    case 16: {
      setState(1135);
      createFunction();
      break;
    }

    case 17: {
      setState(1136);
      dropFunction();
      break;
    }

    case 18: {
      setState(1137);
      createDatabase();
      break;
    }

    case 19: {
      setState(1138);
      dropDatabase();
      break;
    }

    case 20: {
      setState(1139);
      createEvent();
      break;
    }

    case 21: {
      setState(1140);
      dropEvent();
      break;
    }

    case 22: {
      setState(1141);
      createLogfileGroup();
      break;
    }

    case 23: {
      setState(1142);
      dropLogfileGroup();
      break;
    }

    case 24: {
      setState(1143);
      createServer();
      break;
    }

    case 25: {
      setState(1144);
      dropServer();
      break;
    }

    case 26: {
      setState(1145);
      createView();
      break;
    }

    case 27: {
      setState(1146);
      dropView();
      break;
    }

    case 28: {
      setState(1147);
      createTrigger();
      break;
    }

    case 29: {
      setState(1148);
      dropTrigger();
      break;
    }

    case 30: {
      setState(1149);
      alterResourceGroup();
      break;
    }

    case 31: {
      setState(1150);
      createResourceGroup();
      break;
    }

    case 32: {
      setState(1151);
      dropResourceGroup();
      break;
    }

    case 33: {
      setState(1152);
      preparedStatement();
      break;
    }

    case 34: {
      setState(1153);
      setTransaction();
      break;
    }

    case 35: {
      setState(1154);
      beginTransaction();
      break;
    }

    case 36: {
      setState(1155);
      setAutoCommit();
      break;
    }

    case 37: {
      setState(1156);
      commit();
      break;
    }

    case 38: {
      setState(1157);
      rollback();
      break;
    }

    case 39: {
      setState(1158);
      savepoint();
      break;
    }

    case 40: {
      setState(1159);
      grant();
      break;
    }

    case 41: {
      setState(1160);
      revoke();
      break;
    }

    case 42: {
      setState(1161);
      createUser();
      break;
    }

    case 43: {
      setState(1162);
      dropUser();
      break;
    }

    case 44: {
      setState(1163);
      alterUser();
      break;
    }

    case 45: {
      setState(1164);
      renameUser();
      break;
    }

    case 46: {
      setState(1165);
      createRole();
      break;
    }

    case 47: {
      setState(1166);
      dropRole();
      break;
    }

    case 48: {
      setState(1167);
      setDefaultRole();
      break;
    }

    case 49: {
      setState(1168);
      setRole();
      break;
    }

    case 50: {
      setState(1169);
      createTablespaceInnodb();
      break;
    }

    case 51: {
      setState(1170);
      createTablespaceNdb();
      break;
    }

    case 52: {
      setState(1171);
      dropTablespace();
      break;
    }

    case 53: {
      setState(1172);
      createSRSStatement();
      break;
    }

    case 54: {
      setState(1173);
      dropSRSStatement();
      break;
    }

    case 55: {
      setState(1174);
      flush();
      break;
    }

    case 56: {
      setState(1175);
      getDiagnosticsStatement();
      break;
    }

    case 57: {
      setState(1176);
      groupReplication();
      break;
    }

    case 58: {
      setState(1177);
      handlerStatement();
      break;
    }

    case 59: {
      setState(1178);
      help();
      break;
    }

    case 60: {
      setState(1179);
      importStatement();
      break;
    }

    case 61: {
      setState(1180);
      install();
      break;
    }

    case 62: {
      setState(1181);
      kill();
      break;
    }

    case 63: {
      setState(1182);
      loadStatement();
      break;
    }

    case 64: {
      setState(1183);
      lock();
      break;
    }

    case 65: {
      setState(1184);
      cacheIndex();
      break;
    }

    case 66: {
      setState(1185);
      loadIndexInfo();
      break;
    }

    case 67: {
      setState(1186);
      optimizeTable();
      break;
    }

    case 68: {
      setState(1187);
      purgeBinaryLog();
      break;
    }

    case 69: {
      setState(1188);
      releaseSavepoint();
      break;
    }

    case 70: {
      setState(1189);
      resetStatement();
      break;
    }

    case 71: {
      setState(1190);
      setPassword();
      break;
    }

    case 72: {
      setState(1191);
      setTransaction();
      break;
    }

    case 73: {
      setState(1192);
      setResourceGroup();
      break;
    }

    case 74: {
      setState(1193);
      resignalStatement();
      break;
    }

    case 75: {
      setState(1194);
      signalStatement();
      break;
    }

    case 76: {
      setState(1195);
      restart();
      break;
    }

    case 77: {
      setState(1196);
      shutdown();
      break;
    }

    case 78: {
      setState(1197);
      begin();
      break;
    }

    case 79: {
      setState(1198);
      use();
      break;
    }

    case 80: {
      setState(1199);
      explain();
      break;
    }

    case 81: {
      setState(1200);
      doStatement();
      break;
    }

    case 82: {
      setState(1201);
      show();
      break;
    }

    case 83: {
      setState(1202);
      setVariable();
      break;
    }

    case 84: {
      setState(1203);
      setName();
      break;
    }

    case 85: {
      setState(1204);
      setCharacter();
      break;
    }

    case 86: {
      setState(1205);
      call();
      break;
    }

    case 87: {
      setState(1206);
      change();
      break;
    }

    case 88: {
      setState(1207);
      checkTable();
      break;
    }

    case 89: {
      setState(1208);
      checksumTable();
      break;
    }

    case 90: {
      setState(1209);
      clone();
      break;
    }

    case 91: {
      setState(1210);
      startSlave();
      break;
    }

    case 92: {
      setState(1211);
      stopSlave();
      break;
    }

    case 93: {
      setState(1212);
      analyzeTable();
      break;
    }

    case 94: {
      setState(1213);
      renameTable();
      break;
    }

    case 95: {
      setState(1214);
      uninstall();
      break;
    }

    case 96: {
      setState(1215);
      unlock();
      break;
    }

    case 97: {
      setState(1216);
      xa();
      break;
    }

    }
    setState(1224);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SEMI_: {
        setState(1219);
        match(MySQLStatementParser::SEMI_);
        setState(1221);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
        case 1: {
          setState(1220);
          match(MySQLStatementParser::EOF);
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::EOF: {
        setState(1223);
        match(MySQLStatementParser::EOF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertContext ------------------------------------------------------------------

MySQLStatementParser::InsertContext::InsertContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::InsertContext::INSERT() {
  return getToken(MySQLStatementParser::INSERT, 0);
}

MySQLStatementParser::InsertSpecificationContext* MySQLStatementParser::InsertContext::insertSpecification() {
  return getRuleContext<MySQLStatementParser::InsertSpecificationContext>(0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::InsertContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::InsertValuesClauseContext* MySQLStatementParser::InsertContext::insertValuesClause() {
  return getRuleContext<MySQLStatementParser::InsertValuesClauseContext>(0);
}

MySQLStatementParser::SetAssignmentsClauseContext* MySQLStatementParser::InsertContext::setAssignmentsClause() {
  return getRuleContext<MySQLStatementParser::SetAssignmentsClauseContext>(0);
}

MySQLStatementParser::InsertSelectClauseContext* MySQLStatementParser::InsertContext::insertSelectClause() {
  return getRuleContext<MySQLStatementParser::InsertSelectClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::InsertContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

MySQLStatementParser::PartitionNamesContext* MySQLStatementParser::InsertContext::partitionNames() {
  return getRuleContext<MySQLStatementParser::PartitionNamesContext>(0);
}

MySQLStatementParser::OnDuplicateKeyClauseContext* MySQLStatementParser::InsertContext::onDuplicateKeyClause() {
  return getRuleContext<MySQLStatementParser::OnDuplicateKeyClauseContext>(0);
}


size_t MySQLStatementParser::InsertContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInsert;
}

void MySQLStatementParser::InsertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert(this);
}

void MySQLStatementParser::InsertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert(this);
}


antlrcpp::Any MySQLStatementParser::InsertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInsert(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InsertContext* MySQLStatementParser::insert() {
  InsertContext *_localctx = _tracker.createInstance<InsertContext>(_ctx, getState());
  enterRule(_localctx, 2, MySQLStatementParser::RuleInsert);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1226);
    match(MySQLStatementParser::INSERT);
    setState(1227);
    insertSpecification();
    setState(1229);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::INTO) {
      setState(1228);
      match(MySQLStatementParser::INTO);
    }
    setState(1231);
    tableName();
    setState(1233);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PARTITION) {
      setState(1232);
      partitionNames();
    }
    setState(1238);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      setState(1235);
      insertValuesClause();
      break;
    }

    case 2: {
      setState(1236);
      setAssignmentsClause();
      break;
    }

    case 3: {
      setState(1237);
      insertSelectClause();
      break;
    }

    }
    setState(1241);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ON) {
      setState(1240);
      onDuplicateKeyClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::InsertSpecificationContext::InsertSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::InsertSpecificationContext::IGNORE() {
  return getToken(MySQLStatementParser::IGNORE, 0);
}

tree::TerminalNode* MySQLStatementParser::InsertSpecificationContext::LOW_PRIORITY() {
  return getToken(MySQLStatementParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::InsertSpecificationContext::DELAYED() {
  return getToken(MySQLStatementParser::DELAYED, 0);
}

tree::TerminalNode* MySQLStatementParser::InsertSpecificationContext::HIGH_PRIORITY() {
  return getToken(MySQLStatementParser::HIGH_PRIORITY, 0);
}


size_t MySQLStatementParser::InsertSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInsertSpecification;
}

void MySQLStatementParser::InsertSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertSpecification(this);
}

void MySQLStatementParser::InsertSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertSpecification(this);
}


antlrcpp::Any MySQLStatementParser::InsertSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInsertSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InsertSpecificationContext* MySQLStatementParser::insertSpecification() {
  InsertSpecificationContext *_localctx = _tracker.createInstance<InsertSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 4, MySQLStatementParser::RuleInsertSpecification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1244);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DELAYED || _la == MySQLStatementParser::HIGH_PRIORITY || _la == MySQLStatementParser::LOW_PRIORITY) {
      setState(1243);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DELAYED || _la == MySQLStatementParser::HIGH_PRIORITY || _la == MySQLStatementParser::LOW_PRIORITY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1247);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE) {
      setState(1246);
      match(MySQLStatementParser::IGNORE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertValuesClauseContext ------------------------------------------------------------------

MySQLStatementParser::InsertValuesClauseContext::InsertValuesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::InsertValuesClauseContext::VALUES() {
  return getToken(MySQLStatementParser::VALUES, 0);
}

tree::TerminalNode* MySQLStatementParser::InsertValuesClauseContext::VALUE() {
  return getToken(MySQLStatementParser::VALUE, 0);
}

std::vector<MySQLStatementParser::AssignmentValuesContext *> MySQLStatementParser::InsertValuesClauseContext::assignmentValues() {
  return getRuleContexts<MySQLStatementParser::AssignmentValuesContext>();
}

MySQLStatementParser::AssignmentValuesContext* MySQLStatementParser::InsertValuesClauseContext::assignmentValues(size_t i) {
  return getRuleContext<MySQLStatementParser::AssignmentValuesContext>(i);
}

MySQLStatementParser::RowConstructorListContext* MySQLStatementParser::InsertValuesClauseContext::rowConstructorList() {
  return getRuleContext<MySQLStatementParser::RowConstructorListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::InsertValuesClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::InsertValuesClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::ValueReferenceContext* MySQLStatementParser::InsertValuesClauseContext::valueReference() {
  return getRuleContext<MySQLStatementParser::ValueReferenceContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::InsertValuesClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::InsertValuesClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

MySQLStatementParser::FieldsContext* MySQLStatementParser::InsertValuesClauseContext::fields() {
  return getRuleContext<MySQLStatementParser::FieldsContext>(0);
}


size_t MySQLStatementParser::InsertValuesClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInsertValuesClause;
}

void MySQLStatementParser::InsertValuesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertValuesClause(this);
}

void MySQLStatementParser::InsertValuesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertValuesClause(this);
}


antlrcpp::Any MySQLStatementParser::InsertValuesClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInsertValuesClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InsertValuesClauseContext* MySQLStatementParser::insertValuesClause() {
  InsertValuesClauseContext *_localctx = _tracker.createInstance<InsertValuesClauseContext>(_ctx, getState());
  enterRule(_localctx, 6, MySQLStatementParser::RuleInsertValuesClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1254);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(1249);
      match(MySQLStatementParser::LP_);
      setState(1251);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(1250);
        fields();
      }
      setState(1253);
      match(MySQLStatementParser::RP_);
    }
    setState(1256);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::VALUE

    || _la == MySQLStatementParser::VALUES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1266);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::LP_: {
        setState(1257);
        assignmentValues();
        setState(1262);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(1258);
          match(MySQLStatementParser::COMMA_);
          setState(1259);
          assignmentValues();
          setState(1264);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::ROW: {
        setState(1265);
        rowConstructorList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1269);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(1268);
      valueReference();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldsContext ------------------------------------------------------------------

MySQLStatementParser::FieldsContext::FieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::InsertIdentifierContext *> MySQLStatementParser::FieldsContext::insertIdentifier() {
  return getRuleContexts<MySQLStatementParser::InsertIdentifierContext>();
}

MySQLStatementParser::InsertIdentifierContext* MySQLStatementParser::FieldsContext::insertIdentifier(size_t i) {
  return getRuleContext<MySQLStatementParser::InsertIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::FieldsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::FieldsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::FieldsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFields;
}

void MySQLStatementParser::FieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFields(this);
}

void MySQLStatementParser::FieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFields(this);
}


antlrcpp::Any MySQLStatementParser::FieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFields(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FieldsContext* MySQLStatementParser::fields() {
  FieldsContext *_localctx = _tracker.createInstance<FieldsContext>(_ctx, getState());
  enterRule(_localctx, 8, MySQLStatementParser::RuleFields);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1271);
    insertIdentifier();
    setState(1276);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1272);
      match(MySQLStatementParser::COMMA_);
      setState(1273);
      insertIdentifier();
      setState(1278);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertIdentifierContext ------------------------------------------------------------------

MySQLStatementParser::InsertIdentifierContext::InsertIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ColumnRefContext* MySQLStatementParser::InsertIdentifierContext::columnRef() {
  return getRuleContext<MySQLStatementParser::ColumnRefContext>(0);
}

MySQLStatementParser::TableWildContext* MySQLStatementParser::InsertIdentifierContext::tableWild() {
  return getRuleContext<MySQLStatementParser::TableWildContext>(0);
}


size_t MySQLStatementParser::InsertIdentifierContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInsertIdentifier;
}

void MySQLStatementParser::InsertIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertIdentifier(this);
}

void MySQLStatementParser::InsertIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertIdentifier(this);
}


antlrcpp::Any MySQLStatementParser::InsertIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInsertIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InsertIdentifierContext* MySQLStatementParser::insertIdentifier() {
  InsertIdentifierContext *_localctx = _tracker.createInstance<InsertIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 10, MySQLStatementParser::RuleInsertIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1281);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1279);
      columnRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1280);
      tableWild();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableWildContext ------------------------------------------------------------------

MySQLStatementParser::TableWildContext::TableWildContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::TableWildContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::TableWildContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableWildContext::DOT_() {
  return getTokens(MySQLStatementParser::DOT_);
}

tree::TerminalNode* MySQLStatementParser::TableWildContext::DOT_(size_t i) {
  return getToken(MySQLStatementParser::DOT_, i);
}

tree::TerminalNode* MySQLStatementParser::TableWildContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}


size_t MySQLStatementParser::TableWildContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableWild;
}

void MySQLStatementParser::TableWildContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableWild(this);
}

void MySQLStatementParser::TableWildContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableWild(this);
}


antlrcpp::Any MySQLStatementParser::TableWildContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableWild(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableWildContext* MySQLStatementParser::tableWild() {
  TableWildContext *_localctx = _tracker.createInstance<TableWildContext>(_ctx, getState());
  enterRule(_localctx, 12, MySQLStatementParser::RuleTableWild);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1283);
    identifier();
    setState(1284);
    match(MySQLStatementParser::DOT_);
    setState(1288);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(1285);
      identifier();
      setState(1286);
      match(MySQLStatementParser::DOT_);
    }
    setState(1290);
    match(MySQLStatementParser::ASTERISK_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertSelectClauseContext ------------------------------------------------------------------

MySQLStatementParser::InsertSelectClauseContext::InsertSelectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SelectContext* MySQLStatementParser::InsertSelectClauseContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

MySQLStatementParser::ValueReferenceContext* MySQLStatementParser::InsertSelectClauseContext::valueReference() {
  return getRuleContext<MySQLStatementParser::ValueReferenceContext>(0);
}

tree::TerminalNode* MySQLStatementParser::InsertSelectClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::InsertSelectClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::FieldsContext* MySQLStatementParser::InsertSelectClauseContext::fields() {
  return getRuleContext<MySQLStatementParser::FieldsContext>(0);
}


size_t MySQLStatementParser::InsertSelectClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInsertSelectClause;
}

void MySQLStatementParser::InsertSelectClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertSelectClause(this);
}

void MySQLStatementParser::InsertSelectClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertSelectClause(this);
}


antlrcpp::Any MySQLStatementParser::InsertSelectClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInsertSelectClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InsertSelectClauseContext* MySQLStatementParser::insertSelectClause() {
  InsertSelectClauseContext *_localctx = _tracker.createInstance<InsertSelectClauseContext>(_ctx, getState());
  enterRule(_localctx, 14, MySQLStatementParser::RuleInsertSelectClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(1292);
      valueReference();
    }
    setState(1300);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(1295);
      match(MySQLStatementParser::LP_);
      setState(1297);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(1296);
        fields();
      }
      setState(1299);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
    setState(1302);
    select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnDuplicateKeyClauseContext ------------------------------------------------------------------

MySQLStatementParser::OnDuplicateKeyClauseContext::OnDuplicateKeyClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OnDuplicateKeyClauseContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

tree::TerminalNode* MySQLStatementParser::OnDuplicateKeyClauseContext::DUPLICATE() {
  return getToken(MySQLStatementParser::DUPLICATE, 0);
}

tree::TerminalNode* MySQLStatementParser::OnDuplicateKeyClauseContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::OnDuplicateKeyClauseContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

std::vector<MySQLStatementParser::AssignmentContext *> MySQLStatementParser::OnDuplicateKeyClauseContext::assignment() {
  return getRuleContexts<MySQLStatementParser::AssignmentContext>();
}

MySQLStatementParser::AssignmentContext* MySQLStatementParser::OnDuplicateKeyClauseContext::assignment(size_t i) {
  return getRuleContext<MySQLStatementParser::AssignmentContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::OnDuplicateKeyClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::OnDuplicateKeyClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::OnDuplicateKeyClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOnDuplicateKeyClause;
}

void MySQLStatementParser::OnDuplicateKeyClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnDuplicateKeyClause(this);
}

void MySQLStatementParser::OnDuplicateKeyClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnDuplicateKeyClause(this);
}


antlrcpp::Any MySQLStatementParser::OnDuplicateKeyClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOnDuplicateKeyClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OnDuplicateKeyClauseContext* MySQLStatementParser::onDuplicateKeyClause() {
  OnDuplicateKeyClauseContext *_localctx = _tracker.createInstance<OnDuplicateKeyClauseContext>(_ctx, getState());
  enterRule(_localctx, 16, MySQLStatementParser::RuleOnDuplicateKeyClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1304);
    match(MySQLStatementParser::ON);
    setState(1305);
    match(MySQLStatementParser::DUPLICATE);
    setState(1306);
    match(MySQLStatementParser::KEY);
    setState(1307);
    match(MySQLStatementParser::UPDATE);
    setState(1308);
    assignment();
    setState(1313);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1309);
      match(MySQLStatementParser::COMMA_);
      setState(1310);
      assignment();
      setState(1315);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueReferenceContext ------------------------------------------------------------------

MySQLStatementParser::ValueReferenceContext::ValueReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ValueReferenceContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::AliasContext* MySQLStatementParser::ValueReferenceContext::alias() {
  return getRuleContext<MySQLStatementParser::AliasContext>(0);
}

MySQLStatementParser::DerivedColumnsContext* MySQLStatementParser::ValueReferenceContext::derivedColumns() {
  return getRuleContext<MySQLStatementParser::DerivedColumnsContext>(0);
}


size_t MySQLStatementParser::ValueReferenceContext::getRuleIndex() const {
  return MySQLStatementParser::RuleValueReference;
}

void MySQLStatementParser::ValueReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueReference(this);
}

void MySQLStatementParser::ValueReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueReference(this);
}


antlrcpp::Any MySQLStatementParser::ValueReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitValueReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ValueReferenceContext* MySQLStatementParser::valueReference() {
  ValueReferenceContext *_localctx = _tracker.createInstance<ValueReferenceContext>(_ctx, getState());
  enterRule(_localctx, 18, MySQLStatementParser::RuleValueReference);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1316);
    match(MySQLStatementParser::AS);
    setState(1317);
    alias();
    setState(1319);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(1318);
      derivedColumns();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DerivedColumnsContext ------------------------------------------------------------------

MySQLStatementParser::DerivedColumnsContext::DerivedColumnsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DerivedColumnsContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::AliasContext *> MySQLStatementParser::DerivedColumnsContext::alias() {
  return getRuleContexts<MySQLStatementParser::AliasContext>();
}

MySQLStatementParser::AliasContext* MySQLStatementParser::DerivedColumnsContext::alias(size_t i) {
  return getRuleContext<MySQLStatementParser::AliasContext>(i);
}

tree::TerminalNode* MySQLStatementParser::DerivedColumnsContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DerivedColumnsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::DerivedColumnsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::DerivedColumnsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDerivedColumns;
}

void MySQLStatementParser::DerivedColumnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerivedColumns(this);
}

void MySQLStatementParser::DerivedColumnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerivedColumns(this);
}


antlrcpp::Any MySQLStatementParser::DerivedColumnsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDerivedColumns(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DerivedColumnsContext* MySQLStatementParser::derivedColumns() {
  DerivedColumnsContext *_localctx = _tracker.createInstance<DerivedColumnsContext>(_ctx, getState());
  enterRule(_localctx, 20, MySQLStatementParser::RuleDerivedColumns);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1321);
    match(MySQLStatementParser::LP_);
    setState(1322);
    alias();
    setState(1327);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1323);
      match(MySQLStatementParser::COMMA_);
      setState(1324);
      alias();
      setState(1329);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1330);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceContext ------------------------------------------------------------------

MySQLStatementParser::ReplaceContext::ReplaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ReplaceContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::ReplaceContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::ReplaceValuesClauseContext* MySQLStatementParser::ReplaceContext::replaceValuesClause() {
  return getRuleContext<MySQLStatementParser::ReplaceValuesClauseContext>(0);
}

MySQLStatementParser::SetAssignmentsClauseContext* MySQLStatementParser::ReplaceContext::setAssignmentsClause() {
  return getRuleContext<MySQLStatementParser::SetAssignmentsClauseContext>(0);
}

MySQLStatementParser::ReplaceSelectClauseContext* MySQLStatementParser::ReplaceContext::replaceSelectClause() {
  return getRuleContext<MySQLStatementParser::ReplaceSelectClauseContext>(0);
}

MySQLStatementParser::ReplaceSpecificationContext* MySQLStatementParser::ReplaceContext::replaceSpecification() {
  return getRuleContext<MySQLStatementParser::ReplaceSpecificationContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ReplaceContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

MySQLStatementParser::PartitionNamesContext* MySQLStatementParser::ReplaceContext::partitionNames() {
  return getRuleContext<MySQLStatementParser::PartitionNamesContext>(0);
}


size_t MySQLStatementParser::ReplaceContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReplace;
}

void MySQLStatementParser::ReplaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplace(this);
}

void MySQLStatementParser::ReplaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplace(this);
}


antlrcpp::Any MySQLStatementParser::ReplaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReplace(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReplaceContext* MySQLStatementParser::replace() {
  ReplaceContext *_localctx = _tracker.createInstance<ReplaceContext>(_ctx, getState());
  enterRule(_localctx, 22, MySQLStatementParser::RuleReplace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1332);
    match(MySQLStatementParser::REPLACE);
    setState(1334);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DELAYED || _la == MySQLStatementParser::LOW_PRIORITY) {
      setState(1333);
      replaceSpecification();
    }
    setState(1337);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::INTO) {
      setState(1336);
      match(MySQLStatementParser::INTO);
    }
    setState(1339);
    tableName();
    setState(1341);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PARTITION) {
      setState(1340);
      partitionNames();
    }
    setState(1346);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(1343);
      replaceValuesClause();
      break;
    }

    case 2: {
      setState(1344);
      setAssignmentsClause();
      break;
    }

    case 3: {
      setState(1345);
      replaceSelectClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::ReplaceSpecificationContext::ReplaceSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ReplaceSpecificationContext::LOW_PRIORITY() {
  return getToken(MySQLStatementParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::ReplaceSpecificationContext::DELAYED() {
  return getToken(MySQLStatementParser::DELAYED, 0);
}


size_t MySQLStatementParser::ReplaceSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReplaceSpecification;
}

void MySQLStatementParser::ReplaceSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplaceSpecification(this);
}

void MySQLStatementParser::ReplaceSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplaceSpecification(this);
}


antlrcpp::Any MySQLStatementParser::ReplaceSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReplaceSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReplaceSpecificationContext* MySQLStatementParser::replaceSpecification() {
  ReplaceSpecificationContext *_localctx = _tracker.createInstance<ReplaceSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 24, MySQLStatementParser::RuleReplaceSpecification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1348);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DELAYED || _la == MySQLStatementParser::LOW_PRIORITY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceValuesClauseContext ------------------------------------------------------------------

MySQLStatementParser::ReplaceValuesClauseContext::ReplaceValuesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ReplaceValuesClauseContext::VALUES() {
  return getToken(MySQLStatementParser::VALUES, 0);
}

tree::TerminalNode* MySQLStatementParser::ReplaceValuesClauseContext::VALUE() {
  return getToken(MySQLStatementParser::VALUE, 0);
}

std::vector<MySQLStatementParser::AssignmentValuesContext *> MySQLStatementParser::ReplaceValuesClauseContext::assignmentValues() {
  return getRuleContexts<MySQLStatementParser::AssignmentValuesContext>();
}

MySQLStatementParser::AssignmentValuesContext* MySQLStatementParser::ReplaceValuesClauseContext::assignmentValues(size_t i) {
  return getRuleContext<MySQLStatementParser::AssignmentValuesContext>(i);
}

MySQLStatementParser::RowConstructorListContext* MySQLStatementParser::ReplaceValuesClauseContext::rowConstructorList() {
  return getRuleContext<MySQLStatementParser::RowConstructorListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ReplaceValuesClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ReplaceValuesClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::ValueReferenceContext* MySQLStatementParser::ReplaceValuesClauseContext::valueReference() {
  return getRuleContext<MySQLStatementParser::ValueReferenceContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ReplaceValuesClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ReplaceValuesClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

MySQLStatementParser::FieldsContext* MySQLStatementParser::ReplaceValuesClauseContext::fields() {
  return getRuleContext<MySQLStatementParser::FieldsContext>(0);
}


size_t MySQLStatementParser::ReplaceValuesClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReplaceValuesClause;
}

void MySQLStatementParser::ReplaceValuesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplaceValuesClause(this);
}

void MySQLStatementParser::ReplaceValuesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplaceValuesClause(this);
}


antlrcpp::Any MySQLStatementParser::ReplaceValuesClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReplaceValuesClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReplaceValuesClauseContext* MySQLStatementParser::replaceValuesClause() {
  ReplaceValuesClauseContext *_localctx = _tracker.createInstance<ReplaceValuesClauseContext>(_ctx, getState());
  enterRule(_localctx, 26, MySQLStatementParser::RuleReplaceValuesClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1355);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(1350);
      match(MySQLStatementParser::LP_);
      setState(1352);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(1351);
        fields();
      }
      setState(1354);
      match(MySQLStatementParser::RP_);
    }
    setState(1357);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::VALUE

    || _la == MySQLStatementParser::VALUES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1367);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::LP_: {
        setState(1358);
        assignmentValues();
        setState(1363);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(1359);
          match(MySQLStatementParser::COMMA_);
          setState(1360);
          assignmentValues();
          setState(1365);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::ROW: {
        setState(1366);
        rowConstructorList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1370);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(1369);
      valueReference();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceSelectClauseContext ------------------------------------------------------------------

MySQLStatementParser::ReplaceSelectClauseContext::ReplaceSelectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SelectContext* MySQLStatementParser::ReplaceSelectClauseContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

MySQLStatementParser::ValueReferenceContext* MySQLStatementParser::ReplaceSelectClauseContext::valueReference() {
  return getRuleContext<MySQLStatementParser::ValueReferenceContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ReplaceSelectClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ReplaceSelectClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::FieldsContext* MySQLStatementParser::ReplaceSelectClauseContext::fields() {
  return getRuleContext<MySQLStatementParser::FieldsContext>(0);
}


size_t MySQLStatementParser::ReplaceSelectClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReplaceSelectClause;
}

void MySQLStatementParser::ReplaceSelectClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplaceSelectClause(this);
}

void MySQLStatementParser::ReplaceSelectClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplaceSelectClause(this);
}


antlrcpp::Any MySQLStatementParser::ReplaceSelectClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReplaceSelectClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReplaceSelectClauseContext* MySQLStatementParser::replaceSelectClause() {
  ReplaceSelectClauseContext *_localctx = _tracker.createInstance<ReplaceSelectClauseContext>(_ctx, getState());
  enterRule(_localctx, 28, MySQLStatementParser::RuleReplaceSelectClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1373);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(1372);
      valueReference();
    }
    setState(1380);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(1375);
      match(MySQLStatementParser::LP_);
      setState(1377);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(1376);
        fields();
      }
      setState(1379);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
    setState(1382);
    select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateContext ------------------------------------------------------------------

MySQLStatementParser::UpdateContext::UpdateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UpdateContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

MySQLStatementParser::UpdateSpecification_Context* MySQLStatementParser::UpdateContext::updateSpecification_() {
  return getRuleContext<MySQLStatementParser::UpdateSpecification_Context>(0);
}

MySQLStatementParser::TableReferencesContext* MySQLStatementParser::UpdateContext::tableReferences() {
  return getRuleContext<MySQLStatementParser::TableReferencesContext>(0);
}

MySQLStatementParser::SetAssignmentsClauseContext* MySQLStatementParser::UpdateContext::setAssignmentsClause() {
  return getRuleContext<MySQLStatementParser::SetAssignmentsClauseContext>(0);
}

MySQLStatementParser::WithClauseContext* MySQLStatementParser::UpdateContext::withClause() {
  return getRuleContext<MySQLStatementParser::WithClauseContext>(0);
}

MySQLStatementParser::WhereClauseContext* MySQLStatementParser::UpdateContext::whereClause() {
  return getRuleContext<MySQLStatementParser::WhereClauseContext>(0);
}

MySQLStatementParser::OrderByClauseContext* MySQLStatementParser::UpdateContext::orderByClause() {
  return getRuleContext<MySQLStatementParser::OrderByClauseContext>(0);
}

MySQLStatementParser::LimitClauseContext* MySQLStatementParser::UpdateContext::limitClause() {
  return getRuleContext<MySQLStatementParser::LimitClauseContext>(0);
}


size_t MySQLStatementParser::UpdateContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUpdate;
}

void MySQLStatementParser::UpdateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate(this);
}

void MySQLStatementParser::UpdateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate(this);
}


antlrcpp::Any MySQLStatementParser::UpdateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUpdate(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UpdateContext* MySQLStatementParser::update() {
  UpdateContext *_localctx = _tracker.createInstance<UpdateContext>(_ctx, getState());
  enterRule(_localctx, 30, MySQLStatementParser::RuleUpdate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1385);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(1384);
      withClause();
    }
    setState(1387);
    match(MySQLStatementParser::UPDATE);
    setState(1388);
    updateSpecification_();
    setState(1389);
    tableReferences();
    setState(1390);
    setAssignmentsClause();
    setState(1392);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WHERE) {
      setState(1391);
      whereClause();
    }
    setState(1395);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ORDER) {
      setState(1394);
      orderByClause();
    }
    setState(1398);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(1397);
      limitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateSpecification_Context ------------------------------------------------------------------

MySQLStatementParser::UpdateSpecification_Context::UpdateSpecification_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UpdateSpecification_Context::LOW_PRIORITY() {
  return getToken(MySQLStatementParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::UpdateSpecification_Context::IGNORE() {
  return getToken(MySQLStatementParser::IGNORE, 0);
}


size_t MySQLStatementParser::UpdateSpecification_Context::getRuleIndex() const {
  return MySQLStatementParser::RuleUpdateSpecification_;
}

void MySQLStatementParser::UpdateSpecification_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateSpecification_(this);
}

void MySQLStatementParser::UpdateSpecification_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateSpecification_(this);
}


antlrcpp::Any MySQLStatementParser::UpdateSpecification_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUpdateSpecification_(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UpdateSpecification_Context* MySQLStatementParser::updateSpecification_() {
  UpdateSpecification_Context *_localctx = _tracker.createInstance<UpdateSpecification_Context>(_ctx, getState());
  enterRule(_localctx, 32, MySQLStatementParser::RuleUpdateSpecification_);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1401);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOW_PRIORITY) {
      setState(1400);
      match(MySQLStatementParser::LOW_PRIORITY);
    }
    setState(1404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE) {
      setState(1403);
      match(MySQLStatementParser::IGNORE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentContext ------------------------------------------------------------------

MySQLStatementParser::AssignmentContext::AssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ColumnRefContext* MySQLStatementParser::AssignmentContext::columnRef() {
  return getRuleContext<MySQLStatementParser::ColumnRefContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AssignmentContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::AssignmentValueContext* MySQLStatementParser::AssignmentContext::assignmentValue() {
  return getRuleContext<MySQLStatementParser::AssignmentValueContext>(0);
}


size_t MySQLStatementParser::AssignmentContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAssignment;
}

void MySQLStatementParser::AssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment(this);
}

void MySQLStatementParser::AssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment(this);
}


antlrcpp::Any MySQLStatementParser::AssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAssignment(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AssignmentContext* MySQLStatementParser::assignment() {
  AssignmentContext *_localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
  enterRule(_localctx, 34, MySQLStatementParser::RuleAssignment);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1406);
    columnRef();
    setState(1407);
    match(MySQLStatementParser::EQ_);
    setState(1408);
    assignmentValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetAssignmentsClauseContext ------------------------------------------------------------------

MySQLStatementParser::SetAssignmentsClauseContext::SetAssignmentsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetAssignmentsClauseContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

std::vector<MySQLStatementParser::AssignmentContext *> MySQLStatementParser::SetAssignmentsClauseContext::assignment() {
  return getRuleContexts<MySQLStatementParser::AssignmentContext>();
}

MySQLStatementParser::AssignmentContext* MySQLStatementParser::SetAssignmentsClauseContext::assignment(size_t i) {
  return getRuleContext<MySQLStatementParser::AssignmentContext>(i);
}

MySQLStatementParser::ValueReferenceContext* MySQLStatementParser::SetAssignmentsClauseContext::valueReference() {
  return getRuleContext<MySQLStatementParser::ValueReferenceContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetAssignmentsClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SetAssignmentsClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SetAssignmentsClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetAssignmentsClause;
}

void MySQLStatementParser::SetAssignmentsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetAssignmentsClause(this);
}

void MySQLStatementParser::SetAssignmentsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetAssignmentsClause(this);
}


antlrcpp::Any MySQLStatementParser::SetAssignmentsClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetAssignmentsClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetAssignmentsClauseContext* MySQLStatementParser::setAssignmentsClause() {
  SetAssignmentsClauseContext *_localctx = _tracker.createInstance<SetAssignmentsClauseContext>(_ctx, getState());
  enterRule(_localctx, 36, MySQLStatementParser::RuleSetAssignmentsClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1411);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(1410);
      valueReference();
    }
    setState(1413);
    match(MySQLStatementParser::SET);
    setState(1414);
    assignment();
    setState(1419);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1415);
      match(MySQLStatementParser::COMMA_);
      setState(1416);
      assignment();
      setState(1421);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentValuesContext ------------------------------------------------------------------

MySQLStatementParser::AssignmentValuesContext::AssignmentValuesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AssignmentValuesContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::AssignmentValueContext *> MySQLStatementParser::AssignmentValuesContext::assignmentValue() {
  return getRuleContexts<MySQLStatementParser::AssignmentValueContext>();
}

MySQLStatementParser::AssignmentValueContext* MySQLStatementParser::AssignmentValuesContext::assignmentValue(size_t i) {
  return getRuleContext<MySQLStatementParser::AssignmentValueContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AssignmentValuesContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AssignmentValuesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AssignmentValuesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::AssignmentValuesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAssignmentValues;
}

void MySQLStatementParser::AssignmentValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentValues(this);
}

void MySQLStatementParser::AssignmentValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentValues(this);
}


antlrcpp::Any MySQLStatementParser::AssignmentValuesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentValues(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AssignmentValuesContext* MySQLStatementParser::assignmentValues() {
  AssignmentValuesContext *_localctx = _tracker.createInstance<AssignmentValuesContext>(_ctx, getState());
  enterRule(_localctx, 38, MySQLStatementParser::RuleAssignmentValues);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1435);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1422);
      match(MySQLStatementParser::LP_);
      setState(1423);
      assignmentValue();
      setState(1428);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(1424);
        match(MySQLStatementParser::COMMA_);
        setState(1425);
        assignmentValue();
        setState(1430);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1431);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1433);
      match(MySQLStatementParser::LP_);
      setState(1434);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentValueContext ------------------------------------------------------------------

MySQLStatementParser::AssignmentValueContext::AssignmentValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ExprContext* MySQLStatementParser::AssignmentValueContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AssignmentValueContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

MySQLStatementParser::BlobValueContext* MySQLStatementParser::AssignmentValueContext::blobValue() {
  return getRuleContext<MySQLStatementParser::BlobValueContext>(0);
}


size_t MySQLStatementParser::AssignmentValueContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAssignmentValue;
}

void MySQLStatementParser::AssignmentValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentValue(this);
}

void MySQLStatementParser::AssignmentValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentValue(this);
}


antlrcpp::Any MySQLStatementParser::AssignmentValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AssignmentValueContext* MySQLStatementParser::assignmentValue() {
  AssignmentValueContext *_localctx = _tracker.createInstance<AssignmentValueContext>(_ctx, getState());
  enterRule(_localctx, 40, MySQLStatementParser::RuleAssignmentValue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1440);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1437);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1438);
      match(MySQLStatementParser::DEFAULT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1439);
      blobValue();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlobValueContext ------------------------------------------------------------------

MySQLStatementParser::BlobValueContext::BlobValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BlobValueContext::UL_BINARY() {
  return getToken(MySQLStatementParser::UL_BINARY, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::BlobValueContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::BlobValueContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBlobValue;
}

void MySQLStatementParser::BlobValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlobValue(this);
}

void MySQLStatementParser::BlobValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlobValue(this);
}


antlrcpp::Any MySQLStatementParser::BlobValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBlobValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BlobValueContext* MySQLStatementParser::blobValue() {
  BlobValueContext *_localctx = _tracker.createInstance<BlobValueContext>(_ctx, getState());
  enterRule(_localctx, 42, MySQLStatementParser::RuleBlobValue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1442);
    match(MySQLStatementParser::UL_BINARY);
    setState(1443);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

MySQLStatementParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::Delete_stmtContext::DELETE() {
  return getToken(MySQLStatementParser::DELETE, 0);
}

MySQLStatementParser::DeleteSpecificationContext* MySQLStatementParser::Delete_stmtContext::deleteSpecification() {
  return getRuleContext<MySQLStatementParser::DeleteSpecificationContext>(0);
}

MySQLStatementParser::SingleTableClauseContext* MySQLStatementParser::Delete_stmtContext::singleTableClause() {
  return getRuleContext<MySQLStatementParser::SingleTableClauseContext>(0);
}

MySQLStatementParser::MultipleTablesClauseContext* MySQLStatementParser::Delete_stmtContext::multipleTablesClause() {
  return getRuleContext<MySQLStatementParser::MultipleTablesClauseContext>(0);
}

MySQLStatementParser::WhereClauseContext* MySQLStatementParser::Delete_stmtContext::whereClause() {
  return getRuleContext<MySQLStatementParser::WhereClauseContext>(0);
}

MySQLStatementParser::OrderByClauseContext* MySQLStatementParser::Delete_stmtContext::orderByClause() {
  return getRuleContext<MySQLStatementParser::OrderByClauseContext>(0);
}

MySQLStatementParser::LimitClauseContext* MySQLStatementParser::Delete_stmtContext::limitClause() {
  return getRuleContext<MySQLStatementParser::LimitClauseContext>(0);
}


size_t MySQLStatementParser::Delete_stmtContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDelete_stmt;
}

void MySQLStatementParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void MySQLStatementParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


antlrcpp::Any MySQLStatementParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::Delete_stmtContext* MySQLStatementParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, MySQLStatementParser::RuleDelete_stmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1445);
    match(MySQLStatementParser::DELETE);
    setState(1446);
    deleteSpecification();
    setState(1449);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      setState(1447);
      singleTableClause();
      break;
    }

    case 2: {
      setState(1448);
      multipleTablesClause();
      break;
    }

    }
    setState(1452);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WHERE) {
      setState(1451);
      whereClause();
    }
    setState(1455);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ORDER) {
      setState(1454);
      orderByClause();
    }
    setState(1458);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(1457);
      limitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::DeleteSpecificationContext::DeleteSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DeleteSpecificationContext::LOW_PRIORITY() {
  return getToken(MySQLStatementParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::DeleteSpecificationContext::QUICK() {
  return getToken(MySQLStatementParser::QUICK, 0);
}

tree::TerminalNode* MySQLStatementParser::DeleteSpecificationContext::IGNORE() {
  return getToken(MySQLStatementParser::IGNORE, 0);
}


size_t MySQLStatementParser::DeleteSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDeleteSpecification;
}

void MySQLStatementParser::DeleteSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteSpecification(this);
}

void MySQLStatementParser::DeleteSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteSpecification(this);
}


antlrcpp::Any MySQLStatementParser::DeleteSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDeleteSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DeleteSpecificationContext* MySQLStatementParser::deleteSpecification() {
  DeleteSpecificationContext *_localctx = _tracker.createInstance<DeleteSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 46, MySQLStatementParser::RuleDeleteSpecification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1461);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOW_PRIORITY) {
      setState(1460);
      match(MySQLStatementParser::LOW_PRIORITY);
    }
    setState(1464);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      setState(1463);
      match(MySQLStatementParser::QUICK);
      break;
    }

    }
    setState(1467);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE) {
      setState(1466);
      match(MySQLStatementParser::IGNORE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleTableClauseContext ------------------------------------------------------------------

MySQLStatementParser::SingleTableClauseContext::SingleTableClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SingleTableClauseContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::SingleTableClauseContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::AliasContext* MySQLStatementParser::SingleTableClauseContext::alias() {
  return getRuleContext<MySQLStatementParser::AliasContext>(0);
}

MySQLStatementParser::PartitionNamesContext* MySQLStatementParser::SingleTableClauseContext::partitionNames() {
  return getRuleContext<MySQLStatementParser::PartitionNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SingleTableClauseContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}


size_t MySQLStatementParser::SingleTableClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSingleTableClause;
}

void MySQLStatementParser::SingleTableClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleTableClause(this);
}

void MySQLStatementParser::SingleTableClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleTableClause(this);
}


antlrcpp::Any MySQLStatementParser::SingleTableClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSingleTableClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SingleTableClauseContext* MySQLStatementParser::singleTableClause() {
  SingleTableClauseContext *_localctx = _tracker.createInstance<SingleTableClauseContext>(_ctx, getState());
  enterRule(_localctx, 48, MySQLStatementParser::RuleSingleTableClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1469);
    match(MySQLStatementParser::FROM);
    setState(1470);
    tableName();
    setState(1475);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      setState(1472);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::AS) {
        setState(1471);
        match(MySQLStatementParser::AS);
      }
      setState(1474);
      alias();
      break;
    }

    }
    setState(1478);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PARTITION) {
      setState(1477);
      partitionNames();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleTablesClauseContext ------------------------------------------------------------------

MySQLStatementParser::MultipleTablesClauseContext::MultipleTablesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableAliasRefListContext* MySQLStatementParser::MultipleTablesClauseContext::tableAliasRefList() {
  return getRuleContext<MySQLStatementParser::TableAliasRefListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::MultipleTablesClauseContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::TableReferencesContext* MySQLStatementParser::MultipleTablesClauseContext::tableReferences() {
  return getRuleContext<MySQLStatementParser::TableReferencesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::MultipleTablesClauseContext::USING() {
  return getToken(MySQLStatementParser::USING, 0);
}


size_t MySQLStatementParser::MultipleTablesClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleMultipleTablesClause;
}

void MySQLStatementParser::MultipleTablesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleTablesClause(this);
}

void MySQLStatementParser::MultipleTablesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleTablesClause(this);
}


antlrcpp::Any MySQLStatementParser::MultipleTablesClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitMultipleTablesClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::MultipleTablesClauseContext* MySQLStatementParser::multipleTablesClause() {
  MultipleTablesClauseContext *_localctx = _tracker.createInstance<MultipleTablesClauseContext>(_ctx, getState());
  enterRule(_localctx, 50, MySQLStatementParser::RuleMultipleTablesClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1489);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(1480);
        tableAliasRefList();
        setState(1481);
        match(MySQLStatementParser::FROM);
        setState(1482);
        tableReferences();
        break;
      }

      case MySQLStatementParser::FROM: {
        enterOuterAlt(_localctx, 2);
        setState(1484);
        match(MySQLStatementParser::FROM);
        setState(1485);
        tableAliasRefList();
        setState(1486);
        match(MySQLStatementParser::USING);
        setState(1487);
        tableReferences();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectContext ------------------------------------------------------------------

MySQLStatementParser::SelectContext::SelectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::QueryExpressionContext* MySQLStatementParser::SelectContext::queryExpression() {
  return getRuleContext<MySQLStatementParser::QueryExpressionContext>(0);
}

MySQLStatementParser::LockClauseListContext* MySQLStatementParser::SelectContext::lockClauseList() {
  return getRuleContext<MySQLStatementParser::LockClauseListContext>(0);
}

MySQLStatementParser::QueryExpressionParensContext* MySQLStatementParser::SelectContext::queryExpressionParens() {
  return getRuleContext<MySQLStatementParser::QueryExpressionParensContext>(0);
}

MySQLStatementParser::SelectWithIntoContext* MySQLStatementParser::SelectContext::selectWithInto() {
  return getRuleContext<MySQLStatementParser::SelectWithIntoContext>(0);
}


size_t MySQLStatementParser::SelectContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSelect;
}

void MySQLStatementParser::SelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect(this);
}

void MySQLStatementParser::SelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect(this);
}


antlrcpp::Any MySQLStatementParser::SelectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSelect(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SelectContext* MySQLStatementParser::select() {
  SelectContext *_localctx = _tracker.createInstance<SelectContext>(_ctx, getState());
  enterRule(_localctx, 52, MySQLStatementParser::RuleSelect);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1497);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1491);
      queryExpression();
      setState(1493);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::FOR || _la == MySQLStatementParser::LOCK) {
        setState(1492);
        lockClauseList();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1495);
      queryExpressionParens();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1496);
      selectWithInto();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectWithIntoContext ------------------------------------------------------------------

MySQLStatementParser::SelectWithIntoContext::SelectWithIntoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SelectWithIntoContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::SelectWithIntoContext* MySQLStatementParser::SelectWithIntoContext::selectWithInto() {
  return getRuleContext<MySQLStatementParser::SelectWithIntoContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SelectWithIntoContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::QueryExpressionContext* MySQLStatementParser::SelectWithIntoContext::queryExpression() {
  return getRuleContext<MySQLStatementParser::QueryExpressionContext>(0);
}

MySQLStatementParser::SelectIntoExpressionContext* MySQLStatementParser::SelectWithIntoContext::selectIntoExpression() {
  return getRuleContext<MySQLStatementParser::SelectIntoExpressionContext>(0);
}

MySQLStatementParser::LockClauseListContext* MySQLStatementParser::SelectWithIntoContext::lockClauseList() {
  return getRuleContext<MySQLStatementParser::LockClauseListContext>(0);
}


size_t MySQLStatementParser::SelectWithIntoContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSelectWithInto;
}

void MySQLStatementParser::SelectWithIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectWithInto(this);
}

void MySQLStatementParser::SelectWithIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectWithInto(this);
}


antlrcpp::Any MySQLStatementParser::SelectWithIntoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSelectWithInto(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SelectWithIntoContext* MySQLStatementParser::selectWithInto() {
  SelectWithIntoContext *_localctx = _tracker.createInstance<SelectWithIntoContext>(_ctx, getState());
  enterRule(_localctx, 54, MySQLStatementParser::RuleSelectWithInto);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1512);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1499);
      match(MySQLStatementParser::LP_);
      setState(1500);
      selectWithInto();
      setState(1501);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1503);
      queryExpression();
      setState(1504);
      selectIntoExpression();
      setState(1506);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::FOR || _la == MySQLStatementParser::LOCK) {
        setState(1505);
        lockClauseList();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1508);
      queryExpression();
      setState(1509);
      lockClauseList();
      setState(1510);
      selectIntoExpression();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionContext ------------------------------------------------------------------

MySQLStatementParser::QueryExpressionContext::QueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::QueryExpressionBodyContext* MySQLStatementParser::QueryExpressionContext::queryExpressionBody() {
  return getRuleContext<MySQLStatementParser::QueryExpressionBodyContext>(0);
}

MySQLStatementParser::QueryExpressionParensContext* MySQLStatementParser::QueryExpressionContext::queryExpressionParens() {
  return getRuleContext<MySQLStatementParser::QueryExpressionParensContext>(0);
}

MySQLStatementParser::WithClauseContext* MySQLStatementParser::QueryExpressionContext::withClause() {
  return getRuleContext<MySQLStatementParser::WithClauseContext>(0);
}

MySQLStatementParser::OrderByClauseContext* MySQLStatementParser::QueryExpressionContext::orderByClause() {
  return getRuleContext<MySQLStatementParser::OrderByClauseContext>(0);
}

MySQLStatementParser::LimitClauseContext* MySQLStatementParser::QueryExpressionContext::limitClause() {
  return getRuleContext<MySQLStatementParser::LimitClauseContext>(0);
}


size_t MySQLStatementParser::QueryExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleQueryExpression;
}

void MySQLStatementParser::QueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpression(this);
}

void MySQLStatementParser::QueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpression(this);
}


antlrcpp::Any MySQLStatementParser::QueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::QueryExpressionContext* MySQLStatementParser::queryExpression() {
  QueryExpressionContext *_localctx = _tracker.createInstance<QueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 56, MySQLStatementParser::RuleQueryExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1515);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(1514);
      withClause();
    }
    setState(1519);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(1517);
      queryExpressionBody(0);
      break;
    }

    case 2: {
      setState(1518);
      queryExpressionParens();
      break;
    }

    }
    setState(1522);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ORDER) {
      setState(1521);
      orderByClause();
    }
    setState(1525);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(1524);
      limitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionBodyContext ------------------------------------------------------------------

MySQLStatementParser::QueryExpressionBodyContext::QueryExpressionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::QueryPrimaryContext* MySQLStatementParser::QueryExpressionBodyContext::queryPrimary() {
  return getRuleContext<MySQLStatementParser::QueryPrimaryContext>(0);
}

std::vector<MySQLStatementParser::QueryExpressionParensContext *> MySQLStatementParser::QueryExpressionBodyContext::queryExpressionParens() {
  return getRuleContexts<MySQLStatementParser::QueryExpressionParensContext>();
}

MySQLStatementParser::QueryExpressionParensContext* MySQLStatementParser::QueryExpressionBodyContext::queryExpressionParens(size_t i) {
  return getRuleContext<MySQLStatementParser::QueryExpressionParensContext>(i);
}

tree::TerminalNode* MySQLStatementParser::QueryExpressionBodyContext::UNION() {
  return getToken(MySQLStatementParser::UNION, 0);
}

MySQLStatementParser::UnionOptionContext* MySQLStatementParser::QueryExpressionBodyContext::unionOption() {
  return getRuleContext<MySQLStatementParser::UnionOptionContext>(0);
}

MySQLStatementParser::QueryExpressionBodyContext* MySQLStatementParser::QueryExpressionBodyContext::queryExpressionBody() {
  return getRuleContext<MySQLStatementParser::QueryExpressionBodyContext>(0);
}


size_t MySQLStatementParser::QueryExpressionBodyContext::getRuleIndex() const {
  return MySQLStatementParser::RuleQueryExpressionBody;
}

void MySQLStatementParser::QueryExpressionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionBody(this);
}

void MySQLStatementParser::QueryExpressionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionBody(this);
}


antlrcpp::Any MySQLStatementParser::QueryExpressionBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpressionBody(this);
  else
    return visitor->visitChildren(this);
}


MySQLStatementParser::QueryExpressionBodyContext* MySQLStatementParser::queryExpressionBody() {
   return queryExpressionBody(0);
}

MySQLStatementParser::QueryExpressionBodyContext* MySQLStatementParser::queryExpressionBody(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLStatementParser::QueryExpressionBodyContext *_localctx = _tracker.createInstance<QueryExpressionBodyContext>(_ctx, parentState);
  MySQLStatementParser::QueryExpressionBodyContext *previousContext = _localctx;
  size_t startState = 58;
  enterRecursionRule(_localctx, 58, MySQLStatementParser::RuleQueryExpressionBody, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1538);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SELECT:
      case MySQLStatementParser::TABLE:
      case MySQLStatementParser::VALUES: {
        setState(1528);
        queryPrimary();
        break;
      }

      case MySQLStatementParser::LP_: {
        setState(1529);
        queryExpressionParens();
        setState(1530);
        match(MySQLStatementParser::UNION);
        setState(1532);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ALL || _la == MySQLStatementParser::DISTINCT) {
          setState(1531);
          unionOption();
        }
        setState(1536);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLStatementParser::SELECT:
          case MySQLStatementParser::TABLE:
          case MySQLStatementParser::VALUES: {
            setState(1534);
            queryPrimary();
            break;
          }

          case MySQLStatementParser::LP_: {
            setState(1535);
            queryExpressionParens();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(1551);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<QueryExpressionBodyContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleQueryExpressionBody);
        setState(1540);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(1541);
        match(MySQLStatementParser::UNION);
        setState(1543);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ALL || _la == MySQLStatementParser::DISTINCT) {
          setState(1542);
          unionOption();
        }
        setState(1547);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLStatementParser::SELECT:
          case MySQLStatementParser::TABLE:
          case MySQLStatementParser::VALUES: {
            setState(1545);
            queryPrimary();
            break;
          }

          case MySQLStatementParser::LP_: {
            setState(1546);
            queryExpressionParens();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(1553);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QueryExpressionParensContext ------------------------------------------------------------------

MySQLStatementParser::QueryExpressionParensContext::QueryExpressionParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::QueryExpressionParensContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::QueryExpressionParensContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::QueryExpressionParensContext* MySQLStatementParser::QueryExpressionParensContext::queryExpressionParens() {
  return getRuleContext<MySQLStatementParser::QueryExpressionParensContext>(0);
}

MySQLStatementParser::QueryExpressionContext* MySQLStatementParser::QueryExpressionParensContext::queryExpression() {
  return getRuleContext<MySQLStatementParser::QueryExpressionContext>(0);
}

MySQLStatementParser::LockClauseListContext* MySQLStatementParser::QueryExpressionParensContext::lockClauseList() {
  return getRuleContext<MySQLStatementParser::LockClauseListContext>(0);
}


size_t MySQLStatementParser::QueryExpressionParensContext::getRuleIndex() const {
  return MySQLStatementParser::RuleQueryExpressionParens;
}

void MySQLStatementParser::QueryExpressionParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionParens(this);
}

void MySQLStatementParser::QueryExpressionParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionParens(this);
}


antlrcpp::Any MySQLStatementParser::QueryExpressionParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpressionParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::QueryExpressionParensContext* MySQLStatementParser::queryExpressionParens() {
  QueryExpressionParensContext *_localctx = _tracker.createInstance<QueryExpressionParensContext>(_ctx, getState());
  enterRule(_localctx, 60, MySQLStatementParser::RuleQueryExpressionParens);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1554);
    match(MySQLStatementParser::LP_);
    setState(1560);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(1555);
      queryExpressionParens();
      break;
    }

    case 2: {
      setState(1556);
      queryExpression();
      setState(1558);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::FOR || _la == MySQLStatementParser::LOCK) {
        setState(1557);
        lockClauseList();
      }
      break;
    }

    }
    setState(1562);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

MySQLStatementParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::QuerySpecificationContext* MySQLStatementParser::QueryPrimaryContext::querySpecification() {
  return getRuleContext<MySQLStatementParser::QuerySpecificationContext>(0);
}

MySQLStatementParser::TableValueConstructorContext* MySQLStatementParser::QueryPrimaryContext::tableValueConstructor() {
  return getRuleContext<MySQLStatementParser::TableValueConstructorContext>(0);
}

MySQLStatementParser::ExplicitTableContext* MySQLStatementParser::QueryPrimaryContext::explicitTable() {
  return getRuleContext<MySQLStatementParser::ExplicitTableContext>(0);
}


size_t MySQLStatementParser::QueryPrimaryContext::getRuleIndex() const {
  return MySQLStatementParser::RuleQueryPrimary;
}

void MySQLStatementParser::QueryPrimaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryPrimary(this);
}

void MySQLStatementParser::QueryPrimaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryPrimary(this);
}


antlrcpp::Any MySQLStatementParser::QueryPrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitQueryPrimary(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::QueryPrimaryContext* MySQLStatementParser::queryPrimary() {
  QueryPrimaryContext *_localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 62, MySQLStatementParser::RuleQueryPrimary);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1567);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SELECT: {
        enterOuterAlt(_localctx, 1);
        setState(1564);
        querySpecification();
        break;
      }

      case MySQLStatementParser::VALUES: {
        enterOuterAlt(_localctx, 2);
        setState(1565);
        tableValueConstructor();
        break;
      }

      case MySQLStatementParser::TABLE: {
        enterOuterAlt(_localctx, 3);
        setState(1566);
        explicitTable();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

MySQLStatementParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::QuerySpecificationContext::SELECT() {
  return getToken(MySQLStatementParser::SELECT, 0);
}

MySQLStatementParser::ProjectionsContext* MySQLStatementParser::QuerySpecificationContext::projections() {
  return getRuleContext<MySQLStatementParser::ProjectionsContext>(0);
}

std::vector<MySQLStatementParser::SelectSpecificationContext *> MySQLStatementParser::QuerySpecificationContext::selectSpecification() {
  return getRuleContexts<MySQLStatementParser::SelectSpecificationContext>();
}

MySQLStatementParser::SelectSpecificationContext* MySQLStatementParser::QuerySpecificationContext::selectSpecification(size_t i) {
  return getRuleContext<MySQLStatementParser::SelectSpecificationContext>(i);
}

MySQLStatementParser::SelectIntoExpressionContext* MySQLStatementParser::QuerySpecificationContext::selectIntoExpression() {
  return getRuleContext<MySQLStatementParser::SelectIntoExpressionContext>(0);
}

MySQLStatementParser::FromClauseContext* MySQLStatementParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<MySQLStatementParser::FromClauseContext>(0);
}

MySQLStatementParser::WhereClauseContext* MySQLStatementParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<MySQLStatementParser::WhereClauseContext>(0);
}

MySQLStatementParser::GroupByClauseContext* MySQLStatementParser::QuerySpecificationContext::groupByClause() {
  return getRuleContext<MySQLStatementParser::GroupByClauseContext>(0);
}

MySQLStatementParser::HavingClauseContext* MySQLStatementParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<MySQLStatementParser::HavingClauseContext>(0);
}

MySQLStatementParser::WindowClauseContext* MySQLStatementParser::QuerySpecificationContext::windowClause() {
  return getRuleContext<MySQLStatementParser::WindowClauseContext>(0);
}


size_t MySQLStatementParser::QuerySpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleQuerySpecification;
}

void MySQLStatementParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void MySQLStatementParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}


antlrcpp::Any MySQLStatementParser::QuerySpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitQuerySpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::QuerySpecificationContext* MySQLStatementParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 64, MySQLStatementParser::RuleQuerySpecification);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1569);
    match(MySQLStatementParser::SELECT);
    setState(1573);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1570);
        selectSpecification(); 
      }
      setState(1575);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);
    }
    setState(1576);
    projections();
    setState(1578);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(1577);
      selectIntoExpression();
      break;
    }

    }
    setState(1581);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      setState(1580);
      fromClause();
      break;
    }

    }
    setState(1584);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(1583);
      whereClause();
      break;
    }

    }
    setState(1587);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(1586);
      groupByClause();
      break;
    }

    }
    setState(1590);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(1589);
      havingClause();
      break;
    }

    }
    setState(1593);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(1592);
      windowClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallContext ------------------------------------------------------------------

MySQLStatementParser::CallContext::CallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CallContext::CALL() {
  return getToken(MySQLStatementParser::CALL, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CallContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CallContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CallContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::CallContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CallContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CallContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CallContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::CallContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCall;
}

void MySQLStatementParser::CallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall(this);
}

void MySQLStatementParser::CallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall(this);
}


antlrcpp::Any MySQLStatementParser::CallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CallContext* MySQLStatementParser::call() {
  CallContext *_localctx = _tracker.createInstance<CallContext>(_ctx, getState());
  enterRule(_localctx, 66, MySQLStatementParser::RuleCall);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1595);
    match(MySQLStatementParser::CALL);
    setState(1596);
    identifier();
    setState(1609);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      setState(1597);
      match(MySQLStatementParser::LP_);
      setState(1606);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINARY)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CASE - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHAR - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CONVERT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CUME_DIST - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURRENT_DATE - 65))
        | (1ULL << (MySQLStatementParser::CURRENT_TIME - 65))
        | (1ULL << (MySQLStatementParser::CURRENT_TIMESTAMP - 65))
        | (1ULL << (MySQLStatementParser::CURRENT_USER - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATABASE - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DENSE_RANK - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXISTS - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FALSE - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIRST_VALUE - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IF - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INTERVAL - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LAG - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LAST_VALUE - 259))
        | (1ULL << (MySQLStatementParser::LEAD - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LEFT - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCALTIME - 324))
        | (1ULL << (MySQLStatementParser::LOCALTIMESTAMP - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MATCH - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MOD - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOT - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NTH_VALUE - 388))
        | (1ULL << (MySQLStatementParser::NTILE - 388))
        | (1ULL << (MySQLStatementParser::NULL - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERCENT_RANK - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::RANK - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLACE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::RIGHT - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::ROW_NUMBER - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUE - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VALUES - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710))
        | (1ULL << (MySQLStatementParser::NOT_ - 710))
        | (1ULL << (MySQLStatementParser::TILDE_ - 710))
        | (1ULL << (MySQLStatementParser::PLUS_ - 710))
        | (1ULL << (MySQLStatementParser::MINUS_ - 710))
        | (1ULL << (MySQLStatementParser::DOT_ - 710))
        | (1ULL << (MySQLStatementParser::LP_ - 710))
        | (1ULL << (MySQLStatementParser::LBE_ - 710))
        | (1ULL << (MySQLStatementParser::QUESTION_ - 710))
        | (1ULL << (MySQLStatementParser::AT_ - 710)))) != 0) || ((((_la - 780) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 780)) & ((1ULL << (MySQLStatementParser::IDENTIFIER_ - 780))
        | (1ULL << (MySQLStatementParser::SINGLE_QUOTED_TEXT - 780))
        | (1ULL << (MySQLStatementParser::DOUBLE_QUOTED_TEXT - 780))
        | (1ULL << (MySQLStatementParser::NCHAR_TEXT - 780))
        | (1ULL << (MySQLStatementParser::UNDERSCORE_CHARSET - 780))
        | (1ULL << (MySQLStatementParser::NUMBER_ - 780))
        | (1ULL << (MySQLStatementParser::HEX_DIGIT_ - 780))
        | (1ULL << (MySQLStatementParser::BIT_NUM_ - 780)))) != 0)) {
        setState(1598);
        expr(0);
        setState(1603);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(1599);
          match(MySQLStatementParser::COMMA_);
          setState(1600);
          expr(0);
          setState(1605);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(1608);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoStatementContext ------------------------------------------------------------------

MySQLStatementParser::DoStatementContext::DoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DoStatementContext::DO() {
  return getToken(MySQLStatementParser::DO, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::DoStatementContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::DoStatementContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DoStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::DoStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::DoStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDoStatement;
}

void MySQLStatementParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}

void MySQLStatementParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}


antlrcpp::Any MySQLStatementParser::DoStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDoStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DoStatementContext* MySQLStatementParser::doStatement() {
  DoStatementContext *_localctx = _tracker.createInstance<DoStatementContext>(_ctx, getState());
  enterRule(_localctx, 68, MySQLStatementParser::RuleDoStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1611);
    match(MySQLStatementParser::DO);
    setState(1612);
    expr(0);
    setState(1617);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1613);
      match(MySQLStatementParser::COMMA_);
      setState(1614);
      expr(0);
      setState(1619);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerStatementContext ------------------------------------------------------------------

MySQLStatementParser::HandlerStatementContext::HandlerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::HandlerOpenStatementContext* MySQLStatementParser::HandlerStatementContext::handlerOpenStatement() {
  return getRuleContext<MySQLStatementParser::HandlerOpenStatementContext>(0);
}

MySQLStatementParser::HandlerReadIndexStatementContext* MySQLStatementParser::HandlerStatementContext::handlerReadIndexStatement() {
  return getRuleContext<MySQLStatementParser::HandlerReadIndexStatementContext>(0);
}

MySQLStatementParser::HandlerReadStatementContext* MySQLStatementParser::HandlerStatementContext::handlerReadStatement() {
  return getRuleContext<MySQLStatementParser::HandlerReadStatementContext>(0);
}

MySQLStatementParser::HandlerCloseStatementContext* MySQLStatementParser::HandlerStatementContext::handlerCloseStatement() {
  return getRuleContext<MySQLStatementParser::HandlerCloseStatementContext>(0);
}


size_t MySQLStatementParser::HandlerStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHandlerStatement;
}

void MySQLStatementParser::HandlerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerStatement(this);
}

void MySQLStatementParser::HandlerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerStatement(this);
}


antlrcpp::Any MySQLStatementParser::HandlerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHandlerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HandlerStatementContext* MySQLStatementParser::handlerStatement() {
  HandlerStatementContext *_localctx = _tracker.createInstance<HandlerStatementContext>(_ctx, getState());
  enterRule(_localctx, 70, MySQLStatementParser::RuleHandlerStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1624);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1620);
      handlerOpenStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1621);
      handlerReadIndexStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1622);
      handlerReadStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1623);
      handlerCloseStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerOpenStatementContext ------------------------------------------------------------------

MySQLStatementParser::HandlerOpenStatementContext::HandlerOpenStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HandlerOpenStatementContext::HANDLER() {
  return getToken(MySQLStatementParser::HANDLER, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::HandlerOpenStatementContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HandlerOpenStatementContext::OPEN() {
  return getToken(MySQLStatementParser::OPEN, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::HandlerOpenStatementContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HandlerOpenStatementContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}


size_t MySQLStatementParser::HandlerOpenStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHandlerOpenStatement;
}

void MySQLStatementParser::HandlerOpenStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerOpenStatement(this);
}

void MySQLStatementParser::HandlerOpenStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerOpenStatement(this);
}


antlrcpp::Any MySQLStatementParser::HandlerOpenStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHandlerOpenStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HandlerOpenStatementContext* MySQLStatementParser::handlerOpenStatement() {
  HandlerOpenStatementContext *_localctx = _tracker.createInstance<HandlerOpenStatementContext>(_ctx, getState());
  enterRule(_localctx, 72, MySQLStatementParser::RuleHandlerOpenStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1626);
    match(MySQLStatementParser::HANDLER);
    setState(1627);
    tableName();
    setState(1628);
    match(MySQLStatementParser::OPEN);
    setState(1633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::AS)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(1630);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::AS) {
        setState(1629);
        match(MySQLStatementParser::AS);
      }
      setState(1632);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerReadIndexStatementContext ------------------------------------------------------------------

MySQLStatementParser::HandlerReadIndexStatementContext::HandlerReadIndexStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::HANDLER() {
  return getToken(MySQLStatementParser::HANDLER, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::HandlerReadIndexStatementContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::READ() {
  return getToken(MySQLStatementParser::READ, 0);
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::HandlerReadIndexStatementContext::indexName() {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(0);
}

MySQLStatementParser::ComparisonOperatorContext* MySQLStatementParser::HandlerReadIndexStatementContext::comparisonOperator() {
  return getRuleContext<MySQLStatementParser::ComparisonOperatorContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::HandlerReadIndexStatementContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::FIRST() {
  return getToken(MySQLStatementParser::FIRST, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::NEXT() {
  return getToken(MySQLStatementParser::NEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::PREV() {
  return getToken(MySQLStatementParser::PREV, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadIndexStatementContext::LAST() {
  return getToken(MySQLStatementParser::LAST, 0);
}

MySQLStatementParser::WhereClauseContext* MySQLStatementParser::HandlerReadIndexStatementContext::whereClause() {
  return getRuleContext<MySQLStatementParser::WhereClauseContext>(0);
}

MySQLStatementParser::LimitClauseContext* MySQLStatementParser::HandlerReadIndexStatementContext::limitClause() {
  return getRuleContext<MySQLStatementParser::LimitClauseContext>(0);
}


size_t MySQLStatementParser::HandlerReadIndexStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHandlerReadIndexStatement;
}

void MySQLStatementParser::HandlerReadIndexStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerReadIndexStatement(this);
}

void MySQLStatementParser::HandlerReadIndexStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerReadIndexStatement(this);
}


antlrcpp::Any MySQLStatementParser::HandlerReadIndexStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHandlerReadIndexStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HandlerReadIndexStatementContext* MySQLStatementParser::handlerReadIndexStatement() {
  HandlerReadIndexStatementContext *_localctx = _tracker.createInstance<HandlerReadIndexStatementContext>(_ctx, getState());
  enterRule(_localctx, 74, MySQLStatementParser::RuleHandlerReadIndexStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1635);
    match(MySQLStatementParser::HANDLER);
    setState(1636);
    tableName();
    setState(1637);
    match(MySQLStatementParser::READ);
    setState(1638);
    indexName();
    setState(1645);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::EQ_:
      case MySQLStatementParser::NEQ_:
      case MySQLStatementParser::GT_:
      case MySQLStatementParser::GTE_:
      case MySQLStatementParser::LT_:
      case MySQLStatementParser::LTE_: {
        setState(1639);
        comparisonOperator();
        setState(1640);
        match(MySQLStatementParser::LP_);
        setState(1641);
        identifier();
        setState(1642);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::PREV: {
        setState(1644);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::FIRST || _la == MySQLStatementParser::LAST || _la == MySQLStatementParser::NEXT || _la == MySQLStatementParser::PREV)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1648);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WHERE) {
      setState(1647);
      whereClause();
    }
    setState(1651);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(1650);
      limitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerReadStatementContext ------------------------------------------------------------------

MySQLStatementParser::HandlerReadStatementContext::HandlerReadStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HandlerReadStatementContext::HANDLER() {
  return getToken(MySQLStatementParser::HANDLER, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::HandlerReadStatementContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadStatementContext::READ() {
  return getToken(MySQLStatementParser::READ, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadStatementContext::FIRST() {
  return getToken(MySQLStatementParser::FIRST, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerReadStatementContext::NEXT() {
  return getToken(MySQLStatementParser::NEXT, 0);
}

MySQLStatementParser::WhereClauseContext* MySQLStatementParser::HandlerReadStatementContext::whereClause() {
  return getRuleContext<MySQLStatementParser::WhereClauseContext>(0);
}

MySQLStatementParser::LimitClauseContext* MySQLStatementParser::HandlerReadStatementContext::limitClause() {
  return getRuleContext<MySQLStatementParser::LimitClauseContext>(0);
}


size_t MySQLStatementParser::HandlerReadStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHandlerReadStatement;
}

void MySQLStatementParser::HandlerReadStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerReadStatement(this);
}

void MySQLStatementParser::HandlerReadStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerReadStatement(this);
}


antlrcpp::Any MySQLStatementParser::HandlerReadStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHandlerReadStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HandlerReadStatementContext* MySQLStatementParser::handlerReadStatement() {
  HandlerReadStatementContext *_localctx = _tracker.createInstance<HandlerReadStatementContext>(_ctx, getState());
  enterRule(_localctx, 76, MySQLStatementParser::RuleHandlerReadStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1653);
    match(MySQLStatementParser::HANDLER);
    setState(1654);
    tableName();
    setState(1655);
    match(MySQLStatementParser::READ);
    setState(1656);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FIRST || _la == MySQLStatementParser::NEXT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1658);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WHERE) {
      setState(1657);
      whereClause();
    }
    setState(1661);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(1660);
      limitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerCloseStatementContext ------------------------------------------------------------------

MySQLStatementParser::HandlerCloseStatementContext::HandlerCloseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HandlerCloseStatementContext::HANDLER() {
  return getToken(MySQLStatementParser::HANDLER, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::HandlerCloseStatementContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HandlerCloseStatementContext::CLOSE() {
  return getToken(MySQLStatementParser::CLOSE, 0);
}


size_t MySQLStatementParser::HandlerCloseStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHandlerCloseStatement;
}

void MySQLStatementParser::HandlerCloseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerCloseStatement(this);
}

void MySQLStatementParser::HandlerCloseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerCloseStatement(this);
}


antlrcpp::Any MySQLStatementParser::HandlerCloseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHandlerCloseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HandlerCloseStatementContext* MySQLStatementParser::handlerCloseStatement() {
  HandlerCloseStatementContext *_localctx = _tracker.createInstance<HandlerCloseStatementContext>(_ctx, getState());
  enterRule(_localctx, 78, MySQLStatementParser::RuleHandlerCloseStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1663);
    match(MySQLStatementParser::HANDLER);
    setState(1664);
    tableName();
    setState(1665);
    match(MySQLStatementParser::CLOSE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

MySQLStatementParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ImportStatementContext::IMPORT() {
  return getToken(MySQLStatementParser::IMPORT, 0);
}

tree::TerminalNode* MySQLStatementParser::ImportStatementContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::ImportStatementContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::ImportStatementContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::ImportStatementContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::ImportStatementContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::ImportStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleImportStatement;
}

void MySQLStatementParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void MySQLStatementParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}


antlrcpp::Any MySQLStatementParser::ImportStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitImportStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ImportStatementContext* MySQLStatementParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 80, MySQLStatementParser::RuleImportStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1667);
    match(MySQLStatementParser::IMPORT);
    setState(1668);
    match(MySQLStatementParser::TABLE);
    setState(1669);
    match(MySQLStatementParser::FROM);
    setState(1670);
    string_();
    setState(1673);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COMMA_) {
      setState(1671);
      match(MySQLStatementParser::COMMA_);
      setState(1672);
      string_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadStatementContext ------------------------------------------------------------------

MySQLStatementParser::LoadStatementContext::LoadStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::LoadDataStatementContext* MySQLStatementParser::LoadStatementContext::loadDataStatement() {
  return getRuleContext<MySQLStatementParser::LoadDataStatementContext>(0);
}

MySQLStatementParser::LoadXmlStatementContext* MySQLStatementParser::LoadStatementContext::loadXmlStatement() {
  return getRuleContext<MySQLStatementParser::LoadXmlStatementContext>(0);
}


size_t MySQLStatementParser::LoadStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLoadStatement;
}

void MySQLStatementParser::LoadStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadStatement(this);
}

void MySQLStatementParser::LoadStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadStatement(this);
}


antlrcpp::Any MySQLStatementParser::LoadStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLoadStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LoadStatementContext* MySQLStatementParser::loadStatement() {
  LoadStatementContext *_localctx = _tracker.createInstance<LoadStatementContext>(_ctx, getState());
  enterRule(_localctx, 82, MySQLStatementParser::RuleLoadStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1677);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1675);
      loadDataStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1676);
      loadXmlStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataStatementContext ------------------------------------------------------------------

MySQLStatementParser::LoadDataStatementContext::LoadDataStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::LOAD() {
  return getToken(MySQLStatementParser::LOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::DATA() {
  return getToken(MySQLStatementParser::DATA, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::INFILE() {
  return getToken(MySQLStatementParser::INFILE, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::LoadDataStatementContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::LoadDataStatementContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}

MySQLStatementParser::PartitionNamesContext* MySQLStatementParser::LoadDataStatementContext::partitionNames() {
  return getRuleContext<MySQLStatementParser::PartitionNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::CHARACTER() {
  return getToken(MySQLStatementParser::CHARACTER, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::LoadDataStatementContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LoadDataStatementContext::LINES() {
  return getTokens(MySQLStatementParser::LINES);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::LINES(size_t i) {
  return getToken(MySQLStatementParser::LINES, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LoadDataStatementContext::IGNORE() {
  return getTokens(MySQLStatementParser::IGNORE);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::IGNORE(size_t i) {
  return getToken(MySQLStatementParser::IGNORE, i);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::LoadDataStatementContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

MySQLStatementParser::FieldOrVarSpecContext* MySQLStatementParser::LoadDataStatementContext::fieldOrVarSpec() {
  return getRuleContext<MySQLStatementParser::FieldOrVarSpecContext>(0);
}

MySQLStatementParser::SetAssignmentsClauseContext* MySQLStatementParser::LoadDataStatementContext::setAssignmentsClause() {
  return getRuleContext<MySQLStatementParser::SetAssignmentsClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::LOW_PRIORITY() {
  return getToken(MySQLStatementParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::CONCURRENT() {
  return getToken(MySQLStatementParser::CONCURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::FIELDS() {
  return getToken(MySQLStatementParser::FIELDS, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::COLUMNS() {
  return getToken(MySQLStatementParser::COLUMNS, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadDataStatementContext::ROWS() {
  return getToken(MySQLStatementParser::ROWS, 0);
}

std::vector<MySQLStatementParser::SelectFieldsIntoContext *> MySQLStatementParser::LoadDataStatementContext::selectFieldsInto() {
  return getRuleContexts<MySQLStatementParser::SelectFieldsIntoContext>();
}

MySQLStatementParser::SelectFieldsIntoContext* MySQLStatementParser::LoadDataStatementContext::selectFieldsInto(size_t i) {
  return getRuleContext<MySQLStatementParser::SelectFieldsIntoContext>(i);
}

std::vector<MySQLStatementParser::SelectLinesIntoContext *> MySQLStatementParser::LoadDataStatementContext::selectLinesInto() {
  return getRuleContexts<MySQLStatementParser::SelectLinesIntoContext>();
}

MySQLStatementParser::SelectLinesIntoContext* MySQLStatementParser::LoadDataStatementContext::selectLinesInto(size_t i) {
  return getRuleContext<MySQLStatementParser::SelectLinesIntoContext>(i);
}


size_t MySQLStatementParser::LoadDataStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLoadDataStatement;
}

void MySQLStatementParser::LoadDataStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataStatement(this);
}

void MySQLStatementParser::LoadDataStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataStatement(this);
}


antlrcpp::Any MySQLStatementParser::LoadDataStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLoadDataStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LoadDataStatementContext* MySQLStatementParser::loadDataStatement() {
  LoadDataStatementContext *_localctx = _tracker.createInstance<LoadDataStatementContext>(_ctx, getState());
  enterRule(_localctx, 84, MySQLStatementParser::RuleLoadDataStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1679);
    match(MySQLStatementParser::LOAD);
    setState(1680);
    match(MySQLStatementParser::DATA);
    setState(1682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CONCURRENT || _la == MySQLStatementParser::LOW_PRIORITY) {
      setState(1681);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::CONCURRENT || _la == MySQLStatementParser::LOW_PRIORITY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1685);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOCAL) {
      setState(1684);
      match(MySQLStatementParser::LOCAL);
    }
    setState(1687);
    match(MySQLStatementParser::INFILE);
    setState(1688);
    string_();
    setState(1690);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::REPLACE) {
      setState(1689);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::REPLACE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1692);
    match(MySQLStatementParser::INTO);
    setState(1693);
    match(MySQLStatementParser::TABLE);
    setState(1694);
    tableName();
    setState(1696);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PARTITION) {
      setState(1695);
      partitionNames();
    }
    setState(1701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CHARACTER) {
      setState(1698);
      match(MySQLStatementParser::CHARACTER);
      setState(1699);
      match(MySQLStatementParser::SET);
      setState(1700);
      identifier();
    }
    setState(1709);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COLUMNS || _la == MySQLStatementParser::FIELDS) {
      setState(1703);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::COLUMNS || _la == MySQLStatementParser::FIELDS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1705); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1704);
        selectFieldsInto();
        setState(1707); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySQLStatementParser::ENCLOSED

      || _la == MySQLStatementParser::ESCAPED || _la == MySQLStatementParser::OPTIONALLY || _la == MySQLStatementParser::TERMINATED);
    }
    setState(1717);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LINES) {
      setState(1711);
      match(MySQLStatementParser::LINES);
      setState(1713); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1712);
        selectLinesInto();
        setState(1715); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySQLStatementParser::STARTING

      || _la == MySQLStatementParser::TERMINATED);
    }
    setState(1723);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE) {
      setState(1719);
      match(MySQLStatementParser::IGNORE);
      setState(1720);
      numberLiterals();
      setState(1721);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LINES || _la == MySQLStatementParser::ROWS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1726);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(1725);
      fieldOrVarSpec();
    }
    setState(1729);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS || _la == MySQLStatementParser::SET) {
      setState(1728);
      setAssignmentsClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadXmlStatementContext ------------------------------------------------------------------

MySQLStatementParser::LoadXmlStatementContext::LoadXmlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::LOAD() {
  return getToken(MySQLStatementParser::LOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::XML() {
  return getToken(MySQLStatementParser::XML, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::INFILE() {
  return getToken(MySQLStatementParser::INFILE, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::LoadXmlStatementContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::LoadXmlStatementContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::LoadXmlStatementContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::CHARACTER() {
  return getToken(MySQLStatementParser::CHARACTER, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::LoadXmlStatementContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LoadXmlStatementContext::ROWS() {
  return getTokens(MySQLStatementParser::ROWS);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::ROWS(size_t i) {
  return getToken(MySQLStatementParser::ROWS, i);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::IDENTIFIED() {
  return getToken(MySQLStatementParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::LT_() {
  return getToken(MySQLStatementParser::LT_, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::GT_() {
  return getToken(MySQLStatementParser::GT_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LoadXmlStatementContext::IGNORE() {
  return getTokens(MySQLStatementParser::IGNORE);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::IGNORE(size_t i) {
  return getToken(MySQLStatementParser::IGNORE, i);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::LoadXmlStatementContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

MySQLStatementParser::FieldOrVarSpecContext* MySQLStatementParser::LoadXmlStatementContext::fieldOrVarSpec() {
  return getRuleContext<MySQLStatementParser::FieldOrVarSpecContext>(0);
}

MySQLStatementParser::SetAssignmentsClauseContext* MySQLStatementParser::LoadXmlStatementContext::setAssignmentsClause() {
  return getRuleContext<MySQLStatementParser::SetAssignmentsClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::LOW_PRIORITY() {
  return getToken(MySQLStatementParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::CONCURRENT() {
  return getToken(MySQLStatementParser::CONCURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadXmlStatementContext::LINES() {
  return getToken(MySQLStatementParser::LINES, 0);
}


size_t MySQLStatementParser::LoadXmlStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLoadXmlStatement;
}

void MySQLStatementParser::LoadXmlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadXmlStatement(this);
}

void MySQLStatementParser::LoadXmlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadXmlStatement(this);
}


antlrcpp::Any MySQLStatementParser::LoadXmlStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLoadXmlStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LoadXmlStatementContext* MySQLStatementParser::loadXmlStatement() {
  LoadXmlStatementContext *_localctx = _tracker.createInstance<LoadXmlStatementContext>(_ctx, getState());
  enterRule(_localctx, 86, MySQLStatementParser::RuleLoadXmlStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1731);
    match(MySQLStatementParser::LOAD);
    setState(1732);
    match(MySQLStatementParser::XML);
    setState(1734);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CONCURRENT || _la == MySQLStatementParser::LOW_PRIORITY) {
      setState(1733);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::CONCURRENT || _la == MySQLStatementParser::LOW_PRIORITY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1737);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOCAL) {
      setState(1736);
      match(MySQLStatementParser::LOCAL);
    }
    setState(1739);
    match(MySQLStatementParser::INFILE);
    setState(1740);
    string_();
    setState(1742);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::REPLACE) {
      setState(1741);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::REPLACE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1744);
    match(MySQLStatementParser::INTO);
    setState(1745);
    match(MySQLStatementParser::TABLE);
    setState(1746);
    tableName();
    setState(1750);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CHARACTER) {
      setState(1747);
      match(MySQLStatementParser::CHARACTER);
      setState(1748);
      match(MySQLStatementParser::SET);
      setState(1749);
      identifier();
    }
    setState(1759);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ROWS) {
      setState(1752);
      match(MySQLStatementParser::ROWS);
      setState(1753);
      match(MySQLStatementParser::IDENTIFIED);
      setState(1754);
      match(MySQLStatementParser::BY);
      setState(1755);
      match(MySQLStatementParser::LT_);
      setState(1756);
      string_();
      setState(1757);
      match(MySQLStatementParser::GT_);
    }
    setState(1765);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE) {
      setState(1761);
      match(MySQLStatementParser::IGNORE);
      setState(1762);
      numberLiterals();
      setState(1763);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LINES || _la == MySQLStatementParser::ROWS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1768);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(1767);
      fieldOrVarSpec();
    }
    setState(1771);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS || _la == MySQLStatementParser::SET) {
      setState(1770);
      setAssignmentsClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitTableContext ------------------------------------------------------------------

MySQLStatementParser::ExplicitTableContext::ExplicitTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ExplicitTableContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::ExplicitTableContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}


size_t MySQLStatementParser::ExplicitTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExplicitTable;
}

void MySQLStatementParser::ExplicitTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitTable(this);
}

void MySQLStatementParser::ExplicitTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitTable(this);
}


antlrcpp::Any MySQLStatementParser::ExplicitTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExplicitTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExplicitTableContext* MySQLStatementParser::explicitTable() {
  ExplicitTableContext *_localctx = _tracker.createInstance<ExplicitTableContext>(_ctx, getState());
  enterRule(_localctx, 88, MySQLStatementParser::RuleExplicitTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1773);
    match(MySQLStatementParser::TABLE);
    setState(1774);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableValueConstructorContext ------------------------------------------------------------------

MySQLStatementParser::TableValueConstructorContext::TableValueConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TableValueConstructorContext::VALUES() {
  return getToken(MySQLStatementParser::VALUES, 0);
}

MySQLStatementParser::RowConstructorListContext* MySQLStatementParser::TableValueConstructorContext::rowConstructorList() {
  return getRuleContext<MySQLStatementParser::RowConstructorListContext>(0);
}


size_t MySQLStatementParser::TableValueConstructorContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableValueConstructor;
}

void MySQLStatementParser::TableValueConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableValueConstructor(this);
}

void MySQLStatementParser::TableValueConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableValueConstructor(this);
}


antlrcpp::Any MySQLStatementParser::TableValueConstructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableValueConstructor(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableValueConstructorContext* MySQLStatementParser::tableValueConstructor() {
  TableValueConstructorContext *_localctx = _tracker.createInstance<TableValueConstructorContext>(_ctx, getState());
  enterRule(_localctx, 90, MySQLStatementParser::RuleTableValueConstructor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1776);
    match(MySQLStatementParser::VALUES);
    setState(1777);
    rowConstructorList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowConstructorListContext ------------------------------------------------------------------

MySQLStatementParser::RowConstructorListContext::RowConstructorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RowConstructorListContext::ROW() {
  return getTokens(MySQLStatementParser::ROW);
}

tree::TerminalNode* MySQLStatementParser::RowConstructorListContext::ROW(size_t i) {
  return getToken(MySQLStatementParser::ROW, i);
}

std::vector<MySQLStatementParser::AssignmentValuesContext *> MySQLStatementParser::RowConstructorListContext::assignmentValues() {
  return getRuleContexts<MySQLStatementParser::AssignmentValuesContext>();
}

MySQLStatementParser::AssignmentValuesContext* MySQLStatementParser::RowConstructorListContext::assignmentValues(size_t i) {
  return getRuleContext<MySQLStatementParser::AssignmentValuesContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RowConstructorListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::RowConstructorListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::RowConstructorListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRowConstructorList;
}

void MySQLStatementParser::RowConstructorListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowConstructorList(this);
}

void MySQLStatementParser::RowConstructorListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowConstructorList(this);
}


antlrcpp::Any MySQLStatementParser::RowConstructorListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRowConstructorList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RowConstructorListContext* MySQLStatementParser::rowConstructorList() {
  RowConstructorListContext *_localctx = _tracker.createInstance<RowConstructorListContext>(_ctx, getState());
  enterRule(_localctx, 92, MySQLStatementParser::RuleRowConstructorList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1779);
    match(MySQLStatementParser::ROW);
    setState(1780);
    assignmentValues();
    setState(1786);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1781);
        match(MySQLStatementParser::COMMA_);
        setState(1782);
        match(MySQLStatementParser::ROW);
        setState(1783);
        assignmentValues(); 
      }
      setState(1788);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithClauseContext ------------------------------------------------------------------

MySQLStatementParser::WithClauseContext::WithClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WithClauseContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

std::vector<MySQLStatementParser::CteClauseContext *> MySQLStatementParser::WithClauseContext::cteClause() {
  return getRuleContexts<MySQLStatementParser::CteClauseContext>();
}

MySQLStatementParser::CteClauseContext* MySQLStatementParser::WithClauseContext::cteClause(size_t i) {
  return getRuleContext<MySQLStatementParser::CteClauseContext>(i);
}

tree::TerminalNode* MySQLStatementParser::WithClauseContext::RECURSIVE() {
  return getToken(MySQLStatementParser::RECURSIVE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::WithClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::WithClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::WithClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWithClause;
}

void MySQLStatementParser::WithClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithClause(this);
}

void MySQLStatementParser::WithClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithClause(this);
}


antlrcpp::Any MySQLStatementParser::WithClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWithClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WithClauseContext* MySQLStatementParser::withClause() {
  WithClauseContext *_localctx = _tracker.createInstance<WithClauseContext>(_ctx, getState());
  enterRule(_localctx, 94, MySQLStatementParser::RuleWithClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1789);
    match(MySQLStatementParser::WITH);
    setState(1791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RECURSIVE) {
      setState(1790);
      match(MySQLStatementParser::RECURSIVE);
    }
    setState(1793);
    cteClause();
    setState(1798);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1794);
      match(MySQLStatementParser::COMMA_);
      setState(1795);
      cteClause();
      setState(1800);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CteClauseContext ------------------------------------------------------------------

MySQLStatementParser::CteClauseContext::CteClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CteClauseContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CteClauseContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::SubqueryContext* MySQLStatementParser::CteClauseContext::subquery() {
  return getRuleContext<MySQLStatementParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CteClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::CteClauseContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CteClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::CteClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCteClause;
}

void MySQLStatementParser::CteClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCteClause(this);
}

void MySQLStatementParser::CteClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCteClause(this);
}


antlrcpp::Any MySQLStatementParser::CteClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCteClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CteClauseContext* MySQLStatementParser::cteClause() {
  CteClauseContext *_localctx = _tracker.createInstance<CteClauseContext>(_ctx, getState());
  enterRule(_localctx, 96, MySQLStatementParser::RuleCteClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1801);
    identifier();
    setState(1806);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(1802);
      match(MySQLStatementParser::LP_);
      setState(1803);
      columnNames();
      setState(1804);
      match(MySQLStatementParser::RP_);
    }
    setState(1808);
    match(MySQLStatementParser::AS);
    setState(1809);
    subquery();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::SelectSpecificationContext::SelectSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::DuplicateSpecificationContext* MySQLStatementParser::SelectSpecificationContext::duplicateSpecification() {
  return getRuleContext<MySQLStatementParser::DuplicateSpecificationContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::HIGH_PRIORITY() {
  return getToken(MySQLStatementParser::HIGH_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::STRAIGHT_JOIN() {
  return getToken(MySQLStatementParser::STRAIGHT_JOIN, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::SQL_SMALL_RESULT() {
  return getToken(MySQLStatementParser::SQL_SMALL_RESULT, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::SQL_BIG_RESULT() {
  return getToken(MySQLStatementParser::SQL_BIG_RESULT, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::SQL_BUFFER_RESULT() {
  return getToken(MySQLStatementParser::SQL_BUFFER_RESULT, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::SQL_CACHE() {
  return getToken(MySQLStatementParser::SQL_CACHE, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::SQL_NO_CACHE() {
  return getToken(MySQLStatementParser::SQL_NO_CACHE, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectSpecificationContext::SQL_CALC_FOUND_ROWS() {
  return getToken(MySQLStatementParser::SQL_CALC_FOUND_ROWS, 0);
}


size_t MySQLStatementParser::SelectSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSelectSpecification;
}

void MySQLStatementParser::SelectSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectSpecification(this);
}

void MySQLStatementParser::SelectSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectSpecification(this);
}


antlrcpp::Any MySQLStatementParser::SelectSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSelectSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SelectSpecificationContext* MySQLStatementParser::selectSpecification() {
  SelectSpecificationContext *_localctx = _tracker.createInstance<SelectSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 98, MySQLStatementParser::RuleSelectSpecification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1819);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ALL:
      case MySQLStatementParser::DISTINCT:
      case MySQLStatementParser::DISTINCTROW: {
        enterOuterAlt(_localctx, 1);
        setState(1811);
        duplicateSpecification();
        break;
      }

      case MySQLStatementParser::HIGH_PRIORITY: {
        enterOuterAlt(_localctx, 2);
        setState(1812);
        match(MySQLStatementParser::HIGH_PRIORITY);
        break;
      }

      case MySQLStatementParser::STRAIGHT_JOIN: {
        enterOuterAlt(_localctx, 3);
        setState(1813);
        match(MySQLStatementParser::STRAIGHT_JOIN);
        break;
      }

      case MySQLStatementParser::SQL_SMALL_RESULT: {
        enterOuterAlt(_localctx, 4);
        setState(1814);
        match(MySQLStatementParser::SQL_SMALL_RESULT);
        break;
      }

      case MySQLStatementParser::SQL_BIG_RESULT: {
        enterOuterAlt(_localctx, 5);
        setState(1815);
        match(MySQLStatementParser::SQL_BIG_RESULT);
        break;
      }

      case MySQLStatementParser::SQL_BUFFER_RESULT: {
        enterOuterAlt(_localctx, 6);
        setState(1816);
        match(MySQLStatementParser::SQL_BUFFER_RESULT);
        break;
      }

      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_NO_CACHE: {
        enterOuterAlt(_localctx, 7);
        setState(1817);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::SQL_CACHE

        || _la == MySQLStatementParser::SQL_NO_CACHE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLStatementParser::SQL_CALC_FOUND_ROWS: {
        enterOuterAlt(_localctx, 8);
        setState(1818);
        match(MySQLStatementParser::SQL_CALC_FOUND_ROWS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DuplicateSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::DuplicateSpecificationContext::DuplicateSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DuplicateSpecificationContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::DuplicateSpecificationContext::DISTINCT() {
  return getToken(MySQLStatementParser::DISTINCT, 0);
}

tree::TerminalNode* MySQLStatementParser::DuplicateSpecificationContext::DISTINCTROW() {
  return getToken(MySQLStatementParser::DISTINCTROW, 0);
}


size_t MySQLStatementParser::DuplicateSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDuplicateSpecification;
}

void MySQLStatementParser::DuplicateSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDuplicateSpecification(this);
}

void MySQLStatementParser::DuplicateSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDuplicateSpecification(this);
}


antlrcpp::Any MySQLStatementParser::DuplicateSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDuplicateSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DuplicateSpecificationContext* MySQLStatementParser::duplicateSpecification() {
  DuplicateSpecificationContext *_localctx = _tracker.createInstance<DuplicateSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 100, MySQLStatementParser::RuleDuplicateSpecification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1821);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::ALL || _la == MySQLStatementParser::DISTINCT

    || _la == MySQLStatementParser::DISTINCTROW)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProjectionsContext ------------------------------------------------------------------

MySQLStatementParser::ProjectionsContext::ProjectionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::UnqualifiedShorthandContext* MySQLStatementParser::ProjectionsContext::unqualifiedShorthand() {
  return getRuleContext<MySQLStatementParser::UnqualifiedShorthandContext>(0);
}

std::vector<MySQLStatementParser::ProjectionContext *> MySQLStatementParser::ProjectionsContext::projection() {
  return getRuleContexts<MySQLStatementParser::ProjectionContext>();
}

MySQLStatementParser::ProjectionContext* MySQLStatementParser::ProjectionsContext::projection(size_t i) {
  return getRuleContext<MySQLStatementParser::ProjectionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ProjectionsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ProjectionsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::ProjectionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleProjections;
}

void MySQLStatementParser::ProjectionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProjections(this);
}

void MySQLStatementParser::ProjectionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProjections(this);
}


antlrcpp::Any MySQLStatementParser::ProjectionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitProjections(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ProjectionsContext* MySQLStatementParser::projections() {
  ProjectionsContext *_localctx = _tracker.createInstance<ProjectionsContext>(_ctx, getState());
  enterRule(_localctx, 102, MySQLStatementParser::RuleProjections);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1825);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ASTERISK_: {
        setState(1823);
        unqualifiedShorthand();
        break;
      }

      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CASE:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CONVERT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CUME_DIST:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURRENT_DATE:
      case MySQLStatementParser::CURRENT_TIME:
      case MySQLStatementParser::CURRENT_TIMESTAMP:
      case MySQLStatementParser::CURRENT_USER:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATABASE:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DENSE_RANK:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXISTS:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FALSE:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIRST_VALUE:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IF:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INTERVAL:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LAG:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LAST_VALUE:
      case MySQLStatementParser::LEAD:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LEFT:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCALTIME:
      case MySQLStatementParser::LOCALTIMESTAMP:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MATCH:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MOD:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOT:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NTH_VALUE:
      case MySQLStatementParser::NTILE:
      case MySQLStatementParser::NULL:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERCENT_RANK:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::RANK:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLACE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::RIGHT:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::ROW_NUMBER:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUE:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VALUES:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::NOT_:
      case MySQLStatementParser::TILDE_:
      case MySQLStatementParser::PLUS_:
      case MySQLStatementParser::MINUS_:
      case MySQLStatementParser::DOT_:
      case MySQLStatementParser::LP_:
      case MySQLStatementParser::LBE_:
      case MySQLStatementParser::QUESTION_:
      case MySQLStatementParser::AT_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
      case MySQLStatementParser::NCHAR_TEXT:
      case MySQLStatementParser::UNDERSCORE_CHARSET:
      case MySQLStatementParser::NUMBER_:
      case MySQLStatementParser::HEX_DIGIT_:
      case MySQLStatementParser::BIT_NUM_: {
        setState(1824);
        projection();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1831);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1827);
        match(MySQLStatementParser::COMMA_);
        setState(1828);
        projection(); 
      }
      setState(1833);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProjectionContext ------------------------------------------------------------------

MySQLStatementParser::ProjectionContext::ProjectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ExprContext* MySQLStatementParser::ProjectionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

MySQLStatementParser::AliasContext* MySQLStatementParser::ProjectionContext::alias() {
  return getRuleContext<MySQLStatementParser::AliasContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ProjectionContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::QualifiedShorthandContext* MySQLStatementParser::ProjectionContext::qualifiedShorthand() {
  return getRuleContext<MySQLStatementParser::QualifiedShorthandContext>(0);
}


size_t MySQLStatementParser::ProjectionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleProjection;
}

void MySQLStatementParser::ProjectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProjection(this);
}

void MySQLStatementParser::ProjectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProjection(this);
}


antlrcpp::Any MySQLStatementParser::ProjectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitProjection(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ProjectionContext* MySQLStatementParser::projection() {
  ProjectionContext *_localctx = _tracker.createInstance<ProjectionContext>(_ctx, getState());
  enterRule(_localctx, 104, MySQLStatementParser::RuleProjection);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1842);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1834);
      expr(0);
      setState(1839);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
      case 1: {
        setState(1836);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::AS) {
          setState(1835);
          match(MySQLStatementParser::AS);
        }
        setState(1838);
        alias();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1841);
      qualifiedShorthand();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnqualifiedShorthandContext ------------------------------------------------------------------

MySQLStatementParser::UnqualifiedShorthandContext::UnqualifiedShorthandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UnqualifiedShorthandContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}


size_t MySQLStatementParser::UnqualifiedShorthandContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUnqualifiedShorthand;
}

void MySQLStatementParser::UnqualifiedShorthandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnqualifiedShorthand(this);
}

void MySQLStatementParser::UnqualifiedShorthandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnqualifiedShorthand(this);
}


antlrcpp::Any MySQLStatementParser::UnqualifiedShorthandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUnqualifiedShorthand(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UnqualifiedShorthandContext* MySQLStatementParser::unqualifiedShorthand() {
  UnqualifiedShorthandContext *_localctx = _tracker.createInstance<UnqualifiedShorthandContext>(_ctx, getState());
  enterRule(_localctx, 106, MySQLStatementParser::RuleUnqualifiedShorthand);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1844);
    match(MySQLStatementParser::ASTERISK_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedShorthandContext ------------------------------------------------------------------

MySQLStatementParser::QualifiedShorthandContext::QualifiedShorthandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::QualifiedShorthandContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::QualifiedShorthandContext::DOT_ASTERISK_() {
  return getToken(MySQLStatementParser::DOT_ASTERISK_, 0);
}


size_t MySQLStatementParser::QualifiedShorthandContext::getRuleIndex() const {
  return MySQLStatementParser::RuleQualifiedShorthand;
}

void MySQLStatementParser::QualifiedShorthandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedShorthand(this);
}

void MySQLStatementParser::QualifiedShorthandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedShorthand(this);
}


antlrcpp::Any MySQLStatementParser::QualifiedShorthandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedShorthand(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::QualifiedShorthandContext* MySQLStatementParser::qualifiedShorthand() {
  QualifiedShorthandContext *_localctx = _tracker.createInstance<QualifiedShorthandContext>(_ctx, getState());
  enterRule(_localctx, 108, MySQLStatementParser::RuleQualifiedShorthand);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1846);
    identifier();
    setState(1847);
    match(MySQLStatementParser::DOT_ASTERISK_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

MySQLStatementParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FromClauseContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

tree::TerminalNode* MySQLStatementParser::FromClauseContext::DUAL() {
  return getToken(MySQLStatementParser::DUAL, 0);
}

MySQLStatementParser::TableReferencesContext* MySQLStatementParser::FromClauseContext::tableReferences() {
  return getRuleContext<MySQLStatementParser::TableReferencesContext>(0);
}


size_t MySQLStatementParser::FromClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFromClause;
}

void MySQLStatementParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void MySQLStatementParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}


antlrcpp::Any MySQLStatementParser::FromClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFromClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FromClauseContext* MySQLStatementParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 110, MySQLStatementParser::RuleFromClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1849);
    match(MySQLStatementParser::FROM);
    setState(1852);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::DUAL: {
        setState(1850);
        match(MySQLStatementParser::DUAL);
        break;
      }

      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::LP_:
      case MySQLStatementParser::LBE_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(1851);
        tableReferences();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferencesContext ------------------------------------------------------------------

MySQLStatementParser::TableReferencesContext::TableReferencesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::TableReferenceContext *> MySQLStatementParser::TableReferencesContext::tableReference() {
  return getRuleContexts<MySQLStatementParser::TableReferenceContext>();
}

MySQLStatementParser::TableReferenceContext* MySQLStatementParser::TableReferencesContext::tableReference(size_t i) {
  return getRuleContext<MySQLStatementParser::TableReferenceContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableReferencesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::TableReferencesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::TableReferencesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableReferences;
}

void MySQLStatementParser::TableReferencesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReferences(this);
}

void MySQLStatementParser::TableReferencesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReferences(this);
}


antlrcpp::Any MySQLStatementParser::TableReferencesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableReferences(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableReferencesContext* MySQLStatementParser::tableReferences() {
  TableReferencesContext *_localctx = _tracker.createInstance<TableReferencesContext>(_ctx, getState());
  enterRule(_localctx, 112, MySQLStatementParser::RuleTableReferences);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1854);
    tableReference();
    setState(1859);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1855);
        match(MySQLStatementParser::COMMA_);
        setState(1856);
        tableReference(); 
      }
      setState(1861);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscapedTableReferenceContext ------------------------------------------------------------------

MySQLStatementParser::EscapedTableReferenceContext::EscapedTableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableFactorContext* MySQLStatementParser::EscapedTableReferenceContext::tableFactor() {
  return getRuleContext<MySQLStatementParser::TableFactorContext>(0);
}

std::vector<MySQLStatementParser::JoinedTableContext *> MySQLStatementParser::EscapedTableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLStatementParser::JoinedTableContext>();
}

MySQLStatementParser::JoinedTableContext* MySQLStatementParser::EscapedTableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLStatementParser::JoinedTableContext>(i);
}


size_t MySQLStatementParser::EscapedTableReferenceContext::getRuleIndex() const {
  return MySQLStatementParser::RuleEscapedTableReference;
}

void MySQLStatementParser::EscapedTableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscapedTableReference(this);
}

void MySQLStatementParser::EscapedTableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscapedTableReference(this);
}


antlrcpp::Any MySQLStatementParser::EscapedTableReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitEscapedTableReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::EscapedTableReferenceContext* MySQLStatementParser::escapedTableReference() {
  EscapedTableReferenceContext *_localctx = _tracker.createInstance<EscapedTableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 114, MySQLStatementParser::RuleEscapedTableReference);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1862);
    tableFactor();
    setState(1866);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::CROSS || ((((_la - 270) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 270)) & ((1ULL << (MySQLStatementParser::INNER - 270))
      | (1ULL << (MySQLStatementParser::JOIN - 270))
      | (1ULL << (MySQLStatementParser::LEFT - 270)))) != 0) || _la == MySQLStatementParser::NATURAL || _la == MySQLStatementParser::RIGHT || _la == MySQLStatementParser::STRAIGHT_JOIN) {
      setState(1863);
      joinedTable();
      setState(1868);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceContext ------------------------------------------------------------------

MySQLStatementParser::TableReferenceContext::TableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableFactorContext* MySQLStatementParser::TableReferenceContext::tableFactor() {
  return getRuleContext<MySQLStatementParser::TableFactorContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableReferenceContext::LBE_() {
  return getToken(MySQLStatementParser::LBE_, 0);
}

tree::TerminalNode* MySQLStatementParser::TableReferenceContext::OJ() {
  return getToken(MySQLStatementParser::OJ, 0);
}

MySQLStatementParser::EscapedTableReferenceContext* MySQLStatementParser::TableReferenceContext::escapedTableReference() {
  return getRuleContext<MySQLStatementParser::EscapedTableReferenceContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableReferenceContext::RBE_() {
  return getToken(MySQLStatementParser::RBE_, 0);
}

std::vector<MySQLStatementParser::JoinedTableContext *> MySQLStatementParser::TableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLStatementParser::JoinedTableContext>();
}

MySQLStatementParser::JoinedTableContext* MySQLStatementParser::TableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLStatementParser::JoinedTableContext>(i);
}


size_t MySQLStatementParser::TableReferenceContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableReference;
}

void MySQLStatementParser::TableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReference(this);
}

void MySQLStatementParser::TableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReference(this);
}


antlrcpp::Any MySQLStatementParser::TableReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableReferenceContext* MySQLStatementParser::tableReference() {
  TableReferenceContext *_localctx = _tracker.createInstance<TableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 116, MySQLStatementParser::RuleTableReference);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1875);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::LP_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(1869);
        tableFactor();
        break;
      }

      case MySQLStatementParser::LBE_: {
        setState(1870);
        match(MySQLStatementParser::LBE_);
        setState(1871);
        match(MySQLStatementParser::OJ);
        setState(1872);
        escapedTableReference();
        setState(1873);
        match(MySQLStatementParser::RBE_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1880);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1877);
        joinedTable(); 
      }
      setState(1882);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableFactorContext ------------------------------------------------------------------

MySQLStatementParser::TableFactorContext::TableFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::TableFactorContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::PartitionNamesContext* MySQLStatementParser::TableFactorContext::partitionNames() {
  return getRuleContext<MySQLStatementParser::PartitionNamesContext>(0);
}

MySQLStatementParser::AliasContext* MySQLStatementParser::TableFactorContext::alias() {
  return getRuleContext<MySQLStatementParser::AliasContext>(0);
}

MySQLStatementParser::IndexHintListContext* MySQLStatementParser::TableFactorContext::indexHintList() {
  return getRuleContext<MySQLStatementParser::IndexHintListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableFactorContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::SubqueryContext* MySQLStatementParser::TableFactorContext::subquery() {
  return getRuleContext<MySQLStatementParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableFactorContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::TableFactorContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableFactorContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::TableReferencesContext* MySQLStatementParser::TableFactorContext::tableReferences() {
  return getRuleContext<MySQLStatementParser::TableReferencesContext>(0);
}


size_t MySQLStatementParser::TableFactorContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableFactor;
}

void MySQLStatementParser::TableFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFactor(this);
}

void MySQLStatementParser::TableFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFactor(this);
}


antlrcpp::Any MySQLStatementParser::TableFactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableFactor(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableFactorContext* MySQLStatementParser::tableFactor() {
  TableFactorContext *_localctx = _tracker.createInstance<TableFactorContext>(_ctx, getState());
  enterRule(_localctx, 118, MySQLStatementParser::RuleTableFactor);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1911);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1883);
      tableName();
      setState(1885);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
      case 1: {
        setState(1884);
        partitionNames();
        break;
      }

      }
      setState(1891);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
      case 1: {
        setState(1888);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::AS) {
          setState(1887);
          match(MySQLStatementParser::AS);
        }
        setState(1890);
        alias();
        break;
      }

      }
      setState(1894);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
      case 1: {
        setState(1893);
        indexHintList();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1896);
      subquery();
      setState(1898);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::AS) {
        setState(1897);
        match(MySQLStatementParser::AS);
      }
      setState(1900);
      alias();
      setState(1905);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
      case 1: {
        setState(1901);
        match(MySQLStatementParser::LP_);
        setState(1902);
        columnNames();
        setState(1903);
        match(MySQLStatementParser::RP_);
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1907);
      match(MySQLStatementParser::LP_);
      setState(1908);
      tableReferences();
      setState(1909);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionNamesContext ------------------------------------------------------------------

MySQLStatementParser::PartitionNamesContext::PartitionNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionNamesContext::PARTITION() {
  return getToken(MySQLStatementParser::PARTITION, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionNamesContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::PartitionNamesContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::PartitionNamesContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::PartitionNamesContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PartitionNamesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::PartitionNamesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::PartitionNamesContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionNames;
}

void MySQLStatementParser::PartitionNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionNames(this);
}

void MySQLStatementParser::PartitionNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionNames(this);
}


antlrcpp::Any MySQLStatementParser::PartitionNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionNames(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionNamesContext* MySQLStatementParser::partitionNames() {
  PartitionNamesContext *_localctx = _tracker.createInstance<PartitionNamesContext>(_ctx, getState());
  enterRule(_localctx, 120, MySQLStatementParser::RulePartitionNames);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1913);
    match(MySQLStatementParser::PARTITION);
    setState(1914);
    match(MySQLStatementParser::LP_);
    setState(1915);
    identifier();
    setState(1920);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1916);
      match(MySQLStatementParser::COMMA_);
      setState(1917);
      identifier();
      setState(1922);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1923);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintListContext ------------------------------------------------------------------

MySQLStatementParser::IndexHintListContext::IndexHintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IndexHintContext *> MySQLStatementParser::IndexHintListContext::indexHint() {
  return getRuleContexts<MySQLStatementParser::IndexHintContext>();
}

MySQLStatementParser::IndexHintContext* MySQLStatementParser::IndexHintListContext::indexHint(size_t i) {
  return getRuleContext<MySQLStatementParser::IndexHintContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IndexHintListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::IndexHintListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::IndexHintListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIndexHintList;
}

void MySQLStatementParser::IndexHintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintList(this);
}

void MySQLStatementParser::IndexHintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintList(this);
}


antlrcpp::Any MySQLStatementParser::IndexHintListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIndexHintList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IndexHintListContext* MySQLStatementParser::indexHintList() {
  IndexHintListContext *_localctx = _tracker.createInstance<IndexHintListContext>(_ctx, getState());
  enterRule(_localctx, 122, MySQLStatementParser::RuleIndexHintList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1925);
    indexHint();
    setState(1930);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1926);
        match(MySQLStatementParser::COMMA_);
        setState(1927);
        indexHint(); 
      }
      setState(1932);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintContext ------------------------------------------------------------------

MySQLStatementParser::IndexHintContext::IndexHintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::IndexNameContext *> MySQLStatementParser::IndexHintContext::indexName() {
  return getRuleContexts<MySQLStatementParser::IndexNameContext>();
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::IndexHintContext::indexName(size_t i) {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::USE() {
  return getToken(MySQLStatementParser::USE, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::IGNORE() {
  return getToken(MySQLStatementParser::IGNORE, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::FORCE() {
  return getToken(MySQLStatementParser::FORCE, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IndexHintContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::JOIN() {
  return getToken(MySQLStatementParser::JOIN, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::ORDER() {
  return getToken(MySQLStatementParser::ORDER, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexHintContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}


size_t MySQLStatementParser::IndexHintContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIndexHint;
}

void MySQLStatementParser::IndexHintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHint(this);
}

void MySQLStatementParser::IndexHintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHint(this);
}


antlrcpp::Any MySQLStatementParser::IndexHintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIndexHint(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IndexHintContext* MySQLStatementParser::indexHint() {
  IndexHintContext *_localctx = _tracker.createInstance<IndexHintContext>(_ctx, getState());
  enterRule(_localctx, 124, MySQLStatementParser::RuleIndexHint);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1933);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FORCE

    || _la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::USE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1934);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::INDEX

    || _la == MySQLStatementParser::KEY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1943);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(1935);
      match(MySQLStatementParser::FOR);
      setState(1941);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::JOIN: {
          setState(1936);
          match(MySQLStatementParser::JOIN);
          break;
        }

        case MySQLStatementParser::ORDER: {
          setState(1937);
          match(MySQLStatementParser::ORDER);
          setState(1938);
          match(MySQLStatementParser::BY);
          break;
        }

        case MySQLStatementParser::GROUP: {
          setState(1939);
          match(MySQLStatementParser::GROUP);
          setState(1940);
          match(MySQLStatementParser::BY);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(1945);
    match(MySQLStatementParser::LP_);
    setState(1946);
    indexName();
    setState(1951);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(1947);
      match(MySQLStatementParser::COMMA_);
      setState(1948);
      indexName();
      setState(1953);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1954);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinedTableContext ------------------------------------------------------------------

MySQLStatementParser::JoinedTableContext::JoinedTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::InnerJoinTypeContext* MySQLStatementParser::JoinedTableContext::innerJoinType() {
  return getRuleContext<MySQLStatementParser::InnerJoinTypeContext>(0);
}

MySQLStatementParser::TableReferenceContext* MySQLStatementParser::JoinedTableContext::tableReference() {
  return getRuleContext<MySQLStatementParser::TableReferenceContext>(0);
}

MySQLStatementParser::JoinSpecificationContext* MySQLStatementParser::JoinedTableContext::joinSpecification() {
  return getRuleContext<MySQLStatementParser::JoinSpecificationContext>(0);
}

MySQLStatementParser::OuterJoinTypeContext* MySQLStatementParser::JoinedTableContext::outerJoinType() {
  return getRuleContext<MySQLStatementParser::OuterJoinTypeContext>(0);
}

MySQLStatementParser::NaturalJoinTypeContext* MySQLStatementParser::JoinedTableContext::naturalJoinType() {
  return getRuleContext<MySQLStatementParser::NaturalJoinTypeContext>(0);
}

MySQLStatementParser::TableFactorContext* MySQLStatementParser::JoinedTableContext::tableFactor() {
  return getRuleContext<MySQLStatementParser::TableFactorContext>(0);
}


size_t MySQLStatementParser::JoinedTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleJoinedTable;
}

void MySQLStatementParser::JoinedTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinedTable(this);
}

void MySQLStatementParser::JoinedTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinedTable(this);
}


antlrcpp::Any MySQLStatementParser::JoinedTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitJoinedTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::JoinedTableContext* MySQLStatementParser::joinedTable() {
  JoinedTableContext *_localctx = _tracker.createInstance<JoinedTableContext>(_ctx, getState());
  enterRule(_localctx, 126, MySQLStatementParser::RuleJoinedTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1968);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CROSS:
      case MySQLStatementParser::INNER:
      case MySQLStatementParser::JOIN:
      case MySQLStatementParser::STRAIGHT_JOIN: {
        enterOuterAlt(_localctx, 1);
        setState(1956);
        innerJoinType();
        setState(1957);
        tableReference();
        setState(1959);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
        case 1: {
          setState(1958);
          joinSpecification();
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::LEFT:
      case MySQLStatementParser::RIGHT: {
        enterOuterAlt(_localctx, 2);
        setState(1961);
        outerJoinType();
        setState(1962);
        tableReference();
        setState(1963);
        joinSpecification();
        break;
      }

      case MySQLStatementParser::NATURAL: {
        enterOuterAlt(_localctx, 3);
        setState(1965);
        naturalJoinType();
        setState(1966);
        tableFactor();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerJoinTypeContext ------------------------------------------------------------------

MySQLStatementParser::InnerJoinTypeContext::InnerJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::InnerJoinTypeContext::JOIN() {
  return getToken(MySQLStatementParser::JOIN, 0);
}

tree::TerminalNode* MySQLStatementParser::InnerJoinTypeContext::INNER() {
  return getToken(MySQLStatementParser::INNER, 0);
}

tree::TerminalNode* MySQLStatementParser::InnerJoinTypeContext::CROSS() {
  return getToken(MySQLStatementParser::CROSS, 0);
}

tree::TerminalNode* MySQLStatementParser::InnerJoinTypeContext::STRAIGHT_JOIN() {
  return getToken(MySQLStatementParser::STRAIGHT_JOIN, 0);
}


size_t MySQLStatementParser::InnerJoinTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInnerJoinType;
}

void MySQLStatementParser::InnerJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerJoinType(this);
}

void MySQLStatementParser::InnerJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerJoinType(this);
}


antlrcpp::Any MySQLStatementParser::InnerJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInnerJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InnerJoinTypeContext* MySQLStatementParser::innerJoinType() {
  InnerJoinTypeContext *_localctx = _tracker.createInstance<InnerJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 128, MySQLStatementParser::RuleInnerJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1975);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CROSS:
      case MySQLStatementParser::INNER:
      case MySQLStatementParser::JOIN: {
        enterOuterAlt(_localctx, 1);
        setState(1971);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::CROSS || _la == MySQLStatementParser::INNER) {
          setState(1970);
          _la = _input->LA(1);
          if (!(_la == MySQLStatementParser::CROSS || _la == MySQLStatementParser::INNER)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(1973);
        match(MySQLStatementParser::JOIN);
        break;
      }

      case MySQLStatementParser::STRAIGHT_JOIN: {
        enterOuterAlt(_localctx, 2);
        setState(1974);
        match(MySQLStatementParser::STRAIGHT_JOIN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OuterJoinTypeContext ------------------------------------------------------------------

MySQLStatementParser::OuterJoinTypeContext::OuterJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OuterJoinTypeContext::JOIN() {
  return getToken(MySQLStatementParser::JOIN, 0);
}

tree::TerminalNode* MySQLStatementParser::OuterJoinTypeContext::LEFT() {
  return getToken(MySQLStatementParser::LEFT, 0);
}

tree::TerminalNode* MySQLStatementParser::OuterJoinTypeContext::RIGHT() {
  return getToken(MySQLStatementParser::RIGHT, 0);
}

tree::TerminalNode* MySQLStatementParser::OuterJoinTypeContext::OUTER() {
  return getToken(MySQLStatementParser::OUTER, 0);
}


size_t MySQLStatementParser::OuterJoinTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOuterJoinType;
}

void MySQLStatementParser::OuterJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOuterJoinType(this);
}

void MySQLStatementParser::OuterJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOuterJoinType(this);
}


antlrcpp::Any MySQLStatementParser::OuterJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOuterJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OuterJoinTypeContext* MySQLStatementParser::outerJoinType() {
  OuterJoinTypeContext *_localctx = _tracker.createInstance<OuterJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 130, MySQLStatementParser::RuleOuterJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1977);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::LEFT || _la == MySQLStatementParser::RIGHT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1979);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::OUTER) {
      setState(1978);
      match(MySQLStatementParser::OUTER);
    }
    setState(1981);
    match(MySQLStatementParser::JOIN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NaturalJoinTypeContext ------------------------------------------------------------------

MySQLStatementParser::NaturalJoinTypeContext::NaturalJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NaturalJoinTypeContext::NATURAL() {
  return getToken(MySQLStatementParser::NATURAL, 0);
}

tree::TerminalNode* MySQLStatementParser::NaturalJoinTypeContext::JOIN() {
  return getToken(MySQLStatementParser::JOIN, 0);
}

tree::TerminalNode* MySQLStatementParser::NaturalJoinTypeContext::INNER() {
  return getToken(MySQLStatementParser::INNER, 0);
}

tree::TerminalNode* MySQLStatementParser::NaturalJoinTypeContext::LEFT() {
  return getToken(MySQLStatementParser::LEFT, 0);
}

tree::TerminalNode* MySQLStatementParser::NaturalJoinTypeContext::RIGHT() {
  return getToken(MySQLStatementParser::RIGHT, 0);
}

tree::TerminalNode* MySQLStatementParser::NaturalJoinTypeContext::OUTER() {
  return getToken(MySQLStatementParser::OUTER, 0);
}


size_t MySQLStatementParser::NaturalJoinTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNaturalJoinType;
}

void MySQLStatementParser::NaturalJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNaturalJoinType(this);
}

void MySQLStatementParser::NaturalJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNaturalJoinType(this);
}


antlrcpp::Any MySQLStatementParser::NaturalJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNaturalJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NaturalJoinTypeContext* MySQLStatementParser::naturalJoinType() {
  NaturalJoinTypeContext *_localctx = _tracker.createInstance<NaturalJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 132, MySQLStatementParser::RuleNaturalJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1994);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1983);
      match(MySQLStatementParser::NATURAL);
      setState(1985);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::INNER) {
        setState(1984);
        match(MySQLStatementParser::INNER);
      }
      setState(1987);
      match(MySQLStatementParser::JOIN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1988);
      match(MySQLStatementParser::NATURAL);
      setState(1989);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LEFT || _la == MySQLStatementParser::RIGHT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1991);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::OUTER) {
        setState(1990);
        match(MySQLStatementParser::OUTER);
      }
      setState(1993);
      match(MySQLStatementParser::JOIN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::JoinSpecificationContext::JoinSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::JoinSpecificationContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::JoinSpecificationContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::JoinSpecificationContext::USING() {
  return getToken(MySQLStatementParser::USING, 0);
}

tree::TerminalNode* MySQLStatementParser::JoinSpecificationContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::JoinSpecificationContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::JoinSpecificationContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::JoinSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleJoinSpecification;
}

void MySQLStatementParser::JoinSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinSpecification(this);
}

void MySQLStatementParser::JoinSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinSpecification(this);
}


antlrcpp::Any MySQLStatementParser::JoinSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitJoinSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::JoinSpecificationContext* MySQLStatementParser::joinSpecification() {
  JoinSpecificationContext *_localctx = _tracker.createInstance<JoinSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 134, MySQLStatementParser::RuleJoinSpecification);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2003);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ON: {
        enterOuterAlt(_localctx, 1);
        setState(1996);
        match(MySQLStatementParser::ON);
        setState(1997);
        expr(0);
        break;
      }

      case MySQLStatementParser::USING: {
        enterOuterAlt(_localctx, 2);
        setState(1998);
        match(MySQLStatementParser::USING);
        setState(1999);
        match(MySQLStatementParser::LP_);
        setState(2000);
        columnNames();
        setState(2001);
        match(MySQLStatementParser::RP_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

MySQLStatementParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WhereClauseContext::WHERE() {
  return getToken(MySQLStatementParser::WHERE, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::WhereClauseContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::WhereClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWhereClause;
}

void MySQLStatementParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void MySQLStatementParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}


antlrcpp::Any MySQLStatementParser::WhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWhereClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WhereClauseContext* MySQLStatementParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 136, MySQLStatementParser::RuleWhereClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2005);
    match(MySQLStatementParser::WHERE);
    setState(2006);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupByClauseContext ------------------------------------------------------------------

MySQLStatementParser::GroupByClauseContext::GroupByClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::GroupByClauseContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

tree::TerminalNode* MySQLStatementParser::GroupByClauseContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

std::vector<MySQLStatementParser::OrderByItemContext *> MySQLStatementParser::GroupByClauseContext::orderByItem() {
  return getRuleContexts<MySQLStatementParser::OrderByItemContext>();
}

MySQLStatementParser::OrderByItemContext* MySQLStatementParser::GroupByClauseContext::orderByItem(size_t i) {
  return getRuleContext<MySQLStatementParser::OrderByItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::GroupByClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::GroupByClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::GroupByClauseContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::GroupByClauseContext::ROLLUP() {
  return getToken(MySQLStatementParser::ROLLUP, 0);
}


size_t MySQLStatementParser::GroupByClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGroupByClause;
}

void MySQLStatementParser::GroupByClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupByClause(this);
}

void MySQLStatementParser::GroupByClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupByClause(this);
}


antlrcpp::Any MySQLStatementParser::GroupByClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGroupByClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GroupByClauseContext* MySQLStatementParser::groupByClause() {
  GroupByClauseContext *_localctx = _tracker.createInstance<GroupByClauseContext>(_ctx, getState());
  enterRule(_localctx, 138, MySQLStatementParser::RuleGroupByClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2008);
    match(MySQLStatementParser::GROUP);
    setState(2009);
    match(MySQLStatementParser::BY);
    setState(2010);
    orderByItem();
    setState(2015);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2011);
        match(MySQLStatementParser::COMMA_);
        setState(2012);
        orderByItem(); 
      }
      setState(2017);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
    }
    setState(2020);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
    case 1: {
      setState(2018);
      match(MySQLStatementParser::WITH);
      setState(2019);
      match(MySQLStatementParser::ROLLUP);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

MySQLStatementParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HavingClauseContext::HAVING() {
  return getToken(MySQLStatementParser::HAVING, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::HavingClauseContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::HavingClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHavingClause;
}

void MySQLStatementParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void MySQLStatementParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}


antlrcpp::Any MySQLStatementParser::HavingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHavingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HavingClauseContext* MySQLStatementParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 140, MySQLStatementParser::RuleHavingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2022);
    match(MySQLStatementParser::HAVING);
    setState(2023);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitClauseContext ------------------------------------------------------------------

MySQLStatementParser::LimitClauseContext::LimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LimitClauseContext::LIMIT() {
  return getToken(MySQLStatementParser::LIMIT, 0);
}

MySQLStatementParser::LimitRowCountContext* MySQLStatementParser::LimitClauseContext::limitRowCount() {
  return getRuleContext<MySQLStatementParser::LimitRowCountContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LimitClauseContext::OFFSET() {
  return getToken(MySQLStatementParser::OFFSET, 0);
}

MySQLStatementParser::LimitOffsetContext* MySQLStatementParser::LimitClauseContext::limitOffset() {
  return getRuleContext<MySQLStatementParser::LimitOffsetContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LimitClauseContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::LimitClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLimitClause;
}

void MySQLStatementParser::LimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitClause(this);
}

void MySQLStatementParser::LimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitClause(this);
}


antlrcpp::Any MySQLStatementParser::LimitClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLimitClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LimitClauseContext* MySQLStatementParser::limitClause() {
  LimitClauseContext *_localctx = _tracker.createInstance<LimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 142, MySQLStatementParser::RuleLimitClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2025);
    match(MySQLStatementParser::LIMIT);
    setState(2036);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(2029);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
      case 1: {
        setState(2026);
        limitOffset();
        setState(2027);
        match(MySQLStatementParser::COMMA_);
        break;
      }

      }
      setState(2031);
      limitRowCount();
      break;
    }

    case 2: {
      setState(2032);
      limitRowCount();
      setState(2033);
      match(MySQLStatementParser::OFFSET);
      setState(2034);
      limitOffset();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitRowCountContext ------------------------------------------------------------------

MySQLStatementParser::LimitRowCountContext::LimitRowCountContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::LimitRowCountContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

MySQLStatementParser::ParameterMarkerContext* MySQLStatementParser::LimitRowCountContext::parameterMarker() {
  return getRuleContext<MySQLStatementParser::ParameterMarkerContext>(0);
}


size_t MySQLStatementParser::LimitRowCountContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLimitRowCount;
}

void MySQLStatementParser::LimitRowCountContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitRowCount(this);
}

void MySQLStatementParser::LimitRowCountContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitRowCount(this);
}


antlrcpp::Any MySQLStatementParser::LimitRowCountContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLimitRowCount(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LimitRowCountContext* MySQLStatementParser::limitRowCount() {
  LimitRowCountContext *_localctx = _tracker.createInstance<LimitRowCountContext>(_ctx, getState());
  enterRule(_localctx, 144, MySQLStatementParser::RuleLimitRowCount);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2040);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::NUMBER_: {
        enterOuterAlt(_localctx, 1);
        setState(2038);
        numberLiterals();
        break;
      }

      case MySQLStatementParser::QUESTION_: {
        enterOuterAlt(_localctx, 2);
        setState(2039);
        parameterMarker();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOffsetContext ------------------------------------------------------------------

MySQLStatementParser::LimitOffsetContext::LimitOffsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::LimitOffsetContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

MySQLStatementParser::ParameterMarkerContext* MySQLStatementParser::LimitOffsetContext::parameterMarker() {
  return getRuleContext<MySQLStatementParser::ParameterMarkerContext>(0);
}


size_t MySQLStatementParser::LimitOffsetContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLimitOffset;
}

void MySQLStatementParser::LimitOffsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitOffset(this);
}

void MySQLStatementParser::LimitOffsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitOffset(this);
}


antlrcpp::Any MySQLStatementParser::LimitOffsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLimitOffset(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LimitOffsetContext* MySQLStatementParser::limitOffset() {
  LimitOffsetContext *_localctx = _tracker.createInstance<LimitOffsetContext>(_ctx, getState());
  enterRule(_localctx, 146, MySQLStatementParser::RuleLimitOffset);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2044);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::NUMBER_: {
        enterOuterAlt(_localctx, 1);
        setState(2042);
        numberLiterals();
        break;
      }

      case MySQLStatementParser::QUESTION_: {
        enterOuterAlt(_localctx, 2);
        setState(2043);
        parameterMarker();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

MySQLStatementParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WindowClauseContext::WINDOW() {
  return getToken(MySQLStatementParser::WINDOW, 0);
}

std::vector<MySQLStatementParser::WindowItemContext *> MySQLStatementParser::WindowClauseContext::windowItem() {
  return getRuleContexts<MySQLStatementParser::WindowItemContext>();
}

MySQLStatementParser::WindowItemContext* MySQLStatementParser::WindowClauseContext::windowItem(size_t i) {
  return getRuleContext<MySQLStatementParser::WindowItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::WindowClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::WindowClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::WindowClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWindowClause;
}

void MySQLStatementParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void MySQLStatementParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}


antlrcpp::Any MySQLStatementParser::WindowClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWindowClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WindowClauseContext* MySQLStatementParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 148, MySQLStatementParser::RuleWindowClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2046);
    match(MySQLStatementParser::WINDOW);
    setState(2047);
    windowItem();
    setState(2052);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2048);
        match(MySQLStatementParser::COMMA_);
        setState(2049);
        windowItem(); 
      }
      setState(2054);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowItemContext ------------------------------------------------------------------

MySQLStatementParser::WindowItemContext::WindowItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::WindowItemContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WindowItemContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowItemContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::WindowSpecificationContext* MySQLStatementParser::WindowItemContext::windowSpecification() {
  return getRuleContext<MySQLStatementParser::WindowSpecificationContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WindowItemContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::WindowItemContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWindowItem;
}

void MySQLStatementParser::WindowItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowItem(this);
}

void MySQLStatementParser::WindowItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowItem(this);
}


antlrcpp::Any MySQLStatementParser::WindowItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWindowItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WindowItemContext* MySQLStatementParser::windowItem() {
  WindowItemContext *_localctx = _tracker.createInstance<WindowItemContext>(_ctx, getState());
  enterRule(_localctx, 150, MySQLStatementParser::RuleWindowItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2055);
    identifier();
    setState(2056);
    match(MySQLStatementParser::AS);
    setState(2057);
    match(MySQLStatementParser::LP_);
    setState(2058);
    windowSpecification();
    setState(2059);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

MySQLStatementParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::QueryExpressionParensContext* MySQLStatementParser::SubqueryContext::queryExpressionParens() {
  return getRuleContext<MySQLStatementParser::QueryExpressionParensContext>(0);
}


size_t MySQLStatementParser::SubqueryContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSubquery;
}

void MySQLStatementParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}

void MySQLStatementParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}


antlrcpp::Any MySQLStatementParser::SubqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSubquery(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SubqueryContext* MySQLStatementParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 152, MySQLStatementParser::RuleSubquery);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2061);
    queryExpressionParens();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectLinesIntoContext ------------------------------------------------------------------

MySQLStatementParser::SelectLinesIntoContext::SelectLinesIntoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SelectLinesIntoContext::STARTING() {
  return getToken(MySQLStatementParser::STARTING, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectLinesIntoContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::SelectLinesIntoContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::SelectLinesIntoContext::TERMINATED() {
  return getToken(MySQLStatementParser::TERMINATED, 0);
}


size_t MySQLStatementParser::SelectLinesIntoContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSelectLinesInto;
}

void MySQLStatementParser::SelectLinesIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectLinesInto(this);
}

void MySQLStatementParser::SelectLinesIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectLinesInto(this);
}


antlrcpp::Any MySQLStatementParser::SelectLinesIntoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSelectLinesInto(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SelectLinesIntoContext* MySQLStatementParser::selectLinesInto() {
  SelectLinesIntoContext *_localctx = _tracker.createInstance<SelectLinesIntoContext>(_ctx, getState());
  enterRule(_localctx, 154, MySQLStatementParser::RuleSelectLinesInto);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2069);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::STARTING: {
        enterOuterAlt(_localctx, 1);
        setState(2063);
        match(MySQLStatementParser::STARTING);
        setState(2064);
        match(MySQLStatementParser::BY);
        setState(2065);
        string_();
        break;
      }

      case MySQLStatementParser::TERMINATED: {
        enterOuterAlt(_localctx, 2);
        setState(2066);
        match(MySQLStatementParser::TERMINATED);
        setState(2067);
        match(MySQLStatementParser::BY);
        setState(2068);
        string_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectFieldsIntoContext ------------------------------------------------------------------

MySQLStatementParser::SelectFieldsIntoContext::SelectFieldsIntoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SelectFieldsIntoContext::TERMINATED() {
  return getToken(MySQLStatementParser::TERMINATED, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectFieldsIntoContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::SelectFieldsIntoContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::SelectFieldsIntoContext::ENCLOSED() {
  return getToken(MySQLStatementParser::ENCLOSED, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectFieldsIntoContext::OPTIONALLY() {
  return getToken(MySQLStatementParser::OPTIONALLY, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectFieldsIntoContext::ESCAPED() {
  return getToken(MySQLStatementParser::ESCAPED, 0);
}


size_t MySQLStatementParser::SelectFieldsIntoContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSelectFieldsInto;
}

void MySQLStatementParser::SelectFieldsIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectFieldsInto(this);
}

void MySQLStatementParser::SelectFieldsIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectFieldsInto(this);
}


antlrcpp::Any MySQLStatementParser::SelectFieldsIntoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSelectFieldsInto(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SelectFieldsIntoContext* MySQLStatementParser::selectFieldsInto() {
  SelectFieldsIntoContext *_localctx = _tracker.createInstance<SelectFieldsIntoContext>(_ctx, getState());
  enterRule(_localctx, 156, MySQLStatementParser::RuleSelectFieldsInto);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2083);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::TERMINATED: {
        enterOuterAlt(_localctx, 1);
        setState(2071);
        match(MySQLStatementParser::TERMINATED);
        setState(2072);
        match(MySQLStatementParser::BY);
        setState(2073);
        string_();
        break;
      }

      case MySQLStatementParser::ENCLOSED:
      case MySQLStatementParser::OPTIONALLY: {
        enterOuterAlt(_localctx, 2);
        setState(2075);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::OPTIONALLY) {
          setState(2074);
          match(MySQLStatementParser::OPTIONALLY);
        }
        setState(2077);
        match(MySQLStatementParser::ENCLOSED);
        setState(2078);
        match(MySQLStatementParser::BY);
        setState(2079);
        string_();
        break;
      }

      case MySQLStatementParser::ESCAPED: {
        enterOuterAlt(_localctx, 3);
        setState(2080);
        match(MySQLStatementParser::ESCAPED);
        setState(2081);
        match(MySQLStatementParser::BY);
        setState(2082);
        string_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectIntoExpressionContext ------------------------------------------------------------------

MySQLStatementParser::SelectIntoExpressionContext::SelectIntoExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

std::vector<MySQLStatementParser::VariableContext *> MySQLStatementParser::SelectIntoExpressionContext::variable() {
  return getRuleContexts<MySQLStatementParser::VariableContext>();
}

MySQLStatementParser::VariableContext* MySQLStatementParser::SelectIntoExpressionContext::variable(size_t i) {
  return getRuleContext<MySQLStatementParser::VariableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SelectIntoExpressionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::DUMPFILE() {
  return getToken(MySQLStatementParser::DUMPFILE, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::SelectIntoExpressionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::OUTFILE() {
  return getToken(MySQLStatementParser::OUTFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::CHARACTER() {
  return getToken(MySQLStatementParser::CHARACTER, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::SelectIntoExpressionContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::LINES() {
  return getToken(MySQLStatementParser::LINES, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::FIELDS() {
  return getToken(MySQLStatementParser::FIELDS, 0);
}

tree::TerminalNode* MySQLStatementParser::SelectIntoExpressionContext::COLUMNS() {
  return getToken(MySQLStatementParser::COLUMNS, 0);
}

std::vector<MySQLStatementParser::SelectFieldsIntoContext *> MySQLStatementParser::SelectIntoExpressionContext::selectFieldsInto() {
  return getRuleContexts<MySQLStatementParser::SelectFieldsIntoContext>();
}

MySQLStatementParser::SelectFieldsIntoContext* MySQLStatementParser::SelectIntoExpressionContext::selectFieldsInto(size_t i) {
  return getRuleContext<MySQLStatementParser::SelectFieldsIntoContext>(i);
}

std::vector<MySQLStatementParser::SelectLinesIntoContext *> MySQLStatementParser::SelectIntoExpressionContext::selectLinesInto() {
  return getRuleContexts<MySQLStatementParser::SelectLinesIntoContext>();
}

MySQLStatementParser::SelectLinesIntoContext* MySQLStatementParser::SelectIntoExpressionContext::selectLinesInto(size_t i) {
  return getRuleContext<MySQLStatementParser::SelectLinesIntoContext>(i);
}


size_t MySQLStatementParser::SelectIntoExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSelectIntoExpression;
}

void MySQLStatementParser::SelectIntoExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectIntoExpression(this);
}

void MySQLStatementParser::SelectIntoExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectIntoExpression(this);
}


antlrcpp::Any MySQLStatementParser::SelectIntoExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSelectIntoExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SelectIntoExpressionContext* MySQLStatementParser::selectIntoExpression() {
  SelectIntoExpressionContext *_localctx = _tracker.createInstance<SelectIntoExpressionContext>(_ctx, getState());
  enterRule(_localctx, 158, MySQLStatementParser::RuleSelectIntoExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2121);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2085);
      match(MySQLStatementParser::INTO);
      setState(2086);
      variable();
      setState(2091);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2087);
          match(MySQLStatementParser::COMMA_);
          setState(2088);
          variable(); 
        }
        setState(2093);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2094);
      match(MySQLStatementParser::INTO);
      setState(2095);
      match(MySQLStatementParser::DUMPFILE);
      setState(2096);
      string_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2097);
      match(MySQLStatementParser::INTO);
      setState(2098);
      match(MySQLStatementParser::OUTFILE);
      setState(2099);
      string_();
      setState(2103);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
      case 1: {
        setState(2100);
        match(MySQLStatementParser::CHARACTER);
        setState(2101);
        match(MySQLStatementParser::SET);
        setState(2102);
        charsetName();
        break;
      }

      }
      setState(2111);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
      case 1: {
        setState(2105);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::COLUMNS || _la == MySQLStatementParser::FIELDS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2107); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2106);
                  selectFieldsInto();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(2109); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      }
      setState(2119);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
      case 1: {
        setState(2113);
        match(MySQLStatementParser::LINES);
        setState(2115); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2114);
                  selectLinesInto();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(2117); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockClauseContext ------------------------------------------------------------------

MySQLStatementParser::LockClauseContext::LockClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LockClauseContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

MySQLStatementParser::LockStrengthContext* MySQLStatementParser::LockClauseContext::lockStrength() {
  return getRuleContext<MySQLStatementParser::LockStrengthContext>(0);
}

MySQLStatementParser::TableLockingListContext* MySQLStatementParser::LockClauseContext::tableLockingList() {
  return getRuleContext<MySQLStatementParser::TableLockingListContext>(0);
}

MySQLStatementParser::LockedRowActionContext* MySQLStatementParser::LockClauseContext::lockedRowAction() {
  return getRuleContext<MySQLStatementParser::LockedRowActionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LockClauseContext::LOCK() {
  return getToken(MySQLStatementParser::LOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::LockClauseContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

tree::TerminalNode* MySQLStatementParser::LockClauseContext::SHARE() {
  return getToken(MySQLStatementParser::SHARE, 0);
}

tree::TerminalNode* MySQLStatementParser::LockClauseContext::MODE() {
  return getToken(MySQLStatementParser::MODE, 0);
}


size_t MySQLStatementParser::LockClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLockClause;
}

void MySQLStatementParser::LockClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockClause(this);
}

void MySQLStatementParser::LockClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockClause(this);
}


antlrcpp::Any MySQLStatementParser::LockClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLockClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LockClauseContext* MySQLStatementParser::lockClause() {
  LockClauseContext *_localctx = _tracker.createInstance<LockClauseContext>(_ctx, getState());
  enterRule(_localctx, 160, MySQLStatementParser::RuleLockClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2135);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(2123);
        match(MySQLStatementParser::FOR);
        setState(2124);
        lockStrength();
        setState(2126);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::OF) {
          setState(2125);
          tableLockingList();
        }
        setState(2129);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
        case 1: {
          setState(2128);
          lockedRowAction();
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::LOCK: {
        enterOuterAlt(_localctx, 2);
        setState(2131);
        match(MySQLStatementParser::LOCK);
        setState(2132);
        match(MySQLStatementParser::IN);
        setState(2133);
        match(MySQLStatementParser::SHARE);
        setState(2134);
        match(MySQLStatementParser::MODE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockClauseListContext ------------------------------------------------------------------

MySQLStatementParser::LockClauseListContext::LockClauseListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::LockClauseContext *> MySQLStatementParser::LockClauseListContext::lockClause() {
  return getRuleContexts<MySQLStatementParser::LockClauseContext>();
}

MySQLStatementParser::LockClauseContext* MySQLStatementParser::LockClauseListContext::lockClause(size_t i) {
  return getRuleContext<MySQLStatementParser::LockClauseContext>(i);
}


size_t MySQLStatementParser::LockClauseListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLockClauseList;
}

void MySQLStatementParser::LockClauseListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockClauseList(this);
}

void MySQLStatementParser::LockClauseListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockClauseList(this);
}


antlrcpp::Any MySQLStatementParser::LockClauseListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLockClauseList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LockClauseListContext* MySQLStatementParser::lockClauseList() {
  LockClauseListContext *_localctx = _tracker.createInstance<LockClauseListContext>(_ctx, getState());
  enterRule(_localctx, 162, MySQLStatementParser::RuleLockClauseList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2138); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2137);
      lockClause();
      setState(2140); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLStatementParser::FOR || _la == MySQLStatementParser::LOCK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStrengthContext ------------------------------------------------------------------

MySQLStatementParser::LockStrengthContext::LockStrengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LockStrengthContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

tree::TerminalNode* MySQLStatementParser::LockStrengthContext::SHARE() {
  return getToken(MySQLStatementParser::SHARE, 0);
}


size_t MySQLStatementParser::LockStrengthContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLockStrength;
}

void MySQLStatementParser::LockStrengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStrength(this);
}

void MySQLStatementParser::LockStrengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStrength(this);
}


antlrcpp::Any MySQLStatementParser::LockStrengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLockStrength(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LockStrengthContext* MySQLStatementParser::lockStrength() {
  LockStrengthContext *_localctx = _tracker.createInstance<LockStrengthContext>(_ctx, getState());
  enterRule(_localctx, 164, MySQLStatementParser::RuleLockStrength);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2142);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::SHARE || _la == MySQLStatementParser::UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockedRowActionContext ------------------------------------------------------------------

MySQLStatementParser::LockedRowActionContext::LockedRowActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LockedRowActionContext::SKIP_SYMBOL() {
  return getToken(MySQLStatementParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode* MySQLStatementParser::LockedRowActionContext::LOCKED() {
  return getToken(MySQLStatementParser::LOCKED, 0);
}

tree::TerminalNode* MySQLStatementParser::LockedRowActionContext::NOWAIT() {
  return getToken(MySQLStatementParser::NOWAIT, 0);
}


size_t MySQLStatementParser::LockedRowActionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLockedRowAction;
}

void MySQLStatementParser::LockedRowActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockedRowAction(this);
}

void MySQLStatementParser::LockedRowActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockedRowAction(this);
}


antlrcpp::Any MySQLStatementParser::LockedRowActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLockedRowAction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LockedRowActionContext* MySQLStatementParser::lockedRowAction() {
  LockedRowActionContext *_localctx = _tracker.createInstance<LockedRowActionContext>(_ctx, getState());
  enterRule(_localctx, 166, MySQLStatementParser::RuleLockedRowAction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2147);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SKIP_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2144);
        match(MySQLStatementParser::SKIP_SYMBOL);
        setState(2145);
        match(MySQLStatementParser::LOCKED);
        break;
      }

      case MySQLStatementParser::NOWAIT: {
        enterOuterAlt(_localctx, 2);
        setState(2146);
        match(MySQLStatementParser::NOWAIT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableLockingListContext ------------------------------------------------------------------

MySQLStatementParser::TableLockingListContext::TableLockingListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TableLockingListContext::OF() {
  return getToken(MySQLStatementParser::OF, 0);
}

MySQLStatementParser::TableAliasRefListContext* MySQLStatementParser::TableLockingListContext::tableAliasRefList() {
  return getRuleContext<MySQLStatementParser::TableAliasRefListContext>(0);
}


size_t MySQLStatementParser::TableLockingListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableLockingList;
}

void MySQLStatementParser::TableLockingListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableLockingList(this);
}

void MySQLStatementParser::TableLockingListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableLockingList(this);
}


antlrcpp::Any MySQLStatementParser::TableLockingListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableLockingList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableLockingListContext* MySQLStatementParser::tableLockingList() {
  TableLockingListContext *_localctx = _tracker.createInstance<TableLockingListContext>(_ctx, getState());
  enterRule(_localctx, 168, MySQLStatementParser::RuleTableLockingList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2149);
    match(MySQLStatementParser::OF);
    setState(2150);
    tableAliasRefList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableIdentOptWildContext ------------------------------------------------------------------

MySQLStatementParser::TableIdentOptWildContext::TableIdentOptWildContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::TableIdentOptWildContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableIdentOptWildContext::DOT_ASTERISK_() {
  return getToken(MySQLStatementParser::DOT_ASTERISK_, 0);
}


size_t MySQLStatementParser::TableIdentOptWildContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableIdentOptWild;
}

void MySQLStatementParser::TableIdentOptWildContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableIdentOptWild(this);
}

void MySQLStatementParser::TableIdentOptWildContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableIdentOptWild(this);
}


antlrcpp::Any MySQLStatementParser::TableIdentOptWildContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableIdentOptWild(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableIdentOptWildContext* MySQLStatementParser::tableIdentOptWild() {
  TableIdentOptWildContext *_localctx = _tracker.createInstance<TableIdentOptWildContext>(_ctx, getState());
  enterRule(_localctx, 170, MySQLStatementParser::RuleTableIdentOptWild);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2152);
    tableName();
    setState(2154);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DOT_ASTERISK_) {
      setState(2153);
      match(MySQLStatementParser::DOT_ASTERISK_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasRefListContext ------------------------------------------------------------------

MySQLStatementParser::TableAliasRefListContext::TableAliasRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::TableIdentOptWildContext *> MySQLStatementParser::TableAliasRefListContext::tableIdentOptWild() {
  return getRuleContexts<MySQLStatementParser::TableIdentOptWildContext>();
}

MySQLStatementParser::TableIdentOptWildContext* MySQLStatementParser::TableAliasRefListContext::tableIdentOptWild(size_t i) {
  return getRuleContext<MySQLStatementParser::TableIdentOptWildContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableAliasRefListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::TableAliasRefListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::TableAliasRefListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableAliasRefList;
}

void MySQLStatementParser::TableAliasRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAliasRefList(this);
}

void MySQLStatementParser::TableAliasRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAliasRefList(this);
}


antlrcpp::Any MySQLStatementParser::TableAliasRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableAliasRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableAliasRefListContext* MySQLStatementParser::tableAliasRefList() {
  TableAliasRefListContext *_localctx = _tracker.createInstance<TableAliasRefListContext>(_ctx, getState());
  enterRule(_localctx, 172, MySQLStatementParser::RuleTableAliasRefList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2156);
    tableIdentOptWild();
    setState(2161);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(2157);
      match(MySQLStatementParser::COMMA_);
      setState(2158);
      tableIdentOptWild();
      setState(2163);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterStatementContext ------------------------------------------------------------------

MySQLStatementParser::AlterStatementContext::AlterStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::AlterTableContext* MySQLStatementParser::AlterStatementContext::alterTable() {
  return getRuleContext<MySQLStatementParser::AlterTableContext>(0);
}

MySQLStatementParser::AlterDatabaseContext* MySQLStatementParser::AlterStatementContext::alterDatabase() {
  return getRuleContext<MySQLStatementParser::AlterDatabaseContext>(0);
}

MySQLStatementParser::AlterProcedureContext* MySQLStatementParser::AlterStatementContext::alterProcedure() {
  return getRuleContext<MySQLStatementParser::AlterProcedureContext>(0);
}

MySQLStatementParser::AlterFunctionContext* MySQLStatementParser::AlterStatementContext::alterFunction() {
  return getRuleContext<MySQLStatementParser::AlterFunctionContext>(0);
}

MySQLStatementParser::AlterEventContext* MySQLStatementParser::AlterStatementContext::alterEvent() {
  return getRuleContext<MySQLStatementParser::AlterEventContext>(0);
}

MySQLStatementParser::AlterViewContext* MySQLStatementParser::AlterStatementContext::alterView() {
  return getRuleContext<MySQLStatementParser::AlterViewContext>(0);
}

MySQLStatementParser::AlterTablespaceInnodbContext* MySQLStatementParser::AlterStatementContext::alterTablespaceInnodb() {
  return getRuleContext<MySQLStatementParser::AlterTablespaceInnodbContext>(0);
}

MySQLStatementParser::AlterTablespaceNdbContext* MySQLStatementParser::AlterStatementContext::alterTablespaceNdb() {
  return getRuleContext<MySQLStatementParser::AlterTablespaceNdbContext>(0);
}

MySQLStatementParser::AlterLogfileGroupContext* MySQLStatementParser::AlterStatementContext::alterLogfileGroup() {
  return getRuleContext<MySQLStatementParser::AlterLogfileGroupContext>(0);
}

MySQLStatementParser::AlterInstanceContext* MySQLStatementParser::AlterStatementContext::alterInstance() {
  return getRuleContext<MySQLStatementParser::AlterInstanceContext>(0);
}

MySQLStatementParser::AlterServerContext* MySQLStatementParser::AlterStatementContext::alterServer() {
  return getRuleContext<MySQLStatementParser::AlterServerContext>(0);
}


size_t MySQLStatementParser::AlterStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterStatement;
}

void MySQLStatementParser::AlterStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterStatement(this);
}

void MySQLStatementParser::AlterStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterStatement(this);
}


antlrcpp::Any MySQLStatementParser::AlterStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterStatementContext* MySQLStatementParser::alterStatement() {
  AlterStatementContext *_localctx = _tracker.createInstance<AlterStatementContext>(_ctx, getState());
  enterRule(_localctx, 174, MySQLStatementParser::RuleAlterStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2175);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2164);
      alterTable();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2165);
      alterDatabase();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2166);
      alterProcedure();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2167);
      alterFunction();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2168);
      alterEvent();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2169);
      alterView();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2170);
      alterTablespaceInnodb();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2171);
      alterTablespaceNdb();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2172);
      alterLogfileGroup();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2173);
      alterInstance();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2174);
      alterServer();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableContext ------------------------------------------------------------------

MySQLStatementParser::CreateTableContext::CreateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateTableContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::CreateTableContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::CreateLikeClauseContext* MySQLStatementParser::CreateTableContext::createLikeClause() {
  return getRuleContext<MySQLStatementParser::CreateLikeClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableContext::TEMPORARY() {
  return getToken(MySQLStatementParser::TEMPORARY, 0);
}

MySQLStatementParser::NotExistClauseContext* MySQLStatementParser::CreateTableContext::notExistClause() {
  return getRuleContext<MySQLStatementParser::NotExistClauseContext>(0);
}

MySQLStatementParser::CreateDefinitionClauseContext* MySQLStatementParser::CreateTableContext::createDefinitionClause() {
  return getRuleContext<MySQLStatementParser::CreateDefinitionClauseContext>(0);
}

MySQLStatementParser::CreateTableOptionsContext* MySQLStatementParser::CreateTableContext::createTableOptions() {
  return getRuleContext<MySQLStatementParser::CreateTableOptionsContext>(0);
}

MySQLStatementParser::PartitionClauseContext* MySQLStatementParser::CreateTableContext::partitionClause() {
  return getRuleContext<MySQLStatementParser::PartitionClauseContext>(0);
}

MySQLStatementParser::DuplicateAsQueryExpressionContext* MySQLStatementParser::CreateTableContext::duplicateAsQueryExpression() {
  return getRuleContext<MySQLStatementParser::DuplicateAsQueryExpressionContext>(0);
}


size_t MySQLStatementParser::CreateTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateTable;
}

void MySQLStatementParser::CreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTable(this);
}

void MySQLStatementParser::CreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTable(this);
}


antlrcpp::Any MySQLStatementParser::CreateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateTableContext* MySQLStatementParser::createTable() {
  CreateTableContext *_localctx = _tracker.createInstance<CreateTableContext>(_ctx, getState());
  enterRule(_localctx, 176, MySQLStatementParser::RuleCreateTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2177);
    match(MySQLStatementParser::CREATE);
    setState(2179);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::TEMPORARY) {
      setState(2178);
      match(MySQLStatementParser::TEMPORARY);
    }
    setState(2181);
    match(MySQLStatementParser::TABLE);
    setState(2183);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(2182);
      notExistClause();
    }
    setState(2185);
    tableName();
    setState(2199);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(2187);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
      case 1: {
        setState(2186);
        createDefinitionClause();
        break;
      }

      }
      setState(2190);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
      case 1: {
        setState(2189);
        createTableOptions();
        break;
      }

      }
      setState(2193);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::PARTITION) {
        setState(2192);
        partitionClause();
      }
      setState(2196);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
      case 1: {
        setState(2195);
        duplicateAsQueryExpression();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2198);
      createLikeClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionClauseContext ------------------------------------------------------------------

MySQLStatementParser::PartitionClauseContext::PartitionClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionClauseContext::PARTITION() {
  return getToken(MySQLStatementParser::PARTITION, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionClauseContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

MySQLStatementParser::PartitionTypeDefContext* MySQLStatementParser::PartitionClauseContext::partitionTypeDef() {
  return getRuleContext<MySQLStatementParser::PartitionTypeDefContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionClauseContext::PARTITIONS() {
  return getToken(MySQLStatementParser::PARTITIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionClauseContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

MySQLStatementParser::SubPartitionsContext* MySQLStatementParser::PartitionClauseContext::subPartitions() {
  return getRuleContext<MySQLStatementParser::SubPartitionsContext>(0);
}

MySQLStatementParser::PartitionDefinitionsContext* MySQLStatementParser::PartitionClauseContext::partitionDefinitions() {
  return getRuleContext<MySQLStatementParser::PartitionDefinitionsContext>(0);
}


size_t MySQLStatementParser::PartitionClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionClause;
}

void MySQLStatementParser::PartitionClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionClause(this);
}

void MySQLStatementParser::PartitionClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionClause(this);
}


antlrcpp::Any MySQLStatementParser::PartitionClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionClauseContext* MySQLStatementParser::partitionClause() {
  PartitionClauseContext *_localctx = _tracker.createInstance<PartitionClauseContext>(_ctx, getState());
  enterRule(_localctx, 178, MySQLStatementParser::RulePartitionClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2201);
    match(MySQLStatementParser::PARTITION);
    setState(2202);
    match(MySQLStatementParser::BY);
    setState(2203);
    partitionTypeDef();
    setState(2206);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PARTITIONS) {
      setState(2204);
      match(MySQLStatementParser::PARTITIONS);
      setState(2205);
      match(MySQLStatementParser::NUMBER_);
    }
    setState(2209);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
    case 1: {
      setState(2208);
      subPartitions();
      break;
    }

    }
    setState(2212);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx)) {
    case 1: {
      setState(2211);
      partitionDefinitions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionTypeDefContext ------------------------------------------------------------------

MySQLStatementParser::PartitionTypeDefContext::PartitionTypeDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::LINEAR() {
  return getToken(MySQLStatementParser::LINEAR, 0);
}

MySQLStatementParser::PartitionKeyAlgorithmContext* MySQLStatementParser::PartitionTypeDefContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLStatementParser::PartitionKeyAlgorithmContext>(0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::PartitionTypeDefContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::HASH() {
  return getToken(MySQLStatementParser::HASH, 0);
}

MySQLStatementParser::BitExprContext* MySQLStatementParser::PartitionTypeDefContext::bitExpr() {
  return getRuleContext<MySQLStatementParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::RANGE() {
  return getToken(MySQLStatementParser::RANGE, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::LIST() {
  return getToken(MySQLStatementParser::LIST, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionTypeDefContext::COLUMNS() {
  return getToken(MySQLStatementParser::COLUMNS, 0);
}


size_t MySQLStatementParser::PartitionTypeDefContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionTypeDef;
}

void MySQLStatementParser::PartitionTypeDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionTypeDef(this);
}

void MySQLStatementParser::PartitionTypeDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionTypeDef(this);
}


antlrcpp::Any MySQLStatementParser::PartitionTypeDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionTypeDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionTypeDefContext* MySQLStatementParser::partitionTypeDef() {
  PartitionTypeDefContext *_localctx = _tracker.createInstance<PartitionTypeDefContext>(_ctx, getState());
  enterRule(_localctx, 180, MySQLStatementParser::RulePartitionTypeDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2246);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2215);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::LINEAR) {
        setState(2214);
        match(MySQLStatementParser::LINEAR);
      }
      setState(2217);
      match(MySQLStatementParser::KEY);
      setState(2219);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::ALGORITHM) {
        setState(2218);
        partitionKeyAlgorithm();
      }
      setState(2221);
      match(MySQLStatementParser::LP_);
      setState(2223);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(2222);
        columnNames();
      }
      setState(2225);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2227);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::LINEAR) {
        setState(2226);
        match(MySQLStatementParser::LINEAR);
      }
      setState(2229);
      match(MySQLStatementParser::HASH);
      setState(2230);
      match(MySQLStatementParser::LP_);
      setState(2231);
      bitExpr(0);
      setState(2232);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2234);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LIST || _la == MySQLStatementParser::RANGE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2244);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::LP_: {
          setState(2235);
          match(MySQLStatementParser::LP_);
          setState(2236);
          bitExpr(0);
          setState(2237);
          match(MySQLStatementParser::RP_);
          break;
        }

        case MySQLStatementParser::COLUMNS: {
          setState(2239);
          match(MySQLStatementParser::COLUMNS);
          setState(2240);
          match(MySQLStatementParser::LP_);
          setState(2241);
          columnNames();
          setState(2242);
          match(MySQLStatementParser::RP_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubPartitionsContext ------------------------------------------------------------------

MySQLStatementParser::SubPartitionsContext::SubPartitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::SUBPARTITION() {
  return getToken(MySQLStatementParser::SUBPARTITION, 0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::HASH() {
  return getToken(MySQLStatementParser::HASH, 0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::BitExprContext* MySQLStatementParser::SubPartitionsContext::bitExpr() {
  return getRuleContext<MySQLStatementParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::SubPartitionsContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::LINEAR() {
  return getToken(MySQLStatementParser::LINEAR, 0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::SUBPARTITIONS() {
  return getToken(MySQLStatementParser::SUBPARTITIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::SubPartitionsContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

MySQLStatementParser::PartitionKeyAlgorithmContext* MySQLStatementParser::SubPartitionsContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLStatementParser::PartitionKeyAlgorithmContext>(0);
}


size_t MySQLStatementParser::SubPartitionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSubPartitions;
}

void MySQLStatementParser::SubPartitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubPartitions(this);
}

void MySQLStatementParser::SubPartitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubPartitions(this);
}


antlrcpp::Any MySQLStatementParser::SubPartitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSubPartitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SubPartitionsContext* MySQLStatementParser::subPartitions() {
  SubPartitionsContext *_localctx = _tracker.createInstance<SubPartitionsContext>(_ctx, getState());
  enterRule(_localctx, 182, MySQLStatementParser::RuleSubPartitions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2248);
    match(MySQLStatementParser::SUBPARTITION);
    setState(2249);
    match(MySQLStatementParser::BY);
    setState(2251);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LINEAR) {
      setState(2250);
      match(MySQLStatementParser::LINEAR);
    }
    setState(2266);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::HASH: {
        setState(2253);
        match(MySQLStatementParser::HASH);
        setState(2254);
        match(MySQLStatementParser::LP_);
        setState(2255);
        bitExpr(0);
        setState(2256);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::KEY: {
        setState(2258);
        match(MySQLStatementParser::KEY);
        setState(2260);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ALGORITHM) {
          setState(2259);
          partitionKeyAlgorithm();
        }
        setState(2262);
        match(MySQLStatementParser::LP_);
        setState(2263);
        columnNames();
        setState(2264);
        match(MySQLStatementParser::RP_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2270);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
    case 1: {
      setState(2268);
      match(MySQLStatementParser::SUBPARTITIONS);
      setState(2269);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionKeyAlgorithmContext ------------------------------------------------------------------

MySQLStatementParser::PartitionKeyAlgorithmContext::PartitionKeyAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionKeyAlgorithmContext::ALGORITHM() {
  return getToken(MySQLStatementParser::ALGORITHM, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionKeyAlgorithmContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionKeyAlgorithmContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::PartitionKeyAlgorithmContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionKeyAlgorithm;
}

void MySQLStatementParser::PartitionKeyAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionKeyAlgorithm(this);
}

void MySQLStatementParser::PartitionKeyAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionKeyAlgorithm(this);
}


antlrcpp::Any MySQLStatementParser::PartitionKeyAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionKeyAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionKeyAlgorithmContext* MySQLStatementParser::partitionKeyAlgorithm() {
  PartitionKeyAlgorithmContext *_localctx = _tracker.createInstance<PartitionKeyAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 184, MySQLStatementParser::RulePartitionKeyAlgorithm);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2272);
    match(MySQLStatementParser::ALGORITHM);
    setState(2273);
    match(MySQLStatementParser::EQ_);
    setState(2274);
    match(MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DuplicateAsQueryExpressionContext ------------------------------------------------------------------

MySQLStatementParser::DuplicateAsQueryExpressionContext::DuplicateAsQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SelectContext* MySQLStatementParser::DuplicateAsQueryExpressionContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DuplicateAsQueryExpressionContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

tree::TerminalNode* MySQLStatementParser::DuplicateAsQueryExpressionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::DuplicateAsQueryExpressionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::DuplicateAsQueryExpressionContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::DuplicateAsQueryExpressionContext::IGNORE() {
  return getToken(MySQLStatementParser::IGNORE, 0);
}


size_t MySQLStatementParser::DuplicateAsQueryExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDuplicateAsQueryExpression;
}

void MySQLStatementParser::DuplicateAsQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDuplicateAsQueryExpression(this);
}

void MySQLStatementParser::DuplicateAsQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDuplicateAsQueryExpression(this);
}


antlrcpp::Any MySQLStatementParser::DuplicateAsQueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDuplicateAsQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DuplicateAsQueryExpressionContext* MySQLStatementParser::duplicateAsQueryExpression() {
  DuplicateAsQueryExpressionContext *_localctx = _tracker.createInstance<DuplicateAsQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 186, MySQLStatementParser::RuleDuplicateAsQueryExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2277);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::REPLACE) {
      setState(2276);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::REPLACE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2280);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(2279);
      match(MySQLStatementParser::AS);
    }
    setState(2283);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(2282);
      match(MySQLStatementParser::LP_);
      break;
    }

    }
    setState(2285);
    select();
    setState(2287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RP_) {
      setState(2286);
      match(MySQLStatementParser::RP_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableContext ------------------------------------------------------------------

MySQLStatementParser::AlterTableContext::AlterTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterTableContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::AlterTableContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::AlterTableActionsContext* MySQLStatementParser::AlterTableContext::alterTableActions() {
  return getRuleContext<MySQLStatementParser::AlterTableActionsContext>(0);
}

MySQLStatementParser::StandaloneAlterTableActionContext* MySQLStatementParser::AlterTableContext::standaloneAlterTableAction() {
  return getRuleContext<MySQLStatementParser::StandaloneAlterTableActionContext>(0);
}


size_t MySQLStatementParser::AlterTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterTable;
}

void MySQLStatementParser::AlterTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTable(this);
}

void MySQLStatementParser::AlterTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTable(this);
}


antlrcpp::Any MySQLStatementParser::AlterTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterTableContext* MySQLStatementParser::alterTable() {
  AlterTableContext *_localctx = _tracker.createInstance<AlterTableContext>(_ctx, getState());
  enterRule(_localctx, 188, MySQLStatementParser::RuleAlterTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2300);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2289);
      match(MySQLStatementParser::ALTER);
      setState(2290);
      match(MySQLStatementParser::TABLE);
      setState(2291);
      tableName();
      setState(2293);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
      case 1: {
        setState(2292);
        alterTableActions();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2295);
      match(MySQLStatementParser::ALTER);
      setState(2296);
      match(MySQLStatementParser::TABLE);
      setState(2297);
      tableName();
      setState(2298);
      standaloneAlterTableAction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandaloneAlterTableActionContext ------------------------------------------------------------------

MySQLStatementParser::StandaloneAlterTableActionContext::StandaloneAlterTableActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::StandaloneAlterCommandsContext* MySQLStatementParser::StandaloneAlterTableActionContext::standaloneAlterCommands() {
  return getRuleContext<MySQLStatementParser::StandaloneAlterCommandsContext>(0);
}

MySQLStatementParser::AlterCommandsModifierListContext* MySQLStatementParser::StandaloneAlterTableActionContext::alterCommandsModifierList() {
  return getRuleContext<MySQLStatementParser::AlterCommandsModifierListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::StandaloneAlterTableActionContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::StandaloneAlterTableActionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStandaloneAlterTableAction;
}

void MySQLStatementParser::StandaloneAlterTableActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandaloneAlterTableAction(this);
}

void MySQLStatementParser::StandaloneAlterTableActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandaloneAlterTableAction(this);
}


antlrcpp::Any MySQLStatementParser::StandaloneAlterTableActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStandaloneAlterTableAction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StandaloneAlterTableActionContext* MySQLStatementParser::standaloneAlterTableAction() {
  StandaloneAlterTableActionContext *_localctx = _tracker.createInstance<StandaloneAlterTableActionContext>(_ctx, getState());
  enterRule(_localctx, 190, MySQLStatementParser::RuleStandaloneAlterTableAction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2305);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ALGORITHM || _la == MySQLStatementParser::LOCK || _la == MySQLStatementParser::WITH

    || _la == MySQLStatementParser::WITHOUT) {
      setState(2302);
      alterCommandsModifierList();
      setState(2303);
      match(MySQLStatementParser::COMMA_);
    }
    setState(2307);
    standaloneAlterCommands();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableActionsContext ------------------------------------------------------------------

MySQLStatementParser::AlterTableActionsContext::AlterTableActionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::AlterCommandListContext* MySQLStatementParser::AlterTableActionsContext::alterCommandList() {
  return getRuleContext<MySQLStatementParser::AlterCommandListContext>(0);
}

MySQLStatementParser::AlterTablePartitionOptionsContext* MySQLStatementParser::AlterTableActionsContext::alterTablePartitionOptions() {
  return getRuleContext<MySQLStatementParser::AlterTablePartitionOptionsContext>(0);
}


size_t MySQLStatementParser::AlterTableActionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterTableActions;
}

void MySQLStatementParser::AlterTableActionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTableActions(this);
}

void MySQLStatementParser::AlterTableActionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTableActions(this);
}


antlrcpp::Any MySQLStatementParser::AlterTableActionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTableActions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterTableActionsContext* MySQLStatementParser::alterTableActions() {
  AlterTableActionsContext *_localctx = _tracker.createInstance<AlterTableActionsContext>(_ctx, getState());
  enterRule(_localctx, 192, MySQLStatementParser::RuleAlterTableActions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2314);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ADD:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALTER:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::CHANGE:
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARACTER:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::COLLATE:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONVERT:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DROP:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::FORCE:
      case MySQLStatementParser::INDEX:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LOCK:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::ORDER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::RENAME:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::UNION:
      case MySQLStatementParser::WITH:
      case MySQLStatementParser::WITHOUT: {
        enterOuterAlt(_localctx, 1);
        setState(2309);
        alterCommandList();
        setState(2311);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
        case 1: {
          setState(2310);
          alterTablePartitionOptions();
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::PARTITION:
      case MySQLStatementParser::REMOVE: {
        enterOuterAlt(_localctx, 2);
        setState(2313);
        alterTablePartitionOptions();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablePartitionOptionsContext ------------------------------------------------------------------

MySQLStatementParser::AlterTablePartitionOptionsContext::AlterTablePartitionOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::PartitionClauseContext* MySQLStatementParser::AlterTablePartitionOptionsContext::partitionClause() {
  return getRuleContext<MySQLStatementParser::PartitionClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablePartitionOptionsContext::REMOVE() {
  return getToken(MySQLStatementParser::REMOVE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablePartitionOptionsContext::PARTITIONING() {
  return getToken(MySQLStatementParser::PARTITIONING, 0);
}


size_t MySQLStatementParser::AlterTablePartitionOptionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterTablePartitionOptions;
}

void MySQLStatementParser::AlterTablePartitionOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablePartitionOptions(this);
}

void MySQLStatementParser::AlterTablePartitionOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablePartitionOptions(this);
}


antlrcpp::Any MySQLStatementParser::AlterTablePartitionOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTablePartitionOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterTablePartitionOptionsContext* MySQLStatementParser::alterTablePartitionOptions() {
  AlterTablePartitionOptionsContext *_localctx = _tracker.createInstance<AlterTablePartitionOptionsContext>(_ctx, getState());
  enterRule(_localctx, 194, MySQLStatementParser::RuleAlterTablePartitionOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2319);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::PARTITION: {
        enterOuterAlt(_localctx, 1);
        setState(2316);
        partitionClause();
        break;
      }

      case MySQLStatementParser::REMOVE: {
        enterOuterAlt(_localctx, 2);
        setState(2317);
        match(MySQLStatementParser::REMOVE);
        setState(2318);
        match(MySQLStatementParser::PARTITIONING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandListContext ------------------------------------------------------------------

MySQLStatementParser::AlterCommandListContext::AlterCommandListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::AlterCommandsModifierListContext* MySQLStatementParser::AlterCommandListContext::alterCommandsModifierList() {
  return getRuleContext<MySQLStatementParser::AlterCommandsModifierListContext>(0);
}

MySQLStatementParser::AlterListContext* MySQLStatementParser::AlterCommandListContext::alterList() {
  return getRuleContext<MySQLStatementParser::AlterListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterCommandListContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::AlterCommandListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterCommandList;
}

void MySQLStatementParser::AlterCommandListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandList(this);
}

void MySQLStatementParser::AlterCommandListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandList(this);
}


antlrcpp::Any MySQLStatementParser::AlterCommandListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterCommandList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterCommandListContext* MySQLStatementParser::alterCommandList() {
  AlterCommandListContext *_localctx = _tracker.createInstance<AlterCommandListContext>(_ctx, getState());
  enterRule(_localctx, 196, MySQLStatementParser::RuleAlterCommandList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2321);
      alterCommandsModifierList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2325);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::ALGORITHM || _la == MySQLStatementParser::LOCK || _la == MySQLStatementParser::WITH

      || _la == MySQLStatementParser::WITHOUT) {
        setState(2322);
        alterCommandsModifierList();
        setState(2323);
        match(MySQLStatementParser::COMMA_);
      }
      setState(2327);
      alterList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListContext ------------------------------------------------------------------

MySQLStatementParser::AlterListContext::AlterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::AlterListItemContext *> MySQLStatementParser::AlterListContext::alterListItem() {
  return getRuleContexts<MySQLStatementParser::AlterListItemContext>();
}

MySQLStatementParser::AlterListItemContext* MySQLStatementParser::AlterListContext::alterListItem(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterListItemContext>(i);
}

std::vector<MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext *> MySQLStatementParser::AlterListContext::createTableOptionsSpaceSeparated() {
  return getRuleContexts<MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext>();
}

MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext* MySQLStatementParser::AlterListContext::createTableOptionsSpaceSeparated(size_t i) {
  return getRuleContext<MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AlterListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

std::vector<MySQLStatementParser::AlterCommandsModifierContext *> MySQLStatementParser::AlterListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLStatementParser::AlterCommandsModifierContext>();
}

MySQLStatementParser::AlterCommandsModifierContext* MySQLStatementParser::AlterListContext::alterCommandsModifier(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterCommandsModifierContext>(i);
}


size_t MySQLStatementParser::AlterListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterList;
}

void MySQLStatementParser::AlterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterList(this);
}

void MySQLStatementParser::AlterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterList(this);
}


antlrcpp::Any MySQLStatementParser::AlterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterListContext* MySQLStatementParser::alterList() {
  AlterListContext *_localctx = _tracker.createInstance<AlterListContext>(_ctx, getState());
  enterRule(_localctx, 198, MySQLStatementParser::RuleAlterList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2332);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ADD:
      case MySQLStatementParser::ALTER:
      case MySQLStatementParser::CHANGE:
      case MySQLStatementParser::CONVERT:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DROP:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::FORCE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::ORDER:
      case MySQLStatementParser::RENAME: {
        setState(2330);
        alterListItem();
        break;
      }

      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARACTER:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::COLLATE:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::INDEX:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::UNION: {
        setState(2331);
        createTableOptionsSpaceSeparated();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2342);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(2334);
      match(MySQLStatementParser::COMMA_);
      setState(2338);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::ADD:
        case MySQLStatementParser::ALTER:
        case MySQLStatementParser::CHANGE:
        case MySQLStatementParser::CONVERT:
        case MySQLStatementParser::DISABLE:
        case MySQLStatementParser::DROP:
        case MySQLStatementParser::ENABLE:
        case MySQLStatementParser::FORCE:
        case MySQLStatementParser::MODIFY:
        case MySQLStatementParser::ORDER:
        case MySQLStatementParser::RENAME: {
          setState(2335);
          alterListItem();
          break;
        }

        case MySQLStatementParser::ALGORITHM:
        case MySQLStatementParser::LOCK:
        case MySQLStatementParser::WITH:
        case MySQLStatementParser::WITHOUT: {
          setState(2336);
          alterCommandsModifier();
          break;
        }

        case MySQLStatementParser::AUTO_INCREMENT:
        case MySQLStatementParser::AVG_ROW_LENGTH:
        case MySQLStatementParser::CHAR:
        case MySQLStatementParser::CHARACTER:
        case MySQLStatementParser::CHARSET:
        case MySQLStatementParser::CHECKSUM:
        case MySQLStatementParser::COLLATE:
        case MySQLStatementParser::COMMENT:
        case MySQLStatementParser::COMPRESSION:
        case MySQLStatementParser::CONNECTION:
        case MySQLStatementParser::DATA:
        case MySQLStatementParser::DEFAULT:
        case MySQLStatementParser::DELAY_KEY_WRITE:
        case MySQLStatementParser::ENCRYPTION:
        case MySQLStatementParser::ENGINE:
        case MySQLStatementParser::ENGINE_ATTRIBUTE:
        case MySQLStatementParser::INDEX:
        case MySQLStatementParser::INSERT_METHOD:
        case MySQLStatementParser::KEY_BLOCK_SIZE:
        case MySQLStatementParser::MAX_ROWS:
        case MySQLStatementParser::MIN_ROWS:
        case MySQLStatementParser::PACK_KEYS:
        case MySQLStatementParser::PASSWORD:
        case MySQLStatementParser::ROW_FORMAT:
        case MySQLStatementParser::SECONDARY_ENGINE:
        case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
        case MySQLStatementParser::STATS_AUTO_RECALC:
        case MySQLStatementParser::STATS_PERSISTENT:
        case MySQLStatementParser::STATS_SAMPLE_PAGES:
        case MySQLStatementParser::STORAGE:
        case MySQLStatementParser::TABLESPACE:
        case MySQLStatementParser::TABLE_CHECKSUM:
        case MySQLStatementParser::UNION: {
          setState(2337);
          createTableOptionsSpaceSeparated();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2344);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsSpaceSeparatedContext ------------------------------------------------------------------

MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext::CreateTableOptionsSpaceSeparatedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::CreateTableOptionContext *> MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext::createTableOption() {
  return getRuleContexts<MySQLStatementParser::CreateTableOptionContext>();
}

MySQLStatementParser::CreateTableOptionContext* MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext::createTableOption(size_t i) {
  return getRuleContext<MySQLStatementParser::CreateTableOptionContext>(i);
}


size_t MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateTableOptionsSpaceSeparated;
}

void MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptionsSpaceSeparated(this);
}

void MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptionsSpaceSeparated(this);
}


antlrcpp::Any MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateTableOptionsSpaceSeparated(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateTableOptionsSpaceSeparatedContext* MySQLStatementParser::createTableOptionsSpaceSeparated() {
  CreateTableOptionsSpaceSeparatedContext *_localctx = _tracker.createInstance<CreateTableOptionsSpaceSeparatedContext>(_ctx, getState());
  enterRule(_localctx, 200, MySQLStatementParser::RuleCreateTableOptionsSpaceSeparated);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2346); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2345);
              createTableOption();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2348); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListItemContext ------------------------------------------------------------------

MySQLStatementParser::AlterListItemContext::AlterListItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLStatementParser::AlterListItemContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterListItem;
}

void MySQLStatementParser::AlterListItemContext::copyFrom(AlterListItemContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AddColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AddColumnContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

MySQLStatementParser::ColumnDefinitionContext* MySQLStatementParser::AddColumnContext::columnDefinition() {
  return getRuleContext<MySQLStatementParser::ColumnDefinitionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AddColumnContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::TableElementListContext* MySQLStatementParser::AddColumnContext::tableElementList() {
  return getRuleContext<MySQLStatementParser::TableElementListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AddColumnContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::AddColumnContext::COLUMN() {
  return getToken(MySQLStatementParser::COLUMN, 0);
}

MySQLStatementParser::PlaceContext* MySQLStatementParser::AddColumnContext::place() {
  return getRuleContext<MySQLStatementParser::PlaceContext>(0);
}

MySQLStatementParser::AddColumnContext::AddColumnContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AddColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddColumn(this);
}
void MySQLStatementParser::AddColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddColumn(this);
}

antlrcpp::Any MySQLStatementParser::AddColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAddColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- EnableKeysContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::EnableKeysContext::ENABLE() {
  return getToken(MySQLStatementParser::ENABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::EnableKeysContext::KEYS() {
  return getToken(MySQLStatementParser::KEYS, 0);
}

MySQLStatementParser::EnableKeysContext::EnableKeysContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::EnableKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnableKeys(this);
}
void MySQLStatementParser::EnableKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnableKeys(this);
}

antlrcpp::Any MySQLStatementParser::EnableKeysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitEnableKeys(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterTableDropContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterTableDropContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableDropContext::FOREIGN() {
  return getToken(MySQLStatementParser::FOREIGN, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableDropContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableDropContext::PRIMARY() {
  return getToken(MySQLStatementParser::PRIMARY, 0);
}

MySQLStatementParser::KeyOrIndexContext* MySQLStatementParser::AlterTableDropContext::keyOrIndex() {
  return getRuleContext<MySQLStatementParser::KeyOrIndexContext>(0);
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::AlterTableDropContext::indexName() {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableDropContext::CHECK() {
  return getToken(MySQLStatementParser::CHECK, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterTableDropContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableDropContext::CONSTRAINT() {
  return getToken(MySQLStatementParser::CONSTRAINT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableDropContext::COLUMN() {
  return getToken(MySQLStatementParser::COLUMN, 0);
}

MySQLStatementParser::RestrictContext* MySQLStatementParser::AlterTableDropContext::restrict() {
  return getRuleContext<MySQLStatementParser::RestrictContext>(0);
}

MySQLStatementParser::AlterTableDropContext::AlterTableDropContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterTableDropContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTableDrop(this);
}
void MySQLStatementParser::AlterTableDropContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTableDrop(this);
}

antlrcpp::Any MySQLStatementParser::AlterTableDropContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTableDrop(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterConstraintContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterConstraintContext::CONSTRAINT() {
  return getToken(MySQLStatementParser::CONSTRAINT, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterConstraintContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::ConstraintEnforcementContext* MySQLStatementParser::AlterConstraintContext::constraintEnforcement() {
  return getRuleContext<MySQLStatementParser::ConstraintEnforcementContext>(0);
}

MySQLStatementParser::AlterConstraintContext::AlterConstraintContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterConstraint(this);
}
void MySQLStatementParser::AlterConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterConstraint(this);
}

antlrcpp::Any MySQLStatementParser::AlterConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterColumnContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterColumnContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterColumnContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterColumnContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterColumnContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterColumnContext::COLUMN() {
  return getToken(MySQLStatementParser::COLUMN, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterColumnContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::AlterColumnContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterColumnContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::SignedLiteralContext* MySQLStatementParser::AlterColumnContext::signedLiteral() {
  return getRuleContext<MySQLStatementParser::SignedLiteralContext>(0);
}

MySQLStatementParser::AlterColumnContext::AlterColumnContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterColumn(this);
}
void MySQLStatementParser::AlterColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterColumn(this);
}

antlrcpp::Any MySQLStatementParser::AlterColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterCheckContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterCheckContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterCheckContext::CHECK() {
  return getToken(MySQLStatementParser::CHECK, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterCheckContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::ConstraintEnforcementContext* MySQLStatementParser::AlterCheckContext::constraintEnforcement() {
  return getRuleContext<MySQLStatementParser::ConstraintEnforcementContext>(0);
}

MySQLStatementParser::AlterCheckContext::AlterCheckContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterCheckContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCheck(this);
}
void MySQLStatementParser::AlterCheckContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCheck(this);
}

antlrcpp::Any MySQLStatementParser::AlterCheckContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterCheck(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ModifyColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::ModifyColumnContext::MODIFY() {
  return getToken(MySQLStatementParser::MODIFY, 0);
}

MySQLStatementParser::FieldDefinitionContext* MySQLStatementParser::ModifyColumnContext::fieldDefinition() {
  return getRuleContext<MySQLStatementParser::FieldDefinitionContext>(0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ModifyColumnContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ModifyColumnContext::COLUMN() {
  return getToken(MySQLStatementParser::COLUMN, 0);
}

MySQLStatementParser::PlaceContext* MySQLStatementParser::ModifyColumnContext::place() {
  return getRuleContext<MySQLStatementParser::PlaceContext>(0);
}

MySQLStatementParser::ModifyColumnContext::ModifyColumnContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::ModifyColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifyColumn(this);
}
void MySQLStatementParser::ModifyColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifyColumn(this);
}

antlrcpp::Any MySQLStatementParser::ModifyColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitModifyColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterIndexContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterIndexContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterIndexContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::AlterIndexContext::indexName() {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(0);
}

MySQLStatementParser::VisibilityContext* MySQLStatementParser::AlterIndexContext::visibility() {
  return getRuleContext<MySQLStatementParser::VisibilityContext>(0);
}

MySQLStatementParser::AlterIndexContext::AlterIndexContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterIndex(this);
}
void MySQLStatementParser::AlterIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterIndex(this);
}

antlrcpp::Any MySQLStatementParser::AlterIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterIndex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ChangeColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::ChangeColumnContext::CHANGE() {
  return getToken(MySQLStatementParser::CHANGE, 0);
}

MySQLStatementParser::ColumnDefinitionContext* MySQLStatementParser::ChangeColumnContext::columnDefinition() {
  return getRuleContext<MySQLStatementParser::ColumnDefinitionContext>(0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ChangeColumnContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ChangeColumnContext::COLUMN() {
  return getToken(MySQLStatementParser::COLUMN, 0);
}

MySQLStatementParser::PlaceContext* MySQLStatementParser::ChangeColumnContext::place() {
  return getRuleContext<MySQLStatementParser::PlaceContext>(0);
}

MySQLStatementParser::ChangeColumnContext::ChangeColumnContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::ChangeColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeColumn(this);
}
void MySQLStatementParser::ChangeColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeColumn(this);
}

antlrcpp::Any MySQLStatementParser::ChangeColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChangeColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterTableOrderContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterTableOrderContext::ORDER() {
  return getToken(MySQLStatementParser::ORDER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTableOrderContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

MySQLStatementParser::AlterOrderListContext* MySQLStatementParser::AlterTableOrderContext::alterOrderList() {
  return getRuleContext<MySQLStatementParser::AlterOrderListContext>(0);
}

MySQLStatementParser::AlterTableOrderContext::AlterTableOrderContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterTableOrderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTableOrder(this);
}
void MySQLStatementParser::AlterTableOrderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTableOrder(this);
}

antlrcpp::Any MySQLStatementParser::AlterTableOrderContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTableOrder(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterConvertContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterConvertContext::CONVERT() {
  return getToken(MySQLStatementParser::CONVERT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterConvertContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

MySQLStatementParser::CharsetContext* MySQLStatementParser::AlterConvertContext::charset() {
  return getRuleContext<MySQLStatementParser::CharsetContext>(0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::AlterConvertContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}

MySQLStatementParser::CollateClauseContext* MySQLStatementParser::AlterConvertContext::collateClause() {
  return getRuleContext<MySQLStatementParser::CollateClauseContext>(0);
}

MySQLStatementParser::AlterConvertContext::AlterConvertContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterConvertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterConvert(this);
}
void MySQLStatementParser::AlterConvertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterConvert(this);
}

antlrcpp::Any MySQLStatementParser::AlterConvertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterConvert(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RenameIndexContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::RenameIndexContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

MySQLStatementParser::KeyOrIndexContext* MySQLStatementParser::RenameIndexContext::keyOrIndex() {
  return getRuleContext<MySQLStatementParser::KeyOrIndexContext>(0);
}

std::vector<MySQLStatementParser::IndexNameContext *> MySQLStatementParser::RenameIndexContext::indexName() {
  return getRuleContexts<MySQLStatementParser::IndexNameContext>();
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::RenameIndexContext::indexName(size_t i) {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::RenameIndexContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

MySQLStatementParser::RenameIndexContext::RenameIndexContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::RenameIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameIndex(this);
}
void MySQLStatementParser::RenameIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameIndex(this);
}

antlrcpp::Any MySQLStatementParser::RenameIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRenameIndex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterTableForceContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterTableForceContext::FORCE() {
  return getToken(MySQLStatementParser::FORCE, 0);
}

MySQLStatementParser::AlterTableForceContext::AlterTableForceContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterTableForceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTableForce(this);
}
void MySQLStatementParser::AlterTableForceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTableForce(this);
}

antlrcpp::Any MySQLStatementParser::AlterTableForceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTableForce(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AddTableConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AddTableConstraintContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

MySQLStatementParser::TableConstraintDefContext* MySQLStatementParser::AddTableConstraintContext::tableConstraintDef() {
  return getRuleContext<MySQLStatementParser::TableConstraintDefContext>(0);
}

MySQLStatementParser::AddTableConstraintContext::AddTableConstraintContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AddTableConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddTableConstraint(this);
}
void MySQLStatementParser::AddTableConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddTableConstraint(this);
}

antlrcpp::Any MySQLStatementParser::AddTableConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAddTableConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RenameColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::RenameColumnContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

tree::TerminalNode* MySQLStatementParser::RenameColumnContext::COLUMN() {
  return getToken(MySQLStatementParser::COLUMN, 0);
}

tree::TerminalNode* MySQLStatementParser::RenameColumnContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::RenameColumnContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::RenameColumnContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

MySQLStatementParser::RenameColumnContext::RenameColumnContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::RenameColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameColumn(this);
}
void MySQLStatementParser::RenameColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameColumn(this);
}

antlrcpp::Any MySQLStatementParser::RenameColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRenameColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DisableKeysContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::DisableKeysContext::DISABLE() {
  return getToken(MySQLStatementParser::DISABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::DisableKeysContext::KEYS() {
  return getToken(MySQLStatementParser::KEYS, 0);
}

MySQLStatementParser::DisableKeysContext::DisableKeysContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::DisableKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDisableKeys(this);
}
void MySQLStatementParser::DisableKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDisableKeys(this);
}

antlrcpp::Any MySQLStatementParser::DisableKeysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDisableKeys(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterRenameTableContext ------------------------------------------------------------------

tree::TerminalNode* MySQLStatementParser::AlterRenameTableContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::AlterRenameTableContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterRenameTableContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterRenameTableContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::AlterRenameTableContext::AlterRenameTableContext(AlterListItemContext *ctx) { copyFrom(ctx); }

void MySQLStatementParser::AlterRenameTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterRenameTable(this);
}
void MySQLStatementParser::AlterRenameTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterRenameTable(this);
}

antlrcpp::Any MySQLStatementParser::AlterRenameTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterRenameTable(this);
  else
    return visitor->visitChildren(this);
}
MySQLStatementParser::AlterListItemContext* MySQLStatementParser::alterListItem() {
  AlterListItemContext *_localctx = _tracker.createInstance<AlterListItemContext>(_ctx, getState());
  enterRule(_localctx, 202, MySQLStatementParser::RuleAlterListItem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2471);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AddColumnContext>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(2350);
      match(MySQLStatementParser::ADD);
      setState(2352);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::COLUMN) {
        setState(2351);
        match(MySQLStatementParser::COLUMN);
      }
      setState(2362);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::MAX:
        case MySQLStatementParser::MIN:
        case MySQLStatementParser::SUM:
        case MySQLStatementParser::COUNT:
        case MySQLStatementParser::GROUP_CONCAT:
        case MySQLStatementParser::CAST:
        case MySQLStatementParser::POSITION:
        case MySQLStatementParser::SUBSTRING:
        case MySQLStatementParser::SUBSTR:
        case MySQLStatementParser::EXTRACT:
        case MySQLStatementParser::TRIM:
        case MySQLStatementParser::LAST_DAY:
        case MySQLStatementParser::TRADITIONAL:
        case MySQLStatementParser::TREE:
        case MySQLStatementParser::MYSQL_ADMIN:
        case MySQLStatementParser::INSTANT:
        case MySQLStatementParser::INPLACE:
        case MySQLStatementParser::COPY:
        case MySQLStatementParser::UL_BINARY:
        case MySQLStatementParser::AUTOCOMMIT:
        case MySQLStatementParser::INNODB:
        case MySQLStatementParser::REDO_LOG:
        case MySQLStatementParser::ACCOUNT:
        case MySQLStatementParser::ACTION:
        case MySQLStatementParser::ACTIVE:
        case MySQLStatementParser::ADMIN:
        case MySQLStatementParser::AFTER:
        case MySQLStatementParser::AGAINST:
        case MySQLStatementParser::AGGREGATE:
        case MySQLStatementParser::ALGORITHM:
        case MySQLStatementParser::ALWAYS:
        case MySQLStatementParser::ANY:
        case MySQLStatementParser::ASCII:
        case MySQLStatementParser::AT:
        case MySQLStatementParser::ATTRIBUTE:
        case MySQLStatementParser::AUTOEXTEND_SIZE:
        case MySQLStatementParser::AUTO_INCREMENT:
        case MySQLStatementParser::AVG:
        case MySQLStatementParser::AVG_ROW_LENGTH:
        case MySQLStatementParser::BACKUP:
        case MySQLStatementParser::BEGIN:
        case MySQLStatementParser::BINLOG:
        case MySQLStatementParser::BIT:
        case MySQLStatementParser::BLOCK:
        case MySQLStatementParser::BOOL:
        case MySQLStatementParser::BOOLEAN:
        case MySQLStatementParser::BTREE:
        case MySQLStatementParser::BUCKETS:
        case MySQLStatementParser::BYTE:
        case MySQLStatementParser::CACHE:
        case MySQLStatementParser::CASCADED:
        case MySQLStatementParser::CATALOG_NAME:
        case MySQLStatementParser::CHAIN:
        case MySQLStatementParser::CHANGED:
        case MySQLStatementParser::CHANNEL:
        case MySQLStatementParser::CHARSET:
        case MySQLStatementParser::CHECKSUM:
        case MySQLStatementParser::CIPHER:
        case MySQLStatementParser::CLASS_ORIGIN:
        case MySQLStatementParser::CLIENT:
        case MySQLStatementParser::CLONE:
        case MySQLStatementParser::CLOSE:
        case MySQLStatementParser::COALESCE:
        case MySQLStatementParser::CODE:
        case MySQLStatementParser::COLLATION:
        case MySQLStatementParser::COLUMNS:
        case MySQLStatementParser::COLUMN_FORMAT:
        case MySQLStatementParser::COLUMN_NAME:
        case MySQLStatementParser::COMMENT:
        case MySQLStatementParser::COMMIT:
        case MySQLStatementParser::COMMITTED:
        case MySQLStatementParser::COMPACT:
        case MySQLStatementParser::COMPLETION:
        case MySQLStatementParser::COMPONENT:
        case MySQLStatementParser::COMPRESSED:
        case MySQLStatementParser::COMPRESSION:
        case MySQLStatementParser::CONCURRENT:
        case MySQLStatementParser::CONNECTION:
        case MySQLStatementParser::CONSISTENT:
        case MySQLStatementParser::CONSTRAINT_CATALOG:
        case MySQLStatementParser::CONSTRAINT_NAME:
        case MySQLStatementParser::CONSTRAINT_SCHEMA:
        case MySQLStatementParser::CONTAINS:
        case MySQLStatementParser::CONTEXT:
        case MySQLStatementParser::CPU:
        case MySQLStatementParser::CURRENT:
        case MySQLStatementParser::CURSOR_NAME:
        case MySQLStatementParser::DATA:
        case MySQLStatementParser::DATAFILE:
        case MySQLStatementParser::DATE:
        case MySQLStatementParser::DATETIME:
        case MySQLStatementParser::DAY:
        case MySQLStatementParser::DEALLOCATE:
        case MySQLStatementParser::DEFAULT_AUTH:
        case MySQLStatementParser::DEFINER:
        case MySQLStatementParser::DEFINITION:
        case MySQLStatementParser::DELAY_KEY_WRITE:
        case MySQLStatementParser::DESCRIPTION:
        case MySQLStatementParser::DIAGNOSTICS:
        case MySQLStatementParser::DIRECTORY:
        case MySQLStatementParser::DISABLE:
        case MySQLStatementParser::DISCARD:
        case MySQLStatementParser::DISK:
        case MySQLStatementParser::DO:
        case MySQLStatementParser::DUMPFILE:
        case MySQLStatementParser::DUPLICATE:
        case MySQLStatementParser::DYNAMIC:
        case MySQLStatementParser::ENABLE:
        case MySQLStatementParser::ENCRYPTION:
        case MySQLStatementParser::END:
        case MySQLStatementParser::ENDS:
        case MySQLStatementParser::ENFORCED:
        case MySQLStatementParser::ENGINE:
        case MySQLStatementParser::ENGINES:
        case MySQLStatementParser::ENGINE_ATTRIBUTE:
        case MySQLStatementParser::ENUM:
        case MySQLStatementParser::ERROR:
        case MySQLStatementParser::ERRORS:
        case MySQLStatementParser::ESCAPE:
        case MySQLStatementParser::EVENT:
        case MySQLStatementParser::EVENTS:
        case MySQLStatementParser::EVERY:
        case MySQLStatementParser::EXCHANGE:
        case MySQLStatementParser::EXCLUDE:
        case MySQLStatementParser::EXECUTE:
        case MySQLStatementParser::EXPANSION:
        case MySQLStatementParser::EXPIRE:
        case MySQLStatementParser::EXPORT:
        case MySQLStatementParser::EXTENDED:
        case MySQLStatementParser::EXTENT_SIZE:
        case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
        case MySQLStatementParser::FAST:
        case MySQLStatementParser::FAULTS:
        case MySQLStatementParser::FIELDS:
        case MySQLStatementParser::FILE:
        case MySQLStatementParser::FILE_BLOCK_SIZE:
        case MySQLStatementParser::FILTER:
        case MySQLStatementParser::FIRST:
        case MySQLStatementParser::FIXED:
        case MySQLStatementParser::FLUSH:
        case MySQLStatementParser::FOLLOWING:
        case MySQLStatementParser::FOLLOWS:
        case MySQLStatementParser::FORMAT:
        case MySQLStatementParser::FULL:
        case MySQLStatementParser::GENERAL:
        case MySQLStatementParser::GEOMCOLLECTION:
        case MySQLStatementParser::GEOMETRY:
        case MySQLStatementParser::GEOMETRYCOLLECTION:
        case MySQLStatementParser::GET_FORMAT:
        case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
        case MySQLStatementParser::GLOBAL:
        case MySQLStatementParser::GRANTS:
        case MySQLStatementParser::GROUP_REPLICATION:
        case MySQLStatementParser::HANDLER:
        case MySQLStatementParser::HASH:
        case MySQLStatementParser::HELP:
        case MySQLStatementParser::HISTOGRAM:
        case MySQLStatementParser::HISTORY:
        case MySQLStatementParser::HOST:
        case MySQLStatementParser::HOSTS:
        case MySQLStatementParser::HOUR:
        case MySQLStatementParser::IDENTIFIED:
        case MySQLStatementParser::IGNORE_SERVER_IDS:
        case MySQLStatementParser::IMPORT:
        case MySQLStatementParser::INACTIVE:
        case MySQLStatementParser::INDEXES:
        case MySQLStatementParser::INITIAL_SIZE:
        case MySQLStatementParser::INSERT_METHOD:
        case MySQLStatementParser::INSTALL:
        case MySQLStatementParser::INSTANCE:
        case MySQLStatementParser::INVISIBLE:
        case MySQLStatementParser::INVOKER:
        case MySQLStatementParser::IO:
        case MySQLStatementParser::IO_THREAD:
        case MySQLStatementParser::IPC:
        case MySQLStatementParser::ISOLATION:
        case MySQLStatementParser::ISSUER:
        case MySQLStatementParser::JSON:
        case MySQLStatementParser::JSON_VALUE:
        case MySQLStatementParser::KEY_BLOCK_SIZE:
        case MySQLStatementParser::LANGUAGE:
        case MySQLStatementParser::LAST:
        case MySQLStatementParser::LEAVES:
        case MySQLStatementParser::LESS:
        case MySQLStatementParser::LEVEL:
        case MySQLStatementParser::LINESTRING:
        case MySQLStatementParser::LIST:
        case MySQLStatementParser::LOCAL:
        case MySQLStatementParser::LOCKED:
        case MySQLStatementParser::LOCKS:
        case MySQLStatementParser::LOGFILE:
        case MySQLStatementParser::LOGS:
        case MySQLStatementParser::MANAGED:
        case MySQLStatementParser::MASTER:
        case MySQLStatementParser::MASTER_AUTO_POSITION:
        case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
        case MySQLStatementParser::MASTER_CONNECT_RETRY:
        case MySQLStatementParser::MASTER_DELAY:
        case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
        case MySQLStatementParser::MASTER_HOST:
        case MySQLStatementParser::MASTER_LOG_FILE:
        case MySQLStatementParser::MASTER_LOG_POS:
        case MySQLStatementParser::MASTER_PASSWORD:
        case MySQLStatementParser::MASTER_PORT:
        case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
        case MySQLStatementParser::MASTER_RETRY_COUNT:
        case MySQLStatementParser::MASTER_SERVER_ID:
        case MySQLStatementParser::MASTER_SSL:
        case MySQLStatementParser::MASTER_SSL_CA:
        case MySQLStatementParser::MASTER_SSL_CAPATH:
        case MySQLStatementParser::MASTER_SSL_CERT:
        case MySQLStatementParser::MASTER_SSL_CIPHER:
        case MySQLStatementParser::MASTER_SSL_CRL:
        case MySQLStatementParser::MASTER_SSL_CRLPATH:
        case MySQLStatementParser::MASTER_SSL_KEY:
        case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
        case MySQLStatementParser::MASTER_TLS_VERSION:
        case MySQLStatementParser::MASTER_USER:
        case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
        case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
        case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
        case MySQLStatementParser::MAX_ROWS:
        case MySQLStatementParser::MAX_SIZE:
        case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
        case MySQLStatementParser::MAX_USER_CONNECTIONS:
        case MySQLStatementParser::MEDIUM:
        case MySQLStatementParser::MEMBER:
        case MySQLStatementParser::MEMORY:
        case MySQLStatementParser::MERGE:
        case MySQLStatementParser::MESSAGE_TEXT:
        case MySQLStatementParser::MICROSECOND:
        case MySQLStatementParser::MIGRATE:
        case MySQLStatementParser::MINUTE:
        case MySQLStatementParser::MIN_ROWS:
        case MySQLStatementParser::MODE:
        case MySQLStatementParser::MODIFY:
        case MySQLStatementParser::MONTH:
        case MySQLStatementParser::MULTILINESTRING:
        case MySQLStatementParser::MULTIPOINT:
        case MySQLStatementParser::MULTIPOLYGON:
        case MySQLStatementParser::MUTEX:
        case MySQLStatementParser::MYSQL_ERRNO:
        case MySQLStatementParser::NAME:
        case MySQLStatementParser::NAMES:
        case MySQLStatementParser::NATIONAL:
        case MySQLStatementParser::NCHAR:
        case MySQLStatementParser::NDB:
        case MySQLStatementParser::NDBCLUSTER:
        case MySQLStatementParser::NESTED:
        case MySQLStatementParser::NETWORK_NAMESPACE:
        case MySQLStatementParser::NEVER:
        case MySQLStatementParser::NEW:
        case MySQLStatementParser::NEXT:
        case MySQLStatementParser::NO:
        case MySQLStatementParser::NODEGROUP:
        case MySQLStatementParser::NONE:
        case MySQLStatementParser::NOWAIT:
        case MySQLStatementParser::NO_WAIT:
        case MySQLStatementParser::NULLS:
        case MySQLStatementParser::NUMBER:
        case MySQLStatementParser::NVARCHAR:
        case MySQLStatementParser::OFF:
        case MySQLStatementParser::OFFSET:
        case MySQLStatementParser::OJ:
        case MySQLStatementParser::OLD:
        case MySQLStatementParser::ONE:
        case MySQLStatementParser::ONLY:
        case MySQLStatementParser::OPEN:
        case MySQLStatementParser::OPTIONAL:
        case MySQLStatementParser::OPTIONS:
        case MySQLStatementParser::ORDINALITY:
        case MySQLStatementParser::OTHERS:
        case MySQLStatementParser::OWNER:
        case MySQLStatementParser::PACK_KEYS:
        case MySQLStatementParser::PAGE:
        case MySQLStatementParser::PARSER:
        case MySQLStatementParser::PARTIAL:
        case MySQLStatementParser::PARTITIONING:
        case MySQLStatementParser::PASSWORD:
        case MySQLStatementParser::PASSWORD_LOCK_TIME:
        case MySQLStatementParser::PATH:
        case MySQLStatementParser::PERSIST:
        case MySQLStatementParser::PERSIST_ONLY:
        case MySQLStatementParser::PHASE:
        case MySQLStatementParser::PLUGIN:
        case MySQLStatementParser::PLUGINS:
        case MySQLStatementParser::PLUGIN_DIR:
        case MySQLStatementParser::POINT:
        case MySQLStatementParser::POLYGON:
        case MySQLStatementParser::PORT:
        case MySQLStatementParser::PRECEDES:
        case MySQLStatementParser::PRECEDING:
        case MySQLStatementParser::PREPARE:
        case MySQLStatementParser::PRESERVE:
        case MySQLStatementParser::PREV:
        case MySQLStatementParser::PRIVILEGES:
        case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
        case MySQLStatementParser::PROCESS:
        case MySQLStatementParser::PROCESSLIST:
        case MySQLStatementParser::PROFILE:
        case MySQLStatementParser::PROFILES:
        case MySQLStatementParser::PROXY:
        case MySQLStatementParser::QUARTER:
        case MySQLStatementParser::QUERY:
        case MySQLStatementParser::QUICK:
        case MySQLStatementParser::RANDOM:
        case MySQLStatementParser::READ_ONLY:
        case MySQLStatementParser::REBUILD:
        case MySQLStatementParser::RECOVER:
        case MySQLStatementParser::REDO_BUFFER_SIZE:
        case MySQLStatementParser::REDUNDANT:
        case MySQLStatementParser::REFERENCE:
        case MySQLStatementParser::RELAY:
        case MySQLStatementParser::RELAYLOG:
        case MySQLStatementParser::RELAY_LOG_FILE:
        case MySQLStatementParser::RELAY_LOG_POS:
        case MySQLStatementParser::RELAY_THREAD:
        case MySQLStatementParser::RELOAD:
        case MySQLStatementParser::REMOVE:
        case MySQLStatementParser::REORGANIZE:
        case MySQLStatementParser::REPAIR:
        case MySQLStatementParser::REPEATABLE:
        case MySQLStatementParser::REPLICATE_DO_DB:
        case MySQLStatementParser::REPLICATE_DO_TABLE:
        case MySQLStatementParser::REPLICATE_IGNORE_DB:
        case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
        case MySQLStatementParser::REPLICATE_REWRITE_DB:
        case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
        case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
        case MySQLStatementParser::REPLICATION:
        case MySQLStatementParser::REQUIRE_ROW_FORMAT:
        case MySQLStatementParser::RESET:
        case MySQLStatementParser::RESOURCE:
        case MySQLStatementParser::RESPECT:
        case MySQLStatementParser::RESTART:
        case MySQLStatementParser::RESTORE:
        case MySQLStatementParser::RESUME:
        case MySQLStatementParser::RETAIN:
        case MySQLStatementParser::RETURNED_SQLSTATE:
        case MySQLStatementParser::RETURNING:
        case MySQLStatementParser::RETURNS:
        case MySQLStatementParser::REUSE:
        case MySQLStatementParser::REVERSE:
        case MySQLStatementParser::ROLE:
        case MySQLStatementParser::ROLLBACK:
        case MySQLStatementParser::ROLLUP:
        case MySQLStatementParser::ROTATE:
        case MySQLStatementParser::ROUTINE:
        case MySQLStatementParser::ROW_COUNT:
        case MySQLStatementParser::ROW_FORMAT:
        case MySQLStatementParser::RTREE:
        case MySQLStatementParser::SAVEPOINT:
        case MySQLStatementParser::SCHEDULE:
        case MySQLStatementParser::SCHEMA_NAME:
        case MySQLStatementParser::SECOND:
        case MySQLStatementParser::SECONDARY:
        case MySQLStatementParser::SECONDARY_ENGINE:
        case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
        case MySQLStatementParser::SECONDARY_LOAD:
        case MySQLStatementParser::SECONDARY_UNLOAD:
        case MySQLStatementParser::SECURITY:
        case MySQLStatementParser::SERIAL:
        case MySQLStatementParser::SERIALIZABLE:
        case MySQLStatementParser::SERVER:
        case MySQLStatementParser::SESSION:
        case MySQLStatementParser::SHARE:
        case MySQLStatementParser::SHUTDOWN:
        case MySQLStatementParser::SIGNED:
        case MySQLStatementParser::SIMPLE:
        case MySQLStatementParser::SLAVE:
        case MySQLStatementParser::SLOW:
        case MySQLStatementParser::SNAPSHOT:
        case MySQLStatementParser::SOCKET:
        case MySQLStatementParser::SOME:
        case MySQLStatementParser::SONAME:
        case MySQLStatementParser::SOUNDS:
        case MySQLStatementParser::SOURCE:
        case MySQLStatementParser::SQL_CACHE:
        case MySQLStatementParser::SQL_AFTER_GTIDS:
        case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
        case MySQLStatementParser::SQL_BEFORE_GTIDS:
        case MySQLStatementParser::SQL_BUFFER_RESULT:
        case MySQLStatementParser::SQL_NO_CACHE:
        case MySQLStatementParser::SQL_THREAD:
        case MySQLStatementParser::SQL_TSI_DAY:
        case MySQLStatementParser::SQL_TSI_HOUR:
        case MySQLStatementParser::SQL_TSI_MINUTE:
        case MySQLStatementParser::SQL_TSI_MONTH:
        case MySQLStatementParser::SQL_TSI_QUARTER:
        case MySQLStatementParser::SQL_TSI_SECOND:
        case MySQLStatementParser::SQL_TSI_WEEK:
        case MySQLStatementParser::SQL_TSI_YEAR:
        case MySQLStatementParser::SRID:
        case MySQLStatementParser::STACKED:
        case MySQLStatementParser::START:
        case MySQLStatementParser::STARTS:
        case MySQLStatementParser::STATS_AUTO_RECALC:
        case MySQLStatementParser::STATS_PERSISTENT:
        case MySQLStatementParser::STATS_SAMPLE_PAGES:
        case MySQLStatementParser::STATUS:
        case MySQLStatementParser::STOP:
        case MySQLStatementParser::STORAGE:
        case MySQLStatementParser::STREAM:
        case MySQLStatementParser::STRING:
        case MySQLStatementParser::SUBCLASS_ORIGIN:
        case MySQLStatementParser::SUBJECT:
        case MySQLStatementParser::SUBPARTITION:
        case MySQLStatementParser::SUBPARTITIONS:
        case MySQLStatementParser::SUPER:
        case MySQLStatementParser::SUSPEND:
        case MySQLStatementParser::SWAPS:
        case MySQLStatementParser::SWITCHES:
        case MySQLStatementParser::TABLES:
        case MySQLStatementParser::TABLESPACE:
        case MySQLStatementParser::TABLE_CHECKSUM:
        case MySQLStatementParser::TABLE_NAME:
        case MySQLStatementParser::TEMPORARY:
        case MySQLStatementParser::TEMPTABLE:
        case MySQLStatementParser::TEXT:
        case MySQLStatementParser::THAN:
        case MySQLStatementParser::THREAD_PRIORITY:
        case MySQLStatementParser::TIES:
        case MySQLStatementParser::TIME:
        case MySQLStatementParser::TIMESTAMP:
        case MySQLStatementParser::TIMESTAMPADD:
        case MySQLStatementParser::TIMESTAMPDIFF:
        case MySQLStatementParser::TLS:
        case MySQLStatementParser::TRANSACTION:
        case MySQLStatementParser::TRIGGERS:
        case MySQLStatementParser::TRUNCATE:
        case MySQLStatementParser::TYPE:
        case MySQLStatementParser::TYPES:
        case MySQLStatementParser::UNBOUNDED:
        case MySQLStatementParser::UNCOMMITTED:
        case MySQLStatementParser::UNDEFINED:
        case MySQLStatementParser::UNDOFILE:
        case MySQLStatementParser::UNDO_BUFFER_SIZE:
        case MySQLStatementParser::UNICODE:
        case MySQLStatementParser::UNINSTALL:
        case MySQLStatementParser::UNKNOWN:
        case MySQLStatementParser::UNTIL:
        case MySQLStatementParser::UPGRADE:
        case MySQLStatementParser::USER:
        case MySQLStatementParser::USER_RESOURCES:
        case MySQLStatementParser::USE_FRM:
        case MySQLStatementParser::VALIDATION:
        case MySQLStatementParser::VALUE:
        case MySQLStatementParser::VARIABLES:
        case MySQLStatementParser::VCPU:
        case MySQLStatementParser::VIEW:
        case MySQLStatementParser::VISIBLE:
        case MySQLStatementParser::WAIT:
        case MySQLStatementParser::WARNINGS:
        case MySQLStatementParser::WEEK:
        case MySQLStatementParser::WEIGHT_STRING:
        case MySQLStatementParser::WITHOUT:
        case MySQLStatementParser::WORK:
        case MySQLStatementParser::WRAPPER:
        case MySQLStatementParser::X509:
        case MySQLStatementParser::XA:
        case MySQLStatementParser::XID:
        case MySQLStatementParser::XML:
        case MySQLStatementParser::YEAR:
        case MySQLStatementParser::IDENTIFIER_:
        case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
          setState(2354);
          columnDefinition();
          setState(2356);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx)) {
          case 1: {
            setState(2355);
            place();
            break;
          }

          }
          break;
        }

        case MySQLStatementParser::LP_: {
          setState(2358);
          match(MySQLStatementParser::LP_);
          setState(2359);
          tableElementList();
          setState(2360);
          match(MySQLStatementParser::RP_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AddTableConstraintContext>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(2364);
      match(MySQLStatementParser::ADD);
      setState(2365);
      tableConstraintDef();
      break;
    }

    case 3: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::ChangeColumnContext>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(2366);
      match(MySQLStatementParser::CHANGE);
      setState(2368);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::COLUMN) {
        setState(2367);
        match(MySQLStatementParser::COLUMN);
      }
      setState(2370);
      dynamic_cast<ChangeColumnContext *>(_localctx)->columnInternalRef = identifier();
      setState(2371);
      columnDefinition();
      setState(2373);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx)) {
      case 1: {
        setState(2372);
        place();
        break;
      }

      }
      break;
    }

    case 4: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::ModifyColumnContext>(_localctx));
      enterOuterAlt(_localctx, 4);
      setState(2375);
      match(MySQLStatementParser::MODIFY);
      setState(2377);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::COLUMN) {
        setState(2376);
        match(MySQLStatementParser::COLUMN);
      }
      setState(2379);
      dynamic_cast<ModifyColumnContext *>(_localctx)->columnInternalRef = identifier();
      setState(2380);
      fieldDefinition();
      setState(2382);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
      case 1: {
        setState(2381);
        place();
        break;
      }

      }
      break;
    }

    case 5: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterTableDropContext>(_localctx));
      enterOuterAlt(_localctx, 5);
      setState(2384);
      match(MySQLStatementParser::DROP);
      setState(2404);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::MAX:
        case MySQLStatementParser::MIN:
        case MySQLStatementParser::SUM:
        case MySQLStatementParser::COUNT:
        case MySQLStatementParser::GROUP_CONCAT:
        case MySQLStatementParser::CAST:
        case MySQLStatementParser::POSITION:
        case MySQLStatementParser::SUBSTRING:
        case MySQLStatementParser::SUBSTR:
        case MySQLStatementParser::EXTRACT:
        case MySQLStatementParser::TRIM:
        case MySQLStatementParser::LAST_DAY:
        case MySQLStatementParser::TRADITIONAL:
        case MySQLStatementParser::TREE:
        case MySQLStatementParser::MYSQL_ADMIN:
        case MySQLStatementParser::INSTANT:
        case MySQLStatementParser::INPLACE:
        case MySQLStatementParser::COPY:
        case MySQLStatementParser::UL_BINARY:
        case MySQLStatementParser::AUTOCOMMIT:
        case MySQLStatementParser::INNODB:
        case MySQLStatementParser::REDO_LOG:
        case MySQLStatementParser::ACCOUNT:
        case MySQLStatementParser::ACTION:
        case MySQLStatementParser::ACTIVE:
        case MySQLStatementParser::ADMIN:
        case MySQLStatementParser::AFTER:
        case MySQLStatementParser::AGAINST:
        case MySQLStatementParser::AGGREGATE:
        case MySQLStatementParser::ALGORITHM:
        case MySQLStatementParser::ALWAYS:
        case MySQLStatementParser::ANY:
        case MySQLStatementParser::ASCII:
        case MySQLStatementParser::AT:
        case MySQLStatementParser::ATTRIBUTE:
        case MySQLStatementParser::AUTOEXTEND_SIZE:
        case MySQLStatementParser::AUTO_INCREMENT:
        case MySQLStatementParser::AVG:
        case MySQLStatementParser::AVG_ROW_LENGTH:
        case MySQLStatementParser::BACKUP:
        case MySQLStatementParser::BEGIN:
        case MySQLStatementParser::BINLOG:
        case MySQLStatementParser::BIT:
        case MySQLStatementParser::BLOCK:
        case MySQLStatementParser::BOOL:
        case MySQLStatementParser::BOOLEAN:
        case MySQLStatementParser::BTREE:
        case MySQLStatementParser::BUCKETS:
        case MySQLStatementParser::BYTE:
        case MySQLStatementParser::CACHE:
        case MySQLStatementParser::CASCADED:
        case MySQLStatementParser::CATALOG_NAME:
        case MySQLStatementParser::CHAIN:
        case MySQLStatementParser::CHANGED:
        case MySQLStatementParser::CHANNEL:
        case MySQLStatementParser::CHARSET:
        case MySQLStatementParser::CHECKSUM:
        case MySQLStatementParser::CIPHER:
        case MySQLStatementParser::CLASS_ORIGIN:
        case MySQLStatementParser::CLIENT:
        case MySQLStatementParser::CLONE:
        case MySQLStatementParser::CLOSE:
        case MySQLStatementParser::COALESCE:
        case MySQLStatementParser::CODE:
        case MySQLStatementParser::COLLATION:
        case MySQLStatementParser::COLUMN:
        case MySQLStatementParser::COLUMNS:
        case MySQLStatementParser::COLUMN_FORMAT:
        case MySQLStatementParser::COLUMN_NAME:
        case MySQLStatementParser::COMMENT:
        case MySQLStatementParser::COMMIT:
        case MySQLStatementParser::COMMITTED:
        case MySQLStatementParser::COMPACT:
        case MySQLStatementParser::COMPLETION:
        case MySQLStatementParser::COMPONENT:
        case MySQLStatementParser::COMPRESSED:
        case MySQLStatementParser::COMPRESSION:
        case MySQLStatementParser::CONCURRENT:
        case MySQLStatementParser::CONNECTION:
        case MySQLStatementParser::CONSISTENT:
        case MySQLStatementParser::CONSTRAINT_CATALOG:
        case MySQLStatementParser::CONSTRAINT_NAME:
        case MySQLStatementParser::CONSTRAINT_SCHEMA:
        case MySQLStatementParser::CONTAINS:
        case MySQLStatementParser::CONTEXT:
        case MySQLStatementParser::CPU:
        case MySQLStatementParser::CURRENT:
        case MySQLStatementParser::CURSOR_NAME:
        case MySQLStatementParser::DATA:
        case MySQLStatementParser::DATAFILE:
        case MySQLStatementParser::DATE:
        case MySQLStatementParser::DATETIME:
        case MySQLStatementParser::DAY:
        case MySQLStatementParser::DEALLOCATE:
        case MySQLStatementParser::DEFAULT_AUTH:
        case MySQLStatementParser::DEFINER:
        case MySQLStatementParser::DEFINITION:
        case MySQLStatementParser::DELAY_KEY_WRITE:
        case MySQLStatementParser::DESCRIPTION:
        case MySQLStatementParser::DIAGNOSTICS:
        case MySQLStatementParser::DIRECTORY:
        case MySQLStatementParser::DISABLE:
        case MySQLStatementParser::DISCARD:
        case MySQLStatementParser::DISK:
        case MySQLStatementParser::DO:
        case MySQLStatementParser::DUMPFILE:
        case MySQLStatementParser::DUPLICATE:
        case MySQLStatementParser::DYNAMIC:
        case MySQLStatementParser::ENABLE:
        case MySQLStatementParser::ENCRYPTION:
        case MySQLStatementParser::END:
        case MySQLStatementParser::ENDS:
        case MySQLStatementParser::ENFORCED:
        case MySQLStatementParser::ENGINE:
        case MySQLStatementParser::ENGINES:
        case MySQLStatementParser::ENGINE_ATTRIBUTE:
        case MySQLStatementParser::ENUM:
        case MySQLStatementParser::ERROR:
        case MySQLStatementParser::ERRORS:
        case MySQLStatementParser::ESCAPE:
        case MySQLStatementParser::EVENT:
        case MySQLStatementParser::EVENTS:
        case MySQLStatementParser::EVERY:
        case MySQLStatementParser::EXCHANGE:
        case MySQLStatementParser::EXCLUDE:
        case MySQLStatementParser::EXECUTE:
        case MySQLStatementParser::EXPANSION:
        case MySQLStatementParser::EXPIRE:
        case MySQLStatementParser::EXPORT:
        case MySQLStatementParser::EXTENDED:
        case MySQLStatementParser::EXTENT_SIZE:
        case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
        case MySQLStatementParser::FAST:
        case MySQLStatementParser::FAULTS:
        case MySQLStatementParser::FIELDS:
        case MySQLStatementParser::FILE:
        case MySQLStatementParser::FILE_BLOCK_SIZE:
        case MySQLStatementParser::FILTER:
        case MySQLStatementParser::FIRST:
        case MySQLStatementParser::FIXED:
        case MySQLStatementParser::FLUSH:
        case MySQLStatementParser::FOLLOWING:
        case MySQLStatementParser::FOLLOWS:
        case MySQLStatementParser::FORMAT:
        case MySQLStatementParser::FULL:
        case MySQLStatementParser::GENERAL:
        case MySQLStatementParser::GEOMCOLLECTION:
        case MySQLStatementParser::GEOMETRY:
        case MySQLStatementParser::GEOMETRYCOLLECTION:
        case MySQLStatementParser::GET_FORMAT:
        case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
        case MySQLStatementParser::GLOBAL:
        case MySQLStatementParser::GRANTS:
        case MySQLStatementParser::GROUP_REPLICATION:
        case MySQLStatementParser::HANDLER:
        case MySQLStatementParser::HASH:
        case MySQLStatementParser::HELP:
        case MySQLStatementParser::HISTOGRAM:
        case MySQLStatementParser::HISTORY:
        case MySQLStatementParser::HOST:
        case MySQLStatementParser::HOSTS:
        case MySQLStatementParser::HOUR:
        case MySQLStatementParser::IDENTIFIED:
        case MySQLStatementParser::IGNORE_SERVER_IDS:
        case MySQLStatementParser::IMPORT:
        case MySQLStatementParser::INACTIVE:
        case MySQLStatementParser::INDEXES:
        case MySQLStatementParser::INITIAL_SIZE:
        case MySQLStatementParser::INSERT_METHOD:
        case MySQLStatementParser::INSTALL:
        case MySQLStatementParser::INSTANCE:
        case MySQLStatementParser::INVISIBLE:
        case MySQLStatementParser::INVOKER:
        case MySQLStatementParser::IO:
        case MySQLStatementParser::IO_THREAD:
        case MySQLStatementParser::IPC:
        case MySQLStatementParser::ISOLATION:
        case MySQLStatementParser::ISSUER:
        case MySQLStatementParser::JSON:
        case MySQLStatementParser::JSON_VALUE:
        case MySQLStatementParser::KEY_BLOCK_SIZE:
        case MySQLStatementParser::LANGUAGE:
        case MySQLStatementParser::LAST:
        case MySQLStatementParser::LEAVES:
        case MySQLStatementParser::LESS:
        case MySQLStatementParser::LEVEL:
        case MySQLStatementParser::LINESTRING:
        case MySQLStatementParser::LIST:
        case MySQLStatementParser::LOCAL:
        case MySQLStatementParser::LOCKED:
        case MySQLStatementParser::LOCKS:
        case MySQLStatementParser::LOGFILE:
        case MySQLStatementParser::LOGS:
        case MySQLStatementParser::MANAGED:
        case MySQLStatementParser::MASTER:
        case MySQLStatementParser::MASTER_AUTO_POSITION:
        case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
        case MySQLStatementParser::MASTER_CONNECT_RETRY:
        case MySQLStatementParser::MASTER_DELAY:
        case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
        case MySQLStatementParser::MASTER_HOST:
        case MySQLStatementParser::MASTER_LOG_FILE:
        case MySQLStatementParser::MASTER_LOG_POS:
        case MySQLStatementParser::MASTER_PASSWORD:
        case MySQLStatementParser::MASTER_PORT:
        case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
        case MySQLStatementParser::MASTER_RETRY_COUNT:
        case MySQLStatementParser::MASTER_SERVER_ID:
        case MySQLStatementParser::MASTER_SSL:
        case MySQLStatementParser::MASTER_SSL_CA:
        case MySQLStatementParser::MASTER_SSL_CAPATH:
        case MySQLStatementParser::MASTER_SSL_CERT:
        case MySQLStatementParser::MASTER_SSL_CIPHER:
        case MySQLStatementParser::MASTER_SSL_CRL:
        case MySQLStatementParser::MASTER_SSL_CRLPATH:
        case MySQLStatementParser::MASTER_SSL_KEY:
        case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
        case MySQLStatementParser::MASTER_TLS_VERSION:
        case MySQLStatementParser::MASTER_USER:
        case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
        case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
        case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
        case MySQLStatementParser::MAX_ROWS:
        case MySQLStatementParser::MAX_SIZE:
        case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
        case MySQLStatementParser::MAX_USER_CONNECTIONS:
        case MySQLStatementParser::MEDIUM:
        case MySQLStatementParser::MEMBER:
        case MySQLStatementParser::MEMORY:
        case MySQLStatementParser::MERGE:
        case MySQLStatementParser::MESSAGE_TEXT:
        case MySQLStatementParser::MICROSECOND:
        case MySQLStatementParser::MIGRATE:
        case MySQLStatementParser::MINUTE:
        case MySQLStatementParser::MIN_ROWS:
        case MySQLStatementParser::MODE:
        case MySQLStatementParser::MODIFY:
        case MySQLStatementParser::MONTH:
        case MySQLStatementParser::MULTILINESTRING:
        case MySQLStatementParser::MULTIPOINT:
        case MySQLStatementParser::MULTIPOLYGON:
        case MySQLStatementParser::MUTEX:
        case MySQLStatementParser::MYSQL_ERRNO:
        case MySQLStatementParser::NAME:
        case MySQLStatementParser::NAMES:
        case MySQLStatementParser::NATIONAL:
        case MySQLStatementParser::NCHAR:
        case MySQLStatementParser::NDB:
        case MySQLStatementParser::NDBCLUSTER:
        case MySQLStatementParser::NESTED:
        case MySQLStatementParser::NETWORK_NAMESPACE:
        case MySQLStatementParser::NEVER:
        case MySQLStatementParser::NEW:
        case MySQLStatementParser::NEXT:
        case MySQLStatementParser::NO:
        case MySQLStatementParser::NODEGROUP:
        case MySQLStatementParser::NONE:
        case MySQLStatementParser::NOWAIT:
        case MySQLStatementParser::NO_WAIT:
        case MySQLStatementParser::NULLS:
        case MySQLStatementParser::NUMBER:
        case MySQLStatementParser::NVARCHAR:
        case MySQLStatementParser::OFF:
        case MySQLStatementParser::OFFSET:
        case MySQLStatementParser::OJ:
        case MySQLStatementParser::OLD:
        case MySQLStatementParser::ONE:
        case MySQLStatementParser::ONLY:
        case MySQLStatementParser::OPEN:
        case MySQLStatementParser::OPTIONAL:
        case MySQLStatementParser::OPTIONS:
        case MySQLStatementParser::ORDINALITY:
        case MySQLStatementParser::OTHERS:
        case MySQLStatementParser::OWNER:
        case MySQLStatementParser::PACK_KEYS:
        case MySQLStatementParser::PAGE:
        case MySQLStatementParser::PARSER:
        case MySQLStatementParser::PARTIAL:
        case MySQLStatementParser::PARTITIONING:
        case MySQLStatementParser::PASSWORD:
        case MySQLStatementParser::PASSWORD_LOCK_TIME:
        case MySQLStatementParser::PATH:
        case MySQLStatementParser::PERSIST:
        case MySQLStatementParser::PERSIST_ONLY:
        case MySQLStatementParser::PHASE:
        case MySQLStatementParser::PLUGIN:
        case MySQLStatementParser::PLUGINS:
        case MySQLStatementParser::PLUGIN_DIR:
        case MySQLStatementParser::POINT:
        case MySQLStatementParser::POLYGON:
        case MySQLStatementParser::PORT:
        case MySQLStatementParser::PRECEDES:
        case MySQLStatementParser::PRECEDING:
        case MySQLStatementParser::PREPARE:
        case MySQLStatementParser::PRESERVE:
        case MySQLStatementParser::PREV:
        case MySQLStatementParser::PRIVILEGES:
        case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
        case MySQLStatementParser::PROCESS:
        case MySQLStatementParser::PROCESSLIST:
        case MySQLStatementParser::PROFILE:
        case MySQLStatementParser::PROFILES:
        case MySQLStatementParser::PROXY:
        case MySQLStatementParser::QUARTER:
        case MySQLStatementParser::QUERY:
        case MySQLStatementParser::QUICK:
        case MySQLStatementParser::RANDOM:
        case MySQLStatementParser::READ_ONLY:
        case MySQLStatementParser::REBUILD:
        case MySQLStatementParser::RECOVER:
        case MySQLStatementParser::REDO_BUFFER_SIZE:
        case MySQLStatementParser::REDUNDANT:
        case MySQLStatementParser::REFERENCE:
        case MySQLStatementParser::RELAY:
        case MySQLStatementParser::RELAYLOG:
        case MySQLStatementParser::RELAY_LOG_FILE:
        case MySQLStatementParser::RELAY_LOG_POS:
        case MySQLStatementParser::RELAY_THREAD:
        case MySQLStatementParser::RELOAD:
        case MySQLStatementParser::REMOVE:
        case MySQLStatementParser::REORGANIZE:
        case MySQLStatementParser::REPAIR:
        case MySQLStatementParser::REPEATABLE:
        case MySQLStatementParser::REPLICATE_DO_DB:
        case MySQLStatementParser::REPLICATE_DO_TABLE:
        case MySQLStatementParser::REPLICATE_IGNORE_DB:
        case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
        case MySQLStatementParser::REPLICATE_REWRITE_DB:
        case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
        case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
        case MySQLStatementParser::REPLICATION:
        case MySQLStatementParser::REQUIRE_ROW_FORMAT:
        case MySQLStatementParser::RESET:
        case MySQLStatementParser::RESOURCE:
        case MySQLStatementParser::RESPECT:
        case MySQLStatementParser::RESTART:
        case MySQLStatementParser::RESTORE:
        case MySQLStatementParser::RESUME:
        case MySQLStatementParser::RETAIN:
        case MySQLStatementParser::RETURNED_SQLSTATE:
        case MySQLStatementParser::RETURNING:
        case MySQLStatementParser::RETURNS:
        case MySQLStatementParser::REUSE:
        case MySQLStatementParser::REVERSE:
        case MySQLStatementParser::ROLE:
        case MySQLStatementParser::ROLLBACK:
        case MySQLStatementParser::ROLLUP:
        case MySQLStatementParser::ROTATE:
        case MySQLStatementParser::ROUTINE:
        case MySQLStatementParser::ROW_COUNT:
        case MySQLStatementParser::ROW_FORMAT:
        case MySQLStatementParser::RTREE:
        case MySQLStatementParser::SAVEPOINT:
        case MySQLStatementParser::SCHEDULE:
        case MySQLStatementParser::SCHEMA_NAME:
        case MySQLStatementParser::SECOND:
        case MySQLStatementParser::SECONDARY:
        case MySQLStatementParser::SECONDARY_ENGINE:
        case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
        case MySQLStatementParser::SECONDARY_LOAD:
        case MySQLStatementParser::SECONDARY_UNLOAD:
        case MySQLStatementParser::SECURITY:
        case MySQLStatementParser::SERIAL:
        case MySQLStatementParser::SERIALIZABLE:
        case MySQLStatementParser::SERVER:
        case MySQLStatementParser::SESSION:
        case MySQLStatementParser::SHARE:
        case MySQLStatementParser::SHUTDOWN:
        case MySQLStatementParser::SIGNED:
        case MySQLStatementParser::SIMPLE:
        case MySQLStatementParser::SLAVE:
        case MySQLStatementParser::SLOW:
        case MySQLStatementParser::SNAPSHOT:
        case MySQLStatementParser::SOCKET:
        case MySQLStatementParser::SOME:
        case MySQLStatementParser::SONAME:
        case MySQLStatementParser::SOUNDS:
        case MySQLStatementParser::SOURCE:
        case MySQLStatementParser::SQL_CACHE:
        case MySQLStatementParser::SQL_AFTER_GTIDS:
        case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
        case MySQLStatementParser::SQL_BEFORE_GTIDS:
        case MySQLStatementParser::SQL_BUFFER_RESULT:
        case MySQLStatementParser::SQL_NO_CACHE:
        case MySQLStatementParser::SQL_THREAD:
        case MySQLStatementParser::SQL_TSI_DAY:
        case MySQLStatementParser::SQL_TSI_HOUR:
        case MySQLStatementParser::SQL_TSI_MINUTE:
        case MySQLStatementParser::SQL_TSI_MONTH:
        case MySQLStatementParser::SQL_TSI_QUARTER:
        case MySQLStatementParser::SQL_TSI_SECOND:
        case MySQLStatementParser::SQL_TSI_WEEK:
        case MySQLStatementParser::SQL_TSI_YEAR:
        case MySQLStatementParser::SRID:
        case MySQLStatementParser::STACKED:
        case MySQLStatementParser::START:
        case MySQLStatementParser::STARTS:
        case MySQLStatementParser::STATS_AUTO_RECALC:
        case MySQLStatementParser::STATS_PERSISTENT:
        case MySQLStatementParser::STATS_SAMPLE_PAGES:
        case MySQLStatementParser::STATUS:
        case MySQLStatementParser::STOP:
        case MySQLStatementParser::STORAGE:
        case MySQLStatementParser::STREAM:
        case MySQLStatementParser::STRING:
        case MySQLStatementParser::SUBCLASS_ORIGIN:
        case MySQLStatementParser::SUBJECT:
        case MySQLStatementParser::SUBPARTITION:
        case MySQLStatementParser::SUBPARTITIONS:
        case MySQLStatementParser::SUPER:
        case MySQLStatementParser::SUSPEND:
        case MySQLStatementParser::SWAPS:
        case MySQLStatementParser::SWITCHES:
        case MySQLStatementParser::TABLES:
        case MySQLStatementParser::TABLESPACE:
        case MySQLStatementParser::TABLE_CHECKSUM:
        case MySQLStatementParser::TABLE_NAME:
        case MySQLStatementParser::TEMPORARY:
        case MySQLStatementParser::TEMPTABLE:
        case MySQLStatementParser::TEXT:
        case MySQLStatementParser::THAN:
        case MySQLStatementParser::THREAD_PRIORITY:
        case MySQLStatementParser::TIES:
        case MySQLStatementParser::TIME:
        case MySQLStatementParser::TIMESTAMP:
        case MySQLStatementParser::TIMESTAMPADD:
        case MySQLStatementParser::TIMESTAMPDIFF:
        case MySQLStatementParser::TLS:
        case MySQLStatementParser::TRANSACTION:
        case MySQLStatementParser::TRIGGERS:
        case MySQLStatementParser::TRUNCATE:
        case MySQLStatementParser::TYPE:
        case MySQLStatementParser::TYPES:
        case MySQLStatementParser::UNBOUNDED:
        case MySQLStatementParser::UNCOMMITTED:
        case MySQLStatementParser::UNDEFINED:
        case MySQLStatementParser::UNDOFILE:
        case MySQLStatementParser::UNDO_BUFFER_SIZE:
        case MySQLStatementParser::UNICODE:
        case MySQLStatementParser::UNINSTALL:
        case MySQLStatementParser::UNKNOWN:
        case MySQLStatementParser::UNTIL:
        case MySQLStatementParser::UPGRADE:
        case MySQLStatementParser::USER:
        case MySQLStatementParser::USER_RESOURCES:
        case MySQLStatementParser::USE_FRM:
        case MySQLStatementParser::VALIDATION:
        case MySQLStatementParser::VALUE:
        case MySQLStatementParser::VARIABLES:
        case MySQLStatementParser::VCPU:
        case MySQLStatementParser::VIEW:
        case MySQLStatementParser::VISIBLE:
        case MySQLStatementParser::WAIT:
        case MySQLStatementParser::WARNINGS:
        case MySQLStatementParser::WEEK:
        case MySQLStatementParser::WEIGHT_STRING:
        case MySQLStatementParser::WITHOUT:
        case MySQLStatementParser::WORK:
        case MySQLStatementParser::WRAPPER:
        case MySQLStatementParser::X509:
        case MySQLStatementParser::XA:
        case MySQLStatementParser::XID:
        case MySQLStatementParser::XML:
        case MySQLStatementParser::YEAR:
        case MySQLStatementParser::IDENTIFIER_:
        case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
          setState(2386);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::COLUMN) {
            setState(2385);
            match(MySQLStatementParser::COLUMN);
          }
          setState(2388);
          dynamic_cast<AlterTableDropContext *>(_localctx)->columnInternalRef = identifier();
          setState(2390);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::CASCADE || _la == MySQLStatementParser::RESTRICT) {
            setState(2389);
            restrict();
          }
          break;
        }

        case MySQLStatementParser::FOREIGN: {
          setState(2392);
          match(MySQLStatementParser::FOREIGN);
          setState(2393);
          match(MySQLStatementParser::KEY);
          setState(2394);
          dynamic_cast<AlterTableDropContext *>(_localctx)->columnInternalRef = identifier();
          break;
        }

        case MySQLStatementParser::PRIMARY: {
          setState(2395);
          match(MySQLStatementParser::PRIMARY);
          setState(2396);
          match(MySQLStatementParser::KEY);
          break;
        }

        case MySQLStatementParser::INDEX:
        case MySQLStatementParser::KEY: {
          setState(2397);
          keyOrIndex();
          setState(2398);
          indexName();
          break;
        }

        case MySQLStatementParser::CHECK: {
          setState(2400);
          match(MySQLStatementParser::CHECK);
          setState(2401);
          identifier();
          break;
        }

        case MySQLStatementParser::CONSTRAINT: {
          setState(2402);
          match(MySQLStatementParser::CONSTRAINT);
          setState(2403);
          identifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 6: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::DisableKeysContext>(_localctx));
      enterOuterAlt(_localctx, 6);
      setState(2406);
      match(MySQLStatementParser::DISABLE);
      setState(2407);
      match(MySQLStatementParser::KEYS);
      break;
    }

    case 7: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::EnableKeysContext>(_localctx));
      enterOuterAlt(_localctx, 7);
      setState(2408);
      match(MySQLStatementParser::ENABLE);
      setState(2409);
      match(MySQLStatementParser::KEYS);
      break;
    }

    case 8: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterColumnContext>(_localctx));
      enterOuterAlt(_localctx, 8);
      setState(2410);
      match(MySQLStatementParser::ALTER);
      setState(2412);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::COLUMN) {
        setState(2411);
        match(MySQLStatementParser::COLUMN);
      }
      setState(2414);
      dynamic_cast<AlterColumnContext *>(_localctx)->columnInternalRef = identifier();
      setState(2426);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::SET: {
          setState(2415);
          match(MySQLStatementParser::SET);
          setState(2416);
          match(MySQLStatementParser::DEFAULT);
          setState(2422);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLStatementParser::LP_: {
              setState(2417);
              match(MySQLStatementParser::LP_);
              setState(2418);
              expr(0);
              setState(2419);
              match(MySQLStatementParser::RP_);
              break;
            }

            case MySQLStatementParser::DATE:
            case MySQLStatementParser::FALSE:
            case MySQLStatementParser::NULL:
            case MySQLStatementParser::TIME:
            case MySQLStatementParser::TIMESTAMP:
            case MySQLStatementParser::TRUE:
            case MySQLStatementParser::PLUS_:
            case MySQLStatementParser::MINUS_:
            case MySQLStatementParser::SINGLE_QUOTED_TEXT:
            case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
            case MySQLStatementParser::NCHAR_TEXT:
            case MySQLStatementParser::UNDERSCORE_CHARSET:
            case MySQLStatementParser::NUMBER_:
            case MySQLStatementParser::HEX_DIGIT_:
            case MySQLStatementParser::BIT_NUM_: {
              setState(2421);
              signedLiteral();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case MySQLStatementParser::DROP: {
          setState(2424);
          match(MySQLStatementParser::DROP);
          setState(2425);
          match(MySQLStatementParser::DEFAULT);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 9: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterIndexContext>(_localctx));
      enterOuterAlt(_localctx, 9);
      setState(2428);
      match(MySQLStatementParser::ALTER);
      setState(2429);
      match(MySQLStatementParser::INDEX);
      setState(2430);
      indexName();
      setState(2431);
      visibility();
      break;
    }

    case 10: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterCheckContext>(_localctx));
      enterOuterAlt(_localctx, 10);
      setState(2433);
      match(MySQLStatementParser::ALTER);
      setState(2434);
      match(MySQLStatementParser::CHECK);
      setState(2435);
      identifier();
      setState(2436);
      constraintEnforcement();
      break;
    }

    case 11: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterConstraintContext>(_localctx));
      enterOuterAlt(_localctx, 11);
      setState(2438);
      match(MySQLStatementParser::ALTER);
      setState(2439);
      match(MySQLStatementParser::CONSTRAINT);
      setState(2440);
      identifier();
      setState(2441);
      constraintEnforcement();
      break;
    }

    case 12: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::RenameColumnContext>(_localctx));
      enterOuterAlt(_localctx, 12);
      setState(2443);
      match(MySQLStatementParser::RENAME);
      setState(2444);
      match(MySQLStatementParser::COLUMN);
      setState(2445);
      dynamic_cast<RenameColumnContext *>(_localctx)->columnInternalRef = identifier();
      setState(2446);
      match(MySQLStatementParser::TO);
      setState(2447);
      identifier();
      break;
    }

    case 13: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterRenameTableContext>(_localctx));
      enterOuterAlt(_localctx, 13);
      setState(2449);
      match(MySQLStatementParser::RENAME);
      setState(2451);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::AS || _la == MySQLStatementParser::TO) {
        setState(2450);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::AS || _la == MySQLStatementParser::TO)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2453);
      tableName();
      break;
    }

    case 14: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::RenameIndexContext>(_localctx));
      enterOuterAlt(_localctx, 14);
      setState(2454);
      match(MySQLStatementParser::RENAME);
      setState(2455);
      keyOrIndex();
      setState(2456);
      indexName();
      setState(2457);
      match(MySQLStatementParser::TO);
      setState(2458);
      indexName();
      break;
    }

    case 15: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterConvertContext>(_localctx));
      enterOuterAlt(_localctx, 15);
      setState(2460);
      match(MySQLStatementParser::CONVERT);
      setState(2461);
      match(MySQLStatementParser::TO);
      setState(2462);
      charset();
      setState(2463);
      charsetName();
      setState(2465);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::COLLATE) {
        setState(2464);
        collateClause();
      }
      break;
    }

    case 16: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterTableForceContext>(_localctx));
      enterOuterAlt(_localctx, 16);
      setState(2467);
      match(MySQLStatementParser::FORCE);
      break;
    }

    case 17: {
      _localctx = dynamic_cast<AlterListItemContext *>(_tracker.createInstance<MySQLStatementParser::AlterTableOrderContext>(_localctx));
      enterOuterAlt(_localctx, 17);
      setState(2468);
      match(MySQLStatementParser::ORDER);
      setState(2469);
      match(MySQLStatementParser::BY);
      setState(2470);
      alterOrderList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterOrderListContext ------------------------------------------------------------------

MySQLStatementParser::AlterOrderListContext::AlterOrderListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::AlterOrderListContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterOrderListContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

std::vector<MySQLStatementParser::DirectionContext *> MySQLStatementParser::AlterOrderListContext::direction() {
  return getRuleContexts<MySQLStatementParser::DirectionContext>();
}

MySQLStatementParser::DirectionContext* MySQLStatementParser::AlterOrderListContext::direction(size_t i) {
  return getRuleContext<MySQLStatementParser::DirectionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterOrderListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AlterOrderListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::AlterOrderListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterOrderList;
}

void MySQLStatementParser::AlterOrderListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterOrderList(this);
}

void MySQLStatementParser::AlterOrderListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterOrderList(this);
}


antlrcpp::Any MySQLStatementParser::AlterOrderListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterOrderList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterOrderListContext* MySQLStatementParser::alterOrderList() {
  AlterOrderListContext *_localctx = _tracker.createInstance<AlterOrderListContext>(_ctx, getState());
  enterRule(_localctx, 204, MySQLStatementParser::RuleAlterOrderList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2473);
    identifier();
    setState(2475);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ASC || _la == MySQLStatementParser::DESC) {
      setState(2474);
      direction();
    }
    setState(2484);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2477);
        match(MySQLStatementParser::COMMA_);
        setState(2478);
        identifier();
        setState(2480);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ASC || _la == MySQLStatementParser::DESC) {
          setState(2479);
          direction();
        } 
      }
      setState(2486);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableConstraintDefContext ------------------------------------------------------------------

MySQLStatementParser::TableConstraintDefContext::TableConstraintDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::KeyOrIndexContext* MySQLStatementParser::TableConstraintDefContext::keyOrIndex() {
  return getRuleContext<MySQLStatementParser::KeyOrIndexContext>(0);
}

MySQLStatementParser::KeyListWithExpressionContext* MySQLStatementParser::TableConstraintDefContext::keyListWithExpression() {
  return getRuleContext<MySQLStatementParser::KeyListWithExpressionContext>(0);
}

MySQLStatementParser::IndexNameAndTypeContext* MySQLStatementParser::TableConstraintDefContext::indexNameAndType() {
  return getRuleContext<MySQLStatementParser::IndexNameAndTypeContext>(0);
}

std::vector<MySQLStatementParser::IndexOptionContext *> MySQLStatementParser::TableConstraintDefContext::indexOption() {
  return getRuleContexts<MySQLStatementParser::IndexOptionContext>();
}

MySQLStatementParser::IndexOptionContext* MySQLStatementParser::TableConstraintDefContext::indexOption(size_t i) {
  return getRuleContext<MySQLStatementParser::IndexOptionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::TableConstraintDefContext::FULLTEXT() {
  return getToken(MySQLStatementParser::FULLTEXT, 0);
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::TableConstraintDefContext::indexName() {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(0);
}

std::vector<MySQLStatementParser::FulltextIndexOptionContext *> MySQLStatementParser::TableConstraintDefContext::fulltextIndexOption() {
  return getRuleContexts<MySQLStatementParser::FulltextIndexOptionContext>();
}

MySQLStatementParser::FulltextIndexOptionContext* MySQLStatementParser::TableConstraintDefContext::fulltextIndexOption(size_t i) {
  return getRuleContext<MySQLStatementParser::FulltextIndexOptionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::TableConstraintDefContext::SPATIAL() {
  return getToken(MySQLStatementParser::SPATIAL, 0);
}

std::vector<MySQLStatementParser::CommonIndexOptionContext *> MySQLStatementParser::TableConstraintDefContext::commonIndexOption() {
  return getRuleContexts<MySQLStatementParser::CommonIndexOptionContext>();
}

MySQLStatementParser::CommonIndexOptionContext* MySQLStatementParser::TableConstraintDefContext::commonIndexOption(size_t i) {
  return getRuleContext<MySQLStatementParser::CommonIndexOptionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::TableConstraintDefContext::PRIMARY() {
  return getToken(MySQLStatementParser::PRIMARY, 0);
}

tree::TerminalNode* MySQLStatementParser::TableConstraintDefContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::TableConstraintDefContext::UNIQUE() {
  return getToken(MySQLStatementParser::UNIQUE, 0);
}

MySQLStatementParser::ConstraintNameContext* MySQLStatementParser::TableConstraintDefContext::constraintName() {
  return getRuleContext<MySQLStatementParser::ConstraintNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableConstraintDefContext::FOREIGN() {
  return getToken(MySQLStatementParser::FOREIGN, 0);
}

MySQLStatementParser::KeyPartsContext* MySQLStatementParser::TableConstraintDefContext::keyParts() {
  return getRuleContext<MySQLStatementParser::KeyPartsContext>(0);
}

MySQLStatementParser::ReferenceDefinitionContext* MySQLStatementParser::TableConstraintDefContext::referenceDefinition() {
  return getRuleContext<MySQLStatementParser::ReferenceDefinitionContext>(0);
}

MySQLStatementParser::CheckConstraintContext* MySQLStatementParser::TableConstraintDefContext::checkConstraint() {
  return getRuleContext<MySQLStatementParser::CheckConstraintContext>(0);
}

MySQLStatementParser::ConstraintEnforcementContext* MySQLStatementParser::TableConstraintDefContext::constraintEnforcement() {
  return getRuleContext<MySQLStatementParser::ConstraintEnforcementContext>(0);
}


size_t MySQLStatementParser::TableConstraintDefContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableConstraintDef;
}

void MySQLStatementParser::TableConstraintDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableConstraintDef(this);
}

void MySQLStatementParser::TableConstraintDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableConstraintDef(this);
}


antlrcpp::Any MySQLStatementParser::TableConstraintDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableConstraintDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableConstraintDefContext* MySQLStatementParser::tableConstraintDef() {
  TableConstraintDefContext *_localctx = _tracker.createInstance<TableConstraintDefContext>(_ctx, getState());
  enterRule(_localctx, 206, MySQLStatementParser::RuleTableConstraintDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2565);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2487);
      keyOrIndex();
      setState(2489);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(2488);
        indexNameAndType();
      }
      setState(2491);
      keyListWithExpression();
      setState(2495);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2492);
          indexOption(); 
        }
        setState(2497);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2498);
      match(MySQLStatementParser::FULLTEXT);
      setState(2500);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::INDEX

      || _la == MySQLStatementParser::KEY) {
        setState(2499);
        keyOrIndex();
      }
      setState(2503);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(2502);
        indexName();
      }
      setState(2505);
      keyListWithExpression();
      setState(2509);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2506);
          fulltextIndexOption(); 
        }
        setState(2511);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2512);
      match(MySQLStatementParser::SPATIAL);
      setState(2514);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::INDEX

      || _la == MySQLStatementParser::KEY) {
        setState(2513);
        keyOrIndex();
      }
      setState(2517);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(2516);
        indexName();
      }
      setState(2519);
      keyListWithExpression();
      setState(2523);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2520);
          commonIndexOption(); 
        }
        setState(2525);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2527);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::CONSTRAINT) {
        setState(2526);
        constraintName();
      }
      setState(2535);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::PRIMARY: {
          setState(2529);
          match(MySQLStatementParser::PRIMARY);
          setState(2530);
          match(MySQLStatementParser::KEY);
          break;
        }

        case MySQLStatementParser::UNIQUE: {
          setState(2531);
          match(MySQLStatementParser::UNIQUE);
          setState(2533);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::INDEX

          || _la == MySQLStatementParser::KEY) {
            setState(2532);
            keyOrIndex();
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2538);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(2537);
        indexNameAndType();
      }
      setState(2540);
      keyListWithExpression();
      setState(2544);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2541);
          indexOption(); 
        }
        setState(2546);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2548);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::CONSTRAINT) {
        setState(2547);
        constraintName();
      }
      setState(2550);
      match(MySQLStatementParser::FOREIGN);
      setState(2551);
      match(MySQLStatementParser::KEY);
      setState(2553);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
        | (1ULL << MySQLStatementParser::MIN)
        | (1ULL << MySQLStatementParser::SUM)
        | (1ULL << MySQLStatementParser::COUNT)
        | (1ULL << MySQLStatementParser::GROUP_CONCAT)
        | (1ULL << MySQLStatementParser::CAST)
        | (1ULL << MySQLStatementParser::POSITION)
        | (1ULL << MySQLStatementParser::SUBSTRING)
        | (1ULL << MySQLStatementParser::SUBSTR)
        | (1ULL << MySQLStatementParser::EXTRACT)
        | (1ULL << MySQLStatementParser::TRIM)
        | (1ULL << MySQLStatementParser::LAST_DAY)
        | (1ULL << MySQLStatementParser::TRADITIONAL)
        | (1ULL << MySQLStatementParser::TREE)
        | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
        | (1ULL << MySQLStatementParser::INSTANT)
        | (1ULL << MySQLStatementParser::INPLACE)
        | (1ULL << MySQLStatementParser::COPY)
        | (1ULL << MySQLStatementParser::UL_BINARY)
        | (1ULL << MySQLStatementParser::AUTOCOMMIT)
        | (1ULL << MySQLStatementParser::INNODB)
        | (1ULL << MySQLStatementParser::REDO_LOG)
        | (1ULL << MySQLStatementParser::ACCOUNT)
        | (1ULL << MySQLStatementParser::ACTION)
        | (1ULL << MySQLStatementParser::ACTIVE)
        | (1ULL << MySQLStatementParser::ADMIN)
        | (1ULL << MySQLStatementParser::AFTER)
        | (1ULL << MySQLStatementParser::AGAINST)
        | (1ULL << MySQLStatementParser::AGGREGATE)
        | (1ULL << MySQLStatementParser::ALGORITHM)
        | (1ULL << MySQLStatementParser::ALWAYS)
        | (1ULL << MySQLStatementParser::ANY)
        | (1ULL << MySQLStatementParser::ASCII)
        | (1ULL << MySQLStatementParser::AT)
        | (1ULL << MySQLStatementParser::ATTRIBUTE)
        | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
        | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
        | (1ULL << MySQLStatementParser::AVG)
        | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
        | (1ULL << MySQLStatementParser::BACKUP)
        | (1ULL << MySQLStatementParser::BEGIN)
        | (1ULL << MySQLStatementParser::BINLOG)
        | (1ULL << MySQLStatementParser::BIT)
        | (1ULL << MySQLStatementParser::BLOCK)
        | (1ULL << MySQLStatementParser::BOOL)
        | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
        | (1ULL << (MySQLStatementParser::BUCKETS - 65))
        | (1ULL << (MySQLStatementParser::BYTE - 65))
        | (1ULL << (MySQLStatementParser::CACHE - 65))
        | (1ULL << (MySQLStatementParser::CASCADED - 65))
        | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
        | (1ULL << (MySQLStatementParser::CHAIN - 65))
        | (1ULL << (MySQLStatementParser::CHANGED - 65))
        | (1ULL << (MySQLStatementParser::CHANNEL - 65))
        | (1ULL << (MySQLStatementParser::CHARSET - 65))
        | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
        | (1ULL << (MySQLStatementParser::CIPHER - 65))
        | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
        | (1ULL << (MySQLStatementParser::CLIENT - 65))
        | (1ULL << (MySQLStatementParser::CLONE - 65))
        | (1ULL << (MySQLStatementParser::CLOSE - 65))
        | (1ULL << (MySQLStatementParser::COALESCE - 65))
        | (1ULL << (MySQLStatementParser::CODE - 65))
        | (1ULL << (MySQLStatementParser::COLLATION - 65))
        | (1ULL << (MySQLStatementParser::COLUMNS - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
        | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
        | (1ULL << (MySQLStatementParser::COMMENT - 65))
        | (1ULL << (MySQLStatementParser::COMMIT - 65))
        | (1ULL << (MySQLStatementParser::COMMITTED - 65))
        | (1ULL << (MySQLStatementParser::COMPACT - 65))
        | (1ULL << (MySQLStatementParser::COMPLETION - 65))
        | (1ULL << (MySQLStatementParser::COMPONENT - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
        | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
        | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
        | (1ULL << (MySQLStatementParser::CONNECTION - 65))
        | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
        | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
        | (1ULL << (MySQLStatementParser::CONTAINS - 65))
        | (1ULL << (MySQLStatementParser::CONTEXT - 65))
        | (1ULL << (MySQLStatementParser::CPU - 65))
        | (1ULL << (MySQLStatementParser::CURRENT - 65))
        | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
        | (1ULL << (MySQLStatementParser::DATAFILE - 129))
        | (1ULL << (MySQLStatementParser::DATE - 129))
        | (1ULL << (MySQLStatementParser::DATETIME - 129))
        | (1ULL << (MySQLStatementParser::DAY - 129))
        | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
        | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
        | (1ULL << (MySQLStatementParser::DEFINER - 129))
        | (1ULL << (MySQLStatementParser::DEFINITION - 129))
        | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
        | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
        | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
        | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
        | (1ULL << (MySQLStatementParser::DISABLE - 129))
        | (1ULL << (MySQLStatementParser::DISCARD - 129))
        | (1ULL << (MySQLStatementParser::DISK - 129))
        | (1ULL << (MySQLStatementParser::DO - 129))
        | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
        | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
        | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
        | (1ULL << (MySQLStatementParser::ENABLE - 129))
        | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
        | (1ULL << (MySQLStatementParser::END - 129))
        | (1ULL << (MySQLStatementParser::ENDS - 129))
        | (1ULL << (MySQLStatementParser::ENFORCED - 129))
        | (1ULL << (MySQLStatementParser::ENGINE - 129))
        | (1ULL << (MySQLStatementParser::ENGINES - 129))
        | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
        | (1ULL << (MySQLStatementParser::ENUM - 129))
        | (1ULL << (MySQLStatementParser::ERROR - 129))
        | (1ULL << (MySQLStatementParser::ERRORS - 129))
        | (1ULL << (MySQLStatementParser::ESCAPE - 129))
        | (1ULL << (MySQLStatementParser::EVENT - 129))
        | (1ULL << (MySQLStatementParser::EVENTS - 129))
        | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
        | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
        | (1ULL << (MySQLStatementParser::EXECUTE - 193))
        | (1ULL << (MySQLStatementParser::EXPANSION - 193))
        | (1ULL << (MySQLStatementParser::EXPIRE - 193))
        | (1ULL << (MySQLStatementParser::EXPORT - 193))
        | (1ULL << (MySQLStatementParser::EXTENDED - 193))
        | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
        | (1ULL << (MySQLStatementParser::FAST - 193))
        | (1ULL << (MySQLStatementParser::FAULTS - 193))
        | (1ULL << (MySQLStatementParser::FIELDS - 193))
        | (1ULL << (MySQLStatementParser::FILE - 193))
        | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
        | (1ULL << (MySQLStatementParser::FILTER - 193))
        | (1ULL << (MySQLStatementParser::FIRST - 193))
        | (1ULL << (MySQLStatementParser::FIXED - 193))
        | (1ULL << (MySQLStatementParser::FLUSH - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
        | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
        | (1ULL << (MySQLStatementParser::FORMAT - 193))
        | (1ULL << (MySQLStatementParser::FULL - 193))
        | (1ULL << (MySQLStatementParser::GENERAL - 193))
        | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
        | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
        | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
        | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
        | (1ULL << (MySQLStatementParser::GLOBAL - 193))
        | (1ULL << (MySQLStatementParser::GRANTS - 193))
        | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
        | (1ULL << (MySQLStatementParser::HANDLER - 193))
        | (1ULL << (MySQLStatementParser::HASH - 193))
        | (1ULL << (MySQLStatementParser::HELP - 193))
        | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
        | (1ULL << (MySQLStatementParser::HISTORY - 193))
        | (1ULL << (MySQLStatementParser::HOST - 193))
        | (1ULL << (MySQLStatementParser::HOSTS - 193))
        | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
        | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
        | (1ULL << (MySQLStatementParser::IMPORT - 259))
        | (1ULL << (MySQLStatementParser::INACTIVE - 259))
        | (1ULL << (MySQLStatementParser::INDEXES - 259))
        | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
        | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
        | (1ULL << (MySQLStatementParser::INSTALL - 259))
        | (1ULL << (MySQLStatementParser::INSTANCE - 259))
        | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
        | (1ULL << (MySQLStatementParser::INVOKER - 259))
        | (1ULL << (MySQLStatementParser::IO - 259))
        | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
        | (1ULL << (MySQLStatementParser::IPC - 259))
        | (1ULL << (MySQLStatementParser::ISOLATION - 259))
        | (1ULL << (MySQLStatementParser::ISSUER - 259))
        | (1ULL << (MySQLStatementParser::JSON - 259))
        | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
        | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
        | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
        | (1ULL << (MySQLStatementParser::LAST - 259))
        | (1ULL << (MySQLStatementParser::LEAVES - 259))
        | (1ULL << (MySQLStatementParser::LESS - 259))
        | (1ULL << (MySQLStatementParser::LEVEL - 259))
        | (1ULL << (MySQLStatementParser::LINESTRING - 259))
        | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
        | (1ULL << (MySQLStatementParser::LOCKED - 324))
        | (1ULL << (MySQLStatementParser::LOCKS - 324))
        | (1ULL << (MySQLStatementParser::LOGFILE - 324))
        | (1ULL << (MySQLStatementParser::LOGS - 324))
        | (1ULL << (MySQLStatementParser::MANAGED - 324))
        | (1ULL << (MySQLStatementParser::MASTER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
        | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
        | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
        | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
        | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
        | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
        | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
        | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
        | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
        | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
        | (1ULL << (MySQLStatementParser::MEDIUM - 324))
        | (1ULL << (MySQLStatementParser::MEMBER - 324))
        | (1ULL << (MySQLStatementParser::MEMORY - 324))
        | (1ULL << (MySQLStatementParser::MERGE - 324))
        | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
        | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
        | (1ULL << (MySQLStatementParser::MIGRATE - 324))
        | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
        | (1ULL << (MySQLStatementParser::MODE - 388))
        | (1ULL << (MySQLStatementParser::MODIFY - 388))
        | (1ULL << (MySQLStatementParser::MONTH - 388))
        | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
        | (1ULL << (MySQLStatementParser::MUTEX - 388))
        | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
        | (1ULL << (MySQLStatementParser::NAME - 388))
        | (1ULL << (MySQLStatementParser::NAMES - 388))
        | (1ULL << (MySQLStatementParser::NATIONAL - 388))
        | (1ULL << (MySQLStatementParser::NCHAR - 388))
        | (1ULL << (MySQLStatementParser::NDB - 388))
        | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
        | (1ULL << (MySQLStatementParser::NESTED - 388))
        | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
        | (1ULL << (MySQLStatementParser::NEVER - 388))
        | (1ULL << (MySQLStatementParser::NEW - 388))
        | (1ULL << (MySQLStatementParser::NEXT - 388))
        | (1ULL << (MySQLStatementParser::NO - 388))
        | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
        | (1ULL << (MySQLStatementParser::NONE - 388))
        | (1ULL << (MySQLStatementParser::NOWAIT - 388))
        | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
        | (1ULL << (MySQLStatementParser::NULLS - 388))
        | (1ULL << (MySQLStatementParser::NUMBER - 388))
        | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
        | (1ULL << (MySQLStatementParser::OFF - 388))
        | (1ULL << (MySQLStatementParser::OFFSET - 388))
        | (1ULL << (MySQLStatementParser::OJ - 388))
        | (1ULL << (MySQLStatementParser::OLD - 388))
        | (1ULL << (MySQLStatementParser::ONE - 388))
        | (1ULL << (MySQLStatementParser::ONLY - 388))
        | (1ULL << (MySQLStatementParser::OPEN - 388))
        | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
        | (1ULL << (MySQLStatementParser::OPTIONS - 388))
        | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
        | (1ULL << (MySQLStatementParser::OTHERS - 388))
        | (1ULL << (MySQLStatementParser::OWNER - 388))
        | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
        | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
        | (1ULL << (MySQLStatementParser::PARTIAL - 452))
        | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD - 452))
        | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
        | (1ULL << (MySQLStatementParser::PATH - 452))
        | (1ULL << (MySQLStatementParser::PERSIST - 452))
        | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
        | (1ULL << (MySQLStatementParser::PHASE - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN - 452))
        | (1ULL << (MySQLStatementParser::PLUGINS - 452))
        | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
        | (1ULL << (MySQLStatementParser::POINT - 452))
        | (1ULL << (MySQLStatementParser::POLYGON - 452))
        | (1ULL << (MySQLStatementParser::PORT - 452))
        | (1ULL << (MySQLStatementParser::PRECEDES - 452))
        | (1ULL << (MySQLStatementParser::PRECEDING - 452))
        | (1ULL << (MySQLStatementParser::PREPARE - 452))
        | (1ULL << (MySQLStatementParser::PRESERVE - 452))
        | (1ULL << (MySQLStatementParser::PREV - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
        | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
        | (1ULL << (MySQLStatementParser::PROCESS - 452))
        | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
        | (1ULL << (MySQLStatementParser::PROFILE - 452))
        | (1ULL << (MySQLStatementParser::PROFILES - 452))
        | (1ULL << (MySQLStatementParser::PROXY - 452))
        | (1ULL << (MySQLStatementParser::QUARTER - 452))
        | (1ULL << (MySQLStatementParser::QUERY - 452))
        | (1ULL << (MySQLStatementParser::QUICK - 452))
        | (1ULL << (MySQLStatementParser::RANDOM - 452))
        | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
        | (1ULL << (MySQLStatementParser::REBUILD - 452))
        | (1ULL << (MySQLStatementParser::RECOVER - 452))
        | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
        | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
        | (1ULL << (MySQLStatementParser::REFERENCE - 452))
        | (1ULL << (MySQLStatementParser::RELAY - 452))
        | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
        | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
        | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
        | (1ULL << (MySQLStatementParser::RELOAD - 452))
        | (1ULL << (MySQLStatementParser::REMOVE - 452))
        | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
        | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
        | (1ULL << (MySQLStatementParser::REPLICATION - 517))
        | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RESET - 517))
        | (1ULL << (MySQLStatementParser::RESOURCE - 517))
        | (1ULL << (MySQLStatementParser::RESPECT - 517))
        | (1ULL << (MySQLStatementParser::RESTART - 517))
        | (1ULL << (MySQLStatementParser::RESTORE - 517))
        | (1ULL << (MySQLStatementParser::RESUME - 517))
        | (1ULL << (MySQLStatementParser::RETAIN - 517))
        | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
        | (1ULL << (MySQLStatementParser::RETURNING - 517))
        | (1ULL << (MySQLStatementParser::RETURNS - 517))
        | (1ULL << (MySQLStatementParser::REUSE - 517))
        | (1ULL << (MySQLStatementParser::REVERSE - 517))
        | (1ULL << (MySQLStatementParser::ROLE - 517))
        | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
        | (1ULL << (MySQLStatementParser::ROLLUP - 517))
        | (1ULL << (MySQLStatementParser::ROTATE - 517))
        | (1ULL << (MySQLStatementParser::ROUTINE - 517))
        | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
        | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
        | (1ULL << (MySQLStatementParser::RTREE - 517))
        | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
        | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
        | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
        | (1ULL << (MySQLStatementParser::SECOND - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
        | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
        | (1ULL << (MySQLStatementParser::SECURITY - 517))
        | (1ULL << (MySQLStatementParser::SERIAL - 517))
        | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
        | (1ULL << (MySQLStatementParser::SERVER - 517))
        | (1ULL << (MySQLStatementParser::SESSION - 517))
        | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
        | (1ULL << (MySQLStatementParser::SIGNED - 581))
        | (1ULL << (MySQLStatementParser::SIMPLE - 581))
        | (1ULL << (MySQLStatementParser::SLAVE - 581))
        | (1ULL << (MySQLStatementParser::SLOW - 581))
        | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
        | (1ULL << (MySQLStatementParser::SOCKET - 581))
        | (1ULL << (MySQLStatementParser::SOME - 581))
        | (1ULL << (MySQLStatementParser::SONAME - 581))
        | (1ULL << (MySQLStatementParser::SOUNDS - 581))
        | (1ULL << (MySQLStatementParser::SOURCE - 581))
        | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
        | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
        | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
        | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
        | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
        | (1ULL << (MySQLStatementParser::SRID - 581))
        | (1ULL << (MySQLStatementParser::STACKED - 581))
        | (1ULL << (MySQLStatementParser::START - 581))
        | (1ULL << (MySQLStatementParser::STARTS - 581))
        | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
        | (1ULL << (MySQLStatementParser::STATUS - 581))
        | (1ULL << (MySQLStatementParser::STOP - 581))
        | (1ULL << (MySQLStatementParser::STORAGE - 581))
        | (1ULL << (MySQLStatementParser::STREAM - 581))
        | (1ULL << (MySQLStatementParser::STRING - 581))
        | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
        | (1ULL << (MySQLStatementParser::SUBJECT - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
        | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
        | (1ULL << (MySQLStatementParser::SUPER - 581))
        | (1ULL << (MySQLStatementParser::SUSPEND - 581))
        | (1ULL << (MySQLStatementParser::SWAPS - 581))
        | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
        | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
        | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
        | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
        | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
        | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
        | (1ULL << (MySQLStatementParser::TEXT - 645))
        | (1ULL << (MySQLStatementParser::THAN - 645))
        | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
        | (1ULL << (MySQLStatementParser::TIES - 645))
        | (1ULL << (MySQLStatementParser::TIME - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
        | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
        | (1ULL << (MySQLStatementParser::TLS - 645))
        | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
        | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
        | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
        | (1ULL << (MySQLStatementParser::TYPE - 645))
        | (1ULL << (MySQLStatementParser::TYPES - 645))
        | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
        | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
        | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
        | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
        | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
        | (1ULL << (MySQLStatementParser::UNICODE - 645))
        | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
        | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
        | (1ULL << (MySQLStatementParser::UNTIL - 645))
        | (1ULL << (MySQLStatementParser::UPGRADE - 645))
        | (1ULL << (MySQLStatementParser::USER - 645))
        | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
        | (1ULL << (MySQLStatementParser::USE_FRM - 645))
        | (1ULL << (MySQLStatementParser::VALIDATION - 645))
        | (1ULL << (MySQLStatementParser::VALUE - 645))
        | (1ULL << (MySQLStatementParser::VARIABLES - 645))
        | (1ULL << (MySQLStatementParser::VCPU - 645))
        | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
        | (1ULL << (MySQLStatementParser::WAIT - 710))
        | (1ULL << (MySQLStatementParser::WARNINGS - 710))
        | (1ULL << (MySQLStatementParser::WEEK - 710))
        | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
        | (1ULL << (MySQLStatementParser::WITHOUT - 710))
        | (1ULL << (MySQLStatementParser::WORK - 710))
        | (1ULL << (MySQLStatementParser::WRAPPER - 710))
        | (1ULL << (MySQLStatementParser::X509 - 710))
        | (1ULL << (MySQLStatementParser::XA - 710))
        | (1ULL << (MySQLStatementParser::XID - 710))
        | (1ULL << (MySQLStatementParser::XML - 710))
        | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

      || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
        setState(2552);
        indexName();
      }
      setState(2555);
      keyParts();
      setState(2556);
      referenceDefinition();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2559);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::CONSTRAINT) {
        setState(2558);
        constraintName();
      }
      setState(2561);
      checkConstraint();
      setState(2563);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
      case 1: {
        setState(2562);
        constraintEnforcement();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierListContext ------------------------------------------------------------------

MySQLStatementParser::AlterCommandsModifierListContext::AlterCommandsModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::AlterCommandsModifierContext *> MySQLStatementParser::AlterCommandsModifierListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLStatementParser::AlterCommandsModifierContext>();
}

MySQLStatementParser::AlterCommandsModifierContext* MySQLStatementParser::AlterCommandsModifierListContext::alterCommandsModifier(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterCommandsModifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterCommandsModifierListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AlterCommandsModifierListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::AlterCommandsModifierListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterCommandsModifierList;
}

void MySQLStatementParser::AlterCommandsModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifierList(this);
}

void MySQLStatementParser::AlterCommandsModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifierList(this);
}


antlrcpp::Any MySQLStatementParser::AlterCommandsModifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterCommandsModifierList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterCommandsModifierListContext* MySQLStatementParser::alterCommandsModifierList() {
  AlterCommandsModifierListContext *_localctx = _tracker.createInstance<AlterCommandsModifierListContext>(_ctx, getState());
  enterRule(_localctx, 208, MySQLStatementParser::RuleAlterCommandsModifierList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2567);
    alterCommandsModifier();
    setState(2572);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2568);
        match(MySQLStatementParser::COMMA_);
        setState(2569);
        alterCommandsModifier(); 
      }
      setState(2574);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierContext ------------------------------------------------------------------

MySQLStatementParser::AlterCommandsModifierContext::AlterCommandsModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::AlterAlgorithmOptionContext* MySQLStatementParser::AlterCommandsModifierContext::alterAlgorithmOption() {
  return getRuleContext<MySQLStatementParser::AlterAlgorithmOptionContext>(0);
}

MySQLStatementParser::AlterLockOptionContext* MySQLStatementParser::AlterCommandsModifierContext::alterLockOption() {
  return getRuleContext<MySQLStatementParser::AlterLockOptionContext>(0);
}

MySQLStatementParser::WithValidationContext* MySQLStatementParser::AlterCommandsModifierContext::withValidation() {
  return getRuleContext<MySQLStatementParser::WithValidationContext>(0);
}


size_t MySQLStatementParser::AlterCommandsModifierContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterCommandsModifier;
}

void MySQLStatementParser::AlterCommandsModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifier(this);
}

void MySQLStatementParser::AlterCommandsModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifier(this);
}


antlrcpp::Any MySQLStatementParser::AlterCommandsModifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterCommandsModifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterCommandsModifierContext* MySQLStatementParser::alterCommandsModifier() {
  AlterCommandsModifierContext *_localctx = _tracker.createInstance<AlterCommandsModifierContext>(_ctx, getState());
  enterRule(_localctx, 210, MySQLStatementParser::RuleAlterCommandsModifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2578);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ALGORITHM: {
        enterOuterAlt(_localctx, 1);
        setState(2575);
        alterAlgorithmOption();
        break;
      }

      case MySQLStatementParser::LOCK: {
        enterOuterAlt(_localctx, 2);
        setState(2576);
        alterLockOption();
        break;
      }

      case MySQLStatementParser::WITH:
      case MySQLStatementParser::WITHOUT: {
        enterOuterAlt(_localctx, 3);
        setState(2577);
        withValidation();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithValidationContext ------------------------------------------------------------------

MySQLStatementParser::WithValidationContext::WithValidationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WithValidationContext::VALIDATION() {
  return getToken(MySQLStatementParser::VALIDATION, 0);
}

tree::TerminalNode* MySQLStatementParser::WithValidationContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::WithValidationContext::WITHOUT() {
  return getToken(MySQLStatementParser::WITHOUT, 0);
}


size_t MySQLStatementParser::WithValidationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWithValidation;
}

void MySQLStatementParser::WithValidationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithValidation(this);
}

void MySQLStatementParser::WithValidationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithValidation(this);
}


antlrcpp::Any MySQLStatementParser::WithValidationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWithValidation(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WithValidationContext* MySQLStatementParser::withValidation() {
  WithValidationContext *_localctx = _tracker.createInstance<WithValidationContext>(_ctx, getState());
  enterRule(_localctx, 212, MySQLStatementParser::RuleWithValidation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2580);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::WITH

    || _la == MySQLStatementParser::WITHOUT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2581);
    match(MySQLStatementParser::VALIDATION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandaloneAlterCommandsContext ------------------------------------------------------------------

MySQLStatementParser::StandaloneAlterCommandsContext::StandaloneAlterCommandsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StandaloneAlterCommandsContext::DISCARD() {
  return getToken(MySQLStatementParser::DISCARD, 0);
}

tree::TerminalNode* MySQLStatementParser::StandaloneAlterCommandsContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

tree::TerminalNode* MySQLStatementParser::StandaloneAlterCommandsContext::IMPORT() {
  return getToken(MySQLStatementParser::IMPORT, 0);
}

MySQLStatementParser::AlterPartitionContext* MySQLStatementParser::StandaloneAlterCommandsContext::alterPartition() {
  return getRuleContext<MySQLStatementParser::AlterPartitionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::StandaloneAlterCommandsContext::SECONDARY_LOAD() {
  return getToken(MySQLStatementParser::SECONDARY_LOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::StandaloneAlterCommandsContext::SECONDARY_UNLOAD() {
  return getToken(MySQLStatementParser::SECONDARY_UNLOAD, 0);
}


size_t MySQLStatementParser::StandaloneAlterCommandsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStandaloneAlterCommands;
}

void MySQLStatementParser::StandaloneAlterCommandsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandaloneAlterCommands(this);
}

void MySQLStatementParser::StandaloneAlterCommandsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandaloneAlterCommands(this);
}


antlrcpp::Any MySQLStatementParser::StandaloneAlterCommandsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStandaloneAlterCommands(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StandaloneAlterCommandsContext* MySQLStatementParser::standaloneAlterCommands() {
  StandaloneAlterCommandsContext *_localctx = _tracker.createInstance<StandaloneAlterCommandsContext>(_ctx, getState());
  enterRule(_localctx, 214, MySQLStatementParser::RuleStandaloneAlterCommands);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2589);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2583);
      match(MySQLStatementParser::DISCARD);
      setState(2584);
      match(MySQLStatementParser::TABLESPACE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2585);
      match(MySQLStatementParser::IMPORT);
      setState(2586);
      match(MySQLStatementParser::TABLESPACE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2587);
      alterPartition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2588);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::SECONDARY_LOAD

      || _la == MySQLStatementParser::SECONDARY_UNLOAD)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterPartitionContext ------------------------------------------------------------------

MySQLStatementParser::AlterPartitionContext::AlterPartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::PARTITION() {
  return getToken(MySQLStatementParser::PARTITION, 0);
}

MySQLStatementParser::PartitionDefinitionsContext* MySQLStatementParser::AlterPartitionContext::partitionDefinitions() {
  return getRuleContext<MySQLStatementParser::PartitionDefinitionsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::PARTITIONS() {
  return getToken(MySQLStatementParser::PARTITIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

std::vector<MySQLStatementParser::NoWriteToBinLogContext *> MySQLStatementParser::AlterPartitionContext::noWriteToBinLog() {
  return getRuleContexts<MySQLStatementParser::NoWriteToBinLogContext>();
}

MySQLStatementParser::NoWriteToBinLogContext* MySQLStatementParser::AlterPartitionContext::noWriteToBinLog(size_t i) {
  return getRuleContext<MySQLStatementParser::NoWriteToBinLogContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

MySQLStatementParser::IdentifierListContext* MySQLStatementParser::AlterPartitionContext::identifierList() {
  return getRuleContext<MySQLStatementParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::REBUILD() {
  return getToken(MySQLStatementParser::REBUILD, 0);
}

MySQLStatementParser::AllOrPartitionNameListContext* MySQLStatementParser::AlterPartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLStatementParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::OPTIMIZE() {
  return getToken(MySQLStatementParser::OPTIMIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::ANALYZE() {
  return getToken(MySQLStatementParser::ANALYZE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::CHECK() {
  return getToken(MySQLStatementParser::CHECK, 0);
}

std::vector<MySQLStatementParser::CheckTypeContext *> MySQLStatementParser::AlterPartitionContext::checkType() {
  return getRuleContexts<MySQLStatementParser::CheckTypeContext>();
}

MySQLStatementParser::CheckTypeContext* MySQLStatementParser::AlterPartitionContext::checkType(size_t i) {
  return getRuleContext<MySQLStatementParser::CheckTypeContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::REPAIR() {
  return getToken(MySQLStatementParser::REPAIR, 0);
}

std::vector<MySQLStatementParser::RepairTypeContext *> MySQLStatementParser::AlterPartitionContext::repairType() {
  return getRuleContexts<MySQLStatementParser::RepairTypeContext>();
}

MySQLStatementParser::RepairTypeContext* MySQLStatementParser::AlterPartitionContext::repairType(size_t i) {
  return getRuleContext<MySQLStatementParser::RepairTypeContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::COALESCE() {
  return getToken(MySQLStatementParser::COALESCE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::TRUNCATE() {
  return getToken(MySQLStatementParser::TRUNCATE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::REORGANIZE() {
  return getToken(MySQLStatementParser::REORGANIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::EXCHANGE() {
  return getToken(MySQLStatementParser::EXCHANGE, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterPartitionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::AlterPartitionContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::WithValidationContext* MySQLStatementParser::AlterPartitionContext::withValidation() {
  return getRuleContext<MySQLStatementParser::WithValidationContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::DISCARD() {
  return getToken(MySQLStatementParser::DISCARD, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterPartitionContext::IMPORT() {
  return getToken(MySQLStatementParser::IMPORT, 0);
}


size_t MySQLStatementParser::AlterPartitionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterPartition;
}

void MySQLStatementParser::AlterPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterPartition(this);
}

void MySQLStatementParser::AlterPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterPartition(this);
}


antlrcpp::Any MySQLStatementParser::AlterPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterPartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterPartitionContext* MySQLStatementParser::alterPartition() {
  AlterPartitionContext *_localctx = _tracker.createInstance<AlterPartitionContext>(_ctx, getState());
  enterRule(_localctx, 216, MySQLStatementParser::RuleAlterPartition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2685);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ADD: {
        enterOuterAlt(_localctx, 1);
        setState(2591);
        match(MySQLStatementParser::ADD);
        setState(2592);
        match(MySQLStatementParser::PARTITION);
        setState(2594);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG) {
          setState(2593);
          noWriteToBinLog();
        }
        setState(2599);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLStatementParser::LP_: {
            setState(2596);
            partitionDefinitions();
            break;
          }

          case MySQLStatementParser::PARTITIONS: {
            setState(2597);
            match(MySQLStatementParser::PARTITIONS);
            setState(2598);
            match(MySQLStatementParser::NUMBER_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySQLStatementParser::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(2601);
        match(MySQLStatementParser::DROP);
        setState(2602);
        match(MySQLStatementParser::PARTITION);
        setState(2603);
        identifierList();
        break;
      }

      case MySQLStatementParser::REBUILD: {
        enterOuterAlt(_localctx, 3);
        setState(2604);
        match(MySQLStatementParser::REBUILD);
        setState(2605);
        match(MySQLStatementParser::PARTITION);
        setState(2607);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
        case 1: {
          setState(2606);
          noWriteToBinLog();
          break;
        }

        }
        setState(2609);
        allOrPartitionNameList();
        break;
      }

      case MySQLStatementParser::OPTIMIZE: {
        enterOuterAlt(_localctx, 4);
        setState(2610);
        match(MySQLStatementParser::OPTIMIZE);
        setState(2611);
        match(MySQLStatementParser::PARTITION);
        setState(2613);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
        case 1: {
          setState(2612);
          noWriteToBinLog();
          break;
        }

        }
        setState(2615);
        allOrPartitionNameList();
        setState(2617);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
        case 1: {
          setState(2616);
          noWriteToBinLog();
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::ANALYZE: {
        enterOuterAlt(_localctx, 5);
        setState(2619);
        match(MySQLStatementParser::ANALYZE);
        setState(2620);
        match(MySQLStatementParser::PARTITION);
        setState(2622);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, _ctx)) {
        case 1: {
          setState(2621);
          noWriteToBinLog();
          break;
        }

        }
        setState(2624);
        allOrPartitionNameList();
        break;
      }

      case MySQLStatementParser::CHECK: {
        enterOuterAlt(_localctx, 6);
        setState(2625);
        match(MySQLStatementParser::CHECK);
        setState(2626);
        match(MySQLStatementParser::PARTITION);
        setState(2627);
        allOrPartitionNameList();
        setState(2631);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2628);
            checkType(); 
          }
          setState(2633);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx);
        }
        break;
      }

      case MySQLStatementParser::REPAIR: {
        enterOuterAlt(_localctx, 7);
        setState(2634);
        match(MySQLStatementParser::REPAIR);
        setState(2635);
        match(MySQLStatementParser::PARTITION);
        setState(2637);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
        case 1: {
          setState(2636);
          noWriteToBinLog();
          break;
        }

        }
        setState(2639);
        allOrPartitionNameList();
        setState(2643);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2640);
            repairType(); 
          }
          setState(2645);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx);
        }
        break;
      }

      case MySQLStatementParser::COALESCE: {
        enterOuterAlt(_localctx, 8);
        setState(2646);
        match(MySQLStatementParser::COALESCE);
        setState(2647);
        match(MySQLStatementParser::PARTITION);
        setState(2649);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG) {
          setState(2648);
          noWriteToBinLog();
        }
        setState(2651);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::TRUNCATE: {
        enterOuterAlt(_localctx, 9);
        setState(2652);
        match(MySQLStatementParser::TRUNCATE);
        setState(2653);
        match(MySQLStatementParser::PARTITION);
        setState(2654);
        allOrPartitionNameList();
        break;
      }

      case MySQLStatementParser::REORGANIZE: {
        enterOuterAlt(_localctx, 10);
        setState(2655);
        match(MySQLStatementParser::REORGANIZE);
        setState(2656);
        match(MySQLStatementParser::PARTITION);
        setState(2658);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
        case 1: {
          setState(2657);
          noWriteToBinLog();
          break;
        }

        }
        setState(2664);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
        case 1: {
          setState(2660);
          identifierList();
          setState(2661);
          match(MySQLStatementParser::INTO);
          setState(2662);
          partitionDefinitions();
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::EXCHANGE: {
        enterOuterAlt(_localctx, 11);
        setState(2666);
        match(MySQLStatementParser::EXCHANGE);
        setState(2667);
        match(MySQLStatementParser::PARTITION);
        setState(2668);
        identifier();
        setState(2669);
        match(MySQLStatementParser::WITH);
        setState(2670);
        match(MySQLStatementParser::TABLE);
        setState(2671);
        tableName();
        setState(2673);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
        case 1: {
          setState(2672);
          withValidation();
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::DISCARD: {
        enterOuterAlt(_localctx, 12);
        setState(2675);
        match(MySQLStatementParser::DISCARD);
        setState(2676);
        match(MySQLStatementParser::PARTITION);
        setState(2677);
        allOrPartitionNameList();
        setState(2678);
        match(MySQLStatementParser::TABLESPACE);
        break;
      }

      case MySQLStatementParser::IMPORT: {
        enterOuterAlt(_localctx, 13);
        setState(2680);
        match(MySQLStatementParser::IMPORT);
        setState(2681);
        match(MySQLStatementParser::PARTITION);
        setState(2682);
        allOrPartitionNameList();
        setState(2683);
        match(MySQLStatementParser::TABLESPACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintNameContext ------------------------------------------------------------------

MySQLStatementParser::ConstraintNameContext::ConstraintNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConstraintNameContext::CONSTRAINT() {
  return getToken(MySQLStatementParser::CONSTRAINT, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ConstraintNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::ConstraintNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConstraintName;
}

void MySQLStatementParser::ConstraintNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintName(this);
}

void MySQLStatementParser::ConstraintNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintName(this);
}


antlrcpp::Any MySQLStatementParser::ConstraintNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConstraintName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConstraintNameContext* MySQLStatementParser::constraintName() {
  ConstraintNameContext *_localctx = _tracker.createInstance<ConstraintNameContext>(_ctx, getState());
  enterRule(_localctx, 218, MySQLStatementParser::RuleConstraintName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2687);
    match(MySQLStatementParser::CONSTRAINT);
    setState(2689);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(2688);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementListContext ------------------------------------------------------------------

MySQLStatementParser::TableElementListContext::TableElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::TableElementContext *> MySQLStatementParser::TableElementListContext::tableElement() {
  return getRuleContexts<MySQLStatementParser::TableElementContext>();
}

MySQLStatementParser::TableElementContext* MySQLStatementParser::TableElementListContext::tableElement(size_t i) {
  return getRuleContext<MySQLStatementParser::TableElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableElementListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::TableElementListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::TableElementListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableElementList;
}

void MySQLStatementParser::TableElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElementList(this);
}

void MySQLStatementParser::TableElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElementList(this);
}


antlrcpp::Any MySQLStatementParser::TableElementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableElementList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableElementListContext* MySQLStatementParser::tableElementList() {
  TableElementListContext *_localctx = _tracker.createInstance<TableElementListContext>(_ctx, getState());
  enterRule(_localctx, 220, MySQLStatementParser::RuleTableElementList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2691);
    tableElement();
    setState(2696);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(2692);
      match(MySQLStatementParser::COMMA_);
      setState(2693);
      tableElement();
      setState(2698);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementContext ------------------------------------------------------------------

MySQLStatementParser::TableElementContext::TableElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ColumnDefinitionContext* MySQLStatementParser::TableElementContext::columnDefinition() {
  return getRuleContext<MySQLStatementParser::ColumnDefinitionContext>(0);
}

MySQLStatementParser::TableConstraintDefContext* MySQLStatementParser::TableElementContext::tableConstraintDef() {
  return getRuleContext<MySQLStatementParser::TableConstraintDefContext>(0);
}


size_t MySQLStatementParser::TableElementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableElement;
}

void MySQLStatementParser::TableElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElement(this);
}

void MySQLStatementParser::TableElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElement(this);
}


antlrcpp::Any MySQLStatementParser::TableElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableElementContext* MySQLStatementParser::tableElement() {
  TableElementContext *_localctx = _tracker.createInstance<TableElementContext>(_ctx, getState());
  enterRule(_localctx, 222, MySQLStatementParser::RuleTableElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2701);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(2699);
        columnDefinition();
        break;
      }

      case MySQLStatementParser::CHECK:
      case MySQLStatementParser::CONSTRAINT:
      case MySQLStatementParser::FOREIGN:
      case MySQLStatementParser::FULLTEXT:
      case MySQLStatementParser::INDEX:
      case MySQLStatementParser::KEY:
      case MySQLStatementParser::PRIMARY:
      case MySQLStatementParser::SPATIAL:
      case MySQLStatementParser::UNIQUE: {
        enterOuterAlt(_localctx, 2);
        setState(2700);
        tableConstraintDef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestrictContext ------------------------------------------------------------------

MySQLStatementParser::RestrictContext::RestrictContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RestrictContext::RESTRICT() {
  return getToken(MySQLStatementParser::RESTRICT, 0);
}

tree::TerminalNode* MySQLStatementParser::RestrictContext::CASCADE() {
  return getToken(MySQLStatementParser::CASCADE, 0);
}


size_t MySQLStatementParser::RestrictContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRestrict;
}

void MySQLStatementParser::RestrictContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestrict(this);
}

void MySQLStatementParser::RestrictContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestrict(this);
}


antlrcpp::Any MySQLStatementParser::RestrictContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRestrict(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RestrictContext* MySQLStatementParser::restrict() {
  RestrictContext *_localctx = _tracker.createInstance<RestrictContext>(_ctx, getState());
  enterRule(_localctx, 224, MySQLStatementParser::RuleRestrict);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2703);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::CASCADE || _la == MySQLStatementParser::RESTRICT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FulltextIndexOptionContext ------------------------------------------------------------------

MySQLStatementParser::FulltextIndexOptionContext::FulltextIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CommonIndexOptionContext* MySQLStatementParser::FulltextIndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLStatementParser::CommonIndexOptionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FulltextIndexOptionContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::FulltextIndexOptionContext::PARSER() {
  return getToken(MySQLStatementParser::PARSER, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::FulltextIndexOptionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::FulltextIndexOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFulltextIndexOption;
}

void MySQLStatementParser::FulltextIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFulltextIndexOption(this);
}

void MySQLStatementParser::FulltextIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFulltextIndexOption(this);
}


antlrcpp::Any MySQLStatementParser::FulltextIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFulltextIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FulltextIndexOptionContext* MySQLStatementParser::fulltextIndexOption() {
  FulltextIndexOptionContext *_localctx = _tracker.createInstance<FulltextIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 226, MySQLStatementParser::RuleFulltextIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2709);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::VISIBLE: {
        enterOuterAlt(_localctx, 1);
        setState(2705);
        commonIndexOption();
        break;
      }

      case MySQLStatementParser::WITH: {
        enterOuterAlt(_localctx, 2);
        setState(2706);
        match(MySQLStatementParser::WITH);
        setState(2707);
        match(MySQLStatementParser::PARSER);
        setState(2708);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableContext ------------------------------------------------------------------

MySQLStatementParser::DropTableContext::DropTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropTableContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

MySQLStatementParser::TableOrTablesContext* MySQLStatementParser::DropTableContext::tableOrTables() {
  return getRuleContext<MySQLStatementParser::TableOrTablesContext>(0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::DropTableContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DropTableContext::TEMPORARY() {
  return getToken(MySQLStatementParser::TEMPORARY, 0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropTableContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}

MySQLStatementParser::RestrictContext* MySQLStatementParser::DropTableContext::restrict() {
  return getRuleContext<MySQLStatementParser::RestrictContext>(0);
}


size_t MySQLStatementParser::DropTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropTable;
}

void MySQLStatementParser::DropTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTable(this);
}

void MySQLStatementParser::DropTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTable(this);
}


antlrcpp::Any MySQLStatementParser::DropTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropTableContext* MySQLStatementParser::dropTable() {
  DropTableContext *_localctx = _tracker.createInstance<DropTableContext>(_ctx, getState());
  enterRule(_localctx, 228, MySQLStatementParser::RuleDropTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2711);
    match(MySQLStatementParser::DROP);
    setState(2713);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::TEMPORARY) {
      setState(2712);
      match(MySQLStatementParser::TEMPORARY);
    }
    setState(2715);
    tableOrTables();
    setState(2717);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(2716);
      existClause();
    }
    setState(2719);
    tableList();
    setState(2721);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CASCADE || _la == MySQLStatementParser::RESTRICT) {
      setState(2720);
      restrict();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropIndexContext ------------------------------------------------------------------

MySQLStatementParser::DropIndexContext::DropIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropIndexContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropIndexContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::DropIndexContext::indexName() {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DropIndexContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::DropIndexContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

std::vector<MySQLStatementParser::AlterAlgorithmOptionContext *> MySQLStatementParser::DropIndexContext::alterAlgorithmOption() {
  return getRuleContexts<MySQLStatementParser::AlterAlgorithmOptionContext>();
}

MySQLStatementParser::AlterAlgorithmOptionContext* MySQLStatementParser::DropIndexContext::alterAlgorithmOption(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterAlgorithmOptionContext>(i);
}

std::vector<MySQLStatementParser::AlterLockOptionContext *> MySQLStatementParser::DropIndexContext::alterLockOption() {
  return getRuleContexts<MySQLStatementParser::AlterLockOptionContext>();
}

MySQLStatementParser::AlterLockOptionContext* MySQLStatementParser::DropIndexContext::alterLockOption(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterLockOptionContext>(i);
}


size_t MySQLStatementParser::DropIndexContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropIndex;
}

void MySQLStatementParser::DropIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropIndex(this);
}

void MySQLStatementParser::DropIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropIndex(this);
}


antlrcpp::Any MySQLStatementParser::DropIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropIndexContext* MySQLStatementParser::dropIndex() {
  DropIndexContext *_localctx = _tracker.createInstance<DropIndexContext>(_ctx, getState());
  enterRule(_localctx, 230, MySQLStatementParser::RuleDropIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2723);
    match(MySQLStatementParser::DROP);
    setState(2724);
    match(MySQLStatementParser::INDEX);
    setState(2725);
    indexName();
    setState(2728);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ON) {
      setState(2726);
      match(MySQLStatementParser::ON);
      setState(2727);
      tableName();
    }
    setState(2734);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::ALGORITHM || _la == MySQLStatementParser::LOCK) {
      setState(2732);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::ALGORITHM: {
          setState(2730);
          alterAlgorithmOption();
          break;
        }

        case MySQLStatementParser::LOCK: {
          setState(2731);
          alterLockOption();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2736);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterAlgorithmOptionContext ------------------------------------------------------------------

MySQLStatementParser::AlterAlgorithmOptionContext::AlterAlgorithmOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterAlgorithmOptionContext::ALGORITHM() {
  return getToken(MySQLStatementParser::ALGORITHM, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterAlgorithmOptionContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterAlgorithmOptionContext::INSTANT() {
  return getToken(MySQLStatementParser::INSTANT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterAlgorithmOptionContext::INPLACE() {
  return getToken(MySQLStatementParser::INPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterAlgorithmOptionContext::COPY() {
  return getToken(MySQLStatementParser::COPY, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterAlgorithmOptionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::AlterAlgorithmOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterAlgorithmOption;
}

void MySQLStatementParser::AlterAlgorithmOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterAlgorithmOption(this);
}

void MySQLStatementParser::AlterAlgorithmOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterAlgorithmOption(this);
}


antlrcpp::Any MySQLStatementParser::AlterAlgorithmOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterAlgorithmOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterAlgorithmOptionContext* MySQLStatementParser::alterAlgorithmOption() {
  AlterAlgorithmOptionContext *_localctx = _tracker.createInstance<AlterAlgorithmOptionContext>(_ctx, getState());
  enterRule(_localctx, 232, MySQLStatementParser::RuleAlterAlgorithmOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2737);
    match(MySQLStatementParser::ALGORITHM);
    setState(2739);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EQ_) {
      setState(2738);
      match(MySQLStatementParser::EQ_);
    }
    setState(2741);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY))) != 0) || _la == MySQLStatementParser::DEFAULT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLockOptionContext ------------------------------------------------------------------

MySQLStatementParser::AlterLockOptionContext::AlterLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterLockOptionContext::LOCK() {
  return getToken(MySQLStatementParser::LOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLockOptionContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLockOptionContext::NONE() {
  return getToken(MySQLStatementParser::NONE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLockOptionContext::M_SHARED() {
  return getToken(MySQLStatementParser::M_SHARED, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLockOptionContext::M_EXCLUSIVE() {
  return getToken(MySQLStatementParser::M_EXCLUSIVE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLockOptionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::AlterLockOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterLockOption;
}

void MySQLStatementParser::AlterLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLockOption(this);
}

void MySQLStatementParser::AlterLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLockOption(this);
}


antlrcpp::Any MySQLStatementParser::AlterLockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterLockOptionContext* MySQLStatementParser::alterLockOption() {
  AlterLockOptionContext *_localctx = _tracker.createInstance<AlterLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 234, MySQLStatementParser::RuleAlterLockOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2743);
    match(MySQLStatementParser::LOCK);
    setState(2745);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EQ_) {
      setState(2744);
      match(MySQLStatementParser::EQ_);
    }
    setState(2747);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DEFAULT || _la == MySQLStatementParser::NONE || _la == MySQLStatementParser::M_SHARED

    || _la == MySQLStatementParser::M_EXCLUSIVE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TruncateTableContext ------------------------------------------------------------------

MySQLStatementParser::TruncateTableContext::TruncateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TruncateTableContext::TRUNCATE() {
  return getToken(MySQLStatementParser::TRUNCATE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::TruncateTableContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TruncateTableContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}


size_t MySQLStatementParser::TruncateTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTruncateTable;
}

void MySQLStatementParser::TruncateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncateTable(this);
}

void MySQLStatementParser::TruncateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncateTable(this);
}


antlrcpp::Any MySQLStatementParser::TruncateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTruncateTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TruncateTableContext* MySQLStatementParser::truncateTable() {
  TruncateTableContext *_localctx = _tracker.createInstance<TruncateTableContext>(_ctx, getState());
  enterRule(_localctx, 236, MySQLStatementParser::RuleTruncateTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2749);
    match(MySQLStatementParser::TRUNCATE);
    setState(2751);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::TABLE) {
      setState(2750);
      match(MySQLStatementParser::TABLE);
    }
    setState(2753);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexContext ------------------------------------------------------------------

MySQLStatementParser::CreateIndexContext::CreateIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateIndexContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateIndexContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::CreateIndexContext::indexName() {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateIndexContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::CreateIndexContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::KeyListWithExpressionContext* MySQLStatementParser::CreateIndexContext::keyListWithExpression() {
  return getRuleContext<MySQLStatementParser::KeyListWithExpressionContext>(0);
}

MySQLStatementParser::CreateIndexSpecificationContext* MySQLStatementParser::CreateIndexContext::createIndexSpecification() {
  return getRuleContext<MySQLStatementParser::CreateIndexSpecificationContext>(0);
}

MySQLStatementParser::IndexTypeClauseContext* MySQLStatementParser::CreateIndexContext::indexTypeClause() {
  return getRuleContext<MySQLStatementParser::IndexTypeClauseContext>(0);
}

MySQLStatementParser::IndexOptionContext* MySQLStatementParser::CreateIndexContext::indexOption() {
  return getRuleContext<MySQLStatementParser::IndexOptionContext>(0);
}

std::vector<MySQLStatementParser::AlterAlgorithmOptionContext *> MySQLStatementParser::CreateIndexContext::alterAlgorithmOption() {
  return getRuleContexts<MySQLStatementParser::AlterAlgorithmOptionContext>();
}

MySQLStatementParser::AlterAlgorithmOptionContext* MySQLStatementParser::CreateIndexContext::alterAlgorithmOption(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterAlgorithmOptionContext>(i);
}

std::vector<MySQLStatementParser::AlterLockOptionContext *> MySQLStatementParser::CreateIndexContext::alterLockOption() {
  return getRuleContexts<MySQLStatementParser::AlterLockOptionContext>();
}

MySQLStatementParser::AlterLockOptionContext* MySQLStatementParser::CreateIndexContext::alterLockOption(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterLockOptionContext>(i);
}


size_t MySQLStatementParser::CreateIndexContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateIndex;
}

void MySQLStatementParser::CreateIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndex(this);
}

void MySQLStatementParser::CreateIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndex(this);
}


antlrcpp::Any MySQLStatementParser::CreateIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateIndexContext* MySQLStatementParser::createIndex() {
  CreateIndexContext *_localctx = _tracker.createInstance<CreateIndexContext>(_ctx, getState());
  enterRule(_localctx, 238, MySQLStatementParser::RuleCreateIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2755);
    match(MySQLStatementParser::CREATE);
    setState(2757);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FULLTEXT || _la == MySQLStatementParser::SPATIAL || _la == MySQLStatementParser::UNIQUE) {
      setState(2756);
      createIndexSpecification();
    }
    setState(2759);
    match(MySQLStatementParser::INDEX);
    setState(2760);
    indexName();
    setState(2762);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::TYPE

    || _la == MySQLStatementParser::USING) {
      setState(2761);
      indexTypeClause();
    }
    setState(2764);
    match(MySQLStatementParser::ON);
    setState(2765);
    tableName();
    setState(2766);
    keyListWithExpression();
    setState(2768);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COMMENT || _la == MySQLStatementParser::INVISIBLE

    || _la == MySQLStatementParser::KEY_BLOCK_SIZE || ((((_la - 672) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 672)) & ((1ULL << (MySQLStatementParser::TYPE - 672))
      | (1ULL << (MySQLStatementParser::USING - 672))
      | (1ULL << (MySQLStatementParser::VISIBLE - 672)))) != 0)) {
      setState(2767);
      indexOption();
    }
    setState(2774);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::ALGORITHM || _la == MySQLStatementParser::LOCK) {
      setState(2772);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::ALGORITHM: {
          setState(2770);
          alterAlgorithmOption();
          break;
        }

        case MySQLStatementParser::LOCK: {
          setState(2771);
          alterLockOption();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2776);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseContext ------------------------------------------------------------------

MySQLStatementParser::CreateDatabaseContext::CreateDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateDatabaseContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::CreateDatabaseContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateDatabaseContext::DATABASE() {
  return getToken(MySQLStatementParser::DATABASE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateDatabaseContext::SCHEMA() {
  return getToken(MySQLStatementParser::SCHEMA, 0);
}

MySQLStatementParser::NotExistClauseContext* MySQLStatementParser::CreateDatabaseContext::notExistClause() {
  return getRuleContext<MySQLStatementParser::NotExistClauseContext>(0);
}

std::vector<MySQLStatementParser::CreateDatabaseSpecification_Context *> MySQLStatementParser::CreateDatabaseContext::createDatabaseSpecification_() {
  return getRuleContexts<MySQLStatementParser::CreateDatabaseSpecification_Context>();
}

MySQLStatementParser::CreateDatabaseSpecification_Context* MySQLStatementParser::CreateDatabaseContext::createDatabaseSpecification_(size_t i) {
  return getRuleContext<MySQLStatementParser::CreateDatabaseSpecification_Context>(i);
}


size_t MySQLStatementParser::CreateDatabaseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateDatabase;
}

void MySQLStatementParser::CreateDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabase(this);
}

void MySQLStatementParser::CreateDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabase(this);
}


antlrcpp::Any MySQLStatementParser::CreateDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateDatabaseContext* MySQLStatementParser::createDatabase() {
  CreateDatabaseContext *_localctx = _tracker.createInstance<CreateDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 240, MySQLStatementParser::RuleCreateDatabase);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2777);
    match(MySQLStatementParser::CREATE);
    setState(2778);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DATABASE || _la == MySQLStatementParser::SCHEMA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2780);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(2779);
      notExistClause();
    }
    setState(2782);
    schemaName();
    setState(2786);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (MySQLStatementParser::CHAR - 79))
      | (1ULL << (MySQLStatementParser::CHARACTER - 79))
      | (1ULL << (MySQLStatementParser::CHARSET - 79))
      | (1ULL << (MySQLStatementParser::COLLATE - 79)))) != 0) || _la == MySQLStatementParser::DEFAULT

    || _la == MySQLStatementParser::ENCRYPTION) {
      setState(2783);
      createDatabaseSpecification_();
      setState(2788);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterDatabaseContext ------------------------------------------------------------------

MySQLStatementParser::AlterDatabaseContext::AlterDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseContext::DATABASE() {
  return getToken(MySQLStatementParser::DATABASE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseContext::SCHEMA() {
  return getToken(MySQLStatementParser::SCHEMA, 0);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::AlterDatabaseContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}

std::vector<MySQLStatementParser::AlterDatabaseSpecification_Context *> MySQLStatementParser::AlterDatabaseContext::alterDatabaseSpecification_() {
  return getRuleContexts<MySQLStatementParser::AlterDatabaseSpecification_Context>();
}

MySQLStatementParser::AlterDatabaseSpecification_Context* MySQLStatementParser::AlterDatabaseContext::alterDatabaseSpecification_(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterDatabaseSpecification_Context>(i);
}


size_t MySQLStatementParser::AlterDatabaseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterDatabase;
}

void MySQLStatementParser::AlterDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterDatabase(this);
}

void MySQLStatementParser::AlterDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterDatabase(this);
}


antlrcpp::Any MySQLStatementParser::AlterDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterDatabaseContext* MySQLStatementParser::alterDatabase() {
  AlterDatabaseContext *_localctx = _tracker.createInstance<AlterDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 242, MySQLStatementParser::RuleAlterDatabase);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2789);
    match(MySQLStatementParser::ALTER);
    setState(2790);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DATABASE || _la == MySQLStatementParser::SCHEMA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2792);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx)) {
    case 1: {
      setState(2791);
      schemaName();
      break;
    }

    }
    setState(2797);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (MySQLStatementParser::CHAR - 79))
      | (1ULL << (MySQLStatementParser::CHARACTER - 79))
      | (1ULL << (MySQLStatementParser::CHARSET - 79))
      | (1ULL << (MySQLStatementParser::COLLATE - 79)))) != 0) || _la == MySQLStatementParser::DEFAULT

    || _la == MySQLStatementParser::ENCRYPTION || _la == MySQLStatementParser::READ) {
      setState(2794);
      alterDatabaseSpecification_();
      setState(2799);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseSpecification_Context ------------------------------------------------------------------

MySQLStatementParser::CreateDatabaseSpecification_Context::CreateDatabaseSpecification_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::DefaultCharsetContext* MySQLStatementParser::CreateDatabaseSpecification_Context::defaultCharset() {
  return getRuleContext<MySQLStatementParser::DefaultCharsetContext>(0);
}

MySQLStatementParser::DefaultCollationContext* MySQLStatementParser::CreateDatabaseSpecification_Context::defaultCollation() {
  return getRuleContext<MySQLStatementParser::DefaultCollationContext>(0);
}

MySQLStatementParser::DefaultEncryptionContext* MySQLStatementParser::CreateDatabaseSpecification_Context::defaultEncryption() {
  return getRuleContext<MySQLStatementParser::DefaultEncryptionContext>(0);
}


size_t MySQLStatementParser::CreateDatabaseSpecification_Context::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateDatabaseSpecification_;
}

void MySQLStatementParser::CreateDatabaseSpecification_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabaseSpecification_(this);
}

void MySQLStatementParser::CreateDatabaseSpecification_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabaseSpecification_(this);
}


antlrcpp::Any MySQLStatementParser::CreateDatabaseSpecification_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateDatabaseSpecification_(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateDatabaseSpecification_Context* MySQLStatementParser::createDatabaseSpecification_() {
  CreateDatabaseSpecification_Context *_localctx = _tracker.createInstance<CreateDatabaseSpecification_Context>(_ctx, getState());
  enterRule(_localctx, 244, MySQLStatementParser::RuleCreateDatabaseSpecification_);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2800);
      defaultCharset();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2801);
      defaultCollation();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2802);
      defaultEncryption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterDatabaseSpecification_Context ------------------------------------------------------------------

MySQLStatementParser::AlterDatabaseSpecification_Context::AlterDatabaseSpecification_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CreateDatabaseSpecification_Context* MySQLStatementParser::AlterDatabaseSpecification_Context::createDatabaseSpecification_() {
  return getRuleContext<MySQLStatementParser::CreateDatabaseSpecification_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseSpecification_Context::READ() {
  return getToken(MySQLStatementParser::READ, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseSpecification_Context::ONLY() {
  return getToken(MySQLStatementParser::ONLY, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseSpecification_Context::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseSpecification_Context::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterDatabaseSpecification_Context::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::AlterDatabaseSpecification_Context::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterDatabaseSpecification_;
}

void MySQLStatementParser::AlterDatabaseSpecification_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterDatabaseSpecification_(this);
}

void MySQLStatementParser::AlterDatabaseSpecification_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterDatabaseSpecification_(this);
}


antlrcpp::Any MySQLStatementParser::AlterDatabaseSpecification_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterDatabaseSpecification_(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterDatabaseSpecification_Context* MySQLStatementParser::alterDatabaseSpecification_() {
  AlterDatabaseSpecification_Context *_localctx = _tracker.createInstance<AlterDatabaseSpecification_Context>(_ctx, getState());
  enterRule(_localctx, 246, MySQLStatementParser::RuleAlterDatabaseSpecification_);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2812);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARACTER:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::COLLATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::ENCRYPTION: {
        enterOuterAlt(_localctx, 1);
        setState(2805);
        createDatabaseSpecification_();
        break;
      }

      case MySQLStatementParser::READ: {
        enterOuterAlt(_localctx, 2);
        setState(2806);
        match(MySQLStatementParser::READ);
        setState(2807);
        match(MySQLStatementParser::ONLY);
        setState(2809);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(2808);
          match(MySQLStatementParser::EQ_);
        }
        setState(2811);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::DEFAULT || _la == MySQLStatementParser::NUMBER_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropDatabaseContext ------------------------------------------------------------------

MySQLStatementParser::DropDatabaseContext::DropDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropDatabaseContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::DropDatabaseContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DropDatabaseContext::DATABASE() {
  return getToken(MySQLStatementParser::DATABASE, 0);
}

tree::TerminalNode* MySQLStatementParser::DropDatabaseContext::SCHEMA() {
  return getToken(MySQLStatementParser::SCHEMA, 0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropDatabaseContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}


size_t MySQLStatementParser::DropDatabaseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropDatabase;
}

void MySQLStatementParser::DropDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropDatabase(this);
}

void MySQLStatementParser::DropDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropDatabase(this);
}


antlrcpp::Any MySQLStatementParser::DropDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropDatabaseContext* MySQLStatementParser::dropDatabase() {
  DropDatabaseContext *_localctx = _tracker.createInstance<DropDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 248, MySQLStatementParser::RuleDropDatabase);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2814);
    match(MySQLStatementParser::DROP);
    setState(2815);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DATABASE || _la == MySQLStatementParser::SCHEMA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2817);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(2816);
      existClause();
    }
    setState(2819);
    schemaName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterInstanceContext ------------------------------------------------------------------

MySQLStatementParser::AlterInstanceContext::AlterInstanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterInstanceContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterInstanceContext::INSTANCE() {
  return getToken(MySQLStatementParser::INSTANCE, 0);
}

MySQLStatementParser::InstanceActionContext* MySQLStatementParser::AlterInstanceContext::instanceAction() {
  return getRuleContext<MySQLStatementParser::InstanceActionContext>(0);
}


size_t MySQLStatementParser::AlterInstanceContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterInstance;
}

void MySQLStatementParser::AlterInstanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterInstance(this);
}

void MySQLStatementParser::AlterInstanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterInstance(this);
}


antlrcpp::Any MySQLStatementParser::AlterInstanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterInstance(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterInstanceContext* MySQLStatementParser::alterInstance() {
  AlterInstanceContext *_localctx = _tracker.createInstance<AlterInstanceContext>(_ctx, getState());
  enterRule(_localctx, 250, MySQLStatementParser::RuleAlterInstance);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2821);
    match(MySQLStatementParser::ALTER);
    setState(2822);
    match(MySQLStatementParser::INSTANCE);
    setState(2823);
    instanceAction();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstanceActionContext ------------------------------------------------------------------

MySQLStatementParser::InstanceActionContext::InstanceActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::INNODB() {
  return getToken(MySQLStatementParser::INNODB, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::REDO_LOG() {
  return getToken(MySQLStatementParser::REDO_LOG, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::ENABLE() {
  return getToken(MySQLStatementParser::ENABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::DISABLE() {
  return getToken(MySQLStatementParser::DISABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::ROTATE() {
  return getToken(MySQLStatementParser::ROTATE, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::MASTER() {
  return getToken(MySQLStatementParser::MASTER, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::BINLOG() {
  return getToken(MySQLStatementParser::BINLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::RELOAD() {
  return getToken(MySQLStatementParser::RELOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::TLS() {
  return getToken(MySQLStatementParser::TLS, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::CHANNEL() {
  return getToken(MySQLStatementParser::CHANNEL, 0);
}

MySQLStatementParser::ChannelContext* MySQLStatementParser::InstanceActionContext::channel() {
  return getRuleContext<MySQLStatementParser::ChannelContext>(0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::ROLLBACK() {
  return getToken(MySQLStatementParser::ROLLBACK, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

tree::TerminalNode* MySQLStatementParser::InstanceActionContext::ERROR() {
  return getToken(MySQLStatementParser::ERROR, 0);
}


size_t MySQLStatementParser::InstanceActionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInstanceAction;
}

void MySQLStatementParser::InstanceActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstanceAction(this);
}

void MySQLStatementParser::InstanceActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstanceAction(this);
}


antlrcpp::Any MySQLStatementParser::InstanceActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInstanceAction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InstanceActionContext* MySQLStatementParser::instanceAction() {
  InstanceActionContext *_localctx = _tracker.createInstance<InstanceActionContext>(_ctx, getState());
  enterRule(_localctx, 252, MySQLStatementParser::RuleInstanceAction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2849);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2825);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DISABLE

      || _la == MySQLStatementParser::ENABLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2826);
      match(MySQLStatementParser::INNODB);
      setState(2827);
      match(MySQLStatementParser::REDO_LOG);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2828);
      match(MySQLStatementParser::ROTATE);
      setState(2829);
      match(MySQLStatementParser::INNODB);
      setState(2830);
      match(MySQLStatementParser::MASTER);
      setState(2831);
      match(MySQLStatementParser::KEY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2832);
      match(MySQLStatementParser::ROTATE);
      setState(2833);
      match(MySQLStatementParser::BINLOG);
      setState(2834);
      match(MySQLStatementParser::MASTER);
      setState(2835);
      match(MySQLStatementParser::KEY);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2836);
      match(MySQLStatementParser::RELOAD);
      setState(2837);
      match(MySQLStatementParser::TLS);
      setState(2841);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::FOR) {
        setState(2838);
        match(MySQLStatementParser::FOR);
        setState(2839);
        match(MySQLStatementParser::CHANNEL);
        setState(2840);
        channel();
      }
      setState(2847);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NO) {
        setState(2843);
        match(MySQLStatementParser::NO);
        setState(2844);
        match(MySQLStatementParser::ROLLBACK);
        setState(2845);
        match(MySQLStatementParser::ON);
        setState(2846);
        match(MySQLStatementParser::ERROR);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelContext ------------------------------------------------------------------

MySQLStatementParser::ChannelContext::ChannelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ChannelContext::MYSQL_MAIN() {
  return getToken(MySQLStatementParser::MYSQL_MAIN, 0);
}

tree::TerminalNode* MySQLStatementParser::ChannelContext::MYSQL_ADMIN() {
  return getToken(MySQLStatementParser::MYSQL_ADMIN, 0);
}


size_t MySQLStatementParser::ChannelContext::getRuleIndex() const {
  return MySQLStatementParser::RuleChannel;
}

void MySQLStatementParser::ChannelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannel(this);
}

void MySQLStatementParser::ChannelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannel(this);
}


antlrcpp::Any MySQLStatementParser::ChannelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChannel(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ChannelContext* MySQLStatementParser::channel() {
  ChannelContext *_localctx = _tracker.createInstance<ChannelContext>(_ctx, getState());
  enterRule(_localctx, 254, MySQLStatementParser::RuleChannel);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2851);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::MYSQL_MAIN

    || _la == MySQLStatementParser::MYSQL_ADMIN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateEventContext ------------------------------------------------------------------

MySQLStatementParser::CreateEventContext::CreateEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::EVENT() {
  return getToken(MySQLStatementParser::EVENT, 0);
}

MySQLStatementParser::EventNameContext* MySQLStatementParser::CreateEventContext::eventName() {
  return getRuleContext<MySQLStatementParser::EventNameContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateEventContext::ON() {
  return getTokens(MySQLStatementParser::ON);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::ON(size_t i) {
  return getToken(MySQLStatementParser::ON, i);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::SCHEDULE() {
  return getToken(MySQLStatementParser::SCHEDULE, 0);
}

MySQLStatementParser::ScheduleExpressionContext* MySQLStatementParser::CreateEventContext::scheduleExpression() {
  return getRuleContext<MySQLStatementParser::ScheduleExpressionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::DO() {
  return getToken(MySQLStatementParser::DO, 0);
}

MySQLStatementParser::RoutineBodyContext* MySQLStatementParser::CreateEventContext::routineBody() {
  return getRuleContext<MySQLStatementParser::RoutineBodyContext>(0);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::CreateEventContext::ownerStatement() {
  return getRuleContext<MySQLStatementParser::OwnerStatementContext>(0);
}

MySQLStatementParser::NotExistClauseContext* MySQLStatementParser::CreateEventContext::notExistClause() {
  return getRuleContext<MySQLStatementParser::NotExistClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::COMPLETION() {
  return getToken(MySQLStatementParser::COMPLETION, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::PRESERVE() {
  return getToken(MySQLStatementParser::PRESERVE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::ENABLE() {
  return getToken(MySQLStatementParser::ENABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::DISABLE() {
  return getToken(MySQLStatementParser::DISABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::CreateEventContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateEventContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}


size_t MySQLStatementParser::CreateEventContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateEvent;
}

void MySQLStatementParser::CreateEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateEvent(this);
}

void MySQLStatementParser::CreateEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateEvent(this);
}


antlrcpp::Any MySQLStatementParser::CreateEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateEventContext* MySQLStatementParser::createEvent() {
  CreateEventContext *_localctx = _tracker.createInstance<CreateEventContext>(_ctx, getState());
  enterRule(_localctx, 256, MySQLStatementParser::RuleCreateEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2853);
    match(MySQLStatementParser::CREATE);
    setState(2855);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFINER) {
      setState(2854);
      ownerStatement();
    }
    setState(2857);
    match(MySQLStatementParser::EVENT);
    setState(2859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(2858);
      notExistClause();
    }
    setState(2861);
    eventName();
    setState(2862);
    match(MySQLStatementParser::ON);
    setState(2863);
    match(MySQLStatementParser::SCHEDULE);
    setState(2864);
    scheduleExpression();
    setState(2871);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ON) {
      setState(2865);
      match(MySQLStatementParser::ON);
      setState(2866);
      match(MySQLStatementParser::COMPLETION);
      setState(2868);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(2867);
        match(MySQLStatementParser::NOT);
      }
      setState(2870);
      match(MySQLStatementParser::PRESERVE);
    }
    setState(2878);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      setState(2873);
      match(MySQLStatementParser::ENABLE);
      break;
    }

    case 2: {
      setState(2874);
      match(MySQLStatementParser::DISABLE);
      break;
    }

    case 3: {
      setState(2875);
      match(MySQLStatementParser::DISABLE);
      setState(2876);
      match(MySQLStatementParser::ON);
      setState(2877);
      match(MySQLStatementParser::SLAVE);
      break;
    }

    }
    setState(2882);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COMMENT) {
      setState(2880);
      match(MySQLStatementParser::COMMENT);
      setState(2881);
      string_();
    }
    setState(2884);
    match(MySQLStatementParser::DO);
    setState(2885);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterEventContext ------------------------------------------------------------------

MySQLStatementParser::AlterEventContext::AlterEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::EVENT() {
  return getToken(MySQLStatementParser::EVENT, 0);
}

std::vector<MySQLStatementParser::EventNameContext *> MySQLStatementParser::AlterEventContext::eventName() {
  return getRuleContexts<MySQLStatementParser::EventNameContext>();
}

MySQLStatementParser::EventNameContext* MySQLStatementParser::AlterEventContext::eventName(size_t i) {
  return getRuleContext<MySQLStatementParser::EventNameContext>(i);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::AlterEventContext::ownerStatement() {
  return getRuleContext<MySQLStatementParser::OwnerStatementContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterEventContext::ON() {
  return getTokens(MySQLStatementParser::ON);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::ON(size_t i) {
  return getToken(MySQLStatementParser::ON, i);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::SCHEDULE() {
  return getToken(MySQLStatementParser::SCHEDULE, 0);
}

MySQLStatementParser::ScheduleExpressionContext* MySQLStatementParser::AlterEventContext::scheduleExpression() {
  return getRuleContext<MySQLStatementParser::ScheduleExpressionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::COMPLETION() {
  return getToken(MySQLStatementParser::COMPLETION, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::PRESERVE() {
  return getToken(MySQLStatementParser::PRESERVE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::ENABLE() {
  return getToken(MySQLStatementParser::ENABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::DISABLE() {
  return getToken(MySQLStatementParser::DISABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::AlterEventContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::DO() {
  return getToken(MySQLStatementParser::DO, 0);
}

MySQLStatementParser::RoutineBodyContext* MySQLStatementParser::AlterEventContext::routineBody() {
  return getRuleContext<MySQLStatementParser::RoutineBodyContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterEventContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}


size_t MySQLStatementParser::AlterEventContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterEvent;
}

void MySQLStatementParser::AlterEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterEvent(this);
}

void MySQLStatementParser::AlterEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterEvent(this);
}


antlrcpp::Any MySQLStatementParser::AlterEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterEventContext* MySQLStatementParser::alterEvent() {
  AlterEventContext *_localctx = _tracker.createInstance<AlterEventContext>(_ctx, getState());
  enterRule(_localctx, 258, MySQLStatementParser::RuleAlterEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2887);
    match(MySQLStatementParser::ALTER);
    setState(2889);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFINER) {
      setState(2888);
      ownerStatement();
    }
    setState(2891);
    match(MySQLStatementParser::EVENT);
    setState(2892);
    eventName();
    setState(2896);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
    case 1: {
      setState(2893);
      match(MySQLStatementParser::ON);
      setState(2894);
      match(MySQLStatementParser::SCHEDULE);
      setState(2895);
      scheduleExpression();
      break;
    }

    }
    setState(2904);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ON) {
      setState(2898);
      match(MySQLStatementParser::ON);
      setState(2899);
      match(MySQLStatementParser::COMPLETION);
      setState(2901);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(2900);
        match(MySQLStatementParser::NOT);
      }
      setState(2903);
      match(MySQLStatementParser::PRESERVE);
    }
    setState(2909);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RENAME) {
      setState(2906);
      match(MySQLStatementParser::RENAME);
      setState(2907);
      match(MySQLStatementParser::TO);
      setState(2908);
      eventName();
    }
    setState(2916);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
    case 1: {
      setState(2911);
      match(MySQLStatementParser::ENABLE);
      break;
    }

    case 2: {
      setState(2912);
      match(MySQLStatementParser::DISABLE);
      break;
    }

    case 3: {
      setState(2913);
      match(MySQLStatementParser::DISABLE);
      setState(2914);
      match(MySQLStatementParser::ON);
      setState(2915);
      match(MySQLStatementParser::SLAVE);
      break;
    }

    }
    setState(2920);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COMMENT) {
      setState(2918);
      match(MySQLStatementParser::COMMENT);
      setState(2919);
      string_();
    }
    setState(2924);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DO) {
      setState(2922);
      match(MySQLStatementParser::DO);
      setState(2923);
      routineBody();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropEventContext ------------------------------------------------------------------

MySQLStatementParser::DropEventContext::DropEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropEventContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropEventContext::EVENT() {
  return getToken(MySQLStatementParser::EVENT, 0);
}

MySQLStatementParser::EventNameContext* MySQLStatementParser::DropEventContext::eventName() {
  return getRuleContext<MySQLStatementParser::EventNameContext>(0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropEventContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}


size_t MySQLStatementParser::DropEventContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropEvent;
}

void MySQLStatementParser::DropEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropEvent(this);
}

void MySQLStatementParser::DropEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropEvent(this);
}


antlrcpp::Any MySQLStatementParser::DropEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropEventContext* MySQLStatementParser::dropEvent() {
  DropEventContext *_localctx = _tracker.createInstance<DropEventContext>(_ctx, getState());
  enterRule(_localctx, 260, MySQLStatementParser::RuleDropEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2926);
    match(MySQLStatementParser::DROP);
    setState(2927);
    match(MySQLStatementParser::EVENT);
    setState(2929);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(2928);
      existClause();
    }
    setState(2931);
    eventName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateFunctionContext ------------------------------------------------------------------

MySQLStatementParser::CreateFunctionContext::CreateFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateFunctionContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateFunctionContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::CreateFunctionContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateFunctionContext::RETURNS() {
  return getToken(MySQLStatementParser::RETURNS, 0);
}

std::vector<MySQLStatementParser::DataTypeContext *> MySQLStatementParser::CreateFunctionContext::dataType() {
  return getRuleContexts<MySQLStatementParser::DataTypeContext>();
}

MySQLStatementParser::DataTypeContext* MySQLStatementParser::CreateFunctionContext::dataType(size_t i) {
  return getRuleContext<MySQLStatementParser::DataTypeContext>(i);
}

MySQLStatementParser::RoutineBodyContext* MySQLStatementParser::CreateFunctionContext::routineBody() {
  return getRuleContext<MySQLStatementParser::RoutineBodyContext>(0);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::CreateFunctionContext::ownerStatement() {
  return getRuleContext<MySQLStatementParser::OwnerStatementContext>(0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::CreateFunctionContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CreateFunctionContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateFunctionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CreateFunctionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

std::vector<MySQLStatementParser::RoutineOptionContext *> MySQLStatementParser::CreateFunctionContext::routineOption() {
  return getRuleContexts<MySQLStatementParser::RoutineOptionContext>();
}

MySQLStatementParser::RoutineOptionContext* MySQLStatementParser::CreateFunctionContext::routineOption(size_t i) {
  return getRuleContext<MySQLStatementParser::RoutineOptionContext>(i);
}


size_t MySQLStatementParser::CreateFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateFunction;
}

void MySQLStatementParser::CreateFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateFunction(this);
}

void MySQLStatementParser::CreateFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateFunction(this);
}


antlrcpp::Any MySQLStatementParser::CreateFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateFunctionContext* MySQLStatementParser::createFunction() {
  CreateFunctionContext *_localctx = _tracker.createInstance<CreateFunctionContext>(_ctx, getState());
  enterRule(_localctx, 262, MySQLStatementParser::RuleCreateFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2933);
    match(MySQLStatementParser::CREATE);
    setState(2935);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFINER) {
      setState(2934);
      ownerStatement();
    }
    setState(2937);
    match(MySQLStatementParser::FUNCTION);
    setState(2938);
    functionName();
    setState(2939);
    match(MySQLStatementParser::LP_);
    setState(2943);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(2940);
      identifier();
      setState(2941);
      dataType();
    }
    setState(2951);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(2945);
      match(MySQLStatementParser::COMMA_);
      setState(2946);
      identifier();
      setState(2947);
      dataType();
      setState(2953);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2954);
    match(MySQLStatementParser::RP_);
    setState(2955);
    match(MySQLStatementParser::RETURNS);
    setState(2956);
    dataType();
    setState(2960);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2957);
        routineOption(); 
      }
      setState(2962);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx);
    }
    setState(2963);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterFunctionContext ------------------------------------------------------------------

MySQLStatementParser::AlterFunctionContext::AlterFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterFunctionContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterFunctionContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::AlterFunctionContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}

std::vector<MySQLStatementParser::RoutineOptionContext *> MySQLStatementParser::AlterFunctionContext::routineOption() {
  return getRuleContexts<MySQLStatementParser::RoutineOptionContext>();
}

MySQLStatementParser::RoutineOptionContext* MySQLStatementParser::AlterFunctionContext::routineOption(size_t i) {
  return getRuleContext<MySQLStatementParser::RoutineOptionContext>(i);
}


size_t MySQLStatementParser::AlterFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterFunction;
}

void MySQLStatementParser::AlterFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterFunction(this);
}

void MySQLStatementParser::AlterFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterFunction(this);
}


antlrcpp::Any MySQLStatementParser::AlterFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterFunctionContext* MySQLStatementParser::alterFunction() {
  AlterFunctionContext *_localctx = _tracker.createInstance<AlterFunctionContext>(_ctx, getState());
  enterRule(_localctx, 264, MySQLStatementParser::RuleAlterFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2965);
    match(MySQLStatementParser::ALTER);
    setState(2966);
    match(MySQLStatementParser::FUNCTION);
    setState(2967);
    functionName();
    setState(2971);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 97) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 97)) & ((1ULL << (MySQLStatementParser::COMMENT - 97))
      | (1ULL << (MySQLStatementParser::CONTAINS - 97))
      | (1ULL << (MySQLStatementParser::DETERMINISTIC - 97)))) != 0) || _la == MySQLStatementParser::LANGUAGE || ((((_la - 391) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 391)) & ((1ULL << (MySQLStatementParser::MODIFIES - 391))
      | (1ULL << (MySQLStatementParser::NO - 391))
      | (1ULL << (MySQLStatementParser::NOT - 391)))) != 0) || _la == MySQLStatementParser::READS || _la == MySQLStatementParser::SQL) {
      setState(2968);
      routineOption();
      setState(2973);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropFunctionContext ------------------------------------------------------------------

MySQLStatementParser::DropFunctionContext::DropFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropFunctionContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropFunctionContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::DropFunctionContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropFunctionContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}


size_t MySQLStatementParser::DropFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropFunction;
}

void MySQLStatementParser::DropFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropFunction(this);
}

void MySQLStatementParser::DropFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropFunction(this);
}


antlrcpp::Any MySQLStatementParser::DropFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropFunctionContext* MySQLStatementParser::dropFunction() {
  DropFunctionContext *_localctx = _tracker.createInstance<DropFunctionContext>(_ctx, getState());
  enterRule(_localctx, 266, MySQLStatementParser::RuleDropFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2974);
    match(MySQLStatementParser::DROP);
    setState(2975);
    match(MySQLStatementParser::FUNCTION);
    setState(2977);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(2976);
      existClause();
    }
    setState(2979);
    functionName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateProcedureContext ------------------------------------------------------------------

MySQLStatementParser::CreateProcedureContext::CreateProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateProcedureContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateProcedureContext::PROCEDURE() {
  return getToken(MySQLStatementParser::PROCEDURE, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::CreateProcedureContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateProcedureContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateProcedureContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::RoutineBodyContext* MySQLStatementParser::CreateProcedureContext::routineBody() {
  return getRuleContext<MySQLStatementParser::RoutineBodyContext>(0);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::CreateProcedureContext::ownerStatement() {
  return getRuleContext<MySQLStatementParser::OwnerStatementContext>(0);
}

std::vector<MySQLStatementParser::ProcedureParameterContext *> MySQLStatementParser::CreateProcedureContext::procedureParameter() {
  return getRuleContexts<MySQLStatementParser::ProcedureParameterContext>();
}

MySQLStatementParser::ProcedureParameterContext* MySQLStatementParser::CreateProcedureContext::procedureParameter(size_t i) {
  return getRuleContext<MySQLStatementParser::ProcedureParameterContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateProcedureContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CreateProcedureContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

std::vector<MySQLStatementParser::RoutineOptionContext *> MySQLStatementParser::CreateProcedureContext::routineOption() {
  return getRuleContexts<MySQLStatementParser::RoutineOptionContext>();
}

MySQLStatementParser::RoutineOptionContext* MySQLStatementParser::CreateProcedureContext::routineOption(size_t i) {
  return getRuleContext<MySQLStatementParser::RoutineOptionContext>(i);
}


size_t MySQLStatementParser::CreateProcedureContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateProcedure;
}

void MySQLStatementParser::CreateProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateProcedure(this);
}

void MySQLStatementParser::CreateProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateProcedure(this);
}


antlrcpp::Any MySQLStatementParser::CreateProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateProcedureContext* MySQLStatementParser::createProcedure() {
  CreateProcedureContext *_localctx = _tracker.createInstance<CreateProcedureContext>(_ctx, getState());
  enterRule(_localctx, 268, MySQLStatementParser::RuleCreateProcedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2981);
    match(MySQLStatementParser::CREATE);
    setState(2983);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFINER) {
      setState(2982);
      ownerStatement();
    }
    setState(2985);
    match(MySQLStatementParser::PROCEDURE);
    setState(2986);
    functionName();
    setState(2987);
    match(MySQLStatementParser::LP_);
    setState(2989);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::IN - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INOUT - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OUT - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(2988);
      procedureParameter();
    }
    setState(2995);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(2991);
      match(MySQLStatementParser::COMMA_);
      setState(2992);
      procedureParameter();
      setState(2997);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2998);
    match(MySQLStatementParser::RP_);
    setState(3002);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2999);
        routineOption(); 
      }
      setState(3004);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx);
    }
    setState(3005);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterProcedureContext ------------------------------------------------------------------

MySQLStatementParser::AlterProcedureContext::AlterProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterProcedureContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterProcedureContext::PROCEDURE() {
  return getToken(MySQLStatementParser::PROCEDURE, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::AlterProcedureContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}

std::vector<MySQLStatementParser::RoutineOptionContext *> MySQLStatementParser::AlterProcedureContext::routineOption() {
  return getRuleContexts<MySQLStatementParser::RoutineOptionContext>();
}

MySQLStatementParser::RoutineOptionContext* MySQLStatementParser::AlterProcedureContext::routineOption(size_t i) {
  return getRuleContext<MySQLStatementParser::RoutineOptionContext>(i);
}


size_t MySQLStatementParser::AlterProcedureContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterProcedure;
}

void MySQLStatementParser::AlterProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterProcedure(this);
}

void MySQLStatementParser::AlterProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterProcedure(this);
}


antlrcpp::Any MySQLStatementParser::AlterProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterProcedureContext* MySQLStatementParser::alterProcedure() {
  AlterProcedureContext *_localctx = _tracker.createInstance<AlterProcedureContext>(_ctx, getState());
  enterRule(_localctx, 270, MySQLStatementParser::RuleAlterProcedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3007);
    match(MySQLStatementParser::ALTER);
    setState(3008);
    match(MySQLStatementParser::PROCEDURE);
    setState(3009);
    functionName();
    setState(3013);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 97) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 97)) & ((1ULL << (MySQLStatementParser::COMMENT - 97))
      | (1ULL << (MySQLStatementParser::CONTAINS - 97))
      | (1ULL << (MySQLStatementParser::DETERMINISTIC - 97)))) != 0) || _la == MySQLStatementParser::LANGUAGE || ((((_la - 391) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 391)) & ((1ULL << (MySQLStatementParser::MODIFIES - 391))
      | (1ULL << (MySQLStatementParser::NO - 391))
      | (1ULL << (MySQLStatementParser::NOT - 391)))) != 0) || _la == MySQLStatementParser::READS || _la == MySQLStatementParser::SQL) {
      setState(3010);
      routineOption();
      setState(3015);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropProcedureContext ------------------------------------------------------------------

MySQLStatementParser::DropProcedureContext::DropProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropProcedureContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropProcedureContext::PROCEDURE() {
  return getToken(MySQLStatementParser::PROCEDURE, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::DropProcedureContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropProcedureContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}


size_t MySQLStatementParser::DropProcedureContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropProcedure;
}

void MySQLStatementParser::DropProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropProcedure(this);
}

void MySQLStatementParser::DropProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropProcedure(this);
}


antlrcpp::Any MySQLStatementParser::DropProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropProcedureContext* MySQLStatementParser::dropProcedure() {
  DropProcedureContext *_localctx = _tracker.createInstance<DropProcedureContext>(_ctx, getState());
  enterRule(_localctx, 272, MySQLStatementParser::RuleDropProcedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3016);
    match(MySQLStatementParser::DROP);
    setState(3017);
    match(MySQLStatementParser::PROCEDURE);
    setState(3019);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(3018);
      existClause();
    }
    setState(3021);
    functionName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateServerContext ------------------------------------------------------------------

MySQLStatementParser::CreateServerContext::CreateServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::SERVER() {
  return getToken(MySQLStatementParser::SERVER, 0);
}

MySQLStatementParser::ServerNameContext* MySQLStatementParser::CreateServerContext::serverName() {
  return getRuleContext<MySQLStatementParser::ServerNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::FOREIGN() {
  return getToken(MySQLStatementParser::FOREIGN, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::DATA() {
  return getToken(MySQLStatementParser::DATA, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::WRAPPER() {
  return getToken(MySQLStatementParser::WRAPPER, 0);
}

MySQLStatementParser::WrapperNameContext* MySQLStatementParser::CreateServerContext::wrapperName() {
  return getRuleContext<MySQLStatementParser::WrapperNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::OPTIONS() {
  return getToken(MySQLStatementParser::OPTIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::ServerOptionContext *> MySQLStatementParser::CreateServerContext::serverOption() {
  return getRuleContexts<MySQLStatementParser::ServerOptionContext>();
}

MySQLStatementParser::ServerOptionContext* MySQLStatementParser::CreateServerContext::serverOption(size_t i) {
  return getRuleContext<MySQLStatementParser::ServerOptionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateServerContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CreateServerContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::CreateServerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateServer;
}

void MySQLStatementParser::CreateServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateServer(this);
}

void MySQLStatementParser::CreateServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateServer(this);
}


antlrcpp::Any MySQLStatementParser::CreateServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateServerContext* MySQLStatementParser::createServer() {
  CreateServerContext *_localctx = _tracker.createInstance<CreateServerContext>(_ctx, getState());
  enterRule(_localctx, 274, MySQLStatementParser::RuleCreateServer);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3023);
    match(MySQLStatementParser::CREATE);
    setState(3024);
    match(MySQLStatementParser::SERVER);
    setState(3025);
    serverName();
    setState(3026);
    match(MySQLStatementParser::FOREIGN);
    setState(3027);
    match(MySQLStatementParser::DATA);
    setState(3028);
    match(MySQLStatementParser::WRAPPER);
    setState(3029);
    wrapperName();
    setState(3030);
    match(MySQLStatementParser::OPTIONS);
    setState(3031);
    match(MySQLStatementParser::LP_);
    setState(3032);
    serverOption();
    setState(3037);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(3033);
      match(MySQLStatementParser::COMMA_);
      setState(3034);
      serverOption();
      setState(3039);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3040);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterServerContext ------------------------------------------------------------------

MySQLStatementParser::AlterServerContext::AlterServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterServerContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterServerContext::SERVER() {
  return getToken(MySQLStatementParser::SERVER, 0);
}

MySQLStatementParser::ServerNameContext* MySQLStatementParser::AlterServerContext::serverName() {
  return getRuleContext<MySQLStatementParser::ServerNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterServerContext::OPTIONS() {
  return getToken(MySQLStatementParser::OPTIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterServerContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::ServerOptionContext *> MySQLStatementParser::AlterServerContext::serverOption() {
  return getRuleContexts<MySQLStatementParser::ServerOptionContext>();
}

MySQLStatementParser::ServerOptionContext* MySQLStatementParser::AlterServerContext::serverOption(size_t i) {
  return getRuleContext<MySQLStatementParser::ServerOptionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterServerContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterServerContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AlterServerContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::AlterServerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterServer;
}

void MySQLStatementParser::AlterServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterServer(this);
}

void MySQLStatementParser::AlterServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterServer(this);
}


antlrcpp::Any MySQLStatementParser::AlterServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterServerContext* MySQLStatementParser::alterServer() {
  AlterServerContext *_localctx = _tracker.createInstance<AlterServerContext>(_ctx, getState());
  enterRule(_localctx, 276, MySQLStatementParser::RuleAlterServer);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3042);
    match(MySQLStatementParser::ALTER);
    setState(3043);
    match(MySQLStatementParser::SERVER);
    setState(3044);
    serverName();
    setState(3045);
    match(MySQLStatementParser::OPTIONS);
    setState(3046);
    match(MySQLStatementParser::LP_);
    setState(3047);
    serverOption();
    setState(3052);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(3048);
      match(MySQLStatementParser::COMMA_);
      setState(3049);
      serverOption();
      setState(3054);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3055);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropServerContext ------------------------------------------------------------------

MySQLStatementParser::DropServerContext::DropServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropServerContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropServerContext::SERVER() {
  return getToken(MySQLStatementParser::SERVER, 0);
}

MySQLStatementParser::ServerNameContext* MySQLStatementParser::DropServerContext::serverName() {
  return getRuleContext<MySQLStatementParser::ServerNameContext>(0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropServerContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}


size_t MySQLStatementParser::DropServerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropServer;
}

void MySQLStatementParser::DropServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropServer(this);
}

void MySQLStatementParser::DropServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropServer(this);
}


antlrcpp::Any MySQLStatementParser::DropServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropServerContext* MySQLStatementParser::dropServer() {
  DropServerContext *_localctx = _tracker.createInstance<DropServerContext>(_ctx, getState());
  enterRule(_localctx, 278, MySQLStatementParser::RuleDropServer);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3057);
    match(MySQLStatementParser::DROP);
    setState(3058);
    match(MySQLStatementParser::SERVER);
    setState(3060);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(3059);
      existClause();
    }
    setState(3062);
    serverName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateViewContext ------------------------------------------------------------------

MySQLStatementParser::CreateViewContext::CreateViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::VIEW() {
  return getToken(MySQLStatementParser::VIEW, 0);
}

MySQLStatementParser::ViewNameContext* MySQLStatementParser::CreateViewContext::viewName() {
  return getRuleContext<MySQLStatementParser::ViewNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::SelectContext* MySQLStatementParser::CreateViewContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::OR() {
  return getToken(MySQLStatementParser::OR, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::ALGORITHM() {
  return getToken(MySQLStatementParser::ALGORITHM, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::CreateViewContext::ownerStatement() {
  return getRuleContext<MySQLStatementParser::OwnerStatementContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::SQL() {
  return getToken(MySQLStatementParser::SQL, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::SECURITY() {
  return getToken(MySQLStatementParser::SECURITY, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::CreateViewContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::CHECK() {
  return getToken(MySQLStatementParser::CHECK, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::OPTION() {
  return getToken(MySQLStatementParser::OPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::UNDEFINED() {
  return getToken(MySQLStatementParser::UNDEFINED, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::MERGE() {
  return getToken(MySQLStatementParser::MERGE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::TEMPTABLE() {
  return getToken(MySQLStatementParser::TEMPTABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::DEFINER() {
  return getToken(MySQLStatementParser::DEFINER, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::INVOKER() {
  return getToken(MySQLStatementParser::INVOKER, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::CASCADED() {
  return getToken(MySQLStatementParser::CASCADED, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateViewContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}


size_t MySQLStatementParser::CreateViewContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateView;
}

void MySQLStatementParser::CreateViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateView(this);
}

void MySQLStatementParser::CreateViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateView(this);
}


antlrcpp::Any MySQLStatementParser::CreateViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateView(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateViewContext* MySQLStatementParser::createView() {
  CreateViewContext *_localctx = _tracker.createInstance<CreateViewContext>(_ctx, getState());
  enterRule(_localctx, 280, MySQLStatementParser::RuleCreateView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3064);
    match(MySQLStatementParser::CREATE);
    setState(3067);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::OR) {
      setState(3065);
      match(MySQLStatementParser::OR);
      setState(3066);
      match(MySQLStatementParser::REPLACE);
    }
    setState(3072);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ALGORITHM) {
      setState(3069);
      match(MySQLStatementParser::ALGORITHM);
      setState(3070);
      match(MySQLStatementParser::EQ_);
      setState(3071);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::MERGE || _la == MySQLStatementParser::TEMPTABLE

      || _la == MySQLStatementParser::UNDEFINED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3075);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFINER) {
      setState(3074);
      ownerStatement();
    }
    setState(3080);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::SQL) {
      setState(3077);
      match(MySQLStatementParser::SQL);
      setState(3078);
      match(MySQLStatementParser::SECURITY);
      setState(3079);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DEFINER || _la == MySQLStatementParser::INVOKER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3082);
    match(MySQLStatementParser::VIEW);
    setState(3083);
    viewName();
    setState(3088);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(3084);
      match(MySQLStatementParser::LP_);
      setState(3085);
      columnNames();
      setState(3086);
      match(MySQLStatementParser::RP_);
    }
    setState(3090);
    match(MySQLStatementParser::AS);
    setState(3091);
    select();
    setState(3098);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(3092);
      match(MySQLStatementParser::WITH);
      setState(3094);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::CASCADED || _la == MySQLStatementParser::LOCAL) {
        setState(3093);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::CASCADED || _la == MySQLStatementParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(3096);
      match(MySQLStatementParser::CHECK);
      setState(3097);
      match(MySQLStatementParser::OPTION);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterViewContext ------------------------------------------------------------------

MySQLStatementParser::AlterViewContext::AlterViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::VIEW() {
  return getToken(MySQLStatementParser::VIEW, 0);
}

MySQLStatementParser::ViewNameContext* MySQLStatementParser::AlterViewContext::viewName() {
  return getRuleContext<MySQLStatementParser::ViewNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::SelectContext* MySQLStatementParser::AlterViewContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::ALGORITHM() {
  return getToken(MySQLStatementParser::ALGORITHM, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::AlterViewContext::ownerStatement() {
  return getRuleContext<MySQLStatementParser::OwnerStatementContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::SQL() {
  return getToken(MySQLStatementParser::SQL, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::SECURITY() {
  return getToken(MySQLStatementParser::SECURITY, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::AlterViewContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::CHECK() {
  return getToken(MySQLStatementParser::CHECK, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::OPTION() {
  return getToken(MySQLStatementParser::OPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::UNDEFINED() {
  return getToken(MySQLStatementParser::UNDEFINED, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::MERGE() {
  return getToken(MySQLStatementParser::MERGE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::TEMPTABLE() {
  return getToken(MySQLStatementParser::TEMPTABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::DEFINER() {
  return getToken(MySQLStatementParser::DEFINER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::INVOKER() {
  return getToken(MySQLStatementParser::INVOKER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::CASCADED() {
  return getToken(MySQLStatementParser::CASCADED, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterViewContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}


size_t MySQLStatementParser::AlterViewContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterView;
}

void MySQLStatementParser::AlterViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterView(this);
}

void MySQLStatementParser::AlterViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterView(this);
}


antlrcpp::Any MySQLStatementParser::AlterViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterView(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterViewContext* MySQLStatementParser::alterView() {
  AlterViewContext *_localctx = _tracker.createInstance<AlterViewContext>(_ctx, getState());
  enterRule(_localctx, 282, MySQLStatementParser::RuleAlterView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3100);
    match(MySQLStatementParser::ALTER);
    setState(3104);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ALGORITHM) {
      setState(3101);
      match(MySQLStatementParser::ALGORITHM);
      setState(3102);
      match(MySQLStatementParser::EQ_);
      setState(3103);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::MERGE || _la == MySQLStatementParser::TEMPTABLE

      || _la == MySQLStatementParser::UNDEFINED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3107);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFINER) {
      setState(3106);
      ownerStatement();
    }
    setState(3112);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::SQL) {
      setState(3109);
      match(MySQLStatementParser::SQL);
      setState(3110);
      match(MySQLStatementParser::SECURITY);
      setState(3111);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DEFINER || _la == MySQLStatementParser::INVOKER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3114);
    match(MySQLStatementParser::VIEW);
    setState(3115);
    viewName();
    setState(3120);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(3116);
      match(MySQLStatementParser::LP_);
      setState(3117);
      columnNames();
      setState(3118);
      match(MySQLStatementParser::RP_);
    }
    setState(3122);
    match(MySQLStatementParser::AS);
    setState(3123);
    select();
    setState(3130);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(3124);
      match(MySQLStatementParser::WITH);
      setState(3126);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::CASCADED || _la == MySQLStatementParser::LOCAL) {
        setState(3125);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::CASCADED || _la == MySQLStatementParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(3128);
      match(MySQLStatementParser::CHECK);
      setState(3129);
      match(MySQLStatementParser::OPTION);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropViewContext ------------------------------------------------------------------

MySQLStatementParser::DropViewContext::DropViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropViewContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropViewContext::VIEW() {
  return getToken(MySQLStatementParser::VIEW, 0);
}

MySQLStatementParser::ViewNamesContext* MySQLStatementParser::DropViewContext::viewNames() {
  return getRuleContext<MySQLStatementParser::ViewNamesContext>(0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropViewContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}

MySQLStatementParser::RestrictContext* MySQLStatementParser::DropViewContext::restrict() {
  return getRuleContext<MySQLStatementParser::RestrictContext>(0);
}


size_t MySQLStatementParser::DropViewContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropView;
}

void MySQLStatementParser::DropViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropView(this);
}

void MySQLStatementParser::DropViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropView(this);
}


antlrcpp::Any MySQLStatementParser::DropViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropView(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropViewContext* MySQLStatementParser::dropView() {
  DropViewContext *_localctx = _tracker.createInstance<DropViewContext>(_ctx, getState());
  enterRule(_localctx, 284, MySQLStatementParser::RuleDropView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3132);
    match(MySQLStatementParser::DROP);
    setState(3133);
    match(MySQLStatementParser::VIEW);
    setState(3135);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(3134);
      existClause();
    }
    setState(3137);
    viewNames();
    setState(3139);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CASCADE || _la == MySQLStatementParser::RESTRICT) {
      setState(3138);
      restrict();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTablespaceInnodbContext ------------------------------------------------------------------

MySQLStatementParser::CreateTablespaceInnodbContext::CreateTablespaceInnodbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CreateTablespaceInnodbContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::DATAFILE() {
  return getToken(MySQLStatementParser::DATAFILE, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::CreateTablespaceInnodbContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::CreateTablespaceInnodbContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::UNDO() {
  return getToken(MySQLStatementParser::UNDO, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::FILE_BLOCK_SIZE() {
  return getToken(MySQLStatementParser::FILE_BLOCK_SIZE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateTablespaceInnodbContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}

MySQLStatementParser::FileSizeLiteralContext* MySQLStatementParser::CreateTablespaceInnodbContext::fileSizeLiteral() {
  return getRuleContext<MySQLStatementParser::FileSizeLiteralContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::ENCRYPTION() {
  return getToken(MySQLStatementParser::ENCRYPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceInnodbContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}


size_t MySQLStatementParser::CreateTablespaceInnodbContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateTablespaceInnodb;
}

void MySQLStatementParser::CreateTablespaceInnodbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTablespaceInnodb(this);
}

void MySQLStatementParser::CreateTablespaceInnodbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTablespaceInnodb(this);
}


antlrcpp::Any MySQLStatementParser::CreateTablespaceInnodbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateTablespaceInnodb(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateTablespaceInnodbContext* MySQLStatementParser::createTablespaceInnodb() {
  CreateTablespaceInnodbContext *_localctx = _tracker.createInstance<CreateTablespaceInnodbContext>(_ctx, getState());
  enterRule(_localctx, 286, MySQLStatementParser::RuleCreateTablespaceInnodb);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3141);
    match(MySQLStatementParser::CREATE);
    setState(3143);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDO) {
      setState(3142);
      match(MySQLStatementParser::UNDO);
    }
    setState(3145);
    match(MySQLStatementParser::TABLESPACE);
    setState(3146);
    identifier();
    setState(3147);
    match(MySQLStatementParser::ADD);
    setState(3148);
    match(MySQLStatementParser::DATAFILE);
    setState(3149);
    string_();
    setState(3153);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FILE_BLOCK_SIZE) {
      setState(3150);
      match(MySQLStatementParser::FILE_BLOCK_SIZE);
      setState(3151);
      match(MySQLStatementParser::EQ_);
      setState(3152);
      fileSizeLiteral();
    }
    setState(3158);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENCRYPTION) {
      setState(3155);
      match(MySQLStatementParser::ENCRYPTION);
      setState(3156);
      match(MySQLStatementParser::EQ_);
      setState(3157);
      dynamic_cast<CreateTablespaceInnodbContext *>(_localctx)->y_or_n = string_();
    }
    setState(3165);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3160);
      match(MySQLStatementParser::ENGINE);
      setState(3162);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3161);
        match(MySQLStatementParser::EQ_);
      }
      setState(3164);
      string_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTablespaceNdbContext ------------------------------------------------------------------

MySQLStatementParser::CreateTablespaceNdbContext::CreateTablespaceNdbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::CreateTablespaceNdbContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CreateTablespaceNdbContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::DATAFILE() {
  return getToken(MySQLStatementParser::DATAFILE, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::CreateTablespaceNdbContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::CreateTablespaceNdbContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::USE() {
  return getToken(MySQLStatementParser::USE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::LOGFILE() {
  return getToken(MySQLStatementParser::LOGFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::UNDO() {
  return getToken(MySQLStatementParser::UNDO, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::EXTENT_SIZE() {
  return getToken(MySQLStatementParser::EXTENT_SIZE, 0);
}

std::vector<MySQLStatementParser::FileSizeLiteralContext *> MySQLStatementParser::CreateTablespaceNdbContext::fileSizeLiteral() {
  return getRuleContexts<MySQLStatementParser::FileSizeLiteralContext>();
}

MySQLStatementParser::FileSizeLiteralContext* MySQLStatementParser::CreateTablespaceNdbContext::fileSizeLiteral(size_t i) {
  return getRuleContext<MySQLStatementParser::FileSizeLiteralContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::INITIAL_SIZE() {
  return getToken(MySQLStatementParser::INITIAL_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::AUTOEXTEND_SIZE() {
  return getToken(MySQLStatementParser::AUTOEXTEND_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::MAX_SIZE() {
  return getToken(MySQLStatementParser::MAX_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::NODEGROUP() {
  return getToken(MySQLStatementParser::NODEGROUP, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::WAIT() {
  return getToken(MySQLStatementParser::WAIT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateTablespaceNdbContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::CreateTablespaceNdbContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}


size_t MySQLStatementParser::CreateTablespaceNdbContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateTablespaceNdb;
}

void MySQLStatementParser::CreateTablespaceNdbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTablespaceNdb(this);
}

void MySQLStatementParser::CreateTablespaceNdbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTablespaceNdb(this);
}


antlrcpp::Any MySQLStatementParser::CreateTablespaceNdbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateTablespaceNdb(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateTablespaceNdbContext* MySQLStatementParser::createTablespaceNdb() {
  CreateTablespaceNdbContext *_localctx = _tracker.createInstance<CreateTablespaceNdbContext>(_ctx, getState());
  enterRule(_localctx, 288, MySQLStatementParser::RuleCreateTablespaceNdb);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3167);
    match(MySQLStatementParser::CREATE);
    setState(3169);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDO) {
      setState(3168);
      match(MySQLStatementParser::UNDO);
    }
    setState(3171);
    match(MySQLStatementParser::TABLESPACE);
    setState(3172);
    identifier();
    setState(3173);
    match(MySQLStatementParser::ADD);
    setState(3174);
    match(MySQLStatementParser::DATAFILE);
    setState(3175);
    string_();
    setState(3176);
    match(MySQLStatementParser::USE);
    setState(3177);
    match(MySQLStatementParser::LOGFILE);
    setState(3178);
    match(MySQLStatementParser::GROUP);
    setState(3179);
    identifier();
    setState(3185);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EXTENT_SIZE) {
      setState(3180);
      match(MySQLStatementParser::EXTENT_SIZE);
      setState(3182);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3181);
        match(MySQLStatementParser::EQ_);
      }
      setState(3184);
      fileSizeLiteral();
    }
    setState(3192);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::INITIAL_SIZE) {
      setState(3187);
      match(MySQLStatementParser::INITIAL_SIZE);
      setState(3189);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3188);
        match(MySQLStatementParser::EQ_);
      }
      setState(3191);
      fileSizeLiteral();
    }
    setState(3199);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AUTOEXTEND_SIZE) {
      setState(3194);
      match(MySQLStatementParser::AUTOEXTEND_SIZE);
      setState(3196);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3195);
        match(MySQLStatementParser::EQ_);
      }
      setState(3198);
      fileSizeLiteral();
    }
    setState(3206);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::MAX_SIZE) {
      setState(3201);
      match(MySQLStatementParser::MAX_SIZE);
      setState(3203);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3202);
        match(MySQLStatementParser::EQ_);
      }
      setState(3205);
      fileSizeLiteral();
    }
    setState(3213);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::NODEGROUP) {
      setState(3208);
      match(MySQLStatementParser::NODEGROUP);
      setState(3210);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3209);
        match(MySQLStatementParser::EQ_);
      }
      setState(3212);
      identifier();
    }
    setState(3216);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WAIT) {
      setState(3215);
      match(MySQLStatementParser::WAIT);
    }
    setState(3223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COMMENT) {
      setState(3218);
      match(MySQLStatementParser::COMMENT);
      setState(3220);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3219);
        match(MySQLStatementParser::EQ_);
      }
      setState(3222);
      string_();
    }
    setState(3230);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3225);
      match(MySQLStatementParser::ENGINE);
      setState(3227);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3226);
        match(MySQLStatementParser::EQ_);
      }
      setState(3229);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceNdbContext ------------------------------------------------------------------

MySQLStatementParser::AlterTablespaceNdbContext::AlterTablespaceNdbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::AlterTablespaceNdbContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterTablespaceNdbContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::DATAFILE() {
  return getToken(MySQLStatementParser::DATAFILE, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::AlterTablespaceNdbContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::UNDO() {
  return getToken(MySQLStatementParser::UNDO, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::INITIAL_SIZE() {
  return getToken(MySQLStatementParser::INITIAL_SIZE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterTablespaceNdbContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}

MySQLStatementParser::FileSizeLiteralContext* MySQLStatementParser::AlterTablespaceNdbContext::fileSizeLiteral() {
  return getRuleContext<MySQLStatementParser::FileSizeLiteralContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::WAIT() {
  return getToken(MySQLStatementParser::WAIT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceNdbContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}


size_t MySQLStatementParser::AlterTablespaceNdbContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterTablespaceNdb;
}

void MySQLStatementParser::AlterTablespaceNdbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceNdb(this);
}

void MySQLStatementParser::AlterTablespaceNdbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceNdb(this);
}


antlrcpp::Any MySQLStatementParser::AlterTablespaceNdbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTablespaceNdb(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterTablespaceNdbContext* MySQLStatementParser::alterTablespaceNdb() {
  AlterTablespaceNdbContext *_localctx = _tracker.createInstance<AlterTablespaceNdbContext>(_ctx, getState());
  enterRule(_localctx, 290, MySQLStatementParser::RuleAlterTablespaceNdb);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3232);
    match(MySQLStatementParser::ALTER);
    setState(3234);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDO) {
      setState(3233);
      match(MySQLStatementParser::UNDO);
    }
    setState(3236);
    match(MySQLStatementParser::TABLESPACE);
    setState(3237);
    identifier();
    setState(3238);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::ADD || _la == MySQLStatementParser::DROP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3239);
    match(MySQLStatementParser::DATAFILE);
    setState(3240);
    string_();
    setState(3244);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::INITIAL_SIZE) {
      setState(3241);
      match(MySQLStatementParser::INITIAL_SIZE);
      setState(3242);
      match(MySQLStatementParser::EQ_);
      setState(3243);
      fileSizeLiteral();
    }
    setState(3247);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WAIT) {
      setState(3246);
      match(MySQLStatementParser::WAIT);
    }
    setState(3252);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RENAME) {
      setState(3249);
      match(MySQLStatementParser::RENAME);
      setState(3250);
      match(MySQLStatementParser::TO);
      setState(3251);
      identifier();
    }
    setState(3259);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3254);
      match(MySQLStatementParser::ENGINE);
      setState(3256);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3255);
        match(MySQLStatementParser::EQ_);
      }
      setState(3258);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceInnodbContext ------------------------------------------------------------------

MySQLStatementParser::AlterTablespaceInnodbContext::AlterTablespaceInnodbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::AlterTablespaceInnodbContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterTablespaceInnodbContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::ENCRYPTION() {
  return getToken(MySQLStatementParser::ENCRYPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::UNDO() {
  return getToken(MySQLStatementParser::UNDO, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::AlterTablespaceInnodbContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::ACTIVE() {
  return getToken(MySQLStatementParser::ACTIVE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::INACTIVE() {
  return getToken(MySQLStatementParser::INACTIVE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterTablespaceInnodbContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::AlterTablespaceInnodbContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}


size_t MySQLStatementParser::AlterTablespaceInnodbContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterTablespaceInnodb;
}

void MySQLStatementParser::AlterTablespaceInnodbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceInnodb(this);
}

void MySQLStatementParser::AlterTablespaceInnodbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceInnodb(this);
}


antlrcpp::Any MySQLStatementParser::AlterTablespaceInnodbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterTablespaceInnodb(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterTablespaceInnodbContext* MySQLStatementParser::alterTablespaceInnodb() {
  AlterTablespaceInnodbContext *_localctx = _tracker.createInstance<AlterTablespaceInnodbContext>(_ctx, getState());
  enterRule(_localctx, 292, MySQLStatementParser::RuleAlterTablespaceInnodb);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3261);
    match(MySQLStatementParser::ALTER);
    setState(3263);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDO) {
      setState(3262);
      match(MySQLStatementParser::UNDO);
    }
    setState(3265);
    match(MySQLStatementParser::TABLESPACE);
    setState(3266);
    identifier();
    setState(3269);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::SET) {
      setState(3267);
      match(MySQLStatementParser::SET);
      setState(3268);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::ACTIVE || _la == MySQLStatementParser::INACTIVE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }

    setState(3271);
    match(MySQLStatementParser::ENCRYPTION);
    setState(3273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EQ_) {
      setState(3272);
      match(MySQLStatementParser::EQ_);
    }
    setState(3275);
    dynamic_cast<AlterTablespaceInnodbContext *>(_localctx)->y_or_n = string_();
    setState(3280);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RENAME) {
      setState(3277);
      match(MySQLStatementParser::RENAME);
      setState(3278);
      match(MySQLStatementParser::TO);
      setState(3279);
      identifier();
    }
    setState(3287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3282);
      match(MySQLStatementParser::ENGINE);
      setState(3284);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3283);
        match(MySQLStatementParser::EQ_);
      }
      setState(3286);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTablespaceContext ------------------------------------------------------------------

MySQLStatementParser::DropTablespaceContext::DropTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropTablespaceContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropTablespaceContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::DropTablespaceContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::DropTablespaceContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::DropTablespaceContext::UNDO() {
  return getToken(MySQLStatementParser::UNDO, 0);
}

tree::TerminalNode* MySQLStatementParser::DropTablespaceContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::DropTablespaceContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::DropTablespaceContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropTablespace;
}

void MySQLStatementParser::DropTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTablespace(this);
}

void MySQLStatementParser::DropTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTablespace(this);
}


antlrcpp::Any MySQLStatementParser::DropTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropTablespaceContext* MySQLStatementParser::dropTablespace() {
  DropTablespaceContext *_localctx = _tracker.createInstance<DropTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 294, MySQLStatementParser::RuleDropTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3289);
    match(MySQLStatementParser::DROP);
    setState(3291);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDO) {
      setState(3290);
      match(MySQLStatementParser::UNDO);
    }
    setState(3293);
    match(MySQLStatementParser::TABLESPACE);
    setState(3294);
    identifier();
    setState(3300);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3295);
      match(MySQLStatementParser::ENGINE);
      setState(3297);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3296);
        match(MySQLStatementParser::EQ_);
      }
      setState(3299);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateLogfileGroupContext ------------------------------------------------------------------

MySQLStatementParser::CreateLogfileGroupContext::CreateLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::LOGFILE() {
  return getToken(MySQLStatementParser::LOGFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::CreateLogfileGroupContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CreateLogfileGroupContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::UNDOFILE() {
  return getToken(MySQLStatementParser::UNDOFILE, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::CreateLogfileGroupContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::CreateLogfileGroupContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::INITIAL_SIZE() {
  return getToken(MySQLStatementParser::INITIAL_SIZE, 0);
}

std::vector<MySQLStatementParser::FileSizeLiteralContext *> MySQLStatementParser::CreateLogfileGroupContext::fileSizeLiteral() {
  return getRuleContexts<MySQLStatementParser::FileSizeLiteralContext>();
}

MySQLStatementParser::FileSizeLiteralContext* MySQLStatementParser::CreateLogfileGroupContext::fileSizeLiteral(size_t i) {
  return getRuleContext<MySQLStatementParser::FileSizeLiteralContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::UNDO_BUFFER_SIZE() {
  return getToken(MySQLStatementParser::UNDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::REDO_BUFFER_SIZE() {
  return getToken(MySQLStatementParser::REDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::NODEGROUP() {
  return getToken(MySQLStatementParser::NODEGROUP, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::WAIT() {
  return getToken(MySQLStatementParser::WAIT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateLogfileGroupContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::CreateLogfileGroupContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}


size_t MySQLStatementParser::CreateLogfileGroupContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateLogfileGroup;
}

void MySQLStatementParser::CreateLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateLogfileGroup(this);
}

void MySQLStatementParser::CreateLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateLogfileGroup(this);
}


antlrcpp::Any MySQLStatementParser::CreateLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateLogfileGroupContext* MySQLStatementParser::createLogfileGroup() {
  CreateLogfileGroupContext *_localctx = _tracker.createInstance<CreateLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 296, MySQLStatementParser::RuleCreateLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3302);
    match(MySQLStatementParser::CREATE);
    setState(3303);
    match(MySQLStatementParser::LOGFILE);
    setState(3304);
    match(MySQLStatementParser::GROUP);
    setState(3305);
    identifier();
    setState(3306);
    match(MySQLStatementParser::ADD);
    setState(3307);
    match(MySQLStatementParser::UNDOFILE);
    setState(3308);
    string_();
    setState(3314);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::INITIAL_SIZE) {
      setState(3309);
      match(MySQLStatementParser::INITIAL_SIZE);
      setState(3311);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3310);
        match(MySQLStatementParser::EQ_);
      }
      setState(3313);
      fileSizeLiteral();
    }
    setState(3321);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDO_BUFFER_SIZE) {
      setState(3316);
      match(MySQLStatementParser::UNDO_BUFFER_SIZE);
      setState(3318);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3317);
        match(MySQLStatementParser::EQ_);
      }
      setState(3320);
      fileSizeLiteral();
    }
    setState(3328);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::REDO_BUFFER_SIZE) {
      setState(3323);
      match(MySQLStatementParser::REDO_BUFFER_SIZE);
      setState(3325);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3324);
        match(MySQLStatementParser::EQ_);
      }
      setState(3327);
      fileSizeLiteral();
    }
    setState(3335);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::NODEGROUP) {
      setState(3330);
      match(MySQLStatementParser::NODEGROUP);
      setState(3332);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3331);
        match(MySQLStatementParser::EQ_);
      }
      setState(3334);
      identifier();
    }
    setState(3338);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WAIT) {
      setState(3337);
      match(MySQLStatementParser::WAIT);
    }
    setState(3345);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COMMENT) {
      setState(3340);
      match(MySQLStatementParser::COMMENT);
      setState(3342);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3341);
        match(MySQLStatementParser::EQ_);
      }
      setState(3344);
      string_();
    }
    setState(3352);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3347);
      match(MySQLStatementParser::ENGINE);
      setState(3349);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3348);
        match(MySQLStatementParser::EQ_);
      }
      setState(3351);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupContext ------------------------------------------------------------------

MySQLStatementParser::AlterLogfileGroupContext::AlterLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::LOGFILE() {
  return getToken(MySQLStatementParser::LOGFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::AlterLogfileGroupContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::AlterLogfileGroupContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::ADD() {
  return getToken(MySQLStatementParser::ADD, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::UNDOFILE() {
  return getToken(MySQLStatementParser::UNDOFILE, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::AlterLogfileGroupContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::INITIAL_SIZE() {
  return getToken(MySQLStatementParser::INITIAL_SIZE, 0);
}

MySQLStatementParser::FileSizeLiteralContext* MySQLStatementParser::AlterLogfileGroupContext::fileSizeLiteral() {
  return getRuleContext<MySQLStatementParser::FileSizeLiteralContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::WAIT() {
  return getToken(MySQLStatementParser::WAIT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterLogfileGroupContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::AlterLogfileGroupContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}


size_t MySQLStatementParser::AlterLogfileGroupContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterLogfileGroup;
}

void MySQLStatementParser::AlterLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroup(this);
}

void MySQLStatementParser::AlterLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroup(this);
}


antlrcpp::Any MySQLStatementParser::AlterLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterLogfileGroupContext* MySQLStatementParser::alterLogfileGroup() {
  AlterLogfileGroupContext *_localctx = _tracker.createInstance<AlterLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 298, MySQLStatementParser::RuleAlterLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3354);
    match(MySQLStatementParser::ALTER);
    setState(3355);
    match(MySQLStatementParser::LOGFILE);
    setState(3356);
    match(MySQLStatementParser::GROUP);
    setState(3357);
    identifier();
    setState(3358);
    match(MySQLStatementParser::ADD);
    setState(3359);
    match(MySQLStatementParser::UNDOFILE);
    setState(3360);
    string_();
    setState(3366);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::INITIAL_SIZE) {
      setState(3361);
      match(MySQLStatementParser::INITIAL_SIZE);
      setState(3363);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3362);
        match(MySQLStatementParser::EQ_);
      }
      setState(3365);
      fileSizeLiteral();
    }
    setState(3369);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WAIT) {
      setState(3368);
      match(MySQLStatementParser::WAIT);
    }
    setState(3376);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3371);
      match(MySQLStatementParser::ENGINE);
      setState(3373);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3372);
        match(MySQLStatementParser::EQ_);
      }
      setState(3375);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupContext ------------------------------------------------------------------

MySQLStatementParser::DropLogfileGroupContext::DropLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropLogfileGroupContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropLogfileGroupContext::LOGFILE() {
  return getToken(MySQLStatementParser::LOGFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::DropLogfileGroupContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::DropLogfileGroupContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::DropLogfileGroupContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::DropLogfileGroupContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::DropLogfileGroupContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::DropLogfileGroupContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropLogfileGroup;
}

void MySQLStatementParser::DropLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroup(this);
}

void MySQLStatementParser::DropLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroup(this);
}


antlrcpp::Any MySQLStatementParser::DropLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropLogfileGroupContext* MySQLStatementParser::dropLogfileGroup() {
  DropLogfileGroupContext *_localctx = _tracker.createInstance<DropLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 300, MySQLStatementParser::RuleDropLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3378);
    match(MySQLStatementParser::DROP);
    setState(3379);
    match(MySQLStatementParser::LOGFILE);
    setState(3380);
    match(MySQLStatementParser::GROUP);
    setState(3381);
    identifier();
    setState(3387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ENGINE) {
      setState(3382);
      match(MySQLStatementParser::ENGINE);
      setState(3384);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3383);
        match(MySQLStatementParser::EQ_);
      }
      setState(3386);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTriggerContext ------------------------------------------------------------------

MySQLStatementParser::CreateTriggerContext::CreateTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateTriggerContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTriggerContext::TRIGGER() {
  return getToken(MySQLStatementParser::TRIGGER, 0);
}

MySQLStatementParser::TriggerNameContext* MySQLStatementParser::CreateTriggerContext::triggerName() {
  return getRuleContext<MySQLStatementParser::TriggerNameContext>(0);
}

MySQLStatementParser::TriggerTimeContext* MySQLStatementParser::CreateTriggerContext::triggerTime() {
  return getRuleContext<MySQLStatementParser::TriggerTimeContext>(0);
}

MySQLStatementParser::TriggerEventContext* MySQLStatementParser::CreateTriggerContext::triggerEvent() {
  return getRuleContext<MySQLStatementParser::TriggerEventContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTriggerContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::CreateTriggerContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTriggerContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTriggerContext::EACH() {
  return getToken(MySQLStatementParser::EACH, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTriggerContext::ROW() {
  return getToken(MySQLStatementParser::ROW, 0);
}

MySQLStatementParser::RoutineBodyContext* MySQLStatementParser::CreateTriggerContext::routineBody() {
  return getRuleContext<MySQLStatementParser::RoutineBodyContext>(0);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::CreateTriggerContext::ownerStatement() {
  return getRuleContext<MySQLStatementParser::OwnerStatementContext>(0);
}

MySQLStatementParser::TriggerOrderContext* MySQLStatementParser::CreateTriggerContext::triggerOrder() {
  return getRuleContext<MySQLStatementParser::TriggerOrderContext>(0);
}


size_t MySQLStatementParser::CreateTriggerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateTrigger;
}

void MySQLStatementParser::CreateTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTrigger(this);
}

void MySQLStatementParser::CreateTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTrigger(this);
}


antlrcpp::Any MySQLStatementParser::CreateTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateTriggerContext* MySQLStatementParser::createTrigger() {
  CreateTriggerContext *_localctx = _tracker.createInstance<CreateTriggerContext>(_ctx, getState());
  enterRule(_localctx, 302, MySQLStatementParser::RuleCreateTrigger);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3389);
    match(MySQLStatementParser::CREATE);
    setState(3391);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFINER) {
      setState(3390);
      ownerStatement();
    }
    setState(3393);
    match(MySQLStatementParser::TRIGGER);
    setState(3394);
    triggerName();
    setState(3395);
    triggerTime();
    setState(3396);
    triggerEvent();
    setState(3397);
    match(MySQLStatementParser::ON);
    setState(3398);
    tableName();
    setState(3399);
    match(MySQLStatementParser::FOR);
    setState(3400);
    match(MySQLStatementParser::EACH);
    setState(3401);
    match(MySQLStatementParser::ROW);
    setState(3403);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx)) {
    case 1: {
      setState(3402);
      triggerOrder();
      break;
    }

    }
    setState(3405);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTriggerContext ------------------------------------------------------------------

MySQLStatementParser::DropTriggerContext::DropTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropTriggerContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropTriggerContext::TRIGGER() {
  return getToken(MySQLStatementParser::TRIGGER, 0);
}

MySQLStatementParser::TriggerNameContext* MySQLStatementParser::DropTriggerContext::triggerName() {
  return getRuleContext<MySQLStatementParser::TriggerNameContext>(0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::DropTriggerContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::DropTriggerContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DropTriggerContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::DropTriggerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropTrigger;
}

void MySQLStatementParser::DropTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTrigger(this);
}

void MySQLStatementParser::DropTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTrigger(this);
}


antlrcpp::Any MySQLStatementParser::DropTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropTriggerContext* MySQLStatementParser::dropTrigger() {
  DropTriggerContext *_localctx = _tracker.createInstance<DropTriggerContext>(_ctx, getState());
  enterRule(_localctx, 304, MySQLStatementParser::RuleDropTrigger);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3407);
    match(MySQLStatementParser::DROP);
    setState(3408);
    match(MySQLStatementParser::TRIGGER);
    setState(3410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(3409);
      existClause();
    }
    setState(3415);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
    case 1: {
      setState(3412);
      schemaName();
      setState(3413);
      match(MySQLStatementParser::DOT_);
      break;
    }

    }
    setState(3417);
    triggerName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameTableContext ------------------------------------------------------------------

MySQLStatementParser::RenameTableContext::RenameTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RenameTableContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

tree::TerminalNode* MySQLStatementParser::RenameTableContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

std::vector<MySQLStatementParser::TableNameContext *> MySQLStatementParser::RenameTableContext::tableName() {
  return getRuleContexts<MySQLStatementParser::TableNameContext>();
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::RenameTableContext::tableName(size_t i) {
  return getRuleContext<MySQLStatementParser::TableNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RenameTableContext::TO() {
  return getTokens(MySQLStatementParser::TO);
}

tree::TerminalNode* MySQLStatementParser::RenameTableContext::TO(size_t i) {
  return getToken(MySQLStatementParser::TO, i);
}


size_t MySQLStatementParser::RenameTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRenameTable;
}

void MySQLStatementParser::RenameTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameTable(this);
}

void MySQLStatementParser::RenameTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameTable(this);
}


antlrcpp::Any MySQLStatementParser::RenameTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRenameTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RenameTableContext* MySQLStatementParser::renameTable() {
  RenameTableContext *_localctx = _tracker.createInstance<RenameTableContext>(_ctx, getState());
  enterRule(_localctx, 306, MySQLStatementParser::RuleRenameTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3419);
    match(MySQLStatementParser::RENAME);
    setState(3420);
    match(MySQLStatementParser::TABLE);
    setState(3421);
    tableName();
    setState(3422);
    match(MySQLStatementParser::TO);
    setState(3423);
    tableName();
    setState(3430);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(3424);
      tableName();
      setState(3425);
      match(MySQLStatementParser::TO);
      setState(3426);
      tableName();
      setState(3432);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDefinitionClauseContext ------------------------------------------------------------------

MySQLStatementParser::CreateDefinitionClauseContext::CreateDefinitionClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateDefinitionClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::TableElementListContext* MySQLStatementParser::CreateDefinitionClauseContext::tableElementList() {
  return getRuleContext<MySQLStatementParser::TableElementListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateDefinitionClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::CreateDefinitionClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateDefinitionClause;
}

void MySQLStatementParser::CreateDefinitionClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDefinitionClause(this);
}

void MySQLStatementParser::CreateDefinitionClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDefinitionClause(this);
}


antlrcpp::Any MySQLStatementParser::CreateDefinitionClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateDefinitionClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateDefinitionClauseContext* MySQLStatementParser::createDefinitionClause() {
  CreateDefinitionClauseContext *_localctx = _tracker.createInstance<CreateDefinitionClauseContext>(_ctx, getState());
  enterRule(_localctx, 308, MySQLStatementParser::RuleCreateDefinitionClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3433);
    match(MySQLStatementParser::LP_);
    setState(3434);
    tableElementList();
    setState(3435);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnDefinitionContext ------------------------------------------------------------------

MySQLStatementParser::ColumnDefinitionContext::ColumnDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::FieldDefinitionContext* MySQLStatementParser::ColumnDefinitionContext::fieldDefinition() {
  return getRuleContext<MySQLStatementParser::FieldDefinitionContext>(0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ColumnDefinitionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::ReferenceDefinitionContext* MySQLStatementParser::ColumnDefinitionContext::referenceDefinition() {
  return getRuleContext<MySQLStatementParser::ReferenceDefinitionContext>(0);
}


size_t MySQLStatementParser::ColumnDefinitionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleColumnDefinition;
}

void MySQLStatementParser::ColumnDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnDefinition(this);
}

void MySQLStatementParser::ColumnDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnDefinition(this);
}


antlrcpp::Any MySQLStatementParser::ColumnDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitColumnDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ColumnDefinitionContext* MySQLStatementParser::columnDefinition() {
  ColumnDefinitionContext *_localctx = _tracker.createInstance<ColumnDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 310, MySQLStatementParser::RuleColumnDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3437);
    dynamic_cast<ColumnDefinitionContext *>(_localctx)->column_name = identifier();
    setState(3438);
    fieldDefinition();
    setState(3440);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::REFERENCES) {
      setState(3439);
      referenceDefinition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldDefinitionContext ------------------------------------------------------------------

MySQLStatementParser::FieldDefinitionContext::FieldDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::DataTypeContext* MySQLStatementParser::FieldDefinitionContext::dataType() {
  return getRuleContext<MySQLStatementParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FieldDefinitionContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

tree::TerminalNode* MySQLStatementParser::FieldDefinitionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::FieldDefinitionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FieldDefinitionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<MySQLStatementParser::ColumnAttributeContext *> MySQLStatementParser::FieldDefinitionContext::columnAttribute() {
  return getRuleContexts<MySQLStatementParser::ColumnAttributeContext>();
}

MySQLStatementParser::ColumnAttributeContext* MySQLStatementParser::FieldDefinitionContext::columnAttribute(size_t i) {
  return getRuleContext<MySQLStatementParser::ColumnAttributeContext>(i);
}

MySQLStatementParser::CollateClauseContext* MySQLStatementParser::FieldDefinitionContext::collateClause() {
  return getRuleContext<MySQLStatementParser::CollateClauseContext>(0);
}

MySQLStatementParser::GeneratedOptionContext* MySQLStatementParser::FieldDefinitionContext::generatedOption() {
  return getRuleContext<MySQLStatementParser::GeneratedOptionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FieldDefinitionContext::VIRTUAL() {
  return getToken(MySQLStatementParser::VIRTUAL, 0);
}

tree::TerminalNode* MySQLStatementParser::FieldDefinitionContext::STORED() {
  return getToken(MySQLStatementParser::STORED, 0);
}


size_t MySQLStatementParser::FieldDefinitionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFieldDefinition;
}

void MySQLStatementParser::FieldDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldDefinition(this);
}

void MySQLStatementParser::FieldDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldDefinition(this);
}


antlrcpp::Any MySQLStatementParser::FieldDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFieldDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FieldDefinitionContext* MySQLStatementParser::fieldDefinition() {
  FieldDefinitionContext *_localctx = _tracker.createInstance<FieldDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 312, MySQLStatementParser::RuleFieldDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3442);
    dataType();
    setState(3468);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx)) {
    case 1: {
      setState(3446);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3443);
          columnAttribute(); 
        }
        setState(3448);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx);
      }
      break;
    }

    case 2: {
      setState(3450);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::COLLATE) {
        setState(3449);
        collateClause();
      }
      setState(3453);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::GENERATED) {
        setState(3452);
        generatedOption();
      }
      setState(3455);
      match(MySQLStatementParser::AS);
      setState(3456);
      match(MySQLStatementParser::LP_);
      setState(3457);
      expr(0);
      setState(3458);
      match(MySQLStatementParser::RP_);
      setState(3460);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::STORED || _la == MySQLStatementParser::VIRTUAL) {
        setState(3459);
        dynamic_cast<FieldDefinitionContext *>(_localctx)->storedAttribute = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::STORED || _la == MySQLStatementParser::VIRTUAL)) {
          dynamic_cast<FieldDefinitionContext *>(_localctx)->storedAttribute = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(3465);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3462);
          columnAttribute(); 
        }
        setState(3467);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnAttributeContext ------------------------------------------------------------------

MySQLStatementParser::ColumnAttributeContext::ColumnAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::NULL() {
  return getToken(MySQLStatementParser::NULL, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::SECONDARY() {
  return getToken(MySQLStatementParser::SECONDARY, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

MySQLStatementParser::SignedLiteralContext* MySQLStatementParser::ColumnAttributeContext::signedLiteral() {
  return getRuleContext<MySQLStatementParser::SignedLiteralContext>(0);
}

MySQLStatementParser::NowContext* MySQLStatementParser::ColumnAttributeContext::now() {
  return getRuleContext<MySQLStatementParser::NowContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::ColumnAttributeContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::AUTO_INCREMENT() {
  return getToken(MySQLStatementParser::AUTO_INCREMENT, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::VALUE() {
  return getToken(MySQLStatementParser::VALUE, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::SERIAL() {
  return getToken(MySQLStatementParser::SERIAL, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::PRIMARY() {
  return getToken(MySQLStatementParser::PRIMARY, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::UNIQUE() {
  return getToken(MySQLStatementParser::UNIQUE, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::ColumnAttributeContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

MySQLStatementParser::CollateClauseContext* MySQLStatementParser::ColumnAttributeContext::collateClause() {
  return getRuleContext<MySQLStatementParser::CollateClauseContext>(0);
}

MySQLStatementParser::ColumnFormatContext* MySQLStatementParser::ColumnAttributeContext::columnFormat() {
  return getRuleContext<MySQLStatementParser::ColumnFormatContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::COLUMN_FORMAT() {
  return getToken(MySQLStatementParser::COLUMN_FORMAT, 0);
}

MySQLStatementParser::StorageMediaContext* MySQLStatementParser::ColumnAttributeContext::storageMedia() {
  return getRuleContext<MySQLStatementParser::StorageMediaContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::STORAGE() {
  return getToken(MySQLStatementParser::STORAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnAttributeContext::SRID() {
  return getToken(MySQLStatementParser::SRID, 0);
}

MySQLStatementParser::CheckConstraintContext* MySQLStatementParser::ColumnAttributeContext::checkConstraint() {
  return getRuleContext<MySQLStatementParser::CheckConstraintContext>(0);
}

MySQLStatementParser::ConstraintNameContext* MySQLStatementParser::ColumnAttributeContext::constraintName() {
  return getRuleContext<MySQLStatementParser::ConstraintNameContext>(0);
}

MySQLStatementParser::ConstraintEnforcementContext* MySQLStatementParser::ColumnAttributeContext::constraintEnforcement() {
  return getRuleContext<MySQLStatementParser::ConstraintEnforcementContext>(0);
}


size_t MySQLStatementParser::ColumnAttributeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleColumnAttribute;
}

void MySQLStatementParser::ColumnAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnAttribute(this);
}

void MySQLStatementParser::ColumnAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnAttribute(this);
}


antlrcpp::Any MySQLStatementParser::ColumnAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitColumnAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ColumnAttributeContext* MySQLStatementParser::columnAttribute() {
  ColumnAttributeContext *_localctx = _tracker.createInstance<ColumnAttributeContext>(_ctx, getState());
  enterRule(_localctx, 314, MySQLStatementParser::RuleColumnAttribute);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3514);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3471);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(3470);
        match(MySQLStatementParser::NOT);
      }
      setState(3473);
      match(MySQLStatementParser::NULL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3474);
      match(MySQLStatementParser::NOT);
      setState(3475);
      match(MySQLStatementParser::SECONDARY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3476);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::DEFAULT);
      setState(3483);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::DATE:
        case MySQLStatementParser::FALSE:
        case MySQLStatementParser::NULL:
        case MySQLStatementParser::TIME:
        case MySQLStatementParser::TIMESTAMP:
        case MySQLStatementParser::TRUE:
        case MySQLStatementParser::PLUS_:
        case MySQLStatementParser::MINUS_:
        case MySQLStatementParser::SINGLE_QUOTED_TEXT:
        case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
        case MySQLStatementParser::NCHAR_TEXT:
        case MySQLStatementParser::UNDERSCORE_CHARSET:
        case MySQLStatementParser::NUMBER_:
        case MySQLStatementParser::HEX_DIGIT_:
        case MySQLStatementParser::BIT_NUM_: {
          setState(3477);
          signedLiteral();
          break;
        }

        case MySQLStatementParser::CURRENT_TIMESTAMP:
        case MySQLStatementParser::LOCALTIME:
        case MySQLStatementParser::LOCALTIMESTAMP: {
          setState(3478);
          now();
          break;
        }

        case MySQLStatementParser::LP_: {
          setState(3479);
          match(MySQLStatementParser::LP_);
          setState(3480);
          expr(0);
          setState(3481);
          match(MySQLStatementParser::RP_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3485);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::ON);
      setState(3486);
      match(MySQLStatementParser::UPDATE);
      setState(3487);
      now();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3488);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::AUTO_INCREMENT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3489);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::SERIAL);
      setState(3490);
      match(MySQLStatementParser::DEFAULT);
      setState(3491);
      match(MySQLStatementParser::VALUE);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3493);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::PRIMARY) {
        setState(3492);
        match(MySQLStatementParser::PRIMARY);
      }
      setState(3495);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::KEY);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3496);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::UNIQUE);
      setState(3498);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
      case 1: {
        setState(3497);
        match(MySQLStatementParser::KEY);
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3500);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::COMMENT);
      setState(3501);
      string_();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3502);
      collateClause();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3503);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::COLUMN_FORMAT);
      setState(3504);
      columnFormat();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3505);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::STORAGE);
      setState(3506);
      storageMedia();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3507);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLStatementParser::SRID);
      setState(3508);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3510);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::CONSTRAINT) {
        setState(3509);
        constraintName();
      }
      setState(3512);
      checkConstraint();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3513);
      constraintEnforcement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckConstraintContext ------------------------------------------------------------------

MySQLStatementParser::CheckConstraintContext::CheckConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CheckConstraintContext::CHECK() {
  return getToken(MySQLStatementParser::CHECK, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckConstraintContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CheckConstraintContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CheckConstraintContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::CheckConstraintContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCheckConstraint;
}

void MySQLStatementParser::CheckConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckConstraint(this);
}

void MySQLStatementParser::CheckConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckConstraint(this);
}


antlrcpp::Any MySQLStatementParser::CheckConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCheckConstraint(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CheckConstraintContext* MySQLStatementParser::checkConstraint() {
  CheckConstraintContext *_localctx = _tracker.createInstance<CheckConstraintContext>(_ctx, getState());
  enterRule(_localctx, 316, MySQLStatementParser::RuleCheckConstraint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3516);
    match(MySQLStatementParser::CHECK);
    setState(3517);
    match(MySQLStatementParser::LP_);
    setState(3518);
    expr(0);
    setState(3519);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintEnforcementContext ------------------------------------------------------------------

MySQLStatementParser::ConstraintEnforcementContext::ConstraintEnforcementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConstraintEnforcementContext::ENFORCED() {
  return getToken(MySQLStatementParser::ENFORCED, 0);
}

tree::TerminalNode* MySQLStatementParser::ConstraintEnforcementContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}


size_t MySQLStatementParser::ConstraintEnforcementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConstraintEnforcement;
}

void MySQLStatementParser::ConstraintEnforcementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintEnforcement(this);
}

void MySQLStatementParser::ConstraintEnforcementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintEnforcement(this);
}


antlrcpp::Any MySQLStatementParser::ConstraintEnforcementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConstraintEnforcement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConstraintEnforcementContext* MySQLStatementParser::constraintEnforcement() {
  ConstraintEnforcementContext *_localctx = _tracker.createInstance<ConstraintEnforcementContext>(_ctx, getState());
  enterRule(_localctx, 318, MySQLStatementParser::RuleConstraintEnforcement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3522);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::NOT) {
      setState(3521);
      match(MySQLStatementParser::NOT);
    }
    setState(3524);
    match(MySQLStatementParser::ENFORCED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratedOptionContext ------------------------------------------------------------------

MySQLStatementParser::GeneratedOptionContext::GeneratedOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::GeneratedOptionContext::GENERATED() {
  return getToken(MySQLStatementParser::GENERATED, 0);
}

tree::TerminalNode* MySQLStatementParser::GeneratedOptionContext::ALWAYS() {
  return getToken(MySQLStatementParser::ALWAYS, 0);
}


size_t MySQLStatementParser::GeneratedOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGeneratedOption;
}

void MySQLStatementParser::GeneratedOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratedOption(this);
}

void MySQLStatementParser::GeneratedOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratedOption(this);
}


antlrcpp::Any MySQLStatementParser::GeneratedOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGeneratedOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GeneratedOptionContext* MySQLStatementParser::generatedOption() {
  GeneratedOptionContext *_localctx = _tracker.createInstance<GeneratedOptionContext>(_ctx, getState());
  enterRule(_localctx, 320, MySQLStatementParser::RuleGeneratedOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3526);
    match(MySQLStatementParser::GENERATED);
    setState(3527);
    match(MySQLStatementParser::ALWAYS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferenceDefinitionContext ------------------------------------------------------------------

MySQLStatementParser::ReferenceDefinitionContext::ReferenceDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ReferenceDefinitionContext::REFERENCES() {
  return getToken(MySQLStatementParser::REFERENCES, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::ReferenceDefinitionContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::KeyPartsContext* MySQLStatementParser::ReferenceDefinitionContext::keyParts() {
  return getRuleContext<MySQLStatementParser::KeyPartsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceDefinitionContext::MATCH() {
  return getToken(MySQLStatementParser::MATCH, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceDefinitionContext::FULL() {
  return getToken(MySQLStatementParser::FULL, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceDefinitionContext::PARTIAL() {
  return getToken(MySQLStatementParser::PARTIAL, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceDefinitionContext::SIMPLE() {
  return getToken(MySQLStatementParser::SIMPLE, 0);
}

MySQLStatementParser::OnUpdateDeleteContext* MySQLStatementParser::ReferenceDefinitionContext::onUpdateDelete() {
  return getRuleContext<MySQLStatementParser::OnUpdateDeleteContext>(0);
}


size_t MySQLStatementParser::ReferenceDefinitionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReferenceDefinition;
}

void MySQLStatementParser::ReferenceDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferenceDefinition(this);
}

void MySQLStatementParser::ReferenceDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferenceDefinition(this);
}


antlrcpp::Any MySQLStatementParser::ReferenceDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReferenceDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReferenceDefinitionContext* MySQLStatementParser::referenceDefinition() {
  ReferenceDefinitionContext *_localctx = _tracker.createInstance<ReferenceDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 322, MySQLStatementParser::RuleReferenceDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3529);
    match(MySQLStatementParser::REFERENCES);
    setState(3530);
    tableName();
    setState(3531);
    keyParts();
    setState(3538);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx)) {
    case 1: {
      setState(3532);
      match(MySQLStatementParser::MATCH);
      setState(3533);
      match(MySQLStatementParser::FULL);
      break;
    }

    case 2: {
      setState(3534);
      match(MySQLStatementParser::MATCH);
      setState(3535);
      match(MySQLStatementParser::PARTIAL);
      break;
    }

    case 3: {
      setState(3536);
      match(MySQLStatementParser::MATCH);
      setState(3537);
      match(MySQLStatementParser::SIMPLE);
      break;
    }

    }
    setState(3541);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ON) {
      setState(3540);
      onUpdateDelete();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnUpdateDeleteContext ------------------------------------------------------------------

MySQLStatementParser::OnUpdateDeleteContext::OnUpdateDeleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::OnUpdateDeleteContext::ON() {
  return getTokens(MySQLStatementParser::ON);
}

tree::TerminalNode* MySQLStatementParser::OnUpdateDeleteContext::ON(size_t i) {
  return getToken(MySQLStatementParser::ON, i);
}

tree::TerminalNode* MySQLStatementParser::OnUpdateDeleteContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

std::vector<MySQLStatementParser::ReferenceOptionContext *> MySQLStatementParser::OnUpdateDeleteContext::referenceOption() {
  return getRuleContexts<MySQLStatementParser::ReferenceOptionContext>();
}

MySQLStatementParser::ReferenceOptionContext* MySQLStatementParser::OnUpdateDeleteContext::referenceOption(size_t i) {
  return getRuleContext<MySQLStatementParser::ReferenceOptionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::OnUpdateDeleteContext::DELETE() {
  return getToken(MySQLStatementParser::DELETE, 0);
}


size_t MySQLStatementParser::OnUpdateDeleteContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOnUpdateDelete;
}

void MySQLStatementParser::OnUpdateDeleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnUpdateDelete(this);
}

void MySQLStatementParser::OnUpdateDeleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnUpdateDelete(this);
}


antlrcpp::Any MySQLStatementParser::OnUpdateDeleteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOnUpdateDelete(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OnUpdateDeleteContext* MySQLStatementParser::onUpdateDelete() {
  OnUpdateDeleteContext *_localctx = _tracker.createInstance<OnUpdateDeleteContext>(_ctx, getState());
  enterRule(_localctx, 324, MySQLStatementParser::RuleOnUpdateDelete);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3559);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3543);
      match(MySQLStatementParser::ON);
      setState(3544);
      match(MySQLStatementParser::UPDATE);
      setState(3545);
      referenceOption();
      setState(3549);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::ON) {
        setState(3546);
        match(MySQLStatementParser::ON);
        setState(3547);
        match(MySQLStatementParser::DELETE);
        setState(3548);
        referenceOption();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3551);
      match(MySQLStatementParser::ON);
      setState(3552);
      match(MySQLStatementParser::DELETE);
      setState(3553);
      referenceOption();
      setState(3557);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::ON) {
        setState(3554);
        match(MySQLStatementParser::ON);
        setState(3555);
        match(MySQLStatementParser::UPDATE);
        setState(3556);
        referenceOption();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferenceOptionContext ------------------------------------------------------------------

MySQLStatementParser::ReferenceOptionContext::ReferenceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ReferenceOptionContext::RESTRICT() {
  return getToken(MySQLStatementParser::RESTRICT, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceOptionContext::CASCADE() {
  return getToken(MySQLStatementParser::CASCADE, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceOptionContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceOptionContext::NULL() {
  return getToken(MySQLStatementParser::NULL, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceOptionContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceOptionContext::ACTION() {
  return getToken(MySQLStatementParser::ACTION, 0);
}

tree::TerminalNode* MySQLStatementParser::ReferenceOptionContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}


size_t MySQLStatementParser::ReferenceOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReferenceOption;
}

void MySQLStatementParser::ReferenceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferenceOption(this);
}

void MySQLStatementParser::ReferenceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferenceOption(this);
}


antlrcpp::Any MySQLStatementParser::ReferenceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReferenceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReferenceOptionContext* MySQLStatementParser::referenceOption() {
  ReferenceOptionContext *_localctx = _tracker.createInstance<ReferenceOptionContext>(_ctx, getState());
  enterRule(_localctx, 326, MySQLStatementParser::RuleReferenceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3569);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 420, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3561);
      match(MySQLStatementParser::RESTRICT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3562);
      match(MySQLStatementParser::CASCADE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3563);
      match(MySQLStatementParser::SET);
      setState(3564);
      match(MySQLStatementParser::NULL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3565);
      match(MySQLStatementParser::NO);
      setState(3566);
      match(MySQLStatementParser::ACTION);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3567);
      match(MySQLStatementParser::SET);
      setState(3568);
      match(MySQLStatementParser::DEFAULT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameAndTypeContext ------------------------------------------------------------------

MySQLStatementParser::IndexNameAndTypeContext::IndexNameAndTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::IndexNameAndTypeContext::indexName() {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(0);
}

MySQLStatementParser::IndexTypeClauseContext* MySQLStatementParser::IndexNameAndTypeContext::indexTypeClause() {
  return getRuleContext<MySQLStatementParser::IndexTypeClauseContext>(0);
}


size_t MySQLStatementParser::IndexNameAndTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIndexNameAndType;
}

void MySQLStatementParser::IndexNameAndTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexNameAndType(this);
}

void MySQLStatementParser::IndexNameAndTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexNameAndType(this);
}


antlrcpp::Any MySQLStatementParser::IndexNameAndTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIndexNameAndType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IndexNameAndTypeContext* MySQLStatementParser::indexNameAndType() {
  IndexNameAndTypeContext *_localctx = _tracker.createInstance<IndexNameAndTypeContext>(_ctx, getState());
  enterRule(_localctx, 328, MySQLStatementParser::RuleIndexNameAndType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3571);
    indexName();
    setState(3573);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::TYPE

    || _la == MySQLStatementParser::USING) {
      setState(3572);
      indexTypeClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeContext ------------------------------------------------------------------

MySQLStatementParser::IndexTypeContext::IndexTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IndexTypeContext::BTREE() {
  return getToken(MySQLStatementParser::BTREE, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexTypeContext::RTREE() {
  return getToken(MySQLStatementParser::RTREE, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexTypeContext::HASH() {
  return getToken(MySQLStatementParser::HASH, 0);
}


size_t MySQLStatementParser::IndexTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIndexType;
}

void MySQLStatementParser::IndexTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexType(this);
}

void MySQLStatementParser::IndexTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexType(this);
}


antlrcpp::Any MySQLStatementParser::IndexTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIndexType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IndexTypeContext* MySQLStatementParser::indexType() {
  IndexTypeContext *_localctx = _tracker.createInstance<IndexTypeContext>(_ctx, getState());
  enterRule(_localctx, 330, MySQLStatementParser::RuleIndexType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3575);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::BTREE || _la == MySQLStatementParser::HASH || _la == MySQLStatementParser::RTREE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeClauseContext ------------------------------------------------------------------

MySQLStatementParser::IndexTypeClauseContext::IndexTypeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IndexTypeContext* MySQLStatementParser::IndexTypeClauseContext::indexType() {
  return getRuleContext<MySQLStatementParser::IndexTypeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::IndexTypeClauseContext::USING() {
  return getToken(MySQLStatementParser::USING, 0);
}

tree::TerminalNode* MySQLStatementParser::IndexTypeClauseContext::TYPE() {
  return getToken(MySQLStatementParser::TYPE, 0);
}


size_t MySQLStatementParser::IndexTypeClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIndexTypeClause;
}

void MySQLStatementParser::IndexTypeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexTypeClause(this);
}

void MySQLStatementParser::IndexTypeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexTypeClause(this);
}


antlrcpp::Any MySQLStatementParser::IndexTypeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIndexTypeClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IndexTypeClauseContext* MySQLStatementParser::indexTypeClause() {
  IndexTypeClauseContext *_localctx = _tracker.createInstance<IndexTypeClauseContext>(_ctx, getState());
  enterRule(_localctx, 332, MySQLStatementParser::RuleIndexTypeClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3577);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::TYPE

    || _la == MySQLStatementParser::USING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3578);
    indexType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartsContext ------------------------------------------------------------------

MySQLStatementParser::KeyPartsContext::KeyPartsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::KeyPartsContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::KeyPartContext *> MySQLStatementParser::KeyPartsContext::keyPart() {
  return getRuleContexts<MySQLStatementParser::KeyPartContext>();
}

MySQLStatementParser::KeyPartContext* MySQLStatementParser::KeyPartsContext::keyPart(size_t i) {
  return getRuleContext<MySQLStatementParser::KeyPartContext>(i);
}

tree::TerminalNode* MySQLStatementParser::KeyPartsContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::KeyPartsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::KeyPartsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::KeyPartsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleKeyParts;
}

void MySQLStatementParser::KeyPartsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyParts(this);
}

void MySQLStatementParser::KeyPartsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyParts(this);
}


antlrcpp::Any MySQLStatementParser::KeyPartsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitKeyParts(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::KeyPartsContext* MySQLStatementParser::keyParts() {
  KeyPartsContext *_localctx = _tracker.createInstance<KeyPartsContext>(_ctx, getState());
  enterRule(_localctx, 334, MySQLStatementParser::RuleKeyParts);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3580);
    match(MySQLStatementParser::LP_);
    setState(3581);
    keyPart();
    setState(3586);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(3582);
      match(MySQLStatementParser::COMMA_);
      setState(3583);
      keyPart();
      setState(3588);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3589);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartContext ------------------------------------------------------------------

MySQLStatementParser::KeyPartContext::KeyPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ColumnNameContext* MySQLStatementParser::KeyPartContext::columnName() {
  return getRuleContext<MySQLStatementParser::ColumnNameContext>(0);
}

MySQLStatementParser::FieldLengthContext* MySQLStatementParser::KeyPartContext::fieldLength() {
  return getRuleContext<MySQLStatementParser::FieldLengthContext>(0);
}

MySQLStatementParser::DirectionContext* MySQLStatementParser::KeyPartContext::direction() {
  return getRuleContext<MySQLStatementParser::DirectionContext>(0);
}


size_t MySQLStatementParser::KeyPartContext::getRuleIndex() const {
  return MySQLStatementParser::RuleKeyPart;
}

void MySQLStatementParser::KeyPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPart(this);
}

void MySQLStatementParser::KeyPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPart(this);
}


antlrcpp::Any MySQLStatementParser::KeyPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitKeyPart(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::KeyPartContext* MySQLStatementParser::keyPart() {
  KeyPartContext *_localctx = _tracker.createInstance<KeyPartContext>(_ctx, getState());
  enterRule(_localctx, 336, MySQLStatementParser::RuleKeyPart);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3591);
    columnName();
    setState(3593);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(3592);
      fieldLength();
    }
    setState(3596);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ASC || _la == MySQLStatementParser::DESC) {
      setState(3595);
      direction();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartWithExpressionContext ------------------------------------------------------------------

MySQLStatementParser::KeyPartWithExpressionContext::KeyPartWithExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::KeyPartContext* MySQLStatementParser::KeyPartWithExpressionContext::keyPart() {
  return getRuleContext<MySQLStatementParser::KeyPartContext>(0);
}

tree::TerminalNode* MySQLStatementParser::KeyPartWithExpressionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::KeyPartWithExpressionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::KeyPartWithExpressionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::DirectionContext* MySQLStatementParser::KeyPartWithExpressionContext::direction() {
  return getRuleContext<MySQLStatementParser::DirectionContext>(0);
}


size_t MySQLStatementParser::KeyPartWithExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleKeyPartWithExpression;
}

void MySQLStatementParser::KeyPartWithExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPartWithExpression(this);
}

void MySQLStatementParser::KeyPartWithExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPartWithExpression(this);
}


antlrcpp::Any MySQLStatementParser::KeyPartWithExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitKeyPartWithExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::KeyPartWithExpressionContext* MySQLStatementParser::keyPartWithExpression() {
  KeyPartWithExpressionContext *_localctx = _tracker.createInstance<KeyPartWithExpressionContext>(_ctx, getState());
  enterRule(_localctx, 338, MySQLStatementParser::RuleKeyPartWithExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3605);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(3598);
        keyPart();
        break;
      }

      case MySQLStatementParser::LP_: {
        enterOuterAlt(_localctx, 2);
        setState(3599);
        match(MySQLStatementParser::LP_);
        setState(3600);
        expr(0);
        setState(3601);
        match(MySQLStatementParser::RP_);
        setState(3603);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ASC || _la == MySQLStatementParser::DESC) {
          setState(3602);
          direction();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListWithExpressionContext ------------------------------------------------------------------

MySQLStatementParser::KeyListWithExpressionContext::KeyListWithExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::KeyListWithExpressionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::KeyPartWithExpressionContext *> MySQLStatementParser::KeyListWithExpressionContext::keyPartWithExpression() {
  return getRuleContexts<MySQLStatementParser::KeyPartWithExpressionContext>();
}

MySQLStatementParser::KeyPartWithExpressionContext* MySQLStatementParser::KeyListWithExpressionContext::keyPartWithExpression(size_t i) {
  return getRuleContext<MySQLStatementParser::KeyPartWithExpressionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::KeyListWithExpressionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::KeyListWithExpressionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::KeyListWithExpressionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::KeyListWithExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleKeyListWithExpression;
}

void MySQLStatementParser::KeyListWithExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyListWithExpression(this);
}

void MySQLStatementParser::KeyListWithExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyListWithExpression(this);
}


antlrcpp::Any MySQLStatementParser::KeyListWithExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitKeyListWithExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::KeyListWithExpressionContext* MySQLStatementParser::keyListWithExpression() {
  KeyListWithExpressionContext *_localctx = _tracker.createInstance<KeyListWithExpressionContext>(_ctx, getState());
  enterRule(_localctx, 340, MySQLStatementParser::RuleKeyListWithExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3607);
    match(MySQLStatementParser::LP_);
    setState(3608);
    keyPartWithExpression();
    setState(3613);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(3609);
      match(MySQLStatementParser::COMMA_);
      setState(3610);
      keyPartWithExpression();
      setState(3615);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3616);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexOptionContext ------------------------------------------------------------------

MySQLStatementParser::IndexOptionContext::IndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CommonIndexOptionContext* MySQLStatementParser::IndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLStatementParser::CommonIndexOptionContext>(0);
}

MySQLStatementParser::IndexTypeClauseContext* MySQLStatementParser::IndexOptionContext::indexTypeClause() {
  return getRuleContext<MySQLStatementParser::IndexTypeClauseContext>(0);
}


size_t MySQLStatementParser::IndexOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIndexOption;
}

void MySQLStatementParser::IndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexOption(this);
}

void MySQLStatementParser::IndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexOption(this);
}


antlrcpp::Any MySQLStatementParser::IndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IndexOptionContext* MySQLStatementParser::indexOption() {
  IndexOptionContext *_localctx = _tracker.createInstance<IndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 342, MySQLStatementParser::RuleIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3620);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::VISIBLE: {
        enterOuterAlt(_localctx, 1);
        setState(3618);
        commonIndexOption();
        break;
      }

      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::USING: {
        enterOuterAlt(_localctx, 2);
        setState(3619);
        indexTypeClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonIndexOptionContext ------------------------------------------------------------------

MySQLStatementParser::CommonIndexOptionContext::CommonIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CommonIndexOptionContext::KEY_BLOCK_SIZE() {
  return getToken(MySQLStatementParser::KEY_BLOCK_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::CommonIndexOptionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::CommonIndexOptionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

tree::TerminalNode* MySQLStatementParser::CommonIndexOptionContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::CommonIndexOptionContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}

MySQLStatementParser::VisibilityContext* MySQLStatementParser::CommonIndexOptionContext::visibility() {
  return getRuleContext<MySQLStatementParser::VisibilityContext>(0);
}


size_t MySQLStatementParser::CommonIndexOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCommonIndexOption;
}

void MySQLStatementParser::CommonIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonIndexOption(this);
}

void MySQLStatementParser::CommonIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonIndexOption(this);
}


antlrcpp::Any MySQLStatementParser::CommonIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCommonIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CommonIndexOptionContext* MySQLStatementParser::commonIndexOption() {
  CommonIndexOptionContext *_localctx = _tracker.createInstance<CommonIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 344, MySQLStatementParser::RuleCommonIndexOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3630);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::KEY_BLOCK_SIZE: {
        enterOuterAlt(_localctx, 1);
        setState(3622);
        match(MySQLStatementParser::KEY_BLOCK_SIZE);
        setState(3624);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3623);
          match(MySQLStatementParser::EQ_);
        }
        setState(3626);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::COMMENT: {
        enterOuterAlt(_localctx, 2);
        setState(3627);
        match(MySQLStatementParser::COMMENT);
        setState(3628);
        stringLiterals();
        break;
      }

      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::VISIBLE: {
        enterOuterAlt(_localctx, 3);
        setState(3629);
        visibility();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VisibilityContext ------------------------------------------------------------------

MySQLStatementParser::VisibilityContext::VisibilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::VisibilityContext::VISIBLE() {
  return getToken(MySQLStatementParser::VISIBLE, 0);
}

tree::TerminalNode* MySQLStatementParser::VisibilityContext::INVISIBLE() {
  return getToken(MySQLStatementParser::INVISIBLE, 0);
}


size_t MySQLStatementParser::VisibilityContext::getRuleIndex() const {
  return MySQLStatementParser::RuleVisibility;
}

void MySQLStatementParser::VisibilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVisibility(this);
}

void MySQLStatementParser::VisibilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVisibility(this);
}


antlrcpp::Any MySQLStatementParser::VisibilityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitVisibility(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::VisibilityContext* MySQLStatementParser::visibility() {
  VisibilityContext *_localctx = _tracker.createInstance<VisibilityContext>(_ctx, getState());
  enterRule(_localctx, 346, MySQLStatementParser::RuleVisibility);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3632);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::INVISIBLE || _la == MySQLStatementParser::VISIBLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateLikeClauseContext ------------------------------------------------------------------

MySQLStatementParser::CreateLikeClauseContext::CreateLikeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateLikeClauseContext::LIKE() {
  return getToken(MySQLStatementParser::LIKE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::CreateLikeClauseContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateLikeClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateLikeClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::CreateLikeClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateLikeClause;
}

void MySQLStatementParser::CreateLikeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateLikeClause(this);
}

void MySQLStatementParser::CreateLikeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateLikeClause(this);
}


antlrcpp::Any MySQLStatementParser::CreateLikeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateLikeClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateLikeClauseContext* MySQLStatementParser::createLikeClause() {
  CreateLikeClauseContext *_localctx = _tracker.createInstance<CreateLikeClauseContext>(_ctx, getState());
  enterRule(_localctx, 348, MySQLStatementParser::RuleCreateLikeClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3635);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(3634);
      match(MySQLStatementParser::LP_);
    }
    setState(3637);
    match(MySQLStatementParser::LIKE);
    setState(3638);
    tableName();
    setState(3640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RP_) {
      setState(3639);
      match(MySQLStatementParser::RP_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::CreateIndexSpecificationContext::CreateIndexSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateIndexSpecificationContext::UNIQUE() {
  return getToken(MySQLStatementParser::UNIQUE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateIndexSpecificationContext::FULLTEXT() {
  return getToken(MySQLStatementParser::FULLTEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateIndexSpecificationContext::SPATIAL() {
  return getToken(MySQLStatementParser::SPATIAL, 0);
}


size_t MySQLStatementParser::CreateIndexSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateIndexSpecification;
}

void MySQLStatementParser::CreateIndexSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndexSpecification(this);
}

void MySQLStatementParser::CreateIndexSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndexSpecification(this);
}


antlrcpp::Any MySQLStatementParser::CreateIndexSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateIndexSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateIndexSpecificationContext* MySQLStatementParser::createIndexSpecification() {
  CreateIndexSpecificationContext *_localctx = _tracker.createInstance<CreateIndexSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 350, MySQLStatementParser::RuleCreateIndexSpecification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3642);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FULLTEXT || _la == MySQLStatementParser::SPATIAL || _la == MySQLStatementParser::UNIQUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsContext ------------------------------------------------------------------

MySQLStatementParser::CreateTableOptionsContext::CreateTableOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::CreateTableOptionContext *> MySQLStatementParser::CreateTableOptionsContext::createTableOption() {
  return getRuleContexts<MySQLStatementParser::CreateTableOptionContext>();
}

MySQLStatementParser::CreateTableOptionContext* MySQLStatementParser::CreateTableOptionsContext::createTableOption(size_t i) {
  return getRuleContext<MySQLStatementParser::CreateTableOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateTableOptionsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::CreateTableOptionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateTableOptions;
}

void MySQLStatementParser::CreateTableOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptions(this);
}

void MySQLStatementParser::CreateTableOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptions(this);
}


antlrcpp::Any MySQLStatementParser::CreateTableOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateTableOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateTableOptionsContext* MySQLStatementParser::createTableOptions() {
  CreateTableOptionsContext *_localctx = _tracker.createInstance<CreateTableOptionsContext>(_ctx, getState());
  enterRule(_localctx, 352, MySQLStatementParser::RuleCreateTableOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3644);
    createTableOption();
    setState(3651);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3646);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::COMMA_) {
          setState(3645);
          match(MySQLStatementParser::COMMA_);
        }
        setState(3648);
        createTableOption(); 
      }
      setState(3653);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionContext ------------------------------------------------------------------

MySQLStatementParser::CreateTableOptionContext::CreateTableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::EngineRefContext* MySQLStatementParser::CreateTableOptionContext::engineRef() {
  return getRuleContext<MySQLStatementParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::SECONDARY_ENGINE() {
  return getToken(MySQLStatementParser::SECONDARY_ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::NULL() {
  return getToken(MySQLStatementParser::NULL, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::CreateTableOptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CreateTableOptionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::MAX_ROWS() {
  return getToken(MySQLStatementParser::MAX_ROWS, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::MIN_ROWS() {
  return getToken(MySQLStatementParser::MIN_ROWS, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::AVG_ROW_LENGTH() {
  return getToken(MySQLStatementParser::AVG_ROW_LENGTH, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

MySQLStatementParser::TextStringContext* MySQLStatementParser::CreateTableOptionContext::textString() {
  return getRuleContext<MySQLStatementParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::COMPRESSION() {
  return getToken(MySQLStatementParser::COMPRESSION, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::ENCRYPTION() {
  return getToken(MySQLStatementParser::ENCRYPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::AUTO_INCREMENT() {
  return getToken(MySQLStatementParser::AUTO_INCREMENT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::PACK_KEYS() {
  return getToken(MySQLStatementParser::PACK_KEYS, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::STATS_AUTO_RECALC() {
  return getToken(MySQLStatementParser::STATS_AUTO_RECALC, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::STATS_PERSISTENT() {
  return getToken(MySQLStatementParser::STATS_PERSISTENT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::STATS_SAMPLE_PAGES() {
  return getToken(MySQLStatementParser::STATS_SAMPLE_PAGES, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::CHECKSUM() {
  return getToken(MySQLStatementParser::CHECKSUM, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::TABLE_CHECKSUM() {
  return getToken(MySQLStatementParser::TABLE_CHECKSUM, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::DELAY_KEY_WRITE() {
  return getToken(MySQLStatementParser::DELAY_KEY_WRITE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::ROW_FORMAT() {
  return getToken(MySQLStatementParser::ROW_FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::DYNAMIC() {
  return getToken(MySQLStatementParser::DYNAMIC, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::FIXED() {
  return getToken(MySQLStatementParser::FIXED, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::COMPRESSED() {
  return getToken(MySQLStatementParser::COMPRESSED, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::REDUNDANT() {
  return getToken(MySQLStatementParser::REDUNDANT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::COMPACT() {
  return getToken(MySQLStatementParser::COMPACT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::CreateTableOptionContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::UNION() {
  return getToken(MySQLStatementParser::UNION, 0);
}

MySQLStatementParser::DefaultCharsetContext* MySQLStatementParser::CreateTableOptionContext::defaultCharset() {
  return getRuleContext<MySQLStatementParser::DefaultCharsetContext>(0);
}

MySQLStatementParser::DefaultCollationContext* MySQLStatementParser::CreateTableOptionContext::defaultCollation() {
  return getRuleContext<MySQLStatementParser::DefaultCollationContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::INSERT_METHOD() {
  return getToken(MySQLStatementParser::INSERT_METHOD, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::FIRST() {
  return getToken(MySQLStatementParser::FIRST, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::LAST() {
  return getToken(MySQLStatementParser::LAST, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::DIRECTORY() {
  return getToken(MySQLStatementParser::DIRECTORY, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::DATA() {
  return getToken(MySQLStatementParser::DATA, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::STORAGE() {
  return getToken(MySQLStatementParser::STORAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::DISK() {
  return getToken(MySQLStatementParser::DISK, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::MEMORY() {
  return getToken(MySQLStatementParser::MEMORY, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::CONNECTION() {
  return getToken(MySQLStatementParser::CONNECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::KEY_BLOCK_SIZE() {
  return getToken(MySQLStatementParser::KEY_BLOCK_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::ENGINE_ATTRIBUTE() {
  return getToken(MySQLStatementParser::ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateTableOptionContext::SECONDARY_ENGINE_ATTRIBUTE() {
  return getToken(MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
}


size_t MySQLStatementParser::CreateTableOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateTableOption;
}

void MySQLStatementParser::CreateTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOption(this);
}

void MySQLStatementParser::CreateTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOption(this);
}


antlrcpp::Any MySQLStatementParser::CreateTableOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateTableOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateTableOptionContext* MySQLStatementParser::createTableOption() {
  CreateTableOptionContext *_localctx = _tracker.createInstance<CreateTableOptionContext>(_ctx, getState());
  enterRule(_localctx, 354, MySQLStatementParser::RuleCreateTableOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 459, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3654);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::ENGINE);
      setState(3656);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3655);
        match(MySQLStatementParser::EQ_);
      }
      setState(3658);
      engineRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3659);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::SECONDARY_ENGINE);
      setState(3661);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3660);
        match(MySQLStatementParser::EQ_);
      }
      setState(3666);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
      case 1: {
        setState(3663);
        match(MySQLStatementParser::NULL);
        break;
      }

      case 2: {
        setState(3664);
        string_();
        break;
      }

      case 3: {
        setState(3665);
        identifier();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3668);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::MAX_ROWS);
      setState(3670);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3669);
        match(MySQLStatementParser::EQ_);
      }
      setState(3672);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3673);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::MIN_ROWS);
      setState(3675);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3674);
        match(MySQLStatementParser::EQ_);
      }
      setState(3677);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3678);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::AVG_ROW_LENGTH);
      setState(3680);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3679);
        match(MySQLStatementParser::EQ_);
      }
      setState(3682);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3683);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::PASSWORD);
      setState(3685);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3684);
        match(MySQLStatementParser::EQ_);
      }
      setState(3687);
      string_();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3688);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::COMMENT);
      setState(3690);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3689);
        match(MySQLStatementParser::EQ_);
      }
      setState(3692);
      string_();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3693);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::COMPRESSION);
      setState(3695);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3694);
        match(MySQLStatementParser::EQ_);
      }
      setState(3697);
      textString();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3698);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::ENCRYPTION);
      setState(3700);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3699);
        match(MySQLStatementParser::EQ_);
      }
      setState(3702);
      textString();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3703);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::AUTO_INCREMENT);
      setState(3705);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3704);
        match(MySQLStatementParser::EQ_);
      }
      setState(3707);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3708);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::PACK_KEYS);
      setState(3710);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3709);
        match(MySQLStatementParser::EQ_);
      }
      setState(3712);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->ternaryOption = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DEFAULT || _la == MySQLStatementParser::NUMBER_)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->ternaryOption = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3713);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 625) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 625)) & ((1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 625))
        | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 625))
        | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 625)))) != 0))) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3715);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3714);
        match(MySQLStatementParser::EQ_);
      }
      setState(3717);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->ternaryOption = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DEFAULT || _la == MySQLStatementParser::NUMBER_)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->ternaryOption = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3718);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::CHECKSUM || _la == MySQLStatementParser::TABLE_CHECKSUM)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3720);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3719);
        match(MySQLStatementParser::EQ_);
      }
      setState(3722);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3723);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::DELAY_KEY_WRITE);
      setState(3725);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3724);
        match(MySQLStatementParser::EQ_);
      }
      setState(3727);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3728);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::ROW_FORMAT);
      setState(3730);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3729);
        match(MySQLStatementParser::EQ_);
      }
      setState(3732);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->format = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 100) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 100)) & ((1ULL << (MySQLStatementParser::COMPACT - 100))
        | (1ULL << (MySQLStatementParser::COMPRESSED - 100))
        | (1ULL << (MySQLStatementParser::DEFAULT - 100)))) != 0) || _la == MySQLStatementParser::DYNAMIC

      || _la == MySQLStatementParser::FIXED || _la == MySQLStatementParser::REDUNDANT)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->format = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(3733);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::UNION);
      setState(3735);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3734);
        match(MySQLStatementParser::EQ_);
      }
      setState(3737);
      match(MySQLStatementParser::LP_);
      setState(3738);
      tableList();
      setState(3739);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(3741);
      defaultCharset();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(3742);
      defaultCollation();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(3743);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::INSERT_METHOD);
      setState(3745);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3744);
        match(MySQLStatementParser::EQ_);
      }
      setState(3747);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->method = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::FIRST || _la == MySQLStatementParser::LAST || _la == MySQLStatementParser::NO)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->method = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(3748);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::DATA);
      setState(3749);
      match(MySQLStatementParser::DIRECTORY);
      setState(3751);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3750);
        match(MySQLStatementParser::EQ_);
      }
      setState(3753);
      textString();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(3754);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::INDEX);
      setState(3755);
      match(MySQLStatementParser::DIRECTORY);
      setState(3757);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3756);
        match(MySQLStatementParser::EQ_);
      }
      setState(3759);
      textString();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(3760);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::TABLESPACE);
      setState(3762);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3761);
        match(MySQLStatementParser::EQ_);
      }
      setState(3764);
      identifier();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(3765);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::STORAGE);
      setState(3766);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DISK || _la == MySQLStatementParser::MEMORY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(3767);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::CONNECTION);
      setState(3769);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3768);
        match(MySQLStatementParser::EQ_);
      }
      setState(3771);
      textString();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(3772);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::KEY_BLOCK_SIZE);
      setState(3774);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3773);
        match(MySQLStatementParser::EQ_);
      }
      setState(3776);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(3777);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::ENGINE_ATTRIBUTE);
      setState(3779);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(3778);
        match(MySQLStatementParser::EQ_);
      }
      setState(3781);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->jsonAttribute = string_();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(3782);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE);
      setState(3783);
      match(MySQLStatementParser::EQ_);
      setState(3784);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->jsonAttribute = string_();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateSRSStatementContext ------------------------------------------------------------------

MySQLStatementParser::CreateSRSStatementContext::CreateSRSStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateSRSStatementContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateSRSStatementContext::OR() {
  return getToken(MySQLStatementParser::OR, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateSRSStatementContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateSRSStatementContext::SPATIAL() {
  return getToken(MySQLStatementParser::SPATIAL, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateSRSStatementContext::REFERENCE() {
  return getToken(MySQLStatementParser::REFERENCE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateSRSStatementContext::SYSTEM() {
  return getToken(MySQLStatementParser::SYSTEM, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateSRSStatementContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

std::vector<MySQLStatementParser::SrsAttributeContext *> MySQLStatementParser::CreateSRSStatementContext::srsAttribute() {
  return getRuleContexts<MySQLStatementParser::SrsAttributeContext>();
}

MySQLStatementParser::SrsAttributeContext* MySQLStatementParser::CreateSRSStatementContext::srsAttribute(size_t i) {
  return getRuleContext<MySQLStatementParser::SrsAttributeContext>(i);
}

MySQLStatementParser::NotExistClauseContext* MySQLStatementParser::CreateSRSStatementContext::notExistClause() {
  return getRuleContext<MySQLStatementParser::NotExistClauseContext>(0);
}


size_t MySQLStatementParser::CreateSRSStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateSRSStatement;
}

void MySQLStatementParser::CreateSRSStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateSRSStatement(this);
}

void MySQLStatementParser::CreateSRSStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateSRSStatement(this);
}


antlrcpp::Any MySQLStatementParser::CreateSRSStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateSRSStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateSRSStatementContext* MySQLStatementParser::createSRSStatement() {
  CreateSRSStatementContext *_localctx = _tracker.createInstance<CreateSRSStatementContext>(_ctx, getState());
  enterRule(_localctx, 356, MySQLStatementParser::RuleCreateSRSStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3814);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 463, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3787);
      match(MySQLStatementParser::CREATE);
      setState(3788);
      match(MySQLStatementParser::OR);
      setState(3789);
      match(MySQLStatementParser::REPLACE);
      setState(3790);
      match(MySQLStatementParser::SPATIAL);
      setState(3791);
      match(MySQLStatementParser::REFERENCE);
      setState(3792);
      match(MySQLStatementParser::SYSTEM);
      setState(3793);
      match(MySQLStatementParser::NUMBER_);
      setState(3797);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::DEFINITION

      || _la == MySQLStatementParser::DESCRIPTION || _la == MySQLStatementParser::NAME

      || _la == MySQLStatementParser::ORGANIZATION) {
        setState(3794);
        srsAttribute();
        setState(3799);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3800);
      match(MySQLStatementParser::CREATE);
      setState(3801);
      match(MySQLStatementParser::SPATIAL);
      setState(3802);
      match(MySQLStatementParser::REFERENCE);
      setState(3803);
      match(MySQLStatementParser::SYSTEM);
      setState(3805);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::IF) {
        setState(3804);
        notExistClause();
      }
      setState(3807);
      match(MySQLStatementParser::NUMBER_);
      setState(3811);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::DEFINITION

      || _la == MySQLStatementParser::DESCRIPTION || _la == MySQLStatementParser::NAME

      || _la == MySQLStatementParser::ORGANIZATION) {
        setState(3808);
        srsAttribute();
        setState(3813);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropSRSStatementContext ------------------------------------------------------------------

MySQLStatementParser::DropSRSStatementContext::DropSRSStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropSRSStatementContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropSRSStatementContext::SPATIAL() {
  return getToken(MySQLStatementParser::SPATIAL, 0);
}

tree::TerminalNode* MySQLStatementParser::DropSRSStatementContext::REFERENCE() {
  return getToken(MySQLStatementParser::REFERENCE, 0);
}

tree::TerminalNode* MySQLStatementParser::DropSRSStatementContext::SYSTEM() {
  return getToken(MySQLStatementParser::SYSTEM, 0);
}

tree::TerminalNode* MySQLStatementParser::DropSRSStatementContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

MySQLStatementParser::NotExistClauseContext* MySQLStatementParser::DropSRSStatementContext::notExistClause() {
  return getRuleContext<MySQLStatementParser::NotExistClauseContext>(0);
}


size_t MySQLStatementParser::DropSRSStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropSRSStatement;
}

void MySQLStatementParser::DropSRSStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropSRSStatement(this);
}

void MySQLStatementParser::DropSRSStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropSRSStatement(this);
}


antlrcpp::Any MySQLStatementParser::DropSRSStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropSRSStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropSRSStatementContext* MySQLStatementParser::dropSRSStatement() {
  DropSRSStatementContext *_localctx = _tracker.createInstance<DropSRSStatementContext>(_ctx, getState());
  enterRule(_localctx, 358, MySQLStatementParser::RuleDropSRSStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3816);
    match(MySQLStatementParser::DROP);
    setState(3817);
    match(MySQLStatementParser::SPATIAL);
    setState(3818);
    match(MySQLStatementParser::REFERENCE);
    setState(3819);
    match(MySQLStatementParser::SYSTEM);
    setState(3821);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(3820);
      notExistClause();
    }
    setState(3823);
    match(MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrsAttributeContext ------------------------------------------------------------------

MySQLStatementParser::SrsAttributeContext::SrsAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SrsAttributeContext::NAME() {
  return getToken(MySQLStatementParser::NAME, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::SrsAttributeContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::SrsAttributeContext::DEFINITION() {
  return getToken(MySQLStatementParser::DEFINITION, 0);
}

tree::TerminalNode* MySQLStatementParser::SrsAttributeContext::ORGANIZATION() {
  return getToken(MySQLStatementParser::ORGANIZATION, 0);
}

tree::TerminalNode* MySQLStatementParser::SrsAttributeContext::IDENTIFIED() {
  return getToken(MySQLStatementParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySQLStatementParser::SrsAttributeContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

tree::TerminalNode* MySQLStatementParser::SrsAttributeContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::SrsAttributeContext::DESCRIPTION() {
  return getToken(MySQLStatementParser::DESCRIPTION, 0);
}


size_t MySQLStatementParser::SrsAttributeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSrsAttribute;
}

void MySQLStatementParser::SrsAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrsAttribute(this);
}

void MySQLStatementParser::SrsAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrsAttribute(this);
}


antlrcpp::Any MySQLStatementParser::SrsAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSrsAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SrsAttributeContext* MySQLStatementParser::srsAttribute() {
  SrsAttributeContext *_localctx = _tracker.createInstance<SrsAttributeContext>(_ctx, getState());
  enterRule(_localctx, 360, MySQLStatementParser::RuleSrsAttribute);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3837);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(3825);
        match(MySQLStatementParser::NAME);
        setState(3826);
        string_();
        break;
      }

      case MySQLStatementParser::DEFINITION: {
        enterOuterAlt(_localctx, 2);
        setState(3827);
        match(MySQLStatementParser::DEFINITION);
        setState(3828);
        string_();
        break;
      }

      case MySQLStatementParser::ORGANIZATION: {
        enterOuterAlt(_localctx, 3);
        setState(3829);
        match(MySQLStatementParser::ORGANIZATION);
        setState(3830);
        string_();
        setState(3831);
        match(MySQLStatementParser::IDENTIFIED);
        setState(3832);
        match(MySQLStatementParser::BY);
        setState(3833);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::DESCRIPTION: {
        enterOuterAlt(_localctx, 4);
        setState(3835);
        match(MySQLStatementParser::DESCRIPTION);
        setState(3836);
        string_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlaceContext ------------------------------------------------------------------

MySQLStatementParser::PlaceContext::PlaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PlaceContext::FIRST() {
  return getToken(MySQLStatementParser::FIRST, 0);
}

tree::TerminalNode* MySQLStatementParser::PlaceContext::AFTER() {
  return getToken(MySQLStatementParser::AFTER, 0);
}

MySQLStatementParser::ColumnNameContext* MySQLStatementParser::PlaceContext::columnName() {
  return getRuleContext<MySQLStatementParser::ColumnNameContext>(0);
}


size_t MySQLStatementParser::PlaceContext::getRuleIndex() const {
  return MySQLStatementParser::RulePlace;
}

void MySQLStatementParser::PlaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlace(this);
}

void MySQLStatementParser::PlaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlace(this);
}


antlrcpp::Any MySQLStatementParser::PlaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPlace(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PlaceContext* MySQLStatementParser::place() {
  PlaceContext *_localctx = _tracker.createInstance<PlaceContext>(_ctx, getState());
  enterRule(_localctx, 362, MySQLStatementParser::RulePlace);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3842);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::FIRST: {
        enterOuterAlt(_localctx, 1);
        setState(3839);
        match(MySQLStatementParser::FIRST);
        break;
      }

      case MySQLStatementParser::AFTER: {
        enterOuterAlt(_localctx, 2);
        setState(3840);
        match(MySQLStatementParser::AFTER);
        setState(3841);
        columnName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionsContext ------------------------------------------------------------------

MySQLStatementParser::PartitionDefinitionsContext::PartitionDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionsContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::PartitionDefinitionContext *> MySQLStatementParser::PartitionDefinitionsContext::partitionDefinition() {
  return getRuleContexts<MySQLStatementParser::PartitionDefinitionContext>();
}

MySQLStatementParser::PartitionDefinitionContext* MySQLStatementParser::PartitionDefinitionsContext::partitionDefinition(size_t i) {
  return getRuleContext<MySQLStatementParser::PartitionDefinitionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionsContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PartitionDefinitionsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::PartitionDefinitionsContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionDefinitions;
}

void MySQLStatementParser::PartitionDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinitions(this);
}

void MySQLStatementParser::PartitionDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinitions(this);
}


antlrcpp::Any MySQLStatementParser::PartitionDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionDefinitionsContext* MySQLStatementParser::partitionDefinitions() {
  PartitionDefinitionsContext *_localctx = _tracker.createInstance<PartitionDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 364, MySQLStatementParser::RulePartitionDefinitions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3844);
    match(MySQLStatementParser::LP_);
    setState(3845);
    partitionDefinition();
    setState(3850);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(3846);
      match(MySQLStatementParser::COMMA_);
      setState(3847);
      partitionDefinition();
      setState(3852);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3853);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionContext ------------------------------------------------------------------

MySQLStatementParser::PartitionDefinitionContext::PartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::PARTITION() {
  return getToken(MySQLStatementParser::PARTITION, 0);
}

MySQLStatementParser::PartitionNameContext* MySQLStatementParser::PartitionDefinitionContext::partitionName() {
  return getRuleContext<MySQLStatementParser::PartitionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::VALUES() {
  return getToken(MySQLStatementParser::VALUES, 0);
}

std::vector<MySQLStatementParser::PartitionDefinitionOptionContext *> MySQLStatementParser::PartitionDefinitionContext::partitionDefinitionOption() {
  return getRuleContexts<MySQLStatementParser::PartitionDefinitionOptionContext>();
}

MySQLStatementParser::PartitionDefinitionOptionContext* MySQLStatementParser::PartitionDefinitionContext::partitionDefinitionOption(size_t i) {
  return getRuleContext<MySQLStatementParser::PartitionDefinitionOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PartitionDefinitionContext::LP_() {
  return getTokens(MySQLStatementParser::LP_);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::LP_(size_t i) {
  return getToken(MySQLStatementParser::LP_, i);
}

std::vector<MySQLStatementParser::SubpartitionDefinitionContext *> MySQLStatementParser::PartitionDefinitionContext::subpartitionDefinition() {
  return getRuleContexts<MySQLStatementParser::SubpartitionDefinitionContext>();
}

MySQLStatementParser::SubpartitionDefinitionContext* MySQLStatementParser::PartitionDefinitionContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySQLStatementParser::SubpartitionDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PartitionDefinitionContext::RP_() {
  return getTokens(MySQLStatementParser::RP_);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::RP_(size_t i) {
  return getToken(MySQLStatementParser::RP_, i);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::LESS() {
  return getToken(MySQLStatementParser::LESS, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::THAN() {
  return getToken(MySQLStatementParser::THAN, 0);
}

MySQLStatementParser::PartitionLessThanValueContext* MySQLStatementParser::PartitionDefinitionContext::partitionLessThanValue() {
  return getRuleContext<MySQLStatementParser::PartitionLessThanValueContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

MySQLStatementParser::PartitionValueListContext* MySQLStatementParser::PartitionDefinitionContext::partitionValueList() {
  return getRuleContext<MySQLStatementParser::PartitionValueListContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PartitionDefinitionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::PartitionDefinitionContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionDefinition;
}

void MySQLStatementParser::PartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinition(this);
}

void MySQLStatementParser::PartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinition(this);
}


antlrcpp::Any MySQLStatementParser::PartitionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionDefinitionContext* MySQLStatementParser::partitionDefinition() {
  PartitionDefinitionContext *_localctx = _tracker.createInstance<PartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 366, MySQLStatementParser::RulePartitionDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3855);
    match(MySQLStatementParser::PARTITION);
    setState(3856);
    partitionName();
    setState(3868);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::VALUES) {
      setState(3857);
      match(MySQLStatementParser::VALUES);
      setState(3866);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::LESS: {
          setState(3858);
          match(MySQLStatementParser::LESS);
          setState(3859);
          match(MySQLStatementParser::THAN);
          setState(3860);
          partitionLessThanValue();
          break;
        }

        case MySQLStatementParser::IN: {
          setState(3861);
          match(MySQLStatementParser::IN);
          setState(3862);
          match(MySQLStatementParser::LP_);
          setState(3863);
          partitionValueList();
          setState(3864);
          match(MySQLStatementParser::RP_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(3873);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMENT

    || _la == MySQLStatementParser::DATA || _la == MySQLStatementParser::ENGINE || _la == MySQLStatementParser::INDEX || _la == MySQLStatementParser::MAX_ROWS

    || _la == MySQLStatementParser::MIN_ROWS || _la == MySQLStatementParser::STORAGE

    || _la == MySQLStatementParser::TABLESPACE) {
      setState(3870);
      partitionDefinitionOption();
      setState(3875);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3887);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(3876);
      match(MySQLStatementParser::LP_);
      setState(3877);
      subpartitionDefinition();
      setState(3882);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(3878);
        match(MySQLStatementParser::COMMA_);
        setState(3879);
        subpartitionDefinition();
        setState(3884);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3885);
      match(MySQLStatementParser::RP_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionLessThanValueContext ------------------------------------------------------------------

MySQLStatementParser::PartitionLessThanValueContext::PartitionLessThanValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionLessThanValueContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionLessThanValueContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::PartitionLessThanValueContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

MySQLStatementParser::PartitionValueListContext* MySQLStatementParser::PartitionLessThanValueContext::partitionValueList() {
  return getRuleContext<MySQLStatementParser::PartitionValueListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionLessThanValueContext::MAXVALUE() {
  return getToken(MySQLStatementParser::MAXVALUE, 0);
}


size_t MySQLStatementParser::PartitionLessThanValueContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionLessThanValue;
}

void MySQLStatementParser::PartitionLessThanValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionLessThanValue(this);
}

void MySQLStatementParser::PartitionLessThanValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionLessThanValue(this);
}


antlrcpp::Any MySQLStatementParser::PartitionLessThanValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionLessThanValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionLessThanValueContext* MySQLStatementParser::partitionLessThanValue() {
  PartitionLessThanValueContext *_localctx = _tracker.createInstance<PartitionLessThanValueContext>(_ctx, getState());
  enterRule(_localctx, 368, MySQLStatementParser::RulePartitionLessThanValue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3897);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::LP_: {
        enterOuterAlt(_localctx, 1);
        setState(3889);
        match(MySQLStatementParser::LP_);
        setState(3892);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx)) {
        case 1: {
          setState(3890);
          expr(0);
          break;
        }

        case 2: {
          setState(3891);
          partitionValueList();
          break;
        }

        }
        setState(3894);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::MAXVALUE: {
        enterOuterAlt(_localctx, 2);
        setState(3896);
        match(MySQLStatementParser::MAXVALUE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValueListContext ------------------------------------------------------------------

MySQLStatementParser::PartitionValueListContext::PartitionValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::PartitionValueListContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::PartitionValueListContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PartitionValueListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::PartitionValueListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::PartitionValueListContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionValueList;
}

void MySQLStatementParser::PartitionValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValueList(this);
}

void MySQLStatementParser::PartitionValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValueList(this);
}


antlrcpp::Any MySQLStatementParser::PartitionValueListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionValueList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionValueListContext* MySQLStatementParser::partitionValueList() {
  PartitionValueListContext *_localctx = _tracker.createInstance<PartitionValueListContext>(_ctx, getState());
  enterRule(_localctx, 370, MySQLStatementParser::RulePartitionValueList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3899);
    expr(0);
    setState(3904);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(3900);
      match(MySQLStatementParser::COMMA_);
      setState(3901);
      expr(0);
      setState(3906);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionOptionContext ------------------------------------------------------------------

MySQLStatementParser::PartitionDefinitionOptionContext::PartitionDefinitionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::PartitionDefinitionOptionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::STORAGE() {
  return getToken(MySQLStatementParser::STORAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::PartitionDefinitionOptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::DATA() {
  return getToken(MySQLStatementParser::DATA, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::DIRECTORY() {
  return getToken(MySQLStatementParser::DIRECTORY, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::MAX_ROWS() {
  return getToken(MySQLStatementParser::MAX_ROWS, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::MIN_ROWS() {
  return getToken(MySQLStatementParser::MIN_ROWS, 0);
}

tree::TerminalNode* MySQLStatementParser::PartitionDefinitionOptionContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}


size_t MySQLStatementParser::PartitionDefinitionOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionDefinitionOption;
}

void MySQLStatementParser::PartitionDefinitionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinitionOption(this);
}

void MySQLStatementParser::PartitionDefinitionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinitionOption(this);
}


antlrcpp::Any MySQLStatementParser::PartitionDefinitionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinitionOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionDefinitionOptionContext* MySQLStatementParser::partitionDefinitionOption() {
  PartitionDefinitionOptionContext *_localctx = _tracker.createInstance<PartitionDefinitionOptionContext>(_ctx, getState());
  enterRule(_localctx, 372, MySQLStatementParser::RulePartitionDefinitionOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3947);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::STORAGE: {
        enterOuterAlt(_localctx, 1);
        setState(3908);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::STORAGE) {
          setState(3907);
          match(MySQLStatementParser::STORAGE);
        }
        setState(3910);
        match(MySQLStatementParser::ENGINE);
        setState(3912);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3911);
          match(MySQLStatementParser::EQ_);
        }
        setState(3914);
        identifier();
        break;
      }

      case MySQLStatementParser::COMMENT: {
        enterOuterAlt(_localctx, 2);
        setState(3915);
        match(MySQLStatementParser::COMMENT);
        setState(3917);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3916);
          match(MySQLStatementParser::EQ_);
        }
        setState(3919);
        string_();
        break;
      }

      case MySQLStatementParser::DATA: {
        enterOuterAlt(_localctx, 3);
        setState(3920);
        match(MySQLStatementParser::DATA);
        setState(3921);
        match(MySQLStatementParser::DIRECTORY);
        setState(3923);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3922);
          match(MySQLStatementParser::EQ_);
        }
        setState(3925);
        string_();
        break;
      }

      case MySQLStatementParser::INDEX: {
        enterOuterAlt(_localctx, 4);
        setState(3926);
        match(MySQLStatementParser::INDEX);
        setState(3927);
        match(MySQLStatementParser::DIRECTORY);
        setState(3929);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3928);
          match(MySQLStatementParser::EQ_);
        }
        setState(3931);
        string_();
        break;
      }

      case MySQLStatementParser::MAX_ROWS: {
        enterOuterAlt(_localctx, 5);
        setState(3932);
        match(MySQLStatementParser::MAX_ROWS);
        setState(3934);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3933);
          match(MySQLStatementParser::EQ_);
        }
        setState(3936);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MIN_ROWS: {
        enterOuterAlt(_localctx, 6);
        setState(3937);
        match(MySQLStatementParser::MIN_ROWS);
        setState(3939);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3938);
          match(MySQLStatementParser::EQ_);
        }
        setState(3941);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::TABLESPACE: {
        enterOuterAlt(_localctx, 7);
        setState(3942);
        match(MySQLStatementParser::TABLESPACE);
        setState(3944);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(3943);
          match(MySQLStatementParser::EQ_);
        }
        setState(3946);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpartitionDefinitionContext ------------------------------------------------------------------

MySQLStatementParser::SubpartitionDefinitionContext::SubpartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SubpartitionDefinitionContext::SUBPARTITION() {
  return getToken(MySQLStatementParser::SUBPARTITION, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::SubpartitionDefinitionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

std::vector<MySQLStatementParser::PartitionDefinitionOptionContext *> MySQLStatementParser::SubpartitionDefinitionContext::partitionDefinitionOption() {
  return getRuleContexts<MySQLStatementParser::PartitionDefinitionOptionContext>();
}

MySQLStatementParser::PartitionDefinitionOptionContext* MySQLStatementParser::SubpartitionDefinitionContext::partitionDefinitionOption(size_t i) {
  return getRuleContext<MySQLStatementParser::PartitionDefinitionOptionContext>(i);
}


size_t MySQLStatementParser::SubpartitionDefinitionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSubpartitionDefinition;
}

void MySQLStatementParser::SubpartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubpartitionDefinition(this);
}

void MySQLStatementParser::SubpartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubpartitionDefinition(this);
}


antlrcpp::Any MySQLStatementParser::SubpartitionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSubpartitionDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SubpartitionDefinitionContext* MySQLStatementParser::subpartitionDefinition() {
  SubpartitionDefinitionContext *_localctx = _tracker.createInstance<SubpartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 374, MySQLStatementParser::RuleSubpartitionDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3949);
    match(MySQLStatementParser::SUBPARTITION);
    setState(3950);
    identifier();
    setState(3954);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMENT

    || _la == MySQLStatementParser::DATA || _la == MySQLStatementParser::ENGINE || _la == MySQLStatementParser::INDEX || _la == MySQLStatementParser::MAX_ROWS

    || _la == MySQLStatementParser::MIN_ROWS || _la == MySQLStatementParser::STORAGE

    || _la == MySQLStatementParser::TABLESPACE) {
      setState(3951);
      partitionDefinitionOption();
      setState(3956);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OwnerStatementContext ------------------------------------------------------------------

MySQLStatementParser::OwnerStatementContext::OwnerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OwnerStatementContext::DEFINER() {
  return getToken(MySQLStatementParser::DEFINER, 0);
}

tree::TerminalNode* MySQLStatementParser::OwnerStatementContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::OwnerStatementContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::OwnerStatementContext::CURRENT_USER() {
  return getToken(MySQLStatementParser::CURRENT_USER, 0);
}

tree::TerminalNode* MySQLStatementParser::OwnerStatementContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::OwnerStatementContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::OwnerStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOwnerStatement;
}

void MySQLStatementParser::OwnerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOwnerStatement(this);
}

void MySQLStatementParser::OwnerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOwnerStatement(this);
}


antlrcpp::Any MySQLStatementParser::OwnerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOwnerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OwnerStatementContext* MySQLStatementParser::ownerStatement() {
  OwnerStatementContext *_localctx = _tracker.createInstance<OwnerStatementContext>(_ctx, getState());
  enterRule(_localctx, 376, MySQLStatementParser::RuleOwnerStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3957);
    match(MySQLStatementParser::DEFINER);
    setState(3958);
    match(MySQLStatementParser::EQ_);
    setState(3965);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 487, _ctx)) {
    case 1: {
      setState(3959);
      userName();
      break;
    }

    case 2: {
      setState(3960);
      match(MySQLStatementParser::CURRENT_USER);
      setState(3963);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::LP_) {
        setState(3961);
        match(MySQLStatementParser::LP_);
        setState(3962);
        match(MySQLStatementParser::RP_);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScheduleExpressionContext ------------------------------------------------------------------

MySQLStatementParser::ScheduleExpressionContext::ScheduleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ScheduleExpressionContext::AT() {
  return getToken(MySQLStatementParser::AT, 0);
}

std::vector<MySQLStatementParser::TimestampValueContext *> MySQLStatementParser::ScheduleExpressionContext::timestampValue() {
  return getRuleContexts<MySQLStatementParser::TimestampValueContext>();
}

MySQLStatementParser::TimestampValueContext* MySQLStatementParser::ScheduleExpressionContext::timestampValue(size_t i) {
  return getRuleContext<MySQLStatementParser::TimestampValueContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ScheduleExpressionContext::PLUS_() {
  return getTokens(MySQLStatementParser::PLUS_);
}

tree::TerminalNode* MySQLStatementParser::ScheduleExpressionContext::PLUS_(size_t i) {
  return getToken(MySQLStatementParser::PLUS_, i);
}

std::vector<MySQLStatementParser::IntervalExpressionContext *> MySQLStatementParser::ScheduleExpressionContext::intervalExpression() {
  return getRuleContexts<MySQLStatementParser::IntervalExpressionContext>();
}

MySQLStatementParser::IntervalExpressionContext* MySQLStatementParser::ScheduleExpressionContext::intervalExpression(size_t i) {
  return getRuleContext<MySQLStatementParser::IntervalExpressionContext>(i);
}

tree::TerminalNode* MySQLStatementParser::ScheduleExpressionContext::EVERY() {
  return getToken(MySQLStatementParser::EVERY, 0);
}

MySQLStatementParser::IntervalValueContext* MySQLStatementParser::ScheduleExpressionContext::intervalValue() {
  return getRuleContext<MySQLStatementParser::IntervalValueContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ScheduleExpressionContext::STARTS() {
  return getToken(MySQLStatementParser::STARTS, 0);
}

tree::TerminalNode* MySQLStatementParser::ScheduleExpressionContext::ENDS() {
  return getToken(MySQLStatementParser::ENDS, 0);
}


size_t MySQLStatementParser::ScheduleExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleScheduleExpression;
}

void MySQLStatementParser::ScheduleExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScheduleExpression(this);
}

void MySQLStatementParser::ScheduleExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScheduleExpression(this);
}


antlrcpp::Any MySQLStatementParser::ScheduleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitScheduleExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ScheduleExpressionContext* MySQLStatementParser::scheduleExpression() {
  ScheduleExpressionContext *_localctx = _tracker.createInstance<ScheduleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 378, MySQLStatementParser::RuleScheduleExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4000);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(3967);
        match(MySQLStatementParser::AT);
        setState(3968);
        timestampValue();
        setState(3973);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::PLUS_) {
          setState(3969);
          match(MySQLStatementParser::PLUS_);
          setState(3970);
          intervalExpression();
          setState(3975);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::EVERY: {
        enterOuterAlt(_localctx, 2);
        setState(3976);
        match(MySQLStatementParser::EVERY);
        setState(3977);
        intervalValue();
        setState(3987);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::STARTS) {
          setState(3978);
          match(MySQLStatementParser::STARTS);
          setState(3979);
          timestampValue();
          setState(3984);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySQLStatementParser::PLUS_) {
            setState(3980);
            match(MySQLStatementParser::PLUS_);
            setState(3981);
            intervalExpression();
            setState(3986);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(3998);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ENDS) {
          setState(3989);
          match(MySQLStatementParser::ENDS);
          setState(3990);
          timestampValue();
          setState(3995);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySQLStatementParser::PLUS_) {
            setState(3991);
            match(MySQLStatementParser::PLUS_);
            setState(3992);
            intervalExpression();
            setState(3997);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimestampValueContext ------------------------------------------------------------------

MySQLStatementParser::TimestampValueContext::TimestampValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TimestampValueContext::CURRENT_TIMESTAMP() {
  return getToken(MySQLStatementParser::CURRENT_TIMESTAMP, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::TimestampValueContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::TimestampValueContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::TimestampValueContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::TimestampValueContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTimestampValue;
}

void MySQLStatementParser::TimestampValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimestampValue(this);
}

void MySQLStatementParser::TimestampValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimestampValue(this);
}


antlrcpp::Any MySQLStatementParser::TimestampValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTimestampValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TimestampValueContext* MySQLStatementParser::timestampValue() {
  TimestampValueContext *_localctx = _tracker.createInstance<TimestampValueContext>(_ctx, getState());
  enterRule(_localctx, 380, MySQLStatementParser::RuleTimestampValue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4006);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 494, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4002);
      match(MySQLStatementParser::CURRENT_TIMESTAMP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4003);
      stringLiterals();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4004);
      numberLiterals();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4005);
      expr(0);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineBodyContext ------------------------------------------------------------------

MySQLStatementParser::RoutineBodyContext::RoutineBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SimpleStatementContext* MySQLStatementParser::RoutineBodyContext::simpleStatement() {
  return getRuleContext<MySQLStatementParser::SimpleStatementContext>(0);
}

MySQLStatementParser::CompoundStatementContext* MySQLStatementParser::RoutineBodyContext::compoundStatement() {
  return getRuleContext<MySQLStatementParser::CompoundStatementContext>(0);
}


size_t MySQLStatementParser::RoutineBodyContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRoutineBody;
}

void MySQLStatementParser::RoutineBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineBody(this);
}

void MySQLStatementParser::RoutineBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineBody(this);
}


antlrcpp::Any MySQLStatementParser::RoutineBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRoutineBody(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RoutineBodyContext* MySQLStatementParser::routineBody() {
  RoutineBodyContext *_localctx = _tracker.createInstance<RoutineBodyContext>(_ctx, getState());
  enterRule(_localctx, 382, MySQLStatementParser::RuleRoutineBody);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4010);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4008);
      simpleStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4009);
      compoundStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionContext ------------------------------------------------------------------

MySQLStatementParser::ServerOptionContext::ServerOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ServerOptionContext::HOST() {
  return getToken(MySQLStatementParser::HOST, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::ServerOptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::ServerOptionContext::DATABASE() {
  return getToken(MySQLStatementParser::DATABASE, 0);
}

tree::TerminalNode* MySQLStatementParser::ServerOptionContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

tree::TerminalNode* MySQLStatementParser::ServerOptionContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::ServerOptionContext::SOCKET() {
  return getToken(MySQLStatementParser::SOCKET, 0);
}

tree::TerminalNode* MySQLStatementParser::ServerOptionContext::OWNER() {
  return getToken(MySQLStatementParser::OWNER, 0);
}

tree::TerminalNode* MySQLStatementParser::ServerOptionContext::PORT() {
  return getToken(MySQLStatementParser::PORT, 0);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::ServerOptionContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}


size_t MySQLStatementParser::ServerOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleServerOption;
}

void MySQLStatementParser::ServerOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOption(this);
}

void MySQLStatementParser::ServerOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOption(this);
}


antlrcpp::Any MySQLStatementParser::ServerOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitServerOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ServerOptionContext* MySQLStatementParser::serverOption() {
  ServerOptionContext *_localctx = _tracker.createInstance<ServerOptionContext>(_ctx, getState());
  enterRule(_localctx, 384, MySQLStatementParser::RuleServerOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4026);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::HOST: {
        enterOuterAlt(_localctx, 1);
        setState(4012);
        match(MySQLStatementParser::HOST);
        setState(4013);
        string_();
        break;
      }

      case MySQLStatementParser::DATABASE: {
        enterOuterAlt(_localctx, 2);
        setState(4014);
        match(MySQLStatementParser::DATABASE);
        setState(4015);
        string_();
        break;
      }

      case MySQLStatementParser::USER: {
        enterOuterAlt(_localctx, 3);
        setState(4016);
        match(MySQLStatementParser::USER);
        setState(4017);
        string_();
        break;
      }

      case MySQLStatementParser::PASSWORD: {
        enterOuterAlt(_localctx, 4);
        setState(4018);
        match(MySQLStatementParser::PASSWORD);
        setState(4019);
        string_();
        break;
      }

      case MySQLStatementParser::SOCKET: {
        enterOuterAlt(_localctx, 5);
        setState(4020);
        match(MySQLStatementParser::SOCKET);
        setState(4021);
        string_();
        break;
      }

      case MySQLStatementParser::OWNER: {
        enterOuterAlt(_localctx, 6);
        setState(4022);
        match(MySQLStatementParser::OWNER);
        setState(4023);
        string_();
        break;
      }

      case MySQLStatementParser::PORT: {
        enterOuterAlt(_localctx, 7);
        setState(4024);
        match(MySQLStatementParser::PORT);
        setState(4025);
        numberLiterals();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineOptionContext ------------------------------------------------------------------

MySQLStatementParser::RoutineOptionContext::RoutineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::RoutineOptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::LANGUAGE() {
  return getToken(MySQLStatementParser::LANGUAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::SQL() {
  return getToken(MySQLStatementParser::SQL, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::DETERMINISTIC() {
  return getToken(MySQLStatementParser::DETERMINISTIC, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::CONTAINS() {
  return getToken(MySQLStatementParser::CONTAINS, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::READS() {
  return getToken(MySQLStatementParser::READS, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::DATA() {
  return getToken(MySQLStatementParser::DATA, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::MODIFIES() {
  return getToken(MySQLStatementParser::MODIFIES, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::SECURITY() {
  return getToken(MySQLStatementParser::SECURITY, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::DEFINER() {
  return getToken(MySQLStatementParser::DEFINER, 0);
}

tree::TerminalNode* MySQLStatementParser::RoutineOptionContext::INVOKER() {
  return getToken(MySQLStatementParser::INVOKER, 0);
}


size_t MySQLStatementParser::RoutineOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRoutineOption;
}

void MySQLStatementParser::RoutineOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineOption(this);
}

void MySQLStatementParser::RoutineOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineOption(this);
}


antlrcpp::Any MySQLStatementParser::RoutineOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRoutineOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RoutineOptionContext* MySQLStatementParser::routineOption() {
  RoutineOptionContext *_localctx = _tracker.createInstance<RoutineOptionContext>(_ctx, getState());
  enterRule(_localctx, 386, MySQLStatementParser::RuleRoutineOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4051);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::COMMENT: {
        enterOuterAlt(_localctx, 1);
        setState(4028);
        match(MySQLStatementParser::COMMENT);
        setState(4029);
        string_();
        break;
      }

      case MySQLStatementParser::LANGUAGE: {
        enterOuterAlt(_localctx, 2);
        setState(4030);
        match(MySQLStatementParser::LANGUAGE);
        setState(4031);
        match(MySQLStatementParser::SQL);
        break;
      }

      case MySQLStatementParser::DETERMINISTIC:
      case MySQLStatementParser::NOT: {
        enterOuterAlt(_localctx, 3);
        setState(4033);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::NOT) {
          setState(4032);
          match(MySQLStatementParser::NOT);
        }
        setState(4035);
        match(MySQLStatementParser::DETERMINISTIC);
        break;
      }

      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::MODIFIES:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::READS: {
        enterOuterAlt(_localctx, 4);
        setState(4046);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLStatementParser::CONTAINS: {
            setState(4036);
            match(MySQLStatementParser::CONTAINS);
            setState(4037);
            match(MySQLStatementParser::SQL);
            break;
          }

          case MySQLStatementParser::NO: {
            setState(4038);
            match(MySQLStatementParser::NO);
            setState(4039);
            match(MySQLStatementParser::SQL);
            break;
          }

          case MySQLStatementParser::READS: {
            setState(4040);
            match(MySQLStatementParser::READS);
            setState(4041);
            match(MySQLStatementParser::SQL);
            setState(4042);
            match(MySQLStatementParser::DATA);
            break;
          }

          case MySQLStatementParser::MODIFIES: {
            setState(4043);
            match(MySQLStatementParser::MODIFIES);
            setState(4044);
            match(MySQLStatementParser::SQL);
            setState(4045);
            match(MySQLStatementParser::DATA);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySQLStatementParser::SQL: {
        enterOuterAlt(_localctx, 5);
        setState(4048);
        match(MySQLStatementParser::SQL);
        setState(4049);
        match(MySQLStatementParser::SECURITY);
        setState(4050);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::DEFINER || _la == MySQLStatementParser::INVOKER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureParameterContext ------------------------------------------------------------------

MySQLStatementParser::ProcedureParameterContext::ProcedureParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ProcedureParameterContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::DataTypeContext* MySQLStatementParser::ProcedureParameterContext::dataType() {
  return getRuleContext<MySQLStatementParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ProcedureParameterContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

tree::TerminalNode* MySQLStatementParser::ProcedureParameterContext::OUT() {
  return getToken(MySQLStatementParser::OUT, 0);
}

tree::TerminalNode* MySQLStatementParser::ProcedureParameterContext::INOUT() {
  return getToken(MySQLStatementParser::INOUT, 0);
}


size_t MySQLStatementParser::ProcedureParameterContext::getRuleIndex() const {
  return MySQLStatementParser::RuleProcedureParameter;
}

void MySQLStatementParser::ProcedureParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureParameter(this);
}

void MySQLStatementParser::ProcedureParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureParameter(this);
}


antlrcpp::Any MySQLStatementParser::ProcedureParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitProcedureParameter(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ProcedureParameterContext* MySQLStatementParser::procedureParameter() {
  ProcedureParameterContext *_localctx = _tracker.createInstance<ProcedureParameterContext>(_ctx, getState());
  enterRule(_localctx, 388, MySQLStatementParser::RuleProcedureParameter);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4054);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IN

    || _la == MySQLStatementParser::INOUT || _la == MySQLStatementParser::OUT) {
      setState(4053);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::IN

      || _la == MySQLStatementParser::INOUT || _la == MySQLStatementParser::OUT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(4056);
    identifier();
    setState(4057);
    dataType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileSizeLiteralContext ------------------------------------------------------------------

MySQLStatementParser::FileSizeLiteralContext::FileSizeLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FileSizeLiteralContext::FILESIZE_LITERAL() {
  return getToken(MySQLStatementParser::FILESIZE_LITERAL, 0);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::FileSizeLiteralContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}


size_t MySQLStatementParser::FileSizeLiteralContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFileSizeLiteral;
}

void MySQLStatementParser::FileSizeLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileSizeLiteral(this);
}

void MySQLStatementParser::FileSizeLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileSizeLiteral(this);
}


antlrcpp::Any MySQLStatementParser::FileSizeLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFileSizeLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FileSizeLiteralContext* MySQLStatementParser::fileSizeLiteral() {
  FileSizeLiteralContext *_localctx = _tracker.createInstance<FileSizeLiteralContext>(_ctx, getState());
  enterRule(_localctx, 390, MySQLStatementParser::RuleFileSizeLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4061);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::FILESIZE_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(4059);
        match(MySQLStatementParser::FILESIZE_LITERAL);
        break;
      }

      case MySQLStatementParser::NUMBER_: {
        enterOuterAlt(_localctx, 2);
        setState(4060);
        numberLiterals();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStatementContext ------------------------------------------------------------------

MySQLStatementParser::SimpleStatementContext::SimpleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::SimpleStatementContext::validStatement() {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(0);
}


size_t MySQLStatementParser::SimpleStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSimpleStatement;
}

void MySQLStatementParser::SimpleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStatement(this);
}

void MySQLStatementParser::SimpleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStatement(this);
}


antlrcpp::Any MySQLStatementParser::SimpleStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSimpleStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SimpleStatementContext* MySQLStatementParser::simpleStatement() {
  SimpleStatementContext *_localctx = _tracker.createInstance<SimpleStatementContext>(_ctx, getState());
  enterRule(_localctx, 392, MySQLStatementParser::RuleSimpleStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4063);
    validStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

MySQLStatementParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::BeginStatementContext* MySQLStatementParser::CompoundStatementContext::beginStatement() {
  return getRuleContext<MySQLStatementParser::BeginStatementContext>(0);
}


size_t MySQLStatementParser::CompoundStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCompoundStatement;
}

void MySQLStatementParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void MySQLStatementParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}


antlrcpp::Any MySQLStatementParser::CompoundStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCompoundStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CompoundStatementContext* MySQLStatementParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 394, MySQLStatementParser::RuleCompoundStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4065);
    beginStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValidStatementContext ------------------------------------------------------------------

MySQLStatementParser::ValidStatementContext::ValidStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CreateTableContext* MySQLStatementParser::ValidStatementContext::createTable() {
  return getRuleContext<MySQLStatementParser::CreateTableContext>(0);
}

MySQLStatementParser::AlterTableContext* MySQLStatementParser::ValidStatementContext::alterTable() {
  return getRuleContext<MySQLStatementParser::AlterTableContext>(0);
}

MySQLStatementParser::DropTableContext* MySQLStatementParser::ValidStatementContext::dropTable() {
  return getRuleContext<MySQLStatementParser::DropTableContext>(0);
}

MySQLStatementParser::TruncateTableContext* MySQLStatementParser::ValidStatementContext::truncateTable() {
  return getRuleContext<MySQLStatementParser::TruncateTableContext>(0);
}

MySQLStatementParser::InsertContext* MySQLStatementParser::ValidStatementContext::insert() {
  return getRuleContext<MySQLStatementParser::InsertContext>(0);
}

MySQLStatementParser::ReplaceContext* MySQLStatementParser::ValidStatementContext::replace() {
  return getRuleContext<MySQLStatementParser::ReplaceContext>(0);
}

MySQLStatementParser::UpdateContext* MySQLStatementParser::ValidStatementContext::update() {
  return getRuleContext<MySQLStatementParser::UpdateContext>(0);
}

MySQLStatementParser::Delete_stmtContext* MySQLStatementParser::ValidStatementContext::delete_stmt() {
  return getRuleContext<MySQLStatementParser::Delete_stmtContext>(0);
}

MySQLStatementParser::SelectContext* MySQLStatementParser::ValidStatementContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

MySQLStatementParser::CallContext* MySQLStatementParser::ValidStatementContext::call() {
  return getRuleContext<MySQLStatementParser::CallContext>(0);
}

MySQLStatementParser::SetVariableContext* MySQLStatementParser::ValidStatementContext::setVariable() {
  return getRuleContext<MySQLStatementParser::SetVariableContext>(0);
}

MySQLStatementParser::BeginStatementContext* MySQLStatementParser::ValidStatementContext::beginStatement() {
  return getRuleContext<MySQLStatementParser::BeginStatementContext>(0);
}

MySQLStatementParser::DeclareStatementContext* MySQLStatementParser::ValidStatementContext::declareStatement() {
  return getRuleContext<MySQLStatementParser::DeclareStatementContext>(0);
}

MySQLStatementParser::FlowControlStatementContext* MySQLStatementParser::ValidStatementContext::flowControlStatement() {
  return getRuleContext<MySQLStatementParser::FlowControlStatementContext>(0);
}

MySQLStatementParser::CursorStatementContext* MySQLStatementParser::ValidStatementContext::cursorStatement() {
  return getRuleContext<MySQLStatementParser::CursorStatementContext>(0);
}

MySQLStatementParser::ConditionHandlingStatementContext* MySQLStatementParser::ValidStatementContext::conditionHandlingStatement() {
  return getRuleContext<MySQLStatementParser::ConditionHandlingStatementContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ValidStatementContext::SEMI_() {
  return getToken(MySQLStatementParser::SEMI_, 0);
}


size_t MySQLStatementParser::ValidStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleValidStatement;
}

void MySQLStatementParser::ValidStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValidStatement(this);
}

void MySQLStatementParser::ValidStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValidStatement(this);
}


antlrcpp::Any MySQLStatementParser::ValidStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitValidStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::validStatement() {
  ValidStatementContext *_localctx = _tracker.createInstance<ValidStatementContext>(_ctx, getState());
  enterRule(_localctx, 396, MySQLStatementParser::RuleValidStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4083);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 502, _ctx)) {
    case 1: {
      setState(4067);
      createTable();
      break;
    }

    case 2: {
      setState(4068);
      alterTable();
      break;
    }

    case 3: {
      setState(4069);
      dropTable();
      break;
    }

    case 4: {
      setState(4070);
      truncateTable();
      break;
    }

    case 5: {
      setState(4071);
      insert();
      break;
    }

    case 6: {
      setState(4072);
      replace();
      break;
    }

    case 7: {
      setState(4073);
      update();
      break;
    }

    case 8: {
      setState(4074);
      delete_stmt();
      break;
    }

    case 9: {
      setState(4075);
      select();
      break;
    }

    case 10: {
      setState(4076);
      call();
      break;
    }

    case 11: {
      setState(4077);
      setVariable();
      break;
    }

    case 12: {
      setState(4078);
      beginStatement();
      break;
    }

    case 13: {
      setState(4079);
      declareStatement();
      break;
    }

    case 14: {
      setState(4080);
      flowControlStatement();
      break;
    }

    case 15: {
      setState(4081);
      cursorStatement();
      break;
    }

    case 16: {
      setState(4082);
      conditionHandlingStatement();
      break;
    }

    }
    setState(4086);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 503, _ctx)) {
    case 1: {
      setState(4085);
      match(MySQLStatementParser::SEMI_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginStatementContext ------------------------------------------------------------------

MySQLStatementParser::BeginStatementContext::BeginStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BeginStatementContext::BEGIN() {
  return getToken(MySQLStatementParser::BEGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::BeginStatementContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

std::vector<MySQLStatementParser::LabelNameContext *> MySQLStatementParser::BeginStatementContext::labelName() {
  return getRuleContexts<MySQLStatementParser::LabelNameContext>();
}

MySQLStatementParser::LabelNameContext* MySQLStatementParser::BeginStatementContext::labelName(size_t i) {
  return getRuleContext<MySQLStatementParser::LabelNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::BeginStatementContext::COLON_() {
  return getToken(MySQLStatementParser::COLON_, 0);
}

std::vector<MySQLStatementParser::ValidStatementContext *> MySQLStatementParser::BeginStatementContext::validStatement() {
  return getRuleContexts<MySQLStatementParser::ValidStatementContext>();
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::BeginStatementContext::validStatement(size_t i) {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(i);
}

tree::TerminalNode* MySQLStatementParser::BeginStatementContext::SEMI_() {
  return getToken(MySQLStatementParser::SEMI_, 0);
}


size_t MySQLStatementParser::BeginStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBeginStatement;
}

void MySQLStatementParser::BeginStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginStatement(this);
}

void MySQLStatementParser::BeginStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginStatement(this);
}


antlrcpp::Any MySQLStatementParser::BeginStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBeginStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BeginStatementContext* MySQLStatementParser::beginStatement() {
  BeginStatementContext *_localctx = _tracker.createInstance<BeginStatementContext>(_ctx, getState());
  enterRule(_localctx, 398, MySQLStatementParser::RuleBeginStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4091);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 504, _ctx)) {
    case 1: {
      setState(4088);
      labelName();
      setState(4089);
      match(MySQLStatementParser::COLON_);
      break;
    }

    }
    setState(4093);
    match(MySQLStatementParser::BEGIN);
    setState(4097);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4094);
        validStatement(); 
      }
      setState(4099);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx);
    }
    setState(4100);
    match(MySQLStatementParser::END);
    setState(4102);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx)) {
    case 1: {
      setState(4101);
      labelName();
      break;
    }

    }
    setState(4105);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
    case 1: {
      setState(4104);
      match(MySQLStatementParser::SEMI_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareStatementContext ------------------------------------------------------------------

MySQLStatementParser::DeclareStatementContext::DeclareStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DeclareStatementContext::DECLARE() {
  return getToken(MySQLStatementParser::DECLARE, 0);
}

std::vector<MySQLStatementParser::VariableContext *> MySQLStatementParser::DeclareStatementContext::variable() {
  return getRuleContexts<MySQLStatementParser::VariableContext>();
}

MySQLStatementParser::VariableContext* MySQLStatementParser::DeclareStatementContext::variable(size_t i) {
  return getRuleContext<MySQLStatementParser::VariableContext>(i);
}

MySQLStatementParser::DataTypeContext* MySQLStatementParser::DeclareStatementContext::dataType() {
  return getRuleContext<MySQLStatementParser::DataTypeContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DeclareStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::DeclareStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DeclareStatementContext::DEFAULT() {
  return getTokens(MySQLStatementParser::DEFAULT);
}

tree::TerminalNode* MySQLStatementParser::DeclareStatementContext::DEFAULT(size_t i) {
  return getToken(MySQLStatementParser::DEFAULT, i);
}

std::vector<MySQLStatementParser::SimpleExprContext *> MySQLStatementParser::DeclareStatementContext::simpleExpr() {
  return getRuleContexts<MySQLStatementParser::SimpleExprContext>();
}

MySQLStatementParser::SimpleExprContext* MySQLStatementParser::DeclareStatementContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLStatementParser::SimpleExprContext>(i);
}


size_t MySQLStatementParser::DeclareStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDeclareStatement;
}

void MySQLStatementParser::DeclareStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareStatement(this);
}

void MySQLStatementParser::DeclareStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareStatement(this);
}


antlrcpp::Any MySQLStatementParser::DeclareStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDeclareStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DeclareStatementContext* MySQLStatementParser::declareStatement() {
  DeclareStatementContext *_localctx = _tracker.createInstance<DeclareStatementContext>(_ctx, getState());
  enterRule(_localctx, 400, MySQLStatementParser::RuleDeclareStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4107);
    match(MySQLStatementParser::DECLARE);
    setState(4108);
    variable();
    setState(4113);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4109);
      match(MySQLStatementParser::COMMA_);
      setState(4110);
      variable();
      setState(4115);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4116);
    dataType();
    setState(4121);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::DEFAULT) {
      setState(4117);
      match(MySQLStatementParser::DEFAULT);
      setState(4118);
      simpleExpr(0);
      setState(4123);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlowControlStatementContext ------------------------------------------------------------------

MySQLStatementParser::FlowControlStatementContext::FlowControlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CaseStatementContext* MySQLStatementParser::FlowControlStatementContext::caseStatement() {
  return getRuleContext<MySQLStatementParser::CaseStatementContext>(0);
}

MySQLStatementParser::IfStatementContext* MySQLStatementParser::FlowControlStatementContext::ifStatement() {
  return getRuleContext<MySQLStatementParser::IfStatementContext>(0);
}

MySQLStatementParser::IterateStatementContext* MySQLStatementParser::FlowControlStatementContext::iterateStatement() {
  return getRuleContext<MySQLStatementParser::IterateStatementContext>(0);
}

MySQLStatementParser::LeaveStatementContext* MySQLStatementParser::FlowControlStatementContext::leaveStatement() {
  return getRuleContext<MySQLStatementParser::LeaveStatementContext>(0);
}

MySQLStatementParser::LoopStatementContext* MySQLStatementParser::FlowControlStatementContext::loopStatement() {
  return getRuleContext<MySQLStatementParser::LoopStatementContext>(0);
}

MySQLStatementParser::RepeatStatementContext* MySQLStatementParser::FlowControlStatementContext::repeatStatement() {
  return getRuleContext<MySQLStatementParser::RepeatStatementContext>(0);
}

MySQLStatementParser::ReturnStatementContext* MySQLStatementParser::FlowControlStatementContext::returnStatement() {
  return getRuleContext<MySQLStatementParser::ReturnStatementContext>(0);
}

MySQLStatementParser::WhileStatementContext* MySQLStatementParser::FlowControlStatementContext::whileStatement() {
  return getRuleContext<MySQLStatementParser::WhileStatementContext>(0);
}


size_t MySQLStatementParser::FlowControlStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFlowControlStatement;
}

void MySQLStatementParser::FlowControlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlowControlStatement(this);
}

void MySQLStatementParser::FlowControlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlowControlStatement(this);
}


antlrcpp::Any MySQLStatementParser::FlowControlStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFlowControlStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FlowControlStatementContext* MySQLStatementParser::flowControlStatement() {
  FlowControlStatementContext *_localctx = _tracker.createInstance<FlowControlStatementContext>(_ctx, getState());
  enterRule(_localctx, 402, MySQLStatementParser::RuleFlowControlStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4132);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4124);
      caseStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4125);
      ifStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4126);
      iterateStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4127);
      leaveStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4128);
      loopStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4129);
      repeatStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4130);
      returnStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4131);
      whileStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseStatementContext ------------------------------------------------------------------

MySQLStatementParser::CaseStatementContext::CaseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CaseStatementContext::CASE() {
  return getTokens(MySQLStatementParser::CASE);
}

tree::TerminalNode* MySQLStatementParser::CaseStatementContext::CASE(size_t i) {
  return getToken(MySQLStatementParser::CASE, i);
}

tree::TerminalNode* MySQLStatementParser::CaseStatementContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::CaseStatementContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CaseStatementContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CaseStatementContext::WHEN() {
  return getTokens(MySQLStatementParser::WHEN);
}

tree::TerminalNode* MySQLStatementParser::CaseStatementContext::WHEN(size_t i) {
  return getToken(MySQLStatementParser::WHEN, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CaseStatementContext::THEN() {
  return getTokens(MySQLStatementParser::THEN);
}

tree::TerminalNode* MySQLStatementParser::CaseStatementContext::THEN(size_t i) {
  return getToken(MySQLStatementParser::THEN, i);
}

tree::TerminalNode* MySQLStatementParser::CaseStatementContext::ELSE() {
  return getToken(MySQLStatementParser::ELSE, 0);
}

std::vector<MySQLStatementParser::ValidStatementContext *> MySQLStatementParser::CaseStatementContext::validStatement() {
  return getRuleContexts<MySQLStatementParser::ValidStatementContext>();
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::CaseStatementContext::validStatement(size_t i) {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(i);
}


size_t MySQLStatementParser::CaseStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCaseStatement;
}

void MySQLStatementParser::CaseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseStatement(this);
}

void MySQLStatementParser::CaseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseStatement(this);
}


antlrcpp::Any MySQLStatementParser::CaseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCaseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CaseStatementContext* MySQLStatementParser::caseStatement() {
  CaseStatementContext *_localctx = _tracker.createInstance<CaseStatementContext>(_ctx, getState());
  enterRule(_localctx, 404, MySQLStatementParser::RuleCaseStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4134);
    match(MySQLStatementParser::CASE);
    setState(4136);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINARY)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CASE - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHAR - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CONVERT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CUME_DIST - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_DATE - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_TIME - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_TIMESTAMP - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_USER - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATABASE - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DENSE_RANK - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXISTS - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FALSE - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIRST_VALUE - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IF - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INTERVAL - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LAG - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LAST_VALUE - 259))
      | (1ULL << (MySQLStatementParser::LEAD - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LEFT - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCALTIME - 324))
      | (1ULL << (MySQLStatementParser::LOCALTIMESTAMP - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MATCH - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MOD - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOT - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NTH_VALUE - 388))
      | (1ULL << (MySQLStatementParser::NTILE - 388))
      | (1ULL << (MySQLStatementParser::NULL - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERCENT_RANK - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::RANK - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLACE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::RIGHT - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::ROW_NUMBER - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUE - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VALUES - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710))
      | (1ULL << (MySQLStatementParser::NOT_ - 710))
      | (1ULL << (MySQLStatementParser::TILDE_ - 710))
      | (1ULL << (MySQLStatementParser::PLUS_ - 710))
      | (1ULL << (MySQLStatementParser::MINUS_ - 710))
      | (1ULL << (MySQLStatementParser::DOT_ - 710))
      | (1ULL << (MySQLStatementParser::LP_ - 710))
      | (1ULL << (MySQLStatementParser::LBE_ - 710))
      | (1ULL << (MySQLStatementParser::QUESTION_ - 710))
      | (1ULL << (MySQLStatementParser::AT_ - 710)))) != 0) || ((((_la - 780) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 780)) & ((1ULL << (MySQLStatementParser::IDENTIFIER_ - 780))
      | (1ULL << (MySQLStatementParser::SINGLE_QUOTED_TEXT - 780))
      | (1ULL << (MySQLStatementParser::DOUBLE_QUOTED_TEXT - 780))
      | (1ULL << (MySQLStatementParser::NCHAR_TEXT - 780))
      | (1ULL << (MySQLStatementParser::UNDERSCORE_CHARSET - 780))
      | (1ULL << (MySQLStatementParser::NUMBER_ - 780))
      | (1ULL << (MySQLStatementParser::HEX_DIGIT_ - 780))
      | (1ULL << (MySQLStatementParser::BIT_NUM_ - 780)))) != 0)) {
      setState(4135);
      expr(0);
    }
    setState(4146); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(4138);
      match(MySQLStatementParser::WHEN);
      setState(4139);
      expr(0);
      setState(4140);
      match(MySQLStatementParser::THEN);
      setState(4142); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4141);
                validStatement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4144); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 512, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(4148); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLStatementParser::WHEN);
    setState(4156);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ELSE) {
      setState(4150);
      match(MySQLStatementParser::ELSE);
      setState(4152); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4151);
                validStatement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4154); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 514, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    }
    setState(4158);
    match(MySQLStatementParser::END);
    setState(4159);
    match(MySQLStatementParser::CASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

MySQLStatementParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IfStatementContext::IF() {
  return getTokens(MySQLStatementParser::IF);
}

tree::TerminalNode* MySQLStatementParser::IfStatementContext::IF(size_t i) {
  return getToken(MySQLStatementParser::IF, i);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::IfStatementContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::IfStatementContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IfStatementContext::THEN() {
  return getTokens(MySQLStatementParser::THEN);
}

tree::TerminalNode* MySQLStatementParser::IfStatementContext::THEN(size_t i) {
  return getToken(MySQLStatementParser::THEN, i);
}

tree::TerminalNode* MySQLStatementParser::IfStatementContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

std::vector<MySQLStatementParser::ValidStatementContext *> MySQLStatementParser::IfStatementContext::validStatement() {
  return getRuleContexts<MySQLStatementParser::ValidStatementContext>();
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::IfStatementContext::validStatement(size_t i) {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IfStatementContext::ELSEIF() {
  return getTokens(MySQLStatementParser::ELSEIF);
}

tree::TerminalNode* MySQLStatementParser::IfStatementContext::ELSEIF(size_t i) {
  return getToken(MySQLStatementParser::ELSEIF, i);
}

tree::TerminalNode* MySQLStatementParser::IfStatementContext::ELSE() {
  return getToken(MySQLStatementParser::ELSE, 0);
}


size_t MySQLStatementParser::IfStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIfStatement;
}

void MySQLStatementParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void MySQLStatementParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}


antlrcpp::Any MySQLStatementParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IfStatementContext* MySQLStatementParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 406, MySQLStatementParser::RuleIfStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4161);
    match(MySQLStatementParser::IF);
    setState(4162);
    expr(0);
    setState(4163);
    match(MySQLStatementParser::THEN);
    setState(4165); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4164);
              validStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4167); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4179);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::ELSEIF) {
      setState(4169);
      match(MySQLStatementParser::ELSEIF);
      setState(4170);
      expr(0);
      setState(4171);
      match(MySQLStatementParser::THEN);
      setState(4173); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4172);
                validStatement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4175); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(4181);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4188);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ELSE) {
      setState(4182);
      match(MySQLStatementParser::ELSE);
      setState(4184); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4183);
                validStatement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4186); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 519, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    }
    setState(4190);
    match(MySQLStatementParser::END);
    setState(4191);
    match(MySQLStatementParser::IF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterateStatementContext ------------------------------------------------------------------

MySQLStatementParser::IterateStatementContext::IterateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IterateStatementContext::ITERATE() {
  return getToken(MySQLStatementParser::ITERATE, 0);
}

MySQLStatementParser::LabelNameContext* MySQLStatementParser::IterateStatementContext::labelName() {
  return getRuleContext<MySQLStatementParser::LabelNameContext>(0);
}


size_t MySQLStatementParser::IterateStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIterateStatement;
}

void MySQLStatementParser::IterateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterateStatement(this);
}

void MySQLStatementParser::IterateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterateStatement(this);
}


antlrcpp::Any MySQLStatementParser::IterateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIterateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IterateStatementContext* MySQLStatementParser::iterateStatement() {
  IterateStatementContext *_localctx = _tracker.createInstance<IterateStatementContext>(_ctx, getState());
  enterRule(_localctx, 408, MySQLStatementParser::RuleIterateStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4193);
    match(MySQLStatementParser::ITERATE);
    setState(4194);
    labelName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeaveStatementContext ------------------------------------------------------------------

MySQLStatementParser::LeaveStatementContext::LeaveStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LeaveStatementContext::LEAVE() {
  return getToken(MySQLStatementParser::LEAVE, 0);
}

MySQLStatementParser::LabelNameContext* MySQLStatementParser::LeaveStatementContext::labelName() {
  return getRuleContext<MySQLStatementParser::LabelNameContext>(0);
}


size_t MySQLStatementParser::LeaveStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLeaveStatement;
}

void MySQLStatementParser::LeaveStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeaveStatement(this);
}

void MySQLStatementParser::LeaveStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeaveStatement(this);
}


antlrcpp::Any MySQLStatementParser::LeaveStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLeaveStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LeaveStatementContext* MySQLStatementParser::leaveStatement() {
  LeaveStatementContext *_localctx = _tracker.createInstance<LeaveStatementContext>(_ctx, getState());
  enterRule(_localctx, 410, MySQLStatementParser::RuleLeaveStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4196);
    match(MySQLStatementParser::LEAVE);
    setState(4197);
    labelName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoopStatementContext ------------------------------------------------------------------

MySQLStatementParser::LoopStatementContext::LoopStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LoopStatementContext::LOOP() {
  return getTokens(MySQLStatementParser::LOOP);
}

tree::TerminalNode* MySQLStatementParser::LoopStatementContext::LOOP(size_t i) {
  return getToken(MySQLStatementParser::LOOP, i);
}

tree::TerminalNode* MySQLStatementParser::LoopStatementContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

std::vector<MySQLStatementParser::LabelNameContext *> MySQLStatementParser::LoopStatementContext::labelName() {
  return getRuleContexts<MySQLStatementParser::LabelNameContext>();
}

MySQLStatementParser::LabelNameContext* MySQLStatementParser::LoopStatementContext::labelName(size_t i) {
  return getRuleContext<MySQLStatementParser::LabelNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::LoopStatementContext::COLON_() {
  return getToken(MySQLStatementParser::COLON_, 0);
}

std::vector<MySQLStatementParser::ValidStatementContext *> MySQLStatementParser::LoopStatementContext::validStatement() {
  return getRuleContexts<MySQLStatementParser::ValidStatementContext>();
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::LoopStatementContext::validStatement(size_t i) {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(i);
}


size_t MySQLStatementParser::LoopStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLoopStatement;
}

void MySQLStatementParser::LoopStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoopStatement(this);
}

void MySQLStatementParser::LoopStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoopStatement(this);
}


antlrcpp::Any MySQLStatementParser::LoopStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLoopStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LoopStatementContext* MySQLStatementParser::loopStatement() {
  LoopStatementContext *_localctx = _tracker.createInstance<LoopStatementContext>(_ctx, getState());
  enterRule(_localctx, 412, MySQLStatementParser::RuleLoopStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4202);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(4199);
      labelName();
      setState(4200);
      match(MySQLStatementParser::COLON_);
    }
    setState(4204);
    match(MySQLStatementParser::LOOP);
    setState(4206); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4205);
              validStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4208); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 522, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4210);
    match(MySQLStatementParser::END);
    setState(4211);
    match(MySQLStatementParser::LOOP);
    setState(4213);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 523, _ctx)) {
    case 1: {
      setState(4212);
      labelName();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatStatementContext ------------------------------------------------------------------

MySQLStatementParser::RepeatStatementContext::RepeatStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RepeatStatementContext::REPEAT() {
  return getTokens(MySQLStatementParser::REPEAT);
}

tree::TerminalNode* MySQLStatementParser::RepeatStatementContext::REPEAT(size_t i) {
  return getToken(MySQLStatementParser::REPEAT, i);
}

tree::TerminalNode* MySQLStatementParser::RepeatStatementContext::UNTIL() {
  return getToken(MySQLStatementParser::UNTIL, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::RepeatStatementContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::RepeatStatementContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

std::vector<MySQLStatementParser::LabelNameContext *> MySQLStatementParser::RepeatStatementContext::labelName() {
  return getRuleContexts<MySQLStatementParser::LabelNameContext>();
}

MySQLStatementParser::LabelNameContext* MySQLStatementParser::RepeatStatementContext::labelName(size_t i) {
  return getRuleContext<MySQLStatementParser::LabelNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::RepeatStatementContext::COLON_() {
  return getToken(MySQLStatementParser::COLON_, 0);
}

std::vector<MySQLStatementParser::ValidStatementContext *> MySQLStatementParser::RepeatStatementContext::validStatement() {
  return getRuleContexts<MySQLStatementParser::ValidStatementContext>();
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::RepeatStatementContext::validStatement(size_t i) {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(i);
}


size_t MySQLStatementParser::RepeatStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRepeatStatement;
}

void MySQLStatementParser::RepeatStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeatStatement(this);
}

void MySQLStatementParser::RepeatStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeatStatement(this);
}


antlrcpp::Any MySQLStatementParser::RepeatStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRepeatStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RepeatStatementContext* MySQLStatementParser::repeatStatement() {
  RepeatStatementContext *_localctx = _tracker.createInstance<RepeatStatementContext>(_ctx, getState());
  enterRule(_localctx, 414, MySQLStatementParser::RuleRepeatStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4218);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(4215);
      labelName();
      setState(4216);
      match(MySQLStatementParser::COLON_);
    }
    setState(4220);
    match(MySQLStatementParser::REPEAT);
    setState(4222); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4221);
              validStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4224); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4226);
    match(MySQLStatementParser::UNTIL);
    setState(4227);
    expr(0);
    setState(4228);
    match(MySQLStatementParser::END);
    setState(4229);
    match(MySQLStatementParser::REPEAT);
    setState(4231);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 526, _ctx)) {
    case 1: {
      setState(4230);
      labelName();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

MySQLStatementParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ReturnStatementContext::RETURN() {
  return getToken(MySQLStatementParser::RETURN, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::ReturnStatementContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::ReturnStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReturnStatement;
}

void MySQLStatementParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void MySQLStatementParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}


antlrcpp::Any MySQLStatementParser::ReturnStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReturnStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReturnStatementContext* MySQLStatementParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 416, MySQLStatementParser::RuleReturnStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4233);
    match(MySQLStatementParser::RETURN);
    setState(4234);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileStatementContext ------------------------------------------------------------------

MySQLStatementParser::WhileStatementContext::WhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::WhileStatementContext::WHILE() {
  return getTokens(MySQLStatementParser::WHILE);
}

tree::TerminalNode* MySQLStatementParser::WhileStatementContext::WHILE(size_t i) {
  return getToken(MySQLStatementParser::WHILE, i);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::WhileStatementContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WhileStatementContext::DO() {
  return getToken(MySQLStatementParser::DO, 0);
}

tree::TerminalNode* MySQLStatementParser::WhileStatementContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

std::vector<MySQLStatementParser::LabelNameContext *> MySQLStatementParser::WhileStatementContext::labelName() {
  return getRuleContexts<MySQLStatementParser::LabelNameContext>();
}

MySQLStatementParser::LabelNameContext* MySQLStatementParser::WhileStatementContext::labelName(size_t i) {
  return getRuleContext<MySQLStatementParser::LabelNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::WhileStatementContext::COLON_() {
  return getToken(MySQLStatementParser::COLON_, 0);
}

std::vector<MySQLStatementParser::ValidStatementContext *> MySQLStatementParser::WhileStatementContext::validStatement() {
  return getRuleContexts<MySQLStatementParser::ValidStatementContext>();
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::WhileStatementContext::validStatement(size_t i) {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(i);
}


size_t MySQLStatementParser::WhileStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWhileStatement;
}

void MySQLStatementParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}

void MySQLStatementParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}


antlrcpp::Any MySQLStatementParser::WhileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWhileStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WhileStatementContext* MySQLStatementParser::whileStatement() {
  WhileStatementContext *_localctx = _tracker.createInstance<WhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 418, MySQLStatementParser::RuleWhileStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4239);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(4236);
      labelName();
      setState(4237);
      match(MySQLStatementParser::COLON_);
    }
    setState(4241);
    match(MySQLStatementParser::WHILE);
    setState(4242);
    expr(0);
    setState(4243);
    match(MySQLStatementParser::DO);
    setState(4245); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4244);
              validStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4247); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 528, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4249);
    match(MySQLStatementParser::END);
    setState(4250);
    match(MySQLStatementParser::WHILE);
    setState(4252);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx)) {
    case 1: {
      setState(4251);
      labelName();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorStatementContext ------------------------------------------------------------------

MySQLStatementParser::CursorStatementContext::CursorStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CursorCloseStatementContext* MySQLStatementParser::CursorStatementContext::cursorCloseStatement() {
  return getRuleContext<MySQLStatementParser::CursorCloseStatementContext>(0);
}

MySQLStatementParser::CursorDeclareStatementContext* MySQLStatementParser::CursorStatementContext::cursorDeclareStatement() {
  return getRuleContext<MySQLStatementParser::CursorDeclareStatementContext>(0);
}

MySQLStatementParser::CursorFetchStatementContext* MySQLStatementParser::CursorStatementContext::cursorFetchStatement() {
  return getRuleContext<MySQLStatementParser::CursorFetchStatementContext>(0);
}

MySQLStatementParser::CursorOpenStatementContext* MySQLStatementParser::CursorStatementContext::cursorOpenStatement() {
  return getRuleContext<MySQLStatementParser::CursorOpenStatementContext>(0);
}


size_t MySQLStatementParser::CursorStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCursorStatement;
}

void MySQLStatementParser::CursorStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorStatement(this);
}

void MySQLStatementParser::CursorStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorStatement(this);
}


antlrcpp::Any MySQLStatementParser::CursorStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCursorStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CursorStatementContext* MySQLStatementParser::cursorStatement() {
  CursorStatementContext *_localctx = _tracker.createInstance<CursorStatementContext>(_ctx, getState());
  enterRule(_localctx, 420, MySQLStatementParser::RuleCursorStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4258);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CLOSE: {
        enterOuterAlt(_localctx, 1);
        setState(4254);
        cursorCloseStatement();
        break;
      }

      case MySQLStatementParser::DECLARE: {
        enterOuterAlt(_localctx, 2);
        setState(4255);
        cursorDeclareStatement();
        break;
      }

      case MySQLStatementParser::FETCH: {
        enterOuterAlt(_localctx, 3);
        setState(4256);
        cursorFetchStatement();
        break;
      }

      case MySQLStatementParser::OPEN: {
        enterOuterAlt(_localctx, 4);
        setState(4257);
        cursorOpenStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorCloseStatementContext ------------------------------------------------------------------

MySQLStatementParser::CursorCloseStatementContext::CursorCloseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CursorCloseStatementContext::CLOSE() {
  return getToken(MySQLStatementParser::CLOSE, 0);
}

MySQLStatementParser::CursorNameContext* MySQLStatementParser::CursorCloseStatementContext::cursorName() {
  return getRuleContext<MySQLStatementParser::CursorNameContext>(0);
}


size_t MySQLStatementParser::CursorCloseStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCursorCloseStatement;
}

void MySQLStatementParser::CursorCloseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorCloseStatement(this);
}

void MySQLStatementParser::CursorCloseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorCloseStatement(this);
}


antlrcpp::Any MySQLStatementParser::CursorCloseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCursorCloseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CursorCloseStatementContext* MySQLStatementParser::cursorCloseStatement() {
  CursorCloseStatementContext *_localctx = _tracker.createInstance<CursorCloseStatementContext>(_ctx, getState());
  enterRule(_localctx, 422, MySQLStatementParser::RuleCursorCloseStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4260);
    match(MySQLStatementParser::CLOSE);
    setState(4261);
    cursorName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorDeclareStatementContext ------------------------------------------------------------------

MySQLStatementParser::CursorDeclareStatementContext::CursorDeclareStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CursorDeclareStatementContext::DECLARE() {
  return getToken(MySQLStatementParser::DECLARE, 0);
}

MySQLStatementParser::CursorNameContext* MySQLStatementParser::CursorDeclareStatementContext::cursorName() {
  return getRuleContext<MySQLStatementParser::CursorNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CursorDeclareStatementContext::CURSOR() {
  return getToken(MySQLStatementParser::CURSOR, 0);
}

tree::TerminalNode* MySQLStatementParser::CursorDeclareStatementContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

MySQLStatementParser::SelectContext* MySQLStatementParser::CursorDeclareStatementContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}


size_t MySQLStatementParser::CursorDeclareStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCursorDeclareStatement;
}

void MySQLStatementParser::CursorDeclareStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorDeclareStatement(this);
}

void MySQLStatementParser::CursorDeclareStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorDeclareStatement(this);
}


antlrcpp::Any MySQLStatementParser::CursorDeclareStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCursorDeclareStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CursorDeclareStatementContext* MySQLStatementParser::cursorDeclareStatement() {
  CursorDeclareStatementContext *_localctx = _tracker.createInstance<CursorDeclareStatementContext>(_ctx, getState());
  enterRule(_localctx, 424, MySQLStatementParser::RuleCursorDeclareStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4263);
    match(MySQLStatementParser::DECLARE);
    setState(4264);
    cursorName();
    setState(4265);
    match(MySQLStatementParser::CURSOR);
    setState(4266);
    match(MySQLStatementParser::FOR);
    setState(4267);
    select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorFetchStatementContext ------------------------------------------------------------------

MySQLStatementParser::CursorFetchStatementContext::CursorFetchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CursorFetchStatementContext::FETCH() {
  return getToken(MySQLStatementParser::FETCH, 0);
}

MySQLStatementParser::CursorNameContext* MySQLStatementParser::CursorFetchStatementContext::cursorName() {
  return getRuleContext<MySQLStatementParser::CursorNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CursorFetchStatementContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

std::vector<MySQLStatementParser::VariableContext *> MySQLStatementParser::CursorFetchStatementContext::variable() {
  return getRuleContexts<MySQLStatementParser::VariableContext>();
}

MySQLStatementParser::VariableContext* MySQLStatementParser::CursorFetchStatementContext::variable(size_t i) {
  return getRuleContext<MySQLStatementParser::VariableContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CursorFetchStatementContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CursorFetchStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CursorFetchStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::CursorFetchStatementContext::NEXT() {
  return getToken(MySQLStatementParser::NEXT, 0);
}


size_t MySQLStatementParser::CursorFetchStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCursorFetchStatement;
}

void MySQLStatementParser::CursorFetchStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorFetchStatement(this);
}

void MySQLStatementParser::CursorFetchStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorFetchStatement(this);
}


antlrcpp::Any MySQLStatementParser::CursorFetchStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCursorFetchStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CursorFetchStatementContext* MySQLStatementParser::cursorFetchStatement() {
  CursorFetchStatementContext *_localctx = _tracker.createInstance<CursorFetchStatementContext>(_ctx, getState());
  enterRule(_localctx, 426, MySQLStatementParser::RuleCursorFetchStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4269);
    match(MySQLStatementParser::FETCH);
    setState(4274);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 532, _ctx)) {
    case 1: {
      setState(4271);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NEXT) {
        setState(4270);
        match(MySQLStatementParser::NEXT);
      }
      setState(4273);
      match(MySQLStatementParser::FROM);
      break;
    }

    }
    setState(4276);
    cursorName();
    setState(4277);
    match(MySQLStatementParser::INTO);
    setState(4278);
    variable();
    setState(4283);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4279);
      match(MySQLStatementParser::COMMA_);
      setState(4280);
      variable();
      setState(4285);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorOpenStatementContext ------------------------------------------------------------------

MySQLStatementParser::CursorOpenStatementContext::CursorOpenStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CursorOpenStatementContext::OPEN() {
  return getToken(MySQLStatementParser::OPEN, 0);
}

MySQLStatementParser::CursorNameContext* MySQLStatementParser::CursorOpenStatementContext::cursorName() {
  return getRuleContext<MySQLStatementParser::CursorNameContext>(0);
}


size_t MySQLStatementParser::CursorOpenStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCursorOpenStatement;
}

void MySQLStatementParser::CursorOpenStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorOpenStatement(this);
}

void MySQLStatementParser::CursorOpenStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorOpenStatement(this);
}


antlrcpp::Any MySQLStatementParser::CursorOpenStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCursorOpenStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CursorOpenStatementContext* MySQLStatementParser::cursorOpenStatement() {
  CursorOpenStatementContext *_localctx = _tracker.createInstance<CursorOpenStatementContext>(_ctx, getState());
  enterRule(_localctx, 428, MySQLStatementParser::RuleCursorOpenStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4286);
    match(MySQLStatementParser::OPEN);
    setState(4287);
    cursorName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionHandlingStatementContext ------------------------------------------------------------------

MySQLStatementParser::ConditionHandlingStatementContext::ConditionHandlingStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::DeclareConditionStatementContext* MySQLStatementParser::ConditionHandlingStatementContext::declareConditionStatement() {
  return getRuleContext<MySQLStatementParser::DeclareConditionStatementContext>(0);
}

MySQLStatementParser::DeclareHandlerStatementContext* MySQLStatementParser::ConditionHandlingStatementContext::declareHandlerStatement() {
  return getRuleContext<MySQLStatementParser::DeclareHandlerStatementContext>(0);
}

MySQLStatementParser::GetDiagnosticsStatementContext* MySQLStatementParser::ConditionHandlingStatementContext::getDiagnosticsStatement() {
  return getRuleContext<MySQLStatementParser::GetDiagnosticsStatementContext>(0);
}

MySQLStatementParser::ResignalStatementContext* MySQLStatementParser::ConditionHandlingStatementContext::resignalStatement() {
  return getRuleContext<MySQLStatementParser::ResignalStatementContext>(0);
}

MySQLStatementParser::SignalStatementContext* MySQLStatementParser::ConditionHandlingStatementContext::signalStatement() {
  return getRuleContext<MySQLStatementParser::SignalStatementContext>(0);
}


size_t MySQLStatementParser::ConditionHandlingStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConditionHandlingStatement;
}

void MySQLStatementParser::ConditionHandlingStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionHandlingStatement(this);
}

void MySQLStatementParser::ConditionHandlingStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionHandlingStatement(this);
}


antlrcpp::Any MySQLStatementParser::ConditionHandlingStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConditionHandlingStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConditionHandlingStatementContext* MySQLStatementParser::conditionHandlingStatement() {
  ConditionHandlingStatementContext *_localctx = _tracker.createInstance<ConditionHandlingStatementContext>(_ctx, getState());
  enterRule(_localctx, 430, MySQLStatementParser::RuleConditionHandlingStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4294);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 534, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4289);
      declareConditionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4290);
      declareHandlerStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4291);
      getDiagnosticsStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4292);
      resignalStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4293);
      signalStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareConditionStatementContext ------------------------------------------------------------------

MySQLStatementParser::DeclareConditionStatementContext::DeclareConditionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DeclareConditionStatementContext::DECLARE() {
  return getToken(MySQLStatementParser::DECLARE, 0);
}

MySQLStatementParser::ConditionNameContext* MySQLStatementParser::DeclareConditionStatementContext::conditionName() {
  return getRuleContext<MySQLStatementParser::ConditionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DeclareConditionStatementContext::CONDITION() {
  return getToken(MySQLStatementParser::CONDITION, 0);
}

tree::TerminalNode* MySQLStatementParser::DeclareConditionStatementContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

MySQLStatementParser::ConditionValueContext* MySQLStatementParser::DeclareConditionStatementContext::conditionValue() {
  return getRuleContext<MySQLStatementParser::ConditionValueContext>(0);
}


size_t MySQLStatementParser::DeclareConditionStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDeclareConditionStatement;
}

void MySQLStatementParser::DeclareConditionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareConditionStatement(this);
}

void MySQLStatementParser::DeclareConditionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareConditionStatement(this);
}


antlrcpp::Any MySQLStatementParser::DeclareConditionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDeclareConditionStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DeclareConditionStatementContext* MySQLStatementParser::declareConditionStatement() {
  DeclareConditionStatementContext *_localctx = _tracker.createInstance<DeclareConditionStatementContext>(_ctx, getState());
  enterRule(_localctx, 432, MySQLStatementParser::RuleDeclareConditionStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4296);
    match(MySQLStatementParser::DECLARE);
    setState(4297);
    conditionName();
    setState(4298);
    match(MySQLStatementParser::CONDITION);
    setState(4299);
    match(MySQLStatementParser::FOR);
    setState(4300);
    conditionValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareHandlerStatementContext ------------------------------------------------------------------

MySQLStatementParser::DeclareHandlerStatementContext::DeclareHandlerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DeclareHandlerStatementContext::DECLARE() {
  return getToken(MySQLStatementParser::DECLARE, 0);
}

MySQLStatementParser::HandlerActionContext* MySQLStatementParser::DeclareHandlerStatementContext::handlerAction() {
  return getRuleContext<MySQLStatementParser::HandlerActionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DeclareHandlerStatementContext::HANDLER() {
  return getToken(MySQLStatementParser::HANDLER, 0);
}

tree::TerminalNode* MySQLStatementParser::DeclareHandlerStatementContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

std::vector<MySQLStatementParser::ConditionValueContext *> MySQLStatementParser::DeclareHandlerStatementContext::conditionValue() {
  return getRuleContexts<MySQLStatementParser::ConditionValueContext>();
}

MySQLStatementParser::ConditionValueContext* MySQLStatementParser::DeclareHandlerStatementContext::conditionValue(size_t i) {
  return getRuleContext<MySQLStatementParser::ConditionValueContext>(i);
}

MySQLStatementParser::ValidStatementContext* MySQLStatementParser::DeclareHandlerStatementContext::validStatement() {
  return getRuleContext<MySQLStatementParser::ValidStatementContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DeclareHandlerStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::DeclareHandlerStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::DeclareHandlerStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDeclareHandlerStatement;
}

void MySQLStatementParser::DeclareHandlerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareHandlerStatement(this);
}

void MySQLStatementParser::DeclareHandlerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareHandlerStatement(this);
}


antlrcpp::Any MySQLStatementParser::DeclareHandlerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDeclareHandlerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DeclareHandlerStatementContext* MySQLStatementParser::declareHandlerStatement() {
  DeclareHandlerStatementContext *_localctx = _tracker.createInstance<DeclareHandlerStatementContext>(_ctx, getState());
  enterRule(_localctx, 434, MySQLStatementParser::RuleDeclareHandlerStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4302);
    match(MySQLStatementParser::DECLARE);
    setState(4303);
    handlerAction();
    setState(4304);
    match(MySQLStatementParser::HANDLER);
    setState(4305);
    match(MySQLStatementParser::FOR);
    setState(4306);
    conditionValue();
    setState(4311);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4307);
      match(MySQLStatementParser::COMMA_);
      setState(4308);
      conditionValue();
      setState(4313);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4314);
    validStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetDiagnosticsStatementContext ------------------------------------------------------------------

MySQLStatementParser::GetDiagnosticsStatementContext::GetDiagnosticsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::GetDiagnosticsStatementContext::GET() {
  return getToken(MySQLStatementParser::GET, 0);
}

tree::TerminalNode* MySQLStatementParser::GetDiagnosticsStatementContext::DIAGNOSTICS() {
  return getToken(MySQLStatementParser::DIAGNOSTICS, 0);
}

tree::TerminalNode* MySQLStatementParser::GetDiagnosticsStatementContext::CURRENT() {
  return getToken(MySQLStatementParser::CURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::GetDiagnosticsStatementContext::STACKED() {
  return getToken(MySQLStatementParser::STACKED, 0);
}

std::vector<MySQLStatementParser::StatementInformationItemContext *> MySQLStatementParser::GetDiagnosticsStatementContext::statementInformationItem() {
  return getRuleContexts<MySQLStatementParser::StatementInformationItemContext>();
}

MySQLStatementParser::StatementInformationItemContext* MySQLStatementParser::GetDiagnosticsStatementContext::statementInformationItem(size_t i) {
  return getRuleContext<MySQLStatementParser::StatementInformationItemContext>(i);
}

tree::TerminalNode* MySQLStatementParser::GetDiagnosticsStatementContext::CONDITION() {
  return getToken(MySQLStatementParser::CONDITION, 0);
}

MySQLStatementParser::ConditionNumberContext* MySQLStatementParser::GetDiagnosticsStatementContext::conditionNumber() {
  return getRuleContext<MySQLStatementParser::ConditionNumberContext>(0);
}

std::vector<MySQLStatementParser::ConditionInformationItemContext *> MySQLStatementParser::GetDiagnosticsStatementContext::conditionInformationItem() {
  return getRuleContexts<MySQLStatementParser::ConditionInformationItemContext>();
}

MySQLStatementParser::ConditionInformationItemContext* MySQLStatementParser::GetDiagnosticsStatementContext::conditionInformationItem(size_t i) {
  return getRuleContext<MySQLStatementParser::ConditionInformationItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::GetDiagnosticsStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::GetDiagnosticsStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::GetDiagnosticsStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGetDiagnosticsStatement;
}

void MySQLStatementParser::GetDiagnosticsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetDiagnosticsStatement(this);
}

void MySQLStatementParser::GetDiagnosticsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetDiagnosticsStatement(this);
}


antlrcpp::Any MySQLStatementParser::GetDiagnosticsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGetDiagnosticsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GetDiagnosticsStatementContext* MySQLStatementParser::getDiagnosticsStatement() {
  GetDiagnosticsStatementContext *_localctx = _tracker.createInstance<GetDiagnosticsStatementContext>(_ctx, getState());
  enterRule(_localctx, 436, MySQLStatementParser::RuleGetDiagnosticsStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4316);
    match(MySQLStatementParser::GET);
    setState(4318);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CURRENT || _la == MySQLStatementParser::STACKED) {
      setState(4317);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::CURRENT || _la == MySQLStatementParser::STACKED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(4320);
    match(MySQLStatementParser::DIAGNOSTICS);

    setState(4339);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::DOT_:
      case MySQLStatementParser::AT_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(4321);
        statementInformationItem();
        setState(4326);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(4322);
          match(MySQLStatementParser::COMMA_);
          setState(4323);
          statementInformationItem();
          setState(4328);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::CONDITION: {
        setState(4329);
        match(MySQLStatementParser::CONDITION);
        setState(4330);
        conditionNumber();
        setState(4331);
        conditionInformationItem();
        setState(4336);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(4332);
          match(MySQLStatementParser::COMMA_);
          setState(4333);
          conditionInformationItem();
          setState(4338);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementInformationItemContext ------------------------------------------------------------------

MySQLStatementParser::StatementInformationItemContext::StatementInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::VariableContext* MySQLStatementParser::StatementInformationItemContext::variable() {
  return getRuleContext<MySQLStatementParser::VariableContext>(0);
}

tree::TerminalNode* MySQLStatementParser::StatementInformationItemContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::StatementInformationItemNameContext* MySQLStatementParser::StatementInformationItemContext::statementInformationItemName() {
  return getRuleContext<MySQLStatementParser::StatementInformationItemNameContext>(0);
}


size_t MySQLStatementParser::StatementInformationItemContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStatementInformationItem;
}

void MySQLStatementParser::StatementInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementInformationItem(this);
}

void MySQLStatementParser::StatementInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementInformationItem(this);
}


antlrcpp::Any MySQLStatementParser::StatementInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStatementInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StatementInformationItemContext* MySQLStatementParser::statementInformationItem() {
  StatementInformationItemContext *_localctx = _tracker.createInstance<StatementInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 438, MySQLStatementParser::RuleStatementInformationItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4341);
    variable();
    setState(4342);
    match(MySQLStatementParser::EQ_);
    setState(4343);
    statementInformationItemName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionInformationItemContext ------------------------------------------------------------------

MySQLStatementParser::ConditionInformationItemContext::ConditionInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::VariableContext* MySQLStatementParser::ConditionInformationItemContext::variable() {
  return getRuleContext<MySQLStatementParser::VariableContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::ConditionInformationItemNameContext* MySQLStatementParser::ConditionInformationItemContext::conditionInformationItemName() {
  return getRuleContext<MySQLStatementParser::ConditionInformationItemNameContext>(0);
}


size_t MySQLStatementParser::ConditionInformationItemContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConditionInformationItem;
}

void MySQLStatementParser::ConditionInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionInformationItem(this);
}

void MySQLStatementParser::ConditionInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionInformationItem(this);
}


antlrcpp::Any MySQLStatementParser::ConditionInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConditionInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConditionInformationItemContext* MySQLStatementParser::conditionInformationItem() {
  ConditionInformationItemContext *_localctx = _tracker.createInstance<ConditionInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 440, MySQLStatementParser::RuleConditionInformationItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4345);
    variable();
    setState(4346);
    match(MySQLStatementParser::EQ_);
    setState(4347);
    conditionInformationItemName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionNumberContext ------------------------------------------------------------------

MySQLStatementParser::ConditionNumberContext::ConditionNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::VariableContext* MySQLStatementParser::ConditionNumberContext::variable() {
  return getRuleContext<MySQLStatementParser::VariableContext>(0);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::ConditionNumberContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}


size_t MySQLStatementParser::ConditionNumberContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConditionNumber;
}

void MySQLStatementParser::ConditionNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionNumber(this);
}

void MySQLStatementParser::ConditionNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionNumber(this);
}


antlrcpp::Any MySQLStatementParser::ConditionNumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConditionNumber(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConditionNumberContext* MySQLStatementParser::conditionNumber() {
  ConditionNumberContext *_localctx = _tracker.createInstance<ConditionNumberContext>(_ctx, getState());
  enterRule(_localctx, 442, MySQLStatementParser::RuleConditionNumber);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4351);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::DOT_:
      case MySQLStatementParser::AT_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(4349);
        variable();
        break;
      }

      case MySQLStatementParser::NUMBER_: {
        enterOuterAlt(_localctx, 2);
        setState(4350);
        numberLiterals();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementInformationItemNameContext ------------------------------------------------------------------

MySQLStatementParser::StatementInformationItemNameContext::StatementInformationItemNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StatementInformationItemNameContext::NUMBER() {
  return getToken(MySQLStatementParser::NUMBER, 0);
}

tree::TerminalNode* MySQLStatementParser::StatementInformationItemNameContext::ROW_COUNT() {
  return getToken(MySQLStatementParser::ROW_COUNT, 0);
}


size_t MySQLStatementParser::StatementInformationItemNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStatementInformationItemName;
}

void MySQLStatementParser::StatementInformationItemNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementInformationItemName(this);
}

void MySQLStatementParser::StatementInformationItemNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementInformationItemName(this);
}


antlrcpp::Any MySQLStatementParser::StatementInformationItemNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStatementInformationItemName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StatementInformationItemNameContext* MySQLStatementParser::statementInformationItemName() {
  StatementInformationItemNameContext *_localctx = _tracker.createInstance<StatementInformationItemNameContext>(_ctx, getState());
  enterRule(_localctx, 444, MySQLStatementParser::RuleStatementInformationItemName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4353);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::NUMBER || _la == MySQLStatementParser::ROW_COUNT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionInformationItemNameContext ------------------------------------------------------------------

MySQLStatementParser::ConditionInformationItemNameContext::ConditionInformationItemNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::CLASS_ORIGIN() {
  return getToken(MySQLStatementParser::CLASS_ORIGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::SUBCLASS_ORIGIN() {
  return getToken(MySQLStatementParser::SUBCLASS_ORIGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::RETURNED_SQLSTATE() {
  return getToken(MySQLStatementParser::RETURNED_SQLSTATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::MESSAGE_TEXT() {
  return getToken(MySQLStatementParser::MESSAGE_TEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::MYSQL_ERRNO() {
  return getToken(MySQLStatementParser::MYSQL_ERRNO, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::CONSTRAINT_CATALOG() {
  return getToken(MySQLStatementParser::CONSTRAINT_CATALOG, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::CONSTRAINT_SCHEMA() {
  return getToken(MySQLStatementParser::CONSTRAINT_SCHEMA, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::CONSTRAINT_NAME() {
  return getToken(MySQLStatementParser::CONSTRAINT_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::CATALOG_NAME() {
  return getToken(MySQLStatementParser::CATALOG_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::SCHEMA_NAME() {
  return getToken(MySQLStatementParser::SCHEMA_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::TABLE_NAME() {
  return getToken(MySQLStatementParser::TABLE_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::COLUMN_NAME() {
  return getToken(MySQLStatementParser::COLUMN_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionInformationItemNameContext::CURSOR_NAME() {
  return getToken(MySQLStatementParser::CURSOR_NAME, 0);
}


size_t MySQLStatementParser::ConditionInformationItemNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConditionInformationItemName;
}

void MySQLStatementParser::ConditionInformationItemNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionInformationItemName(this);
}

void MySQLStatementParser::ConditionInformationItemNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionInformationItemName(this);
}


antlrcpp::Any MySQLStatementParser::ConditionInformationItemNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConditionInformationItemName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConditionInformationItemNameContext* MySQLStatementParser::conditionInformationItemName() {
  ConditionInformationItemNameContext *_localctx = _tracker.createInstance<ConditionInformationItemNameContext>(_ctx, getState());
  enterRule(_localctx, 446, MySQLStatementParser::RuleConditionInformationItemName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4355);
    _la = _input->LA(1);
    if (!(((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & ((1ULL << (MySQLStatementParser::CATALOG_NAME - 74))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 74))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 74))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 74))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 74))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 74))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 74)))) != 0) || _la == MySQLStatementParser::MESSAGE_TEXT

    || _la == MySQLStatementParser::MYSQL_ERRNO || _la == MySQLStatementParser::RETURNED_SQLSTATE

    || _la == MySQLStatementParser::SCHEMA_NAME || _la == MySQLStatementParser::SUBCLASS_ORIGIN

    || _la == MySQLStatementParser::TABLE_NAME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerActionContext ------------------------------------------------------------------

MySQLStatementParser::HandlerActionContext::HandlerActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HandlerActionContext::CONTINUE() {
  return getToken(MySQLStatementParser::CONTINUE, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerActionContext::EXIT() {
  return getToken(MySQLStatementParser::EXIT, 0);
}

tree::TerminalNode* MySQLStatementParser::HandlerActionContext::UNDO() {
  return getToken(MySQLStatementParser::UNDO, 0);
}


size_t MySQLStatementParser::HandlerActionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHandlerAction;
}

void MySQLStatementParser::HandlerActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerAction(this);
}

void MySQLStatementParser::HandlerActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerAction(this);
}


antlrcpp::Any MySQLStatementParser::HandlerActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHandlerAction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HandlerActionContext* MySQLStatementParser::handlerAction() {
  HandlerActionContext *_localctx = _tracker.createInstance<HandlerActionContext>(_ctx, getState());
  enterRule(_localctx, 448, MySQLStatementParser::RuleHandlerAction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4357);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::CONTINUE || _la == MySQLStatementParser::EXIT || _la == MySQLStatementParser::UNDO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionValueContext ------------------------------------------------------------------

MySQLStatementParser::ConditionValueContext::ConditionValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::ConditionValueContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ConditionValueContext::SQLSTATE() {
  return getToken(MySQLStatementParser::SQLSTATE, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::ConditionValueContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ConditionValueContext::VALUE() {
  return getToken(MySQLStatementParser::VALUE, 0);
}

MySQLStatementParser::ConditionNameContext* MySQLStatementParser::ConditionValueContext::conditionName() {
  return getRuleContext<MySQLStatementParser::ConditionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ConditionValueContext::SQLWARNING() {
  return getToken(MySQLStatementParser::SQLWARNING, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionValueContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionValueContext::FOUND() {
  return getToken(MySQLStatementParser::FOUND, 0);
}

tree::TerminalNode* MySQLStatementParser::ConditionValueContext::SQLEXCEPTION() {
  return getToken(MySQLStatementParser::SQLEXCEPTION, 0);
}


size_t MySQLStatementParser::ConditionValueContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConditionValue;
}

void MySQLStatementParser::ConditionValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionValue(this);
}

void MySQLStatementParser::ConditionValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionValue(this);
}


antlrcpp::Any MySQLStatementParser::ConditionValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConditionValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConditionValueContext* MySQLStatementParser::conditionValue() {
  ConditionValueContext *_localctx = _tracker.createInstance<ConditionValueContext>(_ctx, getState());
  enterRule(_localctx, 450, MySQLStatementParser::RuleConditionValue);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4370);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::NUMBER_: {
        enterOuterAlt(_localctx, 1);
        setState(4359);
        numberLiterals();
        break;
      }

      case MySQLStatementParser::SQLSTATE: {
        enterOuterAlt(_localctx, 2);
        setState(4360);
        match(MySQLStatementParser::SQLSTATE);
        setState(4362);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::VALUE) {
          setState(4361);
          match(MySQLStatementParser::VALUE);
        }
        setState(4364);
        stringLiterals();
        break;
      }

      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 3);
        setState(4365);
        conditionName();
        break;
      }

      case MySQLStatementParser::SQLWARNING: {
        enterOuterAlt(_localctx, 4);
        setState(4366);
        match(MySQLStatementParser::SQLWARNING);
        break;
      }

      case MySQLStatementParser::NOT: {
        enterOuterAlt(_localctx, 5);
        setState(4367);
        match(MySQLStatementParser::NOT);
        setState(4368);
        match(MySQLStatementParser::FOUND);
        break;
      }

      case MySQLStatementParser::SQLEXCEPTION: {
        enterOuterAlt(_localctx, 6);
        setState(4369);
        match(MySQLStatementParser::SQLEXCEPTION);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResignalStatementContext ------------------------------------------------------------------

MySQLStatementParser::ResignalStatementContext::ResignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ResignalStatementContext::RESIGNAL() {
  return getToken(MySQLStatementParser::RESIGNAL, 0);
}

MySQLStatementParser::ConditionValueContext* MySQLStatementParser::ResignalStatementContext::conditionValue() {
  return getRuleContext<MySQLStatementParser::ConditionValueContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ResignalStatementContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

std::vector<MySQLStatementParser::SignalInformationItemContext *> MySQLStatementParser::ResignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLStatementParser::SignalInformationItemContext>();
}

MySQLStatementParser::SignalInformationItemContext* MySQLStatementParser::ResignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLStatementParser::SignalInformationItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ResignalStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ResignalStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::ResignalStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleResignalStatement;
}

void MySQLStatementParser::ResignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResignalStatement(this);
}

void MySQLStatementParser::ResignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResignalStatement(this);
}


antlrcpp::Any MySQLStatementParser::ResignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitResignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ResignalStatementContext* MySQLStatementParser::resignalStatement() {
  ResignalStatementContext *_localctx = _tracker.createInstance<ResignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 452, MySQLStatementParser::RuleResignalStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4372);
    match(MySQLStatementParser::RESIGNAL);
    setState(4374);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 543, _ctx)) {
    case 1: {
      setState(4373);
      conditionValue();
      break;
    }

    }
    setState(4385);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 545, _ctx)) {
    case 1: {
      setState(4376);
      match(MySQLStatementParser::SET);
      setState(4377);
      signalInformationItem();
      setState(4382);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(4378);
        match(MySQLStatementParser::COMMA_);
        setState(4379);
        signalInformationItem();
        setState(4384);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalStatementContext ------------------------------------------------------------------

MySQLStatementParser::SignalStatementContext::SignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SignalStatementContext::SIGNAL() {
  return getToken(MySQLStatementParser::SIGNAL, 0);
}

MySQLStatementParser::ConditionValueContext* MySQLStatementParser::SignalStatementContext::conditionValue() {
  return getRuleContext<MySQLStatementParser::ConditionValueContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SignalStatementContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

std::vector<MySQLStatementParser::SignalInformationItemContext *> MySQLStatementParser::SignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLStatementParser::SignalInformationItemContext>();
}

MySQLStatementParser::SignalInformationItemContext* MySQLStatementParser::SignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLStatementParser::SignalInformationItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SignalStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SignalStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SignalStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSignalStatement;
}

void MySQLStatementParser::SignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalStatement(this);
}

void MySQLStatementParser::SignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalStatement(this);
}


antlrcpp::Any MySQLStatementParser::SignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SignalStatementContext* MySQLStatementParser::signalStatement() {
  SignalStatementContext *_localctx = _tracker.createInstance<SignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 454, MySQLStatementParser::RuleSignalStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4387);
    match(MySQLStatementParser::SIGNAL);
    setState(4388);
    conditionValue();
    setState(4398);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 547, _ctx)) {
    case 1: {
      setState(4389);
      match(MySQLStatementParser::SET);
      setState(4390);
      signalInformationItem();
      setState(4395);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(4391);
        match(MySQLStatementParser::COMMA_);
        setState(4392);
        signalInformationItem();
        setState(4397);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalInformationItemContext ------------------------------------------------------------------

MySQLStatementParser::SignalInformationItemContext::SignalInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ConditionInformationItemNameContext* MySQLStatementParser::SignalInformationItemContext::conditionInformationItemName() {
  return getRuleContext<MySQLStatementParser::ConditionInformationItemNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SignalInformationItemContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::SignalInformationItemContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::SignalInformationItemContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSignalInformationItem;
}

void MySQLStatementParser::SignalInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalInformationItem(this);
}

void MySQLStatementParser::SignalInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalInformationItem(this);
}


antlrcpp::Any MySQLStatementParser::SignalInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSignalInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SignalInformationItemContext* MySQLStatementParser::signalInformationItem() {
  SignalInformationItemContext *_localctx = _tracker.createInstance<SignalInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 456, MySQLStatementParser::RuleSignalInformationItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4400);
    conditionInformationItemName();
    setState(4401);
    match(MySQLStatementParser::EQ_);
    setState(4402);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTransactionContext ------------------------------------------------------------------

MySQLStatementParser::SetTransactionContext::SetTransactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetTransactionContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::SetTransactionContext::TRANSACTION() {
  return getToken(MySQLStatementParser::TRANSACTION, 0);
}

std::vector<MySQLStatementParser::TransactionCharacteristicContext *> MySQLStatementParser::SetTransactionContext::transactionCharacteristic() {
  return getRuleContexts<MySQLStatementParser::TransactionCharacteristicContext>();
}

MySQLStatementParser::TransactionCharacteristicContext* MySQLStatementParser::SetTransactionContext::transactionCharacteristic(size_t i) {
  return getRuleContext<MySQLStatementParser::TransactionCharacteristicContext>(i);
}

MySQLStatementParser::ScopeContext* MySQLStatementParser::SetTransactionContext::scope() {
  return getRuleContext<MySQLStatementParser::ScopeContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetTransactionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SetTransactionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SetTransactionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetTransaction;
}

void MySQLStatementParser::SetTransactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetTransaction(this);
}

void MySQLStatementParser::SetTransactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetTransaction(this);
}


antlrcpp::Any MySQLStatementParser::SetTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetTransaction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetTransactionContext* MySQLStatementParser::setTransaction() {
  SetTransactionContext *_localctx = _tracker.createInstance<SetTransactionContext>(_ctx, getState());
  enterRule(_localctx, 458, MySQLStatementParser::RuleSetTransaction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4404);
    match(MySQLStatementParser::SET);
    setState(4406);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::GLOBAL || _la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::PERSIST

    || _la == MySQLStatementParser::PERSIST_ONLY || _la == MySQLStatementParser::SESSION) {
      setState(4405);
      scope();
    }
    setState(4408);
    match(MySQLStatementParser::TRANSACTION);
    setState(4409);
    transactionCharacteristic();
    setState(4414);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4410);
      match(MySQLStatementParser::COMMA_);
      setState(4411);
      transactionCharacteristic();
      setState(4416);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetAutoCommitContext ------------------------------------------------------------------

MySQLStatementParser::SetAutoCommitContext::SetAutoCommitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetAutoCommitContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::SetAutoCommitContext::AUTOCOMMIT() {
  return getToken(MySQLStatementParser::AUTOCOMMIT, 0);
}

tree::TerminalNode* MySQLStatementParser::SetAutoCommitContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::AutoCommitValueContext* MySQLStatementParser::SetAutoCommitContext::autoCommitValue() {
  return getRuleContext<MySQLStatementParser::AutoCommitValueContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetAutoCommitContext::AT_() {
  return getTokens(MySQLStatementParser::AT_);
}

tree::TerminalNode* MySQLStatementParser::SetAutoCommitContext::AT_(size_t i) {
  return getToken(MySQLStatementParser::AT_, i);
}

MySQLStatementParser::ScopeContext* MySQLStatementParser::SetAutoCommitContext::scope() {
  return getRuleContext<MySQLStatementParser::ScopeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SetAutoCommitContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::SetAutoCommitContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetAutoCommit;
}

void MySQLStatementParser::SetAutoCommitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetAutoCommit(this);
}

void MySQLStatementParser::SetAutoCommitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetAutoCommit(this);
}


antlrcpp::Any MySQLStatementParser::SetAutoCommitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetAutoCommit(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetAutoCommitContext* MySQLStatementParser::setAutoCommit() {
  SetAutoCommitContext *_localctx = _tracker.createInstance<SetAutoCommitContext>(_ctx, getState());
  enterRule(_localctx, 460, MySQLStatementParser::RuleSetAutoCommit);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4417);
    match(MySQLStatementParser::SET);
    setState(4422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AT_) {
      setState(4419);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 550, _ctx)) {
      case 1: {
        setState(4418);
        match(MySQLStatementParser::AT_);
        break;
      }

      }
      setState(4421);
      match(MySQLStatementParser::AT_);
    }
    setState(4425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::GLOBAL || _la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::PERSIST

    || _la == MySQLStatementParser::PERSIST_ONLY || _la == MySQLStatementParser::SESSION) {
      setState(4424);
      scope();
    }
    setState(4428);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DOT_) {
      setState(4427);
      match(MySQLStatementParser::DOT_);
    }
    setState(4430);
    match(MySQLStatementParser::AUTOCOMMIT);
    setState(4431);
    match(MySQLStatementParser::EQ_);
    setState(4432);
    autoCommitValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AutoCommitValueContext ------------------------------------------------------------------

MySQLStatementParser::AutoCommitValueContext::AutoCommitValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AutoCommitValueContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::AutoCommitValueContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

tree::TerminalNode* MySQLStatementParser::AutoCommitValueContext::OFF() {
  return getToken(MySQLStatementParser::OFF, 0);
}


size_t MySQLStatementParser::AutoCommitValueContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAutoCommitValue;
}

void MySQLStatementParser::AutoCommitValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAutoCommitValue(this);
}

void MySQLStatementParser::AutoCommitValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAutoCommitValue(this);
}


antlrcpp::Any MySQLStatementParser::AutoCommitValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAutoCommitValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AutoCommitValueContext* MySQLStatementParser::autoCommitValue() {
  AutoCommitValueContext *_localctx = _tracker.createInstance<AutoCommitValueContext>(_ctx, getState());
  enterRule(_localctx, 462, MySQLStatementParser::RuleAutoCommitValue);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4434);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::OFF

    || _la == MySQLStatementParser::ON || _la == MySQLStatementParser::NUMBER_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginTransactionContext ------------------------------------------------------------------

MySQLStatementParser::BeginTransactionContext::BeginTransactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BeginTransactionContext::BEGIN() {
  return getToken(MySQLStatementParser::BEGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::BeginTransactionContext::START() {
  return getToken(MySQLStatementParser::START, 0);
}

tree::TerminalNode* MySQLStatementParser::BeginTransactionContext::TRANSACTION() {
  return getToken(MySQLStatementParser::TRANSACTION, 0);
}

std::vector<MySQLStatementParser::TransactionCharacteristicContext *> MySQLStatementParser::BeginTransactionContext::transactionCharacteristic() {
  return getRuleContexts<MySQLStatementParser::TransactionCharacteristicContext>();
}

MySQLStatementParser::TransactionCharacteristicContext* MySQLStatementParser::BeginTransactionContext::transactionCharacteristic(size_t i) {
  return getRuleContext<MySQLStatementParser::TransactionCharacteristicContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::BeginTransactionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::BeginTransactionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::BeginTransactionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBeginTransaction;
}

void MySQLStatementParser::BeginTransactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginTransaction(this);
}

void MySQLStatementParser::BeginTransactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginTransaction(this);
}


antlrcpp::Any MySQLStatementParser::BeginTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBeginTransaction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BeginTransactionContext* MySQLStatementParser::beginTransaction() {
  BeginTransactionContext *_localctx = _tracker.createInstance<BeginTransactionContext>(_ctx, getState());
  enterRule(_localctx, 464, MySQLStatementParser::RuleBeginTransaction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4449);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::BEGIN: {
        enterOuterAlt(_localctx, 1);
        setState(4436);
        match(MySQLStatementParser::BEGIN);
        break;
      }

      case MySQLStatementParser::START: {
        enterOuterAlt(_localctx, 2);
        setState(4437);
        match(MySQLStatementParser::START);
        setState(4438);
        match(MySQLStatementParser::TRANSACTION);
        setState(4447);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ISOLATION || _la == MySQLStatementParser::READ || _la == MySQLStatementParser::WITH) {
          setState(4439);
          transactionCharacteristic();
          setState(4444);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySQLStatementParser::COMMA_) {
            setState(4440);
            match(MySQLStatementParser::COMMA_);
            setState(4441);
            transactionCharacteristic();
            setState(4446);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommitContext ------------------------------------------------------------------

MySQLStatementParser::CommitContext::CommitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CommitContext::COMMIT() {
  return getToken(MySQLStatementParser::COMMIT, 0);
}

tree::TerminalNode* MySQLStatementParser::CommitContext::WORK() {
  return getToken(MySQLStatementParser::WORK, 0);
}

MySQLStatementParser::OptionChainContext* MySQLStatementParser::CommitContext::optionChain() {
  return getRuleContext<MySQLStatementParser::OptionChainContext>(0);
}

MySQLStatementParser::OptionReleaseContext* MySQLStatementParser::CommitContext::optionRelease() {
  return getRuleContext<MySQLStatementParser::OptionReleaseContext>(0);
}


size_t MySQLStatementParser::CommitContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCommit;
}

void MySQLStatementParser::CommitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommit(this);
}

void MySQLStatementParser::CommitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommit(this);
}


antlrcpp::Any MySQLStatementParser::CommitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCommit(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CommitContext* MySQLStatementParser::commit() {
  CommitContext *_localctx = _tracker.createInstance<CommitContext>(_ctx, getState());
  enterRule(_localctx, 466, MySQLStatementParser::RuleCommit);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4451);
    match(MySQLStatementParser::COMMIT);
    setState(4453);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WORK) {
      setState(4452);
      match(MySQLStatementParser::WORK);
    }
    setState(4456);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AND) {
      setState(4455);
      optionChain();
    }
    setState(4459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::NO || _la == MySQLStatementParser::RELEASE) {
      setState(4458);
      optionRelease();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RollbackContext ------------------------------------------------------------------

MySQLStatementParser::RollbackContext::RollbackContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RollbackContext::ROLLBACK() {
  return getToken(MySQLStatementParser::ROLLBACK, 0);
}

tree::TerminalNode* MySQLStatementParser::RollbackContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::RollbackContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::RollbackContext::WORK() {
  return getToken(MySQLStatementParser::WORK, 0);
}

tree::TerminalNode* MySQLStatementParser::RollbackContext::SAVEPOINT() {
  return getToken(MySQLStatementParser::SAVEPOINT, 0);
}

MySQLStatementParser::OptionChainContext* MySQLStatementParser::RollbackContext::optionChain() {
  return getRuleContext<MySQLStatementParser::OptionChainContext>(0);
}

MySQLStatementParser::OptionReleaseContext* MySQLStatementParser::RollbackContext::optionRelease() {
  return getRuleContext<MySQLStatementParser::OptionReleaseContext>(0);
}


size_t MySQLStatementParser::RollbackContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRollback;
}

void MySQLStatementParser::RollbackContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRollback(this);
}

void MySQLStatementParser::RollbackContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRollback(this);
}


antlrcpp::Any MySQLStatementParser::RollbackContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRollback(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RollbackContext* MySQLStatementParser::rollback() {
  RollbackContext *_localctx = _tracker.createInstance<RollbackContext>(_ctx, getState());
  enterRule(_localctx, 468, MySQLStatementParser::RuleRollback);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4461);
    match(MySQLStatementParser::ROLLBACK);
    setState(4479);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 565, _ctx)) {
    case 1: {
      setState(4463);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::WORK) {
        setState(4462);
        match(MySQLStatementParser::WORK);
      }
      setState(4465);
      match(MySQLStatementParser::TO);
      setState(4467);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 561, _ctx)) {
      case 1: {
        setState(4466);
        match(MySQLStatementParser::SAVEPOINT);
        break;
      }

      }
      setState(4469);
      identifier();
      break;
    }

    case 2: {
      setState(4471);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::WORK) {
        setState(4470);
        match(MySQLStatementParser::WORK);
      }
      setState(4474);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::AND) {
        setState(4473);
        optionChain();
      }
      setState(4477);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NO || _la == MySQLStatementParser::RELEASE) {
        setState(4476);
        optionRelease();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SavepointContext ------------------------------------------------------------------

MySQLStatementParser::SavepointContext::SavepointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SavepointContext::SAVEPOINT() {
  return getToken(MySQLStatementParser::SAVEPOINT, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::SavepointContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::SavepointContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSavepoint;
}

void MySQLStatementParser::SavepointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepoint(this);
}

void MySQLStatementParser::SavepointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepoint(this);
}


antlrcpp::Any MySQLStatementParser::SavepointContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSavepoint(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SavepointContext* MySQLStatementParser::savepoint() {
  SavepointContext *_localctx = _tracker.createInstance<SavepointContext>(_ctx, getState());
  enterRule(_localctx, 470, MySQLStatementParser::RuleSavepoint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4481);
    match(MySQLStatementParser::SAVEPOINT);
    setState(4482);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginContext ------------------------------------------------------------------

MySQLStatementParser::BeginContext::BeginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BeginContext::BEGIN() {
  return getToken(MySQLStatementParser::BEGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::BeginContext::WORK() {
  return getToken(MySQLStatementParser::WORK, 0);
}


size_t MySQLStatementParser::BeginContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBegin;
}

void MySQLStatementParser::BeginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin(this);
}

void MySQLStatementParser::BeginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin(this);
}


antlrcpp::Any MySQLStatementParser::BeginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBegin(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BeginContext* MySQLStatementParser::begin() {
  BeginContext *_localctx = _tracker.createInstance<BeginContext>(_ctx, getState());
  enterRule(_localctx, 472, MySQLStatementParser::RuleBegin);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4484);
    match(MySQLStatementParser::BEGIN);
    setState(4486);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WORK) {
      setState(4485);
      match(MySQLStatementParser::WORK);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockContext ------------------------------------------------------------------

MySQLStatementParser::LockContext::LockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LockContext::LOCK() {
  return getToken(MySQLStatementParser::LOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::LockContext::INSTANCE() {
  return getToken(MySQLStatementParser::INSTANCE, 0);
}

tree::TerminalNode* MySQLStatementParser::LockContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::LockContext::BACKUP() {
  return getToken(MySQLStatementParser::BACKUP, 0);
}

std::vector<MySQLStatementParser::TableLockContext *> MySQLStatementParser::LockContext::tableLock() {
  return getRuleContexts<MySQLStatementParser::TableLockContext>();
}

MySQLStatementParser::TableLockContext* MySQLStatementParser::LockContext::tableLock(size_t i) {
  return getRuleContext<MySQLStatementParser::TableLockContext>(i);
}

tree::TerminalNode* MySQLStatementParser::LockContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::LockContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LockContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::LockContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::LockContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLock;
}

void MySQLStatementParser::LockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLock(this);
}

void MySQLStatementParser::LockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLock(this);
}


antlrcpp::Any MySQLStatementParser::LockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLock(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LockContext* MySQLStatementParser::lock() {
  LockContext *_localctx = _tracker.createInstance<LockContext>(_ctx, getState());
  enterRule(_localctx, 474, MySQLStatementParser::RuleLock);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4488);
    match(MySQLStatementParser::LOCK);
    setState(4501);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::INSTANCE: {
        setState(4489);
        match(MySQLStatementParser::INSTANCE);
        setState(4490);
        match(MySQLStatementParser::FOR);
        setState(4491);
        match(MySQLStatementParser::BACKUP);
        break;
      }

      case MySQLStatementParser::TABLE:
      case MySQLStatementParser::TABLES: {
        setState(4492);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::TABLE

        || _la == MySQLStatementParser::TABLES)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4493);
        tableLock();
        setState(4498);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(4494);
          match(MySQLStatementParser::COMMA_);
          setState(4495);
          tableLock();
          setState(4500);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlockContext ------------------------------------------------------------------

MySQLStatementParser::UnlockContext::UnlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UnlockContext::UNLOCK() {
  return getToken(MySQLStatementParser::UNLOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnlockContext::INSTANCE() {
  return getToken(MySQLStatementParser::INSTANCE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnlockContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnlockContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}


size_t MySQLStatementParser::UnlockContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUnlock;
}

void MySQLStatementParser::UnlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlock(this);
}

void MySQLStatementParser::UnlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlock(this);
}


antlrcpp::Any MySQLStatementParser::UnlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUnlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UnlockContext* MySQLStatementParser::unlock() {
  UnlockContext *_localctx = _tracker.createInstance<UnlockContext>(_ctx, getState());
  enterRule(_localctx, 476, MySQLStatementParser::RuleUnlock);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4503);
    match(MySQLStatementParser::UNLOCK);
    setState(4504);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::INSTANCE || _la == MySQLStatementParser::TABLE

    || _la == MySQLStatementParser::TABLES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReleaseSavepointContext ------------------------------------------------------------------

MySQLStatementParser::ReleaseSavepointContext::ReleaseSavepointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ReleaseSavepointContext::RELEASE() {
  return getToken(MySQLStatementParser::RELEASE, 0);
}

tree::TerminalNode* MySQLStatementParser::ReleaseSavepointContext::SAVEPOINT() {
  return getToken(MySQLStatementParser::SAVEPOINT, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ReleaseSavepointContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::ReleaseSavepointContext::getRuleIndex() const {
  return MySQLStatementParser::RuleReleaseSavepoint;
}

void MySQLStatementParser::ReleaseSavepointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReleaseSavepoint(this);
}

void MySQLStatementParser::ReleaseSavepointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReleaseSavepoint(this);
}


antlrcpp::Any MySQLStatementParser::ReleaseSavepointContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitReleaseSavepoint(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ReleaseSavepointContext* MySQLStatementParser::releaseSavepoint() {
  ReleaseSavepointContext *_localctx = _tracker.createInstance<ReleaseSavepointContext>(_ctx, getState());
  enterRule(_localctx, 478, MySQLStatementParser::RuleReleaseSavepoint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4506);
    match(MySQLStatementParser::RELEASE);
    setState(4507);
    match(MySQLStatementParser::SAVEPOINT);
    setState(4508);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaContext ------------------------------------------------------------------

MySQLStatementParser::XaContext::XaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::XaContext::XA() {
  return getToken(MySQLStatementParser::XA, 0);
}

MySQLStatementParser::XidContext* MySQLStatementParser::XaContext::xid() {
  return getRuleContext<MySQLStatementParser::XidContext>(0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::PREPARE() {
  return getToken(MySQLStatementParser::PREPARE, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::COMMIT() {
  return getToken(MySQLStatementParser::COMMIT, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::ROLLBACK() {
  return getToken(MySQLStatementParser::ROLLBACK, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::RECOVER() {
  return getToken(MySQLStatementParser::RECOVER, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::START() {
  return getToken(MySQLStatementParser::START, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::BEGIN() {
  return getToken(MySQLStatementParser::BEGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::JOIN() {
  return getToken(MySQLStatementParser::JOIN, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::RESUME() {
  return getToken(MySQLStatementParser::RESUME, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::SUSPEND() {
  return getToken(MySQLStatementParser::SUSPEND, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::ONE() {
  return getToken(MySQLStatementParser::ONE, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::PHASE() {
  return getToken(MySQLStatementParser::PHASE, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::CONVERT() {
  return getToken(MySQLStatementParser::CONVERT, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::XaContext::MIGRATE() {
  return getToken(MySQLStatementParser::MIGRATE, 0);
}


size_t MySQLStatementParser::XaContext::getRuleIndex() const {
  return MySQLStatementParser::RuleXa;
}

void MySQLStatementParser::XaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXa(this);
}

void MySQLStatementParser::XaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXa(this);
}


antlrcpp::Any MySQLStatementParser::XaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitXa(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::XaContext* MySQLStatementParser::xa() {
  XaContext *_localctx = _tracker.createInstance<XaContext>(_ctx, getState());
  enterRule(_localctx, 480, MySQLStatementParser::RuleXa);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4510);
    match(MySQLStatementParser::XA);
    setState(4539);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::START: {
        setState(4511);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::BEGIN || _la == MySQLStatementParser::START)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4512);
        xid();
        setState(4513);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::JOIN || _la == MySQLStatementParser::RESUME)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLStatementParser::END: {
        setState(4515);
        match(MySQLStatementParser::END);
        setState(4516);
        xid();
        setState(4522);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::SUSPEND) {
          setState(4517);
          match(MySQLStatementParser::SUSPEND);
          setState(4520);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::FOR) {
            setState(4518);
            match(MySQLStatementParser::FOR);
            setState(4519);
            match(MySQLStatementParser::MIGRATE);
          }
        }
        break;
      }

      case MySQLStatementParser::PREPARE: {
        setState(4524);
        match(MySQLStatementParser::PREPARE);
        setState(4525);
        xid();
        break;
      }

      case MySQLStatementParser::COMMIT: {
        setState(4526);
        match(MySQLStatementParser::COMMIT);
        setState(4527);
        xid();
        setState(4530);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ONE) {
          setState(4528);
          match(MySQLStatementParser::ONE);
          setState(4529);
          match(MySQLStatementParser::PHASE);
        }
        break;
      }

      case MySQLStatementParser::ROLLBACK: {
        setState(4532);
        match(MySQLStatementParser::ROLLBACK);
        setState(4533);
        xid();
        break;
      }

      case MySQLStatementParser::RECOVER: {
        setState(4534);
        match(MySQLStatementParser::RECOVER);
        setState(4537);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::CONVERT) {
          setState(4535);
          match(MySQLStatementParser::CONVERT);
          setState(4536);
          xid();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionCharacteristicContext ------------------------------------------------------------------

MySQLStatementParser::TransactionCharacteristicContext::TransactionCharacteristicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TransactionCharacteristicContext::ISOLATION() {
  return getToken(MySQLStatementParser::ISOLATION, 0);
}

tree::TerminalNode* MySQLStatementParser::TransactionCharacteristicContext::LEVEL() {
  return getToken(MySQLStatementParser::LEVEL, 0);
}

MySQLStatementParser::LevelContext* MySQLStatementParser::TransactionCharacteristicContext::level() {
  return getRuleContext<MySQLStatementParser::LevelContext>(0);
}

MySQLStatementParser::AccessModeContext* MySQLStatementParser::TransactionCharacteristicContext::accessMode() {
  return getRuleContext<MySQLStatementParser::AccessModeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TransactionCharacteristicContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::TransactionCharacteristicContext::CONSISTENT() {
  return getToken(MySQLStatementParser::CONSISTENT, 0);
}

tree::TerminalNode* MySQLStatementParser::TransactionCharacteristicContext::SNAPSHOT() {
  return getToken(MySQLStatementParser::SNAPSHOT, 0);
}


size_t MySQLStatementParser::TransactionCharacteristicContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTransactionCharacteristic;
}

void MySQLStatementParser::TransactionCharacteristicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionCharacteristic(this);
}

void MySQLStatementParser::TransactionCharacteristicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionCharacteristic(this);
}


antlrcpp::Any MySQLStatementParser::TransactionCharacteristicContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTransactionCharacteristic(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TransactionCharacteristicContext* MySQLStatementParser::transactionCharacteristic() {
  TransactionCharacteristicContext *_localctx = _tracker.createInstance<TransactionCharacteristicContext>(_ctx, getState());
  enterRule(_localctx, 482, MySQLStatementParser::RuleTransactionCharacteristic);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4548);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ISOLATION: {
        enterOuterAlt(_localctx, 1);
        setState(4541);
        match(MySQLStatementParser::ISOLATION);
        setState(4542);
        match(MySQLStatementParser::LEVEL);
        setState(4543);
        level();
        break;
      }

      case MySQLStatementParser::READ: {
        enterOuterAlt(_localctx, 2);
        setState(4544);
        accessMode();
        break;
      }

      case MySQLStatementParser::WITH: {
        enterOuterAlt(_localctx, 3);
        setState(4545);
        match(MySQLStatementParser::WITH);
        setState(4546);
        match(MySQLStatementParser::CONSISTENT);
        setState(4547);
        match(MySQLStatementParser::SNAPSHOT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LevelContext ------------------------------------------------------------------

MySQLStatementParser::LevelContext::LevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LevelContext::REPEATABLE() {
  return getToken(MySQLStatementParser::REPEATABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::LevelContext::READ() {
  return getToken(MySQLStatementParser::READ, 0);
}

tree::TerminalNode* MySQLStatementParser::LevelContext::COMMITTED() {
  return getToken(MySQLStatementParser::COMMITTED, 0);
}

tree::TerminalNode* MySQLStatementParser::LevelContext::UNCOMMITTED() {
  return getToken(MySQLStatementParser::UNCOMMITTED, 0);
}

tree::TerminalNode* MySQLStatementParser::LevelContext::SERIALIZABLE() {
  return getToken(MySQLStatementParser::SERIALIZABLE, 0);
}


size_t MySQLStatementParser::LevelContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLevel;
}

void MySQLStatementParser::LevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevel(this);
}

void MySQLStatementParser::LevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevel(this);
}


antlrcpp::Any MySQLStatementParser::LevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLevel(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LevelContext* MySQLStatementParser::level() {
  LevelContext *_localctx = _tracker.createInstance<LevelContext>(_ctx, getState());
  enterRule(_localctx, 484, MySQLStatementParser::RuleLevel);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4557);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 575, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4550);
      match(MySQLStatementParser::REPEATABLE);
      setState(4551);
      match(MySQLStatementParser::READ);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4552);
      match(MySQLStatementParser::READ);
      setState(4553);
      match(MySQLStatementParser::COMMITTED);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4554);
      match(MySQLStatementParser::READ);
      setState(4555);
      match(MySQLStatementParser::UNCOMMITTED);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4556);
      match(MySQLStatementParser::SERIALIZABLE);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessModeContext ------------------------------------------------------------------

MySQLStatementParser::AccessModeContext::AccessModeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AccessModeContext::READ() {
  return getToken(MySQLStatementParser::READ, 0);
}

tree::TerminalNode* MySQLStatementParser::AccessModeContext::WRITE() {
  return getToken(MySQLStatementParser::WRITE, 0);
}

tree::TerminalNode* MySQLStatementParser::AccessModeContext::ONLY() {
  return getToken(MySQLStatementParser::ONLY, 0);
}


size_t MySQLStatementParser::AccessModeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAccessMode;
}

void MySQLStatementParser::AccessModeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessMode(this);
}

void MySQLStatementParser::AccessModeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessMode(this);
}


antlrcpp::Any MySQLStatementParser::AccessModeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAccessMode(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AccessModeContext* MySQLStatementParser::accessMode() {
  AccessModeContext *_localctx = _tracker.createInstance<AccessModeContext>(_ctx, getState());
  enterRule(_localctx, 486, MySQLStatementParser::RuleAccessMode);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4559);
    match(MySQLStatementParser::READ);
    setState(4560);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::ONLY || _la == MySQLStatementParser::WRITE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionChainContext ------------------------------------------------------------------

MySQLStatementParser::OptionChainContext::OptionChainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OptionChainContext::AND() {
  return getToken(MySQLStatementParser::AND, 0);
}

tree::TerminalNode* MySQLStatementParser::OptionChainContext::CHAIN() {
  return getToken(MySQLStatementParser::CHAIN, 0);
}

tree::TerminalNode* MySQLStatementParser::OptionChainContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}


size_t MySQLStatementParser::OptionChainContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOptionChain;
}

void MySQLStatementParser::OptionChainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionChain(this);
}

void MySQLStatementParser::OptionChainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionChain(this);
}


antlrcpp::Any MySQLStatementParser::OptionChainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOptionChain(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OptionChainContext* MySQLStatementParser::optionChain() {
  OptionChainContext *_localctx = _tracker.createInstance<OptionChainContext>(_ctx, getState());
  enterRule(_localctx, 488, MySQLStatementParser::RuleOptionChain);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4562);
    match(MySQLStatementParser::AND);
    setState(4564);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::NO) {
      setState(4563);
      match(MySQLStatementParser::NO);
    }
    setState(4566);
    match(MySQLStatementParser::CHAIN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionReleaseContext ------------------------------------------------------------------

MySQLStatementParser::OptionReleaseContext::OptionReleaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OptionReleaseContext::RELEASE() {
  return getToken(MySQLStatementParser::RELEASE, 0);
}

tree::TerminalNode* MySQLStatementParser::OptionReleaseContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}


size_t MySQLStatementParser::OptionReleaseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOptionRelease;
}

void MySQLStatementParser::OptionReleaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionRelease(this);
}

void MySQLStatementParser::OptionReleaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionRelease(this);
}


antlrcpp::Any MySQLStatementParser::OptionReleaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOptionRelease(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OptionReleaseContext* MySQLStatementParser::optionRelease() {
  OptionReleaseContext *_localctx = _tracker.createInstance<OptionReleaseContext>(_ctx, getState());
  enterRule(_localctx, 490, MySQLStatementParser::RuleOptionRelease);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::NO) {
      setState(4568);
      match(MySQLStatementParser::NO);
    }
    setState(4571);
    match(MySQLStatementParser::RELEASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableLockContext ------------------------------------------------------------------

MySQLStatementParser::TableLockContext::TableLockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::TableLockContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::LockOptionContext* MySQLStatementParser::TableLockContext::lockOption() {
  return getRuleContext<MySQLStatementParser::LockOptionContext>(0);
}

MySQLStatementParser::AliasContext* MySQLStatementParser::TableLockContext::alias() {
  return getRuleContext<MySQLStatementParser::AliasContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableLockContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}


size_t MySQLStatementParser::TableLockContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableLock;
}

void MySQLStatementParser::TableLockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableLock(this);
}

void MySQLStatementParser::TableLockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableLock(this);
}


antlrcpp::Any MySQLStatementParser::TableLockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableLock(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableLockContext* MySQLStatementParser::tableLock() {
  TableLockContext *_localctx = _tracker.createInstance<TableLockContext>(_ctx, getState());
  enterRule(_localctx, 492, MySQLStatementParser::RuleTableLock);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4573);
    tableName();
    setState(4578);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::AS)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || ((((_la - 780) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 780)) & ((1ULL << (MySQLStatementParser::IDENTIFIER_ - 780))
      | (1ULL << (MySQLStatementParser::SINGLE_QUOTED_TEXT - 780))
      | (1ULL << (MySQLStatementParser::DOUBLE_QUOTED_TEXT - 780)))) != 0)) {
      setState(4575);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::AS) {
        setState(4574);
        match(MySQLStatementParser::AS);
      }
      setState(4577);
      alias();
    }
    setState(4580);
    lockOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockOptionContext ------------------------------------------------------------------

MySQLStatementParser::LockOptionContext::LockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LockOptionContext::READ() {
  return getToken(MySQLStatementParser::READ, 0);
}

tree::TerminalNode* MySQLStatementParser::LockOptionContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}

tree::TerminalNode* MySQLStatementParser::LockOptionContext::WRITE() {
  return getToken(MySQLStatementParser::WRITE, 0);
}

tree::TerminalNode* MySQLStatementParser::LockOptionContext::LOW_PRIORITY() {
  return getToken(MySQLStatementParser::LOW_PRIORITY, 0);
}


size_t MySQLStatementParser::LockOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLockOption;
}

void MySQLStatementParser::LockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockOption(this);
}

void MySQLStatementParser::LockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockOption(this);
}


antlrcpp::Any MySQLStatementParser::LockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LockOptionContext* MySQLStatementParser::lockOption() {
  LockOptionContext *_localctx = _tracker.createInstance<LockOptionContext>(_ctx, getState());
  enterRule(_localctx, 494, MySQLStatementParser::RuleLockOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4590);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::READ: {
        enterOuterAlt(_localctx, 1);
        setState(4582);
        match(MySQLStatementParser::READ);
        setState(4584);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LOCAL) {
          setState(4583);
          match(MySQLStatementParser::LOCAL);
        }
        break;
      }

      case MySQLStatementParser::LOW_PRIORITY:
      case MySQLStatementParser::WRITE: {
        enterOuterAlt(_localctx, 2);
        setState(4587);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LOW_PRIORITY) {
          setState(4586);
          match(MySQLStatementParser::LOW_PRIORITY);
        }
        setState(4589);
        match(MySQLStatementParser::WRITE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XidContext ------------------------------------------------------------------

MySQLStatementParser::XidContext::XidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::XidContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::XidContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::XidContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::XidContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::XidContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}


size_t MySQLStatementParser::XidContext::getRuleIndex() const {
  return MySQLStatementParser::RuleXid;
}

void MySQLStatementParser::XidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXid(this);
}

void MySQLStatementParser::XidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXid(this);
}


antlrcpp::Any MySQLStatementParser::XidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitXid(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::XidContext* MySQLStatementParser::xid() {
  XidContext *_localctx = _tracker.createInstance<XidContext>(_ctx, getState());
  enterRule(_localctx, 496, MySQLStatementParser::RuleXid);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4592);
    string_();
    setState(4597);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4593);
      match(MySQLStatementParser::COMMA_);
      setState(4594);
      string_();
      setState(4599);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4601);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::NUMBER_) {
      setState(4600);
      numberLiterals();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantContext ------------------------------------------------------------------

MySQLStatementParser::GrantContext::GrantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::GrantContext::GRANT() {
  return getToken(MySQLStatementParser::GRANT, 0);
}

MySQLStatementParser::ProxyClauseContext* MySQLStatementParser::GrantContext::proxyClause() {
  return getRuleContext<MySQLStatementParser::ProxyClauseContext>(0);
}

MySQLStatementParser::PrivilegeClauseContext* MySQLStatementParser::GrantContext::privilegeClause() {
  return getRuleContext<MySQLStatementParser::PrivilegeClauseContext>(0);
}

MySQLStatementParser::RoleClauseContext* MySQLStatementParser::GrantContext::roleClause() {
  return getRuleContext<MySQLStatementParser::RoleClauseContext>(0);
}


size_t MySQLStatementParser::GrantContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGrant;
}

void MySQLStatementParser::GrantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrant(this);
}

void MySQLStatementParser::GrantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrant(this);
}


antlrcpp::Any MySQLStatementParser::GrantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGrant(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GrantContext* MySQLStatementParser::grant() {
  GrantContext *_localctx = _tracker.createInstance<GrantContext>(_ctx, getState());
  enterRule(_localctx, 498, MySQLStatementParser::RuleGrant);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4603);
    match(MySQLStatementParser::GRANT);
    setState(4607);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 585, _ctx)) {
    case 1: {
      setState(4604);
      proxyClause();
      break;
    }

    case 2: {
      setState(4605);
      privilegeClause();
      break;
    }

    case 3: {
      setState(4606);
      roleClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokeContext ------------------------------------------------------------------

MySQLStatementParser::RevokeContext::RevokeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RevokeContext::REVOKE() {
  return getToken(MySQLStatementParser::REVOKE, 0);
}

MySQLStatementParser::ProxyClauseContext* MySQLStatementParser::RevokeContext::proxyClause() {
  return getRuleContext<MySQLStatementParser::ProxyClauseContext>(0);
}

MySQLStatementParser::PrivilegeClauseContext* MySQLStatementParser::RevokeContext::privilegeClause() {
  return getRuleContext<MySQLStatementParser::PrivilegeClauseContext>(0);
}

MySQLStatementParser::AllClauseContext* MySQLStatementParser::RevokeContext::allClause() {
  return getRuleContext<MySQLStatementParser::AllClauseContext>(0);
}

MySQLStatementParser::RoleClauseContext* MySQLStatementParser::RevokeContext::roleClause() {
  return getRuleContext<MySQLStatementParser::RoleClauseContext>(0);
}


size_t MySQLStatementParser::RevokeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRevoke;
}

void MySQLStatementParser::RevokeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevoke(this);
}

void MySQLStatementParser::RevokeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevoke(this);
}


antlrcpp::Any MySQLStatementParser::RevokeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRevoke(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RevokeContext* MySQLStatementParser::revoke() {
  RevokeContext *_localctx = _tracker.createInstance<RevokeContext>(_ctx, getState());
  enterRule(_localctx, 500, MySQLStatementParser::RuleRevoke);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4609);
    match(MySQLStatementParser::REVOKE);
    setState(4614);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 586, _ctx)) {
    case 1: {
      setState(4610);
      proxyClause();
      break;
    }

    case 2: {
      setState(4611);
      privilegeClause();
      break;
    }

    case 3: {
      setState(4612);
      allClause();
      break;
    }

    case 4: {
      setState(4613);
      roleClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProxyClauseContext ------------------------------------------------------------------

MySQLStatementParser::ProxyClauseContext::ProxyClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ProxyClauseContext::PROXY() {
  return getToken(MySQLStatementParser::PROXY, 0);
}

tree::TerminalNode* MySQLStatementParser::ProxyClauseContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

MySQLStatementParser::UserOrRoleContext* MySQLStatementParser::ProxyClauseContext::userOrRole() {
  return getRuleContext<MySQLStatementParser::UserOrRoleContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ProxyClauseContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

MySQLStatementParser::UserOrRolesContext* MySQLStatementParser::ProxyClauseContext::userOrRoles() {
  return getRuleContext<MySQLStatementParser::UserOrRolesContext>(0);
}

MySQLStatementParser::WithGrantOptionContext* MySQLStatementParser::ProxyClauseContext::withGrantOption() {
  return getRuleContext<MySQLStatementParser::WithGrantOptionContext>(0);
}


size_t MySQLStatementParser::ProxyClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleProxyClause;
}

void MySQLStatementParser::ProxyClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProxyClause(this);
}

void MySQLStatementParser::ProxyClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProxyClause(this);
}


antlrcpp::Any MySQLStatementParser::ProxyClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitProxyClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ProxyClauseContext* MySQLStatementParser::proxyClause() {
  ProxyClauseContext *_localctx = _tracker.createInstance<ProxyClauseContext>(_ctx, getState());
  enterRule(_localctx, 502, MySQLStatementParser::RuleProxyClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4616);
    match(MySQLStatementParser::PROXY);
    setState(4617);
    match(MySQLStatementParser::ON);
    setState(4618);
    userOrRole();
    setState(4619);
    match(MySQLStatementParser::TO);
    setState(4620);
    userOrRoles();
    setState(4622);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(4621);
      withGrantOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeClauseContext ------------------------------------------------------------------

MySQLStatementParser::PrivilegeClauseContext::PrivilegeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::PrivilegesContext* MySQLStatementParser::PrivilegeClauseContext::privileges() {
  return getRuleContext<MySQLStatementParser::PrivilegesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeClauseContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

MySQLStatementParser::OnObjectClauseContext* MySQLStatementParser::PrivilegeClauseContext::onObjectClause() {
  return getRuleContext<MySQLStatementParser::OnObjectClauseContext>(0);
}

MySQLStatementParser::UserOrRolesContext* MySQLStatementParser::PrivilegeClauseContext::userOrRoles() {
  return getRuleContext<MySQLStatementParser::UserOrRolesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeClauseContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeClauseContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::WithGrantOptionContext* MySQLStatementParser::PrivilegeClauseContext::withGrantOption() {
  return getRuleContext<MySQLStatementParser::WithGrantOptionContext>(0);
}

MySQLStatementParser::GrantOptionContext* MySQLStatementParser::PrivilegeClauseContext::grantOption() {
  return getRuleContext<MySQLStatementParser::GrantOptionContext>(0);
}


size_t MySQLStatementParser::PrivilegeClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RulePrivilegeClause;
}

void MySQLStatementParser::PrivilegeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilegeClause(this);
}

void MySQLStatementParser::PrivilegeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilegeClause(this);
}


antlrcpp::Any MySQLStatementParser::PrivilegeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPrivilegeClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PrivilegeClauseContext* MySQLStatementParser::privilegeClause() {
  PrivilegeClauseContext *_localctx = _tracker.createInstance<PrivilegeClauseContext>(_ctx, getState());
  enterRule(_localctx, 504, MySQLStatementParser::RulePrivilegeClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4624);
    privileges();
    setState(4625);
    match(MySQLStatementParser::ON);
    setState(4626);
    onObjectClause();
    setState(4627);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FROM || _la == MySQLStatementParser::TO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4628);
    userOrRoles();
    setState(4630);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(4629);
      withGrantOption();
    }
    setState(4633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(4632);
      grantOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleClauseContext ------------------------------------------------------------------

MySQLStatementParser::RoleClauseContext::RoleClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::RolesContext* MySQLStatementParser::RoleClauseContext::roles() {
  return getRuleContext<MySQLStatementParser::RolesContext>(0);
}

MySQLStatementParser::UserOrRolesContext* MySQLStatementParser::RoleClauseContext::userOrRoles() {
  return getRuleContext<MySQLStatementParser::UserOrRolesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::RoleClauseContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

tree::TerminalNode* MySQLStatementParser::RoleClauseContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::WithGrantOptionContext* MySQLStatementParser::RoleClauseContext::withGrantOption() {
  return getRuleContext<MySQLStatementParser::WithGrantOptionContext>(0);
}


size_t MySQLStatementParser::RoleClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRoleClause;
}

void MySQLStatementParser::RoleClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleClause(this);
}

void MySQLStatementParser::RoleClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleClause(this);
}


antlrcpp::Any MySQLStatementParser::RoleClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRoleClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RoleClauseContext* MySQLStatementParser::roleClause() {
  RoleClauseContext *_localctx = _tracker.createInstance<RoleClauseContext>(_ctx, getState());
  enterRule(_localctx, 506, MySQLStatementParser::RuleRoleClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4635);
    roles();
    setState(4636);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FROM || _la == MySQLStatementParser::TO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4637);
    userOrRoles();
    setState(4639);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(4638);
      withGrantOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AllClauseContext ------------------------------------------------------------------

MySQLStatementParser::AllClauseContext::AllClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AllClauseContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::AllClauseContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}

tree::TerminalNode* MySQLStatementParser::AllClauseContext::GRANT() {
  return getToken(MySQLStatementParser::GRANT, 0);
}

tree::TerminalNode* MySQLStatementParser::AllClauseContext::OPTION() {
  return getToken(MySQLStatementParser::OPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::AllClauseContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::UserOrRolesContext* MySQLStatementParser::AllClauseContext::userOrRoles() {
  return getRuleContext<MySQLStatementParser::UserOrRolesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AllClauseContext::PRIVILEGES() {
  return getToken(MySQLStatementParser::PRIVILEGES, 0);
}


size_t MySQLStatementParser::AllClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAllClause;
}

void MySQLStatementParser::AllClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAllClause(this);
}

void MySQLStatementParser::AllClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAllClause(this);
}


antlrcpp::Any MySQLStatementParser::AllClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAllClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AllClauseContext* MySQLStatementParser::allClause() {
  AllClauseContext *_localctx = _tracker.createInstance<AllClauseContext>(_ctx, getState());
  enterRule(_localctx, 508, MySQLStatementParser::RuleAllClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4641);
    match(MySQLStatementParser::ALL);
    setState(4643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PRIVILEGES) {
      setState(4642);
      match(MySQLStatementParser::PRIVILEGES);
    }
    setState(4645);
    match(MySQLStatementParser::COMMA_);
    setState(4646);
    match(MySQLStatementParser::GRANT);
    setState(4647);
    match(MySQLStatementParser::OPTION);
    setState(4648);
    match(MySQLStatementParser::FROM);
    setState(4649);
    userOrRoles();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegesContext ------------------------------------------------------------------

MySQLStatementParser::PrivilegesContext::PrivilegesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::PrivilegeContext *> MySQLStatementParser::PrivilegesContext::privilege() {
  return getRuleContexts<MySQLStatementParser::PrivilegeContext>();
}

MySQLStatementParser::PrivilegeContext* MySQLStatementParser::PrivilegesContext::privilege(size_t i) {
  return getRuleContext<MySQLStatementParser::PrivilegeContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PrivilegesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::PrivilegesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::PrivilegesContext::getRuleIndex() const {
  return MySQLStatementParser::RulePrivileges;
}

void MySQLStatementParser::PrivilegesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivileges(this);
}

void MySQLStatementParser::PrivilegesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivileges(this);
}


antlrcpp::Any MySQLStatementParser::PrivilegesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPrivileges(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PrivilegesContext* MySQLStatementParser::privileges() {
  PrivilegesContext *_localctx = _tracker.createInstance<PrivilegesContext>(_ctx, getState());
  enterRule(_localctx, 510, MySQLStatementParser::RulePrivileges);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4651);
    privilege();
    setState(4656);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4652);
      match(MySQLStatementParser::COMMA_);
      setState(4653);
      privilege();
      setState(4658);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeContext ------------------------------------------------------------------

MySQLStatementParser::PrivilegeContext::PrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::PrivilegeTypeContext* MySQLStatementParser::PrivilegeContext::privilegeType() {
  return getRuleContext<MySQLStatementParser::PrivilegeTypeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::PrivilegeContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::PrivilegeContext::getRuleIndex() const {
  return MySQLStatementParser::RulePrivilege;
}

void MySQLStatementParser::PrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilege(this);
}

void MySQLStatementParser::PrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilege(this);
}


antlrcpp::Any MySQLStatementParser::PrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PrivilegeContext* MySQLStatementParser::privilege() {
  PrivilegeContext *_localctx = _tracker.createInstance<PrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 512, MySQLStatementParser::RulePrivilege);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4659);
    privilegeType();
    setState(4664);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LP_) {
      setState(4660);
      match(MySQLStatementParser::LP_);
      setState(4661);
      columnNames();
      setState(4662);
      match(MySQLStatementParser::RP_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeTypeContext ------------------------------------------------------------------

MySQLStatementParser::PrivilegeTypeContext::PrivilegeTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::PRIVILEGES() {
  return getToken(MySQLStatementParser::PRIVILEGES, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::ROUTINE() {
  return getToken(MySQLStatementParser::ROUTINE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::TEMPORARY() {
  return getToken(MySQLStatementParser::TEMPORARY, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::VIEW() {
  return getToken(MySQLStatementParser::VIEW, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::DELETE() {
  return getToken(MySQLStatementParser::DELETE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::EVENT() {
  return getToken(MySQLStatementParser::EVENT, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::EXECUTE() {
  return getToken(MySQLStatementParser::EXECUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::FILE() {
  return getToken(MySQLStatementParser::FILE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::GRANT() {
  return getToken(MySQLStatementParser::GRANT, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::OPTION() {
  return getToken(MySQLStatementParser::OPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::INSERT() {
  return getToken(MySQLStatementParser::INSERT, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::LOCK() {
  return getToken(MySQLStatementParser::LOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::PROCESS() {
  return getToken(MySQLStatementParser::PROCESS, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::PROXY() {
  return getToken(MySQLStatementParser::PROXY, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::REFERENCES() {
  return getToken(MySQLStatementParser::REFERENCES, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::RELOAD() {
  return getToken(MySQLStatementParser::RELOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::REPLICATION() {
  return getToken(MySQLStatementParser::REPLICATION, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::CLIENT() {
  return getToken(MySQLStatementParser::CLIENT, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::SELECT() {
  return getToken(MySQLStatementParser::SELECT, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::DATABASES() {
  return getToken(MySQLStatementParser::DATABASES, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::SHUTDOWN() {
  return getToken(MySQLStatementParser::SHUTDOWN, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::SUPER() {
  return getToken(MySQLStatementParser::SUPER, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::TRIGGER() {
  return getToken(MySQLStatementParser::TRIGGER, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeTypeContext::USAGE() {
  return getToken(MySQLStatementParser::USAGE, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::PrivilegeTypeContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::PrivilegeTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RulePrivilegeType;
}

void MySQLStatementParser::PrivilegeTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilegeType(this);
}

void MySQLStatementParser::PrivilegeTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilegeType(this);
}


antlrcpp::Any MySQLStatementParser::PrivilegeTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPrivilegeType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PrivilegeTypeContext* MySQLStatementParser::privilegeType() {
  PrivilegeTypeContext *_localctx = _tracker.createInstance<PrivilegeTypeContext>(_ctx, getState());
  enterRule(_localctx, 514, MySQLStatementParser::RulePrivilegeType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4718);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 596, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4666);
      match(MySQLStatementParser::ALL);
      setState(4668);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::PRIVILEGES) {
        setState(4667);
        match(MySQLStatementParser::PRIVILEGES);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4670);
      match(MySQLStatementParser::ALTER);
      setState(4672);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::ROUTINE) {
        setState(4671);
        match(MySQLStatementParser::ROUTINE);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4674);
      match(MySQLStatementParser::CREATE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4675);
      match(MySQLStatementParser::CREATE);
      setState(4676);
      match(MySQLStatementParser::ROUTINE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4677);
      match(MySQLStatementParser::CREATE);
      setState(4678);
      match(MySQLStatementParser::TABLESPACE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4679);
      match(MySQLStatementParser::CREATE);
      setState(4680);
      match(MySQLStatementParser::TEMPORARY);
      setState(4681);
      match(MySQLStatementParser::TABLES);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4682);
      match(MySQLStatementParser::CREATE);
      setState(4683);
      match(MySQLStatementParser::USER);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4684);
      match(MySQLStatementParser::CREATE);
      setState(4685);
      match(MySQLStatementParser::VIEW);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4686);
      match(MySQLStatementParser::DELETE);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4687);
      match(MySQLStatementParser::DROP);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4688);
      match(MySQLStatementParser::DROP);
      setState(4689);
      match(MySQLStatementParser::ROLE);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4690);
      match(MySQLStatementParser::EVENT);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(4691);
      match(MySQLStatementParser::EXECUTE);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(4692);
      match(MySQLStatementParser::FILE);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(4693);
      match(MySQLStatementParser::GRANT);
      setState(4694);
      match(MySQLStatementParser::OPTION);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(4695);
      match(MySQLStatementParser::INDEX);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(4696);
      match(MySQLStatementParser::INSERT);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(4697);
      match(MySQLStatementParser::LOCK);
      setState(4698);
      match(MySQLStatementParser::TABLES);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(4699);
      match(MySQLStatementParser::PROCESS);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(4700);
      match(MySQLStatementParser::PROXY);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(4701);
      match(MySQLStatementParser::REFERENCES);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(4702);
      match(MySQLStatementParser::RELOAD);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(4703);
      match(MySQLStatementParser::REPLICATION);
      setState(4704);
      match(MySQLStatementParser::CLIENT);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(4705);
      match(MySQLStatementParser::REPLICATION);
      setState(4706);
      match(MySQLStatementParser::SLAVE);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(4707);
      match(MySQLStatementParser::SELECT);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(4708);
      match(MySQLStatementParser::SHOW);
      setState(4709);
      match(MySQLStatementParser::DATABASES);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(4710);
      match(MySQLStatementParser::SHOW);
      setState(4711);
      match(MySQLStatementParser::VIEW);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(4712);
      match(MySQLStatementParser::SHUTDOWN);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(4713);
      match(MySQLStatementParser::SUPER);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(4714);
      match(MySQLStatementParser::TRIGGER);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(4715);
      match(MySQLStatementParser::UPDATE);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(4716);
      match(MySQLStatementParser::USAGE);
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(4717);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnObjectClauseContext ------------------------------------------------------------------

MySQLStatementParser::OnObjectClauseContext::OnObjectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::PrivilegeLevelContext* MySQLStatementParser::OnObjectClauseContext::privilegeLevel() {
  return getRuleContext<MySQLStatementParser::PrivilegeLevelContext>(0);
}

MySQLStatementParser::ObjectTypeContext* MySQLStatementParser::OnObjectClauseContext::objectType() {
  return getRuleContext<MySQLStatementParser::ObjectTypeContext>(0);
}


size_t MySQLStatementParser::OnObjectClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOnObjectClause;
}

void MySQLStatementParser::OnObjectClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnObjectClause(this);
}

void MySQLStatementParser::OnObjectClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnObjectClause(this);
}


antlrcpp::Any MySQLStatementParser::OnObjectClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOnObjectClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OnObjectClauseContext* MySQLStatementParser::onObjectClause() {
  OnObjectClauseContext *_localctx = _tracker.createInstance<OnObjectClauseContext>(_ctx, getState());
  enterRule(_localctx, 516, MySQLStatementParser::RuleOnObjectClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4721);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FUNCTION || _la == MySQLStatementParser::PROCEDURE || _la == MySQLStatementParser::TABLE) {
      setState(4720);
      objectType();
    }
    setState(4723);
    privilegeLevel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectTypeContext ------------------------------------------------------------------

MySQLStatementParser::ObjectTypeContext::ObjectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ObjectTypeContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::ObjectTypeContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

tree::TerminalNode* MySQLStatementParser::ObjectTypeContext::PROCEDURE() {
  return getToken(MySQLStatementParser::PROCEDURE, 0);
}


size_t MySQLStatementParser::ObjectTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleObjectType;
}

void MySQLStatementParser::ObjectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectType(this);
}

void MySQLStatementParser::ObjectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectType(this);
}


antlrcpp::Any MySQLStatementParser::ObjectTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitObjectType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ObjectTypeContext* MySQLStatementParser::objectType() {
  ObjectTypeContext *_localctx = _tracker.createInstance<ObjectTypeContext>(_ctx, getState());
  enterRule(_localctx, 518, MySQLStatementParser::RuleObjectType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4725);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FUNCTION || _la == MySQLStatementParser::PROCEDURE || _la == MySQLStatementParser::TABLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeLevelContext ------------------------------------------------------------------

MySQLStatementParser::PrivilegeLevelContext::PrivilegeLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PrivilegeLevelContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeLevelContext::DOT_ASTERISK_() {
  return getToken(MySQLStatementParser::DOT_ASTERISK_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::PrivilegeLevelContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::PrivilegeLevelContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::PrivilegeLevelContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PrivilegeLevelContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}

MySQLStatementParser::RoutineNameContext* MySQLStatementParser::PrivilegeLevelContext::routineName() {
  return getRuleContext<MySQLStatementParser::RoutineNameContext>(0);
}


size_t MySQLStatementParser::PrivilegeLevelContext::getRuleIndex() const {
  return MySQLStatementParser::RulePrivilegeLevel;
}

void MySQLStatementParser::PrivilegeLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilegeLevel(this);
}

void MySQLStatementParser::PrivilegeLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilegeLevel(this);
}


antlrcpp::Any MySQLStatementParser::PrivilegeLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPrivilegeLevel(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PrivilegeLevelContext* MySQLStatementParser::privilegeLevel() {
  PrivilegeLevelContext *_localctx = _tracker.createInstance<PrivilegeLevelContext>(_ctx, getState());
  enterRule(_localctx, 520, MySQLStatementParser::RulePrivilegeLevel);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4738);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 598, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4727);
      match(MySQLStatementParser::ASTERISK_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4728);
      match(MySQLStatementParser::ASTERISK_);
      setState(4729);
      match(MySQLStatementParser::DOT_ASTERISK_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4730);
      identifier();
      setState(4731);
      match(MySQLStatementParser::DOT_ASTERISK_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4733);
      tableName();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4734);
      schemaName();
      setState(4735);
      match(MySQLStatementParser::DOT_);
      setState(4736);
      routineName();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserContext ------------------------------------------------------------------

MySQLStatementParser::CreateUserContext::CreateUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateUserContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUserContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

MySQLStatementParser::AlterUserListContext* MySQLStatementParser::CreateUserContext::alterUserList() {
  return getRuleContext<MySQLStatementParser::AlterUserListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateUserContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUserContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUserContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}

MySQLStatementParser::DefaultRoleClauseContext* MySQLStatementParser::CreateUserContext::defaultRoleClause() {
  return getRuleContext<MySQLStatementParser::DefaultRoleClauseContext>(0);
}

MySQLStatementParser::RequireClauseContext* MySQLStatementParser::CreateUserContext::requireClause() {
  return getRuleContext<MySQLStatementParser::RequireClauseContext>(0);
}

MySQLStatementParser::ConnectOptionsContext* MySQLStatementParser::CreateUserContext::connectOptions() {
  return getRuleContext<MySQLStatementParser::ConnectOptionsContext>(0);
}

MySQLStatementParser::AccountLockPasswordExpireOptionsContext* MySQLStatementParser::CreateUserContext::accountLockPasswordExpireOptions() {
  return getRuleContext<MySQLStatementParser::AccountLockPasswordExpireOptionsContext>(0);
}


size_t MySQLStatementParser::CreateUserContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateUser;
}

void MySQLStatementParser::CreateUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUser(this);
}

void MySQLStatementParser::CreateUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUser(this);
}


antlrcpp::Any MySQLStatementParser::CreateUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateUserContext* MySQLStatementParser::createUser() {
  CreateUserContext *_localctx = _tracker.createInstance<CreateUserContext>(_ctx, getState());
  enterRule(_localctx, 522, MySQLStatementParser::RuleCreateUser);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4740);
    match(MySQLStatementParser::CREATE);
    setState(4741);
    match(MySQLStatementParser::USER);
    setState(4745);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(4742);
      match(MySQLStatementParser::IF);
      setState(4743);
      match(MySQLStatementParser::NOT);
      setState(4744);
      match(MySQLStatementParser::EXISTS);
    }
    setState(4747);
    alterUserList();
    setState(4749);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFAULT) {
      setState(4748);
      defaultRoleClause();
    }
    setState(4752);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::REQUIRE) {
      setState(4751);
      requireClause();
    }
    setState(4755);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WITH) {
      setState(4754);
      connectOptions();
    }
    setState(4758);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ACCOUNT || _la == MySQLStatementParser::FAILED_LOGIN_ATTEMPTS || _la == MySQLStatementParser::PASSWORD

    || _la == MySQLStatementParser::PASSWORD_LOCK_TIME) {
      setState(4757);
      accountLockPasswordExpireOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultRoleClauseContext ------------------------------------------------------------------

MySQLStatementParser::DefaultRoleClauseContext::DefaultRoleClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DefaultRoleClauseContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::DefaultRoleClauseContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

std::vector<MySQLStatementParser::RoleNameContext *> MySQLStatementParser::DefaultRoleClauseContext::roleName() {
  return getRuleContexts<MySQLStatementParser::RoleNameContext>();
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::DefaultRoleClauseContext::roleName(size_t i) {
  return getRuleContext<MySQLStatementParser::RoleNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DefaultRoleClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::DefaultRoleClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::DefaultRoleClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDefaultRoleClause;
}

void MySQLStatementParser::DefaultRoleClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultRoleClause(this);
}

void MySQLStatementParser::DefaultRoleClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultRoleClause(this);
}


antlrcpp::Any MySQLStatementParser::DefaultRoleClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDefaultRoleClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DefaultRoleClauseContext* MySQLStatementParser::defaultRoleClause() {
  DefaultRoleClauseContext *_localctx = _tracker.createInstance<DefaultRoleClauseContext>(_ctx, getState());
  enterRule(_localctx, 524, MySQLStatementParser::RuleDefaultRoleClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4760);
    match(MySQLStatementParser::DEFAULT);
    setState(4761);
    match(MySQLStatementParser::ROLE);
    setState(4762);
    roleName();
    setState(4767);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4763);
      match(MySQLStatementParser::COMMA_);
      setState(4764);
      roleName();
      setState(4769);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireClauseContext ------------------------------------------------------------------

MySQLStatementParser::RequireClauseContext::RequireClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RequireClauseContext::REQUIRE() {
  return getToken(MySQLStatementParser::REQUIRE, 0);
}

tree::TerminalNode* MySQLStatementParser::RequireClauseContext::NONE() {
  return getToken(MySQLStatementParser::NONE, 0);
}

std::vector<MySQLStatementParser::TlsOptionContext *> MySQLStatementParser::RequireClauseContext::tlsOption() {
  return getRuleContexts<MySQLStatementParser::TlsOptionContext>();
}

MySQLStatementParser::TlsOptionContext* MySQLStatementParser::RequireClauseContext::tlsOption(size_t i) {
  return getRuleContext<MySQLStatementParser::TlsOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RequireClauseContext::AND() {
  return getTokens(MySQLStatementParser::AND);
}

tree::TerminalNode* MySQLStatementParser::RequireClauseContext::AND(size_t i) {
  return getToken(MySQLStatementParser::AND, i);
}


size_t MySQLStatementParser::RequireClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRequireClause;
}

void MySQLStatementParser::RequireClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireClause(this);
}

void MySQLStatementParser::RequireClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireClause(this);
}


antlrcpp::Any MySQLStatementParser::RequireClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRequireClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RequireClauseContext* MySQLStatementParser::requireClause() {
  RequireClauseContext *_localctx = _tracker.createInstance<RequireClauseContext>(_ctx, getState());
  enterRule(_localctx, 526, MySQLStatementParser::RuleRequireClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4770);
    match(MySQLStatementParser::REQUIRE);
    setState(4782);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::NONE: {
        setState(4771);
        match(MySQLStatementParser::NONE);
        break;
      }

      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::SSL:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::X509: {
        setState(4772);
        tlsOption();
        setState(4779);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::AND

        || _la == MySQLStatementParser::CIPHER || _la == MySQLStatementParser::ISSUER || _la == MySQLStatementParser::SSL

        || _la == MySQLStatementParser::SUBJECT || _la == MySQLStatementParser::X509) {
          setState(4774);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::AND) {
            setState(4773);
            match(MySQLStatementParser::AND);
          }
          setState(4776);
          tlsOption();
          setState(4781);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectOptionsContext ------------------------------------------------------------------

MySQLStatementParser::ConnectOptionsContext::ConnectOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConnectOptionsContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

std::vector<MySQLStatementParser::ConnectOptionContext *> MySQLStatementParser::ConnectOptionsContext::connectOption() {
  return getRuleContexts<MySQLStatementParser::ConnectOptionContext>();
}

MySQLStatementParser::ConnectOptionContext* MySQLStatementParser::ConnectOptionsContext::connectOption(size_t i) {
  return getRuleContext<MySQLStatementParser::ConnectOptionContext>(i);
}


size_t MySQLStatementParser::ConnectOptionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConnectOptions;
}

void MySQLStatementParser::ConnectOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnectOptions(this);
}

void MySQLStatementParser::ConnectOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnectOptions(this);
}


antlrcpp::Any MySQLStatementParser::ConnectOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConnectOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConnectOptionsContext* MySQLStatementParser::connectOptions() {
  ConnectOptionsContext *_localctx = _tracker.createInstance<ConnectOptionsContext>(_ctx, getState());
  enterRule(_localctx, 528, MySQLStatementParser::RuleConnectOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4784);
    match(MySQLStatementParser::WITH);
    setState(4785);
    connectOption();
    setState(4789);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 368) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 368)) & ((1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 368))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 368))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 368))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 368)))) != 0)) {
      setState(4786);
      connectOption();
      setState(4791);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountLockPasswordExpireOptionsContext ------------------------------------------------------------------

MySQLStatementParser::AccountLockPasswordExpireOptionsContext::AccountLockPasswordExpireOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::AccountLockPasswordExpireOptionContext *> MySQLStatementParser::AccountLockPasswordExpireOptionsContext::accountLockPasswordExpireOption() {
  return getRuleContexts<MySQLStatementParser::AccountLockPasswordExpireOptionContext>();
}

MySQLStatementParser::AccountLockPasswordExpireOptionContext* MySQLStatementParser::AccountLockPasswordExpireOptionsContext::accountLockPasswordExpireOption(size_t i) {
  return getRuleContext<MySQLStatementParser::AccountLockPasswordExpireOptionContext>(i);
}


size_t MySQLStatementParser::AccountLockPasswordExpireOptionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAccountLockPasswordExpireOptions;
}

void MySQLStatementParser::AccountLockPasswordExpireOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountLockPasswordExpireOptions(this);
}

void MySQLStatementParser::AccountLockPasswordExpireOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountLockPasswordExpireOptions(this);
}


antlrcpp::Any MySQLStatementParser::AccountLockPasswordExpireOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAccountLockPasswordExpireOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AccountLockPasswordExpireOptionsContext* MySQLStatementParser::accountLockPasswordExpireOptions() {
  AccountLockPasswordExpireOptionsContext *_localctx = _tracker.createInstance<AccountLockPasswordExpireOptionsContext>(_ctx, getState());
  enterRule(_localctx, 530, MySQLStatementParser::RuleAccountLockPasswordExpireOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4793); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(4792);
      accountLockPasswordExpireOption();
      setState(4795); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLStatementParser::ACCOUNT || _la == MySQLStatementParser::FAILED_LOGIN_ATTEMPTS || _la == MySQLStatementParser::PASSWORD

    || _la == MySQLStatementParser::PASSWORD_LOCK_TIME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountLockPasswordExpireOptionContext ------------------------------------------------------------------

MySQLStatementParser::AccountLockPasswordExpireOptionContext::AccountLockPasswordExpireOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::ACCOUNT() {
  return getToken(MySQLStatementParser::ACCOUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::LOCK() {
  return getToken(MySQLStatementParser::LOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::UNLOCK() {
  return getToken(MySQLStatementParser::UNLOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::EXPIRE() {
  return getToken(MySQLStatementParser::EXPIRE, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::NEVER() {
  return getToken(MySQLStatementParser::NEVER, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::INTERVAL() {
  return getToken(MySQLStatementParser::INTERVAL, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::DAY() {
  return getToken(MySQLStatementParser::DAY, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::HISTORY() {
  return getToken(MySQLStatementParser::HISTORY, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::REUSE() {
  return getToken(MySQLStatementParser::REUSE, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::REQUIRE() {
  return getToken(MySQLStatementParser::REQUIRE, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::CURRENT() {
  return getToken(MySQLStatementParser::CURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::OPTIONAL() {
  return getToken(MySQLStatementParser::OPTIONAL, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::FAILED_LOGIN_ATTEMPTS() {
  return getToken(MySQLStatementParser::FAILED_LOGIN_ATTEMPTS, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::PASSWORD_LOCK_TIME() {
  return getToken(MySQLStatementParser::PASSWORD_LOCK_TIME, 0);
}

tree::TerminalNode* MySQLStatementParser::AccountLockPasswordExpireOptionContext::UNBOUNDED() {
  return getToken(MySQLStatementParser::UNBOUNDED, 0);
}


size_t MySQLStatementParser::AccountLockPasswordExpireOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAccountLockPasswordExpireOption;
}

void MySQLStatementParser::AccountLockPasswordExpireOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountLockPasswordExpireOption(this);
}

void MySQLStatementParser::AccountLockPasswordExpireOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountLockPasswordExpireOption(this);
}


antlrcpp::Any MySQLStatementParser::AccountLockPasswordExpireOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAccountLockPasswordExpireOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AccountLockPasswordExpireOptionContext* MySQLStatementParser::accountLockPasswordExpireOption() {
  AccountLockPasswordExpireOptionContext *_localctx = _tracker.createInstance<AccountLockPasswordExpireOptionContext>(_ctx, getState());
  enterRule(_localctx, 532, MySQLStatementParser::RuleAccountLockPasswordExpireOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4829);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 613, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4797);
      match(MySQLStatementParser::ACCOUNT);
      setState(4798);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LOCK || _la == MySQLStatementParser::UNLOCK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4799);
      match(MySQLStatementParser::PASSWORD);
      setState(4800);
      match(MySQLStatementParser::EXPIRE);
      setState(4806);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::DEFAULT: {
          setState(4801);
          match(MySQLStatementParser::DEFAULT);
          break;
        }

        case MySQLStatementParser::NEVER: {
          setState(4802);
          match(MySQLStatementParser::NEVER);
          break;
        }

        case MySQLStatementParser::INTERVAL: {
          setState(4803);
          match(MySQLStatementParser::INTERVAL);
          setState(4804);
          match(MySQLStatementParser::NUMBER_);
          setState(4805);
          match(MySQLStatementParser::DAY);
          break;
        }

        case MySQLStatementParser::EOF:
        case MySQLStatementParser::ACCOUNT:
        case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
        case MySQLStatementParser::PASSWORD:
        case MySQLStatementParser::PASSWORD_LOCK_TIME:
        case MySQLStatementParser::SEMI_: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4808);
      match(MySQLStatementParser::PASSWORD);
      setState(4809);
      match(MySQLStatementParser::HISTORY);
      setState(4810);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DEFAULT || _la == MySQLStatementParser::NUMBER_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4811);
      match(MySQLStatementParser::PASSWORD);
      setState(4812);
      match(MySQLStatementParser::REUSE);
      setState(4813);
      match(MySQLStatementParser::INTERVAL);
      setState(4817);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::DEFAULT: {
          setState(4814);
          match(MySQLStatementParser::DEFAULT);
          break;
        }

        case MySQLStatementParser::NUMBER_: {
          setState(4815);
          match(MySQLStatementParser::NUMBER_);
          setState(4816);
          match(MySQLStatementParser::DAY);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4819);
      match(MySQLStatementParser::PASSWORD);
      setState(4820);
      match(MySQLStatementParser::REQUIRE);
      setState(4821);
      match(MySQLStatementParser::CURRENT);
      setState(4823);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::DEFAULT || _la == MySQLStatementParser::OPTIONAL) {
        setState(4822);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::DEFAULT || _la == MySQLStatementParser::OPTIONAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4825);
      match(MySQLStatementParser::FAILED_LOGIN_ATTEMPTS);
      setState(4826);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4827);
      match(MySQLStatementParser::PASSWORD_LOCK_TIME);
      setState(4828);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::UNBOUNDED || _la == MySQLStatementParser::NUMBER_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserContext ------------------------------------------------------------------

MySQLStatementParser::AlterUserContext::AlterUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterUserContext::USER() {
  return getTokens(MySQLStatementParser::USER);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::USER(size_t i) {
  return getToken(MySQLStatementParser::USER, i);
}

MySQLStatementParser::AlterUserListContext* MySQLStatementParser::AlterUserContext::alterUserList() {
  return getRuleContext<MySQLStatementParser::AlterUserListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}

MySQLStatementParser::RequireClauseContext* MySQLStatementParser::AlterUserContext::requireClause() {
  return getRuleContext<MySQLStatementParser::RequireClauseContext>(0);
}

MySQLStatementParser::ConnectOptionsContext* MySQLStatementParser::AlterUserContext::connectOptions() {
  return getRuleContext<MySQLStatementParser::ConnectOptionsContext>(0);
}

MySQLStatementParser::AccountLockPasswordExpireOptionsContext* MySQLStatementParser::AlterUserContext::accountLockPasswordExpireOptions() {
  return getRuleContext<MySQLStatementParser::AccountLockPasswordExpireOptionsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::UserFuncAuthOptionContext* MySQLStatementParser::AlterUserContext::userFuncAuthOption() {
  return getRuleContext<MySQLStatementParser::UserFuncAuthOptionContext>(0);
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::AlterUserContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::NONE() {
  return getToken(MySQLStatementParser::NONE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

std::vector<MySQLStatementParser::RoleNameContext *> MySQLStatementParser::AlterUserContext::roleName() {
  return getRuleContexts<MySQLStatementParser::RoleNameContext>();
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::AlterUserContext::roleName(size_t i) {
  return getRuleContext<MySQLStatementParser::RoleNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterUserContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AlterUserContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::AlterUserContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterUser;
}

void MySQLStatementParser::AlterUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUser(this);
}

void MySQLStatementParser::AlterUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUser(this);
}


antlrcpp::Any MySQLStatementParser::AlterUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterUserContext* MySQLStatementParser::alterUser() {
  AlterUserContext *_localctx = _tracker.createInstance<AlterUserContext>(_ctx, getState());
  enterRule(_localctx, 534, MySQLStatementParser::RuleAlterUser);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4878);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 622, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4831);
      match(MySQLStatementParser::ALTER);
      setState(4832);
      match(MySQLStatementParser::USER);
      setState(4835);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::IF) {
        setState(4833);
        match(MySQLStatementParser::IF);
        setState(4834);
        match(MySQLStatementParser::EXISTS);
      }
      setState(4837);
      alterUserList();
      setState(4839);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::REQUIRE) {
        setState(4838);
        requireClause();
      }
      setState(4842);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::WITH) {
        setState(4841);
        connectOptions();
      }
      setState(4845);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::ACCOUNT || _la == MySQLStatementParser::FAILED_LOGIN_ATTEMPTS || _la == MySQLStatementParser::PASSWORD

      || _la == MySQLStatementParser::PASSWORD_LOCK_TIME) {
        setState(4844);
        accountLockPasswordExpireOptions();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4847);
      match(MySQLStatementParser::ALTER);
      setState(4848);
      match(MySQLStatementParser::USER);
      setState(4851);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::IF) {
        setState(4849);
        match(MySQLStatementParser::IF);
        setState(4850);
        match(MySQLStatementParser::EXISTS);
      }
      setState(4853);
      match(MySQLStatementParser::USER);
      setState(4854);
      match(MySQLStatementParser::LP_);
      setState(4855);
      match(MySQLStatementParser::RP_);
      setState(4856);
      userFuncAuthOption();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4857);
      match(MySQLStatementParser::ALTER);
      setState(4858);
      match(MySQLStatementParser::USER);
      setState(4861);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::IF) {
        setState(4859);
        match(MySQLStatementParser::IF);
        setState(4860);
        match(MySQLStatementParser::EXISTS);
      }
      setState(4863);
      userName();
      setState(4864);
      match(MySQLStatementParser::DEFAULT);
      setState(4865);
      match(MySQLStatementParser::ROLE);
      setState(4876);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::NONE: {
          setState(4866);
          match(MySQLStatementParser::NONE);
          break;
        }

        case MySQLStatementParser::ALL: {
          setState(4867);
          match(MySQLStatementParser::ALL);
          break;
        }

        case MySQLStatementParser::IDENTIFIER_:
        case MySQLStatementParser::SINGLE_QUOTED_TEXT:
        case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
          setState(4868);
          roleName();
          setState(4873);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySQLStatementParser::COMMA_) {
            setState(4869);
            match(MySQLStatementParser::COMMA_);
            setState(4870);
            roleName();
            setState(4875);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserEntryContext ------------------------------------------------------------------

MySQLStatementParser::AlterUserEntryContext::AlterUserEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::AlterUserEntryContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}

MySQLStatementParser::UserAuthOptionContext* MySQLStatementParser::AlterUserEntryContext::userAuthOption() {
  return getRuleContext<MySQLStatementParser::UserAuthOptionContext>(0);
}


size_t MySQLStatementParser::AlterUserEntryContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterUserEntry;
}

void MySQLStatementParser::AlterUserEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserEntry(this);
}

void MySQLStatementParser::AlterUserEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserEntry(this);
}


antlrcpp::Any MySQLStatementParser::AlterUserEntryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterUserEntry(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterUserEntryContext* MySQLStatementParser::alterUserEntry() {
  AlterUserEntryContext *_localctx = _tracker.createInstance<AlterUserEntryContext>(_ctx, getState());
  enterRule(_localctx, 536, MySQLStatementParser::RuleAlterUserEntry);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4880);
    userName();
    setState(4882);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DISCARD || _la == MySQLStatementParser::IDENTIFIED) {
      setState(4881);
      userAuthOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserListContext ------------------------------------------------------------------

MySQLStatementParser::AlterUserListContext::AlterUserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::AlterUserEntryContext *> MySQLStatementParser::AlterUserListContext::alterUserEntry() {
  return getRuleContexts<MySQLStatementParser::AlterUserEntryContext>();
}

MySQLStatementParser::AlterUserEntryContext* MySQLStatementParser::AlterUserListContext::alterUserEntry(size_t i) {
  return getRuleContext<MySQLStatementParser::AlterUserEntryContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterUserListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AlterUserListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::AlterUserListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterUserList;
}

void MySQLStatementParser::AlterUserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserList(this);
}

void MySQLStatementParser::AlterUserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserList(this);
}


antlrcpp::Any MySQLStatementParser::AlterUserListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterUserList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterUserListContext* MySQLStatementParser::alterUserList() {
  AlterUserListContext *_localctx = _tracker.createInstance<AlterUserListContext>(_ctx, getState());
  enterRule(_localctx, 538, MySQLStatementParser::RuleAlterUserList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4884);
    alterUserEntry();
    setState(4889);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4885);
      match(MySQLStatementParser::COMMA_);
      setState(4886);
      alterUserEntry();
      setState(4891);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUserContext ------------------------------------------------------------------

MySQLStatementParser::DropUserContext::DropUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropUserContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropUserContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

std::vector<MySQLStatementParser::UserNameContext *> MySQLStatementParser::DropUserContext::userName() {
  return getRuleContexts<MySQLStatementParser::UserNameContext>();
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::DropUserContext::userName(size_t i) {
  return getRuleContext<MySQLStatementParser::UserNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::DropUserContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::DropUserContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DropUserContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::DropUserContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::DropUserContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropUser;
}

void MySQLStatementParser::DropUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUser(this);
}

void MySQLStatementParser::DropUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUser(this);
}


antlrcpp::Any MySQLStatementParser::DropUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropUserContext* MySQLStatementParser::dropUser() {
  DropUserContext *_localctx = _tracker.createInstance<DropUserContext>(_ctx, getState());
  enterRule(_localctx, 540, MySQLStatementParser::RuleDropUser);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4892);
    match(MySQLStatementParser::DROP);
    setState(4893);
    match(MySQLStatementParser::USER);
    setState(4896);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(4894);
      match(MySQLStatementParser::IF);
      setState(4895);
      match(MySQLStatementParser::EXISTS);
    }
    setState(4898);
    userName();
    setState(4903);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4899);
      match(MySQLStatementParser::COMMA_);
      setState(4900);
      userName();
      setState(4905);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoleContext ------------------------------------------------------------------

MySQLStatementParser::CreateRoleContext::CreateRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateRoleContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateRoleContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

std::vector<MySQLStatementParser::RoleNameContext *> MySQLStatementParser::CreateRoleContext::roleName() {
  return getRuleContexts<MySQLStatementParser::RoleNameContext>();
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::CreateRoleContext::roleName(size_t i) {
  return getRuleContext<MySQLStatementParser::RoleNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateRoleContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateRoleContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateRoleContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateRoleContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CreateRoleContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::CreateRoleContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateRole;
}

void MySQLStatementParser::CreateRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRole(this);
}

void MySQLStatementParser::CreateRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRole(this);
}


antlrcpp::Any MySQLStatementParser::CreateRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateRoleContext* MySQLStatementParser::createRole() {
  CreateRoleContext *_localctx = _tracker.createInstance<CreateRoleContext>(_ctx, getState());
  enterRule(_localctx, 542, MySQLStatementParser::RuleCreateRole);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4906);
    match(MySQLStatementParser::CREATE);
    setState(4907);
    match(MySQLStatementParser::ROLE);
    setState(4911);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(4908);
      match(MySQLStatementParser::IF);
      setState(4909);
      match(MySQLStatementParser::NOT);
      setState(4910);
      match(MySQLStatementParser::EXISTS);
    }
    setState(4913);
    roleName();
    setState(4918);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4914);
      match(MySQLStatementParser::COMMA_);
      setState(4915);
      roleName();
      setState(4920);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropRoleContext ------------------------------------------------------------------

MySQLStatementParser::DropRoleContext::DropRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropRoleContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropRoleContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

std::vector<MySQLStatementParser::RoleNameContext *> MySQLStatementParser::DropRoleContext::roleName() {
  return getRuleContexts<MySQLStatementParser::RoleNameContext>();
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::DropRoleContext::roleName(size_t i) {
  return getRuleContext<MySQLStatementParser::RoleNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::DropRoleContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::DropRoleContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::DropRoleContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::DropRoleContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::DropRoleContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropRole;
}

void MySQLStatementParser::DropRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropRole(this);
}

void MySQLStatementParser::DropRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropRole(this);
}


antlrcpp::Any MySQLStatementParser::DropRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropRoleContext* MySQLStatementParser::dropRole() {
  DropRoleContext *_localctx = _tracker.createInstance<DropRoleContext>(_ctx, getState());
  enterRule(_localctx, 544, MySQLStatementParser::RuleDropRole);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4921);
    match(MySQLStatementParser::DROP);
    setState(4922);
    match(MySQLStatementParser::ROLE);
    setState(4925);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(4923);
      match(MySQLStatementParser::IF);
      setState(4924);
      match(MySQLStatementParser::EXISTS);
    }
    setState(4927);
    roleName();
    setState(4932);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4928);
      match(MySQLStatementParser::COMMA_);
      setState(4929);
      roleName();
      setState(4934);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameUserContext ------------------------------------------------------------------

MySQLStatementParser::RenameUserContext::RenameUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RenameUserContext::RENAME() {
  return getToken(MySQLStatementParser::RENAME, 0);
}

tree::TerminalNode* MySQLStatementParser::RenameUserContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

std::vector<MySQLStatementParser::UserNameContext *> MySQLStatementParser::RenameUserContext::userName() {
  return getRuleContexts<MySQLStatementParser::UserNameContext>();
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::RenameUserContext::userName(size_t i) {
  return getRuleContext<MySQLStatementParser::UserNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RenameUserContext::TO() {
  return getTokens(MySQLStatementParser::TO);
}

tree::TerminalNode* MySQLStatementParser::RenameUserContext::TO(size_t i) {
  return getToken(MySQLStatementParser::TO, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RenameUserContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::RenameUserContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::RenameUserContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRenameUser;
}

void MySQLStatementParser::RenameUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameUser(this);
}

void MySQLStatementParser::RenameUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameUser(this);
}


antlrcpp::Any MySQLStatementParser::RenameUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRenameUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RenameUserContext* MySQLStatementParser::renameUser() {
  RenameUserContext *_localctx = _tracker.createInstance<RenameUserContext>(_ctx, getState());
  enterRule(_localctx, 546, MySQLStatementParser::RuleRenameUser);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4935);
    match(MySQLStatementParser::RENAME);
    setState(4936);
    match(MySQLStatementParser::USER);
    setState(4937);
    userName();
    setState(4938);
    match(MySQLStatementParser::TO);
    setState(4939);
    userName();
    setState(4947);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4940);
      match(MySQLStatementParser::COMMA_);
      setState(4941);
      userName();
      setState(4942);
      match(MySQLStatementParser::TO);
      setState(4943);
      userName();
      setState(4949);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetDefaultRoleContext ------------------------------------------------------------------

MySQLStatementParser::SetDefaultRoleContext::SetDefaultRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetDefaultRoleContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::SetDefaultRoleContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::SetDefaultRoleContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

tree::TerminalNode* MySQLStatementParser::SetDefaultRoleContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

std::vector<MySQLStatementParser::UserNameContext *> MySQLStatementParser::SetDefaultRoleContext::userName() {
  return getRuleContexts<MySQLStatementParser::UserNameContext>();
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::SetDefaultRoleContext::userName(size_t i) {
  return getRuleContext<MySQLStatementParser::UserNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::SetDefaultRoleContext::NONE() {
  return getToken(MySQLStatementParser::NONE, 0);
}

tree::TerminalNode* MySQLStatementParser::SetDefaultRoleContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

std::vector<MySQLStatementParser::RoleNameContext *> MySQLStatementParser::SetDefaultRoleContext::roleName() {
  return getRuleContexts<MySQLStatementParser::RoleNameContext>();
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::SetDefaultRoleContext::roleName(size_t i) {
  return getRuleContext<MySQLStatementParser::RoleNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetDefaultRoleContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SetDefaultRoleContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SetDefaultRoleContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetDefaultRole;
}

void MySQLStatementParser::SetDefaultRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetDefaultRole(this);
}

void MySQLStatementParser::SetDefaultRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetDefaultRole(this);
}


antlrcpp::Any MySQLStatementParser::SetDefaultRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetDefaultRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetDefaultRoleContext* MySQLStatementParser::setDefaultRole() {
  SetDefaultRoleContext *_localctx = _tracker.createInstance<SetDefaultRoleContext>(_ctx, getState());
  enterRule(_localctx, 548, MySQLStatementParser::RuleSetDefaultRole);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4950);
    match(MySQLStatementParser::SET);
    setState(4951);
    match(MySQLStatementParser::DEFAULT);
    setState(4952);
    match(MySQLStatementParser::ROLE);
    setState(4963);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::NONE: {
        setState(4953);
        match(MySQLStatementParser::NONE);
        break;
      }

      case MySQLStatementParser::ALL: {
        setState(4954);
        match(MySQLStatementParser::ALL);
        break;
      }

      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(4955);
        roleName();
        setState(4960);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(4956);
          match(MySQLStatementParser::COMMA_);
          setState(4957);
          roleName();
          setState(4962);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4965);
    match(MySQLStatementParser::TO);
    setState(4966);
    userName();
    setState(4971);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(4967);
      match(MySQLStatementParser::COMMA_);
      setState(4968);
      userName();
      setState(4973);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetRoleContext ------------------------------------------------------------------

MySQLStatementParser::SetRoleContext::SetRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetRoleContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::SetRoleContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

tree::TerminalNode* MySQLStatementParser::SetRoleContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::SetRoleContext::NONE() {
  return getToken(MySQLStatementParser::NONE, 0);
}

tree::TerminalNode* MySQLStatementParser::SetRoleContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::SetRoleContext::EXCEPT() {
  return getToken(MySQLStatementParser::EXCEPT, 0);
}

MySQLStatementParser::RolesContext* MySQLStatementParser::SetRoleContext::roles() {
  return getRuleContext<MySQLStatementParser::RolesContext>(0);
}


size_t MySQLStatementParser::SetRoleContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetRole;
}

void MySQLStatementParser::SetRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetRole(this);
}

void MySQLStatementParser::SetRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetRole(this);
}


antlrcpp::Any MySQLStatementParser::SetRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetRoleContext* MySQLStatementParser::setRole() {
  SetRoleContext *_localctx = _tracker.createInstance<SetRoleContext>(_ctx, getState());
  enterRule(_localctx, 550, MySQLStatementParser::RuleSetRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4974);
    match(MySQLStatementParser::SET);
    setState(4975);
    match(MySQLStatementParser::ROLE);
    setState(4983);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 635, _ctx)) {
    case 1: {
      setState(4976);
      match(MySQLStatementParser::DEFAULT);
      break;
    }

    case 2: {
      setState(4977);
      match(MySQLStatementParser::NONE);
      break;
    }

    case 3: {
      setState(4978);
      match(MySQLStatementParser::ALL);
      break;
    }

    case 4: {
      setState(4979);
      match(MySQLStatementParser::ALL);
      setState(4980);
      match(MySQLStatementParser::EXCEPT);
      setState(4981);
      roles();
      break;
    }

    case 5: {
      setState(4982);
      roles();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetPasswordContext ------------------------------------------------------------------

MySQLStatementParser::SetPasswordContext::SetPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetPasswordContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetPasswordContext::PASSWORD() {
  return getTokens(MySQLStatementParser::PASSWORD);
}

tree::TerminalNode* MySQLStatementParser::SetPasswordContext::PASSWORD(size_t i) {
  return getToken(MySQLStatementParser::PASSWORD, i);
}

MySQLStatementParser::AuthOptionContext* MySQLStatementParser::SetPasswordContext::authOption() {
  return getRuleContext<MySQLStatementParser::AuthOptionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SetPasswordContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::SetPasswordContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SetPasswordContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::SetPasswordContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::SetPasswordContext::RETAIN() {
  return getToken(MySQLStatementParser::RETAIN, 0);
}

tree::TerminalNode* MySQLStatementParser::SetPasswordContext::CURRENT() {
  return getToken(MySQLStatementParser::CURRENT, 0);
}


size_t MySQLStatementParser::SetPasswordContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetPassword;
}

void MySQLStatementParser::SetPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetPassword(this);
}

void MySQLStatementParser::SetPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetPassword(this);
}


antlrcpp::Any MySQLStatementParser::SetPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetPasswordContext* MySQLStatementParser::setPassword() {
  SetPasswordContext *_localctx = _tracker.createInstance<SetPasswordContext>(_ctx, getState());
  enterRule(_localctx, 552, MySQLStatementParser::RuleSetPassword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4985);
    match(MySQLStatementParser::SET);
    setState(4986);
    match(MySQLStatementParser::PASSWORD);
    setState(4989);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(4987);
      match(MySQLStatementParser::FOR);
      setState(4988);
      userName();
    }
    setState(4991);
    authOption();
    setState(4994);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::REPLACE) {
      setState(4992);
      match(MySQLStatementParser::REPLACE);
      setState(4993);
      string_();
    }
    setState(4999);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RETAIN) {
      setState(4996);
      match(MySQLStatementParser::RETAIN);
      setState(4997);
      match(MySQLStatementParser::CURRENT);
      setState(4998);
      match(MySQLStatementParser::PASSWORD);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AuthOptionContext ------------------------------------------------------------------

MySQLStatementParser::AuthOptionContext::AuthOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AuthOptionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::AuthOptionContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AuthOptionContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

tree::TerminalNode* MySQLStatementParser::AuthOptionContext::RANDOM() {
  return getToken(MySQLStatementParser::RANDOM, 0);
}

tree::TerminalNode* MySQLStatementParser::AuthOptionContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::AuthOptionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::AuthOptionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::AuthOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAuthOption;
}

void MySQLStatementParser::AuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAuthOption(this);
}

void MySQLStatementParser::AuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAuthOption(this);
}


antlrcpp::Any MySQLStatementParser::AuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAuthOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AuthOptionContext* MySQLStatementParser::authOption() {
  AuthOptionContext *_localctx = _tracker.createInstance<AuthOptionContext>(_ctx, getState());
  enterRule(_localctx, 554, MySQLStatementParser::RuleAuthOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5011);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 639, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5001);
      match(MySQLStatementParser::EQ_);
      setState(5002);
      stringLiterals();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5003);
      match(MySQLStatementParser::TO);
      setState(5004);
      match(MySQLStatementParser::RANDOM);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5005);
      match(MySQLStatementParser::EQ_);
      setState(5006);
      match(MySQLStatementParser::PASSWORD);
      setState(5007);
      match(MySQLStatementParser::LP_);
      setState(5008);
      stringLiterals();
      setState(5009);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithGrantOptionContext ------------------------------------------------------------------

MySQLStatementParser::WithGrantOptionContext::WithGrantOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WithGrantOptionContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::WithGrantOptionContext::GRANT() {
  return getToken(MySQLStatementParser::GRANT, 0);
}

tree::TerminalNode* MySQLStatementParser::WithGrantOptionContext::OPTION() {
  return getToken(MySQLStatementParser::OPTION, 0);
}


size_t MySQLStatementParser::WithGrantOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWithGrantOption;
}

void MySQLStatementParser::WithGrantOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithGrantOption(this);
}

void MySQLStatementParser::WithGrantOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithGrantOption(this);
}


antlrcpp::Any MySQLStatementParser::WithGrantOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWithGrantOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WithGrantOptionContext* MySQLStatementParser::withGrantOption() {
  WithGrantOptionContext *_localctx = _tracker.createInstance<WithGrantOptionContext>(_ctx, getState());
  enterRule(_localctx, 556, MySQLStatementParser::RuleWithGrantOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5013);
    match(MySQLStatementParser::WITH);
    setState(5014);
    match(MySQLStatementParser::GRANT);
    setState(5015);
    match(MySQLStatementParser::OPTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserOrRolesContext ------------------------------------------------------------------

MySQLStatementParser::UserOrRolesContext::UserOrRolesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::UserOrRoleContext *> MySQLStatementParser::UserOrRolesContext::userOrRole() {
  return getRuleContexts<MySQLStatementParser::UserOrRoleContext>();
}

MySQLStatementParser::UserOrRoleContext* MySQLStatementParser::UserOrRolesContext::userOrRole(size_t i) {
  return getRuleContext<MySQLStatementParser::UserOrRoleContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::UserOrRolesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::UserOrRolesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::UserOrRolesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUserOrRoles;
}

void MySQLStatementParser::UserOrRolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserOrRoles(this);
}

void MySQLStatementParser::UserOrRolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserOrRoles(this);
}


antlrcpp::Any MySQLStatementParser::UserOrRolesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUserOrRoles(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UserOrRolesContext* MySQLStatementParser::userOrRoles() {
  UserOrRolesContext *_localctx = _tracker.createInstance<UserOrRolesContext>(_ctx, getState());
  enterRule(_localctx, 558, MySQLStatementParser::RuleUserOrRoles);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5017);
    userOrRole();
    setState(5022);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(5018);
      match(MySQLStatementParser::COMMA_);
      setState(5019);
      userOrRole();
      setState(5024);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RolesContext ------------------------------------------------------------------

MySQLStatementParser::RolesContext::RolesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::RoleNameContext *> MySQLStatementParser::RolesContext::roleName() {
  return getRuleContexts<MySQLStatementParser::RoleNameContext>();
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::RolesContext::roleName(size_t i) {
  return getRuleContext<MySQLStatementParser::RoleNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RolesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::RolesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::RolesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRoles;
}

void MySQLStatementParser::RolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoles(this);
}

void MySQLStatementParser::RolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoles(this);
}


antlrcpp::Any MySQLStatementParser::RolesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRoles(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RolesContext* MySQLStatementParser::roles() {
  RolesContext *_localctx = _tracker.createInstance<RolesContext>(_ctx, getState());
  enterRule(_localctx, 560, MySQLStatementParser::RuleRoles);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5025);
    roleName();
    setState(5030);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(5026);
      match(MySQLStatementParser::COMMA_);
      setState(5027);
      roleName();
      setState(5032);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantOptionContext ------------------------------------------------------------------

MySQLStatementParser::GrantOptionContext::GrantOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::GrantOptionContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::GrantOptionContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::GrantOptionContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::GrantOptionContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

tree::TerminalNode* MySQLStatementParser::GrantOptionContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::GrantOptionContext::NONE() {
  return getToken(MySQLStatementParser::NONE, 0);
}

tree::TerminalNode* MySQLStatementParser::GrantOptionContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::GrantOptionContext::EXCEPT() {
  return getToken(MySQLStatementParser::EXCEPT, 0);
}

MySQLStatementParser::RolesContext* MySQLStatementParser::GrantOptionContext::roles() {
  return getRuleContext<MySQLStatementParser::RolesContext>(0);
}


size_t MySQLStatementParser::GrantOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGrantOption;
}

void MySQLStatementParser::GrantOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantOption(this);
}

void MySQLStatementParser::GrantOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantOption(this);
}


antlrcpp::Any MySQLStatementParser::GrantOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGrantOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GrantOptionContext* MySQLStatementParser::grantOption() {
  GrantOptionContext *_localctx = _tracker.createInstance<GrantOptionContext>(_ctx, getState());
  enterRule(_localctx, 562, MySQLStatementParser::RuleGrantOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5033);
    match(MySQLStatementParser::AS);
    setState(5034);
    userName();
    setState(5044);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 642, _ctx)) {
    case 1: {
      setState(5035);
      match(MySQLStatementParser::WITH);
      setState(5036);
      match(MySQLStatementParser::ROLE);
      setState(5037);
      match(MySQLStatementParser::DEFAULT);
      break;
    }

    case 2: {
      setState(5038);
      match(MySQLStatementParser::NONE);
      break;
    }

    case 3: {
      setState(5039);
      match(MySQLStatementParser::ALL);
      break;
    }

    case 4: {
      setState(5040);
      match(MySQLStatementParser::ALL);
      setState(5041);
      match(MySQLStatementParser::EXCEPT);
      setState(5042);
      roles();
      break;
    }

    case 5: {
      setState(5043);
      roles();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserAuthOptionContext ------------------------------------------------------------------

MySQLStatementParser::UserAuthOptionContext::UserAuthOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifiedByContext* MySQLStatementParser::UserAuthOptionContext::identifiedBy() {
  return getRuleContext<MySQLStatementParser::IdentifiedByContext>(0);
}

MySQLStatementParser::IdentifiedWithContext* MySQLStatementParser::UserAuthOptionContext::identifiedWith() {
  return getRuleContext<MySQLStatementParser::IdentifiedWithContext>(0);
}

tree::TerminalNode* MySQLStatementParser::UserAuthOptionContext::DISCARD() {
  return getToken(MySQLStatementParser::DISCARD, 0);
}

tree::TerminalNode* MySQLStatementParser::UserAuthOptionContext::OLD() {
  return getToken(MySQLStatementParser::OLD, 0);
}

tree::TerminalNode* MySQLStatementParser::UserAuthOptionContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}


size_t MySQLStatementParser::UserAuthOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUserAuthOption;
}

void MySQLStatementParser::UserAuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserAuthOption(this);
}

void MySQLStatementParser::UserAuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserAuthOption(this);
}


antlrcpp::Any MySQLStatementParser::UserAuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUserAuthOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UserAuthOptionContext* MySQLStatementParser::userAuthOption() {
  UserAuthOptionContext *_localctx = _tracker.createInstance<UserAuthOptionContext>(_ctx, getState());
  enterRule(_localctx, 564, MySQLStatementParser::RuleUserAuthOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5051);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 643, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5046);
      identifiedBy();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5047);
      identifiedWith();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5048);
      match(MySQLStatementParser::DISCARD);
      setState(5049);
      match(MySQLStatementParser::OLD);
      setState(5050);
      match(MySQLStatementParser::PASSWORD);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedByContext ------------------------------------------------------------------

MySQLStatementParser::IdentifiedByContext::IdentifiedByContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IdentifiedByContext::IDENTIFIED() {
  return getToken(MySQLStatementParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedByContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::IdentifiedByContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::IdentifiedByContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedByContext::RANDOM() {
  return getToken(MySQLStatementParser::RANDOM, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IdentifiedByContext::PASSWORD() {
  return getTokens(MySQLStatementParser::PASSWORD);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedByContext::PASSWORD(size_t i) {
  return getToken(MySQLStatementParser::PASSWORD, i);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedByContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedByContext::RETAIN() {
  return getToken(MySQLStatementParser::RETAIN, 0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedByContext::CURRENT() {
  return getToken(MySQLStatementParser::CURRENT, 0);
}


size_t MySQLStatementParser::IdentifiedByContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIdentifiedBy;
}

void MySQLStatementParser::IdentifiedByContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedBy(this);
}

void MySQLStatementParser::IdentifiedByContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedBy(this);
}


antlrcpp::Any MySQLStatementParser::IdentifiedByContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIdentifiedBy(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IdentifiedByContext* MySQLStatementParser::identifiedBy() {
  IdentifiedByContext *_localctx = _tracker.createInstance<IdentifiedByContext>(_ctx, getState());
  enterRule(_localctx, 566, MySQLStatementParser::RuleIdentifiedBy);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5053);
    match(MySQLStatementParser::IDENTIFIED);
    setState(5054);
    match(MySQLStatementParser::BY);
    setState(5058);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(5055);
        string_();
        break;
      }

      case MySQLStatementParser::RANDOM: {
        setState(5056);
        match(MySQLStatementParser::RANDOM);
        setState(5057);
        match(MySQLStatementParser::PASSWORD);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(5062);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::REPLACE) {
      setState(5060);
      match(MySQLStatementParser::REPLACE);
      setState(5061);
      string_();
    }
    setState(5067);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RETAIN) {
      setState(5064);
      match(MySQLStatementParser::RETAIN);
      setState(5065);
      match(MySQLStatementParser::CURRENT);
      setState(5066);
      match(MySQLStatementParser::PASSWORD);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedWithContext ------------------------------------------------------------------

MySQLStatementParser::IdentifiedWithContext::IdentifiedWithContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::IDENTIFIED() {
  return getToken(MySQLStatementParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

MySQLStatementParser::PluginNameContext* MySQLStatementParser::IdentifiedWithContext::pluginName() {
  return getRuleContext<MySQLStatementParser::PluginNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::IdentifiedWithContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::RANDOM() {
  return getToken(MySQLStatementParser::RANDOM, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IdentifiedWithContext::PASSWORD() {
  return getTokens(MySQLStatementParser::PASSWORD);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::PASSWORD(size_t i) {
  return getToken(MySQLStatementParser::PASSWORD, i);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::IdentifiedWithContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::RETAIN() {
  return getToken(MySQLStatementParser::RETAIN, 0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::CURRENT() {
  return getToken(MySQLStatementParser::CURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::IdentifiedWithContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::TextStringHashContext* MySQLStatementParser::IdentifiedWithContext::textStringHash() {
  return getRuleContext<MySQLStatementParser::TextStringHashContext>(0);
}


size_t MySQLStatementParser::IdentifiedWithContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIdentifiedWith;
}

void MySQLStatementParser::IdentifiedWithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedWith(this);
}

void MySQLStatementParser::IdentifiedWithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedWith(this);
}


antlrcpp::Any MySQLStatementParser::IdentifiedWithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIdentifiedWith(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IdentifiedWithContext* MySQLStatementParser::identifiedWith() {
  IdentifiedWithContext *_localctx = _tracker.createInstance<IdentifiedWithContext>(_ctx, getState());
  enterRule(_localctx, 568, MySQLStatementParser::RuleIdentifiedWith);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5100);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 651, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5069);
      match(MySQLStatementParser::IDENTIFIED);
      setState(5070);
      match(MySQLStatementParser::WITH);
      setState(5071);
      pluginName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5072);
      match(MySQLStatementParser::IDENTIFIED);
      setState(5073);
      match(MySQLStatementParser::WITH);
      setState(5074);
      pluginName();
      setState(5075);
      match(MySQLStatementParser::BY);
      setState(5079);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::SINGLE_QUOTED_TEXT:
        case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
          setState(5076);
          string_();
          break;
        }

        case MySQLStatementParser::RANDOM: {
          setState(5077);
          match(MySQLStatementParser::RANDOM);
          setState(5078);
          match(MySQLStatementParser::PASSWORD);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(5083);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::REPLACE) {
        setState(5081);
        match(MySQLStatementParser::REPLACE);
        setState(5082);
        stringLiterals();
      }
      setState(5088);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::RETAIN) {
        setState(5085);
        match(MySQLStatementParser::RETAIN);
        setState(5086);
        match(MySQLStatementParser::CURRENT);
        setState(5087);
        match(MySQLStatementParser::PASSWORD);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5090);
      match(MySQLStatementParser::IDENTIFIED);
      setState(5091);
      match(MySQLStatementParser::WITH);
      setState(5092);
      pluginName();
      setState(5093);
      match(MySQLStatementParser::AS);
      setState(5094);
      textStringHash();
      setState(5098);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::RETAIN) {
        setState(5095);
        match(MySQLStatementParser::RETAIN);
        setState(5096);
        match(MySQLStatementParser::CURRENT);
        setState(5097);
        match(MySQLStatementParser::PASSWORD);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectOptionContext ------------------------------------------------------------------

MySQLStatementParser::ConnectOptionContext::ConnectOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConnectOptionContext::MAX_QUERIES_PER_HOUR() {
  return getToken(MySQLStatementParser::MAX_QUERIES_PER_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::ConnectOptionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::ConnectOptionContext::MAX_UPDATES_PER_HOUR() {
  return getToken(MySQLStatementParser::MAX_UPDATES_PER_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::ConnectOptionContext::MAX_CONNECTIONS_PER_HOUR() {
  return getToken(MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::ConnectOptionContext::MAX_USER_CONNECTIONS() {
  return getToken(MySQLStatementParser::MAX_USER_CONNECTIONS, 0);
}


size_t MySQLStatementParser::ConnectOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConnectOption;
}

void MySQLStatementParser::ConnectOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnectOption(this);
}

void MySQLStatementParser::ConnectOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnectOption(this);
}


antlrcpp::Any MySQLStatementParser::ConnectOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConnectOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConnectOptionContext* MySQLStatementParser::connectOption() {
  ConnectOptionContext *_localctx = _tracker.createInstance<ConnectOptionContext>(_ctx, getState());
  enterRule(_localctx, 570, MySQLStatementParser::RuleConnectOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5110);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR: {
        enterOuterAlt(_localctx, 1);
        setState(5102);
        match(MySQLStatementParser::MAX_QUERIES_PER_HOUR);
        setState(5103);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MAX_UPDATES_PER_HOUR: {
        enterOuterAlt(_localctx, 2);
        setState(5104);
        match(MySQLStatementParser::MAX_UPDATES_PER_HOUR);
        setState(5105);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR: {
        enterOuterAlt(_localctx, 3);
        setState(5106);
        match(MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR);
        setState(5107);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MAX_USER_CONNECTIONS: {
        enterOuterAlt(_localctx, 4);
        setState(5108);
        match(MySQLStatementParser::MAX_USER_CONNECTIONS);
        setState(5109);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TlsOptionContext ------------------------------------------------------------------

MySQLStatementParser::TlsOptionContext::TlsOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TlsOptionContext::SSL() {
  return getToken(MySQLStatementParser::SSL, 0);
}

tree::TerminalNode* MySQLStatementParser::TlsOptionContext::X509() {
  return getToken(MySQLStatementParser::X509, 0);
}

tree::TerminalNode* MySQLStatementParser::TlsOptionContext::CIPHER() {
  return getToken(MySQLStatementParser::CIPHER, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::TlsOptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::TlsOptionContext::ISSUER() {
  return getToken(MySQLStatementParser::ISSUER, 0);
}

tree::TerminalNode* MySQLStatementParser::TlsOptionContext::SUBJECT() {
  return getToken(MySQLStatementParser::SUBJECT, 0);
}


size_t MySQLStatementParser::TlsOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTlsOption;
}

void MySQLStatementParser::TlsOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTlsOption(this);
}

void MySQLStatementParser::TlsOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTlsOption(this);
}


antlrcpp::Any MySQLStatementParser::TlsOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTlsOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TlsOptionContext* MySQLStatementParser::tlsOption() {
  TlsOptionContext *_localctx = _tracker.createInstance<TlsOptionContext>(_ctx, getState());
  enterRule(_localctx, 572, MySQLStatementParser::RuleTlsOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5120);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SSL: {
        enterOuterAlt(_localctx, 1);
        setState(5112);
        match(MySQLStatementParser::SSL);
        break;
      }

      case MySQLStatementParser::X509: {
        enterOuterAlt(_localctx, 2);
        setState(5113);
        match(MySQLStatementParser::X509);
        break;
      }

      case MySQLStatementParser::CIPHER: {
        enterOuterAlt(_localctx, 3);
        setState(5114);
        match(MySQLStatementParser::CIPHER);
        setState(5115);
        string_();
        break;
      }

      case MySQLStatementParser::ISSUER: {
        enterOuterAlt(_localctx, 4);
        setState(5116);
        match(MySQLStatementParser::ISSUER);
        setState(5117);
        string_();
        break;
      }

      case MySQLStatementParser::SUBJECT: {
        enterOuterAlt(_localctx, 5);
        setState(5118);
        match(MySQLStatementParser::SUBJECT);
        setState(5119);
        string_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserFuncAuthOptionContext ------------------------------------------------------------------

MySQLStatementParser::UserFuncAuthOptionContext::UserFuncAuthOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifiedByContext* MySQLStatementParser::UserFuncAuthOptionContext::identifiedBy() {
  return getRuleContext<MySQLStatementParser::IdentifiedByContext>(0);
}

tree::TerminalNode* MySQLStatementParser::UserFuncAuthOptionContext::DISCARD() {
  return getToken(MySQLStatementParser::DISCARD, 0);
}

tree::TerminalNode* MySQLStatementParser::UserFuncAuthOptionContext::OLD() {
  return getToken(MySQLStatementParser::OLD, 0);
}

tree::TerminalNode* MySQLStatementParser::UserFuncAuthOptionContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}


size_t MySQLStatementParser::UserFuncAuthOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUserFuncAuthOption;
}

void MySQLStatementParser::UserFuncAuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserFuncAuthOption(this);
}

void MySQLStatementParser::UserFuncAuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserFuncAuthOption(this);
}


antlrcpp::Any MySQLStatementParser::UserFuncAuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUserFuncAuthOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UserFuncAuthOptionContext* MySQLStatementParser::userFuncAuthOption() {
  UserFuncAuthOptionContext *_localctx = _tracker.createInstance<UserFuncAuthOptionContext>(_ctx, getState());
  enterRule(_localctx, 574, MySQLStatementParser::RuleUserFuncAuthOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5126);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::IDENTIFIED: {
        enterOuterAlt(_localctx, 1);
        setState(5122);
        identifiedBy();
        break;
      }

      case MySQLStatementParser::DISCARD: {
        enterOuterAlt(_localctx, 2);
        setState(5123);
        match(MySQLStatementParser::DISCARD);
        setState(5124);
        match(MySQLStatementParser::OLD);
        setState(5125);
        match(MySQLStatementParser::PASSWORD);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseContext ------------------------------------------------------------------

MySQLStatementParser::UseContext::UseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UseContext::USE() {
  return getToken(MySQLStatementParser::USE, 0);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::UseContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}


size_t MySQLStatementParser::UseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUse;
}

void MySQLStatementParser::UseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse(this);
}

void MySQLStatementParser::UseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse(this);
}


antlrcpp::Any MySQLStatementParser::UseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUse(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UseContext* MySQLStatementParser::use() {
  UseContext *_localctx = _tracker.createInstance<UseContext>(_ctx, getState());
  enterRule(_localctx, 576, MySQLStatementParser::RuleUse);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5128);
    match(MySQLStatementParser::USE);
    setState(5129);
    schemaName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HelpContext ------------------------------------------------------------------

MySQLStatementParser::HelpContext::HelpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HelpContext::HELP() {
  return getToken(MySQLStatementParser::HELP, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::HelpContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::HelpContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHelp;
}

void MySQLStatementParser::HelpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHelp(this);
}

void MySQLStatementParser::HelpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHelp(this);
}


antlrcpp::Any MySQLStatementParser::HelpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHelp(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HelpContext* MySQLStatementParser::help() {
  HelpContext *_localctx = _tracker.createInstance<HelpContext>(_ctx, getState());
  enterRule(_localctx, 578, MySQLStatementParser::RuleHelp);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5131);
    match(MySQLStatementParser::HELP);
    setState(5132);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainContext ------------------------------------------------------------------

MySQLStatementParser::ExplainContext::ExplainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ExplainContext::DESC() {
  return getToken(MySQLStatementParser::DESC, 0);
}

tree::TerminalNode* MySQLStatementParser::ExplainContext::DESCRIBE() {
  return getToken(MySQLStatementParser::DESCRIBE, 0);
}

tree::TerminalNode* MySQLStatementParser::ExplainContext::EXPLAIN() {
  return getToken(MySQLStatementParser::EXPLAIN, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::ExplainContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ExplainContext::ANALYZE() {
  return getToken(MySQLStatementParser::ANALYZE, 0);
}

MySQLStatementParser::SelectContext* MySQLStatementParser::ExplainContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

MySQLStatementParser::ExplainableStatementContext* MySQLStatementParser::ExplainContext::explainableStatement() {
  return getRuleContext<MySQLStatementParser::ExplainableStatementContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ExplainContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::ExplainContext::CONNECTION() {
  return getToken(MySQLStatementParser::CONNECTION, 0);
}

MySQLStatementParser::ConnectionIdContext* MySQLStatementParser::ExplainContext::connectionId() {
  return getRuleContext<MySQLStatementParser::ConnectionIdContext>(0);
}

MySQLStatementParser::ColumnRefContext* MySQLStatementParser::ExplainContext::columnRef() {
  return getRuleContext<MySQLStatementParser::ColumnRefContext>(0);
}

MySQLStatementParser::TextStringContext* MySQLStatementParser::ExplainContext::textString() {
  return getRuleContext<MySQLStatementParser::TextStringContext>(0);
}

MySQLStatementParser::ExplainTypeContext* MySQLStatementParser::ExplainContext::explainType() {
  return getRuleContext<MySQLStatementParser::ExplainTypeContext>(0);
}


size_t MySQLStatementParser::ExplainContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExplain;
}

void MySQLStatementParser::ExplainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplain(this);
}

void MySQLStatementParser::ExplainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplain(this);
}


antlrcpp::Any MySQLStatementParser::ExplainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExplain(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExplainContext* MySQLStatementParser::explain() {
  ExplainContext *_localctx = _tracker.createInstance<ExplainContext>(_ctx, getState());
  enterRule(_localctx, 580, MySQLStatementParser::RuleExplain);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5134);
    _la = _input->LA(1);
    if (!(((((_la - 152) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 152)) & ((1ULL << (MySQLStatementParser::DESC - 152))
      | (1ULL << (MySQLStatementParser::DESCRIBE - 152))
      | (1ULL << (MySQLStatementParser::EXPLAIN - 152)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5151);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 658, _ctx)) {
    case 1: {
      setState(5135);
      tableName();
      setState(5138);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 655, _ctx)) {
      case 1: {
        setState(5136);
        columnRef();
        break;
      }

      case 2: {
        setState(5137);
        textString();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(5141);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::FORMAT) {
        setState(5140);
        explainType();
      }
      setState(5147);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::DELETE:
        case MySQLStatementParser::INSERT:
        case MySQLStatementParser::REPLACE:
        case MySQLStatementParser::SELECT:
        case MySQLStatementParser::TABLE:
        case MySQLStatementParser::UPDATE:
        case MySQLStatementParser::VALUES:
        case MySQLStatementParser::WITH:
        case MySQLStatementParser::LP_: {
          setState(5143);
          explainableStatement();
          break;
        }

        case MySQLStatementParser::FOR: {
          setState(5144);
          match(MySQLStatementParser::FOR);
          setState(5145);
          match(MySQLStatementParser::CONNECTION);
          setState(5146);
          connectionId();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      setState(5149);
      match(MySQLStatementParser::ANALYZE);
      setState(5150);
      select();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowDatabasesContext ------------------------------------------------------------------

MySQLStatementParser::ShowDatabasesContext::ShowDatabasesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowDatabasesContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowDatabasesContext::DATABASES() {
  return getToken(MySQLStatementParser::DATABASES, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowDatabasesContext::SCHEMAS() {
  return getToken(MySQLStatementParser::SCHEMAS, 0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowDatabasesContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowDatabasesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowDatabases;
}

void MySQLStatementParser::ShowDatabasesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowDatabases(this);
}

void MySQLStatementParser::ShowDatabasesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowDatabases(this);
}


antlrcpp::Any MySQLStatementParser::ShowDatabasesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowDatabases(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowDatabasesContext* MySQLStatementParser::showDatabases() {
  ShowDatabasesContext *_localctx = _tracker.createInstance<ShowDatabasesContext>(_ctx, getState());
  enterRule(_localctx, 582, MySQLStatementParser::RuleShowDatabases);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5153);
    match(MySQLStatementParser::SHOW);
    setState(5154);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DATABASES || _la == MySQLStatementParser::SCHEMAS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5156);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5155);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowTablesContext ------------------------------------------------------------------

MySQLStatementParser::ShowTablesContext::ShowTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowTablesContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowTablesContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowTablesContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowTablesContext::FULL() {
  return getToken(MySQLStatementParser::FULL, 0);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::ShowTablesContext::fromSchema() {
  return getRuleContext<MySQLStatementParser::FromSchemaContext>(0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowTablesContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowTablesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowTables;
}

void MySQLStatementParser::ShowTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowTables(this);
}

void MySQLStatementParser::ShowTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowTables(this);
}


antlrcpp::Any MySQLStatementParser::ShowTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowTables(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowTablesContext* MySQLStatementParser::showTables() {
  ShowTablesContext *_localctx = _tracker.createInstance<ShowTablesContext>(_ctx, getState());
  enterRule(_localctx, 584, MySQLStatementParser::RuleShowTables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5158);
    match(MySQLStatementParser::SHOW);
    setState(5160);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EXTENDED) {
      setState(5159);
      match(MySQLStatementParser::EXTENDED);
    }
    setState(5163);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FULL) {
      setState(5162);
      match(MySQLStatementParser::FULL);
    }
    setState(5165);
    match(MySQLStatementParser::TABLES);
    setState(5167);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN) {
      setState(5166);
      fromSchema();
    }
    setState(5170);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5169);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowTableStatusContext ------------------------------------------------------------------

MySQLStatementParser::ShowTableStatusContext::ShowTableStatusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowTableStatusContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowTableStatusContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowTableStatusContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::ShowTableStatusContext::fromSchema() {
  return getRuleContext<MySQLStatementParser::FromSchemaContext>(0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowTableStatusContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowTableStatusContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowTableStatus;
}

void MySQLStatementParser::ShowTableStatusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowTableStatus(this);
}

void MySQLStatementParser::ShowTableStatusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowTableStatus(this);
}


antlrcpp::Any MySQLStatementParser::ShowTableStatusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowTableStatus(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowTableStatusContext* MySQLStatementParser::showTableStatus() {
  ShowTableStatusContext *_localctx = _tracker.createInstance<ShowTableStatusContext>(_ctx, getState());
  enterRule(_localctx, 586, MySQLStatementParser::RuleShowTableStatus);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5172);
    match(MySQLStatementParser::SHOW);
    setState(5173);
    match(MySQLStatementParser::TABLE);
    setState(5174);
    match(MySQLStatementParser::STATUS);
    setState(5176);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN) {
      setState(5175);
      fromSchema();
    }
    setState(5179);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5178);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowColumnsContext ------------------------------------------------------------------

MySQLStatementParser::ShowColumnsContext::ShowColumnsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowColumnsContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

MySQLStatementParser::FromTableContext* MySQLStatementParser::ShowColumnsContext::fromTable() {
  return getRuleContext<MySQLStatementParser::FromTableContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowColumnsContext::COLUMNS() {
  return getToken(MySQLStatementParser::COLUMNS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowColumnsContext::FIELDS() {
  return getToken(MySQLStatementParser::FIELDS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowColumnsContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowColumnsContext::FULL() {
  return getToken(MySQLStatementParser::FULL, 0);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::ShowColumnsContext::fromSchema() {
  return getRuleContext<MySQLStatementParser::FromSchemaContext>(0);
}

MySQLStatementParser::ShowColumnLikeContext* MySQLStatementParser::ShowColumnsContext::showColumnLike() {
  return getRuleContext<MySQLStatementParser::ShowColumnLikeContext>(0);
}

MySQLStatementParser::ShowWhereClauseContext* MySQLStatementParser::ShowColumnsContext::showWhereClause() {
  return getRuleContext<MySQLStatementParser::ShowWhereClauseContext>(0);
}


size_t MySQLStatementParser::ShowColumnsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowColumns;
}

void MySQLStatementParser::ShowColumnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowColumns(this);
}

void MySQLStatementParser::ShowColumnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowColumns(this);
}


antlrcpp::Any MySQLStatementParser::ShowColumnsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowColumns(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowColumnsContext* MySQLStatementParser::showColumns() {
  ShowColumnsContext *_localctx = _tracker.createInstance<ShowColumnsContext>(_ctx, getState());
  enterRule(_localctx, 588, MySQLStatementParser::RuleShowColumns);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5181);
    match(MySQLStatementParser::SHOW);
    setState(5183);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EXTENDED) {
      setState(5182);
      match(MySQLStatementParser::EXTENDED);
    }
    setState(5186);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FULL) {
      setState(5185);
      match(MySQLStatementParser::FULL);
    }
    setState(5188);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::COLUMNS || _la == MySQLStatementParser::FIELDS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5189);
    fromTable();
    setState(5191);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN) {
      setState(5190);
      fromSchema();
    }
    setState(5195);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::LIKE: {
        setState(5193);
        showColumnLike();
        break;
      }

      case MySQLStatementParser::WHERE: {
        setState(5194);
        showWhereClause();
        break;
      }

      case MySQLStatementParser::EOF:
      case MySQLStatementParser::SEMI_: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowIndexContext ------------------------------------------------------------------

MySQLStatementParser::ShowIndexContext::ShowIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowIndexContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

MySQLStatementParser::FromTableContext* MySQLStatementParser::ShowIndexContext::fromTable() {
  return getRuleContext<MySQLStatementParser::FromTableContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowIndexContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowIndexContext::INDEXES() {
  return getToken(MySQLStatementParser::INDEXES, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowIndexContext::KEYS() {
  return getToken(MySQLStatementParser::KEYS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowIndexContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::ShowIndexContext::fromSchema() {
  return getRuleContext<MySQLStatementParser::FromSchemaContext>(0);
}

MySQLStatementParser::ShowWhereClauseContext* MySQLStatementParser::ShowIndexContext::showWhereClause() {
  return getRuleContext<MySQLStatementParser::ShowWhereClauseContext>(0);
}


size_t MySQLStatementParser::ShowIndexContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowIndex;
}

void MySQLStatementParser::ShowIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowIndex(this);
}

void MySQLStatementParser::ShowIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowIndex(this);
}


antlrcpp::Any MySQLStatementParser::ShowIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowIndexContext* MySQLStatementParser::showIndex() {
  ShowIndexContext *_localctx = _tracker.createInstance<ShowIndexContext>(_ctx, getState());
  enterRule(_localctx, 590, MySQLStatementParser::RuleShowIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5197);
    match(MySQLStatementParser::SHOW);
    setState(5199);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EXTENDED) {
      setState(5198);
      match(MySQLStatementParser::EXTENDED);
    }
    setState(5201);
    _la = _input->LA(1);
    if (!(((((_la - 266) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 266)) & ((1ULL << (MySQLStatementParser::INDEX - 266))
      | (1ULL << (MySQLStatementParser::INDEXES - 266))
      | (1ULL << (MySQLStatementParser::KEYS - 266)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5202);
    fromTable();
    setState(5204);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN) {
      setState(5203);
      fromSchema();
    }
    setState(5207);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::WHERE) {
      setState(5206);
      showWhereClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateTableContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateTableContext::ShowCreateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateTableContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateTableContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateTableContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::ShowCreateTableContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}


size_t MySQLStatementParser::ShowCreateTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateTable;
}

void MySQLStatementParser::ShowCreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateTable(this);
}

void MySQLStatementParser::ShowCreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateTable(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateTableContext* MySQLStatementParser::showCreateTable() {
  ShowCreateTableContext *_localctx = _tracker.createInstance<ShowCreateTableContext>(_ctx, getState());
  enterRule(_localctx, 592, MySQLStatementParser::RuleShowCreateTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5209);
    match(MySQLStatementParser::SHOW);
    setState(5210);
    match(MySQLStatementParser::CREATE);
    setState(5211);
    match(MySQLStatementParser::TABLE);
    setState(5212);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromSchemaContext ------------------------------------------------------------------

MySQLStatementParser::FromSchemaContext::FromSchemaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::FromSchemaContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FromSchemaContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

tree::TerminalNode* MySQLStatementParser::FromSchemaContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}


size_t MySQLStatementParser::FromSchemaContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFromSchema;
}

void MySQLStatementParser::FromSchemaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromSchema(this);
}

void MySQLStatementParser::FromSchemaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromSchema(this);
}


antlrcpp::Any MySQLStatementParser::FromSchemaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFromSchema(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::fromSchema() {
  FromSchemaContext *_localctx = _tracker.createInstance<FromSchemaContext>(_ctx, getState());
  enterRule(_localctx, 594, MySQLStatementParser::RuleFromSchema);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5214);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5215);
    schemaName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromTableContext ------------------------------------------------------------------

MySQLStatementParser::FromTableContext::FromTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::FromTableContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FromTableContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

tree::TerminalNode* MySQLStatementParser::FromTableContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}


size_t MySQLStatementParser::FromTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFromTable;
}

void MySQLStatementParser::FromTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromTable(this);
}

void MySQLStatementParser::FromTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromTable(this);
}


antlrcpp::Any MySQLStatementParser::FromTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFromTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FromTableContext* MySQLStatementParser::fromTable() {
  FromTableContext *_localctx = _tracker.createInstance<FromTableContext>(_ctx, getState());
  enterRule(_localctx, 596, MySQLStatementParser::RuleFromTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5217);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5218);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowLikeContext ------------------------------------------------------------------

MySQLStatementParser::ShowLikeContext::ShowLikeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowLikeContext::LIKE() {
  return getToken(MySQLStatementParser::LIKE, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::ShowLikeContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}


size_t MySQLStatementParser::ShowLikeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowLike;
}

void MySQLStatementParser::ShowLikeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowLike(this);
}

void MySQLStatementParser::ShowLikeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowLike(this);
}


antlrcpp::Any MySQLStatementParser::ShowLikeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowLike(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowLikeContext* MySQLStatementParser::showLike() {
  ShowLikeContext *_localctx = _tracker.createInstance<ShowLikeContext>(_ctx, getState());
  enterRule(_localctx, 598, MySQLStatementParser::RuleShowLike);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5220);
    match(MySQLStatementParser::LIKE);
    setState(5221);
    stringLiterals();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowColumnLikeContext ------------------------------------------------------------------

MySQLStatementParser::ShowColumnLikeContext::ShowColumnLikeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowColumnLikeContext::LIKE() {
  return getToken(MySQLStatementParser::LIKE, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::ShowColumnLikeContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}


size_t MySQLStatementParser::ShowColumnLikeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowColumnLike;
}

void MySQLStatementParser::ShowColumnLikeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowColumnLike(this);
}

void MySQLStatementParser::ShowColumnLikeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowColumnLike(this);
}


antlrcpp::Any MySQLStatementParser::ShowColumnLikeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowColumnLike(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowColumnLikeContext* MySQLStatementParser::showColumnLike() {
  ShowColumnLikeContext *_localctx = _tracker.createInstance<ShowColumnLikeContext>(_ctx, getState());
  enterRule(_localctx, 600, MySQLStatementParser::RuleShowColumnLike);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5223);
    match(MySQLStatementParser::LIKE);
    setState(5224);
    stringLiterals();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowWhereClauseContext ------------------------------------------------------------------

MySQLStatementParser::ShowWhereClauseContext::ShowWhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowWhereClauseContext::WHERE() {
  return getToken(MySQLStatementParser::WHERE, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::ShowWhereClauseContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::ShowWhereClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowWhereClause;
}

void MySQLStatementParser::ShowWhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowWhereClause(this);
}

void MySQLStatementParser::ShowWhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowWhereClause(this);
}


antlrcpp::Any MySQLStatementParser::ShowWhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowWhereClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowWhereClauseContext* MySQLStatementParser::showWhereClause() {
  ShowWhereClauseContext *_localctx = _tracker.createInstance<ShowWhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 602, MySQLStatementParser::RuleShowWhereClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5226);
    match(MySQLStatementParser::WHERE);
    setState(5227);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowFilterContext ------------------------------------------------------------------

MySQLStatementParser::ShowFilterContext::ShowFilterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ShowLikeContext* MySQLStatementParser::ShowFilterContext::showLike() {
  return getRuleContext<MySQLStatementParser::ShowLikeContext>(0);
}

MySQLStatementParser::ShowWhereClauseContext* MySQLStatementParser::ShowFilterContext::showWhereClause() {
  return getRuleContext<MySQLStatementParser::ShowWhereClauseContext>(0);
}


size_t MySQLStatementParser::ShowFilterContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowFilter;
}

void MySQLStatementParser::ShowFilterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowFilter(this);
}

void MySQLStatementParser::ShowFilterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowFilter(this);
}


antlrcpp::Any MySQLStatementParser::ShowFilterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowFilter(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::showFilter() {
  ShowFilterContext *_localctx = _tracker.createInstance<ShowFilterContext>(_ctx, getState());
  enterRule(_localctx, 604, MySQLStatementParser::RuleShowFilter);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5231);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::LIKE: {
        enterOuterAlt(_localctx, 1);
        setState(5229);
        showLike();
        break;
      }

      case MySQLStatementParser::WHERE: {
        enterOuterAlt(_localctx, 2);
        setState(5230);
        showWhereClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProfileTypeContext ------------------------------------------------------------------

MySQLStatementParser::ShowProfileTypeContext::ShowProfileTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::BLOCK() {
  return getToken(MySQLStatementParser::BLOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::IO() {
  return getToken(MySQLStatementParser::IO, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::CONTEXT() {
  return getToken(MySQLStatementParser::CONTEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::SWITCHES() {
  return getToken(MySQLStatementParser::SWITCHES, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::CPU() {
  return getToken(MySQLStatementParser::CPU, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::IPC() {
  return getToken(MySQLStatementParser::IPC, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::MEMORY() {
  return getToken(MySQLStatementParser::MEMORY, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::PAGE() {
  return getToken(MySQLStatementParser::PAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::FAULTS() {
  return getToken(MySQLStatementParser::FAULTS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::SOURCE() {
  return getToken(MySQLStatementParser::SOURCE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileTypeContext::SWAPS() {
  return getToken(MySQLStatementParser::SWAPS, 0);
}


size_t MySQLStatementParser::ShowProfileTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowProfileType;
}

void MySQLStatementParser::ShowProfileTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProfileType(this);
}

void MySQLStatementParser::ShowProfileTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProfileType(this);
}


antlrcpp::Any MySQLStatementParser::ShowProfileTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowProfileType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowProfileTypeContext* MySQLStatementParser::showProfileType() {
  ShowProfileTypeContext *_localctx = _tracker.createInstance<ShowProfileTypeContext>(_ctx, getState());
  enterRule(_localctx, 606, MySQLStatementParser::RuleShowProfileType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5245);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ALL: {
        enterOuterAlt(_localctx, 1);
        setState(5233);
        match(MySQLStatementParser::ALL);
        break;
      }

      case MySQLStatementParser::BLOCK: {
        enterOuterAlt(_localctx, 2);
        setState(5234);
        match(MySQLStatementParser::BLOCK);
        setState(5235);
        match(MySQLStatementParser::IO);
        break;
      }

      case MySQLStatementParser::CONTEXT: {
        enterOuterAlt(_localctx, 3);
        setState(5236);
        match(MySQLStatementParser::CONTEXT);
        setState(5237);
        match(MySQLStatementParser::SWITCHES);
        break;
      }

      case MySQLStatementParser::CPU: {
        enterOuterAlt(_localctx, 4);
        setState(5238);
        match(MySQLStatementParser::CPU);
        break;
      }

      case MySQLStatementParser::IPC: {
        enterOuterAlt(_localctx, 5);
        setState(5239);
        match(MySQLStatementParser::IPC);
        break;
      }

      case MySQLStatementParser::MEMORY: {
        enterOuterAlt(_localctx, 6);
        setState(5240);
        match(MySQLStatementParser::MEMORY);
        break;
      }

      case MySQLStatementParser::PAGE: {
        enterOuterAlt(_localctx, 7);
        setState(5241);
        match(MySQLStatementParser::PAGE);
        setState(5242);
        match(MySQLStatementParser::FAULTS);
        break;
      }

      case MySQLStatementParser::SOURCE: {
        enterOuterAlt(_localctx, 8);
        setState(5243);
        match(MySQLStatementParser::SOURCE);
        break;
      }

      case MySQLStatementParser::SWAPS: {
        enterOuterAlt(_localctx, 9);
        setState(5244);
        match(MySQLStatementParser::SWAPS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetVariableContext ------------------------------------------------------------------

MySQLStatementParser::SetVariableContext::SetVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetVariableContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

std::vector<MySQLStatementParser::VariableAssignContext *> MySQLStatementParser::SetVariableContext::variableAssign() {
  return getRuleContexts<MySQLStatementParser::VariableAssignContext>();
}

MySQLStatementParser::VariableAssignContext* MySQLStatementParser::SetVariableContext::variableAssign(size_t i) {
  return getRuleContext<MySQLStatementParser::VariableAssignContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetVariableContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SetVariableContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SetVariableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetVariable;
}

void MySQLStatementParser::SetVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetVariable(this);
}

void MySQLStatementParser::SetVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetVariable(this);
}


antlrcpp::Any MySQLStatementParser::SetVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetVariableContext* MySQLStatementParser::setVariable() {
  SetVariableContext *_localctx = _tracker.createInstance<SetVariableContext>(_ctx, getState());
  enterRule(_localctx, 608, MySQLStatementParser::RuleSetVariable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5247);
    match(MySQLStatementParser::SET);
    setState(5248);
    variableAssign();
    setState(5253);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(5249);
      match(MySQLStatementParser::COMMA_);
      setState(5250);
      variableAssign();
      setState(5255);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableAssignContext ------------------------------------------------------------------

MySQLStatementParser::VariableAssignContext::VariableAssignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::VariableContext* MySQLStatementParser::VariableAssignContext::variable() {
  return getRuleContext<MySQLStatementParser::VariableContext>(0);
}

tree::TerminalNode* MySQLStatementParser::VariableAssignContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::SetExprOrDefaultContext* MySQLStatementParser::VariableAssignContext::setExprOrDefault() {
  return getRuleContext<MySQLStatementParser::SetExprOrDefaultContext>(0);
}


size_t MySQLStatementParser::VariableAssignContext::getRuleIndex() const {
  return MySQLStatementParser::RuleVariableAssign;
}

void MySQLStatementParser::VariableAssignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableAssign(this);
}

void MySQLStatementParser::VariableAssignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableAssign(this);
}


antlrcpp::Any MySQLStatementParser::VariableAssignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitVariableAssign(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::VariableAssignContext* MySQLStatementParser::variableAssign() {
  VariableAssignContext *_localctx = _tracker.createInstance<VariableAssignContext>(_ctx, getState());
  enterRule(_localctx, 610, MySQLStatementParser::RuleVariableAssign);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5256);
    variable();
    setState(5257);
    match(MySQLStatementParser::EQ_);
    setState(5258);
    setExprOrDefault();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowBinaryLogsContext ------------------------------------------------------------------

MySQLStatementParser::ShowBinaryLogsContext::ShowBinaryLogsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowBinaryLogsContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinaryLogsContext::LOGS() {
  return getToken(MySQLStatementParser::LOGS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinaryLogsContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinaryLogsContext::MASTER() {
  return getToken(MySQLStatementParser::MASTER, 0);
}


size_t MySQLStatementParser::ShowBinaryLogsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowBinaryLogs;
}

void MySQLStatementParser::ShowBinaryLogsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowBinaryLogs(this);
}

void MySQLStatementParser::ShowBinaryLogsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowBinaryLogs(this);
}


antlrcpp::Any MySQLStatementParser::ShowBinaryLogsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowBinaryLogs(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowBinaryLogsContext* MySQLStatementParser::showBinaryLogs() {
  ShowBinaryLogsContext *_localctx = _tracker.createInstance<ShowBinaryLogsContext>(_ctx, getState());
  enterRule(_localctx, 612, MySQLStatementParser::RuleShowBinaryLogs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5260);
    match(MySQLStatementParser::SHOW);
    setState(5261);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::BINARY || _la == MySQLStatementParser::MASTER)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5262);
    match(MySQLStatementParser::LOGS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowBinlogEventsContext ------------------------------------------------------------------

MySQLStatementParser::ShowBinlogEventsContext::ShowBinlogEventsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::BINLOG() {
  return getToken(MySQLStatementParser::BINLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::EVENTS() {
  return getToken(MySQLStatementParser::EVENTS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::DEFINER() {
  return getToken(MySQLStatementParser::DEFINER, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ShowBinlogEventsContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::LIMIT() {
  return getToken(MySQLStatementParser::LIMIT, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowBinlogEventsContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::ShowBinlogEventsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowBinlogEvents;
}

void MySQLStatementParser::ShowBinlogEventsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowBinlogEvents(this);
}

void MySQLStatementParser::ShowBinlogEventsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowBinlogEvents(this);
}


antlrcpp::Any MySQLStatementParser::ShowBinlogEventsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowBinlogEvents(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowBinlogEventsContext* MySQLStatementParser::showBinlogEvents() {
  ShowBinlogEventsContext *_localctx = _tracker.createInstance<ShowBinlogEventsContext>(_ctx, getState());
  enterRule(_localctx, 614, MySQLStatementParser::RuleShowBinlogEvents);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5264);
    match(MySQLStatementParser::SHOW);
    setState(5265);
    match(MySQLStatementParser::BINLOG);
    setState(5266);
    match(MySQLStatementParser::EVENTS);
    setState(5269);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IN) {
      setState(5267);
      match(MySQLStatementParser::IN);
      setState(5268);
      match(MySQLStatementParser::DEFINER);
    }
    setState(5273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM) {
      setState(5271);
      match(MySQLStatementParser::FROM);
      setState(5272);
      match(MySQLStatementParser::NUMBER_);
    }
    setState(5281);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(5275);
      match(MySQLStatementParser::LIMIT);
      setState(5278);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 678, _ctx)) {
      case 1: {
        setState(5276);
        match(MySQLStatementParser::NUMBER_);
        setState(5277);
        match(MySQLStatementParser::COMMA_);
        break;
      }

      }
      setState(5280);
      match(MySQLStatementParser::NUMBER_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCharacterSetContext ------------------------------------------------------------------

MySQLStatementParser::ShowCharacterSetContext::ShowCharacterSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCharacterSetContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCharacterSetContext::CHARACTER() {
  return getToken(MySQLStatementParser::CHARACTER, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCharacterSetContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowCharacterSetContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowCharacterSetContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCharacterSet;
}

void MySQLStatementParser::ShowCharacterSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCharacterSet(this);
}

void MySQLStatementParser::ShowCharacterSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCharacterSet(this);
}


antlrcpp::Any MySQLStatementParser::ShowCharacterSetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCharacterSet(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCharacterSetContext* MySQLStatementParser::showCharacterSet() {
  ShowCharacterSetContext *_localctx = _tracker.createInstance<ShowCharacterSetContext>(_ctx, getState());
  enterRule(_localctx, 616, MySQLStatementParser::RuleShowCharacterSet);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5283);
    match(MySQLStatementParser::SHOW);
    setState(5284);
    match(MySQLStatementParser::CHARACTER);
    setState(5285);
    match(MySQLStatementParser::SET);
    setState(5287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5286);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCollationContext ------------------------------------------------------------------

MySQLStatementParser::ShowCollationContext::ShowCollationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCollationContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCollationContext::COLLATION() {
  return getToken(MySQLStatementParser::COLLATION, 0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowCollationContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowCollationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCollation;
}

void MySQLStatementParser::ShowCollationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCollation(this);
}

void MySQLStatementParser::ShowCollationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCollation(this);
}


antlrcpp::Any MySQLStatementParser::ShowCollationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCollation(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCollationContext* MySQLStatementParser::showCollation() {
  ShowCollationContext *_localctx = _tracker.createInstance<ShowCollationContext>(_ctx, getState());
  enterRule(_localctx, 618, MySQLStatementParser::RuleShowCollation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5289);
    match(MySQLStatementParser::SHOW);
    setState(5290);
    match(MySQLStatementParser::COLLATION);
    setState(5292);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5291);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateDatabaseContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateDatabaseContext::ShowCreateDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateDatabaseContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateDatabaseContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::ShowCreateDatabaseContext::schemaName() {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateDatabaseContext::DATABASE() {
  return getToken(MySQLStatementParser::DATABASE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateDatabaseContext::SCHEMA() {
  return getToken(MySQLStatementParser::SCHEMA, 0);
}

MySQLStatementParser::NotExistClauseContext* MySQLStatementParser::ShowCreateDatabaseContext::notExistClause() {
  return getRuleContext<MySQLStatementParser::NotExistClauseContext>(0);
}


size_t MySQLStatementParser::ShowCreateDatabaseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateDatabase;
}

void MySQLStatementParser::ShowCreateDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateDatabase(this);
}

void MySQLStatementParser::ShowCreateDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateDatabase(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateDatabaseContext* MySQLStatementParser::showCreateDatabase() {
  ShowCreateDatabaseContext *_localctx = _tracker.createInstance<ShowCreateDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 620, MySQLStatementParser::RuleShowCreateDatabase);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5294);
    match(MySQLStatementParser::SHOW);
    setState(5295);
    match(MySQLStatementParser::CREATE);
    setState(5296);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DATABASE || _la == MySQLStatementParser::SCHEMA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5298);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IF) {
      setState(5297);
      notExistClause();
    }
    setState(5300);
    schemaName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateEventContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateEventContext::ShowCreateEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateEventContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateEventContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateEventContext::EVENT() {
  return getToken(MySQLStatementParser::EVENT, 0);
}

MySQLStatementParser::EventNameContext* MySQLStatementParser::ShowCreateEventContext::eventName() {
  return getRuleContext<MySQLStatementParser::EventNameContext>(0);
}


size_t MySQLStatementParser::ShowCreateEventContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateEvent;
}

void MySQLStatementParser::ShowCreateEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateEvent(this);
}

void MySQLStatementParser::ShowCreateEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateEvent(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateEventContext* MySQLStatementParser::showCreateEvent() {
  ShowCreateEventContext *_localctx = _tracker.createInstance<ShowCreateEventContext>(_ctx, getState());
  enterRule(_localctx, 622, MySQLStatementParser::RuleShowCreateEvent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5302);
    match(MySQLStatementParser::SHOW);
    setState(5303);
    match(MySQLStatementParser::CREATE);
    setState(5304);
    match(MySQLStatementParser::EVENT);
    setState(5305);
    eventName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateFunctionContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateFunctionContext::ShowCreateFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateFunctionContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateFunctionContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateFunctionContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::ShowCreateFunctionContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}


size_t MySQLStatementParser::ShowCreateFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateFunction;
}

void MySQLStatementParser::ShowCreateFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateFunction(this);
}

void MySQLStatementParser::ShowCreateFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateFunction(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateFunctionContext* MySQLStatementParser::showCreateFunction() {
  ShowCreateFunctionContext *_localctx = _tracker.createInstance<ShowCreateFunctionContext>(_ctx, getState());
  enterRule(_localctx, 624, MySQLStatementParser::RuleShowCreateFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5307);
    match(MySQLStatementParser::SHOW);
    setState(5308);
    match(MySQLStatementParser::CREATE);
    setState(5309);
    match(MySQLStatementParser::FUNCTION);
    setState(5310);
    functionName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateProcedureContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateProcedureContext::ShowCreateProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateProcedureContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateProcedureContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateProcedureContext::PROCEDURE() {
  return getToken(MySQLStatementParser::PROCEDURE, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::ShowCreateProcedureContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}


size_t MySQLStatementParser::ShowCreateProcedureContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateProcedure;
}

void MySQLStatementParser::ShowCreateProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateProcedure(this);
}

void MySQLStatementParser::ShowCreateProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateProcedure(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateProcedureContext* MySQLStatementParser::showCreateProcedure() {
  ShowCreateProcedureContext *_localctx = _tracker.createInstance<ShowCreateProcedureContext>(_ctx, getState());
  enterRule(_localctx, 626, MySQLStatementParser::RuleShowCreateProcedure);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5312);
    match(MySQLStatementParser::SHOW);
    setState(5313);
    match(MySQLStatementParser::CREATE);
    setState(5314);
    match(MySQLStatementParser::PROCEDURE);
    setState(5315);
    functionName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateTriggerContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateTriggerContext::ShowCreateTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateTriggerContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateTriggerContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateTriggerContext::TRIGGER() {
  return getToken(MySQLStatementParser::TRIGGER, 0);
}

MySQLStatementParser::TriggerNameContext* MySQLStatementParser::ShowCreateTriggerContext::triggerName() {
  return getRuleContext<MySQLStatementParser::TriggerNameContext>(0);
}


size_t MySQLStatementParser::ShowCreateTriggerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateTrigger;
}

void MySQLStatementParser::ShowCreateTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateTrigger(this);
}

void MySQLStatementParser::ShowCreateTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateTrigger(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateTriggerContext* MySQLStatementParser::showCreateTrigger() {
  ShowCreateTriggerContext *_localctx = _tracker.createInstance<ShowCreateTriggerContext>(_ctx, getState());
  enterRule(_localctx, 628, MySQLStatementParser::RuleShowCreateTrigger);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5317);
    match(MySQLStatementParser::SHOW);
    setState(5318);
    match(MySQLStatementParser::CREATE);
    setState(5319);
    match(MySQLStatementParser::TRIGGER);
    setState(5320);
    triggerName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateUserContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateUserContext::ShowCreateUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateUserContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateUserContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateUserContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::ShowCreateUserContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}


size_t MySQLStatementParser::ShowCreateUserContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateUser;
}

void MySQLStatementParser::ShowCreateUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateUser(this);
}

void MySQLStatementParser::ShowCreateUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateUser(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateUserContext* MySQLStatementParser::showCreateUser() {
  ShowCreateUserContext *_localctx = _tracker.createInstance<ShowCreateUserContext>(_ctx, getState());
  enterRule(_localctx, 630, MySQLStatementParser::RuleShowCreateUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5322);
    match(MySQLStatementParser::SHOW);
    setState(5323);
    match(MySQLStatementParser::CREATE);
    setState(5324);
    match(MySQLStatementParser::USER);
    setState(5325);
    userName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateViewContext ------------------------------------------------------------------

MySQLStatementParser::ShowCreateViewContext::ShowCreateViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowCreateViewContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateViewContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowCreateViewContext::VIEW() {
  return getToken(MySQLStatementParser::VIEW, 0);
}

MySQLStatementParser::ViewNameContext* MySQLStatementParser::ShowCreateViewContext::viewName() {
  return getRuleContext<MySQLStatementParser::ViewNameContext>(0);
}


size_t MySQLStatementParser::ShowCreateViewContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowCreateView;
}

void MySQLStatementParser::ShowCreateViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateView(this);
}

void MySQLStatementParser::ShowCreateViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateView(this);
}


antlrcpp::Any MySQLStatementParser::ShowCreateViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateView(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowCreateViewContext* MySQLStatementParser::showCreateView() {
  ShowCreateViewContext *_localctx = _tracker.createInstance<ShowCreateViewContext>(_ctx, getState());
  enterRule(_localctx, 632, MySQLStatementParser::RuleShowCreateView);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5327);
    match(MySQLStatementParser::SHOW);
    setState(5328);
    match(MySQLStatementParser::CREATE);
    setState(5329);
    match(MySQLStatementParser::VIEW);
    setState(5330);
    viewName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEngineContext ------------------------------------------------------------------

MySQLStatementParser::ShowEngineContext::ShowEngineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowEngineContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowEngineContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

MySQLStatementParser::EngineRefContext* MySQLStatementParser::ShowEngineContext::engineRef() {
  return getRuleContext<MySQLStatementParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowEngineContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowEngineContext::MUTEX() {
  return getToken(MySQLStatementParser::MUTEX, 0);
}


size_t MySQLStatementParser::ShowEngineContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowEngine;
}

void MySQLStatementParser::ShowEngineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEngine(this);
}

void MySQLStatementParser::ShowEngineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEngine(this);
}


antlrcpp::Any MySQLStatementParser::ShowEngineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowEngine(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowEngineContext* MySQLStatementParser::showEngine() {
  ShowEngineContext *_localctx = _tracker.createInstance<ShowEngineContext>(_ctx, getState());
  enterRule(_localctx, 634, MySQLStatementParser::RuleShowEngine);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5332);
    match(MySQLStatementParser::SHOW);
    setState(5333);
    match(MySQLStatementParser::ENGINE);
    setState(5334);
    engineRef();
    setState(5335);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::MUTEX || _la == MySQLStatementParser::STATUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEnginesContext ------------------------------------------------------------------

MySQLStatementParser::ShowEnginesContext::ShowEnginesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowEnginesContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowEnginesContext::ENGINES() {
  return getToken(MySQLStatementParser::ENGINES, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowEnginesContext::STORAGE() {
  return getToken(MySQLStatementParser::STORAGE, 0);
}


size_t MySQLStatementParser::ShowEnginesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowEngines;
}

void MySQLStatementParser::ShowEnginesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEngines(this);
}

void MySQLStatementParser::ShowEnginesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEngines(this);
}


antlrcpp::Any MySQLStatementParser::ShowEnginesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowEngines(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowEnginesContext* MySQLStatementParser::showEngines() {
  ShowEnginesContext *_localctx = _tracker.createInstance<ShowEnginesContext>(_ctx, getState());
  enterRule(_localctx, 636, MySQLStatementParser::RuleShowEngines);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5337);
    match(MySQLStatementParser::SHOW);
    setState(5339);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::STORAGE) {
      setState(5338);
      match(MySQLStatementParser::STORAGE);
    }
    setState(5341);
    match(MySQLStatementParser::ENGINES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowErrorsContext ------------------------------------------------------------------

MySQLStatementParser::ShowErrorsContext::ShowErrorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::ERRORS() {
  return getToken(MySQLStatementParser::ERRORS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::COUNT() {
  return getToken(MySQLStatementParser::COUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::LIMIT() {
  return getToken(MySQLStatementParser::LIMIT, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ShowErrorsContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::ShowErrorsContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::ShowErrorsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowErrors;
}

void MySQLStatementParser::ShowErrorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowErrors(this);
}

void MySQLStatementParser::ShowErrorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowErrors(this);
}


antlrcpp::Any MySQLStatementParser::ShowErrorsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowErrors(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowErrorsContext* MySQLStatementParser::showErrors() {
  ShowErrorsContext *_localctx = _tracker.createInstance<ShowErrorsContext>(_ctx, getState());
  enterRule(_localctx, 638, MySQLStatementParser::RuleShowErrors);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5343);
    match(MySQLStatementParser::SHOW);
    setState(5348);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COUNT) {
      setState(5344);
      match(MySQLStatementParser::COUNT);
      setState(5345);
      match(MySQLStatementParser::LP_);
      setState(5346);
      match(MySQLStatementParser::ASTERISK_);
      setState(5347);
      match(MySQLStatementParser::RP_);
    }
    setState(5350);
    match(MySQLStatementParser::ERRORS);
    setState(5357);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(5351);
      match(MySQLStatementParser::LIMIT);
      setState(5354);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 685, _ctx)) {
      case 1: {
        setState(5352);
        match(MySQLStatementParser::NUMBER_);
        setState(5353);
        match(MySQLStatementParser::COMMA_);
        break;
      }

      }
      setState(5356);
      match(MySQLStatementParser::NUMBER_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEventsContext ------------------------------------------------------------------

MySQLStatementParser::ShowEventsContext::ShowEventsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowEventsContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowEventsContext::EVENTS() {
  return getToken(MySQLStatementParser::EVENTS, 0);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::ShowEventsContext::fromSchema() {
  return getRuleContext<MySQLStatementParser::FromSchemaContext>(0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowEventsContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowEventsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowEvents;
}

void MySQLStatementParser::ShowEventsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEvents(this);
}

void MySQLStatementParser::ShowEventsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEvents(this);
}


antlrcpp::Any MySQLStatementParser::ShowEventsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowEvents(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowEventsContext* MySQLStatementParser::showEvents() {
  ShowEventsContext *_localctx = _tracker.createInstance<ShowEventsContext>(_ctx, getState());
  enterRule(_localctx, 640, MySQLStatementParser::RuleShowEvents);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5359);
    match(MySQLStatementParser::SHOW);
    setState(5360);
    match(MySQLStatementParser::EVENTS);
    setState(5362);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN) {
      setState(5361);
      fromSchema();
    }
    setState(5365);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5364);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowFunctionCodeContext ------------------------------------------------------------------

MySQLStatementParser::ShowFunctionCodeContext::ShowFunctionCodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowFunctionCodeContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowFunctionCodeContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowFunctionCodeContext::CODE() {
  return getToken(MySQLStatementParser::CODE, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::ShowFunctionCodeContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}


size_t MySQLStatementParser::ShowFunctionCodeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowFunctionCode;
}

void MySQLStatementParser::ShowFunctionCodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowFunctionCode(this);
}

void MySQLStatementParser::ShowFunctionCodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowFunctionCode(this);
}


antlrcpp::Any MySQLStatementParser::ShowFunctionCodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowFunctionCode(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowFunctionCodeContext* MySQLStatementParser::showFunctionCode() {
  ShowFunctionCodeContext *_localctx = _tracker.createInstance<ShowFunctionCodeContext>(_ctx, getState());
  enterRule(_localctx, 642, MySQLStatementParser::RuleShowFunctionCode);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5367);
    match(MySQLStatementParser::SHOW);
    setState(5368);
    match(MySQLStatementParser::FUNCTION);
    setState(5369);
    match(MySQLStatementParser::CODE);
    setState(5370);
    functionName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowFunctionStatusContext ------------------------------------------------------------------

MySQLStatementParser::ShowFunctionStatusContext::ShowFunctionStatusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowFunctionStatusContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowFunctionStatusContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowFunctionStatusContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowFunctionStatusContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowFunctionStatusContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowFunctionStatus;
}

void MySQLStatementParser::ShowFunctionStatusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowFunctionStatus(this);
}

void MySQLStatementParser::ShowFunctionStatusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowFunctionStatus(this);
}


antlrcpp::Any MySQLStatementParser::ShowFunctionStatusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowFunctionStatus(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowFunctionStatusContext* MySQLStatementParser::showFunctionStatus() {
  ShowFunctionStatusContext *_localctx = _tracker.createInstance<ShowFunctionStatusContext>(_ctx, getState());
  enterRule(_localctx, 644, MySQLStatementParser::RuleShowFunctionStatus);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5372);
    match(MySQLStatementParser::SHOW);
    setState(5373);
    match(MySQLStatementParser::FUNCTION);
    setState(5374);
    match(MySQLStatementParser::STATUS);
    setState(5376);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5375);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowGrantContext ------------------------------------------------------------------

MySQLStatementParser::ShowGrantContext::ShowGrantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowGrantContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowGrantContext::GRANTS() {
  return getToken(MySQLStatementParser::GRANTS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowGrantContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

MySQLStatementParser::UserOrRoleContext* MySQLStatementParser::ShowGrantContext::userOrRole() {
  return getRuleContext<MySQLStatementParser::UserOrRoleContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowGrantContext::USING() {
  return getToken(MySQLStatementParser::USING, 0);
}

std::vector<MySQLStatementParser::UserNameContext *> MySQLStatementParser::ShowGrantContext::userName() {
  return getRuleContexts<MySQLStatementParser::UserNameContext>();
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::ShowGrantContext::userName(size_t i) {
  return getRuleContext<MySQLStatementParser::UserNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ShowGrantContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ShowGrantContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::ShowGrantContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowGrant;
}

void MySQLStatementParser::ShowGrantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowGrant(this);
}

void MySQLStatementParser::ShowGrantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowGrant(this);
}


antlrcpp::Any MySQLStatementParser::ShowGrantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowGrant(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowGrantContext* MySQLStatementParser::showGrant() {
  ShowGrantContext *_localctx = _tracker.createInstance<ShowGrantContext>(_ctx, getState());
  enterRule(_localctx, 646, MySQLStatementParser::RuleShowGrant);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5378);
    match(MySQLStatementParser::SHOW);
    setState(5379);
    match(MySQLStatementParser::GRANTS);
    setState(5392);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(5380);
      match(MySQLStatementParser::FOR);
      setState(5381);
      userOrRole();
      setState(5390);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::USING) {
        setState(5382);
        match(MySQLStatementParser::USING);
        setState(5383);
        userName();
        setState(5386); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(5384);
          match(MySQLStatementParser::COMMA_);
          setState(5385);
          userName();
          setState(5388); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MySQLStatementParser::COMMA_);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowMasterStatusContext ------------------------------------------------------------------

MySQLStatementParser::ShowMasterStatusContext::ShowMasterStatusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowMasterStatusContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowMasterStatusContext::MASTER() {
  return getToken(MySQLStatementParser::MASTER, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowMasterStatusContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}


size_t MySQLStatementParser::ShowMasterStatusContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowMasterStatus;
}

void MySQLStatementParser::ShowMasterStatusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowMasterStatus(this);
}

void MySQLStatementParser::ShowMasterStatusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowMasterStatus(this);
}


antlrcpp::Any MySQLStatementParser::ShowMasterStatusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowMasterStatus(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowMasterStatusContext* MySQLStatementParser::showMasterStatus() {
  ShowMasterStatusContext *_localctx = _tracker.createInstance<ShowMasterStatusContext>(_ctx, getState());
  enterRule(_localctx, 648, MySQLStatementParser::RuleShowMasterStatus);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5394);
    match(MySQLStatementParser::SHOW);
    setState(5395);
    match(MySQLStatementParser::MASTER);
    setState(5396);
    match(MySQLStatementParser::STATUS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowOpenTablesContext ------------------------------------------------------------------

MySQLStatementParser::ShowOpenTablesContext::ShowOpenTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowOpenTablesContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowOpenTablesContext::OPEN() {
  return getToken(MySQLStatementParser::OPEN, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowOpenTablesContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::ShowOpenTablesContext::fromSchema() {
  return getRuleContext<MySQLStatementParser::FromSchemaContext>(0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowOpenTablesContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowOpenTablesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowOpenTables;
}

void MySQLStatementParser::ShowOpenTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowOpenTables(this);
}

void MySQLStatementParser::ShowOpenTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowOpenTables(this);
}


antlrcpp::Any MySQLStatementParser::ShowOpenTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowOpenTables(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowOpenTablesContext* MySQLStatementParser::showOpenTables() {
  ShowOpenTablesContext *_localctx = _tracker.createInstance<ShowOpenTablesContext>(_ctx, getState());
  enterRule(_localctx, 650, MySQLStatementParser::RuleShowOpenTables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5398);
    match(MySQLStatementParser::SHOW);
    setState(5399);
    match(MySQLStatementParser::OPEN);
    setState(5400);
    match(MySQLStatementParser::TABLES);
    setState(5402);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN) {
      setState(5401);
      fromSchema();
    }
    setState(5405);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5404);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowPluginsContext ------------------------------------------------------------------

MySQLStatementParser::ShowPluginsContext::ShowPluginsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowPluginsContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowPluginsContext::PLUGINS() {
  return getToken(MySQLStatementParser::PLUGINS, 0);
}


size_t MySQLStatementParser::ShowPluginsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowPlugins;
}

void MySQLStatementParser::ShowPluginsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowPlugins(this);
}

void MySQLStatementParser::ShowPluginsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowPlugins(this);
}


antlrcpp::Any MySQLStatementParser::ShowPluginsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowPlugins(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowPluginsContext* MySQLStatementParser::showPlugins() {
  ShowPluginsContext *_localctx = _tracker.createInstance<ShowPluginsContext>(_ctx, getState());
  enterRule(_localctx, 652, MySQLStatementParser::RuleShowPlugins);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5407);
    match(MySQLStatementParser::SHOW);
    setState(5408);
    match(MySQLStatementParser::PLUGINS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowPrivilegesContext ------------------------------------------------------------------

MySQLStatementParser::ShowPrivilegesContext::ShowPrivilegesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowPrivilegesContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowPrivilegesContext::PRIVILEGES() {
  return getToken(MySQLStatementParser::PRIVILEGES, 0);
}


size_t MySQLStatementParser::ShowPrivilegesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowPrivileges;
}

void MySQLStatementParser::ShowPrivilegesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowPrivileges(this);
}

void MySQLStatementParser::ShowPrivilegesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowPrivileges(this);
}


antlrcpp::Any MySQLStatementParser::ShowPrivilegesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowPrivileges(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowPrivilegesContext* MySQLStatementParser::showPrivileges() {
  ShowPrivilegesContext *_localctx = _tracker.createInstance<ShowPrivilegesContext>(_ctx, getState());
  enterRule(_localctx, 654, MySQLStatementParser::RuleShowPrivileges);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5410);
    match(MySQLStatementParser::SHOW);
    setState(5411);
    match(MySQLStatementParser::PRIVILEGES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProcedureCodeContext ------------------------------------------------------------------

MySQLStatementParser::ShowProcedureCodeContext::ShowProcedureCodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowProcedureCodeContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProcedureCodeContext::PROCEDURE() {
  return getToken(MySQLStatementParser::PROCEDURE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProcedureCodeContext::CODE() {
  return getToken(MySQLStatementParser::CODE, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::ShowProcedureCodeContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}


size_t MySQLStatementParser::ShowProcedureCodeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowProcedureCode;
}

void MySQLStatementParser::ShowProcedureCodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProcedureCode(this);
}

void MySQLStatementParser::ShowProcedureCodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProcedureCode(this);
}


antlrcpp::Any MySQLStatementParser::ShowProcedureCodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowProcedureCode(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowProcedureCodeContext* MySQLStatementParser::showProcedureCode() {
  ShowProcedureCodeContext *_localctx = _tracker.createInstance<ShowProcedureCodeContext>(_ctx, getState());
  enterRule(_localctx, 656, MySQLStatementParser::RuleShowProcedureCode);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5413);
    match(MySQLStatementParser::SHOW);
    setState(5414);
    match(MySQLStatementParser::PROCEDURE);
    setState(5415);
    match(MySQLStatementParser::CODE);
    setState(5416);
    functionName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProcedureStatusContext ------------------------------------------------------------------

MySQLStatementParser::ShowProcedureStatusContext::ShowProcedureStatusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowProcedureStatusContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProcedureStatusContext::PROCEDURE() {
  return getToken(MySQLStatementParser::PROCEDURE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProcedureStatusContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowProcedureStatusContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowProcedureStatusContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowProcedureStatus;
}

void MySQLStatementParser::ShowProcedureStatusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProcedureStatus(this);
}

void MySQLStatementParser::ShowProcedureStatusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProcedureStatus(this);
}


antlrcpp::Any MySQLStatementParser::ShowProcedureStatusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowProcedureStatus(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowProcedureStatusContext* MySQLStatementParser::showProcedureStatus() {
  ShowProcedureStatusContext *_localctx = _tracker.createInstance<ShowProcedureStatusContext>(_ctx, getState());
  enterRule(_localctx, 658, MySQLStatementParser::RuleShowProcedureStatus);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5418);
    match(MySQLStatementParser::SHOW);
    setState(5419);
    match(MySQLStatementParser::PROCEDURE);
    setState(5420);
    match(MySQLStatementParser::STATUS);
    setState(5421);
    showFilter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProcesslistContext ------------------------------------------------------------------

MySQLStatementParser::ShowProcesslistContext::ShowProcesslistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowProcesslistContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProcesslistContext::PROCESSLIST() {
  return getToken(MySQLStatementParser::PROCESSLIST, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProcesslistContext::FULL() {
  return getToken(MySQLStatementParser::FULL, 0);
}


size_t MySQLStatementParser::ShowProcesslistContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowProcesslist;
}

void MySQLStatementParser::ShowProcesslistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProcesslist(this);
}

void MySQLStatementParser::ShowProcesslistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProcesslist(this);
}


antlrcpp::Any MySQLStatementParser::ShowProcesslistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowProcesslist(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowProcesslistContext* MySQLStatementParser::showProcesslist() {
  ShowProcesslistContext *_localctx = _tracker.createInstance<ShowProcesslistContext>(_ctx, getState());
  enterRule(_localctx, 660, MySQLStatementParser::RuleShowProcesslist);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5423);
    match(MySQLStatementParser::SHOW);
    setState(5425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FULL) {
      setState(5424);
      match(MySQLStatementParser::FULL);
    }
    setState(5427);
    match(MySQLStatementParser::PROCESSLIST);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProfileContext ------------------------------------------------------------------

MySQLStatementParser::ShowProfileContext::ShowProfileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::PROFILE() {
  return getToken(MySQLStatementParser::PROFILE, 0);
}

std::vector<MySQLStatementParser::ShowProfileTypeContext *> MySQLStatementParser::ShowProfileContext::showProfileType() {
  return getRuleContexts<MySQLStatementParser::ShowProfileTypeContext>();
}

MySQLStatementParser::ShowProfileTypeContext* MySQLStatementParser::ShowProfileContext::showProfileType(size_t i) {
  return getRuleContext<MySQLStatementParser::ShowProfileTypeContext>(i);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::QUERY() {
  return getToken(MySQLStatementParser::QUERY, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ShowProfileContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::LIMIT() {
  return getToken(MySQLStatementParser::LIMIT, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ShowProfileContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::ShowProfileContext::OFFSET() {
  return getToken(MySQLStatementParser::OFFSET, 0);
}


size_t MySQLStatementParser::ShowProfileContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowProfile;
}

void MySQLStatementParser::ShowProfileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProfile(this);
}

void MySQLStatementParser::ShowProfileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProfile(this);
}


antlrcpp::Any MySQLStatementParser::ShowProfileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowProfile(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowProfileContext* MySQLStatementParser::showProfile() {
  ShowProfileContext *_localctx = _tracker.createInstance<ShowProfileContext>(_ctx, getState());
  enterRule(_localctx, 662, MySQLStatementParser::RuleShowProfile);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5429);
    match(MySQLStatementParser::SHOW);
    setState(5430);
    match(MySQLStatementParser::PROFILE);
    setState(5439);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ALL

    || _la == MySQLStatementParser::BLOCK || _la == MySQLStatementParser::CONTEXT

    || _la == MySQLStatementParser::CPU || _la == MySQLStatementParser::IPC || _la == MySQLStatementParser::MEMORY || _la == MySQLStatementParser::PAGE || _la == MySQLStatementParser::SOURCE

    || _la == MySQLStatementParser::SWAPS) {
      setState(5431);
      showProfileType();
      setState(5436);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5432);
        match(MySQLStatementParser::COMMA_);
        setState(5433);
        showProfileType();
        setState(5438);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(5444);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(5441);
      match(MySQLStatementParser::FOR);
      setState(5442);
      match(MySQLStatementParser::QUERY);
      setState(5443);
      match(MySQLStatementParser::NUMBER_);
    }
    setState(5452);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(5446);
      match(MySQLStatementParser::LIMIT);
      setState(5447);
      match(MySQLStatementParser::NUMBER_);
      setState(5450);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::OFFSET) {
        setState(5448);
        match(MySQLStatementParser::OFFSET);
        setState(5449);
        match(MySQLStatementParser::NUMBER_);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProfilesContext ------------------------------------------------------------------

MySQLStatementParser::ShowProfilesContext::ShowProfilesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowProfilesContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowProfilesContext::PROFILES() {
  return getToken(MySQLStatementParser::PROFILES, 0);
}


size_t MySQLStatementParser::ShowProfilesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowProfiles;
}

void MySQLStatementParser::ShowProfilesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProfiles(this);
}

void MySQLStatementParser::ShowProfilesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProfiles(this);
}


antlrcpp::Any MySQLStatementParser::ShowProfilesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowProfiles(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowProfilesContext* MySQLStatementParser::showProfiles() {
  ShowProfilesContext *_localctx = _tracker.createInstance<ShowProfilesContext>(_ctx, getState());
  enterRule(_localctx, 664, MySQLStatementParser::RuleShowProfiles);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5454);
    match(MySQLStatementParser::SHOW);
    setState(5455);
    match(MySQLStatementParser::PROFILES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowRelaylogEventContext ------------------------------------------------------------------

MySQLStatementParser::ShowRelaylogEventContext::ShowRelaylogEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::RELAYLOG() {
  return getToken(MySQLStatementParser::RELAYLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::EVENTS() {
  return getToken(MySQLStatementParser::EVENTS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::CHANNEL() {
  return getToken(MySQLStatementParser::CHANNEL, 0);
}

MySQLStatementParser::ChannelNameContext* MySQLStatementParser::ShowRelaylogEventContext::channelName() {
  return getRuleContext<MySQLStatementParser::ChannelNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

MySQLStatementParser::LogNameContext* MySQLStatementParser::ShowRelaylogEventContext::logName() {
  return getRuleContext<MySQLStatementParser::LogNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ShowRelaylogEventContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::LIMIT() {
  return getToken(MySQLStatementParser::LIMIT, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowRelaylogEventContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::ShowRelaylogEventContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowRelaylogEvent;
}

void MySQLStatementParser::ShowRelaylogEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowRelaylogEvent(this);
}

void MySQLStatementParser::ShowRelaylogEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowRelaylogEvent(this);
}


antlrcpp::Any MySQLStatementParser::ShowRelaylogEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowRelaylogEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowRelaylogEventContext* MySQLStatementParser::showRelaylogEvent() {
  ShowRelaylogEventContext *_localctx = _tracker.createInstance<ShowRelaylogEventContext>(_ctx, getState());
  enterRule(_localctx, 666, MySQLStatementParser::RuleShowRelaylogEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5457);
    match(MySQLStatementParser::SHOW);
    setState(5458);
    match(MySQLStatementParser::RELAYLOG);
    setState(5459);
    match(MySQLStatementParser::EVENTS);
    setState(5462);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IN) {
      setState(5460);
      match(MySQLStatementParser::IN);
      setState(5461);
      logName();
    }
    setState(5466);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM) {
      setState(5464);
      match(MySQLStatementParser::FROM);
      setState(5465);
      match(MySQLStatementParser::NUMBER_);
    }
    setState(5474);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(5468);
      match(MySQLStatementParser::LIMIT);
      setState(5471);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 703, _ctx)) {
      case 1: {
        setState(5469);
        match(MySQLStatementParser::NUMBER_);
        setState(5470);
        match(MySQLStatementParser::COMMA_);
        break;
      }

      }
      setState(5473);
      match(MySQLStatementParser::NUMBER_);
    }
    setState(5476);
    match(MySQLStatementParser::FOR);
    setState(5477);
    match(MySQLStatementParser::CHANNEL);
    setState(5478);
    channelName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowSlavehostContext ------------------------------------------------------------------

MySQLStatementParser::ShowSlavehostContext::ShowSlavehostContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowSlavehostContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowSlavehostContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowSlavehostContext::HOST() {
  return getToken(MySQLStatementParser::HOST, 0);
}


size_t MySQLStatementParser::ShowSlavehostContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowSlavehost;
}

void MySQLStatementParser::ShowSlavehostContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowSlavehost(this);
}

void MySQLStatementParser::ShowSlavehostContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowSlavehost(this);
}


antlrcpp::Any MySQLStatementParser::ShowSlavehostContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowSlavehost(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowSlavehostContext* MySQLStatementParser::showSlavehost() {
  ShowSlavehostContext *_localctx = _tracker.createInstance<ShowSlavehostContext>(_ctx, getState());
  enterRule(_localctx, 668, MySQLStatementParser::RuleShowSlavehost);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5480);
    match(MySQLStatementParser::SHOW);
    setState(5481);
    match(MySQLStatementParser::SLAVE);
    setState(5482);
    match(MySQLStatementParser::HOST);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowSlaveStatusContext ------------------------------------------------------------------

MySQLStatementParser::ShowSlaveStatusContext::ShowSlaveStatusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowSlaveStatusContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowSlaveStatusContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowSlaveStatusContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowSlaveStatusContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowSlaveStatusContext::CHANNEL() {
  return getToken(MySQLStatementParser::CHANNEL, 0);
}

MySQLStatementParser::ChannelNameContext* MySQLStatementParser::ShowSlaveStatusContext::channelName() {
  return getRuleContext<MySQLStatementParser::ChannelNameContext>(0);
}


size_t MySQLStatementParser::ShowSlaveStatusContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowSlaveStatus;
}

void MySQLStatementParser::ShowSlaveStatusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowSlaveStatus(this);
}

void MySQLStatementParser::ShowSlaveStatusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowSlaveStatus(this);
}


antlrcpp::Any MySQLStatementParser::ShowSlaveStatusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowSlaveStatus(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowSlaveStatusContext* MySQLStatementParser::showSlaveStatus() {
  ShowSlaveStatusContext *_localctx = _tracker.createInstance<ShowSlaveStatusContext>(_ctx, getState());
  enterRule(_localctx, 670, MySQLStatementParser::RuleShowSlaveStatus);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5484);
    match(MySQLStatementParser::SHOW);
    setState(5485);
    match(MySQLStatementParser::SLAVE);
    setState(5486);
    match(MySQLStatementParser::STATUS);
    setState(5490);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(5487);
      match(MySQLStatementParser::FOR);
      setState(5488);
      match(MySQLStatementParser::CHANNEL);
      setState(5489);
      channelName();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowStatusContext ------------------------------------------------------------------

MySQLStatementParser::ShowStatusContext::ShowStatusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowStatusContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowStatusContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowStatusContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowStatusContext::GLOBAL() {
  return getToken(MySQLStatementParser::GLOBAL, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowStatusContext::SESSION() {
  return getToken(MySQLStatementParser::SESSION, 0);
}


size_t MySQLStatementParser::ShowStatusContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowStatus;
}

void MySQLStatementParser::ShowStatusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowStatus(this);
}

void MySQLStatementParser::ShowStatusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowStatus(this);
}


antlrcpp::Any MySQLStatementParser::ShowStatusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowStatus(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowStatusContext* MySQLStatementParser::showStatus() {
  ShowStatusContext *_localctx = _tracker.createInstance<ShowStatusContext>(_ctx, getState());
  enterRule(_localctx, 672, MySQLStatementParser::RuleShowStatus);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5492);
    match(MySQLStatementParser::SHOW);
    setState(5494);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::GLOBAL || _la == MySQLStatementParser::SESSION) {
      setState(5493);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::GLOBAL || _la == MySQLStatementParser::SESSION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5496);
    match(MySQLStatementParser::STATUS);
    setState(5498);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5497);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowTrriggersContext ------------------------------------------------------------------

MySQLStatementParser::ShowTrriggersContext::ShowTrriggersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowTrriggersContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowTrriggersContext::TRIGGER() {
  return getToken(MySQLStatementParser::TRIGGER, 0);
}

MySQLStatementParser::FromSchemaContext* MySQLStatementParser::ShowTrriggersContext::fromSchema() {
  return getRuleContext<MySQLStatementParser::FromSchemaContext>(0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowTrriggersContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}


size_t MySQLStatementParser::ShowTrriggersContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowTrriggers;
}

void MySQLStatementParser::ShowTrriggersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowTrriggers(this);
}

void MySQLStatementParser::ShowTrriggersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowTrriggers(this);
}


antlrcpp::Any MySQLStatementParser::ShowTrriggersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowTrriggers(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowTrriggersContext* MySQLStatementParser::showTrriggers() {
  ShowTrriggersContext *_localctx = _tracker.createInstance<ShowTrriggersContext>(_ctx, getState());
  enterRule(_localctx, 674, MySQLStatementParser::RuleShowTrriggers);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5500);
    match(MySQLStatementParser::SHOW);
    setState(5501);
    match(MySQLStatementParser::TRIGGER);
    setState(5503);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FROM

    || _la == MySQLStatementParser::IN) {
      setState(5502);
      fromSchema();
    }
    setState(5506);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5505);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowVariablesContext ------------------------------------------------------------------

MySQLStatementParser::ShowVariablesContext::ShowVariablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowVariablesContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowVariablesContext::VARIABLES() {
  return getToken(MySQLStatementParser::VARIABLES, 0);
}

MySQLStatementParser::ShowFilterContext* MySQLStatementParser::ShowVariablesContext::showFilter() {
  return getRuleContext<MySQLStatementParser::ShowFilterContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ShowVariablesContext::GLOBAL() {
  return getToken(MySQLStatementParser::GLOBAL, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowVariablesContext::SESSION() {
  return getToken(MySQLStatementParser::SESSION, 0);
}


size_t MySQLStatementParser::ShowVariablesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowVariables;
}

void MySQLStatementParser::ShowVariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowVariables(this);
}

void MySQLStatementParser::ShowVariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowVariables(this);
}


antlrcpp::Any MySQLStatementParser::ShowVariablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowVariables(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowVariablesContext* MySQLStatementParser::showVariables() {
  ShowVariablesContext *_localctx = _tracker.createInstance<ShowVariablesContext>(_ctx, getState());
  enterRule(_localctx, 676, MySQLStatementParser::RuleShowVariables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5508);
    match(MySQLStatementParser::SHOW);
    setState(5510);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::GLOBAL || _la == MySQLStatementParser::SESSION) {
      setState(5509);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::GLOBAL || _la == MySQLStatementParser::SESSION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5512);
    match(MySQLStatementParser::VARIABLES);
    setState(5514);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIKE || _la == MySQLStatementParser::WHERE) {
      setState(5513);
      showFilter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowWarningsContext ------------------------------------------------------------------

MySQLStatementParser::ShowWarningsContext::ShowWarningsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::SHOW() {
  return getToken(MySQLStatementParser::SHOW, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::WARNINGS() {
  return getToken(MySQLStatementParser::WARNINGS, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::COUNT() {
  return getToken(MySQLStatementParser::COUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::LIMIT() {
  return getToken(MySQLStatementParser::LIMIT, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ShowWarningsContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::ShowWarningsContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::ShowWarningsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShowWarnings;
}

void MySQLStatementParser::ShowWarningsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowWarnings(this);
}

void MySQLStatementParser::ShowWarningsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowWarnings(this);
}


antlrcpp::Any MySQLStatementParser::ShowWarningsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShowWarnings(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowWarningsContext* MySQLStatementParser::showWarnings() {
  ShowWarningsContext *_localctx = _tracker.createInstance<ShowWarningsContext>(_ctx, getState());
  enterRule(_localctx, 678, MySQLStatementParser::RuleShowWarnings);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5516);
    match(MySQLStatementParser::SHOW);
    setState(5521);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COUNT) {
      setState(5517);
      match(MySQLStatementParser::COUNT);
      setState(5518);
      match(MySQLStatementParser::LP_);
      setState(5519);
      match(MySQLStatementParser::ASTERISK_);
      setState(5520);
      match(MySQLStatementParser::RP_);
    }
    setState(5523);
    match(MySQLStatementParser::WARNINGS);
    setState(5530);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LIMIT) {
      setState(5524);
      match(MySQLStatementParser::LIMIT);
      setState(5527);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 713, _ctx)) {
      case 1: {
        setState(5525);
        match(MySQLStatementParser::NUMBER_);
        setState(5526);
        match(MySQLStatementParser::COMMA_);
        break;
      }

      }
      setState(5529);
      match(MySQLStatementParser::NUMBER_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetCharacterContext ------------------------------------------------------------------

MySQLStatementParser::SetCharacterContext::SetCharacterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetCharacterContext::SET() {
  return getTokens(MySQLStatementParser::SET);
}

tree::TerminalNode* MySQLStatementParser::SetCharacterContext::SET(size_t i) {
  return getToken(MySQLStatementParser::SET, i);
}

tree::TerminalNode* MySQLStatementParser::SetCharacterContext::CHARACTER() {
  return getToken(MySQLStatementParser::CHARACTER, 0);
}

tree::TerminalNode* MySQLStatementParser::SetCharacterContext::CHARSET() {
  return getToken(MySQLStatementParser::CHARSET, 0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::SetCharacterContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SetCharacterContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}


size_t MySQLStatementParser::SetCharacterContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetCharacter;
}

void MySQLStatementParser::SetCharacterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetCharacter(this);
}

void MySQLStatementParser::SetCharacterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetCharacter(this);
}


antlrcpp::Any MySQLStatementParser::SetCharacterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetCharacter(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetCharacterContext* MySQLStatementParser::setCharacter() {
  SetCharacterContext *_localctx = _tracker.createInstance<SetCharacterContext>(_ctx, getState());
  enterRule(_localctx, 680, MySQLStatementParser::RuleSetCharacter);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5532);
    match(MySQLStatementParser::SET);
    setState(5536);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CHARACTER: {
        setState(5533);
        match(MySQLStatementParser::CHARACTER);
        setState(5534);
        match(MySQLStatementParser::SET);
        break;
      }

      case MySQLStatementParser::CHARSET: {
        setState(5535);
        match(MySQLStatementParser::CHARSET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(5540);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(5538);
        charsetName();
        break;
      }

      case MySQLStatementParser::DEFAULT: {
        setState(5539);
        match(MySQLStatementParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetNameContext ------------------------------------------------------------------

MySQLStatementParser::SetNameContext::SetNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetNameContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::SetNameContext::NAMES() {
  return getToken(MySQLStatementParser::NAMES, 0);
}

tree::TerminalNode* MySQLStatementParser::SetNameContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::SetNameContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::SetNameContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SetNameContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

MySQLStatementParser::CollateClauseContext* MySQLStatementParser::SetNameContext::collateClause() {
  return getRuleContext<MySQLStatementParser::CollateClauseContext>(0);
}


size_t MySQLStatementParser::SetNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetName;
}

void MySQLStatementParser::SetNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetName(this);
}

void MySQLStatementParser::SetNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetName(this);
}


antlrcpp::Any MySQLStatementParser::SetNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetNameContext* MySQLStatementParser::setName() {
  SetNameContext *_localctx = _tracker.createInstance<SetNameContext>(_ctx, getState());
  enterRule(_localctx, 682, MySQLStatementParser::RuleSetName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5542);
    match(MySQLStatementParser::SET);
    setState(5543);
    match(MySQLStatementParser::NAMES);
    setState(5551);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::EQ_: {
        setState(5544);
        match(MySQLStatementParser::EQ_);
        setState(5545);
        expr(0);
        break;
      }

      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(5546);
        charsetName();
        setState(5548);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::COLLATE) {
          setState(5547);
          collateClause();
        }
        break;
      }

      case MySQLStatementParser::DEFAULT: {
        setState(5550);
        match(MySQLStatementParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloneContext ------------------------------------------------------------------

MySQLStatementParser::CloneContext::CloneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CloneContext::CLONE() {
  return getToken(MySQLStatementParser::CLONE, 0);
}

MySQLStatementParser::CloneActionContext* MySQLStatementParser::CloneContext::cloneAction() {
  return getRuleContext<MySQLStatementParser::CloneActionContext>(0);
}


size_t MySQLStatementParser::CloneContext::getRuleIndex() const {
  return MySQLStatementParser::RuleClone;
}

void MySQLStatementParser::CloneContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClone(this);
}

void MySQLStatementParser::CloneContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClone(this);
}


antlrcpp::Any MySQLStatementParser::CloneContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitClone(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CloneContext* MySQLStatementParser::clone() {
  CloneContext *_localctx = _tracker.createInstance<CloneContext>(_ctx, getState());
  enterRule(_localctx, 684, MySQLStatementParser::RuleClone);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5553);
    match(MySQLStatementParser::CLONE);
    setState(5554);
    cloneAction();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloneActionContext ------------------------------------------------------------------

MySQLStatementParser::CloneActionContext::CloneActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::DATA() {
  return getToken(MySQLStatementParser::DATA, 0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::DIRECTORY() {
  return getToken(MySQLStatementParser::DIRECTORY, 0);
}

MySQLStatementParser::CloneDirContext* MySQLStatementParser::CloneActionContext::cloneDir() {
  return getRuleContext<MySQLStatementParser::CloneDirContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::INSTANCE() {
  return getToken(MySQLStatementParser::INSTANCE, 0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::CloneInstanceContext* MySQLStatementParser::CloneActionContext::cloneInstance() {
  return getRuleContext<MySQLStatementParser::CloneInstanceContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::IDENTIFIED() {
  return getToken(MySQLStatementParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::CloneActionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::REQUIRE() {
  return getToken(MySQLStatementParser::REQUIRE, 0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::SSL() {
  return getToken(MySQLStatementParser::SSL, 0);
}

tree::TerminalNode* MySQLStatementParser::CloneActionContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}


size_t MySQLStatementParser::CloneActionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCloneAction;
}

void MySQLStatementParser::CloneActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloneAction(this);
}

void MySQLStatementParser::CloneActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloneAction(this);
}


antlrcpp::Any MySQLStatementParser::CloneActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCloneAction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CloneActionContext* MySQLStatementParser::cloneAction() {
  CloneActionContext *_localctx = _tracker.createInstance<CloneActionContext>(_ctx, getState());
  enterRule(_localctx, 686, MySQLStatementParser::RuleCloneAction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5584);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::LOCAL: {
        enterOuterAlt(_localctx, 1);
        setState(5556);
        match(MySQLStatementParser::LOCAL);
        setState(5557);
        match(MySQLStatementParser::DATA);
        setState(5558);
        match(MySQLStatementParser::DIRECTORY);
        setState(5560);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::EQ_) {
          setState(5559);
          match(MySQLStatementParser::EQ_);
        }
        setState(5562);
        cloneDir();
        break;
      }

      case MySQLStatementParser::INSTANCE: {
        enterOuterAlt(_localctx, 2);
        setState(5563);
        match(MySQLStatementParser::INSTANCE);
        setState(5564);
        match(MySQLStatementParser::FROM);
        setState(5565);
        cloneInstance();
        setState(5566);
        match(MySQLStatementParser::IDENTIFIED);
        setState(5567);
        match(MySQLStatementParser::BY);
        setState(5568);
        string_();
        setState(5575);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::DATA) {
          setState(5569);
          match(MySQLStatementParser::DATA);
          setState(5570);
          match(MySQLStatementParser::DIRECTORY);
          setState(5572);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::EQ_) {
            setState(5571);
            match(MySQLStatementParser::EQ_);
          }
          setState(5574);
          cloneDir();
        }
        setState(5582);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::REQUIRE) {
          setState(5577);
          match(MySQLStatementParser::REQUIRE);
          setState(5579);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::NO) {
            setState(5578);
            match(MySQLStatementParser::NO);
          }
          setState(5581);
          match(MySQLStatementParser::SSL);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUdfContext ------------------------------------------------------------------

MySQLStatementParser::CreateUdfContext::CreateUdfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::FUNCTION() {
  return getToken(MySQLStatementParser::FUNCTION, 0);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::CreateUdfContext::functionName() {
  return getRuleContext<MySQLStatementParser::FunctionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::RETURNS() {
  return getToken(MySQLStatementParser::RETURNS, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::SONAME() {
  return getToken(MySQLStatementParser::SONAME, 0);
}

MySQLStatementParser::ShardLibraryNameContext* MySQLStatementParser::CreateUdfContext::shardLibraryName() {
  return getRuleContext<MySQLStatementParser::ShardLibraryNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::STRING() {
  return getToken(MySQLStatementParser::STRING, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::INTEGER() {
  return getToken(MySQLStatementParser::INTEGER, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::REAL() {
  return getToken(MySQLStatementParser::REAL, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::DECIMAL() {
  return getToken(MySQLStatementParser::DECIMAL, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateUdfContext::AGGREGATE() {
  return getToken(MySQLStatementParser::AGGREGATE, 0);
}


size_t MySQLStatementParser::CreateUdfContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateUdf;
}

void MySQLStatementParser::CreateUdfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUdf(this);
}

void MySQLStatementParser::CreateUdfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUdf(this);
}


antlrcpp::Any MySQLStatementParser::CreateUdfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateUdf(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateUdfContext* MySQLStatementParser::createUdf() {
  CreateUdfContext *_localctx = _tracker.createInstance<CreateUdfContext>(_ctx, getState());
  enterRule(_localctx, 688, MySQLStatementParser::RuleCreateUdf);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5586);
    match(MySQLStatementParser::CREATE);
    setState(5588);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AGGREGATE) {
      setState(5587);
      match(MySQLStatementParser::AGGREGATE);
    }
    setState(5590);
    match(MySQLStatementParser::FUNCTION);
    setState(5591);
    functionName();
    setState(5592);
    match(MySQLStatementParser::RETURNS);
    setState(5593);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DECIMAL || _la == MySQLStatementParser::INTEGER || _la == MySQLStatementParser::REAL || _la == MySQLStatementParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5594);
    match(MySQLStatementParser::SONAME);
    setState(5595);
    shardLibraryName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstallContext ------------------------------------------------------------------

MySQLStatementParser::InstallContext::InstallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::InstallComponentContext* MySQLStatementParser::InstallContext::installComponent() {
  return getRuleContext<MySQLStatementParser::InstallComponentContext>(0);
}

MySQLStatementParser::InstallPluginContext* MySQLStatementParser::InstallContext::installPlugin() {
  return getRuleContext<MySQLStatementParser::InstallPluginContext>(0);
}


size_t MySQLStatementParser::InstallContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInstall;
}

void MySQLStatementParser::InstallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstall(this);
}

void MySQLStatementParser::InstallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstall(this);
}


antlrcpp::Any MySQLStatementParser::InstallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInstall(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InstallContext* MySQLStatementParser::install() {
  InstallContext *_localctx = _tracker.createInstance<InstallContext>(_ctx, getState());
  enterRule(_localctx, 690, MySQLStatementParser::RuleInstall);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5599);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 726, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5597);
      installComponent();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5598);
      installPlugin();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UninstallContext ------------------------------------------------------------------

MySQLStatementParser::UninstallContext::UninstallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::UninstallComponentContext* MySQLStatementParser::UninstallContext::uninstallComponent() {
  return getRuleContext<MySQLStatementParser::UninstallComponentContext>(0);
}

MySQLStatementParser::UninstallPluginContext* MySQLStatementParser::UninstallContext::uninstallPlugin() {
  return getRuleContext<MySQLStatementParser::UninstallPluginContext>(0);
}


size_t MySQLStatementParser::UninstallContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUninstall;
}

void MySQLStatementParser::UninstallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUninstall(this);
}

void MySQLStatementParser::UninstallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUninstall(this);
}


antlrcpp::Any MySQLStatementParser::UninstallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUninstall(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UninstallContext* MySQLStatementParser::uninstall() {
  UninstallContext *_localctx = _tracker.createInstance<UninstallContext>(_ctx, getState());
  enterRule(_localctx, 692, MySQLStatementParser::RuleUninstall);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5603);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 727, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5601);
      uninstallComponent();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5602);
      uninstallPlugin();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstallComponentContext ------------------------------------------------------------------

MySQLStatementParser::InstallComponentContext::InstallComponentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::InstallComponentContext::INSTALL() {
  return getToken(MySQLStatementParser::INSTALL, 0);
}

tree::TerminalNode* MySQLStatementParser::InstallComponentContext::COMPONENT() {
  return getToken(MySQLStatementParser::COMPONENT, 0);
}

std::vector<MySQLStatementParser::ComponentNameContext *> MySQLStatementParser::InstallComponentContext::componentName() {
  return getRuleContexts<MySQLStatementParser::ComponentNameContext>();
}

MySQLStatementParser::ComponentNameContext* MySQLStatementParser::InstallComponentContext::componentName(size_t i) {
  return getRuleContext<MySQLStatementParser::ComponentNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::InstallComponentContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::InstallComponentContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::InstallComponentContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInstallComponent;
}

void MySQLStatementParser::InstallComponentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstallComponent(this);
}

void MySQLStatementParser::InstallComponentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstallComponent(this);
}


antlrcpp::Any MySQLStatementParser::InstallComponentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInstallComponent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InstallComponentContext* MySQLStatementParser::installComponent() {
  InstallComponentContext *_localctx = _tracker.createInstance<InstallComponentContext>(_ctx, getState());
  enterRule(_localctx, 694, MySQLStatementParser::RuleInstallComponent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5605);
    match(MySQLStatementParser::INSTALL);
    setState(5606);
    match(MySQLStatementParser::COMPONENT);
    setState(5607);
    componentName();
    setState(5612);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(5608);
      match(MySQLStatementParser::COMMA_);
      setState(5609);
      componentName();
      setState(5614);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstallPluginContext ------------------------------------------------------------------

MySQLStatementParser::InstallPluginContext::InstallPluginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::InstallPluginContext::INSTALL() {
  return getToken(MySQLStatementParser::INSTALL, 0);
}

tree::TerminalNode* MySQLStatementParser::InstallPluginContext::PLUGIN() {
  return getToken(MySQLStatementParser::PLUGIN, 0);
}

MySQLStatementParser::PluginNameContext* MySQLStatementParser::InstallPluginContext::pluginName() {
  return getRuleContext<MySQLStatementParser::PluginNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::InstallPluginContext::SONAME() {
  return getToken(MySQLStatementParser::SONAME, 0);
}

MySQLStatementParser::ShardLibraryNameContext* MySQLStatementParser::InstallPluginContext::shardLibraryName() {
  return getRuleContext<MySQLStatementParser::ShardLibraryNameContext>(0);
}


size_t MySQLStatementParser::InstallPluginContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInstallPlugin;
}

void MySQLStatementParser::InstallPluginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstallPlugin(this);
}

void MySQLStatementParser::InstallPluginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstallPlugin(this);
}


antlrcpp::Any MySQLStatementParser::InstallPluginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInstallPlugin(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InstallPluginContext* MySQLStatementParser::installPlugin() {
  InstallPluginContext *_localctx = _tracker.createInstance<InstallPluginContext>(_ctx, getState());
  enterRule(_localctx, 696, MySQLStatementParser::RuleInstallPlugin);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5615);
    match(MySQLStatementParser::INSTALL);
    setState(5616);
    match(MySQLStatementParser::PLUGIN);
    setState(5617);
    pluginName();
    setState(5618);
    match(MySQLStatementParser::SONAME);
    setState(5619);
    shardLibraryName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UninstallComponentContext ------------------------------------------------------------------

MySQLStatementParser::UninstallComponentContext::UninstallComponentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UninstallComponentContext::UNINSTALL() {
  return getToken(MySQLStatementParser::UNINSTALL, 0);
}

tree::TerminalNode* MySQLStatementParser::UninstallComponentContext::COMPONENT() {
  return getToken(MySQLStatementParser::COMPONENT, 0);
}

std::vector<MySQLStatementParser::ComponentNameContext *> MySQLStatementParser::UninstallComponentContext::componentName() {
  return getRuleContexts<MySQLStatementParser::ComponentNameContext>();
}

MySQLStatementParser::ComponentNameContext* MySQLStatementParser::UninstallComponentContext::componentName(size_t i) {
  return getRuleContext<MySQLStatementParser::ComponentNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::UninstallComponentContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::UninstallComponentContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::UninstallComponentContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUninstallComponent;
}

void MySQLStatementParser::UninstallComponentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUninstallComponent(this);
}

void MySQLStatementParser::UninstallComponentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUninstallComponent(this);
}


antlrcpp::Any MySQLStatementParser::UninstallComponentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUninstallComponent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UninstallComponentContext* MySQLStatementParser::uninstallComponent() {
  UninstallComponentContext *_localctx = _tracker.createInstance<UninstallComponentContext>(_ctx, getState());
  enterRule(_localctx, 698, MySQLStatementParser::RuleUninstallComponent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5621);
    match(MySQLStatementParser::UNINSTALL);
    setState(5622);
    match(MySQLStatementParser::COMPONENT);
    setState(5623);
    componentName();
    setState(5628);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(5624);
      match(MySQLStatementParser::COMMA_);
      setState(5625);
      componentName();
      setState(5630);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UninstallPluginContext ------------------------------------------------------------------

MySQLStatementParser::UninstallPluginContext::UninstallPluginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UninstallPluginContext::UNINSTALL() {
  return getToken(MySQLStatementParser::UNINSTALL, 0);
}

tree::TerminalNode* MySQLStatementParser::UninstallPluginContext::PLUGIN() {
  return getToken(MySQLStatementParser::PLUGIN, 0);
}

MySQLStatementParser::PluginNameContext* MySQLStatementParser::UninstallPluginContext::pluginName() {
  return getRuleContext<MySQLStatementParser::PluginNameContext>(0);
}


size_t MySQLStatementParser::UninstallPluginContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUninstallPlugin;
}

void MySQLStatementParser::UninstallPluginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUninstallPlugin(this);
}

void MySQLStatementParser::UninstallPluginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUninstallPlugin(this);
}


antlrcpp::Any MySQLStatementParser::UninstallPluginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUninstallPlugin(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UninstallPluginContext* MySQLStatementParser::uninstallPlugin() {
  UninstallPluginContext *_localctx = _tracker.createInstance<UninstallPluginContext>(_ctx, getState());
  enterRule(_localctx, 700, MySQLStatementParser::RuleUninstallPlugin);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5631);
    match(MySQLStatementParser::UNINSTALL);
    setState(5632);
    match(MySQLStatementParser::PLUGIN);
    setState(5633);
    pluginName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnalyzeTableContext ------------------------------------------------------------------

MySQLStatementParser::AnalyzeTableContext::AnalyzeTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AnalyzeTableContext::ANALYZE() {
  return getToken(MySQLStatementParser::ANALYZE, 0);
}

MySQLStatementParser::TableOrTablesContext* MySQLStatementParser::AnalyzeTableContext::tableOrTables() {
  return getRuleContext<MySQLStatementParser::TableOrTablesContext>(0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::AnalyzeTableContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

MySQLStatementParser::HistogramContext* MySQLStatementParser::AnalyzeTableContext::histogram() {
  return getRuleContext<MySQLStatementParser::HistogramContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AnalyzeTableContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySQLStatementParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::AnalyzeTableContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}


size_t MySQLStatementParser::AnalyzeTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAnalyzeTable;
}

void MySQLStatementParser::AnalyzeTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalyzeTable(this);
}

void MySQLStatementParser::AnalyzeTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalyzeTable(this);
}


antlrcpp::Any MySQLStatementParser::AnalyzeTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAnalyzeTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AnalyzeTableContext* MySQLStatementParser::analyzeTable() {
  AnalyzeTableContext *_localctx = _tracker.createInstance<AnalyzeTableContext>(_ctx, getState());
  enterRule(_localctx, 702, MySQLStatementParser::RuleAnalyzeTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5635);
    match(MySQLStatementParser::ANALYZE);
    setState(5637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG) {
      setState(5636);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5639);
    tableOrTables();
    setState(5640);
    tableList();
    setState(5642);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DROP || _la == MySQLStatementParser::UPDATE) {
      setState(5641);
      histogram();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramContext ------------------------------------------------------------------

MySQLStatementParser::HistogramContext::HistogramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HistogramContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

tree::TerminalNode* MySQLStatementParser::HistogramContext::HISTOGRAM() {
  return getToken(MySQLStatementParser::HISTOGRAM, 0);
}

tree::TerminalNode* MySQLStatementParser::HistogramContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::HistogramContext::columnNames() {
  return getRuleContext<MySQLStatementParser::ColumnNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::HistogramContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::HistogramContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::HistogramContext::BUCKETS() {
  return getToken(MySQLStatementParser::BUCKETS, 0);
}

tree::TerminalNode* MySQLStatementParser::HistogramContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}


size_t MySQLStatementParser::HistogramContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHistogram;
}

void MySQLStatementParser::HistogramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHistogram(this);
}

void MySQLStatementParser::HistogramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHistogram(this);
}


antlrcpp::Any MySQLStatementParser::HistogramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHistogram(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HistogramContext* MySQLStatementParser::histogram() {
  HistogramContext *_localctx = _tracker.createInstance<HistogramContext>(_ctx, getState());
  enterRule(_localctx, 704, MySQLStatementParser::RuleHistogram);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5657);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::UPDATE: {
        enterOuterAlt(_localctx, 1);
        setState(5644);
        match(MySQLStatementParser::UPDATE);
        setState(5645);
        match(MySQLStatementParser::HISTOGRAM);
        setState(5646);
        match(MySQLStatementParser::ON);
        setState(5647);
        columnNames();
        setState(5651);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::WITH) {
          setState(5648);
          match(MySQLStatementParser::WITH);
          setState(5649);
          match(MySQLStatementParser::NUMBER_);
          setState(5650);
          match(MySQLStatementParser::BUCKETS);
        }
        break;
      }

      case MySQLStatementParser::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(5653);
        match(MySQLStatementParser::DROP);
        setState(5654);
        match(MySQLStatementParser::HISTOGRAM);
        setState(5655);
        match(MySQLStatementParser::ON);
        setState(5656);
        columnNames();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckTableContext ------------------------------------------------------------------

MySQLStatementParser::CheckTableContext::CheckTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CheckTableContext::CHECK() {
  return getToken(MySQLStatementParser::CHECK, 0);
}

MySQLStatementParser::TableOrTablesContext* MySQLStatementParser::CheckTableContext::tableOrTables() {
  return getRuleContext<MySQLStatementParser::TableOrTablesContext>(0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::CheckTableContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

MySQLStatementParser::CheckTableOptionContext* MySQLStatementParser::CheckTableContext::checkTableOption() {
  return getRuleContext<MySQLStatementParser::CheckTableOptionContext>(0);
}


size_t MySQLStatementParser::CheckTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCheckTable;
}

void MySQLStatementParser::CheckTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckTable(this);
}

void MySQLStatementParser::CheckTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckTable(this);
}


antlrcpp::Any MySQLStatementParser::CheckTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCheckTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CheckTableContext* MySQLStatementParser::checkTable() {
  CheckTableContext *_localctx = _tracker.createInstance<CheckTableContext>(_ctx, getState());
  enterRule(_localctx, 706, MySQLStatementParser::RuleCheckTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5659);
    match(MySQLStatementParser::CHECK);
    setState(5660);
    tableOrTables();
    setState(5661);
    tableList();
    setState(5663);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CHANGE || ((((_la - 202) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 202)) & ((1ULL << (MySQLStatementParser::EXTENDED - 202))
      | (1ULL << (MySQLStatementParser::FAST - 202))
      | (1ULL << (MySQLStatementParser::FOR - 202)))) != 0) || _la == MySQLStatementParser::MEDIUM || _la == MySQLStatementParser::QUICK) {
      setState(5662);
      checkTableOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckTableOptionContext ------------------------------------------------------------------

MySQLStatementParser::CheckTableOptionContext::CheckTableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CheckTableOptionContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTableOptionContext::UPGRADE() {
  return getToken(MySQLStatementParser::UPGRADE, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTableOptionContext::QUICK() {
  return getToken(MySQLStatementParser::QUICK, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTableOptionContext::FAST() {
  return getToken(MySQLStatementParser::FAST, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTableOptionContext::MEDIUM() {
  return getToken(MySQLStatementParser::MEDIUM, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTableOptionContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTableOptionContext::CHANGE() {
  return getToken(MySQLStatementParser::CHANGE, 0);
}


size_t MySQLStatementParser::CheckTableOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCheckTableOption;
}

void MySQLStatementParser::CheckTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckTableOption(this);
}

void MySQLStatementParser::CheckTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckTableOption(this);
}


antlrcpp::Any MySQLStatementParser::CheckTableOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCheckTableOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CheckTableOptionContext* MySQLStatementParser::checkTableOption() {
  CheckTableOptionContext *_localctx = _tracker.createInstance<CheckTableOptionContext>(_ctx, getState());
  enterRule(_localctx, 708, MySQLStatementParser::RuleCheckTableOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5672);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(5665);
        match(MySQLStatementParser::FOR);
        setState(5666);
        match(MySQLStatementParser::UPGRADE);
        break;
      }

      case MySQLStatementParser::QUICK: {
        enterOuterAlt(_localctx, 2);
        setState(5667);
        match(MySQLStatementParser::QUICK);
        break;
      }

      case MySQLStatementParser::FAST: {
        enterOuterAlt(_localctx, 3);
        setState(5668);
        match(MySQLStatementParser::FAST);
        break;
      }

      case MySQLStatementParser::MEDIUM: {
        enterOuterAlt(_localctx, 4);
        setState(5669);
        match(MySQLStatementParser::MEDIUM);
        break;
      }

      case MySQLStatementParser::EXTENDED: {
        enterOuterAlt(_localctx, 5);
        setState(5670);
        match(MySQLStatementParser::EXTENDED);
        break;
      }

      case MySQLStatementParser::CHANGE: {
        enterOuterAlt(_localctx, 6);
        setState(5671);
        match(MySQLStatementParser::CHANGE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChecksumTableContext ------------------------------------------------------------------

MySQLStatementParser::ChecksumTableContext::ChecksumTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ChecksumTableContext::CHECKSUM() {
  return getToken(MySQLStatementParser::CHECKSUM, 0);
}

MySQLStatementParser::TableOrTablesContext* MySQLStatementParser::ChecksumTableContext::tableOrTables() {
  return getRuleContext<MySQLStatementParser::TableOrTablesContext>(0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::ChecksumTableContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ChecksumTableContext::QUICK() {
  return getToken(MySQLStatementParser::QUICK, 0);
}

tree::TerminalNode* MySQLStatementParser::ChecksumTableContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}


size_t MySQLStatementParser::ChecksumTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleChecksumTable;
}

void MySQLStatementParser::ChecksumTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecksumTable(this);
}

void MySQLStatementParser::ChecksumTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecksumTable(this);
}


antlrcpp::Any MySQLStatementParser::ChecksumTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChecksumTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ChecksumTableContext* MySQLStatementParser::checksumTable() {
  ChecksumTableContext *_localctx = _tracker.createInstance<ChecksumTableContext>(_ctx, getState());
  enterRule(_localctx, 710, MySQLStatementParser::RuleChecksumTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5674);
    match(MySQLStatementParser::CHECKSUM);
    setState(5675);
    tableOrTables();
    setState(5676);
    tableList();
    setState(5678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EXTENDED || _la == MySQLStatementParser::QUICK) {
      setState(5677);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::EXTENDED || _la == MySQLStatementParser::QUICK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptimizeTableContext ------------------------------------------------------------------

MySQLStatementParser::OptimizeTableContext::OptimizeTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OptimizeTableContext::OPTIMIZE() {
  return getToken(MySQLStatementParser::OPTIMIZE, 0);
}

MySQLStatementParser::TableOrTablesContext* MySQLStatementParser::OptimizeTableContext::tableOrTables() {
  return getRuleContext<MySQLStatementParser::TableOrTablesContext>(0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::OptimizeTableContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::OptimizeTableContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySQLStatementParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::OptimizeTableContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}


size_t MySQLStatementParser::OptimizeTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOptimizeTable;
}

void MySQLStatementParser::OptimizeTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptimizeTable(this);
}

void MySQLStatementParser::OptimizeTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptimizeTable(this);
}


antlrcpp::Any MySQLStatementParser::OptimizeTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOptimizeTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OptimizeTableContext* MySQLStatementParser::optimizeTable() {
  OptimizeTableContext *_localctx = _tracker.createInstance<OptimizeTableContext>(_ctx, getState());
  enterRule(_localctx, 712, MySQLStatementParser::RuleOptimizeTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5680);
    match(MySQLStatementParser::OPTIMIZE);
    setState(5682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG) {
      setState(5681);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5684);
    tableOrTables();
    setState(5685);
    tableList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepairTableContext ------------------------------------------------------------------

MySQLStatementParser::RepairTableContext::RepairTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RepairTableContext::REPAIR() {
  return getToken(MySQLStatementParser::REPAIR, 0);
}

MySQLStatementParser::TableOrTablesContext* MySQLStatementParser::RepairTableContext::tableOrTables() {
  return getRuleContext<MySQLStatementParser::TableOrTablesContext>(0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::RepairTableContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::RepairTableContext::QUICK() {
  return getToken(MySQLStatementParser::QUICK, 0);
}

tree::TerminalNode* MySQLStatementParser::RepairTableContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

tree::TerminalNode* MySQLStatementParser::RepairTableContext::USE_FRM() {
  return getToken(MySQLStatementParser::USE_FRM, 0);
}

tree::TerminalNode* MySQLStatementParser::RepairTableContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySQLStatementParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::RepairTableContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}


size_t MySQLStatementParser::RepairTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRepairTable;
}

void MySQLStatementParser::RepairTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepairTable(this);
}

void MySQLStatementParser::RepairTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepairTable(this);
}


antlrcpp::Any MySQLStatementParser::RepairTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRepairTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RepairTableContext* MySQLStatementParser::repairTable() {
  RepairTableContext *_localctx = _tracker.createInstance<RepairTableContext>(_ctx, getState());
  enterRule(_localctx, 714, MySQLStatementParser::RuleRepairTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5687);
    match(MySQLStatementParser::REPAIR);
    setState(5689);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG) {
      setState(5688);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5691);
    tableOrTables();
    setState(5692);
    tableList();
    setState(5694);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::QUICK) {
      setState(5693);
      match(MySQLStatementParser::QUICK);
    }
    setState(5697);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EXTENDED) {
      setState(5696);
      match(MySQLStatementParser::EXTENDED);
    }
    setState(5700);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::USE_FRM) {
      setState(5699);
      match(MySQLStatementParser::USE_FRM);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterResourceGroupContext ------------------------------------------------------------------

MySQLStatementParser::AlterResourceGroupContext::AlterResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::ALTER() {
  return getToken(MySQLStatementParser::ALTER, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::RESOURCE() {
  return getToken(MySQLStatementParser::RESOURCE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

MySQLStatementParser::GroupNameContext* MySQLStatementParser::AlterResourceGroupContext::groupName() {
  return getRuleContext<MySQLStatementParser::GroupNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::VCPU() {
  return getToken(MySQLStatementParser::VCPU, 0);
}

std::vector<MySQLStatementParser::VcpuSpecContext *> MySQLStatementParser::AlterResourceGroupContext::vcpuSpec() {
  return getRuleContexts<MySQLStatementParser::VcpuSpecContext>();
}

MySQLStatementParser::VcpuSpecContext* MySQLStatementParser::AlterResourceGroupContext::vcpuSpec(size_t i) {
  return getRuleContext<MySQLStatementParser::VcpuSpecContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::THREAD_PRIORITY() {
  return getToken(MySQLStatementParser::THREAD_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::ENABLE() {
  return getToken(MySQLStatementParser::ENABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::DISABLE() {
  return getToken(MySQLStatementParser::DISABLE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterResourceGroupContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AlterResourceGroupContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::AlterResourceGroupContext::FORCE() {
  return getToken(MySQLStatementParser::FORCE, 0);
}


size_t MySQLStatementParser::AlterResourceGroupContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlterResourceGroup;
}

void MySQLStatementParser::AlterResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterResourceGroup(this);
}

void MySQLStatementParser::AlterResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterResourceGroup(this);
}


antlrcpp::Any MySQLStatementParser::AlterResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlterResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AlterResourceGroupContext* MySQLStatementParser::alterResourceGroup() {
  AlterResourceGroupContext *_localctx = _tracker.createInstance<AlterResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 716, MySQLStatementParser::RuleAlterResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5702);
    match(MySQLStatementParser::ALTER);
    setState(5703);
    match(MySQLStatementParser::RESOURCE);
    setState(5704);
    match(MySQLStatementParser::GROUP);
    setState(5705);
    groupName();
    setState(5718);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::VCPU) {
      setState(5706);
      match(MySQLStatementParser::VCPU);
      setState(5708);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(5707);
        match(MySQLStatementParser::EQ_);
      }
      setState(5710);
      vcpuSpec();
      setState(5715);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5711);
        match(MySQLStatementParser::COMMA_);
        setState(5712);
        vcpuSpec();
        setState(5717);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(5725);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::THREAD_PRIORITY) {
      setState(5720);
      match(MySQLStatementParser::THREAD_PRIORITY);
      setState(5722);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(5721);
        match(MySQLStatementParser::EQ_);
      }
      setState(5724);
      match(MySQLStatementParser::NUMBER_);
    }
    setState(5732);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ENABLE: {
        setState(5727);
        match(MySQLStatementParser::ENABLE);
        break;
      }

      case MySQLStatementParser::DISABLE: {
        setState(5728);
        match(MySQLStatementParser::DISABLE);
        setState(5730);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::FORCE) {
          setState(5729);
          match(MySQLStatementParser::FORCE);
        }
        break;
      }

      case MySQLStatementParser::EOF:
      case MySQLStatementParser::SEMI_: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VcpuSpecContext ------------------------------------------------------------------

MySQLStatementParser::VcpuSpecContext::VcpuSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::VcpuSpecContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::VcpuSpecContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::VcpuSpecContext::MINUS_() {
  return getToken(MySQLStatementParser::MINUS_, 0);
}


size_t MySQLStatementParser::VcpuSpecContext::getRuleIndex() const {
  return MySQLStatementParser::RuleVcpuSpec;
}

void MySQLStatementParser::VcpuSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVcpuSpec(this);
}

void MySQLStatementParser::VcpuSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVcpuSpec(this);
}


antlrcpp::Any MySQLStatementParser::VcpuSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitVcpuSpec(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::VcpuSpecContext* MySQLStatementParser::vcpuSpec() {
  VcpuSpecContext *_localctx = _tracker.createInstance<VcpuSpecContext>(_ctx, getState());
  enterRule(_localctx, 718, MySQLStatementParser::RuleVcpuSpec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5738);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 749, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5734);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5735);
      match(MySQLStatementParser::NUMBER_);
      setState(5736);
      match(MySQLStatementParser::MINUS_);
      setState(5737);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateResourceGroupContext ------------------------------------------------------------------

MySQLStatementParser::CreateResourceGroupContext::CreateResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::CREATE() {
  return getToken(MySQLStatementParser::CREATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::RESOURCE() {
  return getToken(MySQLStatementParser::RESOURCE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

MySQLStatementParser::GroupNameContext* MySQLStatementParser::CreateResourceGroupContext::groupName() {
  return getRuleContext<MySQLStatementParser::GroupNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::TYPE() {
  return getToken(MySQLStatementParser::TYPE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateResourceGroupContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::SYSTEM() {
  return getToken(MySQLStatementParser::SYSTEM, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::VCPU() {
  return getToken(MySQLStatementParser::VCPU, 0);
}

std::vector<MySQLStatementParser::VcpuSpecContext *> MySQLStatementParser::CreateResourceGroupContext::vcpuSpec() {
  return getRuleContexts<MySQLStatementParser::VcpuSpecContext>();
}

MySQLStatementParser::VcpuSpecContext* MySQLStatementParser::CreateResourceGroupContext::vcpuSpec(size_t i) {
  return getRuleContext<MySQLStatementParser::VcpuSpecContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::THREAD_PRIORITY() {
  return getToken(MySQLStatementParser::THREAD_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::ENABLE() {
  return getToken(MySQLStatementParser::ENABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::DISABLE() {
  return getToken(MySQLStatementParser::DISABLE, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CreateResourceGroupContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CreateResourceGroupContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::CreateResourceGroupContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCreateResourceGroup;
}

void MySQLStatementParser::CreateResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateResourceGroup(this);
}

void MySQLStatementParser::CreateResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateResourceGroup(this);
}


antlrcpp::Any MySQLStatementParser::CreateResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCreateResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CreateResourceGroupContext* MySQLStatementParser::createResourceGroup() {
  CreateResourceGroupContext *_localctx = _tracker.createInstance<CreateResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 720, MySQLStatementParser::RuleCreateResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5740);
    match(MySQLStatementParser::CREATE);
    setState(5741);
    match(MySQLStatementParser::RESOURCE);
    setState(5742);
    match(MySQLStatementParser::GROUP);
    setState(5743);
    groupName();
    setState(5744);
    match(MySQLStatementParser::TYPE);
    setState(5745);
    match(MySQLStatementParser::EQ_);
    setState(5746);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::SYSTEM

    || _la == MySQLStatementParser::USER)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5759);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::VCPU) {
      setState(5747);
      match(MySQLStatementParser::VCPU);
      setState(5749);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(5748);
        match(MySQLStatementParser::EQ_);
      }
      setState(5751);
      vcpuSpec();
      setState(5756);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5752);
        match(MySQLStatementParser::COMMA_);
        setState(5753);
        vcpuSpec();
        setState(5758);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(5766);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::THREAD_PRIORITY) {
      setState(5761);
      match(MySQLStatementParser::THREAD_PRIORITY);
      setState(5763);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EQ_) {
        setState(5762);
        match(MySQLStatementParser::EQ_);
      }
      setState(5765);
      match(MySQLStatementParser::NUMBER_);
    }
    setState(5769);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DISABLE

    || _la == MySQLStatementParser::ENABLE) {
      setState(5768);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DISABLE

      || _la == MySQLStatementParser::ENABLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropResourceGroupContext ------------------------------------------------------------------

MySQLStatementParser::DropResourceGroupContext::DropResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DropResourceGroupContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}

tree::TerminalNode* MySQLStatementParser::DropResourceGroupContext::RESOURCE() {
  return getToken(MySQLStatementParser::RESOURCE, 0);
}

tree::TerminalNode* MySQLStatementParser::DropResourceGroupContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

MySQLStatementParser::GroupNameContext* MySQLStatementParser::DropResourceGroupContext::groupName() {
  return getRuleContext<MySQLStatementParser::GroupNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DropResourceGroupContext::FORCE() {
  return getToken(MySQLStatementParser::FORCE, 0);
}


size_t MySQLStatementParser::DropResourceGroupContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDropResourceGroup;
}

void MySQLStatementParser::DropResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropResourceGroup(this);
}

void MySQLStatementParser::DropResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropResourceGroup(this);
}


antlrcpp::Any MySQLStatementParser::DropResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDropResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DropResourceGroupContext* MySQLStatementParser::dropResourceGroup() {
  DropResourceGroupContext *_localctx = _tracker.createInstance<DropResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 722, MySQLStatementParser::RuleDropResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5771);
    match(MySQLStatementParser::DROP);
    setState(5772);
    match(MySQLStatementParser::RESOURCE);
    setState(5773);
    match(MySQLStatementParser::GROUP);
    setState(5774);
    groupName();
    setState(5776);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FORCE) {
      setState(5775);
      match(MySQLStatementParser::FORCE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetResourceGroupContext ------------------------------------------------------------------

MySQLStatementParser::SetResourceGroupContext::SetResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SetResourceGroupContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::SetResourceGroupContext::RESOURCE() {
  return getToken(MySQLStatementParser::RESOURCE, 0);
}

tree::TerminalNode* MySQLStatementParser::SetResourceGroupContext::GROUP() {
  return getToken(MySQLStatementParser::GROUP, 0);
}

MySQLStatementParser::GroupNameContext* MySQLStatementParser::SetResourceGroupContext::groupName() {
  return getRuleContext<MySQLStatementParser::GroupNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SetResourceGroupContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetResourceGroupContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::SetResourceGroupContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SetResourceGroupContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SetResourceGroupContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SetResourceGroupContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetResourceGroup;
}

void MySQLStatementParser::SetResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetResourceGroup(this);
}

void MySQLStatementParser::SetResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetResourceGroup(this);
}


antlrcpp::Any MySQLStatementParser::SetResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetResourceGroupContext* MySQLStatementParser::setResourceGroup() {
  SetResourceGroupContext *_localctx = _tracker.createInstance<SetResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 724, MySQLStatementParser::RuleSetResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5778);
    match(MySQLStatementParser::SET);
    setState(5779);
    match(MySQLStatementParser::RESOURCE);
    setState(5780);
    match(MySQLStatementParser::GROUP);
    setState(5781);
    groupName();
    setState(5791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(5782);
      match(MySQLStatementParser::FOR);
      setState(5783);
      match(MySQLStatementParser::NUMBER_);
      setState(5788);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5784);
        match(MySQLStatementParser::COMMA_);
        setState(5785);
        match(MySQLStatementParser::NUMBER_);
        setState(5790);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinlogContext ------------------------------------------------------------------

MySQLStatementParser::BinlogContext::BinlogContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BinlogContext::BINLOG() {
  return getToken(MySQLStatementParser::BINLOG, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::BinlogContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}


size_t MySQLStatementParser::BinlogContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBinlog;
}

void MySQLStatementParser::BinlogContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinlog(this);
}

void MySQLStatementParser::BinlogContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinlog(this);
}


antlrcpp::Any MySQLStatementParser::BinlogContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBinlog(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BinlogContext* MySQLStatementParser::binlog() {
  BinlogContext *_localctx = _tracker.createInstance<BinlogContext>(_ctx, getState());
  enterRule(_localctx, 726, MySQLStatementParser::RuleBinlog);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5793);
    match(MySQLStatementParser::BINLOG);
    setState(5794);
    stringLiterals();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CacheIndexContext ------------------------------------------------------------------

MySQLStatementParser::CacheIndexContext::CacheIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::CACHE() {
  return getToken(MySQLStatementParser::CACHE, 0);
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

std::vector<MySQLStatementParser::TableIndexListContext *> MySQLStatementParser::CacheIndexContext::tableIndexList() {
  return getRuleContexts<MySQLStatementParser::TableIndexListContext>();
}

MySQLStatementParser::TableIndexListContext* MySQLStatementParser::CacheIndexContext::tableIndexList(size_t i) {
  return getRuleContext<MySQLStatementParser::TableIndexListContext>(i);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::CacheIndexContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::PARTITION() {
  return getToken(MySQLStatementParser::PARTITION, 0);
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::PartitionListContext* MySQLStatementParser::CacheIndexContext::partitionList() {
  return getRuleContext<MySQLStatementParser::PartitionListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CacheIndexContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CacheIndexContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CacheIndexContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::CacheIndexContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCacheIndex;
}

void MySQLStatementParser::CacheIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCacheIndex(this);
}

void MySQLStatementParser::CacheIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCacheIndex(this);
}


antlrcpp::Any MySQLStatementParser::CacheIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCacheIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CacheIndexContext* MySQLStatementParser::cacheIndex() {
  CacheIndexContext *_localctx = _tracker.createInstance<CacheIndexContext>(_ctx, getState());
  enterRule(_localctx, 728, MySQLStatementParser::RuleCacheIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5796);
    match(MySQLStatementParser::CACHE);
    setState(5797);
    match(MySQLStatementParser::INDEX);
    setState(5812);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 760, _ctx)) {
    case 1: {
      setState(5798);
      tableIndexList();
      setState(5803);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5799);
        match(MySQLStatementParser::COMMA_);
        setState(5800);
        tableIndexList();
        setState(5805);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(5806);
      tableName();
      setState(5807);
      match(MySQLStatementParser::PARTITION);
      setState(5808);
      match(MySQLStatementParser::LP_);
      setState(5809);
      partitionList();
      setState(5810);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
    setState(5814);
    match(MySQLStatementParser::IN);
    setState(5817);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(5815);
        identifier();
        break;
      }

      case MySQLStatementParser::DEFAULT: {
        setState(5816);
        match(MySQLStatementParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableIndexListContext ------------------------------------------------------------------

MySQLStatementParser::TableIndexListContext::TableIndexListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::TableIndexListContext::tableName() {
  return getRuleContext<MySQLStatementParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::PARTITION() {
  return getToken(MySQLStatementParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableIndexListContext::LP_() {
  return getTokens(MySQLStatementParser::LP_);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::LP_(size_t i) {
  return getToken(MySQLStatementParser::LP_, i);
}

MySQLStatementParser::PartitionListContext* MySQLStatementParser::TableIndexListContext::partitionList() {
  return getRuleContext<MySQLStatementParser::PartitionListContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableIndexListContext::RP_() {
  return getTokens(MySQLStatementParser::RP_);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::RP_(size_t i) {
  return getToken(MySQLStatementParser::RP_, i);
}

std::vector<MySQLStatementParser::IndexNameContext *> MySQLStatementParser::TableIndexListContext::indexName() {
  return getRuleContexts<MySQLStatementParser::IndexNameContext>();
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::TableIndexListContext::indexName(size_t i) {
  return getRuleContext<MySQLStatementParser::IndexNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::IGNORE() {
  return getToken(MySQLStatementParser::IGNORE, 0);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::LEAVES() {
  return getToken(MySQLStatementParser::LEAVES, 0);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableIndexListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::TableIndexListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::TableIndexListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableIndexList;
}

void MySQLStatementParser::TableIndexListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableIndexList(this);
}

void MySQLStatementParser::TableIndexListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableIndexList(this);
}


antlrcpp::Any MySQLStatementParser::TableIndexListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableIndexList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableIndexListContext* MySQLStatementParser::tableIndexList() {
  TableIndexListContext *_localctx = _tracker.createInstance<TableIndexListContext>(_ctx, getState());
  enterRule(_localctx, 730, MySQLStatementParser::RuleTableIndexList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5819);
    tableName();
    setState(5825);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PARTITION) {
      setState(5820);
      match(MySQLStatementParser::PARTITION);
      setState(5821);
      match(MySQLStatementParser::LP_);
      setState(5822);
      partitionList();
      setState(5823);
      match(MySQLStatementParser::RP_);
    }
    setState(5839);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::INDEX

    || _la == MySQLStatementParser::KEY) {
      setState(5827);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::INDEX

      || _la == MySQLStatementParser::KEY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5828);
      match(MySQLStatementParser::LP_);
      setState(5829);
      indexName();
      setState(5834);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5830);
        match(MySQLStatementParser::COMMA_);
        setState(5831);
        indexName();
        setState(5836);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5837);
      match(MySQLStatementParser::RP_);
    }
    setState(5843);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IGNORE) {
      setState(5841);
      match(MySQLStatementParser::IGNORE);
      setState(5842);
      match(MySQLStatementParser::LEAVES);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionListContext ------------------------------------------------------------------

MySQLStatementParser::PartitionListContext::PartitionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::PartitionNameContext *> MySQLStatementParser::PartitionListContext::partitionName() {
  return getRuleContexts<MySQLStatementParser::PartitionNameContext>();
}

MySQLStatementParser::PartitionNameContext* MySQLStatementParser::PartitionListContext::partitionName(size_t i) {
  return getRuleContext<MySQLStatementParser::PartitionNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PartitionListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::PartitionListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::PartitionListContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}


size_t MySQLStatementParser::PartitionListContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionList;
}

void MySQLStatementParser::PartitionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionList(this);
}

void MySQLStatementParser::PartitionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionList(this);
}


antlrcpp::Any MySQLStatementParser::PartitionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionListContext* MySQLStatementParser::partitionList() {
  PartitionListContext *_localctx = _tracker.createInstance<PartitionListContext>(_ctx, getState());
  enterRule(_localctx, 732, MySQLStatementParser::RulePartitionList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5854);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(5845);
        partitionName();
        setState(5850);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(5846);
          match(MySQLStatementParser::COMMA_);
          setState(5847);
          partitionName();
          setState(5852);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::ALL: {
        enterOuterAlt(_localctx, 2);
        setState(5853);
        match(MySQLStatementParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushContext ------------------------------------------------------------------

MySQLStatementParser::FlushContext::FlushContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FlushContext::FLUSH() {
  return getToken(MySQLStatementParser::FLUSH, 0);
}

std::vector<MySQLStatementParser::FlushOptionContext *> MySQLStatementParser::FlushContext::flushOption() {
  return getRuleContexts<MySQLStatementParser::FlushOptionContext>();
}

MySQLStatementParser::FlushOptionContext* MySQLStatementParser::FlushContext::flushOption(size_t i) {
  return getRuleContext<MySQLStatementParser::FlushOptionContext>(i);
}

MySQLStatementParser::TablesOptionContext* MySQLStatementParser::FlushContext::tablesOption() {
  return getRuleContext<MySQLStatementParser::TablesOptionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FlushContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySQLStatementParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::FlushContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::FlushContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::FlushContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFlush;
}

void MySQLStatementParser::FlushContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlush(this);
}

void MySQLStatementParser::FlushContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlush(this);
}


antlrcpp::Any MySQLStatementParser::FlushContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFlush(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FlushContext* MySQLStatementParser::flush() {
  FlushContext *_localctx = _tracker.createInstance<FlushContext>(_ctx, getState());
  enterRule(_localctx, 734, MySQLStatementParser::RuleFlush);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5856);
    match(MySQLStatementParser::FLUSH);
    setState(5858);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG) {
      setState(5857);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5869);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::OPTIMIZER_COSTS:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::USER_RESOURCES: {
        setState(5860);
        flushOption();
        setState(5865);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(5861);
          match(MySQLStatementParser::COMMA_);
          setState(5862);
          flushOption();
          setState(5867);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::TABLES: {
        setState(5868);
        tablesOption();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushOptionContext ------------------------------------------------------------------

MySQLStatementParser::FlushOptionContext::FlushOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::LOGS() {
  return getToken(MySQLStatementParser::LOGS, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::ERROR() {
  return getToken(MySQLStatementParser::ERROR, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::GENERAL() {
  return getToken(MySQLStatementParser::GENERAL, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::HOSTS() {
  return getToken(MySQLStatementParser::HOSTS, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::PRIVILEGES() {
  return getToken(MySQLStatementParser::PRIVILEGES, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::OPTIMIZER_COSTS() {
  return getToken(MySQLStatementParser::OPTIMIZER_COSTS, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::RELAY() {
  return getToken(MySQLStatementParser::RELAY, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::CHANNEL() {
  return getToken(MySQLStatementParser::CHANNEL, 0);
}

MySQLStatementParser::ChannelNameContext* MySQLStatementParser::FlushOptionContext::channelName() {
  return getRuleContext<MySQLStatementParser::ChannelNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::SLOW() {
  return getToken(MySQLStatementParser::SLOW, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

tree::TerminalNode* MySQLStatementParser::FlushOptionContext::USER_RESOURCES() {
  return getToken(MySQLStatementParser::USER_RESOURCES, 0);
}


size_t MySQLStatementParser::FlushOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFlushOption;
}

void MySQLStatementParser::FlushOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushOption(this);
}

void MySQLStatementParser::FlushOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushOption(this);
}


antlrcpp::Any MySQLStatementParser::FlushOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFlushOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FlushOptionContext* MySQLStatementParser::flushOption() {
  FlushOptionContext *_localctx = _tracker.createInstance<FlushOptionContext>(_ctx, getState());
  enterRule(_localctx, 736, MySQLStatementParser::RuleFlushOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5894);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::BINARY: {
        enterOuterAlt(_localctx, 1);
        setState(5871);
        match(MySQLStatementParser::BINARY);
        setState(5872);
        match(MySQLStatementParser::LOGS);
        break;
      }

      case MySQLStatementParser::ENGINE: {
        enterOuterAlt(_localctx, 2);
        setState(5873);
        match(MySQLStatementParser::ENGINE);
        setState(5874);
        match(MySQLStatementParser::LOGS);
        break;
      }

      case MySQLStatementParser::ERROR: {
        enterOuterAlt(_localctx, 3);
        setState(5875);
        match(MySQLStatementParser::ERROR);
        setState(5876);
        match(MySQLStatementParser::LOGS);
        break;
      }

      case MySQLStatementParser::GENERAL: {
        enterOuterAlt(_localctx, 4);
        setState(5877);
        match(MySQLStatementParser::GENERAL);
        setState(5878);
        match(MySQLStatementParser::LOGS);
        break;
      }

      case MySQLStatementParser::HOSTS: {
        enterOuterAlt(_localctx, 5);
        setState(5879);
        match(MySQLStatementParser::HOSTS);
        break;
      }

      case MySQLStatementParser::LOGS: {
        enterOuterAlt(_localctx, 6);
        setState(5880);
        match(MySQLStatementParser::LOGS);
        break;
      }

      case MySQLStatementParser::PRIVILEGES: {
        enterOuterAlt(_localctx, 7);
        setState(5881);
        match(MySQLStatementParser::PRIVILEGES);
        break;
      }

      case MySQLStatementParser::OPTIMIZER_COSTS: {
        enterOuterAlt(_localctx, 8);
        setState(5882);
        match(MySQLStatementParser::OPTIMIZER_COSTS);
        break;
      }

      case MySQLStatementParser::RELAY: {
        enterOuterAlt(_localctx, 9);
        setState(5883);
        match(MySQLStatementParser::RELAY);
        setState(5884);
        match(MySQLStatementParser::LOGS);
        setState(5888);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::FOR) {
          setState(5885);
          match(MySQLStatementParser::FOR);
          setState(5886);
          match(MySQLStatementParser::CHANNEL);
          setState(5887);
          channelName();
        }
        break;
      }

      case MySQLStatementParser::SLOW: {
        enterOuterAlt(_localctx, 10);
        setState(5890);
        match(MySQLStatementParser::SLOW);
        setState(5891);
        match(MySQLStatementParser::LOGS);
        break;
      }

      case MySQLStatementParser::STATUS: {
        enterOuterAlt(_localctx, 11);
        setState(5892);
        match(MySQLStatementParser::STATUS);
        break;
      }

      case MySQLStatementParser::USER_RESOURCES: {
        enterOuterAlt(_localctx, 12);
        setState(5893);
        match(MySQLStatementParser::USER_RESOURCES);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablesOptionContext ------------------------------------------------------------------

MySQLStatementParser::TablesOptionContext::TablesOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TablesOptionContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}

std::vector<MySQLStatementParser::TableNameContext *> MySQLStatementParser::TablesOptionContext::tableName() {
  return getRuleContexts<MySQLStatementParser::TableNameContext>();
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::TablesOptionContext::tableName(size_t i) {
  return getRuleContext<MySQLStatementParser::TableNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TablesOptionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::TablesOptionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::TablesOptionContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::TablesOptionContext::READ() {
  return getToken(MySQLStatementParser::READ, 0);
}

tree::TerminalNode* MySQLStatementParser::TablesOptionContext::LOCK() {
  return getToken(MySQLStatementParser::LOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::TablesOptionContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::TablesOptionContext::EXPORT() {
  return getToken(MySQLStatementParser::EXPORT, 0);
}


size_t MySQLStatementParser::TablesOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTablesOption;
}

void MySQLStatementParser::TablesOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablesOption(this);
}

void MySQLStatementParser::TablesOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablesOption(this);
}


antlrcpp::Any MySQLStatementParser::TablesOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTablesOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TablesOptionContext* MySQLStatementParser::tablesOption() {
  TablesOptionContext *_localctx = _tracker.createInstance<TablesOptionContext>(_ctx, getState());
  enterRule(_localctx, 738, MySQLStatementParser::RuleTablesOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5935);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 776, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5896);
      match(MySQLStatementParser::TABLES);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5897);
      match(MySQLStatementParser::TABLES);
      setState(5898);
      tableName();
      setState(5903);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5899);
        match(MySQLStatementParser::COMMA_);
        setState(5900);
        tableName();
        setState(5905);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5906);
      match(MySQLStatementParser::TABLES);
      setState(5907);
      match(MySQLStatementParser::WITH);
      setState(5908);
      match(MySQLStatementParser::READ);
      setState(5909);
      match(MySQLStatementParser::LOCK);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5910);
      match(MySQLStatementParser::TABLES);
      setState(5911);
      tableName();
      setState(5916);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5912);
        match(MySQLStatementParser::COMMA_);
        setState(5913);
        tableName();
        setState(5918);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5919);
      match(MySQLStatementParser::WITH);
      setState(5920);
      match(MySQLStatementParser::READ);
      setState(5921);
      match(MySQLStatementParser::LOCK);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5923);
      match(MySQLStatementParser::TABLES);
      setState(5924);
      tableName();
      setState(5929);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5925);
        match(MySQLStatementParser::COMMA_);
        setState(5926);
        tableName();
        setState(5931);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5932);
      match(MySQLStatementParser::FOR);
      setState(5933);
      match(MySQLStatementParser::EXPORT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KillContext ------------------------------------------------------------------

MySQLStatementParser::KillContext::KillContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::KillContext::KILL() {
  return getToken(MySQLStatementParser::KILL, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::KillContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::KillContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::KillContext::CONNECTION() {
  return getToken(MySQLStatementParser::CONNECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::KillContext::QUERY() {
  return getToken(MySQLStatementParser::QUERY, 0);
}


size_t MySQLStatementParser::KillContext::getRuleIndex() const {
  return MySQLStatementParser::RuleKill;
}

void MySQLStatementParser::KillContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKill(this);
}

void MySQLStatementParser::KillContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKill(this);
}


antlrcpp::Any MySQLStatementParser::KillContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitKill(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::KillContext* MySQLStatementParser::kill() {
  KillContext *_localctx = _tracker.createInstance<KillContext>(_ctx, getState());
  enterRule(_localctx, 740, MySQLStatementParser::RuleKill);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5937);
    match(MySQLStatementParser::KILL);
    setState(5939);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::CONNECTION || _la == MySQLStatementParser::QUERY) {
      setState(5938);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::CONNECTION || _la == MySQLStatementParser::QUERY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5942); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(5941);
      match(MySQLStatementParser::NUMBER_);
      setState(5944); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadIndexInfoContext ------------------------------------------------------------------

MySQLStatementParser::LoadIndexInfoContext::LoadIndexInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LoadIndexInfoContext::LOAD() {
  return getToken(MySQLStatementParser::LOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadIndexInfoContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadIndexInfoContext::INTO() {
  return getToken(MySQLStatementParser::INTO, 0);
}

tree::TerminalNode* MySQLStatementParser::LoadIndexInfoContext::CACHE() {
  return getToken(MySQLStatementParser::CACHE, 0);
}

std::vector<MySQLStatementParser::TableIndexListContext *> MySQLStatementParser::LoadIndexInfoContext::tableIndexList() {
  return getRuleContexts<MySQLStatementParser::TableIndexListContext>();
}

MySQLStatementParser::TableIndexListContext* MySQLStatementParser::LoadIndexInfoContext::tableIndexList(size_t i) {
  return getRuleContext<MySQLStatementParser::TableIndexListContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LoadIndexInfoContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::LoadIndexInfoContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::LoadIndexInfoContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLoadIndexInfo;
}

void MySQLStatementParser::LoadIndexInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadIndexInfo(this);
}

void MySQLStatementParser::LoadIndexInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadIndexInfo(this);
}


antlrcpp::Any MySQLStatementParser::LoadIndexInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLoadIndexInfo(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LoadIndexInfoContext* MySQLStatementParser::loadIndexInfo() {
  LoadIndexInfoContext *_localctx = _tracker.createInstance<LoadIndexInfoContext>(_ctx, getState());
  enterRule(_localctx, 742, MySQLStatementParser::RuleLoadIndexInfo);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5946);
    match(MySQLStatementParser::LOAD);
    setState(5947);
    match(MySQLStatementParser::INDEX);
    setState(5948);
    match(MySQLStatementParser::INTO);
    setState(5949);
    match(MySQLStatementParser::CACHE);
    setState(5950);
    tableIndexList();
    setState(5955);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(5951);
      match(MySQLStatementParser::COMMA_);
      setState(5952);
      tableIndexList();
      setState(5957);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetStatementContext ------------------------------------------------------------------

MySQLStatementParser::ResetStatementContext::ResetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ResetStatementContext::RESET() {
  return getToken(MySQLStatementParser::RESET, 0);
}

std::vector<MySQLStatementParser::ResetOptionContext *> MySQLStatementParser::ResetStatementContext::resetOption() {
  return getRuleContexts<MySQLStatementParser::ResetOptionContext>();
}

MySQLStatementParser::ResetOptionContext* MySQLStatementParser::ResetStatementContext::resetOption(size_t i) {
  return getRuleContext<MySQLStatementParser::ResetOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ResetStatementContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ResetStatementContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

MySQLStatementParser::ResetPersistContext* MySQLStatementParser::ResetStatementContext::resetPersist() {
  return getRuleContext<MySQLStatementParser::ResetPersistContext>(0);
}


size_t MySQLStatementParser::ResetStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleResetStatement;
}

void MySQLStatementParser::ResetStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetStatement(this);
}

void MySQLStatementParser::ResetStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetStatement(this);
}


antlrcpp::Any MySQLStatementParser::ResetStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitResetStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ResetStatementContext* MySQLStatementParser::resetStatement() {
  ResetStatementContext *_localctx = _tracker.createInstance<ResetStatementContext>(_ctx, getState());
  enterRule(_localctx, 744, MySQLStatementParser::RuleResetStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5968);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 781, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5958);
      match(MySQLStatementParser::RESET);
      setState(5959);
      resetOption();
      setState(5964);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(5960);
        match(MySQLStatementParser::COMMA_);
        setState(5961);
        resetOption();
        setState(5966);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5967);
      resetPersist();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetOptionContext ------------------------------------------------------------------

MySQLStatementParser::ResetOptionContext::ResetOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ResetOptionContext::MASTER() {
  return getToken(MySQLStatementParser::MASTER, 0);
}

tree::TerminalNode* MySQLStatementParser::ResetOptionContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

MySQLStatementParser::BinaryLogFileIndexNumberContext* MySQLStatementParser::ResetOptionContext::binaryLogFileIndexNumber() {
  return getRuleContext<MySQLStatementParser::BinaryLogFileIndexNumberContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ResetOptionContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

tree::TerminalNode* MySQLStatementParser::ResetOptionContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

MySQLStatementParser::ChannelOptionContext* MySQLStatementParser::ResetOptionContext::channelOption() {
  return getRuleContext<MySQLStatementParser::ChannelOptionContext>(0);
}


size_t MySQLStatementParser::ResetOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleResetOption;
}

void MySQLStatementParser::ResetOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetOption(this);
}

void MySQLStatementParser::ResetOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetOption(this);
}


antlrcpp::Any MySQLStatementParser::ResetOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitResetOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ResetOptionContext* MySQLStatementParser::resetOption() {
  ResetOptionContext *_localctx = _tracker.createInstance<ResetOptionContext>(_ctx, getState());
  enterRule(_localctx, 746, MySQLStatementParser::RuleResetOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5982);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MASTER: {
        enterOuterAlt(_localctx, 1);
        setState(5970);
        match(MySQLStatementParser::MASTER);
        setState(5973);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::TO) {
          setState(5971);
          match(MySQLStatementParser::TO);
          setState(5972);
          binaryLogFileIndexNumber();
        }
        break;
      }

      case MySQLStatementParser::SLAVE: {
        enterOuterAlt(_localctx, 2);
        setState(5975);
        match(MySQLStatementParser::SLAVE);
        setState(5977);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::ALL) {
          setState(5976);
          match(MySQLStatementParser::ALL);
        }
        setState(5980);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::FOR) {
          setState(5979);
          channelOption();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetPersistContext ------------------------------------------------------------------

MySQLStatementParser::ResetPersistContext::ResetPersistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ResetPersistContext::RESET() {
  return getToken(MySQLStatementParser::RESET, 0);
}

tree::TerminalNode* MySQLStatementParser::ResetPersistContext::PERSIST() {
  return getToken(MySQLStatementParser::PERSIST, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ResetPersistContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::ResetPersistContext::existClause() {
  return getRuleContext<MySQLStatementParser::ExistClauseContext>(0);
}


size_t MySQLStatementParser::ResetPersistContext::getRuleIndex() const {
  return MySQLStatementParser::RuleResetPersist;
}

void MySQLStatementParser::ResetPersistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetPersist(this);
}

void MySQLStatementParser::ResetPersistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetPersist(this);
}


antlrcpp::Any MySQLStatementParser::ResetPersistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitResetPersist(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ResetPersistContext* MySQLStatementParser::resetPersist() {
  ResetPersistContext *_localctx = _tracker.createInstance<ResetPersistContext>(_ctx, getState());
  enterRule(_localctx, 748, MySQLStatementParser::RuleResetPersist);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5984);
    match(MySQLStatementParser::RESET);
    setState(5985);
    match(MySQLStatementParser::PERSIST);
    setState(5990);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IF - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(5987);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::IF) {
        setState(5986);
        existClause();
      }
      setState(5989);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestartContext ------------------------------------------------------------------

MySQLStatementParser::RestartContext::RestartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RestartContext::RESTART() {
  return getToken(MySQLStatementParser::RESTART, 0);
}


size_t MySQLStatementParser::RestartContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRestart;
}

void MySQLStatementParser::RestartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestart(this);
}

void MySQLStatementParser::RestartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestart(this);
}


antlrcpp::Any MySQLStatementParser::RestartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRestart(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RestartContext* MySQLStatementParser::restart() {
  RestartContext *_localctx = _tracker.createInstance<RestartContext>(_ctx, getState());
  enterRule(_localctx, 750, MySQLStatementParser::RuleRestart);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5992);
    match(MySQLStatementParser::RESTART);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShutdownContext ------------------------------------------------------------------

MySQLStatementParser::ShutdownContext::ShutdownContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShutdownContext::SHUTDOWN() {
  return getToken(MySQLStatementParser::SHUTDOWN, 0);
}


size_t MySQLStatementParser::ShutdownContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShutdown;
}

void MySQLStatementParser::ShutdownContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShutdown(this);
}

void MySQLStatementParser::ShutdownContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShutdown(this);
}


antlrcpp::Any MySQLStatementParser::ShutdownContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShutdown(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShutdownContext* MySQLStatementParser::shutdown() {
  ShutdownContext *_localctx = _tracker.createInstance<ShutdownContext>(_ctx, getState());
  enterRule(_localctx, 752, MySQLStatementParser::RuleShutdown);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5994);
    match(MySQLStatementParser::SHUTDOWN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainTypeContext ------------------------------------------------------------------

MySQLStatementParser::ExplainTypeContext::ExplainTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ExplainTypeContext::FORMAT() {
  return getToken(MySQLStatementParser::FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::ExplainTypeContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::FormatNameContext* MySQLStatementParser::ExplainTypeContext::formatName() {
  return getRuleContext<MySQLStatementParser::FormatNameContext>(0);
}


size_t MySQLStatementParser::ExplainTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExplainType;
}

void MySQLStatementParser::ExplainTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainType(this);
}

void MySQLStatementParser::ExplainTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainType(this);
}


antlrcpp::Any MySQLStatementParser::ExplainTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExplainType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExplainTypeContext* MySQLStatementParser::explainType() {
  ExplainTypeContext *_localctx = _tracker.createInstance<ExplainTypeContext>(_ctx, getState());
  enterRule(_localctx, 754, MySQLStatementParser::RuleExplainType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5996);
    match(MySQLStatementParser::FORMAT);
    setState(5997);
    match(MySQLStatementParser::EQ_);
    setState(5998);
    formatName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainableStatementContext ------------------------------------------------------------------

MySQLStatementParser::ExplainableStatementContext::ExplainableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SelectContext* MySQLStatementParser::ExplainableStatementContext::select() {
  return getRuleContext<MySQLStatementParser::SelectContext>(0);
}

MySQLStatementParser::Delete_stmtContext* MySQLStatementParser::ExplainableStatementContext::delete_stmt() {
  return getRuleContext<MySQLStatementParser::Delete_stmtContext>(0);
}

MySQLStatementParser::InsertContext* MySQLStatementParser::ExplainableStatementContext::insert() {
  return getRuleContext<MySQLStatementParser::InsertContext>(0);
}

MySQLStatementParser::ReplaceContext* MySQLStatementParser::ExplainableStatementContext::replace() {
  return getRuleContext<MySQLStatementParser::ReplaceContext>(0);
}

MySQLStatementParser::UpdateContext* MySQLStatementParser::ExplainableStatementContext::update() {
  return getRuleContext<MySQLStatementParser::UpdateContext>(0);
}


size_t MySQLStatementParser::ExplainableStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExplainableStatement;
}

void MySQLStatementParser::ExplainableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainableStatement(this);
}

void MySQLStatementParser::ExplainableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainableStatement(this);
}


antlrcpp::Any MySQLStatementParser::ExplainableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExplainableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExplainableStatementContext* MySQLStatementParser::explainableStatement() {
  ExplainableStatementContext *_localctx = _tracker.createInstance<ExplainableStatementContext>(_ctx, getState());
  enterRule(_localctx, 756, MySQLStatementParser::RuleExplainableStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6005);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 788, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6000);
      select();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6001);
      delete_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6002);
      insert();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6003);
      replace();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6004);
      update();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormatNameContext ------------------------------------------------------------------

MySQLStatementParser::FormatNameContext::FormatNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FormatNameContext::TRADITIONAL() {
  return getToken(MySQLStatementParser::TRADITIONAL, 0);
}

tree::TerminalNode* MySQLStatementParser::FormatNameContext::JSON() {
  return getToken(MySQLStatementParser::JSON, 0);
}

tree::TerminalNode* MySQLStatementParser::FormatNameContext::TREE() {
  return getToken(MySQLStatementParser::TREE, 0);
}


size_t MySQLStatementParser::FormatNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFormatName;
}

void MySQLStatementParser::FormatNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormatName(this);
}

void MySQLStatementParser::FormatNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormatName(this);
}


antlrcpp::Any MySQLStatementParser::FormatNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFormatName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FormatNameContext* MySQLStatementParser::formatName() {
  FormatNameContext *_localctx = _tracker.createInstance<FormatNameContext>(_ctx, getState());
  enterRule(_localctx, 758, MySQLStatementParser::RuleFormatName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6007);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::TRADITIONAL

    || _la == MySQLStatementParser::TREE || _la == MySQLStatementParser::JSON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowContext ------------------------------------------------------------------

MySQLStatementParser::ShowContext::ShowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ShowDatabasesContext* MySQLStatementParser::ShowContext::showDatabases() {
  return getRuleContext<MySQLStatementParser::ShowDatabasesContext>(0);
}

MySQLStatementParser::ShowTablesContext* MySQLStatementParser::ShowContext::showTables() {
  return getRuleContext<MySQLStatementParser::ShowTablesContext>(0);
}

MySQLStatementParser::ShowTableStatusContext* MySQLStatementParser::ShowContext::showTableStatus() {
  return getRuleContext<MySQLStatementParser::ShowTableStatusContext>(0);
}

MySQLStatementParser::ShowBinaryLogsContext* MySQLStatementParser::ShowContext::showBinaryLogs() {
  return getRuleContext<MySQLStatementParser::ShowBinaryLogsContext>(0);
}

MySQLStatementParser::ShowColumnsContext* MySQLStatementParser::ShowContext::showColumns() {
  return getRuleContext<MySQLStatementParser::ShowColumnsContext>(0);
}

MySQLStatementParser::ShowIndexContext* MySQLStatementParser::ShowContext::showIndex() {
  return getRuleContext<MySQLStatementParser::ShowIndexContext>(0);
}

MySQLStatementParser::ShowCreateDatabaseContext* MySQLStatementParser::ShowContext::showCreateDatabase() {
  return getRuleContext<MySQLStatementParser::ShowCreateDatabaseContext>(0);
}

MySQLStatementParser::ShowCreateTableContext* MySQLStatementParser::ShowContext::showCreateTable() {
  return getRuleContext<MySQLStatementParser::ShowCreateTableContext>(0);
}

MySQLStatementParser::ShowBinlogEventsContext* MySQLStatementParser::ShowContext::showBinlogEvents() {
  return getRuleContext<MySQLStatementParser::ShowBinlogEventsContext>(0);
}

MySQLStatementParser::ShowCharacterSetContext* MySQLStatementParser::ShowContext::showCharacterSet() {
  return getRuleContext<MySQLStatementParser::ShowCharacterSetContext>(0);
}

MySQLStatementParser::ShowCollationContext* MySQLStatementParser::ShowContext::showCollation() {
  return getRuleContext<MySQLStatementParser::ShowCollationContext>(0);
}

MySQLStatementParser::ShowCreateEventContext* MySQLStatementParser::ShowContext::showCreateEvent() {
  return getRuleContext<MySQLStatementParser::ShowCreateEventContext>(0);
}

MySQLStatementParser::ShowCreateFunctionContext* MySQLStatementParser::ShowContext::showCreateFunction() {
  return getRuleContext<MySQLStatementParser::ShowCreateFunctionContext>(0);
}

MySQLStatementParser::ShowCreateProcedureContext* MySQLStatementParser::ShowContext::showCreateProcedure() {
  return getRuleContext<MySQLStatementParser::ShowCreateProcedureContext>(0);
}

MySQLStatementParser::ShowCreateTriggerContext* MySQLStatementParser::ShowContext::showCreateTrigger() {
  return getRuleContext<MySQLStatementParser::ShowCreateTriggerContext>(0);
}

MySQLStatementParser::ShowCreateUserContext* MySQLStatementParser::ShowContext::showCreateUser() {
  return getRuleContext<MySQLStatementParser::ShowCreateUserContext>(0);
}

MySQLStatementParser::ShowCreateViewContext* MySQLStatementParser::ShowContext::showCreateView() {
  return getRuleContext<MySQLStatementParser::ShowCreateViewContext>(0);
}

MySQLStatementParser::ShowEngineContext* MySQLStatementParser::ShowContext::showEngine() {
  return getRuleContext<MySQLStatementParser::ShowEngineContext>(0);
}

MySQLStatementParser::ShowEnginesContext* MySQLStatementParser::ShowContext::showEngines() {
  return getRuleContext<MySQLStatementParser::ShowEnginesContext>(0);
}

MySQLStatementParser::ShowErrorsContext* MySQLStatementParser::ShowContext::showErrors() {
  return getRuleContext<MySQLStatementParser::ShowErrorsContext>(0);
}

MySQLStatementParser::ShowEventsContext* MySQLStatementParser::ShowContext::showEvents() {
  return getRuleContext<MySQLStatementParser::ShowEventsContext>(0);
}

MySQLStatementParser::ShowFunctionCodeContext* MySQLStatementParser::ShowContext::showFunctionCode() {
  return getRuleContext<MySQLStatementParser::ShowFunctionCodeContext>(0);
}

MySQLStatementParser::ShowFunctionStatusContext* MySQLStatementParser::ShowContext::showFunctionStatus() {
  return getRuleContext<MySQLStatementParser::ShowFunctionStatusContext>(0);
}

MySQLStatementParser::ShowGrantContext* MySQLStatementParser::ShowContext::showGrant() {
  return getRuleContext<MySQLStatementParser::ShowGrantContext>(0);
}

MySQLStatementParser::ShowMasterStatusContext* MySQLStatementParser::ShowContext::showMasterStatus() {
  return getRuleContext<MySQLStatementParser::ShowMasterStatusContext>(0);
}

MySQLStatementParser::ShowPluginsContext* MySQLStatementParser::ShowContext::showPlugins() {
  return getRuleContext<MySQLStatementParser::ShowPluginsContext>(0);
}

MySQLStatementParser::ShowOpenTablesContext* MySQLStatementParser::ShowContext::showOpenTables() {
  return getRuleContext<MySQLStatementParser::ShowOpenTablesContext>(0);
}

MySQLStatementParser::ShowPrivilegesContext* MySQLStatementParser::ShowContext::showPrivileges() {
  return getRuleContext<MySQLStatementParser::ShowPrivilegesContext>(0);
}

MySQLStatementParser::ShowProcedureCodeContext* MySQLStatementParser::ShowContext::showProcedureCode() {
  return getRuleContext<MySQLStatementParser::ShowProcedureCodeContext>(0);
}

MySQLStatementParser::ShowProcesslistContext* MySQLStatementParser::ShowContext::showProcesslist() {
  return getRuleContext<MySQLStatementParser::ShowProcesslistContext>(0);
}

MySQLStatementParser::ShowProfileContext* MySQLStatementParser::ShowContext::showProfile() {
  return getRuleContext<MySQLStatementParser::ShowProfileContext>(0);
}

MySQLStatementParser::ShowProcedureStatusContext* MySQLStatementParser::ShowContext::showProcedureStatus() {
  return getRuleContext<MySQLStatementParser::ShowProcedureStatusContext>(0);
}

MySQLStatementParser::ShowProfilesContext* MySQLStatementParser::ShowContext::showProfiles() {
  return getRuleContext<MySQLStatementParser::ShowProfilesContext>(0);
}

MySQLStatementParser::ShowSlavehostContext* MySQLStatementParser::ShowContext::showSlavehost() {
  return getRuleContext<MySQLStatementParser::ShowSlavehostContext>(0);
}

MySQLStatementParser::ShowSlaveStatusContext* MySQLStatementParser::ShowContext::showSlaveStatus() {
  return getRuleContext<MySQLStatementParser::ShowSlaveStatusContext>(0);
}

MySQLStatementParser::ShowRelaylogEventContext* MySQLStatementParser::ShowContext::showRelaylogEvent() {
  return getRuleContext<MySQLStatementParser::ShowRelaylogEventContext>(0);
}

MySQLStatementParser::ShowStatusContext* MySQLStatementParser::ShowContext::showStatus() {
  return getRuleContext<MySQLStatementParser::ShowStatusContext>(0);
}

MySQLStatementParser::ShowTrriggersContext* MySQLStatementParser::ShowContext::showTrriggers() {
  return getRuleContext<MySQLStatementParser::ShowTrriggersContext>(0);
}

MySQLStatementParser::ShowWarningsContext* MySQLStatementParser::ShowContext::showWarnings() {
  return getRuleContext<MySQLStatementParser::ShowWarningsContext>(0);
}

MySQLStatementParser::ShowVariablesContext* MySQLStatementParser::ShowContext::showVariables() {
  return getRuleContext<MySQLStatementParser::ShowVariablesContext>(0);
}


size_t MySQLStatementParser::ShowContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShow;
}

void MySQLStatementParser::ShowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShow(this);
}

void MySQLStatementParser::ShowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShow(this);
}


antlrcpp::Any MySQLStatementParser::ShowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShow(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShowContext* MySQLStatementParser::show() {
  ShowContext *_localctx = _tracker.createInstance<ShowContext>(_ctx, getState());
  enterRule(_localctx, 760, MySQLStatementParser::RuleShow);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6049);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 789, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6009);
      showDatabases();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6010);
      showTables();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6011);
      showTableStatus();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6012);
      showBinaryLogs();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6013);
      showColumns();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6014);
      showIndex();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6015);
      showCreateDatabase();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6016);
      showCreateTable();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6017);
      showBinlogEvents();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6018);
      showCharacterSet();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6019);
      showCollation();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6020);
      showCreateEvent();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6021);
      showCreateFunction();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(6022);
      showCreateProcedure();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(6023);
      showCreateTrigger();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(6024);
      showCreateUser();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(6025);
      showCreateView();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(6026);
      showEngine();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(6027);
      showEngines();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(6028);
      showErrors();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(6029);
      showEvents();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(6030);
      showFunctionCode();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(6031);
      showFunctionStatus();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(6032);
      showGrant();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(6033);
      showMasterStatus();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(6034);
      showPlugins();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(6035);
      showOpenTables();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(6036);
      showPrivileges();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(6037);
      showProcedureCode();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(6038);
      showProcesslist();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(6039);
      showProfile();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(6040);
      showProcedureStatus();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(6041);
      showProfiles();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(6042);
      showSlavehost();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(6043);
      showSlaveStatus();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(6044);
      showRelaylogEvent();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(6045);
      showStatus();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(6046);
      showTrriggers();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(6047);
      showWarnings();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(6048);
      showVariables();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeContext ------------------------------------------------------------------

MySQLStatementParser::ChangeContext::ChangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ChangeMasterToContext* MySQLStatementParser::ChangeContext::changeMasterTo() {
  return getRuleContext<MySQLStatementParser::ChangeMasterToContext>(0);
}

MySQLStatementParser::ChangeReplicationFilterContext* MySQLStatementParser::ChangeContext::changeReplicationFilter() {
  return getRuleContext<MySQLStatementParser::ChangeReplicationFilterContext>(0);
}


size_t MySQLStatementParser::ChangeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleChange;
}

void MySQLStatementParser::ChangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChange(this);
}

void MySQLStatementParser::ChangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChange(this);
}


antlrcpp::Any MySQLStatementParser::ChangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChange(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ChangeContext* MySQLStatementParser::change() {
  ChangeContext *_localctx = _tracker.createInstance<ChangeContext>(_ctx, getState());
  enterRule(_localctx, 762, MySQLStatementParser::RuleChange);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6053);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 790, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6051);
      changeMasterTo();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6052);
      changeReplicationFilter();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeMasterToContext ------------------------------------------------------------------

MySQLStatementParser::ChangeMasterToContext::ChangeMasterToContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ChangeMasterToContext::CHANGE() {
  return getToken(MySQLStatementParser::CHANGE, 0);
}

tree::TerminalNode* MySQLStatementParser::ChangeMasterToContext::MASTER() {
  return getToken(MySQLStatementParser::MASTER, 0);
}

tree::TerminalNode* MySQLStatementParser::ChangeMasterToContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

MySQLStatementParser::MasterDefsContext* MySQLStatementParser::ChangeMasterToContext::masterDefs() {
  return getRuleContext<MySQLStatementParser::MasterDefsContext>(0);
}

MySQLStatementParser::ChannelOptionContext* MySQLStatementParser::ChangeMasterToContext::channelOption() {
  return getRuleContext<MySQLStatementParser::ChannelOptionContext>(0);
}


size_t MySQLStatementParser::ChangeMasterToContext::getRuleIndex() const {
  return MySQLStatementParser::RuleChangeMasterTo;
}

void MySQLStatementParser::ChangeMasterToContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeMasterTo(this);
}

void MySQLStatementParser::ChangeMasterToContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeMasterTo(this);
}


antlrcpp::Any MySQLStatementParser::ChangeMasterToContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChangeMasterTo(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ChangeMasterToContext* MySQLStatementParser::changeMasterTo() {
  ChangeMasterToContext *_localctx = _tracker.createInstance<ChangeMasterToContext>(_ctx, getState());
  enterRule(_localctx, 764, MySQLStatementParser::RuleChangeMasterTo);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6055);
    match(MySQLStatementParser::CHANGE);
    setState(6056);
    match(MySQLStatementParser::MASTER);
    setState(6057);
    match(MySQLStatementParser::TO);
    setState(6058);
    masterDefs();
    setState(6060);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(6059);
      channelOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationFilterContext ------------------------------------------------------------------

MySQLStatementParser::ChangeReplicationFilterContext::ChangeReplicationFilterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ChangeReplicationFilterContext::CHANGE() {
  return getToken(MySQLStatementParser::CHANGE, 0);
}

tree::TerminalNode* MySQLStatementParser::ChangeReplicationFilterContext::REPLICATION() {
  return getToken(MySQLStatementParser::REPLICATION, 0);
}

tree::TerminalNode* MySQLStatementParser::ChangeReplicationFilterContext::FILTER() {
  return getToken(MySQLStatementParser::FILTER, 0);
}

MySQLStatementParser::FilterDefsContext* MySQLStatementParser::ChangeReplicationFilterContext::filterDefs() {
  return getRuleContext<MySQLStatementParser::FilterDefsContext>(0);
}

MySQLStatementParser::ChannelOptionContext* MySQLStatementParser::ChangeReplicationFilterContext::channelOption() {
  return getRuleContext<MySQLStatementParser::ChannelOptionContext>(0);
}


size_t MySQLStatementParser::ChangeReplicationFilterContext::getRuleIndex() const {
  return MySQLStatementParser::RuleChangeReplicationFilter;
}

void MySQLStatementParser::ChangeReplicationFilterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationFilter(this);
}

void MySQLStatementParser::ChangeReplicationFilterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationFilter(this);
}


antlrcpp::Any MySQLStatementParser::ChangeReplicationFilterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChangeReplicationFilter(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ChangeReplicationFilterContext* MySQLStatementParser::changeReplicationFilter() {
  ChangeReplicationFilterContext *_localctx = _tracker.createInstance<ChangeReplicationFilterContext>(_ctx, getState());
  enterRule(_localctx, 766, MySQLStatementParser::RuleChangeReplicationFilter);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6062);
    match(MySQLStatementParser::CHANGE);
    setState(6063);
    match(MySQLStatementParser::REPLICATION);
    setState(6064);
    match(MySQLStatementParser::FILTER);
    setState(6065);
    filterDefs();
    setState(6067);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(6066);
      channelOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartSlaveContext ------------------------------------------------------------------

MySQLStatementParser::StartSlaveContext::StartSlaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StartSlaveContext::START() {
  return getToken(MySQLStatementParser::START, 0);
}

tree::TerminalNode* MySQLStatementParser::StartSlaveContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

MySQLStatementParser::ConnectionOptionsContext* MySQLStatementParser::StartSlaveContext::connectionOptions() {
  return getRuleContext<MySQLStatementParser::ConnectionOptionsContext>(0);
}

MySQLStatementParser::ThreadTypesContext* MySQLStatementParser::StartSlaveContext::threadTypes() {
  return getRuleContext<MySQLStatementParser::ThreadTypesContext>(0);
}

MySQLStatementParser::UtilOptionContext* MySQLStatementParser::StartSlaveContext::utilOption() {
  return getRuleContext<MySQLStatementParser::UtilOptionContext>(0);
}

MySQLStatementParser::ChannelOptionContext* MySQLStatementParser::StartSlaveContext::channelOption() {
  return getRuleContext<MySQLStatementParser::ChannelOptionContext>(0);
}


size_t MySQLStatementParser::StartSlaveContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStartSlave;
}

void MySQLStatementParser::StartSlaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartSlave(this);
}

void MySQLStatementParser::StartSlaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartSlave(this);
}


antlrcpp::Any MySQLStatementParser::StartSlaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStartSlave(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StartSlaveContext* MySQLStatementParser::startSlave() {
  StartSlaveContext *_localctx = _tracker.createInstance<StartSlaveContext>(_ctx, getState());
  enterRule(_localctx, 768, MySQLStatementParser::RuleStartSlave);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6069);
    match(MySQLStatementParser::START);
    setState(6070);
    match(MySQLStatementParser::SLAVE);
    setState(6072);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IO_THREAD || _la == MySQLStatementParser::SQL_THREAD) {
      setState(6071);
      threadTypes();
    }
    setState(6075);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNTIL) {
      setState(6074);
      utilOption();
    }
    setState(6077);
    connectionOptions();
    setState(6079);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::FOR) {
      setState(6078);
      channelOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopSlaveContext ------------------------------------------------------------------

MySQLStatementParser::StopSlaveContext::StopSlaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StopSlaveContext::STOP() {
  return getToken(MySQLStatementParser::STOP, 0);
}

tree::TerminalNode* MySQLStatementParser::StopSlaveContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

MySQLStatementParser::ThreadTypesContext* MySQLStatementParser::StopSlaveContext::threadTypes() {
  return getRuleContext<MySQLStatementParser::ThreadTypesContext>(0);
}

std::vector<MySQLStatementParser::ChannelOptionContext *> MySQLStatementParser::StopSlaveContext::channelOption() {
  return getRuleContexts<MySQLStatementParser::ChannelOptionContext>();
}

MySQLStatementParser::ChannelOptionContext* MySQLStatementParser::StopSlaveContext::channelOption(size_t i) {
  return getRuleContext<MySQLStatementParser::ChannelOptionContext>(i);
}


size_t MySQLStatementParser::StopSlaveContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStopSlave;
}

void MySQLStatementParser::StopSlaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopSlave(this);
}

void MySQLStatementParser::StopSlaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopSlave(this);
}


antlrcpp::Any MySQLStatementParser::StopSlaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStopSlave(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StopSlaveContext* MySQLStatementParser::stopSlave() {
  StopSlaveContext *_localctx = _tracker.createInstance<StopSlaveContext>(_ctx, getState());
  enterRule(_localctx, 770, MySQLStatementParser::RuleStopSlave);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6081);
    match(MySQLStatementParser::STOP);
    setState(6082);
    match(MySQLStatementParser::SLAVE);
    setState(6083);
    threadTypes();
    setState(6087);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::FOR) {
      setState(6084);
      channelOption();
      setState(6089);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationContext ------------------------------------------------------------------

MySQLStatementParser::GroupReplicationContext::GroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::StartGroupReplicationContext* MySQLStatementParser::GroupReplicationContext::startGroupReplication() {
  return getRuleContext<MySQLStatementParser::StartGroupReplicationContext>(0);
}

MySQLStatementParser::StopGroupReplicationContext* MySQLStatementParser::GroupReplicationContext::stopGroupReplication() {
  return getRuleContext<MySQLStatementParser::StopGroupReplicationContext>(0);
}


size_t MySQLStatementParser::GroupReplicationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGroupReplication;
}

void MySQLStatementParser::GroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplication(this);
}

void MySQLStatementParser::GroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplication(this);
}


antlrcpp::Any MySQLStatementParser::GroupReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGroupReplication(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GroupReplicationContext* MySQLStatementParser::groupReplication() {
  GroupReplicationContext *_localctx = _tracker.createInstance<GroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 772, MySQLStatementParser::RuleGroupReplication);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6092);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::START: {
        enterOuterAlt(_localctx, 1);
        setState(6090);
        startGroupReplication();
        break;
      }

      case MySQLStatementParser::STOP: {
        enterOuterAlt(_localctx, 2);
        setState(6091);
        stopGroupReplication();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartGroupReplicationContext ------------------------------------------------------------------

MySQLStatementParser::StartGroupReplicationContext::StartGroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StartGroupReplicationContext::START() {
  return getToken(MySQLStatementParser::START, 0);
}

tree::TerminalNode* MySQLStatementParser::StartGroupReplicationContext::GROUP_REPLICATION() {
  return getToken(MySQLStatementParser::GROUP_REPLICATION, 0);
}


size_t MySQLStatementParser::StartGroupReplicationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStartGroupReplication;
}

void MySQLStatementParser::StartGroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartGroupReplication(this);
}

void MySQLStatementParser::StartGroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartGroupReplication(this);
}


antlrcpp::Any MySQLStatementParser::StartGroupReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStartGroupReplication(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StartGroupReplicationContext* MySQLStatementParser::startGroupReplication() {
  StartGroupReplicationContext *_localctx = _tracker.createInstance<StartGroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 774, MySQLStatementParser::RuleStartGroupReplication);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6094);
    match(MySQLStatementParser::START);
    setState(6095);
    match(MySQLStatementParser::GROUP_REPLICATION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopGroupReplicationContext ------------------------------------------------------------------

MySQLStatementParser::StopGroupReplicationContext::StopGroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StopGroupReplicationContext::STOP() {
  return getToken(MySQLStatementParser::STOP, 0);
}

tree::TerminalNode* MySQLStatementParser::StopGroupReplicationContext::GROUP_REPLICATION() {
  return getToken(MySQLStatementParser::GROUP_REPLICATION, 0);
}


size_t MySQLStatementParser::StopGroupReplicationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStopGroupReplication;
}

void MySQLStatementParser::StopGroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopGroupReplication(this);
}

void MySQLStatementParser::StopGroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopGroupReplication(this);
}


antlrcpp::Any MySQLStatementParser::StopGroupReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStopGroupReplication(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StopGroupReplicationContext* MySQLStatementParser::stopGroupReplication() {
  StopGroupReplicationContext *_localctx = _tracker.createInstance<StopGroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 776, MySQLStatementParser::RuleStopGroupReplication);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6097);
    match(MySQLStatementParser::STOP);
    setState(6098);
    match(MySQLStatementParser::GROUP_REPLICATION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PurgeBinaryLogContext ------------------------------------------------------------------

MySQLStatementParser::PurgeBinaryLogContext::PurgeBinaryLogContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PurgeBinaryLogContext::PURGE() {
  return getToken(MySQLStatementParser::PURGE, 0);
}

tree::TerminalNode* MySQLStatementParser::PurgeBinaryLogContext::LOGS() {
  return getToken(MySQLStatementParser::LOGS, 0);
}

tree::TerminalNode* MySQLStatementParser::PurgeBinaryLogContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::PurgeBinaryLogContext::MASTER() {
  return getToken(MySQLStatementParser::MASTER, 0);
}

tree::TerminalNode* MySQLStatementParser::PurgeBinaryLogContext::TO() {
  return getToken(MySQLStatementParser::TO, 0);
}

MySQLStatementParser::LogNameContext* MySQLStatementParser::PurgeBinaryLogContext::logName() {
  return getRuleContext<MySQLStatementParser::LogNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PurgeBinaryLogContext::BEFORE() {
  return getToken(MySQLStatementParser::BEFORE, 0);
}

MySQLStatementParser::DatetimeExprContext* MySQLStatementParser::PurgeBinaryLogContext::datetimeExpr() {
  return getRuleContext<MySQLStatementParser::DatetimeExprContext>(0);
}


size_t MySQLStatementParser::PurgeBinaryLogContext::getRuleIndex() const {
  return MySQLStatementParser::RulePurgeBinaryLog;
}

void MySQLStatementParser::PurgeBinaryLogContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPurgeBinaryLog(this);
}

void MySQLStatementParser::PurgeBinaryLogContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPurgeBinaryLog(this);
}


antlrcpp::Any MySQLStatementParser::PurgeBinaryLogContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPurgeBinaryLog(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PurgeBinaryLogContext* MySQLStatementParser::purgeBinaryLog() {
  PurgeBinaryLogContext *_localctx = _tracker.createInstance<PurgeBinaryLogContext>(_ctx, getState());
  enterRule(_localctx, 778, MySQLStatementParser::RulePurgeBinaryLog);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6100);
    match(MySQLStatementParser::PURGE);
    setState(6101);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::BINARY || _la == MySQLStatementParser::MASTER)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6102);
    match(MySQLStatementParser::LOGS);
    setState(6107);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::TO: {
        setState(6103);
        match(MySQLStatementParser::TO);
        setState(6104);
        logName();
        break;
      }

      case MySQLStatementParser::BEFORE: {
        setState(6105);
        match(MySQLStatementParser::BEFORE);
        setState(6106);
        datetimeExpr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThreadTypesContext ------------------------------------------------------------------

MySQLStatementParser::ThreadTypesContext::ThreadTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::ThreadTypeContext *> MySQLStatementParser::ThreadTypesContext::threadType() {
  return getRuleContexts<MySQLStatementParser::ThreadTypeContext>();
}

MySQLStatementParser::ThreadTypeContext* MySQLStatementParser::ThreadTypesContext::threadType(size_t i) {
  return getRuleContext<MySQLStatementParser::ThreadTypeContext>(i);
}


size_t MySQLStatementParser::ThreadTypesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleThreadTypes;
}

void MySQLStatementParser::ThreadTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThreadTypes(this);
}

void MySQLStatementParser::ThreadTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThreadTypes(this);
}


antlrcpp::Any MySQLStatementParser::ThreadTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitThreadTypes(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ThreadTypesContext* MySQLStatementParser::threadTypes() {
  ThreadTypesContext *_localctx = _tracker.createInstance<ThreadTypesContext>(_ctx, getState());
  enterRule(_localctx, 780, MySQLStatementParser::RuleThreadTypes);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6110); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(6109);
      threadType();
      setState(6112); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLStatementParser::IO_THREAD || _la == MySQLStatementParser::SQL_THREAD);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThreadTypeContext ------------------------------------------------------------------

MySQLStatementParser::ThreadTypeContext::ThreadTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ThreadTypeContext::IO_THREAD() {
  return getToken(MySQLStatementParser::IO_THREAD, 0);
}

tree::TerminalNode* MySQLStatementParser::ThreadTypeContext::SQL_THREAD() {
  return getToken(MySQLStatementParser::SQL_THREAD, 0);
}


size_t MySQLStatementParser::ThreadTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleThreadType;
}

void MySQLStatementParser::ThreadTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThreadType(this);
}

void MySQLStatementParser::ThreadTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThreadType(this);
}


antlrcpp::Any MySQLStatementParser::ThreadTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitThreadType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ThreadTypeContext* MySQLStatementParser::threadType() {
  ThreadTypeContext *_localctx = _tracker.createInstance<ThreadTypeContext>(_ctx, getState());
  enterRule(_localctx, 782, MySQLStatementParser::RuleThreadType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6114);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::IO_THREAD || _la == MySQLStatementParser::SQL_THREAD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UtilOptionContext ------------------------------------------------------------------

MySQLStatementParser::UtilOptionContext::UtilOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::UNTIL() {
  return getToken(MySQLStatementParser::UNTIL, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::UtilOptionContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::UtilOptionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::MASTER_LOG_FILE() {
  return getToken(MySQLStatementParser::MASTER_LOG_FILE, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::UtilOptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::MASTER_LOG_POS() {
  return getToken(MySQLStatementParser::MASTER_LOG_POS, 0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::RELAY_LOG_FILE() {
  return getToken(MySQLStatementParser::RELAY_LOG_FILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::RELAY_LOG_POS() {
  return getToken(MySQLStatementParser::RELAY_LOG_POS, 0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::SQL_AFTER_MTS_GAPS() {
  return getToken(MySQLStatementParser::SQL_AFTER_MTS_GAPS, 0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::SQL_BEFORE_GTIDS() {
  return getToken(MySQLStatementParser::SQL_BEFORE_GTIDS, 0);
}

tree::TerminalNode* MySQLStatementParser::UtilOptionContext::SQL_AFTER_GTIDS() {
  return getToken(MySQLStatementParser::SQL_AFTER_GTIDS, 0);
}


size_t MySQLStatementParser::UtilOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUtilOption;
}

void MySQLStatementParser::UtilOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUtilOption(this);
}

void MySQLStatementParser::UtilOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUtilOption(this);
}


antlrcpp::Any MySQLStatementParser::UtilOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUtilOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UtilOptionContext* MySQLStatementParser::utilOption() {
  UtilOptionContext *_localctx = _tracker.createInstance<UtilOptionContext>(_ctx, getState());
  enterRule(_localctx, 784, MySQLStatementParser::RuleUtilOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6116);
    match(MySQLStatementParser::UNTIL);
    setState(6137);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS: {
        setState(6117);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::SQL_AFTER_GTIDS

        || _la == MySQLStatementParser::SQL_BEFORE_GTIDS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6118);
        match(MySQLStatementParser::EQ_);
        setState(6119);
        identifier();
        break;
      }

      case MySQLStatementParser::MASTER_LOG_FILE: {
        setState(6120);
        match(MySQLStatementParser::MASTER_LOG_FILE);
        setState(6121);
        match(MySQLStatementParser::EQ_);
        setState(6122);
        string_();
        setState(6123);
        match(MySQLStatementParser::COMMA_);
        setState(6124);
        match(MySQLStatementParser::MASTER_LOG_POS);
        setState(6125);
        match(MySQLStatementParser::EQ_);
        setState(6126);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::RELAY_LOG_FILE: {
        setState(6128);
        match(MySQLStatementParser::RELAY_LOG_FILE);
        setState(6129);
        match(MySQLStatementParser::EQ_);
        setState(6130);
        string_();
        setState(6131);
        match(MySQLStatementParser::COMMA_);
        setState(6132);
        match(MySQLStatementParser::RELAY_LOG_POS);
        setState(6133);
        match(MySQLStatementParser::EQ_);
        setState(6134);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::SQL_AFTER_MTS_GAPS: {
        setState(6136);
        match(MySQLStatementParser::SQL_AFTER_MTS_GAPS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectionOptionsContext ------------------------------------------------------------------

MySQLStatementParser::ConnectionOptionsContext::ConnectionOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConnectionOptionsContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ConnectionOptionsContext::EQ_() {
  return getTokens(MySQLStatementParser::EQ_);
}

tree::TerminalNode* MySQLStatementParser::ConnectionOptionsContext::EQ_(size_t i) {
  return getToken(MySQLStatementParser::EQ_, i);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::ConnectionOptionsContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::ConnectionOptionsContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::ConnectionOptionsContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::ConnectionOptionsContext::DEFAULT_AUTH() {
  return getToken(MySQLStatementParser::DEFAULT_AUTH, 0);
}

tree::TerminalNode* MySQLStatementParser::ConnectionOptionsContext::PLUGIN_DIR() {
  return getToken(MySQLStatementParser::PLUGIN_DIR, 0);
}


size_t MySQLStatementParser::ConnectionOptionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConnectionOptions;
}

void MySQLStatementParser::ConnectionOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnectionOptions(this);
}

void MySQLStatementParser::ConnectionOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnectionOptions(this);
}


antlrcpp::Any MySQLStatementParser::ConnectionOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConnectionOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConnectionOptionsContext* MySQLStatementParser::connectionOptions() {
  ConnectionOptionsContext *_localctx = _tracker.createInstance<ConnectionOptionsContext>(_ctx, getState());
  enterRule(_localctx, 786, MySQLStatementParser::RuleConnectionOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6142);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::USER) {
      setState(6139);
      match(MySQLStatementParser::USER);
      setState(6140);
      match(MySQLStatementParser::EQ_);
      setState(6141);
      string_();
    }
    setState(6147);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PASSWORD) {
      setState(6144);
      match(MySQLStatementParser::PASSWORD);
      setState(6145);
      match(MySQLStatementParser::EQ_);
      setState(6146);
      string_();
    }
    setState(6152);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFAULT_AUTH) {
      setState(6149);
      match(MySQLStatementParser::DEFAULT_AUTH);
      setState(6150);
      match(MySQLStatementParser::EQ_);
      setState(6151);
      string_();
    }
    setState(6157);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PLUGIN_DIR) {
      setState(6154);
      match(MySQLStatementParser::PLUGIN_DIR);
      setState(6155);
      match(MySQLStatementParser::EQ_);
      setState(6156);
      string_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterDefsContext ------------------------------------------------------------------

MySQLStatementParser::MasterDefsContext::MasterDefsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::MasterDefContext *> MySQLStatementParser::MasterDefsContext::masterDef() {
  return getRuleContexts<MySQLStatementParser::MasterDefContext>();
}

MySQLStatementParser::MasterDefContext* MySQLStatementParser::MasterDefsContext::masterDef(size_t i) {
  return getRuleContext<MySQLStatementParser::MasterDefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::MasterDefsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::MasterDefsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::MasterDefsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleMasterDefs;
}

void MySQLStatementParser::MasterDefsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterDefs(this);
}

void MySQLStatementParser::MasterDefsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterDefs(this);
}


antlrcpp::Any MySQLStatementParser::MasterDefsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitMasterDefs(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::MasterDefsContext* MySQLStatementParser::masterDefs() {
  MasterDefsContext *_localctx = _tracker.createInstance<MasterDefsContext>(_ctx, getState());
  enterRule(_localctx, 788, MySQLStatementParser::RuleMasterDefs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6159);
    masterDef();
    setState(6164);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6160);
      match(MySQLStatementParser::COMMA_);
      setState(6161);
      masterDef();
      setState(6166);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterDefContext ------------------------------------------------------------------

MySQLStatementParser::MasterDefContext::MasterDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_BIND() {
  return getToken(MySQLStatementParser::MASTER_BIND, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::MasterDefContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_HOST() {
  return getToken(MySQLStatementParser::MASTER_HOST, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_USER() {
  return getToken(MySQLStatementParser::MASTER_USER, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_PASSWORD() {
  return getToken(MySQLStatementParser::MASTER_PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_PORT() {
  return getToken(MySQLStatementParser::MASTER_PORT, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::PRIVILEGE_CHECKS_USER() {
  return getToken(MySQLStatementParser::PRIVILEGE_CHECKS_USER, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::ACCOUNT() {
  return getToken(MySQLStatementParser::ACCOUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::NULL() {
  return getToken(MySQLStatementParser::NULL, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::REQUIRE_ROW_FORMAT() {
  return getToken(MySQLStatementParser::REQUIRE_ROW_FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_CONNECT_RETRY() {
  return getToken(MySQLStatementParser::MASTER_CONNECT_RETRY, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_RETRY_COUNT() {
  return getToken(MySQLStatementParser::MASTER_RETRY_COUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_DELAY() {
  return getToken(MySQLStatementParser::MASTER_DELAY, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_HEARTBEAT_PERIOD() {
  return getToken(MySQLStatementParser::MASTER_HEARTBEAT_PERIOD, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_LOG_FILE() {
  return getToken(MySQLStatementParser::MASTER_LOG_FILE, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_LOG_POS() {
  return getToken(MySQLStatementParser::MASTER_LOG_POS, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_AUTO_POSITION() {
  return getToken(MySQLStatementParser::MASTER_AUTO_POSITION, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::RELAY_LOG_FILE() {
  return getToken(MySQLStatementParser::RELAY_LOG_FILE, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::RELAY_LOG_POS() {
  return getToken(MySQLStatementParser::RELAY_LOG_POS, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_COMPRESSION_ALGORITHMS() {
  return getToken(MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_ZSTD_COMPRESSION_LEVEL() {
  return getToken(MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL() {
  return getToken(MySQLStatementParser::MASTER_SSL, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_CA() {
  return getToken(MySQLStatementParser::MASTER_SSL_CA, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_CAPATH() {
  return getToken(MySQLStatementParser::MASTER_SSL_CAPATH, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_CERT() {
  return getToken(MySQLStatementParser::MASTER_SSL_CERT, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_CRL() {
  return getToken(MySQLStatementParser::MASTER_SSL_CRL, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_CRLPATH() {
  return getToken(MySQLStatementParser::MASTER_SSL_CRLPATH, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_KEY() {
  return getToken(MySQLStatementParser::MASTER_SSL_KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_CIPHER() {
  return getToken(MySQLStatementParser::MASTER_SSL_CIPHER, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_SSL_VERIFY_SERVER_CERT() {
  return getToken(MySQLStatementParser::MASTER_SSL_VERIFY_SERVER_CERT, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_TLS_VERSION() {
  return getToken(MySQLStatementParser::MASTER_TLS_VERSION, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_TLS_CIPHERSUITES() {
  return getToken(MySQLStatementParser::MASTER_TLS_CIPHERSUITES, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::MASTER_PUBLIC_KEY_PATH() {
  return getToken(MySQLStatementParser::MASTER_PUBLIC_KEY_PATH, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::GET_MASTER_PUBLIC_KEY() {
  return getToken(MySQLStatementParser::GET_MASTER_PUBLIC_KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::IGNORE_SERVER_IDS() {
  return getToken(MySQLStatementParser::IGNORE_SERVER_IDS, 0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::IgnoreServerIdsContext* MySQLStatementParser::MasterDefContext::ignoreServerIds() {
  return getRuleContext<MySQLStatementParser::IgnoreServerIdsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::MasterDefContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::MasterDefContext::getRuleIndex() const {
  return MySQLStatementParser::RuleMasterDef;
}

void MySQLStatementParser::MasterDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterDef(this);
}

void MySQLStatementParser::MasterDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterDef(this);
}


antlrcpp::Any MySQLStatementParser::MasterDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitMasterDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::MasterDefContext* MySQLStatementParser::masterDef() {
  MasterDefContext *_localctx = _tracker.createInstance<MasterDefContext>(_ctx, getState());
  enterRule(_localctx, 790, MySQLStatementParser::RuleMasterDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6266);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MASTER_BIND: {
        enterOuterAlt(_localctx, 1);
        setState(6167);
        match(MySQLStatementParser::MASTER_BIND);
        setState(6168);
        match(MySQLStatementParser::EQ_);
        setState(6169);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_HOST: {
        enterOuterAlt(_localctx, 2);
        setState(6170);
        match(MySQLStatementParser::MASTER_HOST);
        setState(6171);
        match(MySQLStatementParser::EQ_);
        setState(6172);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_USER: {
        enterOuterAlt(_localctx, 3);
        setState(6173);
        match(MySQLStatementParser::MASTER_USER);
        setState(6174);
        match(MySQLStatementParser::EQ_);
        setState(6175);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_PASSWORD: {
        enterOuterAlt(_localctx, 4);
        setState(6176);
        match(MySQLStatementParser::MASTER_PASSWORD);
        setState(6177);
        match(MySQLStatementParser::EQ_);
        setState(6178);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_PORT: {
        enterOuterAlt(_localctx, 5);
        setState(6179);
        match(MySQLStatementParser::MASTER_PORT);
        setState(6180);
        match(MySQLStatementParser::EQ_);
        setState(6181);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::PRIVILEGE_CHECKS_USER: {
        enterOuterAlt(_localctx, 6);
        setState(6182);
        match(MySQLStatementParser::PRIVILEGE_CHECKS_USER);
        setState(6183);
        match(MySQLStatementParser::EQ_);
        setState(6184);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::ACCOUNT || _la == MySQLStatementParser::NULL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLStatementParser::REQUIRE_ROW_FORMAT: {
        enterOuterAlt(_localctx, 7);
        setState(6185);
        match(MySQLStatementParser::REQUIRE_ROW_FORMAT);
        setState(6186);
        match(MySQLStatementParser::EQ_);
        setState(6187);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_CONNECT_RETRY: {
        enterOuterAlt(_localctx, 8);
        setState(6188);
        match(MySQLStatementParser::MASTER_CONNECT_RETRY);
        setState(6189);
        match(MySQLStatementParser::EQ_);
        setState(6190);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_RETRY_COUNT: {
        enterOuterAlt(_localctx, 9);
        setState(6191);
        match(MySQLStatementParser::MASTER_RETRY_COUNT);
        setState(6192);
        match(MySQLStatementParser::EQ_);
        setState(6193);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_DELAY: {
        enterOuterAlt(_localctx, 10);
        setState(6194);
        match(MySQLStatementParser::MASTER_DELAY);
        setState(6195);
        match(MySQLStatementParser::EQ_);
        setState(6196);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD: {
        enterOuterAlt(_localctx, 11);
        setState(6197);
        match(MySQLStatementParser::MASTER_HEARTBEAT_PERIOD);
        setState(6198);
        match(MySQLStatementParser::EQ_);
        setState(6199);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_LOG_FILE: {
        enterOuterAlt(_localctx, 12);
        setState(6200);
        match(MySQLStatementParser::MASTER_LOG_FILE);
        setState(6201);
        match(MySQLStatementParser::EQ_);
        setState(6202);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_LOG_POS: {
        enterOuterAlt(_localctx, 13);
        setState(6203);
        match(MySQLStatementParser::MASTER_LOG_POS);
        setState(6204);
        match(MySQLStatementParser::EQ_);
        setState(6205);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_AUTO_POSITION: {
        enterOuterAlt(_localctx, 14);
        setState(6206);
        match(MySQLStatementParser::MASTER_AUTO_POSITION);
        setState(6207);
        match(MySQLStatementParser::EQ_);
        setState(6208);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::RELAY_LOG_FILE: {
        enterOuterAlt(_localctx, 15);
        setState(6209);
        match(MySQLStatementParser::RELAY_LOG_FILE);
        setState(6210);
        match(MySQLStatementParser::EQ_);
        setState(6211);
        string_();
        break;
      }

      case MySQLStatementParser::RELAY_LOG_POS: {
        enterOuterAlt(_localctx, 16);
        setState(6212);
        match(MySQLStatementParser::RELAY_LOG_POS);
        setState(6213);
        match(MySQLStatementParser::EQ_);
        setState(6214);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS: {
        enterOuterAlt(_localctx, 17);
        setState(6215);
        match(MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS);
        setState(6216);
        match(MySQLStatementParser::EQ_);
        setState(6217);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL: {
        enterOuterAlt(_localctx, 18);
        setState(6218);
        match(MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL);
        setState(6219);
        match(MySQLStatementParser::EQ_);
        setState(6220);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_SSL: {
        enterOuterAlt(_localctx, 19);
        setState(6221);
        match(MySQLStatementParser::MASTER_SSL);
        setState(6222);
        match(MySQLStatementParser::EQ_);
        setState(6223);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_SSL_CA: {
        enterOuterAlt(_localctx, 20);
        setState(6224);
        match(MySQLStatementParser::MASTER_SSL_CA);
        setState(6225);
        match(MySQLStatementParser::EQ_);
        setState(6226);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_SSL_CAPATH: {
        enterOuterAlt(_localctx, 21);
        setState(6227);
        match(MySQLStatementParser::MASTER_SSL_CAPATH);
        setState(6228);
        match(MySQLStatementParser::EQ_);
        setState(6229);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_SSL_CERT: {
        enterOuterAlt(_localctx, 22);
        setState(6230);
        match(MySQLStatementParser::MASTER_SSL_CERT);
        setState(6231);
        match(MySQLStatementParser::EQ_);
        setState(6232);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_SSL_CRL: {
        enterOuterAlt(_localctx, 23);
        setState(6233);
        match(MySQLStatementParser::MASTER_SSL_CRL);
        setState(6234);
        match(MySQLStatementParser::EQ_);
        setState(6235);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_SSL_CRLPATH: {
        enterOuterAlt(_localctx, 24);
        setState(6236);
        match(MySQLStatementParser::MASTER_SSL_CRLPATH);
        setState(6237);
        match(MySQLStatementParser::EQ_);
        setState(6238);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_SSL_KEY: {
        enterOuterAlt(_localctx, 25);
        setState(6239);
        match(MySQLStatementParser::MASTER_SSL_KEY);
        setState(6240);
        match(MySQLStatementParser::EQ_);
        setState(6241);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_SSL_CIPHER: {
        enterOuterAlt(_localctx, 26);
        setState(6242);
        match(MySQLStatementParser::MASTER_SSL_CIPHER);
        setState(6243);
        match(MySQLStatementParser::EQ_);
        setState(6244);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_SSL_VERIFY_SERVER_CERT: {
        enterOuterAlt(_localctx, 27);
        setState(6245);
        match(MySQLStatementParser::MASTER_SSL_VERIFY_SERVER_CERT);
        setState(6246);
        match(MySQLStatementParser::EQ_);
        setState(6247);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::MASTER_TLS_VERSION: {
        enterOuterAlt(_localctx, 28);
        setState(6248);
        match(MySQLStatementParser::MASTER_TLS_VERSION);
        setState(6249);
        match(MySQLStatementParser::EQ_);
        setState(6250);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES: {
        enterOuterAlt(_localctx, 29);
        setState(6251);
        match(MySQLStatementParser::MASTER_TLS_CIPHERSUITES);
        setState(6252);
        match(MySQLStatementParser::EQ_);
        setState(6253);
        string_();
        break;
      }

      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH: {
        enterOuterAlt(_localctx, 30);
        setState(6254);
        match(MySQLStatementParser::MASTER_PUBLIC_KEY_PATH);
        setState(6255);
        match(MySQLStatementParser::EQ_);
        setState(6256);
        string_();
        break;
      }

      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY: {
        enterOuterAlt(_localctx, 31);
        setState(6257);
        match(MySQLStatementParser::GET_MASTER_PUBLIC_KEY);
        setState(6258);
        match(MySQLStatementParser::EQ_);
        setState(6259);
        match(MySQLStatementParser::NUMBER_);
        break;
      }

      case MySQLStatementParser::IGNORE_SERVER_IDS: {
        enterOuterAlt(_localctx, 32);
        setState(6260);
        match(MySQLStatementParser::IGNORE_SERVER_IDS);
        setState(6261);
        match(MySQLStatementParser::EQ_);
        setState(6262);
        match(MySQLStatementParser::LP_);
        setState(6263);
        ignoreServerIds();
        setState(6264);
        match(MySQLStatementParser::RP_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IgnoreServerIdsContext ------------------------------------------------------------------

MySQLStatementParser::IgnoreServerIdsContext::IgnoreServerIdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IgnoreServerIdContext *> MySQLStatementParser::IgnoreServerIdsContext::ignoreServerId() {
  return getRuleContexts<MySQLStatementParser::IgnoreServerIdContext>();
}

MySQLStatementParser::IgnoreServerIdContext* MySQLStatementParser::IgnoreServerIdsContext::ignoreServerId(size_t i) {
  return getRuleContext<MySQLStatementParser::IgnoreServerIdContext>(i);
}

tree::TerminalNode* MySQLStatementParser::IgnoreServerIdsContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}


size_t MySQLStatementParser::IgnoreServerIdsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIgnoreServerIds;
}

void MySQLStatementParser::IgnoreServerIdsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIgnoreServerIds(this);
}

void MySQLStatementParser::IgnoreServerIdsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIgnoreServerIds(this);
}


antlrcpp::Any MySQLStatementParser::IgnoreServerIdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIgnoreServerIds(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IgnoreServerIdsContext* MySQLStatementParser::ignoreServerIds() {
  IgnoreServerIdsContext *_localctx = _tracker.createInstance<IgnoreServerIdsContext>(_ctx, getState());
  enterRule(_localctx, 792, MySQLStatementParser::RuleIgnoreServerIds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6268);
    ignoreServerId();

    setState(6269);
    match(MySQLStatementParser::COMMA_);
    setState(6270);
    ignoreServerId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IgnoreServerIdContext ------------------------------------------------------------------

MySQLStatementParser::IgnoreServerIdContext::IgnoreServerIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IgnoreServerIdContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::IgnoreServerIdContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIgnoreServerId;
}

void MySQLStatementParser::IgnoreServerIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIgnoreServerId(this);
}

void MySQLStatementParser::IgnoreServerIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIgnoreServerId(this);
}


antlrcpp::Any MySQLStatementParser::IgnoreServerIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIgnoreServerId(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IgnoreServerIdContext* MySQLStatementParser::ignoreServerId() {
  IgnoreServerIdContext *_localctx = _tracker.createInstance<IgnoreServerIdContext>(_ctx, getState());
  enterRule(_localctx, 794, MySQLStatementParser::RuleIgnoreServerId);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6272);
    match(MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDefsContext ------------------------------------------------------------------

MySQLStatementParser::FilterDefsContext::FilterDefsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::FilterDefContext *> MySQLStatementParser::FilterDefsContext::filterDef() {
  return getRuleContexts<MySQLStatementParser::FilterDefContext>();
}

MySQLStatementParser::FilterDefContext* MySQLStatementParser::FilterDefsContext::filterDef(size_t i) {
  return getRuleContext<MySQLStatementParser::FilterDefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::FilterDefsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::FilterDefsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::FilterDefsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFilterDefs;
}

void MySQLStatementParser::FilterDefsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDefs(this);
}

void MySQLStatementParser::FilterDefsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDefs(this);
}


antlrcpp::Any MySQLStatementParser::FilterDefsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFilterDefs(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FilterDefsContext* MySQLStatementParser::filterDefs() {
  FilterDefsContext *_localctx = _tracker.createInstance<FilterDefsContext>(_ctx, getState());
  enterRule(_localctx, 796, MySQLStatementParser::RuleFilterDefs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6274);
    filterDef();
    setState(6279);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6275);
      match(MySQLStatementParser::COMMA_);
      setState(6276);
      filterDef();
      setState(6281);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDefContext ------------------------------------------------------------------

MySQLStatementParser::FilterDefContext::FilterDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::REPLICATE_DO_DB() {
  return getToken(MySQLStatementParser::REPLICATE_DO_DB, 0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::SchemaNamesContext* MySQLStatementParser::FilterDefContext::schemaNames() {
  return getRuleContext<MySQLStatementParser::SchemaNamesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::REPLICATE_IGNORE_DB() {
  return getToken(MySQLStatementParser::REPLICATE_IGNORE_DB, 0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::REPLICATE_DO_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_DO_TABLE, 0);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::FilterDefContext::tableList() {
  return getRuleContext<MySQLStatementParser::TableListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::REPLICATE_IGNORE_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::REPLICATE_WILD_DO_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_WILD_DO_TABLE, 0);
}

MySQLStatementParser::WildTablesContext* MySQLStatementParser::FilterDefContext::wildTables() {
  return getRuleContext<MySQLStatementParser::WildTablesContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::REPLICATE_WILD_IGNORE_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::FilterDefContext::REPLICATE_REWRITE_DB() {
  return getToken(MySQLStatementParser::REPLICATE_REWRITE_DB, 0);
}

MySQLStatementParser::SchemaPairsContext* MySQLStatementParser::FilterDefContext::schemaPairs() {
  return getRuleContext<MySQLStatementParser::SchemaPairsContext>(0);
}


size_t MySQLStatementParser::FilterDefContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFilterDef;
}

void MySQLStatementParser::FilterDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDef(this);
}

void MySQLStatementParser::FilterDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDef(this);
}


antlrcpp::Any MySQLStatementParser::FilterDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFilterDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FilterDefContext* MySQLStatementParser::filterDef() {
  FilterDefContext *_localctx = _tracker.createInstance<FilterDefContext>(_ctx, getState());
  enterRule(_localctx, 798, MySQLStatementParser::RuleFilterDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6331);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::REPLICATE_DO_DB: {
        enterOuterAlt(_localctx, 1);
        setState(6282);
        match(MySQLStatementParser::REPLICATE_DO_DB);
        setState(6283);
        match(MySQLStatementParser::EQ_);
        setState(6284);
        match(MySQLStatementParser::LP_);
        setState(6286);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
          | (1ULL << MySQLStatementParser::MIN)
          | (1ULL << MySQLStatementParser::SUM)
          | (1ULL << MySQLStatementParser::COUNT)
          | (1ULL << MySQLStatementParser::GROUP_CONCAT)
          | (1ULL << MySQLStatementParser::CAST)
          | (1ULL << MySQLStatementParser::POSITION)
          | (1ULL << MySQLStatementParser::SUBSTRING)
          | (1ULL << MySQLStatementParser::SUBSTR)
          | (1ULL << MySQLStatementParser::EXTRACT)
          | (1ULL << MySQLStatementParser::TRIM)
          | (1ULL << MySQLStatementParser::LAST_DAY)
          | (1ULL << MySQLStatementParser::TRADITIONAL)
          | (1ULL << MySQLStatementParser::TREE)
          | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
          | (1ULL << MySQLStatementParser::INSTANT)
          | (1ULL << MySQLStatementParser::INPLACE)
          | (1ULL << MySQLStatementParser::COPY)
          | (1ULL << MySQLStatementParser::UL_BINARY)
          | (1ULL << MySQLStatementParser::AUTOCOMMIT)
          | (1ULL << MySQLStatementParser::INNODB)
          | (1ULL << MySQLStatementParser::REDO_LOG)
          | (1ULL << MySQLStatementParser::ACCOUNT)
          | (1ULL << MySQLStatementParser::ACTION)
          | (1ULL << MySQLStatementParser::ACTIVE)
          | (1ULL << MySQLStatementParser::ADMIN)
          | (1ULL << MySQLStatementParser::AFTER)
          | (1ULL << MySQLStatementParser::AGAINST)
          | (1ULL << MySQLStatementParser::AGGREGATE)
          | (1ULL << MySQLStatementParser::ALGORITHM)
          | (1ULL << MySQLStatementParser::ALWAYS)
          | (1ULL << MySQLStatementParser::ANY)
          | (1ULL << MySQLStatementParser::ASCII)
          | (1ULL << MySQLStatementParser::AT)
          | (1ULL << MySQLStatementParser::ATTRIBUTE)
          | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
          | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
          | (1ULL << MySQLStatementParser::AVG)
          | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
          | (1ULL << MySQLStatementParser::BACKUP)
          | (1ULL << MySQLStatementParser::BEGIN)
          | (1ULL << MySQLStatementParser::BINLOG)
          | (1ULL << MySQLStatementParser::BIT)
          | (1ULL << MySQLStatementParser::BLOCK)
          | (1ULL << MySQLStatementParser::BOOL)
          | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
          | (1ULL << (MySQLStatementParser::BUCKETS - 65))
          | (1ULL << (MySQLStatementParser::BYTE - 65))
          | (1ULL << (MySQLStatementParser::CACHE - 65))
          | (1ULL << (MySQLStatementParser::CASCADED - 65))
          | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
          | (1ULL << (MySQLStatementParser::CHAIN - 65))
          | (1ULL << (MySQLStatementParser::CHANGED - 65))
          | (1ULL << (MySQLStatementParser::CHANNEL - 65))
          | (1ULL << (MySQLStatementParser::CHARSET - 65))
          | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
          | (1ULL << (MySQLStatementParser::CIPHER - 65))
          | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
          | (1ULL << (MySQLStatementParser::CLIENT - 65))
          | (1ULL << (MySQLStatementParser::CLONE - 65))
          | (1ULL << (MySQLStatementParser::CLOSE - 65))
          | (1ULL << (MySQLStatementParser::COALESCE - 65))
          | (1ULL << (MySQLStatementParser::CODE - 65))
          | (1ULL << (MySQLStatementParser::COLLATION - 65))
          | (1ULL << (MySQLStatementParser::COLUMNS - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
          | (1ULL << (MySQLStatementParser::COMMENT - 65))
          | (1ULL << (MySQLStatementParser::COMMIT - 65))
          | (1ULL << (MySQLStatementParser::COMMITTED - 65))
          | (1ULL << (MySQLStatementParser::COMPACT - 65))
          | (1ULL << (MySQLStatementParser::COMPLETION - 65))
          | (1ULL << (MySQLStatementParser::COMPONENT - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
          | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
          | (1ULL << (MySQLStatementParser::CONNECTION - 65))
          | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
          | (1ULL << (MySQLStatementParser::CONTAINS - 65))
          | (1ULL << (MySQLStatementParser::CONTEXT - 65))
          | (1ULL << (MySQLStatementParser::CPU - 65))
          | (1ULL << (MySQLStatementParser::CURRENT - 65))
          | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
          | (1ULL << (MySQLStatementParser::DATAFILE - 129))
          | (1ULL << (MySQLStatementParser::DATE - 129))
          | (1ULL << (MySQLStatementParser::DATETIME - 129))
          | (1ULL << (MySQLStatementParser::DAY - 129))
          | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
          | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
          | (1ULL << (MySQLStatementParser::DEFINER - 129))
          | (1ULL << (MySQLStatementParser::DEFINITION - 129))
          | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
          | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
          | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
          | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
          | (1ULL << (MySQLStatementParser::DISABLE - 129))
          | (1ULL << (MySQLStatementParser::DISCARD - 129))
          | (1ULL << (MySQLStatementParser::DISK - 129))
          | (1ULL << (MySQLStatementParser::DO - 129))
          | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
          | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
          | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
          | (1ULL << (MySQLStatementParser::ENABLE - 129))
          | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
          | (1ULL << (MySQLStatementParser::END - 129))
          | (1ULL << (MySQLStatementParser::ENDS - 129))
          | (1ULL << (MySQLStatementParser::ENFORCED - 129))
          | (1ULL << (MySQLStatementParser::ENGINE - 129))
          | (1ULL << (MySQLStatementParser::ENGINES - 129))
          | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
          | (1ULL << (MySQLStatementParser::ENUM - 129))
          | (1ULL << (MySQLStatementParser::ERROR - 129))
          | (1ULL << (MySQLStatementParser::ERRORS - 129))
          | (1ULL << (MySQLStatementParser::ESCAPE - 129))
          | (1ULL << (MySQLStatementParser::EVENT - 129))
          | (1ULL << (MySQLStatementParser::EVENTS - 129))
          | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
          | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
          | (1ULL << (MySQLStatementParser::EXECUTE - 193))
          | (1ULL << (MySQLStatementParser::EXPANSION - 193))
          | (1ULL << (MySQLStatementParser::EXPIRE - 193))
          | (1ULL << (MySQLStatementParser::EXPORT - 193))
          | (1ULL << (MySQLStatementParser::EXTENDED - 193))
          | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
          | (1ULL << (MySQLStatementParser::FAST - 193))
          | (1ULL << (MySQLStatementParser::FAULTS - 193))
          | (1ULL << (MySQLStatementParser::FIELDS - 193))
          | (1ULL << (MySQLStatementParser::FILE - 193))
          | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FILTER - 193))
          | (1ULL << (MySQLStatementParser::FIRST - 193))
          | (1ULL << (MySQLStatementParser::FIXED - 193))
          | (1ULL << (MySQLStatementParser::FLUSH - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
          | (1ULL << (MySQLStatementParser::FORMAT - 193))
          | (1ULL << (MySQLStatementParser::FULL - 193))
          | (1ULL << (MySQLStatementParser::GENERAL - 193))
          | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
          | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
          | (1ULL << (MySQLStatementParser::GLOBAL - 193))
          | (1ULL << (MySQLStatementParser::GRANTS - 193))
          | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
          | (1ULL << (MySQLStatementParser::HANDLER - 193))
          | (1ULL << (MySQLStatementParser::HASH - 193))
          | (1ULL << (MySQLStatementParser::HELP - 193))
          | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
          | (1ULL << (MySQLStatementParser::HISTORY - 193))
          | (1ULL << (MySQLStatementParser::HOST - 193))
          | (1ULL << (MySQLStatementParser::HOSTS - 193))
          | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
          | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
          | (1ULL << (MySQLStatementParser::IMPORT - 259))
          | (1ULL << (MySQLStatementParser::INACTIVE - 259))
          | (1ULL << (MySQLStatementParser::INDEXES - 259))
          | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
          | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
          | (1ULL << (MySQLStatementParser::INSTALL - 259))
          | (1ULL << (MySQLStatementParser::INSTANCE - 259))
          | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
          | (1ULL << (MySQLStatementParser::INVOKER - 259))
          | (1ULL << (MySQLStatementParser::IO - 259))
          | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
          | (1ULL << (MySQLStatementParser::IPC - 259))
          | (1ULL << (MySQLStatementParser::ISOLATION - 259))
          | (1ULL << (MySQLStatementParser::ISSUER - 259))
          | (1ULL << (MySQLStatementParser::JSON - 259))
          | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
          | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
          | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
          | (1ULL << (MySQLStatementParser::LAST - 259))
          | (1ULL << (MySQLStatementParser::LEAVES - 259))
          | (1ULL << (MySQLStatementParser::LESS - 259))
          | (1ULL << (MySQLStatementParser::LEVEL - 259))
          | (1ULL << (MySQLStatementParser::LINESTRING - 259))
          | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
          | (1ULL << (MySQLStatementParser::LOCKED - 324))
          | (1ULL << (MySQLStatementParser::LOCKS - 324))
          | (1ULL << (MySQLStatementParser::LOGFILE - 324))
          | (1ULL << (MySQLStatementParser::LOGS - 324))
          | (1ULL << (MySQLStatementParser::MANAGED - 324))
          | (1ULL << (MySQLStatementParser::MASTER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
          | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
          | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
          | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
          | (1ULL << (MySQLStatementParser::MEDIUM - 324))
          | (1ULL << (MySQLStatementParser::MEMBER - 324))
          | (1ULL << (MySQLStatementParser::MEMORY - 324))
          | (1ULL << (MySQLStatementParser::MERGE - 324))
          | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
          | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
          | (1ULL << (MySQLStatementParser::MIGRATE - 324))
          | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
          | (1ULL << (MySQLStatementParser::MODE - 388))
          | (1ULL << (MySQLStatementParser::MODIFY - 388))
          | (1ULL << (MySQLStatementParser::MONTH - 388))
          | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
          | (1ULL << (MySQLStatementParser::MUTEX - 388))
          | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
          | (1ULL << (MySQLStatementParser::NAME - 388))
          | (1ULL << (MySQLStatementParser::NAMES - 388))
          | (1ULL << (MySQLStatementParser::NATIONAL - 388))
          | (1ULL << (MySQLStatementParser::NCHAR - 388))
          | (1ULL << (MySQLStatementParser::NDB - 388))
          | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
          | (1ULL << (MySQLStatementParser::NESTED - 388))
          | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
          | (1ULL << (MySQLStatementParser::NEVER - 388))
          | (1ULL << (MySQLStatementParser::NEW - 388))
          | (1ULL << (MySQLStatementParser::NEXT - 388))
          | (1ULL << (MySQLStatementParser::NO - 388))
          | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
          | (1ULL << (MySQLStatementParser::NONE - 388))
          | (1ULL << (MySQLStatementParser::NOWAIT - 388))
          | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
          | (1ULL << (MySQLStatementParser::NULLS - 388))
          | (1ULL << (MySQLStatementParser::NUMBER - 388))
          | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
          | (1ULL << (MySQLStatementParser::OFF - 388))
          | (1ULL << (MySQLStatementParser::OFFSET - 388))
          | (1ULL << (MySQLStatementParser::OJ - 388))
          | (1ULL << (MySQLStatementParser::OLD - 388))
          | (1ULL << (MySQLStatementParser::ONE - 388))
          | (1ULL << (MySQLStatementParser::ONLY - 388))
          | (1ULL << (MySQLStatementParser::OPEN - 388))
          | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
          | (1ULL << (MySQLStatementParser::OPTIONS - 388))
          | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
          | (1ULL << (MySQLStatementParser::OTHERS - 388))
          | (1ULL << (MySQLStatementParser::OWNER - 388))
          | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
          | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
          | (1ULL << (MySQLStatementParser::PARTIAL - 452))
          | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
          | (1ULL << (MySQLStatementParser::PATH - 452))
          | (1ULL << (MySQLStatementParser::PERSIST - 452))
          | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
          | (1ULL << (MySQLStatementParser::PHASE - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN - 452))
          | (1ULL << (MySQLStatementParser::PLUGINS - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
          | (1ULL << (MySQLStatementParser::POINT - 452))
          | (1ULL << (MySQLStatementParser::POLYGON - 452))
          | (1ULL << (MySQLStatementParser::PORT - 452))
          | (1ULL << (MySQLStatementParser::PRECEDES - 452))
          | (1ULL << (MySQLStatementParser::PRECEDING - 452))
          | (1ULL << (MySQLStatementParser::PREPARE - 452))
          | (1ULL << (MySQLStatementParser::PRESERVE - 452))
          | (1ULL << (MySQLStatementParser::PREV - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
          | (1ULL << (MySQLStatementParser::PROCESS - 452))
          | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
          | (1ULL << (MySQLStatementParser::PROFILE - 452))
          | (1ULL << (MySQLStatementParser::PROFILES - 452))
          | (1ULL << (MySQLStatementParser::PROXY - 452))
          | (1ULL << (MySQLStatementParser::QUARTER - 452))
          | (1ULL << (MySQLStatementParser::QUERY - 452))
          | (1ULL << (MySQLStatementParser::QUICK - 452))
          | (1ULL << (MySQLStatementParser::RANDOM - 452))
          | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
          | (1ULL << (MySQLStatementParser::REBUILD - 452))
          | (1ULL << (MySQLStatementParser::RECOVER - 452))
          | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
          | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
          | (1ULL << (MySQLStatementParser::REFERENCE - 452))
          | (1ULL << (MySQLStatementParser::RELAY - 452))
          | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
          | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
          | (1ULL << (MySQLStatementParser::RELOAD - 452))
          | (1ULL << (MySQLStatementParser::REMOVE - 452))
          | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
          | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATION - 517))
          | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RESET - 517))
          | (1ULL << (MySQLStatementParser::RESOURCE - 517))
          | (1ULL << (MySQLStatementParser::RESPECT - 517))
          | (1ULL << (MySQLStatementParser::RESTART - 517))
          | (1ULL << (MySQLStatementParser::RESTORE - 517))
          | (1ULL << (MySQLStatementParser::RESUME - 517))
          | (1ULL << (MySQLStatementParser::RETAIN - 517))
          | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
          | (1ULL << (MySQLStatementParser::RETURNING - 517))
          | (1ULL << (MySQLStatementParser::RETURNS - 517))
          | (1ULL << (MySQLStatementParser::REUSE - 517))
          | (1ULL << (MySQLStatementParser::REVERSE - 517))
          | (1ULL << (MySQLStatementParser::ROLE - 517))
          | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
          | (1ULL << (MySQLStatementParser::ROLLUP - 517))
          | (1ULL << (MySQLStatementParser::ROTATE - 517))
          | (1ULL << (MySQLStatementParser::ROUTINE - 517))
          | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
          | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RTREE - 517))
          | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
          | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
          | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
          | (1ULL << (MySQLStatementParser::SECOND - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
          | (1ULL << (MySQLStatementParser::SECURITY - 517))
          | (1ULL << (MySQLStatementParser::SERIAL - 517))
          | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
          | (1ULL << (MySQLStatementParser::SERVER - 517))
          | (1ULL << (MySQLStatementParser::SESSION - 517))
          | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
          | (1ULL << (MySQLStatementParser::SIGNED - 581))
          | (1ULL << (MySQLStatementParser::SIMPLE - 581))
          | (1ULL << (MySQLStatementParser::SLAVE - 581))
          | (1ULL << (MySQLStatementParser::SLOW - 581))
          | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
          | (1ULL << (MySQLStatementParser::SOCKET - 581))
          | (1ULL << (MySQLStatementParser::SOME - 581))
          | (1ULL << (MySQLStatementParser::SONAME - 581))
          | (1ULL << (MySQLStatementParser::SOUNDS - 581))
          | (1ULL << (MySQLStatementParser::SOURCE - 581))
          | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
          | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
          | (1ULL << (MySQLStatementParser::SRID - 581))
          | (1ULL << (MySQLStatementParser::STACKED - 581))
          | (1ULL << (MySQLStatementParser::START - 581))
          | (1ULL << (MySQLStatementParser::STARTS - 581))
          | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
          | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
          | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
          | (1ULL << (MySQLStatementParser::STATUS - 581))
          | (1ULL << (MySQLStatementParser::STOP - 581))
          | (1ULL << (MySQLStatementParser::STORAGE - 581))
          | (1ULL << (MySQLStatementParser::STREAM - 581))
          | (1ULL << (MySQLStatementParser::STRING - 581))
          | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
          | (1ULL << (MySQLStatementParser::SUBJECT - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
          | (1ULL << (MySQLStatementParser::SUPER - 581))
          | (1ULL << (MySQLStatementParser::SUSPEND - 581))
          | (1ULL << (MySQLStatementParser::SWAPS - 581))
          | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
          | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
          | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
          | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
          | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
          | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
          | (1ULL << (MySQLStatementParser::TEXT - 645))
          | (1ULL << (MySQLStatementParser::THAN - 645))
          | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
          | (1ULL << (MySQLStatementParser::TIES - 645))
          | (1ULL << (MySQLStatementParser::TIME - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
          | (1ULL << (MySQLStatementParser::TLS - 645))
          | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
          | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
          | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
          | (1ULL << (MySQLStatementParser::TYPE - 645))
          | (1ULL << (MySQLStatementParser::TYPES - 645))
          | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
          | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
          | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
          | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
          | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
          | (1ULL << (MySQLStatementParser::UNICODE - 645))
          | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
          | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
          | (1ULL << (MySQLStatementParser::UNTIL - 645))
          | (1ULL << (MySQLStatementParser::UPGRADE - 645))
          | (1ULL << (MySQLStatementParser::USER - 645))
          | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
          | (1ULL << (MySQLStatementParser::USE_FRM - 645))
          | (1ULL << (MySQLStatementParser::VALIDATION - 645))
          | (1ULL << (MySQLStatementParser::VALUE - 645))
          | (1ULL << (MySQLStatementParser::VARIABLES - 645))
          | (1ULL << (MySQLStatementParser::VCPU - 645))
          | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
          | (1ULL << (MySQLStatementParser::WAIT - 710))
          | (1ULL << (MySQLStatementParser::WARNINGS - 710))
          | (1ULL << (MySQLStatementParser::WEEK - 710))
          | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
          | (1ULL << (MySQLStatementParser::WITHOUT - 710))
          | (1ULL << (MySQLStatementParser::WORK - 710))
          | (1ULL << (MySQLStatementParser::WRAPPER - 710))
          | (1ULL << (MySQLStatementParser::X509 - 710))
          | (1ULL << (MySQLStatementParser::XA - 710))
          | (1ULL << (MySQLStatementParser::XID - 710))
          | (1ULL << (MySQLStatementParser::XML - 710))
          | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

        || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
          setState(6285);
          schemaNames();
        }
        setState(6288);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::REPLICATE_IGNORE_DB: {
        enterOuterAlt(_localctx, 2);
        setState(6289);
        match(MySQLStatementParser::REPLICATE_IGNORE_DB);
        setState(6290);
        match(MySQLStatementParser::EQ_);
        setState(6291);
        match(MySQLStatementParser::LP_);
        setState(6293);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
          | (1ULL << MySQLStatementParser::MIN)
          | (1ULL << MySQLStatementParser::SUM)
          | (1ULL << MySQLStatementParser::COUNT)
          | (1ULL << MySQLStatementParser::GROUP_CONCAT)
          | (1ULL << MySQLStatementParser::CAST)
          | (1ULL << MySQLStatementParser::POSITION)
          | (1ULL << MySQLStatementParser::SUBSTRING)
          | (1ULL << MySQLStatementParser::SUBSTR)
          | (1ULL << MySQLStatementParser::EXTRACT)
          | (1ULL << MySQLStatementParser::TRIM)
          | (1ULL << MySQLStatementParser::LAST_DAY)
          | (1ULL << MySQLStatementParser::TRADITIONAL)
          | (1ULL << MySQLStatementParser::TREE)
          | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
          | (1ULL << MySQLStatementParser::INSTANT)
          | (1ULL << MySQLStatementParser::INPLACE)
          | (1ULL << MySQLStatementParser::COPY)
          | (1ULL << MySQLStatementParser::UL_BINARY)
          | (1ULL << MySQLStatementParser::AUTOCOMMIT)
          | (1ULL << MySQLStatementParser::INNODB)
          | (1ULL << MySQLStatementParser::REDO_LOG)
          | (1ULL << MySQLStatementParser::ACCOUNT)
          | (1ULL << MySQLStatementParser::ACTION)
          | (1ULL << MySQLStatementParser::ACTIVE)
          | (1ULL << MySQLStatementParser::ADMIN)
          | (1ULL << MySQLStatementParser::AFTER)
          | (1ULL << MySQLStatementParser::AGAINST)
          | (1ULL << MySQLStatementParser::AGGREGATE)
          | (1ULL << MySQLStatementParser::ALGORITHM)
          | (1ULL << MySQLStatementParser::ALWAYS)
          | (1ULL << MySQLStatementParser::ANY)
          | (1ULL << MySQLStatementParser::ASCII)
          | (1ULL << MySQLStatementParser::AT)
          | (1ULL << MySQLStatementParser::ATTRIBUTE)
          | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
          | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
          | (1ULL << MySQLStatementParser::AVG)
          | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
          | (1ULL << MySQLStatementParser::BACKUP)
          | (1ULL << MySQLStatementParser::BEGIN)
          | (1ULL << MySQLStatementParser::BINLOG)
          | (1ULL << MySQLStatementParser::BIT)
          | (1ULL << MySQLStatementParser::BLOCK)
          | (1ULL << MySQLStatementParser::BOOL)
          | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
          | (1ULL << (MySQLStatementParser::BUCKETS - 65))
          | (1ULL << (MySQLStatementParser::BYTE - 65))
          | (1ULL << (MySQLStatementParser::CACHE - 65))
          | (1ULL << (MySQLStatementParser::CASCADED - 65))
          | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
          | (1ULL << (MySQLStatementParser::CHAIN - 65))
          | (1ULL << (MySQLStatementParser::CHANGED - 65))
          | (1ULL << (MySQLStatementParser::CHANNEL - 65))
          | (1ULL << (MySQLStatementParser::CHARSET - 65))
          | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
          | (1ULL << (MySQLStatementParser::CIPHER - 65))
          | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
          | (1ULL << (MySQLStatementParser::CLIENT - 65))
          | (1ULL << (MySQLStatementParser::CLONE - 65))
          | (1ULL << (MySQLStatementParser::CLOSE - 65))
          | (1ULL << (MySQLStatementParser::COALESCE - 65))
          | (1ULL << (MySQLStatementParser::CODE - 65))
          | (1ULL << (MySQLStatementParser::COLLATION - 65))
          | (1ULL << (MySQLStatementParser::COLUMNS - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
          | (1ULL << (MySQLStatementParser::COMMENT - 65))
          | (1ULL << (MySQLStatementParser::COMMIT - 65))
          | (1ULL << (MySQLStatementParser::COMMITTED - 65))
          | (1ULL << (MySQLStatementParser::COMPACT - 65))
          | (1ULL << (MySQLStatementParser::COMPLETION - 65))
          | (1ULL << (MySQLStatementParser::COMPONENT - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
          | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
          | (1ULL << (MySQLStatementParser::CONNECTION - 65))
          | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
          | (1ULL << (MySQLStatementParser::CONTAINS - 65))
          | (1ULL << (MySQLStatementParser::CONTEXT - 65))
          | (1ULL << (MySQLStatementParser::CPU - 65))
          | (1ULL << (MySQLStatementParser::CURRENT - 65))
          | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
          | (1ULL << (MySQLStatementParser::DATAFILE - 129))
          | (1ULL << (MySQLStatementParser::DATE - 129))
          | (1ULL << (MySQLStatementParser::DATETIME - 129))
          | (1ULL << (MySQLStatementParser::DAY - 129))
          | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
          | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
          | (1ULL << (MySQLStatementParser::DEFINER - 129))
          | (1ULL << (MySQLStatementParser::DEFINITION - 129))
          | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
          | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
          | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
          | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
          | (1ULL << (MySQLStatementParser::DISABLE - 129))
          | (1ULL << (MySQLStatementParser::DISCARD - 129))
          | (1ULL << (MySQLStatementParser::DISK - 129))
          | (1ULL << (MySQLStatementParser::DO - 129))
          | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
          | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
          | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
          | (1ULL << (MySQLStatementParser::ENABLE - 129))
          | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
          | (1ULL << (MySQLStatementParser::END - 129))
          | (1ULL << (MySQLStatementParser::ENDS - 129))
          | (1ULL << (MySQLStatementParser::ENFORCED - 129))
          | (1ULL << (MySQLStatementParser::ENGINE - 129))
          | (1ULL << (MySQLStatementParser::ENGINES - 129))
          | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
          | (1ULL << (MySQLStatementParser::ENUM - 129))
          | (1ULL << (MySQLStatementParser::ERROR - 129))
          | (1ULL << (MySQLStatementParser::ERRORS - 129))
          | (1ULL << (MySQLStatementParser::ESCAPE - 129))
          | (1ULL << (MySQLStatementParser::EVENT - 129))
          | (1ULL << (MySQLStatementParser::EVENTS - 129))
          | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
          | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
          | (1ULL << (MySQLStatementParser::EXECUTE - 193))
          | (1ULL << (MySQLStatementParser::EXPANSION - 193))
          | (1ULL << (MySQLStatementParser::EXPIRE - 193))
          | (1ULL << (MySQLStatementParser::EXPORT - 193))
          | (1ULL << (MySQLStatementParser::EXTENDED - 193))
          | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
          | (1ULL << (MySQLStatementParser::FAST - 193))
          | (1ULL << (MySQLStatementParser::FAULTS - 193))
          | (1ULL << (MySQLStatementParser::FIELDS - 193))
          | (1ULL << (MySQLStatementParser::FILE - 193))
          | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FILTER - 193))
          | (1ULL << (MySQLStatementParser::FIRST - 193))
          | (1ULL << (MySQLStatementParser::FIXED - 193))
          | (1ULL << (MySQLStatementParser::FLUSH - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
          | (1ULL << (MySQLStatementParser::FORMAT - 193))
          | (1ULL << (MySQLStatementParser::FULL - 193))
          | (1ULL << (MySQLStatementParser::GENERAL - 193))
          | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
          | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
          | (1ULL << (MySQLStatementParser::GLOBAL - 193))
          | (1ULL << (MySQLStatementParser::GRANTS - 193))
          | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
          | (1ULL << (MySQLStatementParser::HANDLER - 193))
          | (1ULL << (MySQLStatementParser::HASH - 193))
          | (1ULL << (MySQLStatementParser::HELP - 193))
          | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
          | (1ULL << (MySQLStatementParser::HISTORY - 193))
          | (1ULL << (MySQLStatementParser::HOST - 193))
          | (1ULL << (MySQLStatementParser::HOSTS - 193))
          | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
          | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
          | (1ULL << (MySQLStatementParser::IMPORT - 259))
          | (1ULL << (MySQLStatementParser::INACTIVE - 259))
          | (1ULL << (MySQLStatementParser::INDEXES - 259))
          | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
          | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
          | (1ULL << (MySQLStatementParser::INSTALL - 259))
          | (1ULL << (MySQLStatementParser::INSTANCE - 259))
          | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
          | (1ULL << (MySQLStatementParser::INVOKER - 259))
          | (1ULL << (MySQLStatementParser::IO - 259))
          | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
          | (1ULL << (MySQLStatementParser::IPC - 259))
          | (1ULL << (MySQLStatementParser::ISOLATION - 259))
          | (1ULL << (MySQLStatementParser::ISSUER - 259))
          | (1ULL << (MySQLStatementParser::JSON - 259))
          | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
          | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
          | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
          | (1ULL << (MySQLStatementParser::LAST - 259))
          | (1ULL << (MySQLStatementParser::LEAVES - 259))
          | (1ULL << (MySQLStatementParser::LESS - 259))
          | (1ULL << (MySQLStatementParser::LEVEL - 259))
          | (1ULL << (MySQLStatementParser::LINESTRING - 259))
          | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
          | (1ULL << (MySQLStatementParser::LOCKED - 324))
          | (1ULL << (MySQLStatementParser::LOCKS - 324))
          | (1ULL << (MySQLStatementParser::LOGFILE - 324))
          | (1ULL << (MySQLStatementParser::LOGS - 324))
          | (1ULL << (MySQLStatementParser::MANAGED - 324))
          | (1ULL << (MySQLStatementParser::MASTER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
          | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
          | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
          | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
          | (1ULL << (MySQLStatementParser::MEDIUM - 324))
          | (1ULL << (MySQLStatementParser::MEMBER - 324))
          | (1ULL << (MySQLStatementParser::MEMORY - 324))
          | (1ULL << (MySQLStatementParser::MERGE - 324))
          | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
          | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
          | (1ULL << (MySQLStatementParser::MIGRATE - 324))
          | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
          | (1ULL << (MySQLStatementParser::MODE - 388))
          | (1ULL << (MySQLStatementParser::MODIFY - 388))
          | (1ULL << (MySQLStatementParser::MONTH - 388))
          | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
          | (1ULL << (MySQLStatementParser::MUTEX - 388))
          | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
          | (1ULL << (MySQLStatementParser::NAME - 388))
          | (1ULL << (MySQLStatementParser::NAMES - 388))
          | (1ULL << (MySQLStatementParser::NATIONAL - 388))
          | (1ULL << (MySQLStatementParser::NCHAR - 388))
          | (1ULL << (MySQLStatementParser::NDB - 388))
          | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
          | (1ULL << (MySQLStatementParser::NESTED - 388))
          | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
          | (1ULL << (MySQLStatementParser::NEVER - 388))
          | (1ULL << (MySQLStatementParser::NEW - 388))
          | (1ULL << (MySQLStatementParser::NEXT - 388))
          | (1ULL << (MySQLStatementParser::NO - 388))
          | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
          | (1ULL << (MySQLStatementParser::NONE - 388))
          | (1ULL << (MySQLStatementParser::NOWAIT - 388))
          | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
          | (1ULL << (MySQLStatementParser::NULLS - 388))
          | (1ULL << (MySQLStatementParser::NUMBER - 388))
          | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
          | (1ULL << (MySQLStatementParser::OFF - 388))
          | (1ULL << (MySQLStatementParser::OFFSET - 388))
          | (1ULL << (MySQLStatementParser::OJ - 388))
          | (1ULL << (MySQLStatementParser::OLD - 388))
          | (1ULL << (MySQLStatementParser::ONE - 388))
          | (1ULL << (MySQLStatementParser::ONLY - 388))
          | (1ULL << (MySQLStatementParser::OPEN - 388))
          | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
          | (1ULL << (MySQLStatementParser::OPTIONS - 388))
          | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
          | (1ULL << (MySQLStatementParser::OTHERS - 388))
          | (1ULL << (MySQLStatementParser::OWNER - 388))
          | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
          | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
          | (1ULL << (MySQLStatementParser::PARTIAL - 452))
          | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
          | (1ULL << (MySQLStatementParser::PATH - 452))
          | (1ULL << (MySQLStatementParser::PERSIST - 452))
          | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
          | (1ULL << (MySQLStatementParser::PHASE - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN - 452))
          | (1ULL << (MySQLStatementParser::PLUGINS - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
          | (1ULL << (MySQLStatementParser::POINT - 452))
          | (1ULL << (MySQLStatementParser::POLYGON - 452))
          | (1ULL << (MySQLStatementParser::PORT - 452))
          | (1ULL << (MySQLStatementParser::PRECEDES - 452))
          | (1ULL << (MySQLStatementParser::PRECEDING - 452))
          | (1ULL << (MySQLStatementParser::PREPARE - 452))
          | (1ULL << (MySQLStatementParser::PRESERVE - 452))
          | (1ULL << (MySQLStatementParser::PREV - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
          | (1ULL << (MySQLStatementParser::PROCESS - 452))
          | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
          | (1ULL << (MySQLStatementParser::PROFILE - 452))
          | (1ULL << (MySQLStatementParser::PROFILES - 452))
          | (1ULL << (MySQLStatementParser::PROXY - 452))
          | (1ULL << (MySQLStatementParser::QUARTER - 452))
          | (1ULL << (MySQLStatementParser::QUERY - 452))
          | (1ULL << (MySQLStatementParser::QUICK - 452))
          | (1ULL << (MySQLStatementParser::RANDOM - 452))
          | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
          | (1ULL << (MySQLStatementParser::REBUILD - 452))
          | (1ULL << (MySQLStatementParser::RECOVER - 452))
          | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
          | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
          | (1ULL << (MySQLStatementParser::REFERENCE - 452))
          | (1ULL << (MySQLStatementParser::RELAY - 452))
          | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
          | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
          | (1ULL << (MySQLStatementParser::RELOAD - 452))
          | (1ULL << (MySQLStatementParser::REMOVE - 452))
          | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
          | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATION - 517))
          | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RESET - 517))
          | (1ULL << (MySQLStatementParser::RESOURCE - 517))
          | (1ULL << (MySQLStatementParser::RESPECT - 517))
          | (1ULL << (MySQLStatementParser::RESTART - 517))
          | (1ULL << (MySQLStatementParser::RESTORE - 517))
          | (1ULL << (MySQLStatementParser::RESUME - 517))
          | (1ULL << (MySQLStatementParser::RETAIN - 517))
          | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
          | (1ULL << (MySQLStatementParser::RETURNING - 517))
          | (1ULL << (MySQLStatementParser::RETURNS - 517))
          | (1ULL << (MySQLStatementParser::REUSE - 517))
          | (1ULL << (MySQLStatementParser::REVERSE - 517))
          | (1ULL << (MySQLStatementParser::ROLE - 517))
          | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
          | (1ULL << (MySQLStatementParser::ROLLUP - 517))
          | (1ULL << (MySQLStatementParser::ROTATE - 517))
          | (1ULL << (MySQLStatementParser::ROUTINE - 517))
          | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
          | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RTREE - 517))
          | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
          | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
          | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
          | (1ULL << (MySQLStatementParser::SECOND - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
          | (1ULL << (MySQLStatementParser::SECURITY - 517))
          | (1ULL << (MySQLStatementParser::SERIAL - 517))
          | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
          | (1ULL << (MySQLStatementParser::SERVER - 517))
          | (1ULL << (MySQLStatementParser::SESSION - 517))
          | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
          | (1ULL << (MySQLStatementParser::SIGNED - 581))
          | (1ULL << (MySQLStatementParser::SIMPLE - 581))
          | (1ULL << (MySQLStatementParser::SLAVE - 581))
          | (1ULL << (MySQLStatementParser::SLOW - 581))
          | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
          | (1ULL << (MySQLStatementParser::SOCKET - 581))
          | (1ULL << (MySQLStatementParser::SOME - 581))
          | (1ULL << (MySQLStatementParser::SONAME - 581))
          | (1ULL << (MySQLStatementParser::SOUNDS - 581))
          | (1ULL << (MySQLStatementParser::SOURCE - 581))
          | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
          | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
          | (1ULL << (MySQLStatementParser::SRID - 581))
          | (1ULL << (MySQLStatementParser::STACKED - 581))
          | (1ULL << (MySQLStatementParser::START - 581))
          | (1ULL << (MySQLStatementParser::STARTS - 581))
          | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
          | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
          | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
          | (1ULL << (MySQLStatementParser::STATUS - 581))
          | (1ULL << (MySQLStatementParser::STOP - 581))
          | (1ULL << (MySQLStatementParser::STORAGE - 581))
          | (1ULL << (MySQLStatementParser::STREAM - 581))
          | (1ULL << (MySQLStatementParser::STRING - 581))
          | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
          | (1ULL << (MySQLStatementParser::SUBJECT - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
          | (1ULL << (MySQLStatementParser::SUPER - 581))
          | (1ULL << (MySQLStatementParser::SUSPEND - 581))
          | (1ULL << (MySQLStatementParser::SWAPS - 581))
          | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
          | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
          | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
          | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
          | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
          | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
          | (1ULL << (MySQLStatementParser::TEXT - 645))
          | (1ULL << (MySQLStatementParser::THAN - 645))
          | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
          | (1ULL << (MySQLStatementParser::TIES - 645))
          | (1ULL << (MySQLStatementParser::TIME - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
          | (1ULL << (MySQLStatementParser::TLS - 645))
          | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
          | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
          | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
          | (1ULL << (MySQLStatementParser::TYPE - 645))
          | (1ULL << (MySQLStatementParser::TYPES - 645))
          | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
          | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
          | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
          | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
          | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
          | (1ULL << (MySQLStatementParser::UNICODE - 645))
          | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
          | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
          | (1ULL << (MySQLStatementParser::UNTIL - 645))
          | (1ULL << (MySQLStatementParser::UPGRADE - 645))
          | (1ULL << (MySQLStatementParser::USER - 645))
          | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
          | (1ULL << (MySQLStatementParser::USE_FRM - 645))
          | (1ULL << (MySQLStatementParser::VALIDATION - 645))
          | (1ULL << (MySQLStatementParser::VALUE - 645))
          | (1ULL << (MySQLStatementParser::VARIABLES - 645))
          | (1ULL << (MySQLStatementParser::VCPU - 645))
          | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
          | (1ULL << (MySQLStatementParser::WAIT - 710))
          | (1ULL << (MySQLStatementParser::WARNINGS - 710))
          | (1ULL << (MySQLStatementParser::WEEK - 710))
          | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
          | (1ULL << (MySQLStatementParser::WITHOUT - 710))
          | (1ULL << (MySQLStatementParser::WORK - 710))
          | (1ULL << (MySQLStatementParser::WRAPPER - 710))
          | (1ULL << (MySQLStatementParser::X509 - 710))
          | (1ULL << (MySQLStatementParser::XA - 710))
          | (1ULL << (MySQLStatementParser::XID - 710))
          | (1ULL << (MySQLStatementParser::XML - 710))
          | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

        || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
          setState(6292);
          schemaNames();
        }
        setState(6295);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::REPLICATE_DO_TABLE: {
        enterOuterAlt(_localctx, 3);
        setState(6296);
        match(MySQLStatementParser::REPLICATE_DO_TABLE);
        setState(6297);
        match(MySQLStatementParser::EQ_);
        setState(6298);
        match(MySQLStatementParser::LP_);
        setState(6300);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
          | (1ULL << MySQLStatementParser::MIN)
          | (1ULL << MySQLStatementParser::SUM)
          | (1ULL << MySQLStatementParser::COUNT)
          | (1ULL << MySQLStatementParser::GROUP_CONCAT)
          | (1ULL << MySQLStatementParser::CAST)
          | (1ULL << MySQLStatementParser::POSITION)
          | (1ULL << MySQLStatementParser::SUBSTRING)
          | (1ULL << MySQLStatementParser::SUBSTR)
          | (1ULL << MySQLStatementParser::EXTRACT)
          | (1ULL << MySQLStatementParser::TRIM)
          | (1ULL << MySQLStatementParser::LAST_DAY)
          | (1ULL << MySQLStatementParser::TRADITIONAL)
          | (1ULL << MySQLStatementParser::TREE)
          | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
          | (1ULL << MySQLStatementParser::INSTANT)
          | (1ULL << MySQLStatementParser::INPLACE)
          | (1ULL << MySQLStatementParser::COPY)
          | (1ULL << MySQLStatementParser::UL_BINARY)
          | (1ULL << MySQLStatementParser::AUTOCOMMIT)
          | (1ULL << MySQLStatementParser::INNODB)
          | (1ULL << MySQLStatementParser::REDO_LOG)
          | (1ULL << MySQLStatementParser::ACCOUNT)
          | (1ULL << MySQLStatementParser::ACTION)
          | (1ULL << MySQLStatementParser::ACTIVE)
          | (1ULL << MySQLStatementParser::ADMIN)
          | (1ULL << MySQLStatementParser::AFTER)
          | (1ULL << MySQLStatementParser::AGAINST)
          | (1ULL << MySQLStatementParser::AGGREGATE)
          | (1ULL << MySQLStatementParser::ALGORITHM)
          | (1ULL << MySQLStatementParser::ALWAYS)
          | (1ULL << MySQLStatementParser::ANY)
          | (1ULL << MySQLStatementParser::ASCII)
          | (1ULL << MySQLStatementParser::AT)
          | (1ULL << MySQLStatementParser::ATTRIBUTE)
          | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
          | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
          | (1ULL << MySQLStatementParser::AVG)
          | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
          | (1ULL << MySQLStatementParser::BACKUP)
          | (1ULL << MySQLStatementParser::BEGIN)
          | (1ULL << MySQLStatementParser::BINLOG)
          | (1ULL << MySQLStatementParser::BIT)
          | (1ULL << MySQLStatementParser::BLOCK)
          | (1ULL << MySQLStatementParser::BOOL)
          | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
          | (1ULL << (MySQLStatementParser::BUCKETS - 65))
          | (1ULL << (MySQLStatementParser::BYTE - 65))
          | (1ULL << (MySQLStatementParser::CACHE - 65))
          | (1ULL << (MySQLStatementParser::CASCADED - 65))
          | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
          | (1ULL << (MySQLStatementParser::CHAIN - 65))
          | (1ULL << (MySQLStatementParser::CHANGED - 65))
          | (1ULL << (MySQLStatementParser::CHANNEL - 65))
          | (1ULL << (MySQLStatementParser::CHARSET - 65))
          | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
          | (1ULL << (MySQLStatementParser::CIPHER - 65))
          | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
          | (1ULL << (MySQLStatementParser::CLIENT - 65))
          | (1ULL << (MySQLStatementParser::CLONE - 65))
          | (1ULL << (MySQLStatementParser::CLOSE - 65))
          | (1ULL << (MySQLStatementParser::COALESCE - 65))
          | (1ULL << (MySQLStatementParser::CODE - 65))
          | (1ULL << (MySQLStatementParser::COLLATION - 65))
          | (1ULL << (MySQLStatementParser::COLUMNS - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
          | (1ULL << (MySQLStatementParser::COMMENT - 65))
          | (1ULL << (MySQLStatementParser::COMMIT - 65))
          | (1ULL << (MySQLStatementParser::COMMITTED - 65))
          | (1ULL << (MySQLStatementParser::COMPACT - 65))
          | (1ULL << (MySQLStatementParser::COMPLETION - 65))
          | (1ULL << (MySQLStatementParser::COMPONENT - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
          | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
          | (1ULL << (MySQLStatementParser::CONNECTION - 65))
          | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
          | (1ULL << (MySQLStatementParser::CONTAINS - 65))
          | (1ULL << (MySQLStatementParser::CONTEXT - 65))
          | (1ULL << (MySQLStatementParser::CPU - 65))
          | (1ULL << (MySQLStatementParser::CURRENT - 65))
          | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
          | (1ULL << (MySQLStatementParser::DATAFILE - 129))
          | (1ULL << (MySQLStatementParser::DATE - 129))
          | (1ULL << (MySQLStatementParser::DATETIME - 129))
          | (1ULL << (MySQLStatementParser::DAY - 129))
          | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
          | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
          | (1ULL << (MySQLStatementParser::DEFINER - 129))
          | (1ULL << (MySQLStatementParser::DEFINITION - 129))
          | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
          | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
          | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
          | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
          | (1ULL << (MySQLStatementParser::DISABLE - 129))
          | (1ULL << (MySQLStatementParser::DISCARD - 129))
          | (1ULL << (MySQLStatementParser::DISK - 129))
          | (1ULL << (MySQLStatementParser::DO - 129))
          | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
          | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
          | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
          | (1ULL << (MySQLStatementParser::ENABLE - 129))
          | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
          | (1ULL << (MySQLStatementParser::END - 129))
          | (1ULL << (MySQLStatementParser::ENDS - 129))
          | (1ULL << (MySQLStatementParser::ENFORCED - 129))
          | (1ULL << (MySQLStatementParser::ENGINE - 129))
          | (1ULL << (MySQLStatementParser::ENGINES - 129))
          | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
          | (1ULL << (MySQLStatementParser::ENUM - 129))
          | (1ULL << (MySQLStatementParser::ERROR - 129))
          | (1ULL << (MySQLStatementParser::ERRORS - 129))
          | (1ULL << (MySQLStatementParser::ESCAPE - 129))
          | (1ULL << (MySQLStatementParser::EVENT - 129))
          | (1ULL << (MySQLStatementParser::EVENTS - 129))
          | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
          | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
          | (1ULL << (MySQLStatementParser::EXECUTE - 193))
          | (1ULL << (MySQLStatementParser::EXPANSION - 193))
          | (1ULL << (MySQLStatementParser::EXPIRE - 193))
          | (1ULL << (MySQLStatementParser::EXPORT - 193))
          | (1ULL << (MySQLStatementParser::EXTENDED - 193))
          | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
          | (1ULL << (MySQLStatementParser::FAST - 193))
          | (1ULL << (MySQLStatementParser::FAULTS - 193))
          | (1ULL << (MySQLStatementParser::FIELDS - 193))
          | (1ULL << (MySQLStatementParser::FILE - 193))
          | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FILTER - 193))
          | (1ULL << (MySQLStatementParser::FIRST - 193))
          | (1ULL << (MySQLStatementParser::FIXED - 193))
          | (1ULL << (MySQLStatementParser::FLUSH - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
          | (1ULL << (MySQLStatementParser::FORMAT - 193))
          | (1ULL << (MySQLStatementParser::FULL - 193))
          | (1ULL << (MySQLStatementParser::GENERAL - 193))
          | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
          | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
          | (1ULL << (MySQLStatementParser::GLOBAL - 193))
          | (1ULL << (MySQLStatementParser::GRANTS - 193))
          | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
          | (1ULL << (MySQLStatementParser::HANDLER - 193))
          | (1ULL << (MySQLStatementParser::HASH - 193))
          | (1ULL << (MySQLStatementParser::HELP - 193))
          | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
          | (1ULL << (MySQLStatementParser::HISTORY - 193))
          | (1ULL << (MySQLStatementParser::HOST - 193))
          | (1ULL << (MySQLStatementParser::HOSTS - 193))
          | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
          | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
          | (1ULL << (MySQLStatementParser::IMPORT - 259))
          | (1ULL << (MySQLStatementParser::INACTIVE - 259))
          | (1ULL << (MySQLStatementParser::INDEXES - 259))
          | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
          | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
          | (1ULL << (MySQLStatementParser::INSTALL - 259))
          | (1ULL << (MySQLStatementParser::INSTANCE - 259))
          | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
          | (1ULL << (MySQLStatementParser::INVOKER - 259))
          | (1ULL << (MySQLStatementParser::IO - 259))
          | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
          | (1ULL << (MySQLStatementParser::IPC - 259))
          | (1ULL << (MySQLStatementParser::ISOLATION - 259))
          | (1ULL << (MySQLStatementParser::ISSUER - 259))
          | (1ULL << (MySQLStatementParser::JSON - 259))
          | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
          | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
          | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
          | (1ULL << (MySQLStatementParser::LAST - 259))
          | (1ULL << (MySQLStatementParser::LEAVES - 259))
          | (1ULL << (MySQLStatementParser::LESS - 259))
          | (1ULL << (MySQLStatementParser::LEVEL - 259))
          | (1ULL << (MySQLStatementParser::LINESTRING - 259))
          | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
          | (1ULL << (MySQLStatementParser::LOCKED - 324))
          | (1ULL << (MySQLStatementParser::LOCKS - 324))
          | (1ULL << (MySQLStatementParser::LOGFILE - 324))
          | (1ULL << (MySQLStatementParser::LOGS - 324))
          | (1ULL << (MySQLStatementParser::MANAGED - 324))
          | (1ULL << (MySQLStatementParser::MASTER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
          | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
          | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
          | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
          | (1ULL << (MySQLStatementParser::MEDIUM - 324))
          | (1ULL << (MySQLStatementParser::MEMBER - 324))
          | (1ULL << (MySQLStatementParser::MEMORY - 324))
          | (1ULL << (MySQLStatementParser::MERGE - 324))
          | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
          | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
          | (1ULL << (MySQLStatementParser::MIGRATE - 324))
          | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
          | (1ULL << (MySQLStatementParser::MODE - 388))
          | (1ULL << (MySQLStatementParser::MODIFY - 388))
          | (1ULL << (MySQLStatementParser::MONTH - 388))
          | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
          | (1ULL << (MySQLStatementParser::MUTEX - 388))
          | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
          | (1ULL << (MySQLStatementParser::NAME - 388))
          | (1ULL << (MySQLStatementParser::NAMES - 388))
          | (1ULL << (MySQLStatementParser::NATIONAL - 388))
          | (1ULL << (MySQLStatementParser::NCHAR - 388))
          | (1ULL << (MySQLStatementParser::NDB - 388))
          | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
          | (1ULL << (MySQLStatementParser::NESTED - 388))
          | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
          | (1ULL << (MySQLStatementParser::NEVER - 388))
          | (1ULL << (MySQLStatementParser::NEW - 388))
          | (1ULL << (MySQLStatementParser::NEXT - 388))
          | (1ULL << (MySQLStatementParser::NO - 388))
          | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
          | (1ULL << (MySQLStatementParser::NONE - 388))
          | (1ULL << (MySQLStatementParser::NOWAIT - 388))
          | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
          | (1ULL << (MySQLStatementParser::NULLS - 388))
          | (1ULL << (MySQLStatementParser::NUMBER - 388))
          | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
          | (1ULL << (MySQLStatementParser::OFF - 388))
          | (1ULL << (MySQLStatementParser::OFFSET - 388))
          | (1ULL << (MySQLStatementParser::OJ - 388))
          | (1ULL << (MySQLStatementParser::OLD - 388))
          | (1ULL << (MySQLStatementParser::ONE - 388))
          | (1ULL << (MySQLStatementParser::ONLY - 388))
          | (1ULL << (MySQLStatementParser::OPEN - 388))
          | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
          | (1ULL << (MySQLStatementParser::OPTIONS - 388))
          | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
          | (1ULL << (MySQLStatementParser::OTHERS - 388))
          | (1ULL << (MySQLStatementParser::OWNER - 388))
          | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
          | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
          | (1ULL << (MySQLStatementParser::PARTIAL - 452))
          | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
          | (1ULL << (MySQLStatementParser::PATH - 452))
          | (1ULL << (MySQLStatementParser::PERSIST - 452))
          | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
          | (1ULL << (MySQLStatementParser::PHASE - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN - 452))
          | (1ULL << (MySQLStatementParser::PLUGINS - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
          | (1ULL << (MySQLStatementParser::POINT - 452))
          | (1ULL << (MySQLStatementParser::POLYGON - 452))
          | (1ULL << (MySQLStatementParser::PORT - 452))
          | (1ULL << (MySQLStatementParser::PRECEDES - 452))
          | (1ULL << (MySQLStatementParser::PRECEDING - 452))
          | (1ULL << (MySQLStatementParser::PREPARE - 452))
          | (1ULL << (MySQLStatementParser::PRESERVE - 452))
          | (1ULL << (MySQLStatementParser::PREV - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
          | (1ULL << (MySQLStatementParser::PROCESS - 452))
          | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
          | (1ULL << (MySQLStatementParser::PROFILE - 452))
          | (1ULL << (MySQLStatementParser::PROFILES - 452))
          | (1ULL << (MySQLStatementParser::PROXY - 452))
          | (1ULL << (MySQLStatementParser::QUARTER - 452))
          | (1ULL << (MySQLStatementParser::QUERY - 452))
          | (1ULL << (MySQLStatementParser::QUICK - 452))
          | (1ULL << (MySQLStatementParser::RANDOM - 452))
          | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
          | (1ULL << (MySQLStatementParser::REBUILD - 452))
          | (1ULL << (MySQLStatementParser::RECOVER - 452))
          | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
          | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
          | (1ULL << (MySQLStatementParser::REFERENCE - 452))
          | (1ULL << (MySQLStatementParser::RELAY - 452))
          | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
          | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
          | (1ULL << (MySQLStatementParser::RELOAD - 452))
          | (1ULL << (MySQLStatementParser::REMOVE - 452))
          | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
          | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATION - 517))
          | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RESET - 517))
          | (1ULL << (MySQLStatementParser::RESOURCE - 517))
          | (1ULL << (MySQLStatementParser::RESPECT - 517))
          | (1ULL << (MySQLStatementParser::RESTART - 517))
          | (1ULL << (MySQLStatementParser::RESTORE - 517))
          | (1ULL << (MySQLStatementParser::RESUME - 517))
          | (1ULL << (MySQLStatementParser::RETAIN - 517))
          | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
          | (1ULL << (MySQLStatementParser::RETURNING - 517))
          | (1ULL << (MySQLStatementParser::RETURNS - 517))
          | (1ULL << (MySQLStatementParser::REUSE - 517))
          | (1ULL << (MySQLStatementParser::REVERSE - 517))
          | (1ULL << (MySQLStatementParser::ROLE - 517))
          | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
          | (1ULL << (MySQLStatementParser::ROLLUP - 517))
          | (1ULL << (MySQLStatementParser::ROTATE - 517))
          | (1ULL << (MySQLStatementParser::ROUTINE - 517))
          | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
          | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RTREE - 517))
          | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
          | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
          | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
          | (1ULL << (MySQLStatementParser::SECOND - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
          | (1ULL << (MySQLStatementParser::SECURITY - 517))
          | (1ULL << (MySQLStatementParser::SERIAL - 517))
          | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
          | (1ULL << (MySQLStatementParser::SERVER - 517))
          | (1ULL << (MySQLStatementParser::SESSION - 517))
          | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
          | (1ULL << (MySQLStatementParser::SIGNED - 581))
          | (1ULL << (MySQLStatementParser::SIMPLE - 581))
          | (1ULL << (MySQLStatementParser::SLAVE - 581))
          | (1ULL << (MySQLStatementParser::SLOW - 581))
          | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
          | (1ULL << (MySQLStatementParser::SOCKET - 581))
          | (1ULL << (MySQLStatementParser::SOME - 581))
          | (1ULL << (MySQLStatementParser::SONAME - 581))
          | (1ULL << (MySQLStatementParser::SOUNDS - 581))
          | (1ULL << (MySQLStatementParser::SOURCE - 581))
          | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
          | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
          | (1ULL << (MySQLStatementParser::SRID - 581))
          | (1ULL << (MySQLStatementParser::STACKED - 581))
          | (1ULL << (MySQLStatementParser::START - 581))
          | (1ULL << (MySQLStatementParser::STARTS - 581))
          | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
          | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
          | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
          | (1ULL << (MySQLStatementParser::STATUS - 581))
          | (1ULL << (MySQLStatementParser::STOP - 581))
          | (1ULL << (MySQLStatementParser::STORAGE - 581))
          | (1ULL << (MySQLStatementParser::STREAM - 581))
          | (1ULL << (MySQLStatementParser::STRING - 581))
          | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
          | (1ULL << (MySQLStatementParser::SUBJECT - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
          | (1ULL << (MySQLStatementParser::SUPER - 581))
          | (1ULL << (MySQLStatementParser::SUSPEND - 581))
          | (1ULL << (MySQLStatementParser::SWAPS - 581))
          | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
          | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
          | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
          | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
          | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
          | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
          | (1ULL << (MySQLStatementParser::TEXT - 645))
          | (1ULL << (MySQLStatementParser::THAN - 645))
          | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
          | (1ULL << (MySQLStatementParser::TIES - 645))
          | (1ULL << (MySQLStatementParser::TIME - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
          | (1ULL << (MySQLStatementParser::TLS - 645))
          | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
          | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
          | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
          | (1ULL << (MySQLStatementParser::TYPE - 645))
          | (1ULL << (MySQLStatementParser::TYPES - 645))
          | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
          | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
          | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
          | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
          | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
          | (1ULL << (MySQLStatementParser::UNICODE - 645))
          | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
          | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
          | (1ULL << (MySQLStatementParser::UNTIL - 645))
          | (1ULL << (MySQLStatementParser::UPGRADE - 645))
          | (1ULL << (MySQLStatementParser::USER - 645))
          | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
          | (1ULL << (MySQLStatementParser::USE_FRM - 645))
          | (1ULL << (MySQLStatementParser::VALIDATION - 645))
          | (1ULL << (MySQLStatementParser::VALUE - 645))
          | (1ULL << (MySQLStatementParser::VARIABLES - 645))
          | (1ULL << (MySQLStatementParser::VCPU - 645))
          | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
          | (1ULL << (MySQLStatementParser::WAIT - 710))
          | (1ULL << (MySQLStatementParser::WARNINGS - 710))
          | (1ULL << (MySQLStatementParser::WEEK - 710))
          | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
          | (1ULL << (MySQLStatementParser::WITHOUT - 710))
          | (1ULL << (MySQLStatementParser::WORK - 710))
          | (1ULL << (MySQLStatementParser::WRAPPER - 710))
          | (1ULL << (MySQLStatementParser::X509 - 710))
          | (1ULL << (MySQLStatementParser::XA - 710))
          | (1ULL << (MySQLStatementParser::XID - 710))
          | (1ULL << (MySQLStatementParser::XML - 710))
          | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

        || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
          setState(6299);
          tableList();
        }
        setState(6302);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::REPLICATE_IGNORE_TABLE: {
        enterOuterAlt(_localctx, 4);
        setState(6303);
        match(MySQLStatementParser::REPLICATE_IGNORE_TABLE);
        setState(6304);
        match(MySQLStatementParser::EQ_);
        setState(6305);
        match(MySQLStatementParser::LP_);
        setState(6307);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
          | (1ULL << MySQLStatementParser::MIN)
          | (1ULL << MySQLStatementParser::SUM)
          | (1ULL << MySQLStatementParser::COUNT)
          | (1ULL << MySQLStatementParser::GROUP_CONCAT)
          | (1ULL << MySQLStatementParser::CAST)
          | (1ULL << MySQLStatementParser::POSITION)
          | (1ULL << MySQLStatementParser::SUBSTRING)
          | (1ULL << MySQLStatementParser::SUBSTR)
          | (1ULL << MySQLStatementParser::EXTRACT)
          | (1ULL << MySQLStatementParser::TRIM)
          | (1ULL << MySQLStatementParser::LAST_DAY)
          | (1ULL << MySQLStatementParser::TRADITIONAL)
          | (1ULL << MySQLStatementParser::TREE)
          | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
          | (1ULL << MySQLStatementParser::INSTANT)
          | (1ULL << MySQLStatementParser::INPLACE)
          | (1ULL << MySQLStatementParser::COPY)
          | (1ULL << MySQLStatementParser::UL_BINARY)
          | (1ULL << MySQLStatementParser::AUTOCOMMIT)
          | (1ULL << MySQLStatementParser::INNODB)
          | (1ULL << MySQLStatementParser::REDO_LOG)
          | (1ULL << MySQLStatementParser::ACCOUNT)
          | (1ULL << MySQLStatementParser::ACTION)
          | (1ULL << MySQLStatementParser::ACTIVE)
          | (1ULL << MySQLStatementParser::ADMIN)
          | (1ULL << MySQLStatementParser::AFTER)
          | (1ULL << MySQLStatementParser::AGAINST)
          | (1ULL << MySQLStatementParser::AGGREGATE)
          | (1ULL << MySQLStatementParser::ALGORITHM)
          | (1ULL << MySQLStatementParser::ALWAYS)
          | (1ULL << MySQLStatementParser::ANY)
          | (1ULL << MySQLStatementParser::ASCII)
          | (1ULL << MySQLStatementParser::AT)
          | (1ULL << MySQLStatementParser::ATTRIBUTE)
          | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
          | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
          | (1ULL << MySQLStatementParser::AVG)
          | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
          | (1ULL << MySQLStatementParser::BACKUP)
          | (1ULL << MySQLStatementParser::BEGIN)
          | (1ULL << MySQLStatementParser::BINLOG)
          | (1ULL << MySQLStatementParser::BIT)
          | (1ULL << MySQLStatementParser::BLOCK)
          | (1ULL << MySQLStatementParser::BOOL)
          | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
          | (1ULL << (MySQLStatementParser::BUCKETS - 65))
          | (1ULL << (MySQLStatementParser::BYTE - 65))
          | (1ULL << (MySQLStatementParser::CACHE - 65))
          | (1ULL << (MySQLStatementParser::CASCADED - 65))
          | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
          | (1ULL << (MySQLStatementParser::CHAIN - 65))
          | (1ULL << (MySQLStatementParser::CHANGED - 65))
          | (1ULL << (MySQLStatementParser::CHANNEL - 65))
          | (1ULL << (MySQLStatementParser::CHARSET - 65))
          | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
          | (1ULL << (MySQLStatementParser::CIPHER - 65))
          | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
          | (1ULL << (MySQLStatementParser::CLIENT - 65))
          | (1ULL << (MySQLStatementParser::CLONE - 65))
          | (1ULL << (MySQLStatementParser::CLOSE - 65))
          | (1ULL << (MySQLStatementParser::COALESCE - 65))
          | (1ULL << (MySQLStatementParser::CODE - 65))
          | (1ULL << (MySQLStatementParser::COLLATION - 65))
          | (1ULL << (MySQLStatementParser::COLUMNS - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
          | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
          | (1ULL << (MySQLStatementParser::COMMENT - 65))
          | (1ULL << (MySQLStatementParser::COMMIT - 65))
          | (1ULL << (MySQLStatementParser::COMMITTED - 65))
          | (1ULL << (MySQLStatementParser::COMPACT - 65))
          | (1ULL << (MySQLStatementParser::COMPLETION - 65))
          | (1ULL << (MySQLStatementParser::COMPONENT - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
          | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
          | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
          | (1ULL << (MySQLStatementParser::CONNECTION - 65))
          | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
          | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
          | (1ULL << (MySQLStatementParser::CONTAINS - 65))
          | (1ULL << (MySQLStatementParser::CONTEXT - 65))
          | (1ULL << (MySQLStatementParser::CPU - 65))
          | (1ULL << (MySQLStatementParser::CURRENT - 65))
          | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
          | (1ULL << (MySQLStatementParser::DATAFILE - 129))
          | (1ULL << (MySQLStatementParser::DATE - 129))
          | (1ULL << (MySQLStatementParser::DATETIME - 129))
          | (1ULL << (MySQLStatementParser::DAY - 129))
          | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
          | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
          | (1ULL << (MySQLStatementParser::DEFINER - 129))
          | (1ULL << (MySQLStatementParser::DEFINITION - 129))
          | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
          | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
          | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
          | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
          | (1ULL << (MySQLStatementParser::DISABLE - 129))
          | (1ULL << (MySQLStatementParser::DISCARD - 129))
          | (1ULL << (MySQLStatementParser::DISK - 129))
          | (1ULL << (MySQLStatementParser::DO - 129))
          | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
          | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
          | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
          | (1ULL << (MySQLStatementParser::ENABLE - 129))
          | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
          | (1ULL << (MySQLStatementParser::END - 129))
          | (1ULL << (MySQLStatementParser::ENDS - 129))
          | (1ULL << (MySQLStatementParser::ENFORCED - 129))
          | (1ULL << (MySQLStatementParser::ENGINE - 129))
          | (1ULL << (MySQLStatementParser::ENGINES - 129))
          | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
          | (1ULL << (MySQLStatementParser::ENUM - 129))
          | (1ULL << (MySQLStatementParser::ERROR - 129))
          | (1ULL << (MySQLStatementParser::ERRORS - 129))
          | (1ULL << (MySQLStatementParser::ESCAPE - 129))
          | (1ULL << (MySQLStatementParser::EVENT - 129))
          | (1ULL << (MySQLStatementParser::EVENTS - 129))
          | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
          | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
          | (1ULL << (MySQLStatementParser::EXECUTE - 193))
          | (1ULL << (MySQLStatementParser::EXPANSION - 193))
          | (1ULL << (MySQLStatementParser::EXPIRE - 193))
          | (1ULL << (MySQLStatementParser::EXPORT - 193))
          | (1ULL << (MySQLStatementParser::EXTENDED - 193))
          | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
          | (1ULL << (MySQLStatementParser::FAST - 193))
          | (1ULL << (MySQLStatementParser::FAULTS - 193))
          | (1ULL << (MySQLStatementParser::FIELDS - 193))
          | (1ULL << (MySQLStatementParser::FILE - 193))
          | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
          | (1ULL << (MySQLStatementParser::FILTER - 193))
          | (1ULL << (MySQLStatementParser::FIRST - 193))
          | (1ULL << (MySQLStatementParser::FIXED - 193))
          | (1ULL << (MySQLStatementParser::FLUSH - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
          | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
          | (1ULL << (MySQLStatementParser::FORMAT - 193))
          | (1ULL << (MySQLStatementParser::FULL - 193))
          | (1ULL << (MySQLStatementParser::GENERAL - 193))
          | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
          | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
          | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
          | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
          | (1ULL << (MySQLStatementParser::GLOBAL - 193))
          | (1ULL << (MySQLStatementParser::GRANTS - 193))
          | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
          | (1ULL << (MySQLStatementParser::HANDLER - 193))
          | (1ULL << (MySQLStatementParser::HASH - 193))
          | (1ULL << (MySQLStatementParser::HELP - 193))
          | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
          | (1ULL << (MySQLStatementParser::HISTORY - 193))
          | (1ULL << (MySQLStatementParser::HOST - 193))
          | (1ULL << (MySQLStatementParser::HOSTS - 193))
          | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
          | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
          | (1ULL << (MySQLStatementParser::IMPORT - 259))
          | (1ULL << (MySQLStatementParser::INACTIVE - 259))
          | (1ULL << (MySQLStatementParser::INDEXES - 259))
          | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
          | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
          | (1ULL << (MySQLStatementParser::INSTALL - 259))
          | (1ULL << (MySQLStatementParser::INSTANCE - 259))
          | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
          | (1ULL << (MySQLStatementParser::INVOKER - 259))
          | (1ULL << (MySQLStatementParser::IO - 259))
          | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
          | (1ULL << (MySQLStatementParser::IPC - 259))
          | (1ULL << (MySQLStatementParser::ISOLATION - 259))
          | (1ULL << (MySQLStatementParser::ISSUER - 259))
          | (1ULL << (MySQLStatementParser::JSON - 259))
          | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
          | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
          | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
          | (1ULL << (MySQLStatementParser::LAST - 259))
          | (1ULL << (MySQLStatementParser::LEAVES - 259))
          | (1ULL << (MySQLStatementParser::LESS - 259))
          | (1ULL << (MySQLStatementParser::LEVEL - 259))
          | (1ULL << (MySQLStatementParser::LINESTRING - 259))
          | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
          | (1ULL << (MySQLStatementParser::LOCKED - 324))
          | (1ULL << (MySQLStatementParser::LOCKS - 324))
          | (1ULL << (MySQLStatementParser::LOGFILE - 324))
          | (1ULL << (MySQLStatementParser::LOGS - 324))
          | (1ULL << (MySQLStatementParser::MANAGED - 324))
          | (1ULL << (MySQLStatementParser::MASTER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
          | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
          | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
          | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
          | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
          | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
          | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
          | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
          | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
          | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
          | (1ULL << (MySQLStatementParser::MEDIUM - 324))
          | (1ULL << (MySQLStatementParser::MEMBER - 324))
          | (1ULL << (MySQLStatementParser::MEMORY - 324))
          | (1ULL << (MySQLStatementParser::MERGE - 324))
          | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
          | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
          | (1ULL << (MySQLStatementParser::MIGRATE - 324))
          | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
          | (1ULL << (MySQLStatementParser::MODE - 388))
          | (1ULL << (MySQLStatementParser::MODIFY - 388))
          | (1ULL << (MySQLStatementParser::MONTH - 388))
          | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
          | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
          | (1ULL << (MySQLStatementParser::MUTEX - 388))
          | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
          | (1ULL << (MySQLStatementParser::NAME - 388))
          | (1ULL << (MySQLStatementParser::NAMES - 388))
          | (1ULL << (MySQLStatementParser::NATIONAL - 388))
          | (1ULL << (MySQLStatementParser::NCHAR - 388))
          | (1ULL << (MySQLStatementParser::NDB - 388))
          | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
          | (1ULL << (MySQLStatementParser::NESTED - 388))
          | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
          | (1ULL << (MySQLStatementParser::NEVER - 388))
          | (1ULL << (MySQLStatementParser::NEW - 388))
          | (1ULL << (MySQLStatementParser::NEXT - 388))
          | (1ULL << (MySQLStatementParser::NO - 388))
          | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
          | (1ULL << (MySQLStatementParser::NONE - 388))
          | (1ULL << (MySQLStatementParser::NOWAIT - 388))
          | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
          | (1ULL << (MySQLStatementParser::NULLS - 388))
          | (1ULL << (MySQLStatementParser::NUMBER - 388))
          | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
          | (1ULL << (MySQLStatementParser::OFF - 388))
          | (1ULL << (MySQLStatementParser::OFFSET - 388))
          | (1ULL << (MySQLStatementParser::OJ - 388))
          | (1ULL << (MySQLStatementParser::OLD - 388))
          | (1ULL << (MySQLStatementParser::ONE - 388))
          | (1ULL << (MySQLStatementParser::ONLY - 388))
          | (1ULL << (MySQLStatementParser::OPEN - 388))
          | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
          | (1ULL << (MySQLStatementParser::OPTIONS - 388))
          | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
          | (1ULL << (MySQLStatementParser::OTHERS - 388))
          | (1ULL << (MySQLStatementParser::OWNER - 388))
          | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
          | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
          | (1ULL << (MySQLStatementParser::PARTIAL - 452))
          | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD - 452))
          | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
          | (1ULL << (MySQLStatementParser::PATH - 452))
          | (1ULL << (MySQLStatementParser::PERSIST - 452))
          | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
          | (1ULL << (MySQLStatementParser::PHASE - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN - 452))
          | (1ULL << (MySQLStatementParser::PLUGINS - 452))
          | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
          | (1ULL << (MySQLStatementParser::POINT - 452))
          | (1ULL << (MySQLStatementParser::POLYGON - 452))
          | (1ULL << (MySQLStatementParser::PORT - 452))
          | (1ULL << (MySQLStatementParser::PRECEDES - 452))
          | (1ULL << (MySQLStatementParser::PRECEDING - 452))
          | (1ULL << (MySQLStatementParser::PREPARE - 452))
          | (1ULL << (MySQLStatementParser::PRESERVE - 452))
          | (1ULL << (MySQLStatementParser::PREV - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
          | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
          | (1ULL << (MySQLStatementParser::PROCESS - 452))
          | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
          | (1ULL << (MySQLStatementParser::PROFILE - 452))
          | (1ULL << (MySQLStatementParser::PROFILES - 452))
          | (1ULL << (MySQLStatementParser::PROXY - 452))
          | (1ULL << (MySQLStatementParser::QUARTER - 452))
          | (1ULL << (MySQLStatementParser::QUERY - 452))
          | (1ULL << (MySQLStatementParser::QUICK - 452))
          | (1ULL << (MySQLStatementParser::RANDOM - 452))
          | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
          | (1ULL << (MySQLStatementParser::REBUILD - 452))
          | (1ULL << (MySQLStatementParser::RECOVER - 452))
          | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
          | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
          | (1ULL << (MySQLStatementParser::REFERENCE - 452))
          | (1ULL << (MySQLStatementParser::RELAY - 452))
          | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
          | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
          | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
          | (1ULL << (MySQLStatementParser::RELOAD - 452))
          | (1ULL << (MySQLStatementParser::REMOVE - 452))
          | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
          | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
          | (1ULL << (MySQLStatementParser::REPLICATION - 517))
          | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RESET - 517))
          | (1ULL << (MySQLStatementParser::RESOURCE - 517))
          | (1ULL << (MySQLStatementParser::RESPECT - 517))
          | (1ULL << (MySQLStatementParser::RESTART - 517))
          | (1ULL << (MySQLStatementParser::RESTORE - 517))
          | (1ULL << (MySQLStatementParser::RESUME - 517))
          | (1ULL << (MySQLStatementParser::RETAIN - 517))
          | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
          | (1ULL << (MySQLStatementParser::RETURNING - 517))
          | (1ULL << (MySQLStatementParser::RETURNS - 517))
          | (1ULL << (MySQLStatementParser::REUSE - 517))
          | (1ULL << (MySQLStatementParser::REVERSE - 517))
          | (1ULL << (MySQLStatementParser::ROLE - 517))
          | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
          | (1ULL << (MySQLStatementParser::ROLLUP - 517))
          | (1ULL << (MySQLStatementParser::ROTATE - 517))
          | (1ULL << (MySQLStatementParser::ROUTINE - 517))
          | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
          | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
          | (1ULL << (MySQLStatementParser::RTREE - 517))
          | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
          | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
          | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
          | (1ULL << (MySQLStatementParser::SECOND - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
          | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
          | (1ULL << (MySQLStatementParser::SECURITY - 517))
          | (1ULL << (MySQLStatementParser::SERIAL - 517))
          | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
          | (1ULL << (MySQLStatementParser::SERVER - 517))
          | (1ULL << (MySQLStatementParser::SESSION - 517))
          | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
          | (1ULL << (MySQLStatementParser::SIGNED - 581))
          | (1ULL << (MySQLStatementParser::SIMPLE - 581))
          | (1ULL << (MySQLStatementParser::SLAVE - 581))
          | (1ULL << (MySQLStatementParser::SLOW - 581))
          | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
          | (1ULL << (MySQLStatementParser::SOCKET - 581))
          | (1ULL << (MySQLStatementParser::SOME - 581))
          | (1ULL << (MySQLStatementParser::SONAME - 581))
          | (1ULL << (MySQLStatementParser::SOUNDS - 581))
          | (1ULL << (MySQLStatementParser::SOURCE - 581))
          | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
          | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
          | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
          | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
          | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
          | (1ULL << (MySQLStatementParser::SRID - 581))
          | (1ULL << (MySQLStatementParser::STACKED - 581))
          | (1ULL << (MySQLStatementParser::START - 581))
          | (1ULL << (MySQLStatementParser::STARTS - 581))
          | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
          | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
          | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
          | (1ULL << (MySQLStatementParser::STATUS - 581))
          | (1ULL << (MySQLStatementParser::STOP - 581))
          | (1ULL << (MySQLStatementParser::STORAGE - 581))
          | (1ULL << (MySQLStatementParser::STREAM - 581))
          | (1ULL << (MySQLStatementParser::STRING - 581))
          | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
          | (1ULL << (MySQLStatementParser::SUBJECT - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
          | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
          | (1ULL << (MySQLStatementParser::SUPER - 581))
          | (1ULL << (MySQLStatementParser::SUSPEND - 581))
          | (1ULL << (MySQLStatementParser::SWAPS - 581))
          | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
          | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
          | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
          | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
          | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
          | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
          | (1ULL << (MySQLStatementParser::TEXT - 645))
          | (1ULL << (MySQLStatementParser::THAN - 645))
          | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
          | (1ULL << (MySQLStatementParser::TIES - 645))
          | (1ULL << (MySQLStatementParser::TIME - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
          | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
          | (1ULL << (MySQLStatementParser::TLS - 645))
          | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
          | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
          | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
          | (1ULL << (MySQLStatementParser::TYPE - 645))
          | (1ULL << (MySQLStatementParser::TYPES - 645))
          | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
          | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
          | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
          | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
          | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
          | (1ULL << (MySQLStatementParser::UNICODE - 645))
          | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
          | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
          | (1ULL << (MySQLStatementParser::UNTIL - 645))
          | (1ULL << (MySQLStatementParser::UPGRADE - 645))
          | (1ULL << (MySQLStatementParser::USER - 645))
          | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
          | (1ULL << (MySQLStatementParser::USE_FRM - 645))
          | (1ULL << (MySQLStatementParser::VALIDATION - 645))
          | (1ULL << (MySQLStatementParser::VALUE - 645))
          | (1ULL << (MySQLStatementParser::VARIABLES - 645))
          | (1ULL << (MySQLStatementParser::VCPU - 645))
          | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
          | (1ULL << (MySQLStatementParser::WAIT - 710))
          | (1ULL << (MySQLStatementParser::WARNINGS - 710))
          | (1ULL << (MySQLStatementParser::WEEK - 710))
          | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
          | (1ULL << (MySQLStatementParser::WITHOUT - 710))
          | (1ULL << (MySQLStatementParser::WORK - 710))
          | (1ULL << (MySQLStatementParser::WRAPPER - 710))
          | (1ULL << (MySQLStatementParser::X509 - 710))
          | (1ULL << (MySQLStatementParser::XA - 710))
          | (1ULL << (MySQLStatementParser::XID - 710))
          | (1ULL << (MySQLStatementParser::XML - 710))
          | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

        || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
          setState(6306);
          tableList();
        }
        setState(6309);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE: {
        enterOuterAlt(_localctx, 5);
        setState(6310);
        match(MySQLStatementParser::REPLICATE_WILD_DO_TABLE);
        setState(6311);
        match(MySQLStatementParser::EQ_);
        setState(6312);
        match(MySQLStatementParser::LP_);
        setState(6314);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::SINGLE_QUOTED_TEXT

        || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
          setState(6313);
          wildTables();
        }
        setState(6316);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE: {
        enterOuterAlt(_localctx, 6);
        setState(6317);
        match(MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE);
        setState(6318);
        match(MySQLStatementParser::EQ_);
        setState(6319);
        match(MySQLStatementParser::LP_);
        setState(6321);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::SINGLE_QUOTED_TEXT

        || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
          setState(6320);
          wildTables();
        }
        setState(6323);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::REPLICATE_REWRITE_DB: {
        enterOuterAlt(_localctx, 7);
        setState(6324);
        match(MySQLStatementParser::REPLICATE_REWRITE_DB);
        setState(6325);
        match(MySQLStatementParser::EQ_);
        setState(6326);
        match(MySQLStatementParser::LP_);
        setState(6328);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(6327);
          schemaPairs();
        }
        setState(6330);
        match(MySQLStatementParser::RP_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WildTablesContext ------------------------------------------------------------------

MySQLStatementParser::WildTablesContext::WildTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::WildTableContext *> MySQLStatementParser::WildTablesContext::wildTable() {
  return getRuleContexts<MySQLStatementParser::WildTableContext>();
}

MySQLStatementParser::WildTableContext* MySQLStatementParser::WildTablesContext::wildTable(size_t i) {
  return getRuleContext<MySQLStatementParser::WildTableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::WildTablesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::WildTablesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::WildTablesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWildTables;
}

void MySQLStatementParser::WildTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildTables(this);
}

void MySQLStatementParser::WildTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildTables(this);
}


antlrcpp::Any MySQLStatementParser::WildTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWildTables(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WildTablesContext* MySQLStatementParser::wildTables() {
  WildTablesContext *_localctx = _tracker.createInstance<WildTablesContext>(_ctx, getState());
  enterRule(_localctx, 800, MySQLStatementParser::RuleWildTables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6333);
    wildTable();
    setState(6338);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6334);
      match(MySQLStatementParser::COMMA_);
      setState(6335);
      wildTable();
      setState(6340);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WildTableContext ------------------------------------------------------------------

MySQLStatementParser::WildTableContext::WildTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::String_Context* MySQLStatementParser::WildTableContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::WildTableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWildTable;
}

void MySQLStatementParser::WildTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildTable(this);
}

void MySQLStatementParser::WildTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildTable(this);
}


antlrcpp::Any MySQLStatementParser::WildTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWildTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WildTableContext* MySQLStatementParser::wildTable() {
  WildTableContext *_localctx = _tracker.createInstance<WildTableContext>(_ctx, getState());
  enterRule(_localctx, 802, MySQLStatementParser::RuleWildTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6341);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterMarkerContext ------------------------------------------------------------------

MySQLStatementParser::ParameterMarkerContext::ParameterMarkerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ParameterMarkerContext::QUESTION_() {
  return getToken(MySQLStatementParser::QUESTION_, 0);
}


size_t MySQLStatementParser::ParameterMarkerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleParameterMarker;
}

void MySQLStatementParser::ParameterMarkerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterMarker(this);
}

void MySQLStatementParser::ParameterMarkerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterMarker(this);
}


antlrcpp::Any MySQLStatementParser::ParameterMarkerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitParameterMarker(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ParameterMarkerContext* MySQLStatementParser::parameterMarker() {
  ParameterMarkerContext *_localctx = _tracker.createInstance<ParameterMarkerContext>(_ctx, getState());
  enterRule(_localctx, 804, MySQLStatementParser::RuleParameterMarker);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6343);
    match(MySQLStatementParser::QUESTION_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CustomKeywordContext ------------------------------------------------------------------

MySQLStatementParser::CustomKeywordContext::CustomKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::MAX() {
  return getToken(MySQLStatementParser::MAX, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::MIN() {
  return getToken(MySQLStatementParser::MIN, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::SUM() {
  return getToken(MySQLStatementParser::SUM, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::COUNT() {
  return getToken(MySQLStatementParser::COUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::GROUP_CONCAT() {
  return getToken(MySQLStatementParser::GROUP_CONCAT, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::CAST() {
  return getToken(MySQLStatementParser::CAST, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::POSITION() {
  return getToken(MySQLStatementParser::POSITION, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::SUBSTRING() {
  return getToken(MySQLStatementParser::SUBSTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::SUBSTR() {
  return getToken(MySQLStatementParser::SUBSTR, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::EXTRACT() {
  return getToken(MySQLStatementParser::EXTRACT, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::TRIM() {
  return getToken(MySQLStatementParser::TRIM, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::LAST_DAY() {
  return getToken(MySQLStatementParser::LAST_DAY, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::TRADITIONAL() {
  return getToken(MySQLStatementParser::TRADITIONAL, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::TREE() {
  return getToken(MySQLStatementParser::TREE, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::MYSQL_ADMIN() {
  return getToken(MySQLStatementParser::MYSQL_ADMIN, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::INSTANT() {
  return getToken(MySQLStatementParser::INSTANT, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::INPLACE() {
  return getToken(MySQLStatementParser::INPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::COPY() {
  return getToken(MySQLStatementParser::COPY, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::UL_BINARY() {
  return getToken(MySQLStatementParser::UL_BINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::AUTOCOMMIT() {
  return getToken(MySQLStatementParser::AUTOCOMMIT, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::INNODB() {
  return getToken(MySQLStatementParser::INNODB, 0);
}

tree::TerminalNode* MySQLStatementParser::CustomKeywordContext::REDO_LOG() {
  return getToken(MySQLStatementParser::REDO_LOG, 0);
}


size_t MySQLStatementParser::CustomKeywordContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCustomKeyword;
}

void MySQLStatementParser::CustomKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCustomKeyword(this);
}

void MySQLStatementParser::CustomKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCustomKeyword(this);
}


antlrcpp::Any MySQLStatementParser::CustomKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCustomKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CustomKeywordContext* MySQLStatementParser::customKeyword() {
  CustomKeywordContext *_localctx = _tracker.createInstance<CustomKeywordContext>(_ctx, getState());
  enterRule(_localctx, 806, MySQLStatementParser::RuleCustomKeyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6345);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralsContext ------------------------------------------------------------------

MySQLStatementParser::LiteralsContext::LiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::LiteralsContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::LiteralsContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

MySQLStatementParser::TemporalLiteralsContext* MySQLStatementParser::LiteralsContext::temporalLiterals() {
  return getRuleContext<MySQLStatementParser::TemporalLiteralsContext>(0);
}

MySQLStatementParser::HexadecimalLiteralsContext* MySQLStatementParser::LiteralsContext::hexadecimalLiterals() {
  return getRuleContext<MySQLStatementParser::HexadecimalLiteralsContext>(0);
}

MySQLStatementParser::BitValueLiteralsContext* MySQLStatementParser::LiteralsContext::bitValueLiterals() {
  return getRuleContext<MySQLStatementParser::BitValueLiteralsContext>(0);
}

MySQLStatementParser::BooleanLiteralsContext* MySQLStatementParser::LiteralsContext::booleanLiterals() {
  return getRuleContext<MySQLStatementParser::BooleanLiteralsContext>(0);
}

MySQLStatementParser::NullValueLiteralsContext* MySQLStatementParser::LiteralsContext::nullValueLiterals() {
  return getRuleContext<MySQLStatementParser::NullValueLiteralsContext>(0);
}


size_t MySQLStatementParser::LiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLiterals;
}

void MySQLStatementParser::LiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiterals(this);
}

void MySQLStatementParser::LiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiterals(this);
}


antlrcpp::Any MySQLStatementParser::LiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LiteralsContext* MySQLStatementParser::literals() {
  LiteralsContext *_localctx = _tracker.createInstance<LiteralsContext>(_ctx, getState());
  enterRule(_localctx, 808, MySQLStatementParser::RuleLiterals);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6354);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 817, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6347);
      stringLiterals();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6348);
      numberLiterals();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6349);
      temporalLiterals();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6350);
      hexadecimalLiterals();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6351);
      bitValueLiterals();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6352);
      booleanLiterals();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6353);
      nullValueLiterals();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_Context ------------------------------------------------------------------

MySQLStatementParser::String_Context::String_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::String_Context::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLStatementParser::DOUBLE_QUOTED_TEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::String_Context::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLStatementParser::SINGLE_QUOTED_TEXT, 0);
}


size_t MySQLStatementParser::String_Context::getRuleIndex() const {
  return MySQLStatementParser::RuleString_;
}

void MySQLStatementParser::String_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterString_(this);
}

void MySQLStatementParser::String_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitString_(this);
}


antlrcpp::Any MySQLStatementParser::String_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitString_(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::String_Context* MySQLStatementParser::string_() {
  String_Context *_localctx = _tracker.createInstance<String_Context>(_ctx, getState());
  enterRule(_localctx, 810, MySQLStatementParser::RuleString_);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6356);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::SINGLE_QUOTED_TEXT

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringLiteralsContext ------------------------------------------------------------------

MySQLStatementParser::StringLiteralsContext::StringLiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::String_Context* MySQLStatementParser::StringLiteralsContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::StringLiteralsContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLStatementParser::UNDERSCORE_CHARSET, 0);
}

tree::TerminalNode* MySQLStatementParser::StringLiteralsContext::NCHAR_TEXT() {
  return getToken(MySQLStatementParser::NCHAR_TEXT, 0);
}


size_t MySQLStatementParser::StringLiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStringLiterals;
}

void MySQLStatementParser::StringLiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiterals(this);
}

void MySQLStatementParser::StringLiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiterals(this);
}


antlrcpp::Any MySQLStatementParser::StringLiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStringLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::stringLiterals() {
  StringLiteralsContext *_localctx = _tracker.createInstance<StringLiteralsContext>(_ctx, getState());
  enterRule(_localctx, 812, MySQLStatementParser::RuleStringLiterals);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6363);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
      case MySQLStatementParser::UNDERSCORE_CHARSET: {
        enterOuterAlt(_localctx, 1);
        setState(6359);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::UNDERSCORE_CHARSET) {
          setState(6358);
          match(MySQLStatementParser::UNDERSCORE_CHARSET);
        }
        setState(6361);
        string_();
        break;
      }

      case MySQLStatementParser::NCHAR_TEXT: {
        enterOuterAlt(_localctx, 2);
        setState(6362);
        match(MySQLStatementParser::NCHAR_TEXT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberLiteralsContext ------------------------------------------------------------------

MySQLStatementParser::NumberLiteralsContext::NumberLiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NumberLiteralsContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::NumberLiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNumberLiterals;
}

void MySQLStatementParser::NumberLiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberLiterals(this);
}

void MySQLStatementParser::NumberLiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberLiterals(this);
}


antlrcpp::Any MySQLStatementParser::NumberLiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNumberLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::numberLiterals() {
  NumberLiteralsContext *_localctx = _tracker.createInstance<NumberLiteralsContext>(_ctx, getState());
  enterRule(_localctx, 814, MySQLStatementParser::RuleNumberLiterals);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6365);
    match(MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalLiteralsContext ------------------------------------------------------------------

MySQLStatementParser::TemporalLiteralsContext::TemporalLiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TemporalLiteralsContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLStatementParser::SINGLE_QUOTED_TEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::TemporalLiteralsContext::DATE() {
  return getToken(MySQLStatementParser::DATE, 0);
}

tree::TerminalNode* MySQLStatementParser::TemporalLiteralsContext::TIME() {
  return getToken(MySQLStatementParser::TIME, 0);
}

tree::TerminalNode* MySQLStatementParser::TemporalLiteralsContext::TIMESTAMP() {
  return getToken(MySQLStatementParser::TIMESTAMP, 0);
}


size_t MySQLStatementParser::TemporalLiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTemporalLiterals;
}

void MySQLStatementParser::TemporalLiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalLiterals(this);
}

void MySQLStatementParser::TemporalLiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalLiterals(this);
}


antlrcpp::Any MySQLStatementParser::TemporalLiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTemporalLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TemporalLiteralsContext* MySQLStatementParser::temporalLiterals() {
  TemporalLiteralsContext *_localctx = _tracker.createInstance<TemporalLiteralsContext>(_ctx, getState());
  enterRule(_localctx, 816, MySQLStatementParser::RuleTemporalLiterals);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6367);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DATE || _la == MySQLStatementParser::TIME

    || _la == MySQLStatementParser::TIMESTAMP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6368);
    match(MySQLStatementParser::SINGLE_QUOTED_TEXT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HexadecimalLiteralsContext ------------------------------------------------------------------

MySQLStatementParser::HexadecimalLiteralsContext::HexadecimalLiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::HexadecimalLiteralsContext::HEX_DIGIT_() {
  return getToken(MySQLStatementParser::HEX_DIGIT_, 0);
}

tree::TerminalNode* MySQLStatementParser::HexadecimalLiteralsContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLStatementParser::UNDERSCORE_CHARSET, 0);
}

MySQLStatementParser::CollateClauseContext* MySQLStatementParser::HexadecimalLiteralsContext::collateClause() {
  return getRuleContext<MySQLStatementParser::CollateClauseContext>(0);
}


size_t MySQLStatementParser::HexadecimalLiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHexadecimalLiterals;
}

void MySQLStatementParser::HexadecimalLiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHexadecimalLiterals(this);
}

void MySQLStatementParser::HexadecimalLiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHexadecimalLiterals(this);
}


antlrcpp::Any MySQLStatementParser::HexadecimalLiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHexadecimalLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HexadecimalLiteralsContext* MySQLStatementParser::hexadecimalLiterals() {
  HexadecimalLiteralsContext *_localctx = _tracker.createInstance<HexadecimalLiteralsContext>(_ctx, getState());
  enterRule(_localctx, 818, MySQLStatementParser::RuleHexadecimalLiterals);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6371);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDERSCORE_CHARSET) {
      setState(6370);
      match(MySQLStatementParser::UNDERSCORE_CHARSET);
    }
    setState(6373);
    match(MySQLStatementParser::HEX_DIGIT_);
    setState(6375);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 821, _ctx)) {
    case 1: {
      setState(6374);
      collateClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitValueLiteralsContext ------------------------------------------------------------------

MySQLStatementParser::BitValueLiteralsContext::BitValueLiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BitValueLiteralsContext::BIT_NUM_() {
  return getToken(MySQLStatementParser::BIT_NUM_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitValueLiteralsContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLStatementParser::UNDERSCORE_CHARSET, 0);
}

MySQLStatementParser::CollateClauseContext* MySQLStatementParser::BitValueLiteralsContext::collateClause() {
  return getRuleContext<MySQLStatementParser::CollateClauseContext>(0);
}


size_t MySQLStatementParser::BitValueLiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBitValueLiterals;
}

void MySQLStatementParser::BitValueLiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitValueLiterals(this);
}

void MySQLStatementParser::BitValueLiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitValueLiterals(this);
}


antlrcpp::Any MySQLStatementParser::BitValueLiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBitValueLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BitValueLiteralsContext* MySQLStatementParser::bitValueLiterals() {
  BitValueLiteralsContext *_localctx = _tracker.createInstance<BitValueLiteralsContext>(_ctx, getState());
  enterRule(_localctx, 820, MySQLStatementParser::RuleBitValueLiterals);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6378);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::UNDERSCORE_CHARSET) {
      setState(6377);
      match(MySQLStatementParser::UNDERSCORE_CHARSET);
    }
    setState(6380);
    match(MySQLStatementParser::BIT_NUM_);
    setState(6382);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 823, _ctx)) {
    case 1: {
      setState(6381);
      collateClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanLiteralsContext ------------------------------------------------------------------

MySQLStatementParser::BooleanLiteralsContext::BooleanLiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BooleanLiteralsContext::TRUE() {
  return getToken(MySQLStatementParser::TRUE, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanLiteralsContext::FALSE() {
  return getToken(MySQLStatementParser::FALSE, 0);
}


size_t MySQLStatementParser::BooleanLiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBooleanLiterals;
}

void MySQLStatementParser::BooleanLiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiterals(this);
}

void MySQLStatementParser::BooleanLiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiterals(this);
}


antlrcpp::Any MySQLStatementParser::BooleanLiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBooleanLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BooleanLiteralsContext* MySQLStatementParser::booleanLiterals() {
  BooleanLiteralsContext *_localctx = _tracker.createInstance<BooleanLiteralsContext>(_ctx, getState());
  enterRule(_localctx, 822, MySQLStatementParser::RuleBooleanLiterals);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6384);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FALSE || _la == MySQLStatementParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullValueLiteralsContext ------------------------------------------------------------------

MySQLStatementParser::NullValueLiteralsContext::NullValueLiteralsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NullValueLiteralsContext::NULL() {
  return getToken(MySQLStatementParser::NULL, 0);
}


size_t MySQLStatementParser::NullValueLiteralsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNullValueLiterals;
}

void MySQLStatementParser::NullValueLiteralsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullValueLiterals(this);
}

void MySQLStatementParser::NullValueLiteralsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullValueLiterals(this);
}


antlrcpp::Any MySQLStatementParser::NullValueLiteralsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNullValueLiterals(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NullValueLiteralsContext* MySQLStatementParser::nullValueLiterals() {
  NullValueLiteralsContext *_localctx = _tracker.createInstance<NullValueLiteralsContext>(_ctx, getState());
  enterRule(_localctx, 824, MySQLStatementParser::RuleNullValueLiterals);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6386);
    match(MySQLStatementParser::NULL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollationNameContext ------------------------------------------------------------------

MySQLStatementParser::CollationNameContext::CollationNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::CollationNameContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CollationNameContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}


size_t MySQLStatementParser::CollationNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCollationName;
}

void MySQLStatementParser::CollationNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollationName(this);
}

void MySQLStatementParser::CollationNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollationName(this);
}


antlrcpp::Any MySQLStatementParser::CollationNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCollationName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CollationNameContext* MySQLStatementParser::collationName() {
  CollationNameContext *_localctx = _tracker.createInstance<CollationNameContext>(_ctx, getState());
  enterRule(_localctx, 826, MySQLStatementParser::RuleCollationName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6390);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(6388);
        textOrIdentifier();
        break;
      }

      case MySQLStatementParser::BINARY: {
        enterOuterAlt(_localctx, 2);
        setState(6389);
        match(MySQLStatementParser::BINARY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

MySQLStatementParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IdentifierContext::IDENTIFIER_() {
  return getToken(MySQLStatementParser::IDENTIFIER_, 0);
}

MySQLStatementParser::UnreservedWordContext* MySQLStatementParser::IdentifierContext::unreservedWord() {
  return getRuleContext<MySQLStatementParser::UnreservedWordContext>(0);
}

MySQLStatementParser::CustomKeywordContext* MySQLStatementParser::IdentifierContext::customKeyword() {
  return getRuleContext<MySQLStatementParser::CustomKeywordContext>(0);
}

tree::TerminalNode* MySQLStatementParser::IdentifierContext::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLStatementParser::DOUBLE_QUOTED_TEXT, 0);
}


size_t MySQLStatementParser::IdentifierContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIdentifier;
}

void MySQLStatementParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void MySQLStatementParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}


antlrcpp::Any MySQLStatementParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 828, MySQLStatementParser::RuleIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6396);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::IDENTIFIER_: {
        enterOuterAlt(_localctx, 1);
        setState(6392);
        match(MySQLStatementParser::IDENTIFIER_);
        break;
      }

      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR: {
        enterOuterAlt(_localctx, 2);
        setState(6393);
        unreservedWord();
        break;
      }

      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG: {
        enterOuterAlt(_localctx, 3);
        setState(6394);
        customKeyword();
        break;
      }

      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 4);
        setState(6395);
        match(MySQLStatementParser::DOUBLE_QUOTED_TEXT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnreservedWordContext ------------------------------------------------------------------

MySQLStatementParser::UnreservedWordContext::UnreservedWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ACCOUNT() {
  return getToken(MySQLStatementParser::ACCOUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ACTION() {
  return getToken(MySQLStatementParser::ACTION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ACTIVE() {
  return getToken(MySQLStatementParser::ACTIVE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ADMIN() {
  return getToken(MySQLStatementParser::ADMIN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AFTER() {
  return getToken(MySQLStatementParser::AFTER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AGAINST() {
  return getToken(MySQLStatementParser::AGAINST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AGGREGATE() {
  return getToken(MySQLStatementParser::AGGREGATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ALGORITHM() {
  return getToken(MySQLStatementParser::ALGORITHM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ALWAYS() {
  return getToken(MySQLStatementParser::ALWAYS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ANY() {
  return getToken(MySQLStatementParser::ANY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ASCII() {
  return getToken(MySQLStatementParser::ASCII, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AT() {
  return getToken(MySQLStatementParser::AT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ATTRIBUTE() {
  return getToken(MySQLStatementParser::ATTRIBUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AUTOEXTEND_SIZE() {
  return getToken(MySQLStatementParser::AUTOEXTEND_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AUTO_INCREMENT() {
  return getToken(MySQLStatementParser::AUTO_INCREMENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AVG() {
  return getToken(MySQLStatementParser::AVG, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::AVG_ROW_LENGTH() {
  return getToken(MySQLStatementParser::AVG_ROW_LENGTH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BACKUP() {
  return getToken(MySQLStatementParser::BACKUP, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BEGIN() {
  return getToken(MySQLStatementParser::BEGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BINLOG() {
  return getToken(MySQLStatementParser::BINLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BIT() {
  return getToken(MySQLStatementParser::BIT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BLOCK() {
  return getToken(MySQLStatementParser::BLOCK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BOOL() {
  return getToken(MySQLStatementParser::BOOL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BOOLEAN() {
  return getToken(MySQLStatementParser::BOOLEAN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BTREE() {
  return getToken(MySQLStatementParser::BTREE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BUCKETS() {
  return getToken(MySQLStatementParser::BUCKETS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::BYTE() {
  return getToken(MySQLStatementParser::BYTE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CACHE() {
  return getToken(MySQLStatementParser::CACHE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CASCADED() {
  return getToken(MySQLStatementParser::CASCADED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CATALOG_NAME() {
  return getToken(MySQLStatementParser::CATALOG_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CHAIN() {
  return getToken(MySQLStatementParser::CHAIN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CHANGED() {
  return getToken(MySQLStatementParser::CHANGED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CHANNEL() {
  return getToken(MySQLStatementParser::CHANNEL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CHARSET() {
  return getToken(MySQLStatementParser::CHARSET, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CHECKSUM() {
  return getToken(MySQLStatementParser::CHECKSUM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CIPHER() {
  return getToken(MySQLStatementParser::CIPHER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CLASS_ORIGIN() {
  return getToken(MySQLStatementParser::CLASS_ORIGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CLIENT() {
  return getToken(MySQLStatementParser::CLIENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CLONE() {
  return getToken(MySQLStatementParser::CLONE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CLOSE() {
  return getToken(MySQLStatementParser::CLOSE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COALESCE() {
  return getToken(MySQLStatementParser::COALESCE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CODE() {
  return getToken(MySQLStatementParser::CODE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COLLATION() {
  return getToken(MySQLStatementParser::COLLATION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COLUMNS() {
  return getToken(MySQLStatementParser::COLUMNS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COLUMN_FORMAT() {
  return getToken(MySQLStatementParser::COLUMN_FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COLUMN_NAME() {
  return getToken(MySQLStatementParser::COLUMN_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMMENT() {
  return getToken(MySQLStatementParser::COMMENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMMIT() {
  return getToken(MySQLStatementParser::COMMIT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMMITTED() {
  return getToken(MySQLStatementParser::COMMITTED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMPACT() {
  return getToken(MySQLStatementParser::COMPACT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMPLETION() {
  return getToken(MySQLStatementParser::COMPLETION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMPONENT() {
  return getToken(MySQLStatementParser::COMPONENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMPRESSED() {
  return getToken(MySQLStatementParser::COMPRESSED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::COMPRESSION() {
  return getToken(MySQLStatementParser::COMPRESSION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONCURRENT() {
  return getToken(MySQLStatementParser::CONCURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONNECTION() {
  return getToken(MySQLStatementParser::CONNECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONSISTENT() {
  return getToken(MySQLStatementParser::CONSISTENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONSTRAINT_CATALOG() {
  return getToken(MySQLStatementParser::CONSTRAINT_CATALOG, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONSTRAINT_NAME() {
  return getToken(MySQLStatementParser::CONSTRAINT_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONSTRAINT_SCHEMA() {
  return getToken(MySQLStatementParser::CONSTRAINT_SCHEMA, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONTAINS() {
  return getToken(MySQLStatementParser::CONTAINS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CONTEXT() {
  return getToken(MySQLStatementParser::CONTEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CPU() {
  return getToken(MySQLStatementParser::CPU, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CURRENT() {
  return getToken(MySQLStatementParser::CURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::CURSOR_NAME() {
  return getToken(MySQLStatementParser::CURSOR_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DATA() {
  return getToken(MySQLStatementParser::DATA, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DATAFILE() {
  return getToken(MySQLStatementParser::DATAFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DATE() {
  return getToken(MySQLStatementParser::DATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DATETIME() {
  return getToken(MySQLStatementParser::DATETIME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DAY() {
  return getToken(MySQLStatementParser::DAY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DEFAULT_AUTH() {
  return getToken(MySQLStatementParser::DEFAULT_AUTH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DEFINER() {
  return getToken(MySQLStatementParser::DEFINER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DEFINITION() {
  return getToken(MySQLStatementParser::DEFINITION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DEALLOCATE() {
  return getToken(MySQLStatementParser::DEALLOCATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DELAY_KEY_WRITE() {
  return getToken(MySQLStatementParser::DELAY_KEY_WRITE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DESCRIPTION() {
  return getToken(MySQLStatementParser::DESCRIPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DIAGNOSTICS() {
  return getToken(MySQLStatementParser::DIAGNOSTICS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DIRECTORY() {
  return getToken(MySQLStatementParser::DIRECTORY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DISABLE() {
  return getToken(MySQLStatementParser::DISABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DISCARD() {
  return getToken(MySQLStatementParser::DISCARD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DISK() {
  return getToken(MySQLStatementParser::DISK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DO() {
  return getToken(MySQLStatementParser::DO, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DUMPFILE() {
  return getToken(MySQLStatementParser::DUMPFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DUPLICATE() {
  return getToken(MySQLStatementParser::DUPLICATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::DYNAMIC() {
  return getToken(MySQLStatementParser::DYNAMIC, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENABLE() {
  return getToken(MySQLStatementParser::ENABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENCRYPTION() {
  return getToken(MySQLStatementParser::ENCRYPTION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENFORCED() {
  return getToken(MySQLStatementParser::ENFORCED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENDS() {
  return getToken(MySQLStatementParser::ENDS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENGINE() {
  return getToken(MySQLStatementParser::ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENGINES() {
  return getToken(MySQLStatementParser::ENGINES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENGINE_ATTRIBUTE() {
  return getToken(MySQLStatementParser::ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ENUM() {
  return getToken(MySQLStatementParser::ENUM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ERROR() {
  return getToken(MySQLStatementParser::ERROR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ERRORS() {
  return getToken(MySQLStatementParser::ERRORS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ESCAPE() {
  return getToken(MySQLStatementParser::ESCAPE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EVENT() {
  return getToken(MySQLStatementParser::EVENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EVENTS() {
  return getToken(MySQLStatementParser::EVENTS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EVERY() {
  return getToken(MySQLStatementParser::EVERY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXCHANGE() {
  return getToken(MySQLStatementParser::EXCHANGE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXCLUDE() {
  return getToken(MySQLStatementParser::EXCLUDE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXECUTE() {
  return getToken(MySQLStatementParser::EXECUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXPANSION() {
  return getToken(MySQLStatementParser::EXPANSION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXPIRE() {
  return getToken(MySQLStatementParser::EXPIRE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXPORT() {
  return getToken(MySQLStatementParser::EXPORT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::EXTENT_SIZE() {
  return getToken(MySQLStatementParser::EXTENT_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FAILED_LOGIN_ATTEMPTS() {
  return getToken(MySQLStatementParser::FAILED_LOGIN_ATTEMPTS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FAST() {
  return getToken(MySQLStatementParser::FAST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FAULTS() {
  return getToken(MySQLStatementParser::FAULTS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FIELDS() {
  return getToken(MySQLStatementParser::FIELDS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FILE() {
  return getToken(MySQLStatementParser::FILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FILE_BLOCK_SIZE() {
  return getToken(MySQLStatementParser::FILE_BLOCK_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FILTER() {
  return getToken(MySQLStatementParser::FILTER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FIRST() {
  return getToken(MySQLStatementParser::FIRST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FIXED() {
  return getToken(MySQLStatementParser::FIXED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FLUSH() {
  return getToken(MySQLStatementParser::FLUSH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FOLLOWING() {
  return getToken(MySQLStatementParser::FOLLOWING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FOLLOWS() {
  return getToken(MySQLStatementParser::FOLLOWS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FORMAT() {
  return getToken(MySQLStatementParser::FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::FULL() {
  return getToken(MySQLStatementParser::FULL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GENERAL() {
  return getToken(MySQLStatementParser::GENERAL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GEOMCOLLECTION() {
  return getToken(MySQLStatementParser::GEOMCOLLECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GEOMETRY() {
  return getToken(MySQLStatementParser::GEOMETRY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GEOMETRYCOLLECTION() {
  return getToken(MySQLStatementParser::GEOMETRYCOLLECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GET_FORMAT() {
  return getToken(MySQLStatementParser::GET_FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GET_MASTER_PUBLIC_KEY() {
  return getToken(MySQLStatementParser::GET_MASTER_PUBLIC_KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GLOBAL() {
  return getToken(MySQLStatementParser::GLOBAL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GRANTS() {
  return getToken(MySQLStatementParser::GRANTS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::GROUP_REPLICATION() {
  return getToken(MySQLStatementParser::GROUP_REPLICATION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HANDLER() {
  return getToken(MySQLStatementParser::HANDLER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HASH() {
  return getToken(MySQLStatementParser::HASH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HELP() {
  return getToken(MySQLStatementParser::HELP, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HISTOGRAM() {
  return getToken(MySQLStatementParser::HISTOGRAM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HISTORY() {
  return getToken(MySQLStatementParser::HISTORY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HOST() {
  return getToken(MySQLStatementParser::HOST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HOSTS() {
  return getToken(MySQLStatementParser::HOSTS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::HOUR() {
  return getToken(MySQLStatementParser::HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::IDENTIFIED() {
  return getToken(MySQLStatementParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::IGNORE_SERVER_IDS() {
  return getToken(MySQLStatementParser::IGNORE_SERVER_IDS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::IMPORT() {
  return getToken(MySQLStatementParser::IMPORT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INACTIVE() {
  return getToken(MySQLStatementParser::INACTIVE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INDEXES() {
  return getToken(MySQLStatementParser::INDEXES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INITIAL_SIZE() {
  return getToken(MySQLStatementParser::INITIAL_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INSERT_METHOD() {
  return getToken(MySQLStatementParser::INSERT_METHOD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INSTALL() {
  return getToken(MySQLStatementParser::INSTALL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INSTANCE() {
  return getToken(MySQLStatementParser::INSTANCE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INVISIBLE() {
  return getToken(MySQLStatementParser::INVISIBLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::INVOKER() {
  return getToken(MySQLStatementParser::INVOKER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::IO() {
  return getToken(MySQLStatementParser::IO, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::IO_THREAD() {
  return getToken(MySQLStatementParser::IO_THREAD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::IPC() {
  return getToken(MySQLStatementParser::IPC, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ISOLATION() {
  return getToken(MySQLStatementParser::ISOLATION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ISSUER() {
  return getToken(MySQLStatementParser::ISSUER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::JSON() {
  return getToken(MySQLStatementParser::JSON, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::JSON_VALUE() {
  return getToken(MySQLStatementParser::JSON_VALUE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::KEY_BLOCK_SIZE() {
  return getToken(MySQLStatementParser::KEY_BLOCK_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LANGUAGE() {
  return getToken(MySQLStatementParser::LANGUAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LAST() {
  return getToken(MySQLStatementParser::LAST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LEAVES() {
  return getToken(MySQLStatementParser::LEAVES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LESS() {
  return getToken(MySQLStatementParser::LESS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LEVEL() {
  return getToken(MySQLStatementParser::LEVEL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LINESTRING() {
  return getToken(MySQLStatementParser::LINESTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LIST() {
  return getToken(MySQLStatementParser::LIST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LOCKED() {
  return getToken(MySQLStatementParser::LOCKED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LOCKS() {
  return getToken(MySQLStatementParser::LOCKS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LOGFILE() {
  return getToken(MySQLStatementParser::LOGFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::LOGS() {
  return getToken(MySQLStatementParser::LOGS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MANAGED() {
  return getToken(MySQLStatementParser::MANAGED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER() {
  return getToken(MySQLStatementParser::MASTER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_AUTO_POSITION() {
  return getToken(MySQLStatementParser::MASTER_AUTO_POSITION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_COMPRESSION_ALGORITHMS() {
  return getToken(MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_CONNECT_RETRY() {
  return getToken(MySQLStatementParser::MASTER_CONNECT_RETRY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_DELAY() {
  return getToken(MySQLStatementParser::MASTER_DELAY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_HEARTBEAT_PERIOD() {
  return getToken(MySQLStatementParser::MASTER_HEARTBEAT_PERIOD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_HOST() {
  return getToken(MySQLStatementParser::MASTER_HOST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_LOG_FILE() {
  return getToken(MySQLStatementParser::MASTER_LOG_FILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_LOG_POS() {
  return getToken(MySQLStatementParser::MASTER_LOG_POS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_PASSWORD() {
  return getToken(MySQLStatementParser::MASTER_PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_PUBLIC_KEY_PATH() {
  return getToken(MySQLStatementParser::MASTER_PUBLIC_KEY_PATH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_PORT() {
  return getToken(MySQLStatementParser::MASTER_PORT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_RETRY_COUNT() {
  return getToken(MySQLStatementParser::MASTER_RETRY_COUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SERVER_ID() {
  return getToken(MySQLStatementParser::MASTER_SERVER_ID, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL() {
  return getToken(MySQLStatementParser::MASTER_SSL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL_CA() {
  return getToken(MySQLStatementParser::MASTER_SSL_CA, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL_CAPATH() {
  return getToken(MySQLStatementParser::MASTER_SSL_CAPATH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL_CERT() {
  return getToken(MySQLStatementParser::MASTER_SSL_CERT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL_CIPHER() {
  return getToken(MySQLStatementParser::MASTER_SSL_CIPHER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL_CRL() {
  return getToken(MySQLStatementParser::MASTER_SSL_CRL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL_CRLPATH() {
  return getToken(MySQLStatementParser::MASTER_SSL_CRLPATH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_SSL_KEY() {
  return getToken(MySQLStatementParser::MASTER_SSL_KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_TLS_CIPHERSUITES() {
  return getToken(MySQLStatementParser::MASTER_TLS_CIPHERSUITES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_TLS_VERSION() {
  return getToken(MySQLStatementParser::MASTER_TLS_VERSION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_USER() {
  return getToken(MySQLStatementParser::MASTER_USER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MASTER_ZSTD_COMPRESSION_LEVEL() {
  return getToken(MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MAX_CONNECTIONS_PER_HOUR() {
  return getToken(MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MAX_QUERIES_PER_HOUR() {
  return getToken(MySQLStatementParser::MAX_QUERIES_PER_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MAX_ROWS() {
  return getToken(MySQLStatementParser::MAX_ROWS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MAX_SIZE() {
  return getToken(MySQLStatementParser::MAX_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MAX_UPDATES_PER_HOUR() {
  return getToken(MySQLStatementParser::MAX_UPDATES_PER_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MAX_USER_CONNECTIONS() {
  return getToken(MySQLStatementParser::MAX_USER_CONNECTIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MEDIUM() {
  return getToken(MySQLStatementParser::MEDIUM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MEMORY() {
  return getToken(MySQLStatementParser::MEMORY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MERGE() {
  return getToken(MySQLStatementParser::MERGE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MESSAGE_TEXT() {
  return getToken(MySQLStatementParser::MESSAGE_TEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MICROSECOND() {
  return getToken(MySQLStatementParser::MICROSECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MIGRATE() {
  return getToken(MySQLStatementParser::MIGRATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MINUTE() {
  return getToken(MySQLStatementParser::MINUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MIN_ROWS() {
  return getToken(MySQLStatementParser::MIN_ROWS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MODE() {
  return getToken(MySQLStatementParser::MODE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MODIFY() {
  return getToken(MySQLStatementParser::MODIFY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MONTH() {
  return getToken(MySQLStatementParser::MONTH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MULTILINESTRING() {
  return getToken(MySQLStatementParser::MULTILINESTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MULTIPOINT() {
  return getToken(MySQLStatementParser::MULTIPOINT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MULTIPOLYGON() {
  return getToken(MySQLStatementParser::MULTIPOLYGON, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MUTEX() {
  return getToken(MySQLStatementParser::MUTEX, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MYSQL_ERRNO() {
  return getToken(MySQLStatementParser::MYSQL_ERRNO, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NAME() {
  return getToken(MySQLStatementParser::NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NAMES() {
  return getToken(MySQLStatementParser::NAMES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NATIONAL() {
  return getToken(MySQLStatementParser::NATIONAL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NCHAR() {
  return getToken(MySQLStatementParser::NCHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NDB() {
  return getToken(MySQLStatementParser::NDB, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NDBCLUSTER() {
  return getToken(MySQLStatementParser::NDBCLUSTER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NESTED() {
  return getToken(MySQLStatementParser::NESTED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NETWORK_NAMESPACE() {
  return getToken(MySQLStatementParser::NETWORK_NAMESPACE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NEVER() {
  return getToken(MySQLStatementParser::NEVER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NEW() {
  return getToken(MySQLStatementParser::NEW, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NEXT() {
  return getToken(MySQLStatementParser::NEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NO() {
  return getToken(MySQLStatementParser::NO, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NODEGROUP() {
  return getToken(MySQLStatementParser::NODEGROUP, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NONE() {
  return getToken(MySQLStatementParser::NONE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NOWAIT() {
  return getToken(MySQLStatementParser::NOWAIT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NO_WAIT() {
  return getToken(MySQLStatementParser::NO_WAIT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NULLS() {
  return getToken(MySQLStatementParser::NULLS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NUMBER() {
  return getToken(MySQLStatementParser::NUMBER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::NVARCHAR() {
  return getToken(MySQLStatementParser::NVARCHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OFFSET() {
  return getToken(MySQLStatementParser::OFFSET, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OFF() {
  return getToken(MySQLStatementParser::OFF, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OJ() {
  return getToken(MySQLStatementParser::OJ, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OLD() {
  return getToken(MySQLStatementParser::OLD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ONE() {
  return getToken(MySQLStatementParser::ONE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ONLY() {
  return getToken(MySQLStatementParser::ONLY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OPEN() {
  return getToken(MySQLStatementParser::OPEN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OPTIONAL() {
  return getToken(MySQLStatementParser::OPTIONAL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OPTIONS() {
  return getToken(MySQLStatementParser::OPTIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ORDINALITY() {
  return getToken(MySQLStatementParser::ORDINALITY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OTHERS() {
  return getToken(MySQLStatementParser::OTHERS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::OWNER() {
  return getToken(MySQLStatementParser::OWNER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PACK_KEYS() {
  return getToken(MySQLStatementParser::PACK_KEYS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PAGE() {
  return getToken(MySQLStatementParser::PAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PARSER() {
  return getToken(MySQLStatementParser::PARSER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PARTIAL() {
  return getToken(MySQLStatementParser::PARTIAL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PARTITIONING() {
  return getToken(MySQLStatementParser::PARTITIONING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PASSWORD() {
  return getToken(MySQLStatementParser::PASSWORD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PASSWORD_LOCK_TIME() {
  return getToken(MySQLStatementParser::PASSWORD_LOCK_TIME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PATH() {
  return getToken(MySQLStatementParser::PATH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PERSIST() {
  return getToken(MySQLStatementParser::PERSIST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PERSIST_ONLY() {
  return getToken(MySQLStatementParser::PERSIST_ONLY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PHASE() {
  return getToken(MySQLStatementParser::PHASE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PLUGIN() {
  return getToken(MySQLStatementParser::PLUGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PLUGINS() {
  return getToken(MySQLStatementParser::PLUGINS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PLUGIN_DIR() {
  return getToken(MySQLStatementParser::PLUGIN_DIR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::POINT() {
  return getToken(MySQLStatementParser::POINT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::POLYGON() {
  return getToken(MySQLStatementParser::POLYGON, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PORT() {
  return getToken(MySQLStatementParser::PORT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PRECEDES() {
  return getToken(MySQLStatementParser::PRECEDES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PRECEDING() {
  return getToken(MySQLStatementParser::PRECEDING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PREPARE() {
  return getToken(MySQLStatementParser::PREPARE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PRESERVE() {
  return getToken(MySQLStatementParser::PRESERVE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PREV() {
  return getToken(MySQLStatementParser::PREV, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PRIVILEGES() {
  return getToken(MySQLStatementParser::PRIVILEGES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PRIVILEGE_CHECKS_USER() {
  return getToken(MySQLStatementParser::PRIVILEGE_CHECKS_USER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PROCESS() {
  return getToken(MySQLStatementParser::PROCESS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PROCESSLIST() {
  return getToken(MySQLStatementParser::PROCESSLIST, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PROFILE() {
  return getToken(MySQLStatementParser::PROFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PROFILES() {
  return getToken(MySQLStatementParser::PROFILES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::PROXY() {
  return getToken(MySQLStatementParser::PROXY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::QUARTER() {
  return getToken(MySQLStatementParser::QUARTER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::QUERY() {
  return getToken(MySQLStatementParser::QUERY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::QUICK() {
  return getToken(MySQLStatementParser::QUICK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RANDOM() {
  return getToken(MySQLStatementParser::RANDOM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::READ_ONLY() {
  return getToken(MySQLStatementParser::READ_ONLY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REBUILD() {
  return getToken(MySQLStatementParser::REBUILD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RECOVER() {
  return getToken(MySQLStatementParser::RECOVER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REDO_BUFFER_SIZE() {
  return getToken(MySQLStatementParser::REDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REDUNDANT() {
  return getToken(MySQLStatementParser::REDUNDANT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REFERENCE() {
  return getToken(MySQLStatementParser::REFERENCE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RELAY() {
  return getToken(MySQLStatementParser::RELAY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RELAYLOG() {
  return getToken(MySQLStatementParser::RELAYLOG, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RELAY_LOG_FILE() {
  return getToken(MySQLStatementParser::RELAY_LOG_FILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RELAY_LOG_POS() {
  return getToken(MySQLStatementParser::RELAY_LOG_POS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RELAY_THREAD() {
  return getToken(MySQLStatementParser::RELAY_THREAD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RELOAD() {
  return getToken(MySQLStatementParser::RELOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REMOVE() {
  return getToken(MySQLStatementParser::REMOVE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REORGANIZE() {
  return getToken(MySQLStatementParser::REORGANIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPAIR() {
  return getToken(MySQLStatementParser::REPAIR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPEATABLE() {
  return getToken(MySQLStatementParser::REPEATABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATE_DO_DB() {
  return getToken(MySQLStatementParser::REPLICATE_DO_DB, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATE_DO_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_DO_TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATE_IGNORE_DB() {
  return getToken(MySQLStatementParser::REPLICATE_IGNORE_DB, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATE_IGNORE_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATE_REWRITE_DB() {
  return getToken(MySQLStatementParser::REPLICATE_REWRITE_DB, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATE_WILD_DO_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_WILD_DO_TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATE_WILD_IGNORE_TABLE() {
  return getToken(MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REPLICATION() {
  return getToken(MySQLStatementParser::REPLICATION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REQUIRE_ROW_FORMAT() {
  return getToken(MySQLStatementParser::REQUIRE_ROW_FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RESET() {
  return getToken(MySQLStatementParser::RESET, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RESOURCE() {
  return getToken(MySQLStatementParser::RESOURCE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RESPECT() {
  return getToken(MySQLStatementParser::RESPECT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RESTART() {
  return getToken(MySQLStatementParser::RESTART, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RESTORE() {
  return getToken(MySQLStatementParser::RESTORE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RESUME() {
  return getToken(MySQLStatementParser::RESUME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RETAIN() {
  return getToken(MySQLStatementParser::RETAIN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RETURNED_SQLSTATE() {
  return getToken(MySQLStatementParser::RETURNED_SQLSTATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RETURNING() {
  return getToken(MySQLStatementParser::RETURNING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RETURNS() {
  return getToken(MySQLStatementParser::RETURNS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REUSE() {
  return getToken(MySQLStatementParser::REUSE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::REVERSE() {
  return getToken(MySQLStatementParser::REVERSE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ROLE() {
  return getToken(MySQLStatementParser::ROLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ROLLBACK() {
  return getToken(MySQLStatementParser::ROLLBACK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ROLLUP() {
  return getToken(MySQLStatementParser::ROLLUP, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ROTATE() {
  return getToken(MySQLStatementParser::ROTATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ROUTINE() {
  return getToken(MySQLStatementParser::ROUTINE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ROW_COUNT() {
  return getToken(MySQLStatementParser::ROW_COUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::ROW_FORMAT() {
  return getToken(MySQLStatementParser::ROW_FORMAT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::RTREE() {
  return getToken(MySQLStatementParser::RTREE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SAVEPOINT() {
  return getToken(MySQLStatementParser::SAVEPOINT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SCHEDULE() {
  return getToken(MySQLStatementParser::SCHEDULE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SCHEMA_NAME() {
  return getToken(MySQLStatementParser::SCHEMA_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SECOND() {
  return getToken(MySQLStatementParser::SECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SECONDARY() {
  return getToken(MySQLStatementParser::SECONDARY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SECONDARY_ENGINE() {
  return getToken(MySQLStatementParser::SECONDARY_ENGINE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SECONDARY_ENGINE_ATTRIBUTE() {
  return getToken(MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SECONDARY_LOAD() {
  return getToken(MySQLStatementParser::SECONDARY_LOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SECONDARY_UNLOAD() {
  return getToken(MySQLStatementParser::SECONDARY_UNLOAD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SECURITY() {
  return getToken(MySQLStatementParser::SECURITY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SERIAL() {
  return getToken(MySQLStatementParser::SERIAL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SERIALIZABLE() {
  return getToken(MySQLStatementParser::SERIALIZABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SERVER() {
  return getToken(MySQLStatementParser::SERVER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SESSION() {
  return getToken(MySQLStatementParser::SESSION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SHARE() {
  return getToken(MySQLStatementParser::SHARE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SHUTDOWN() {
  return getToken(MySQLStatementParser::SHUTDOWN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SIGNED() {
  return getToken(MySQLStatementParser::SIGNED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SIMPLE() {
  return getToken(MySQLStatementParser::SIMPLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SLAVE() {
  return getToken(MySQLStatementParser::SLAVE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SLOW() {
  return getToken(MySQLStatementParser::SLOW, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SNAPSHOT() {
  return getToken(MySQLStatementParser::SNAPSHOT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SOCKET() {
  return getToken(MySQLStatementParser::SOCKET, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SOME() {
  return getToken(MySQLStatementParser::SOME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SONAME() {
  return getToken(MySQLStatementParser::SONAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SOUNDS() {
  return getToken(MySQLStatementParser::SOUNDS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SOURCE() {
  return getToken(MySQLStatementParser::SOURCE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_AFTER_GTIDS() {
  return getToken(MySQLStatementParser::SQL_AFTER_GTIDS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_AFTER_MTS_GAPS() {
  return getToken(MySQLStatementParser::SQL_AFTER_MTS_GAPS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_BEFORE_GTIDS() {
  return getToken(MySQLStatementParser::SQL_BEFORE_GTIDS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_BUFFER_RESULT() {
  return getToken(MySQLStatementParser::SQL_BUFFER_RESULT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_NO_CACHE() {
  return getToken(MySQLStatementParser::SQL_NO_CACHE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_THREAD() {
  return getToken(MySQLStatementParser::SQL_THREAD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_DAY() {
  return getToken(MySQLStatementParser::SQL_TSI_DAY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_HOUR() {
  return getToken(MySQLStatementParser::SQL_TSI_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_MINUTE() {
  return getToken(MySQLStatementParser::SQL_TSI_MINUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_MONTH() {
  return getToken(MySQLStatementParser::SQL_TSI_MONTH, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_QUARTER() {
  return getToken(MySQLStatementParser::SQL_TSI_QUARTER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_SECOND() {
  return getToken(MySQLStatementParser::SQL_TSI_SECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_WEEK() {
  return getToken(MySQLStatementParser::SQL_TSI_WEEK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_TSI_YEAR() {
  return getToken(MySQLStatementParser::SQL_TSI_YEAR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SRID() {
  return getToken(MySQLStatementParser::SRID, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STACKED() {
  return getToken(MySQLStatementParser::STACKED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::START() {
  return getToken(MySQLStatementParser::START, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STARTS() {
  return getToken(MySQLStatementParser::STARTS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STATS_AUTO_RECALC() {
  return getToken(MySQLStatementParser::STATS_AUTO_RECALC, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STATS_PERSISTENT() {
  return getToken(MySQLStatementParser::STATS_PERSISTENT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STATS_SAMPLE_PAGES() {
  return getToken(MySQLStatementParser::STATS_SAMPLE_PAGES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STATUS() {
  return getToken(MySQLStatementParser::STATUS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STOP() {
  return getToken(MySQLStatementParser::STOP, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STORAGE() {
  return getToken(MySQLStatementParser::STORAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STREAM() {
  return getToken(MySQLStatementParser::STREAM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::STRING() {
  return getToken(MySQLStatementParser::STRING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SUBCLASS_ORIGIN() {
  return getToken(MySQLStatementParser::SUBCLASS_ORIGIN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SUBJECT() {
  return getToken(MySQLStatementParser::SUBJECT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SUBPARTITION() {
  return getToken(MySQLStatementParser::SUBPARTITION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SUBPARTITIONS() {
  return getToken(MySQLStatementParser::SUBPARTITIONS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SUPER() {
  return getToken(MySQLStatementParser::SUPER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SUSPEND() {
  return getToken(MySQLStatementParser::SUSPEND, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SWAPS() {
  return getToken(MySQLStatementParser::SWAPS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SWITCHES() {
  return getToken(MySQLStatementParser::SWITCHES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::SQL_CACHE() {
  return getToken(MySQLStatementParser::SQL_CACHE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TABLESPACE() {
  return getToken(MySQLStatementParser::TABLESPACE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TABLE_CHECKSUM() {
  return getToken(MySQLStatementParser::TABLE_CHECKSUM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TABLE_NAME() {
  return getToken(MySQLStatementParser::TABLE_NAME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TEMPORARY() {
  return getToken(MySQLStatementParser::TEMPORARY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TEMPTABLE() {
  return getToken(MySQLStatementParser::TEMPTABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TEXT() {
  return getToken(MySQLStatementParser::TEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::THAN() {
  return getToken(MySQLStatementParser::THAN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::THREAD_PRIORITY() {
  return getToken(MySQLStatementParser::THREAD_PRIORITY, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TIES() {
  return getToken(MySQLStatementParser::TIES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TIME() {
  return getToken(MySQLStatementParser::TIME, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TIMESTAMP() {
  return getToken(MySQLStatementParser::TIMESTAMP, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TIMESTAMPADD() {
  return getToken(MySQLStatementParser::TIMESTAMPADD, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TIMESTAMPDIFF() {
  return getToken(MySQLStatementParser::TIMESTAMPDIFF, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TLS() {
  return getToken(MySQLStatementParser::TLS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TRANSACTION() {
  return getToken(MySQLStatementParser::TRANSACTION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TRIGGERS() {
  return getToken(MySQLStatementParser::TRIGGERS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TRUNCATE() {
  return getToken(MySQLStatementParser::TRUNCATE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TYPE() {
  return getToken(MySQLStatementParser::TYPE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::TYPES() {
  return getToken(MySQLStatementParser::TYPES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNBOUNDED() {
  return getToken(MySQLStatementParser::UNBOUNDED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNCOMMITTED() {
  return getToken(MySQLStatementParser::UNCOMMITTED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNDEFINED() {
  return getToken(MySQLStatementParser::UNDEFINED, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNDOFILE() {
  return getToken(MySQLStatementParser::UNDOFILE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNDO_BUFFER_SIZE() {
  return getToken(MySQLStatementParser::UNDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNICODE() {
  return getToken(MySQLStatementParser::UNICODE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNINSTALL() {
  return getToken(MySQLStatementParser::UNINSTALL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNKNOWN() {
  return getToken(MySQLStatementParser::UNKNOWN, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UNTIL() {
  return getToken(MySQLStatementParser::UNTIL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::UPGRADE() {
  return getToken(MySQLStatementParser::UPGRADE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::USER() {
  return getToken(MySQLStatementParser::USER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::USER_RESOURCES() {
  return getToken(MySQLStatementParser::USER_RESOURCES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::USE_FRM() {
  return getToken(MySQLStatementParser::USE_FRM, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::VALIDATION() {
  return getToken(MySQLStatementParser::VALIDATION, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::VALUE() {
  return getToken(MySQLStatementParser::VALUE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::VARIABLES() {
  return getToken(MySQLStatementParser::VARIABLES, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::VCPU() {
  return getToken(MySQLStatementParser::VCPU, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::VIEW() {
  return getToken(MySQLStatementParser::VIEW, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::VISIBLE() {
  return getToken(MySQLStatementParser::VISIBLE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::WAIT() {
  return getToken(MySQLStatementParser::WAIT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::WARNINGS() {
  return getToken(MySQLStatementParser::WARNINGS, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::WEEK() {
  return getToken(MySQLStatementParser::WEEK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::WEIGHT_STRING() {
  return getToken(MySQLStatementParser::WEIGHT_STRING, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::WITHOUT() {
  return getToken(MySQLStatementParser::WITHOUT, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::WORK() {
  return getToken(MySQLStatementParser::WORK, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::WRAPPER() {
  return getToken(MySQLStatementParser::WRAPPER, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::X509() {
  return getToken(MySQLStatementParser::X509, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::XA() {
  return getToken(MySQLStatementParser::XA, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::XID() {
  return getToken(MySQLStatementParser::XID, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::XML() {
  return getToken(MySQLStatementParser::XML, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::YEAR() {
  return getToken(MySQLStatementParser::YEAR, 0);
}

tree::TerminalNode* MySQLStatementParser::UnreservedWordContext::MEMBER() {
  return getToken(MySQLStatementParser::MEMBER, 0);
}


size_t MySQLStatementParser::UnreservedWordContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUnreservedWord;
}

void MySQLStatementParser::UnreservedWordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnreservedWord(this);
}

void MySQLStatementParser::UnreservedWordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnreservedWord(this);
}


antlrcpp::Any MySQLStatementParser::UnreservedWordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUnreservedWord(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UnreservedWordContext* MySQLStatementParser::unreservedWord() {
  UnreservedWordContext *_localctx = _tracker.createInstance<UnreservedWordContext>(_ctx, getState());
  enterRule(_localctx, 830, MySQLStatementParser::RuleUnreservedWord);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6398);
    _la = _input->LA(1);
    if (!(((((_la - 26) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 26)) & ((1ULL << (MySQLStatementParser::ACCOUNT - 26))
      | (1ULL << (MySQLStatementParser::ACTION - 26))
      | (1ULL << (MySQLStatementParser::ACTIVE - 26))
      | (1ULL << (MySQLStatementParser::ADMIN - 26))
      | (1ULL << (MySQLStatementParser::AFTER - 26))
      | (1ULL << (MySQLStatementParser::AGAINST - 26))
      | (1ULL << (MySQLStatementParser::AGGREGATE - 26))
      | (1ULL << (MySQLStatementParser::ALGORITHM - 26))
      | (1ULL << (MySQLStatementParser::ALWAYS - 26))
      | (1ULL << (MySQLStatementParser::ANY - 26))
      | (1ULL << (MySQLStatementParser::ASCII - 26))
      | (1ULL << (MySQLStatementParser::AT - 26))
      | (1ULL << (MySQLStatementParser::ATTRIBUTE - 26))
      | (1ULL << (MySQLStatementParser::AUTOEXTEND_SIZE - 26))
      | (1ULL << (MySQLStatementParser::AUTO_INCREMENT - 26))
      | (1ULL << (MySQLStatementParser::AVG - 26))
      | (1ULL << (MySQLStatementParser::AVG_ROW_LENGTH - 26))
      | (1ULL << (MySQLStatementParser::BACKUP - 26))
      | (1ULL << (MySQLStatementParser::BEGIN - 26))
      | (1ULL << (MySQLStatementParser::BINLOG - 26))
      | (1ULL << (MySQLStatementParser::BIT - 26))
      | (1ULL << (MySQLStatementParser::BLOCK - 26))
      | (1ULL << (MySQLStatementParser::BOOL - 26))
      | (1ULL << (MySQLStatementParser::BOOLEAN - 26))
      | (1ULL << (MySQLStatementParser::BTREE - 26))
      | (1ULL << (MySQLStatementParser::BUCKETS - 26))
      | (1ULL << (MySQLStatementParser::BYTE - 26))
      | (1ULL << (MySQLStatementParser::CACHE - 26))
      | (1ULL << (MySQLStatementParser::CASCADED - 26))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 26))
      | (1ULL << (MySQLStatementParser::CHAIN - 26))
      | (1ULL << (MySQLStatementParser::CHANGED - 26))
      | (1ULL << (MySQLStatementParser::CHANNEL - 26))
      | (1ULL << (MySQLStatementParser::CHARSET - 26))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 26))
      | (1ULL << (MySQLStatementParser::CIPHER - 26))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 26))
      | (1ULL << (MySQLStatementParser::CLIENT - 26))
      | (1ULL << (MySQLStatementParser::CLONE - 26))
      | (1ULL << (MySQLStatementParser::CLOSE - 26))
      | (1ULL << (MySQLStatementParser::COALESCE - 26)))) != 0) || ((((_la - 90) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 90)) & ((1ULL << (MySQLStatementParser::CODE - 90))
      | (1ULL << (MySQLStatementParser::COLLATION - 90))
      | (1ULL << (MySQLStatementParser::COLUMNS - 90))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 90))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 90))
      | (1ULL << (MySQLStatementParser::COMMENT - 90))
      | (1ULL << (MySQLStatementParser::COMMIT - 90))
      | (1ULL << (MySQLStatementParser::COMMITTED - 90))
      | (1ULL << (MySQLStatementParser::COMPACT - 90))
      | (1ULL << (MySQLStatementParser::COMPLETION - 90))
      | (1ULL << (MySQLStatementParser::COMPONENT - 90))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 90))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 90))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 90))
      | (1ULL << (MySQLStatementParser::CONNECTION - 90))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 90))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 90))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 90))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 90))
      | (1ULL << (MySQLStatementParser::CONTAINS - 90))
      | (1ULL << (MySQLStatementParser::CONTEXT - 90))
      | (1ULL << (MySQLStatementParser::CPU - 90))
      | (1ULL << (MySQLStatementParser::CURRENT - 90))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 90))
      | (1ULL << (MySQLStatementParser::DATA - 90))
      | (1ULL << (MySQLStatementParser::DATAFILE - 90))
      | (1ULL << (MySQLStatementParser::DATE - 90))
      | (1ULL << (MySQLStatementParser::DATETIME - 90))
      | (1ULL << (MySQLStatementParser::DAY - 90))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 90))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 90))
      | (1ULL << (MySQLStatementParser::DEFINER - 90))
      | (1ULL << (MySQLStatementParser::DEFINITION - 90))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 90)))) != 0) || ((((_la - 154) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 154)) & ((1ULL << (MySQLStatementParser::DESCRIPTION - 154))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 154))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 154))
      | (1ULL << (MySQLStatementParser::DISABLE - 154))
      | (1ULL << (MySQLStatementParser::DISCARD - 154))
      | (1ULL << (MySQLStatementParser::DISK - 154))
      | (1ULL << (MySQLStatementParser::DO - 154))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 154))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 154))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 154))
      | (1ULL << (MySQLStatementParser::ENABLE - 154))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 154))
      | (1ULL << (MySQLStatementParser::END - 154))
      | (1ULL << (MySQLStatementParser::ENDS - 154))
      | (1ULL << (MySQLStatementParser::ENFORCED - 154))
      | (1ULL << (MySQLStatementParser::ENGINE - 154))
      | (1ULL << (MySQLStatementParser::ENGINES - 154))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 154))
      | (1ULL << (MySQLStatementParser::ENUM - 154))
      | (1ULL << (MySQLStatementParser::ERROR - 154))
      | (1ULL << (MySQLStatementParser::ERRORS - 154))
      | (1ULL << (MySQLStatementParser::ESCAPE - 154))
      | (1ULL << (MySQLStatementParser::EVENT - 154))
      | (1ULL << (MySQLStatementParser::EVENTS - 154))
      | (1ULL << (MySQLStatementParser::EVERY - 154))
      | (1ULL << (MySQLStatementParser::EXCHANGE - 154))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 154))
      | (1ULL << (MySQLStatementParser::EXECUTE - 154))
      | (1ULL << (MySQLStatementParser::EXPANSION - 154))
      | (1ULL << (MySQLStatementParser::EXPIRE - 154))
      | (1ULL << (MySQLStatementParser::EXPORT - 154))
      | (1ULL << (MySQLStatementParser::EXTENDED - 154))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 154))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 154))
      | (1ULL << (MySQLStatementParser::FAST - 154))
      | (1ULL << (MySQLStatementParser::FAULTS - 154))
      | (1ULL << (MySQLStatementParser::FIELDS - 154))
      | (1ULL << (MySQLStatementParser::FILE - 154))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 154))
      | (1ULL << (MySQLStatementParser::FILTER - 154))
      | (1ULL << (MySQLStatementParser::FIRST - 154))
      | (1ULL << (MySQLStatementParser::FIXED - 154)))) != 0) || ((((_la - 219) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 219)) & ((1ULL << (MySQLStatementParser::FLUSH - 219))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 219))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 219))
      | (1ULL << (MySQLStatementParser::FORMAT - 219))
      | (1ULL << (MySQLStatementParser::FULL - 219))
      | (1ULL << (MySQLStatementParser::GENERAL - 219))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 219))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 219))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 219))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 219))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 219))
      | (1ULL << (MySQLStatementParser::GLOBAL - 219))
      | (1ULL << (MySQLStatementParser::GRANTS - 219))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 219))
      | (1ULL << (MySQLStatementParser::HANDLER - 219))
      | (1ULL << (MySQLStatementParser::HASH - 219))
      | (1ULL << (MySQLStatementParser::HELP - 219))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 219))
      | (1ULL << (MySQLStatementParser::HISTORY - 219))
      | (1ULL << (MySQLStatementParser::HOST - 219))
      | (1ULL << (MySQLStatementParser::HOSTS - 219))
      | (1ULL << (MySQLStatementParser::HOUR - 219))
      | (1ULL << (MySQLStatementParser::IDENTIFIED - 219))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 219))
      | (1ULL << (MySQLStatementParser::IMPORT - 219))
      | (1ULL << (MySQLStatementParser::INACTIVE - 219))
      | (1ULL << (MySQLStatementParser::INDEXES - 219))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 219))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 219))
      | (1ULL << (MySQLStatementParser::INSTALL - 219))
      | (1ULL << (MySQLStatementParser::INSTANCE - 219)))) != 0) || ((((_la - 286) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 286)) & ((1ULL << (MySQLStatementParser::INVISIBLE - 286))
      | (1ULL << (MySQLStatementParser::INVOKER - 286))
      | (1ULL << (MySQLStatementParser::IO - 286))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 286))
      | (1ULL << (MySQLStatementParser::IPC - 286))
      | (1ULL << (MySQLStatementParser::ISOLATION - 286))
      | (1ULL << (MySQLStatementParser::ISSUER - 286))
      | (1ULL << (MySQLStatementParser::JSON - 286))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 286))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 286))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 286))
      | (1ULL << (MySQLStatementParser::LAST - 286))
      | (1ULL << (MySQLStatementParser::LEAVES - 286))
      | (1ULL << (MySQLStatementParser::LESS - 286))
      | (1ULL << (MySQLStatementParser::LEVEL - 286))
      | (1ULL << (MySQLStatementParser::LINESTRING - 286))
      | (1ULL << (MySQLStatementParser::LIST - 286))
      | (1ULL << (MySQLStatementParser::LOCAL - 286))
      | (1ULL << (MySQLStatementParser::LOCKED - 286))
      | (1ULL << (MySQLStatementParser::LOCKS - 286))
      | (1ULL << (MySQLStatementParser::LOGFILE - 286))
      | (1ULL << (MySQLStatementParser::LOGS - 286))
      | (1ULL << (MySQLStatementParser::MANAGED - 286))
      | (1ULL << (MySQLStatementParser::MASTER - 286))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 286))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 286))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 286))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 286))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 286))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 286))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 286))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 286))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 286))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 286)))) != 0) || ((((_la - 350) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 350)) & ((1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 350))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 350))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 350))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 350))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 350))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 350))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 350))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 350))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 350))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 350))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 350))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 350))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 350))
      | (1ULL << (MySQLStatementParser::MEDIUM - 350))
      | (1ULL << (MySQLStatementParser::MEMBER - 350))
      | (1ULL << (MySQLStatementParser::MEMORY - 350))
      | (1ULL << (MySQLStatementParser::MERGE - 350))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 350))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 350))
      | (1ULL << (MySQLStatementParser::MIGRATE - 350))
      | (1ULL << (MySQLStatementParser::MINUTE - 350))
      | (1ULL << (MySQLStatementParser::MIN_ROWS - 350))
      | (1ULL << (MySQLStatementParser::MODE - 350))
      | (1ULL << (MySQLStatementParser::MODIFY - 350))
      | (1ULL << (MySQLStatementParser::MONTH - 350))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 350))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 350))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 350))
      | (1ULL << (MySQLStatementParser::MUTEX - 350))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 350))
      | (1ULL << (MySQLStatementParser::NAME - 350))
      | (1ULL << (MySQLStatementParser::NAMES - 350))
      | (1ULL << (MySQLStatementParser::NATIONAL - 350))
      | (1ULL << (MySQLStatementParser::NCHAR - 350))
      | (1ULL << (MySQLStatementParser::NDB - 350))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 350))
      | (1ULL << (MySQLStatementParser::NESTED - 350))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 350))
      | (1ULL << (MySQLStatementParser::NEVER - 350))
      | (1ULL << (MySQLStatementParser::NEW - 350))
      | (1ULL << (MySQLStatementParser::NEXT - 350))
      | (1ULL << (MySQLStatementParser::NO - 350))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 350))
      | (1ULL << (MySQLStatementParser::NONE - 350)))) != 0) || ((((_la - 415) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 415)) & ((1ULL << (MySQLStatementParser::NOWAIT - 415))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 415))
      | (1ULL << (MySQLStatementParser::NULLS - 415))
      | (1ULL << (MySQLStatementParser::NUMBER - 415))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 415))
      | (1ULL << (MySQLStatementParser::OFF - 415))
      | (1ULL << (MySQLStatementParser::OFFSET - 415))
      | (1ULL << (MySQLStatementParser::OJ - 415))
      | (1ULL << (MySQLStatementParser::OLD - 415))
      | (1ULL << (MySQLStatementParser::ONE - 415))
      | (1ULL << (MySQLStatementParser::ONLY - 415))
      | (1ULL << (MySQLStatementParser::OPEN - 415))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 415))
      | (1ULL << (MySQLStatementParser::OPTIONS - 415))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 415))
      | (1ULL << (MySQLStatementParser::OTHERS - 415))
      | (1ULL << (MySQLStatementParser::OWNER - 415))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 415))
      | (1ULL << (MySQLStatementParser::PAGE - 415))
      | (1ULL << (MySQLStatementParser::PARSER - 415))
      | (1ULL << (MySQLStatementParser::PARTIAL - 415))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 415))
      | (1ULL << (MySQLStatementParser::PASSWORD - 415))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 415))
      | (1ULL << (MySQLStatementParser::PATH - 415))
      | (1ULL << (MySQLStatementParser::PERSIST - 415))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 415))
      | (1ULL << (MySQLStatementParser::PHASE - 415))
      | (1ULL << (MySQLStatementParser::PLUGIN - 415))
      | (1ULL << (MySQLStatementParser::PLUGINS - 415))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 415))
      | (1ULL << (MySQLStatementParser::POINT - 415))
      | (1ULL << (MySQLStatementParser::POLYGON - 415))
      | (1ULL << (MySQLStatementParser::PORT - 415))
      | (1ULL << (MySQLStatementParser::PRECEDES - 415))
      | (1ULL << (MySQLStatementParser::PRECEDING - 415))
      | (1ULL << (MySQLStatementParser::PREPARE - 415))
      | (1ULL << (MySQLStatementParser::PRESERVE - 415))
      | (1ULL << (MySQLStatementParser::PREV - 415))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 415))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 415)))) != 0) || ((((_la - 480) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 480)) & ((1ULL << (MySQLStatementParser::PROCESS - 480))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 480))
      | (1ULL << (MySQLStatementParser::PROFILE - 480))
      | (1ULL << (MySQLStatementParser::PROFILES - 480))
      | (1ULL << (MySQLStatementParser::PROXY - 480))
      | (1ULL << (MySQLStatementParser::QUARTER - 480))
      | (1ULL << (MySQLStatementParser::QUERY - 480))
      | (1ULL << (MySQLStatementParser::QUICK - 480))
      | (1ULL << (MySQLStatementParser::RANDOM - 480))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 480))
      | (1ULL << (MySQLStatementParser::REBUILD - 480))
      | (1ULL << (MySQLStatementParser::RECOVER - 480))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 480))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 480))
      | (1ULL << (MySQLStatementParser::REFERENCE - 480))
      | (1ULL << (MySQLStatementParser::RELAY - 480))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 480))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 480))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 480))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 480))
      | (1ULL << (MySQLStatementParser::RELOAD - 480))
      | (1ULL << (MySQLStatementParser::REMOVE - 480))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 480))
      | (1ULL << (MySQLStatementParser::REPAIR - 480))
      | (1ULL << (MySQLStatementParser::REPEATABLE - 480))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 480))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 480))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 480))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 480))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 480))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 480))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 480))
      | (1ULL << (MySQLStatementParser::REPLICATION - 480))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 480))
      | (1ULL << (MySQLStatementParser::RESET - 480))
      | (1ULL << (MySQLStatementParser::RESOURCE - 480))
      | (1ULL << (MySQLStatementParser::RESPECT - 480))
      | (1ULL << (MySQLStatementParser::RESTART - 480))
      | (1ULL << (MySQLStatementParser::RESTORE - 480))
      | (1ULL << (MySQLStatementParser::RESUME - 480))
      | (1ULL << (MySQLStatementParser::RETAIN - 480))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 480))
      | (1ULL << (MySQLStatementParser::RETURNING - 480))
      | (1ULL << (MySQLStatementParser::RETURNS - 480))
      | (1ULL << (MySQLStatementParser::REUSE - 480))
      | (1ULL << (MySQLStatementParser::REVERSE - 480)))) != 0) || ((((_la - 547) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 547)) & ((1ULL << (MySQLStatementParser::ROLE - 547))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 547))
      | (1ULL << (MySQLStatementParser::ROLLUP - 547))
      | (1ULL << (MySQLStatementParser::ROTATE - 547))
      | (1ULL << (MySQLStatementParser::ROUTINE - 547))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 547))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 547))
      | (1ULL << (MySQLStatementParser::RTREE - 547))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 547))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 547))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 547))
      | (1ULL << (MySQLStatementParser::SECOND - 547))
      | (1ULL << (MySQLStatementParser::SECONDARY - 547))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 547))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 547))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 547))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 547))
      | (1ULL << (MySQLStatementParser::SECURITY - 547))
      | (1ULL << (MySQLStatementParser::SERIAL - 547))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 547))
      | (1ULL << (MySQLStatementParser::SERVER - 547))
      | (1ULL << (MySQLStatementParser::SESSION - 547))
      | (1ULL << (MySQLStatementParser::SHARE - 547))
      | (1ULL << (MySQLStatementParser::SHUTDOWN - 547))
      | (1ULL << (MySQLStatementParser::SIGNED - 547))
      | (1ULL << (MySQLStatementParser::SIMPLE - 547))
      | (1ULL << (MySQLStatementParser::SLAVE - 547))
      | (1ULL << (MySQLStatementParser::SLOW - 547))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 547))
      | (1ULL << (MySQLStatementParser::SOCKET - 547))
      | (1ULL << (MySQLStatementParser::SOME - 547))
      | (1ULL << (MySQLStatementParser::SONAME - 547))
      | (1ULL << (MySQLStatementParser::SOUNDS - 547))
      | (1ULL << (MySQLStatementParser::SOURCE - 547))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 547))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 547))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 547))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 547))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 547))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 547))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 547)))) != 0) || ((((_la - 611) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 611)) & ((1ULL << (MySQLStatementParser::SQL_TSI_DAY - 611))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 611))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 611))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 611))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 611))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 611))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 611))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 611))
      | (1ULL << (MySQLStatementParser::SRID - 611))
      | (1ULL << (MySQLStatementParser::STACKED - 611))
      | (1ULL << (MySQLStatementParser::START - 611))
      | (1ULL << (MySQLStatementParser::STARTS - 611))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 611))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 611))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 611))
      | (1ULL << (MySQLStatementParser::STATUS - 611))
      | (1ULL << (MySQLStatementParser::STOP - 611))
      | (1ULL << (MySQLStatementParser::STORAGE - 611))
      | (1ULL << (MySQLStatementParser::STREAM - 611))
      | (1ULL << (MySQLStatementParser::STRING - 611))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 611))
      | (1ULL << (MySQLStatementParser::SUBJECT - 611))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 611))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 611))
      | (1ULL << (MySQLStatementParser::SUPER - 611))
      | (1ULL << (MySQLStatementParser::SUSPEND - 611))
      | (1ULL << (MySQLStatementParser::SWAPS - 611))
      | (1ULL << (MySQLStatementParser::SWITCHES - 611))
      | (1ULL << (MySQLStatementParser::TABLES - 611))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 611))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 611))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 611))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 611))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 611))
      | (1ULL << (MySQLStatementParser::TEXT - 611))
      | (1ULL << (MySQLStatementParser::THAN - 611))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 611))
      | (1ULL << (MySQLStatementParser::TIES - 611))
      | (1ULL << (MySQLStatementParser::TIME - 611))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 611))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 611))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 611))
      | (1ULL << (MySQLStatementParser::TLS - 611))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 611))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 611))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 611))
      | (1ULL << (MySQLStatementParser::TYPE - 611))
      | (1ULL << (MySQLStatementParser::TYPES - 611))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 611)))) != 0) || ((((_la - 675) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 675)) & ((1ULL << (MySQLStatementParser::UNCOMMITTED - 675))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 675))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 675))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 675))
      | (1ULL << (MySQLStatementParser::UNICODE - 675))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 675))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 675))
      | (1ULL << (MySQLStatementParser::UNTIL - 675))
      | (1ULL << (MySQLStatementParser::UPGRADE - 675))
      | (1ULL << (MySQLStatementParser::USER - 675))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 675))
      | (1ULL << (MySQLStatementParser::USE_FRM - 675))
      | (1ULL << (MySQLStatementParser::VALIDATION - 675))
      | (1ULL << (MySQLStatementParser::VALUE - 675))
      | (1ULL << (MySQLStatementParser::VARIABLES - 675))
      | (1ULL << (MySQLStatementParser::VCPU - 675))
      | (1ULL << (MySQLStatementParser::VIEW - 675))
      | (1ULL << (MySQLStatementParser::VISIBLE - 675))
      | (1ULL << (MySQLStatementParser::WAIT - 675))
      | (1ULL << (MySQLStatementParser::WARNINGS - 675))
      | (1ULL << (MySQLStatementParser::WEEK - 675))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 675))
      | (1ULL << (MySQLStatementParser::WITHOUT - 675))
      | (1ULL << (MySQLStatementParser::WORK - 675))
      | (1ULL << (MySQLStatementParser::WRAPPER - 675))
      | (1ULL << (MySQLStatementParser::X509 - 675))
      | (1ULL << (MySQLStatementParser::XA - 675))
      | (1ULL << (MySQLStatementParser::XID - 675))
      | (1ULL << (MySQLStatementParser::XML - 675))
      | (1ULL << (MySQLStatementParser::YEAR - 675)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextOrIdentifierContext ------------------------------------------------------------------

MySQLStatementParser::TextOrIdentifierContext::TextOrIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::TextOrIdentifierContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::TextOrIdentifierContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::TextOrIdentifierContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTextOrIdentifier;
}

void MySQLStatementParser::TextOrIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextOrIdentifier(this);
}

void MySQLStatementParser::TextOrIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextOrIdentifier(this);
}


antlrcpp::Any MySQLStatementParser::TextOrIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTextOrIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::textOrIdentifier() {
  TextOrIdentifierContext *_localctx = _tracker.createInstance<TextOrIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 832, MySQLStatementParser::RuleTextOrIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6402);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 826, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6400);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6401);
      string_();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableContext ------------------------------------------------------------------

MySQLStatementParser::VariableContext::VariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::InternalVariableNameContext* MySQLStatementParser::VariableContext::internalVariableName() {
  return getRuleContext<MySQLStatementParser::InternalVariableNameContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::VariableContext::AT_() {
  return getTokens(MySQLStatementParser::AT_);
}

tree::TerminalNode* MySQLStatementParser::VariableContext::AT_(size_t i) {
  return getToken(MySQLStatementParser::AT_, i);
}

MySQLStatementParser::ScopeContext* MySQLStatementParser::VariableContext::scope() {
  return getRuleContext<MySQLStatementParser::ScopeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::VariableContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::VariableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleVariable;
}

void MySQLStatementParser::VariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable(this);
}

void MySQLStatementParser::VariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable(this);
}


antlrcpp::Any MySQLStatementParser::VariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::VariableContext* MySQLStatementParser::variable() {
  VariableContext *_localctx = _tracker.createInstance<VariableContext>(_ctx, getState());
  enterRule(_localctx, 834, MySQLStatementParser::RuleVariable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AT_) {
      setState(6405);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 827, _ctx)) {
      case 1: {
        setState(6404);
        match(MySQLStatementParser::AT_);
        break;
      }

      }
      setState(6407);
      match(MySQLStatementParser::AT_);
    }
    setState(6411);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 829, _ctx)) {
    case 1: {
      setState(6410);
      scope();
      break;
    }

    }
    setState(6414);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DOT_) {
      setState(6413);
      match(MySQLStatementParser::DOT_);
    }
    setState(6416);
    internalVariableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserVariableContext ------------------------------------------------------------------

MySQLStatementParser::UserVariableContext::UserVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UserVariableContext::AT_() {
  return getToken(MySQLStatementParser::AT_, 0);
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::UserVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}


size_t MySQLStatementParser::UserVariableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUserVariable;
}

void MySQLStatementParser::UserVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserVariable(this);
}

void MySQLStatementParser::UserVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserVariable(this);
}


antlrcpp::Any MySQLStatementParser::UserVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUserVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UserVariableContext* MySQLStatementParser::userVariable() {
  UserVariableContext *_localctx = _tracker.createInstance<UserVariableContext>(_ctx, getState());
  enterRule(_localctx, 836, MySQLStatementParser::RuleUserVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6418);
    match(MySQLStatementParser::AT_);
    setState(6419);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SystemVariableContext ------------------------------------------------------------------

MySQLStatementParser::SystemVariableContext::SystemVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SystemVariableContext::AT_() {
  return getTokens(MySQLStatementParser::AT_);
}

tree::TerminalNode* MySQLStatementParser::SystemVariableContext::AT_(size_t i) {
  return getToken(MySQLStatementParser::AT_, i);
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::SystemVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}

MySQLStatementParser::ScopeContext* MySQLStatementParser::SystemVariableContext::scope() {
  return getRuleContext<MySQLStatementParser::ScopeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SystemVariableContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::SystemVariableContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::SystemVariableContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSystemVariable;
}

void MySQLStatementParser::SystemVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSystemVariable(this);
}

void MySQLStatementParser::SystemVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSystemVariable(this);
}


antlrcpp::Any MySQLStatementParser::SystemVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSystemVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SystemVariableContext* MySQLStatementParser::systemVariable() {
  SystemVariableContext *_localctx = _tracker.createInstance<SystemVariableContext>(_ctx, getState());
  enterRule(_localctx, 838, MySQLStatementParser::RuleSystemVariable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6421);
    match(MySQLStatementParser::AT_);
    setState(6422);
    match(MySQLStatementParser::AT_);
    setState(6424);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 831, _ctx)) {
    case 1: {
      setState(6423);
      scope();
      break;
    }

    }
    setState(6426);
    textOrIdentifier();
    setState(6429);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DOT_) {
      setState(6427);
      match(MySQLStatementParser::DOT_);
      setState(6428);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScopeContext ------------------------------------------------------------------

MySQLStatementParser::ScopeContext::ScopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ScopeContext::GLOBAL() {
  return getToken(MySQLStatementParser::GLOBAL, 0);
}

tree::TerminalNode* MySQLStatementParser::ScopeContext::PERSIST() {
  return getToken(MySQLStatementParser::PERSIST, 0);
}

tree::TerminalNode* MySQLStatementParser::ScopeContext::PERSIST_ONLY() {
  return getToken(MySQLStatementParser::PERSIST_ONLY, 0);
}

tree::TerminalNode* MySQLStatementParser::ScopeContext::SESSION() {
  return getToken(MySQLStatementParser::SESSION, 0);
}

tree::TerminalNode* MySQLStatementParser::ScopeContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}


size_t MySQLStatementParser::ScopeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleScope;
}

void MySQLStatementParser::ScopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScope(this);
}

void MySQLStatementParser::ScopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScope(this);
}


antlrcpp::Any MySQLStatementParser::ScopeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitScope(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ScopeContext* MySQLStatementParser::scope() {
  ScopeContext *_localctx = _tracker.createInstance<ScopeContext>(_ctx, getState());
  enterRule(_localctx, 840, MySQLStatementParser::RuleScope);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6431);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::GLOBAL || _la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::PERSIST

    || _la == MySQLStatementParser::PERSIST_ONLY || _la == MySQLStatementParser::SESSION)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InternalVariableNameContext ------------------------------------------------------------------

MySQLStatementParser::InternalVariableNameContext::InternalVariableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::InternalVariableNameContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::InternalVariableNameContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::InternalVariableNameContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::InternalVariableNameContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::InternalVariableNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleInternalVariableName;
}

void MySQLStatementParser::InternalVariableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInternalVariableName(this);
}

void MySQLStatementParser::InternalVariableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInternalVariableName(this);
}


antlrcpp::Any MySQLStatementParser::InternalVariableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitInternalVariableName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::InternalVariableNameContext* MySQLStatementParser::internalVariableName() {
  InternalVariableNameContext *_localctx = _tracker.createInstance<InternalVariableNameContext>(_ctx, getState());
  enterRule(_localctx, 842, MySQLStatementParser::RuleInternalVariableName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6441);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 833, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6433);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6434);
      match(MySQLStatementParser::DEFAULT);
      setState(6435);
      match(MySQLStatementParser::DOT_);
      setState(6436);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6437);
      identifier();
      setState(6438);
      match(MySQLStatementParser::DOT_);
      setState(6439);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetExprOrDefaultContext ------------------------------------------------------------------

MySQLStatementParser::SetExprOrDefaultContext::SetExprOrDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ExprContext* MySQLStatementParser::SetExprOrDefaultContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SetExprOrDefaultContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::SetExprOrDefaultContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::SetExprOrDefaultContext::ON() {
  return getToken(MySQLStatementParser::ON, 0);
}

tree::TerminalNode* MySQLStatementParser::SetExprOrDefaultContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::SetExprOrDefaultContext::ROW() {
  return getToken(MySQLStatementParser::ROW, 0);
}

tree::TerminalNode* MySQLStatementParser::SetExprOrDefaultContext::SYSTEM() {
  return getToken(MySQLStatementParser::SYSTEM, 0);
}


size_t MySQLStatementParser::SetExprOrDefaultContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSetExprOrDefault;
}

void MySQLStatementParser::SetExprOrDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetExprOrDefault(this);
}

void MySQLStatementParser::SetExprOrDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetExprOrDefault(this);
}


antlrcpp::Any MySQLStatementParser::SetExprOrDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSetExprOrDefault(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SetExprOrDefaultContext* MySQLStatementParser::setExprOrDefault() {
  SetExprOrDefaultContext *_localctx = _tracker.createInstance<SetExprOrDefaultContext>(_ctx, getState());
  enterRule(_localctx, 844, MySQLStatementParser::RuleSetExprOrDefault);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6450);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 834, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6443);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6444);
      match(MySQLStatementParser::DEFAULT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6445);
      match(MySQLStatementParser::ALL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6446);
      match(MySQLStatementParser::ON);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6447);
      match(MySQLStatementParser::BINARY);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6448);
      match(MySQLStatementParser::ROW);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6449);
      match(MySQLStatementParser::SYSTEM);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaNameContext ------------------------------------------------------------------

MySQLStatementParser::SchemaNameContext::SchemaNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::SchemaNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::SchemaNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSchemaName;
}

void MySQLStatementParser::SchemaNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaName(this);
}

void MySQLStatementParser::SchemaNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaName(this);
}


antlrcpp::Any MySQLStatementParser::SchemaNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSchemaName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::schemaName() {
  SchemaNameContext *_localctx = _tracker.createInstance<SchemaNameContext>(_ctx, getState());
  enterRule(_localctx, 846, MySQLStatementParser::RuleSchemaName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6452);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaNamesContext ------------------------------------------------------------------

MySQLStatementParser::SchemaNamesContext::SchemaNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::SchemaNameContext *> MySQLStatementParser::SchemaNamesContext::schemaName() {
  return getRuleContexts<MySQLStatementParser::SchemaNameContext>();
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::SchemaNamesContext::schemaName(size_t i) {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SchemaNamesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SchemaNamesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SchemaNamesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSchemaNames;
}

void MySQLStatementParser::SchemaNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaNames(this);
}

void MySQLStatementParser::SchemaNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaNames(this);
}


antlrcpp::Any MySQLStatementParser::SchemaNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSchemaNames(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SchemaNamesContext* MySQLStatementParser::schemaNames() {
  SchemaNamesContext *_localctx = _tracker.createInstance<SchemaNamesContext>(_ctx, getState());
  enterRule(_localctx, 848, MySQLStatementParser::RuleSchemaNames);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6454);
    schemaName();
    setState(6459);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6455);
      match(MySQLStatementParser::COMMA_);
      setState(6456);
      schemaName();
      setState(6461);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetNameContext ------------------------------------------------------------------

MySQLStatementParser::CharsetNameContext::CharsetNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::CharsetNameContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CharsetNameContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}


size_t MySQLStatementParser::CharsetNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCharsetName;
}

void MySQLStatementParser::CharsetNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetName(this);
}

void MySQLStatementParser::CharsetNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetName(this);
}


antlrcpp::Any MySQLStatementParser::CharsetNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCharsetName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::charsetName() {
  CharsetNameContext *_localctx = _tracker.createInstance<CharsetNameContext>(_ctx, getState());
  enterRule(_localctx, 850, MySQLStatementParser::RuleCharsetName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6464);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(6462);
        textOrIdentifier();
        break;
      }

      case MySQLStatementParser::BINARY: {
        enterOuterAlt(_localctx, 2);
        setState(6463);
        match(MySQLStatementParser::BINARY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaPairsContext ------------------------------------------------------------------

MySQLStatementParser::SchemaPairsContext::SchemaPairsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::SchemaPairContext *> MySQLStatementParser::SchemaPairsContext::schemaPair() {
  return getRuleContexts<MySQLStatementParser::SchemaPairContext>();
}

MySQLStatementParser::SchemaPairContext* MySQLStatementParser::SchemaPairsContext::schemaPair(size_t i) {
  return getRuleContext<MySQLStatementParser::SchemaPairContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SchemaPairsContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SchemaPairsContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SchemaPairsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSchemaPairs;
}

void MySQLStatementParser::SchemaPairsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaPairs(this);
}

void MySQLStatementParser::SchemaPairsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaPairs(this);
}


antlrcpp::Any MySQLStatementParser::SchemaPairsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSchemaPairs(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SchemaPairsContext* MySQLStatementParser::schemaPairs() {
  SchemaPairsContext *_localctx = _tracker.createInstance<SchemaPairsContext>(_ctx, getState());
  enterRule(_localctx, 852, MySQLStatementParser::RuleSchemaPairs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6466);
    schemaPair();
    setState(6471);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6467);
      match(MySQLStatementParser::COMMA_);
      setState(6468);
      schemaPair();
      setState(6473);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaPairContext ------------------------------------------------------------------

MySQLStatementParser::SchemaPairContext::SchemaPairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SchemaPairContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::SchemaNameContext *> MySQLStatementParser::SchemaPairContext::schemaName() {
  return getRuleContexts<MySQLStatementParser::SchemaNameContext>();
}

MySQLStatementParser::SchemaNameContext* MySQLStatementParser::SchemaPairContext::schemaName(size_t i) {
  return getRuleContext<MySQLStatementParser::SchemaNameContext>(i);
}

tree::TerminalNode* MySQLStatementParser::SchemaPairContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}

tree::TerminalNode* MySQLStatementParser::SchemaPairContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::SchemaPairContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSchemaPair;
}

void MySQLStatementParser::SchemaPairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaPair(this);
}

void MySQLStatementParser::SchemaPairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaPair(this);
}


antlrcpp::Any MySQLStatementParser::SchemaPairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSchemaPair(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SchemaPairContext* MySQLStatementParser::schemaPair() {
  SchemaPairContext *_localctx = _tracker.createInstance<SchemaPairContext>(_ctx, getState());
  enterRule(_localctx, 854, MySQLStatementParser::RuleSchemaPair);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6474);
    match(MySQLStatementParser::LP_);
    setState(6475);
    schemaName();
    setState(6476);
    match(MySQLStatementParser::COMMA_);
    setState(6477);
    schemaName();
    setState(6478);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableNameContext ------------------------------------------------------------------

MySQLStatementParser::TableNameContext::TableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::NameContext* MySQLStatementParser::TableNameContext::name() {
  return getRuleContext<MySQLStatementParser::NameContext>(0);
}

MySQLStatementParser::OwnerContext* MySQLStatementParser::TableNameContext::owner() {
  return getRuleContext<MySQLStatementParser::OwnerContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TableNameContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::TableNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableName;
}

void MySQLStatementParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}

void MySQLStatementParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}


antlrcpp::Any MySQLStatementParser::TableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::tableName() {
  TableNameContext *_localctx = _tracker.createInstance<TableNameContext>(_ctx, getState());
  enterRule(_localctx, 856, MySQLStatementParser::RuleTableName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6483);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 838, _ctx)) {
    case 1: {
      setState(6480);
      owner();
      setState(6481);
      match(MySQLStatementParser::DOT_);
      break;
    }

    }
    setState(6485);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnNameContext ------------------------------------------------------------------

MySQLStatementParser::ColumnNameContext::ColumnNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ColumnNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::ColumnNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleColumnName;
}

void MySQLStatementParser::ColumnNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnName(this);
}

void MySQLStatementParser::ColumnNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnName(this);
}


antlrcpp::Any MySQLStatementParser::ColumnNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitColumnName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ColumnNameContext* MySQLStatementParser::columnName() {
  ColumnNameContext *_localctx = _tracker.createInstance<ColumnNameContext>(_ctx, getState());
  enterRule(_localctx, 858, MySQLStatementParser::RuleColumnName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6487);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameContext ------------------------------------------------------------------

MySQLStatementParser::IndexNameContext::IndexNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::IndexNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::IndexNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIndexName;
}

void MySQLStatementParser::IndexNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexName(this);
}

void MySQLStatementParser::IndexNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexName(this);
}


antlrcpp::Any MySQLStatementParser::IndexNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIndexName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IndexNameContext* MySQLStatementParser::indexName() {
  IndexNameContext *_localctx = _tracker.createInstance<IndexNameContext>(_ctx, getState());
  enterRule(_localctx, 860, MySQLStatementParser::RuleIndexName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6489);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserIdentifierOrTextContext ------------------------------------------------------------------

MySQLStatementParser::UserIdentifierOrTextContext::UserIdentifierOrTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::TextOrIdentifierContext *> MySQLStatementParser::UserIdentifierOrTextContext::textOrIdentifier() {
  return getRuleContexts<MySQLStatementParser::TextOrIdentifierContext>();
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::UserIdentifierOrTextContext::textOrIdentifier(size_t i) {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::UserIdentifierOrTextContext::AT_() {
  return getToken(MySQLStatementParser::AT_, 0);
}


size_t MySQLStatementParser::UserIdentifierOrTextContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUserIdentifierOrText;
}

void MySQLStatementParser::UserIdentifierOrTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserIdentifierOrText(this);
}

void MySQLStatementParser::UserIdentifierOrTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserIdentifierOrText(this);
}


antlrcpp::Any MySQLStatementParser::UserIdentifierOrTextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUserIdentifierOrText(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UserIdentifierOrTextContext* MySQLStatementParser::userIdentifierOrText() {
  UserIdentifierOrTextContext *_localctx = _tracker.createInstance<UserIdentifierOrTextContext>(_ctx, getState());
  enterRule(_localctx, 862, MySQLStatementParser::RuleUserIdentifierOrText);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6491);
    textOrIdentifier();
    setState(6494);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 839, _ctx)) {
    case 1: {
      setState(6492);
      match(MySQLStatementParser::AT_);
      setState(6493);
      textOrIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserNameContext ------------------------------------------------------------------

MySQLStatementParser::UserNameContext::UserNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::UserIdentifierOrTextContext* MySQLStatementParser::UserNameContext::userIdentifierOrText() {
  return getRuleContext<MySQLStatementParser::UserIdentifierOrTextContext>(0);
}

tree::TerminalNode* MySQLStatementParser::UserNameContext::CURRENT_USER() {
  return getToken(MySQLStatementParser::CURRENT_USER, 0);
}

tree::TerminalNode* MySQLStatementParser::UserNameContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::UserNameContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::UserNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUserName;
}

void MySQLStatementParser::UserNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserName(this);
}

void MySQLStatementParser::UserNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserName(this);
}


antlrcpp::Any MySQLStatementParser::UserNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUserName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::userName() {
  UserNameContext *_localctx = _tracker.createInstance<UserNameContext>(_ctx, getState());
  enterRule(_localctx, 864, MySQLStatementParser::RuleUserName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6502);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(6496);
        userIdentifierOrText();
        break;
      }

      case MySQLStatementParser::CURRENT_USER: {
        enterOuterAlt(_localctx, 2);
        setState(6497);
        match(MySQLStatementParser::CURRENT_USER);
        setState(6500);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(6498);
          match(MySQLStatementParser::LP_);
          setState(6499);
          match(MySQLStatementParser::RP_);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventNameContext ------------------------------------------------------------------

MySQLStatementParser::EventNameContext::EventNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::EventNameContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::EventNameContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::EventNameContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::EventNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleEventName;
}

void MySQLStatementParser::EventNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventName(this);
}

void MySQLStatementParser::EventNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventName(this);
}


antlrcpp::Any MySQLStatementParser::EventNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitEventName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::EventNameContext* MySQLStatementParser::eventName() {
  EventNameContext *_localctx = _tracker.createInstance<EventNameContext>(_ctx, getState());
  enterRule(_localctx, 866, MySQLStatementParser::RuleEventName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6504);
    identifier();
    setState(6507);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DOT_) {
      setState(6505);
      match(MySQLStatementParser::DOT_);
      setState(6506);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerNameContext ------------------------------------------------------------------

MySQLStatementParser::ServerNameContext::ServerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::ServerNameContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}


size_t MySQLStatementParser::ServerNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleServerName;
}

void MySQLStatementParser::ServerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerName(this);
}

void MySQLStatementParser::ServerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerName(this);
}


antlrcpp::Any MySQLStatementParser::ServerNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitServerName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ServerNameContext* MySQLStatementParser::serverName() {
  ServerNameContext *_localctx = _tracker.createInstance<ServerNameContext>(_ctx, getState());
  enterRule(_localctx, 868, MySQLStatementParser::RuleServerName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6509);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WrapperNameContext ------------------------------------------------------------------

MySQLStatementParser::WrapperNameContext::WrapperNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::WrapperNameContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}


size_t MySQLStatementParser::WrapperNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWrapperName;
}

void MySQLStatementParser::WrapperNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWrapperName(this);
}

void MySQLStatementParser::WrapperNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWrapperName(this);
}


antlrcpp::Any MySQLStatementParser::WrapperNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWrapperName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WrapperNameContext* MySQLStatementParser::wrapperName() {
  WrapperNameContext *_localctx = _tracker.createInstance<WrapperNameContext>(_ctx, getState());
  enterRule(_localctx, 870, MySQLStatementParser::RuleWrapperName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6511);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

MySQLStatementParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::FunctionNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::OwnerContext* MySQLStatementParser::FunctionNameContext::owner() {
  return getRuleContext<MySQLStatementParser::OwnerContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FunctionNameContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::FunctionNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFunctionName;
}

void MySQLStatementParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void MySQLStatementParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}


antlrcpp::Any MySQLStatementParser::FunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFunctionName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FunctionNameContext* MySQLStatementParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 872, MySQLStatementParser::RuleFunctionName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6520);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 844, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6513);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6517);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 843, _ctx)) {
      case 1: {
        setState(6514);
        owner();
        setState(6515);
        match(MySQLStatementParser::DOT_);
        break;
      }

      }
      setState(6519);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewNameContext ------------------------------------------------------------------

MySQLStatementParser::ViewNameContext::ViewNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ViewNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

MySQLStatementParser::OwnerContext* MySQLStatementParser::ViewNameContext::owner() {
  return getRuleContext<MySQLStatementParser::OwnerContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ViewNameContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::ViewNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleViewName;
}

void MySQLStatementParser::ViewNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewName(this);
}

void MySQLStatementParser::ViewNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewName(this);
}


antlrcpp::Any MySQLStatementParser::ViewNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitViewName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ViewNameContext* MySQLStatementParser::viewName() {
  ViewNameContext *_localctx = _tracker.createInstance<ViewNameContext>(_ctx, getState());
  enterRule(_localctx, 874, MySQLStatementParser::RuleViewName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6529);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 846, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6522);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6526);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 845, _ctx)) {
      case 1: {
        setState(6523);
        owner();
        setState(6524);
        match(MySQLStatementParser::DOT_);
        break;
      }

      }
      setState(6528);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OwnerContext ------------------------------------------------------------------

MySQLStatementParser::OwnerContext::OwnerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::OwnerContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::OwnerContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOwner;
}

void MySQLStatementParser::OwnerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOwner(this);
}

void MySQLStatementParser::OwnerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOwner(this);
}


antlrcpp::Any MySQLStatementParser::OwnerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOwner(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OwnerContext* MySQLStatementParser::owner() {
  OwnerContext *_localctx = _tracker.createInstance<OwnerContext>(_ctx, getState());
  enterRule(_localctx, 876, MySQLStatementParser::RuleOwner);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6531);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasContext ------------------------------------------------------------------

MySQLStatementParser::AliasContext::AliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::AliasContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}


size_t MySQLStatementParser::AliasContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAlias;
}

void MySQLStatementParser::AliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlias(this);
}

void MySQLStatementParser::AliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlias(this);
}


antlrcpp::Any MySQLStatementParser::AliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAlias(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AliasContext* MySQLStatementParser::alias() {
  AliasContext *_localctx = _tracker.createInstance<AliasContext>(_ctx, getState());
  enterRule(_localctx, 878, MySQLStatementParser::RuleAlias);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6533);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

MySQLStatementParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::NameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::NameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleName;
}

void MySQLStatementParser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void MySQLStatementParser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


antlrcpp::Any MySQLStatementParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NameContext* MySQLStatementParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 880, MySQLStatementParser::RuleName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6535);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableListContext ------------------------------------------------------------------

MySQLStatementParser::TableListContext::TableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::TableNameContext *> MySQLStatementParser::TableListContext::tableName() {
  return getRuleContexts<MySQLStatementParser::TableNameContext>();
}

MySQLStatementParser::TableNameContext* MySQLStatementParser::TableListContext::tableName(size_t i) {
  return getRuleContext<MySQLStatementParser::TableNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::TableListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::TableListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::TableListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableList;
}

void MySQLStatementParser::TableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableList(this);
}

void MySQLStatementParser::TableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableList(this);
}


antlrcpp::Any MySQLStatementParser::TableListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableListContext* MySQLStatementParser::tableList() {
  TableListContext *_localctx = _tracker.createInstance<TableListContext>(_ctx, getState());
  enterRule(_localctx, 882, MySQLStatementParser::RuleTableList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6537);
    tableName();
    setState(6542);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6538);
      match(MySQLStatementParser::COMMA_);
      setState(6539);
      tableName();
      setState(6544);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewNamesContext ------------------------------------------------------------------

MySQLStatementParser::ViewNamesContext::ViewNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::ViewNameContext *> MySQLStatementParser::ViewNamesContext::viewName() {
  return getRuleContexts<MySQLStatementParser::ViewNameContext>();
}

MySQLStatementParser::ViewNameContext* MySQLStatementParser::ViewNamesContext::viewName(size_t i) {
  return getRuleContext<MySQLStatementParser::ViewNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ViewNamesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ViewNamesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::ViewNamesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleViewNames;
}

void MySQLStatementParser::ViewNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewNames(this);
}

void MySQLStatementParser::ViewNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewNames(this);
}


antlrcpp::Any MySQLStatementParser::ViewNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitViewNames(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ViewNamesContext* MySQLStatementParser::viewNames() {
  ViewNamesContext *_localctx = _tracker.createInstance<ViewNamesContext>(_ctx, getState());
  enterRule(_localctx, 884, MySQLStatementParser::RuleViewNames);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6545);
    viewName();
    setState(6550);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6546);
      match(MySQLStatementParser::COMMA_);
      setState(6547);
      viewName();
      setState(6552);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnNamesContext ------------------------------------------------------------------

MySQLStatementParser::ColumnNamesContext::ColumnNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::ColumnNameContext *> MySQLStatementParser::ColumnNamesContext::columnName() {
  return getRuleContexts<MySQLStatementParser::ColumnNameContext>();
}

MySQLStatementParser::ColumnNameContext* MySQLStatementParser::ColumnNamesContext::columnName(size_t i) {
  return getRuleContext<MySQLStatementParser::ColumnNameContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ColumnNamesContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ColumnNamesContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::ColumnNamesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleColumnNames;
}

void MySQLStatementParser::ColumnNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnNames(this);
}

void MySQLStatementParser::ColumnNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnNames(this);
}


antlrcpp::Any MySQLStatementParser::ColumnNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitColumnNames(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ColumnNamesContext* MySQLStatementParser::columnNames() {
  ColumnNamesContext *_localctx = _tracker.createInstance<ColumnNamesContext>(_ctx, getState());
  enterRule(_localctx, 886, MySQLStatementParser::RuleColumnNames);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6553);
    columnName();
    setState(6558);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6554);
      match(MySQLStatementParser::COMMA_);
      setState(6555);
      columnName();
      setState(6560);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupNameContext ------------------------------------------------------------------

MySQLStatementParser::GroupNameContext::GroupNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::GroupNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::GroupNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGroupName;
}

void MySQLStatementParser::GroupNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupName(this);
}

void MySQLStatementParser::GroupNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupName(this);
}


antlrcpp::Any MySQLStatementParser::GroupNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGroupName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GroupNameContext* MySQLStatementParser::groupName() {
  GroupNameContext *_localctx = _tracker.createInstance<GroupNameContext>(_ctx, getState());
  enterRule(_localctx, 888, MySQLStatementParser::RuleGroupName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6561);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineNameContext ------------------------------------------------------------------

MySQLStatementParser::RoutineNameContext::RoutineNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::RoutineNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::RoutineNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRoutineName;
}

void MySQLStatementParser::RoutineNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineName(this);
}

void MySQLStatementParser::RoutineNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineName(this);
}


antlrcpp::Any MySQLStatementParser::RoutineNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRoutineName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RoutineNameContext* MySQLStatementParser::routineName() {
  RoutineNameContext *_localctx = _tracker.createInstance<RoutineNameContext>(_ctx, getState());
  enterRule(_localctx, 890, MySQLStatementParser::RuleRoutineName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6563);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShardLibraryNameContext ------------------------------------------------------------------

MySQLStatementParser::ShardLibraryNameContext::ShardLibraryNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::ShardLibraryNameContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}


size_t MySQLStatementParser::ShardLibraryNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShardLibraryName;
}

void MySQLStatementParser::ShardLibraryNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShardLibraryName(this);
}

void MySQLStatementParser::ShardLibraryNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShardLibraryName(this);
}


antlrcpp::Any MySQLStatementParser::ShardLibraryNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShardLibraryName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShardLibraryNameContext* MySQLStatementParser::shardLibraryName() {
  ShardLibraryNameContext *_localctx = _tracker.createInstance<ShardLibraryNameContext>(_ctx, getState());
  enterRule(_localctx, 892, MySQLStatementParser::RuleShardLibraryName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6565);
    stringLiterals();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentNameContext ------------------------------------------------------------------

MySQLStatementParser::ComponentNameContext::ComponentNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::String_Context* MySQLStatementParser::ComponentNameContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::ComponentNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleComponentName;
}

void MySQLStatementParser::ComponentNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentName(this);
}

void MySQLStatementParser::ComponentNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentName(this);
}


antlrcpp::Any MySQLStatementParser::ComponentNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitComponentName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ComponentNameContext* MySQLStatementParser::componentName() {
  ComponentNameContext *_localctx = _tracker.createInstance<ComponentNameContext>(_ctx, getState());
  enterRule(_localctx, 894, MySQLStatementParser::RuleComponentName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6567);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PluginNameContext ------------------------------------------------------------------

MySQLStatementParser::PluginNameContext::PluginNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::PluginNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::PluginNameContext::getRuleIndex() const {
  return MySQLStatementParser::RulePluginName;
}

void MySQLStatementParser::PluginNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPluginName(this);
}

void MySQLStatementParser::PluginNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPluginName(this);
}


antlrcpp::Any MySQLStatementParser::PluginNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPluginName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PluginNameContext* MySQLStatementParser::pluginName() {
  PluginNameContext *_localctx = _tracker.createInstance<PluginNameContext>(_ctx, getState());
  enterRule(_localctx, 896, MySQLStatementParser::RulePluginName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6569);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HostNameContext ------------------------------------------------------------------

MySQLStatementParser::HostNameContext::HostNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::String_Context* MySQLStatementParser::HostNameContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::HostNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleHostName;
}

void MySQLStatementParser::HostNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHostName(this);
}

void MySQLStatementParser::HostNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHostName(this);
}


antlrcpp::Any MySQLStatementParser::HostNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitHostName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::HostNameContext* MySQLStatementParser::hostName() {
  HostNameContext *_localctx = _tracker.createInstance<HostNameContext>(_ctx, getState());
  enterRule(_localctx, 898, MySQLStatementParser::RuleHostName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6571);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

MySQLStatementParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PortContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::PortContext::getRuleIndex() const {
  return MySQLStatementParser::RulePort;
}

void MySQLStatementParser::PortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort(this);
}

void MySQLStatementParser::PortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort(this);
}


antlrcpp::Any MySQLStatementParser::PortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPort(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PortContext* MySQLStatementParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 900, MySQLStatementParser::RulePort);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6573);
    match(MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloneInstanceContext ------------------------------------------------------------------

MySQLStatementParser::CloneInstanceContext::CloneInstanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::CloneInstanceContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CloneInstanceContext::AT_() {
  return getToken(MySQLStatementParser::AT_, 0);
}

MySQLStatementParser::HostNameContext* MySQLStatementParser::CloneInstanceContext::hostName() {
  return getRuleContext<MySQLStatementParser::HostNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CloneInstanceContext::COLON_() {
  return getToken(MySQLStatementParser::COLON_, 0);
}

MySQLStatementParser::PortContext* MySQLStatementParser::CloneInstanceContext::port() {
  return getRuleContext<MySQLStatementParser::PortContext>(0);
}


size_t MySQLStatementParser::CloneInstanceContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCloneInstance;
}

void MySQLStatementParser::CloneInstanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloneInstance(this);
}

void MySQLStatementParser::CloneInstanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloneInstance(this);
}


antlrcpp::Any MySQLStatementParser::CloneInstanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCloneInstance(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CloneInstanceContext* MySQLStatementParser::cloneInstance() {
  CloneInstanceContext *_localctx = _tracker.createInstance<CloneInstanceContext>(_ctx, getState());
  enterRule(_localctx, 902, MySQLStatementParser::RuleCloneInstance);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6575);
    userName();
    setState(6576);
    match(MySQLStatementParser::AT_);
    setState(6577);
    hostName();
    setState(6578);
    match(MySQLStatementParser::COLON_);
    setState(6579);
    port();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloneDirContext ------------------------------------------------------------------

MySQLStatementParser::CloneDirContext::CloneDirContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::String_Context* MySQLStatementParser::CloneDirContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::CloneDirContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCloneDir;
}

void MySQLStatementParser::CloneDirContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloneDir(this);
}

void MySQLStatementParser::CloneDirContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloneDir(this);
}


antlrcpp::Any MySQLStatementParser::CloneDirContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCloneDir(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CloneDirContext* MySQLStatementParser::cloneDir() {
  CloneDirContext *_localctx = _tracker.createInstance<CloneDirContext>(_ctx, getState());
  enterRule(_localctx, 904, MySQLStatementParser::RuleCloneDir);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6581);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelNameContext ------------------------------------------------------------------

MySQLStatementParser::ChannelNameContext::ChannelNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::ChannelNameContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ChannelNameContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::ChannelNameContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::ChannelNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleChannelName;
}

void MySQLStatementParser::ChannelNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannelName(this);
}

void MySQLStatementParser::ChannelNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannelName(this);
}


antlrcpp::Any MySQLStatementParser::ChannelNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChannelName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ChannelNameContext* MySQLStatementParser::channelName() {
  ChannelNameContext *_localctx = _tracker.createInstance<ChannelNameContext>(_ctx, getState());
  enterRule(_localctx, 906, MySQLStatementParser::RuleChannelName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6583);
    identifier();
    setState(6586);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DOT_) {
      setState(6584);
      match(MySQLStatementParser::DOT_);
      setState(6585);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogNameContext ------------------------------------------------------------------

MySQLStatementParser::LogNameContext::LogNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::LogNameContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}


size_t MySQLStatementParser::LogNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLogName;
}

void MySQLStatementParser::LogNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogName(this);
}

void MySQLStatementParser::LogNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogName(this);
}


antlrcpp::Any MySQLStatementParser::LogNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLogName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LogNameContext* MySQLStatementParser::logName() {
  LogNameContext *_localctx = _tracker.createInstance<LogNameContext>(_ctx, getState());
  enterRule(_localctx, 908, MySQLStatementParser::RuleLogName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6588);
    stringLiterals();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleNameContext ------------------------------------------------------------------

MySQLStatementParser::RoleNameContext::RoleNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RoleNameContext::AT_() {
  return getToken(MySQLStatementParser::AT_, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::RoleNameContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::RoleNameContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::RoleNameContext::IDENTIFIER_() {
  return getTokens(MySQLStatementParser::IDENTIFIER_);
}

tree::TerminalNode* MySQLStatementParser::RoleNameContext::IDENTIFIER_(size_t i) {
  return getToken(MySQLStatementParser::IDENTIFIER_, i);
}


size_t MySQLStatementParser::RoleNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRoleName;
}

void MySQLStatementParser::RoleNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleName(this);
}

void MySQLStatementParser::RoleNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleName(this);
}


antlrcpp::Any MySQLStatementParser::RoleNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRoleName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::roleName() {
  RoleNameContext *_localctx = _tracker.createInstance<RoleNameContext>(_ctx, getState());
  enterRule(_localctx, 910, MySQLStatementParser::RuleRoleName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6600);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 853, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6592);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::SINGLE_QUOTED_TEXT:
        case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
          setState(6590);
          string_();
          break;
        }

        case MySQLStatementParser::IDENTIFIER_: {
          setState(6591);
          match(MySQLStatementParser::IDENTIFIER_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6594);
      match(MySQLStatementParser::AT_);
      setState(6597);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::SINGLE_QUOTED_TEXT:
        case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
          setState(6595);
          string_();
          break;
        }

        case MySQLStatementParser::IDENTIFIER_: {
          setState(6596);
          match(MySQLStatementParser::IDENTIFIER_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6599);
      match(MySQLStatementParser::IDENTIFIER_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EngineRefContext ------------------------------------------------------------------

MySQLStatementParser::EngineRefContext::EngineRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::EngineRefContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}


size_t MySQLStatementParser::EngineRefContext::getRuleIndex() const {
  return MySQLStatementParser::RuleEngineRef;
}

void MySQLStatementParser::EngineRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEngineRef(this);
}

void MySQLStatementParser::EngineRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEngineRef(this);
}


antlrcpp::Any MySQLStatementParser::EngineRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitEngineRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::EngineRefContext* MySQLStatementParser::engineRef() {
  EngineRefContext *_localctx = _tracker.createInstance<EngineRefContext>(_ctx, getState());
  enterRule(_localctx, 912, MySQLStatementParser::RuleEngineRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6602);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerNameContext ------------------------------------------------------------------

MySQLStatementParser::TriggerNameContext::TriggerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::TriggerNameContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::TriggerNameContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

tree::TerminalNode* MySQLStatementParser::TriggerNameContext::DOT_() {
  return getToken(MySQLStatementParser::DOT_, 0);
}


size_t MySQLStatementParser::TriggerNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTriggerName;
}

void MySQLStatementParser::TriggerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerName(this);
}

void MySQLStatementParser::TriggerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerName(this);
}


antlrcpp::Any MySQLStatementParser::TriggerNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTriggerName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TriggerNameContext* MySQLStatementParser::triggerName() {
  TriggerNameContext *_localctx = _tracker.createInstance<TriggerNameContext>(_ctx, getState());
  enterRule(_localctx, 914, MySQLStatementParser::RuleTriggerName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6604);
    identifier();
    setState(6607);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DOT_) {
      setState(6605);
      match(MySQLStatementParser::DOT_);
      setState(6606);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerTimeContext ------------------------------------------------------------------

MySQLStatementParser::TriggerTimeContext::TriggerTimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TriggerTimeContext::BEFORE() {
  return getToken(MySQLStatementParser::BEFORE, 0);
}

tree::TerminalNode* MySQLStatementParser::TriggerTimeContext::AFTER() {
  return getToken(MySQLStatementParser::AFTER, 0);
}


size_t MySQLStatementParser::TriggerTimeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTriggerTime;
}

void MySQLStatementParser::TriggerTimeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerTime(this);
}

void MySQLStatementParser::TriggerTimeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerTime(this);
}


antlrcpp::Any MySQLStatementParser::TriggerTimeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTriggerTime(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TriggerTimeContext* MySQLStatementParser::triggerTime() {
  TriggerTimeContext *_localctx = _tracker.createInstance<TriggerTimeContext>(_ctx, getState());
  enterRule(_localctx, 916, MySQLStatementParser::RuleTriggerTime);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6609);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::AFTER

    || _la == MySQLStatementParser::BEFORE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableOrTablesContext ------------------------------------------------------------------

MySQLStatementParser::TableOrTablesContext::TableOrTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TableOrTablesContext::TABLE() {
  return getToken(MySQLStatementParser::TABLE, 0);
}

tree::TerminalNode* MySQLStatementParser::TableOrTablesContext::TABLES() {
  return getToken(MySQLStatementParser::TABLES, 0);
}


size_t MySQLStatementParser::TableOrTablesContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTableOrTables;
}

void MySQLStatementParser::TableOrTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOrTables(this);
}

void MySQLStatementParser::TableOrTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOrTables(this);
}


antlrcpp::Any MySQLStatementParser::TableOrTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTableOrTables(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TableOrTablesContext* MySQLStatementParser::tableOrTables() {
  TableOrTablesContext *_localctx = _tracker.createInstance<TableOrTablesContext>(_ctx, getState());
  enterRule(_localctx, 918, MySQLStatementParser::RuleTableOrTables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6611);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::TABLE

    || _la == MySQLStatementParser::TABLES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserOrRoleContext ------------------------------------------------------------------

MySQLStatementParser::UserOrRoleContext::UserOrRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::UserNameContext* MySQLStatementParser::UserOrRoleContext::userName() {
  return getRuleContext<MySQLStatementParser::UserNameContext>(0);
}

MySQLStatementParser::RoleNameContext* MySQLStatementParser::UserOrRoleContext::roleName() {
  return getRuleContext<MySQLStatementParser::RoleNameContext>(0);
}


size_t MySQLStatementParser::UserOrRoleContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUserOrRole;
}

void MySQLStatementParser::UserOrRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserOrRole(this);
}

void MySQLStatementParser::UserOrRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserOrRole(this);
}


antlrcpp::Any MySQLStatementParser::UserOrRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUserOrRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UserOrRoleContext* MySQLStatementParser::userOrRole() {
  UserOrRoleContext *_localctx = _tracker.createInstance<UserOrRoleContext>(_ctx, getState());
  enterRule(_localctx, 920, MySQLStatementParser::RuleUserOrRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6615);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 855, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6613);
      userName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6614);
      roleName();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionNameContext ------------------------------------------------------------------

MySQLStatementParser::PartitionNameContext::PartitionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::PartitionNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::PartitionNameContext::getRuleIndex() const {
  return MySQLStatementParser::RulePartitionName;
}

void MySQLStatementParser::PartitionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionName(this);
}

void MySQLStatementParser::PartitionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionName(this);
}


antlrcpp::Any MySQLStatementParser::PartitionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPartitionName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PartitionNameContext* MySQLStatementParser::partitionName() {
  PartitionNameContext *_localctx = _tracker.createInstance<PartitionNameContext>(_ctx, getState());
  enterRule(_localctx, 922, MySQLStatementParser::RulePartitionName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6617);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

MySQLStatementParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::IdentifierListContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::IdentifierListContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::IdentifierListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::IdentifierListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::IdentifierListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIdentifierList;
}

void MySQLStatementParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void MySQLStatementParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}


antlrcpp::Any MySQLStatementParser::IdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IdentifierListContext* MySQLStatementParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 924, MySQLStatementParser::RuleIdentifierList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6619);
    identifier();
    setState(6624);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6620);
      match(MySQLStatementParser::COMMA_);
      setState(6621);
      identifier();
      setState(6626);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AllOrPartitionNameListContext ------------------------------------------------------------------

MySQLStatementParser::AllOrPartitionNameListContext::AllOrPartitionNameListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AllOrPartitionNameListContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

MySQLStatementParser::IdentifierListContext* MySQLStatementParser::AllOrPartitionNameListContext::identifierList() {
  return getRuleContext<MySQLStatementParser::IdentifierListContext>(0);
}


size_t MySQLStatementParser::AllOrPartitionNameListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAllOrPartitionNameList;
}

void MySQLStatementParser::AllOrPartitionNameListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAllOrPartitionNameList(this);
}

void MySQLStatementParser::AllOrPartitionNameListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAllOrPartitionNameList(this);
}


antlrcpp::Any MySQLStatementParser::AllOrPartitionNameListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAllOrPartitionNameList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AllOrPartitionNameListContext* MySQLStatementParser::allOrPartitionNameList() {
  AllOrPartitionNameListContext *_localctx = _tracker.createInstance<AllOrPartitionNameListContext>(_ctx, getState());
  enterRule(_localctx, 926, MySQLStatementParser::RuleAllOrPartitionNameList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6629);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ALL: {
        enterOuterAlt(_localctx, 1);
        setState(6627);
        match(MySQLStatementParser::ALL);
        break;
      }

      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 2);
        setState(6628);
        identifierList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerEventContext ------------------------------------------------------------------

MySQLStatementParser::TriggerEventContext::TriggerEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TriggerEventContext::INSERT() {
  return getToken(MySQLStatementParser::INSERT, 0);
}

tree::TerminalNode* MySQLStatementParser::TriggerEventContext::UPDATE() {
  return getToken(MySQLStatementParser::UPDATE, 0);
}

tree::TerminalNode* MySQLStatementParser::TriggerEventContext::DELETE() {
  return getToken(MySQLStatementParser::DELETE, 0);
}


size_t MySQLStatementParser::TriggerEventContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTriggerEvent;
}

void MySQLStatementParser::TriggerEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerEvent(this);
}

void MySQLStatementParser::TriggerEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerEvent(this);
}


antlrcpp::Any MySQLStatementParser::TriggerEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTriggerEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TriggerEventContext* MySQLStatementParser::triggerEvent() {
  TriggerEventContext *_localctx = _tracker.createInstance<TriggerEventContext>(_ctx, getState());
  enterRule(_localctx, 928, MySQLStatementParser::RuleTriggerEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6631);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DELETE || _la == MySQLStatementParser::INSERT || _la == MySQLStatementParser::UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerOrderContext ------------------------------------------------------------------

MySQLStatementParser::TriggerOrderContext::TriggerOrderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::TriggerNameContext* MySQLStatementParser::TriggerOrderContext::triggerName() {
  return getRuleContext<MySQLStatementParser::TriggerNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::TriggerOrderContext::FOLLOWS() {
  return getToken(MySQLStatementParser::FOLLOWS, 0);
}

tree::TerminalNode* MySQLStatementParser::TriggerOrderContext::PRECEDES() {
  return getToken(MySQLStatementParser::PRECEDES, 0);
}


size_t MySQLStatementParser::TriggerOrderContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTriggerOrder;
}

void MySQLStatementParser::TriggerOrderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerOrder(this);
}

void MySQLStatementParser::TriggerOrderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerOrder(this);
}


antlrcpp::Any MySQLStatementParser::TriggerOrderContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTriggerOrder(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TriggerOrderContext* MySQLStatementParser::triggerOrder() {
  TriggerOrderContext *_localctx = _tracker.createInstance<TriggerOrderContext>(_ctx, getState());
  enterRule(_localctx, 930, MySQLStatementParser::RuleTriggerOrder);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6633);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::FOLLOWS || _la == MySQLStatementParser::PRECEDES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6634);
    triggerName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

MySQLStatementParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::BooleanPrimaryContext* MySQLStatementParser::ExprContext::booleanPrimary() {
  return getRuleContext<MySQLStatementParser::BooleanPrimaryContext>(0);
}

MySQLStatementParser::NotOperatorContext* MySQLStatementParser::ExprContext::notOperator() {
  return getRuleContext<MySQLStatementParser::NotOperatorContext>(0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::ExprContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::ExprContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

MySQLStatementParser::LogicalOperatorContext* MySQLStatementParser::ExprContext::logicalOperator() {
  return getRuleContext<MySQLStatementParser::LogicalOperatorContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ExprContext::XOR() {
  return getToken(MySQLStatementParser::XOR, 0);
}


size_t MySQLStatementParser::ExprContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExpr;
}

void MySQLStatementParser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void MySQLStatementParser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}


antlrcpp::Any MySQLStatementParser::ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExpr(this);
  else
    return visitor->visitChildren(this);
}


MySQLStatementParser::ExprContext* MySQLStatementParser::expr() {
   return expr(0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLStatementParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  MySQLStatementParser::ExprContext *previousContext = _localctx;
  size_t startState = 932;
  enterRecursionRule(_localctx, 932, MySQLStatementParser::RuleExpr, precedence);

    

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6641);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 858, _ctx)) {
    case 1: {
      setState(6637);
      booleanPrimary(0);
      break;
    }

    case 2: {
      setState(6638);
      notOperator();
      setState(6639);
      expr(1);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(6652);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 860, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6650);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 859, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(6643);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(6644);
          logicalOperator();
          setState(6645);
          expr(4);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(6647);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(6648);
          match(MySQLStatementParser::XOR);
          setState(6649);
          expr(3);
          break;
        }

        } 
      }
      setState(6654);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 860, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- LogicalOperatorContext ------------------------------------------------------------------

MySQLStatementParser::LogicalOperatorContext::LogicalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LogicalOperatorContext::OR() {
  return getToken(MySQLStatementParser::OR, 0);
}

tree::TerminalNode* MySQLStatementParser::LogicalOperatorContext::OR_() {
  return getToken(MySQLStatementParser::OR_, 0);
}

tree::TerminalNode* MySQLStatementParser::LogicalOperatorContext::AND() {
  return getToken(MySQLStatementParser::AND, 0);
}

tree::TerminalNode* MySQLStatementParser::LogicalOperatorContext::AND_() {
  return getToken(MySQLStatementParser::AND_, 0);
}


size_t MySQLStatementParser::LogicalOperatorContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLogicalOperator;
}

void MySQLStatementParser::LogicalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalOperator(this);
}

void MySQLStatementParser::LogicalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalOperator(this);
}


antlrcpp::Any MySQLStatementParser::LogicalOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLogicalOperator(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LogicalOperatorContext* MySQLStatementParser::logicalOperator() {
  LogicalOperatorContext *_localctx = _tracker.createInstance<LogicalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 934, MySQLStatementParser::RuleLogicalOperator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6655);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::AND || _la == MySQLStatementParser::OR || _la == MySQLStatementParser::AND_

    || _la == MySQLStatementParser::OR_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotOperatorContext ------------------------------------------------------------------

MySQLStatementParser::NotOperatorContext::NotOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NotOperatorContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::NotOperatorContext::NOT_() {
  return getToken(MySQLStatementParser::NOT_, 0);
}


size_t MySQLStatementParser::NotOperatorContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNotOperator;
}

void MySQLStatementParser::NotOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotOperator(this);
}

void MySQLStatementParser::NotOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotOperator(this);
}


antlrcpp::Any MySQLStatementParser::NotOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNotOperator(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NotOperatorContext* MySQLStatementParser::notOperator() {
  NotOperatorContext *_localctx = _tracker.createInstance<NotOperatorContext>(_ctx, getState());
  enterRule(_localctx, 936, MySQLStatementParser::RuleNotOperator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6657);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::NOT || _la == MySQLStatementParser::NOT_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanPrimaryContext ------------------------------------------------------------------

MySQLStatementParser::BooleanPrimaryContext::BooleanPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::PredicateContext* MySQLStatementParser::BooleanPrimaryContext::predicate() {
  return getRuleContext<MySQLStatementParser::PredicateContext>(0);
}

MySQLStatementParser::BooleanPrimaryContext* MySQLStatementParser::BooleanPrimaryContext::booleanPrimary() {
  return getRuleContext<MySQLStatementParser::BooleanPrimaryContext>(0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::IS() {
  return getToken(MySQLStatementParser::IS, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::TRUE() {
  return getToken(MySQLStatementParser::TRUE, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::FALSE() {
  return getToken(MySQLStatementParser::FALSE, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::UNKNOWN() {
  return getToken(MySQLStatementParser::UNKNOWN, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::NULL() {
  return getToken(MySQLStatementParser::NULL, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::SAFE_EQ_() {
  return getToken(MySQLStatementParser::SAFE_EQ_, 0);
}

MySQLStatementParser::ComparisonOperatorContext* MySQLStatementParser::BooleanPrimaryContext::comparisonOperator() {
  return getRuleContext<MySQLStatementParser::ComparisonOperatorContext>(0);
}

MySQLStatementParser::SubqueryContext* MySQLStatementParser::BooleanPrimaryContext::subquery() {
  return getRuleContext<MySQLStatementParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::BooleanPrimaryContext::ANY() {
  return getToken(MySQLStatementParser::ANY, 0);
}


size_t MySQLStatementParser::BooleanPrimaryContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBooleanPrimary;
}

void MySQLStatementParser::BooleanPrimaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanPrimary(this);
}

void MySQLStatementParser::BooleanPrimaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanPrimary(this);
}


antlrcpp::Any MySQLStatementParser::BooleanPrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBooleanPrimary(this);
  else
    return visitor->visitChildren(this);
}


MySQLStatementParser::BooleanPrimaryContext* MySQLStatementParser::booleanPrimary() {
   return booleanPrimary(0);
}

MySQLStatementParser::BooleanPrimaryContext* MySQLStatementParser::booleanPrimary(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLStatementParser::BooleanPrimaryContext *_localctx = _tracker.createInstance<BooleanPrimaryContext>(_ctx, parentState);
  MySQLStatementParser::BooleanPrimaryContext *previousContext = _localctx;
  size_t startState = 938;
  enterRecursionRule(_localctx, 938, MySQLStatementParser::RuleBooleanPrimary, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6660);
    predicate();
    _ctx->stop = _input->LT(-1);
    setState(6682);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 863, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6680);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 862, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<BooleanPrimaryContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBooleanPrimary);
          setState(6662);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(6663);
          match(MySQLStatementParser::IS);
          setState(6665);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::NOT) {
            setState(6664);
            match(MySQLStatementParser::NOT);
          }
          setState(6667);
          _la = _input->LA(1);
          if (!(_la == MySQLStatementParser::FALSE || _la == MySQLStatementParser::NULL || _la == MySQLStatementParser::TRUE

          || _la == MySQLStatementParser::UNKNOWN)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<BooleanPrimaryContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBooleanPrimary);
          setState(6668);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(6669);
          match(MySQLStatementParser::SAFE_EQ_);
          setState(6670);
          predicate();
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<BooleanPrimaryContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBooleanPrimary);
          setState(6671);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(6672);
          comparisonOperator();
          setState(6673);
          predicate();
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<BooleanPrimaryContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBooleanPrimary);
          setState(6675);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(6676);
          comparisonOperator();
          setState(6677);
          _la = _input->LA(1);
          if (!(_la == MySQLStatementParser::ALL

          || _la == MySQLStatementParser::ANY)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(6678);
          subquery();
          break;
        }

        } 
      }
      setState(6684);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 863, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

MySQLStatementParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ComparisonOperatorContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}

tree::TerminalNode* MySQLStatementParser::ComparisonOperatorContext::GTE_() {
  return getToken(MySQLStatementParser::GTE_, 0);
}

tree::TerminalNode* MySQLStatementParser::ComparisonOperatorContext::GT_() {
  return getToken(MySQLStatementParser::GT_, 0);
}

tree::TerminalNode* MySQLStatementParser::ComparisonOperatorContext::LTE_() {
  return getToken(MySQLStatementParser::LTE_, 0);
}

tree::TerminalNode* MySQLStatementParser::ComparisonOperatorContext::LT_() {
  return getToken(MySQLStatementParser::LT_, 0);
}

tree::TerminalNode* MySQLStatementParser::ComparisonOperatorContext::NEQ_() {
  return getToken(MySQLStatementParser::NEQ_, 0);
}


size_t MySQLStatementParser::ComparisonOperatorContext::getRuleIndex() const {
  return MySQLStatementParser::RuleComparisonOperator;
}

void MySQLStatementParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void MySQLStatementParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}


antlrcpp::Any MySQLStatementParser::ComparisonOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitComparisonOperator(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ComparisonOperatorContext* MySQLStatementParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 940, MySQLStatementParser::RuleComparisonOperator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6685);
    _la = _input->LA(1);
    if (!(((((_la - 754) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 754)) & ((1ULL << (MySQLStatementParser::EQ_ - 754))
      | (1ULL << (MySQLStatementParser::NEQ_ - 754))
      | (1ULL << (MySQLStatementParser::GT_ - 754))
      | (1ULL << (MySQLStatementParser::GTE_ - 754))
      | (1ULL << (MySQLStatementParser::LT_ - 754))
      | (1ULL << (MySQLStatementParser::LTE_ - 754)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

MySQLStatementParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::BitExprContext *> MySQLStatementParser::PredicateContext::bitExpr() {
  return getRuleContexts<MySQLStatementParser::BitExprContext>();
}

MySQLStatementParser::BitExprContext* MySQLStatementParser::PredicateContext::bitExpr(size_t i) {
  return getRuleContext<MySQLStatementParser::BitExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

MySQLStatementParser::SubqueryContext* MySQLStatementParser::PredicateContext::subquery() {
  return getRuleContext<MySQLStatementParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::PredicateContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::PredicateContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PredicateContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::BETWEEN() {
  return getToken(MySQLStatementParser::BETWEEN, 0);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::AND() {
  return getToken(MySQLStatementParser::AND, 0);
}

MySQLStatementParser::PredicateContext* MySQLStatementParser::PredicateContext::predicate() {
  return getRuleContext<MySQLStatementParser::PredicateContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::SOUNDS() {
  return getToken(MySQLStatementParser::SOUNDS, 0);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::LIKE() {
  return getToken(MySQLStatementParser::LIKE, 0);
}

std::vector<MySQLStatementParser::SimpleExprContext *> MySQLStatementParser::PredicateContext::simpleExpr() {
  return getRuleContexts<MySQLStatementParser::SimpleExprContext>();
}

MySQLStatementParser::SimpleExprContext* MySQLStatementParser::PredicateContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLStatementParser::SimpleExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::ESCAPE() {
  return getToken(MySQLStatementParser::ESCAPE, 0);
}

tree::TerminalNode* MySQLStatementParser::PredicateContext::REGEXP() {
  return getToken(MySQLStatementParser::REGEXP, 0);
}


size_t MySQLStatementParser::PredicateContext::getRuleIndex() const {
  return MySQLStatementParser::RulePredicate;
}

void MySQLStatementParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void MySQLStatementParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}


antlrcpp::Any MySQLStatementParser::PredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPredicate(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PredicateContext* MySQLStatementParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 942, MySQLStatementParser::RulePredicate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6742);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 871, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6687);
      bitExpr(0);
      setState(6689);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(6688);
        match(MySQLStatementParser::NOT);
      }
      setState(6691);
      match(MySQLStatementParser::IN);
      setState(6692);
      subquery();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6694);
      bitExpr(0);
      setState(6696);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(6695);
        match(MySQLStatementParser::NOT);
      }
      setState(6698);
      match(MySQLStatementParser::IN);
      setState(6699);
      match(MySQLStatementParser::LP_);
      setState(6700);
      expr(0);
      setState(6705);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(6701);
        match(MySQLStatementParser::COMMA_);
        setState(6702);
        expr(0);
        setState(6707);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6708);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6710);
      bitExpr(0);
      setState(6712);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(6711);
        match(MySQLStatementParser::NOT);
      }
      setState(6714);
      match(MySQLStatementParser::BETWEEN);
      setState(6715);
      bitExpr(0);
      setState(6716);
      match(MySQLStatementParser::AND);
      setState(6717);
      predicate();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6719);
      bitExpr(0);
      setState(6720);
      match(MySQLStatementParser::SOUNDS);
      setState(6721);
      match(MySQLStatementParser::LIKE);
      setState(6722);
      bitExpr(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6724);
      bitExpr(0);
      setState(6726);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(6725);
        match(MySQLStatementParser::NOT);
      }
      setState(6728);
      match(MySQLStatementParser::LIKE);
      setState(6729);
      simpleExpr(0);
      setState(6732);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 869, _ctx)) {
      case 1: {
        setState(6730);
        match(MySQLStatementParser::ESCAPE);
        setState(6731);
        simpleExpr(0);
        break;
      }

      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6734);
      bitExpr(0);
      setState(6736);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NOT) {
        setState(6735);
        match(MySQLStatementParser::NOT);
      }
      setState(6738);
      match(MySQLStatementParser::REGEXP);
      setState(6739);
      bitExpr(0);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6741);
      bitExpr(0);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitExprContext ------------------------------------------------------------------

MySQLStatementParser::BitExprContext::BitExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::SimpleExprContext* MySQLStatementParser::BitExprContext::simpleExpr() {
  return getRuleContext<MySQLStatementParser::SimpleExprContext>(0);
}

std::vector<MySQLStatementParser::BitExprContext *> MySQLStatementParser::BitExprContext::bitExpr() {
  return getRuleContexts<MySQLStatementParser::BitExprContext>();
}

MySQLStatementParser::BitExprContext* MySQLStatementParser::BitExprContext::bitExpr(size_t i) {
  return getRuleContext<MySQLStatementParser::BitExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::VERTICAL_BAR_() {
  return getToken(MySQLStatementParser::VERTICAL_BAR_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::AMPERSAND_() {
  return getToken(MySQLStatementParser::AMPERSAND_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::SIGNED_LEFT_SHIFT_() {
  return getToken(MySQLStatementParser::SIGNED_LEFT_SHIFT_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::SIGNED_RIGHT_SHIFT_() {
  return getToken(MySQLStatementParser::SIGNED_RIGHT_SHIFT_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::PLUS_() {
  return getToken(MySQLStatementParser::PLUS_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::MINUS_() {
  return getToken(MySQLStatementParser::MINUS_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::SLASH_() {
  return getToken(MySQLStatementParser::SLASH_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::DIV() {
  return getToken(MySQLStatementParser::DIV, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::MOD() {
  return getToken(MySQLStatementParser::MOD, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::MOD_() {
  return getToken(MySQLStatementParser::MOD_, 0);
}

tree::TerminalNode* MySQLStatementParser::BitExprContext::CARET_() {
  return getToken(MySQLStatementParser::CARET_, 0);
}

MySQLStatementParser::IntervalExpressionContext* MySQLStatementParser::BitExprContext::intervalExpression() {
  return getRuleContext<MySQLStatementParser::IntervalExpressionContext>(0);
}


size_t MySQLStatementParser::BitExprContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBitExpr;
}

void MySQLStatementParser::BitExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitExpr(this);
}

void MySQLStatementParser::BitExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitExpr(this);
}


antlrcpp::Any MySQLStatementParser::BitExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBitExpr(this);
  else
    return visitor->visitChildren(this);
}


MySQLStatementParser::BitExprContext* MySQLStatementParser::bitExpr() {
   return bitExpr(0);
}

MySQLStatementParser::BitExprContext* MySQLStatementParser::bitExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLStatementParser::BitExprContext *_localctx = _tracker.createInstance<BitExprContext>(_ctx, parentState);
  MySQLStatementParser::BitExprContext *previousContext = _localctx;
  size_t startState = 944;
  enterRecursionRule(_localctx, 944, MySQLStatementParser::RuleBitExpr, precedence);

    

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6745);
    simpleExpr(0);
    _ctx->stop = _input->LT(-1);
    setState(6791);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 873, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6789);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 872, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6747);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(6748);
          match(MySQLStatementParser::VERTICAL_BAR_);
          setState(6749);
          bitExpr(16);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6750);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(6751);
          match(MySQLStatementParser::AMPERSAND_);
          setState(6752);
          bitExpr(15);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6753);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(6754);
          match(MySQLStatementParser::SIGNED_LEFT_SHIFT_);
          setState(6755);
          bitExpr(14);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6756);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(6757);
          match(MySQLStatementParser::SIGNED_RIGHT_SHIFT_);
          setState(6758);
          bitExpr(13);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6759);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(6760);
          match(MySQLStatementParser::PLUS_);
          setState(6761);
          bitExpr(12);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6762);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(6763);
          match(MySQLStatementParser::MINUS_);
          setState(6764);
          bitExpr(11);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6765);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(6766);
          match(MySQLStatementParser::ASTERISK_);
          setState(6767);
          bitExpr(10);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6768);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(6769);
          match(MySQLStatementParser::SLASH_);
          setState(6770);
          bitExpr(9);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6771);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(6772);
          match(MySQLStatementParser::DIV);
          setState(6773);
          bitExpr(8);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6774);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(6775);
          match(MySQLStatementParser::MOD);
          setState(6776);
          bitExpr(7);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6777);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(6778);
          match(MySQLStatementParser::MOD_);
          setState(6779);
          bitExpr(6);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6780);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(6781);
          match(MySQLStatementParser::CARET_);
          setState(6782);
          bitExpr(5);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6783);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(6784);
          match(MySQLStatementParser::PLUS_);
          setState(6785);
          intervalExpression();
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(6786);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(6787);
          match(MySQLStatementParser::MINUS_);
          setState(6788);
          intervalExpression();
          break;
        }

        } 
      }
      setState(6793);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 873, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- SimpleExprContext ------------------------------------------------------------------

MySQLStatementParser::SimpleExprContext::SimpleExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::FunctionCallContext* MySQLStatementParser::SimpleExprContext::functionCall() {
  return getRuleContext<MySQLStatementParser::FunctionCallContext>(0);
}

MySQLStatementParser::ParameterMarkerContext* MySQLStatementParser::SimpleExprContext::parameterMarker() {
  return getRuleContext<MySQLStatementParser::ParameterMarkerContext>(0);
}

MySQLStatementParser::LiteralsContext* MySQLStatementParser::SimpleExprContext::literals() {
  return getRuleContext<MySQLStatementParser::LiteralsContext>(0);
}

MySQLStatementParser::ColumnRefContext* MySQLStatementParser::SimpleExprContext::columnRef() {
  return getRuleContext<MySQLStatementParser::ColumnRefContext>(0);
}

MySQLStatementParser::VariableContext* MySQLStatementParser::SimpleExprContext::variable() {
  return getRuleContext<MySQLStatementParser::VariableContext>(0);
}

std::vector<MySQLStatementParser::SimpleExprContext *> MySQLStatementParser::SimpleExprContext::simpleExpr() {
  return getRuleContexts<MySQLStatementParser::SimpleExprContext>();
}

MySQLStatementParser::SimpleExprContext* MySQLStatementParser::SimpleExprContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLStatementParser::SimpleExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::PLUS_() {
  return getToken(MySQLStatementParser::PLUS_, 0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::MINUS_() {
  return getToken(MySQLStatementParser::MINUS_, 0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::TILDE_() {
  return getToken(MySQLStatementParser::TILDE_, 0);
}

MySQLStatementParser::NotOperatorContext* MySQLStatementParser::SimpleExprContext::notOperator() {
  return getRuleContext<MySQLStatementParser::NotOperatorContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::SimpleExprContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::SimpleExprContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::ROW() {
  return getToken(MySQLStatementParser::ROW, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SimpleExprContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

MySQLStatementParser::SubqueryContext* MySQLStatementParser::SimpleExprContext::subquery() {
  return getRuleContext<MySQLStatementParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::LBE_() {
  return getToken(MySQLStatementParser::LBE_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::SimpleExprContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::RBE_() {
  return getToken(MySQLStatementParser::RBE_, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::SimpleExprContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::JSON_SEPARATOR() {
  return getToken(MySQLStatementParser::JSON_SEPARATOR, 0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::JSON_UNQUOTED_SEPARATOR() {
  return getToken(MySQLStatementParser::JSON_UNQUOTED_SEPARATOR, 0);
}

MySQLStatementParser::MatchExpressionContext* MySQLStatementParser::SimpleExprContext::matchExpression() {
  return getRuleContext<MySQLStatementParser::MatchExpressionContext>(0);
}

MySQLStatementParser::CaseExpressionContext* MySQLStatementParser::SimpleExprContext::caseExpression() {
  return getRuleContext<MySQLStatementParser::CaseExpressionContext>(0);
}

MySQLStatementParser::IntervalExpressionContext* MySQLStatementParser::SimpleExprContext::intervalExpression() {
  return getRuleContext<MySQLStatementParser::IntervalExpressionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::OR_() {
  return getToken(MySQLStatementParser::OR_, 0);
}

tree::TerminalNode* MySQLStatementParser::SimpleExprContext::COLLATE() {
  return getToken(MySQLStatementParser::COLLATE, 0);
}

MySQLStatementParser::TextOrIdentifierContext* MySQLStatementParser::SimpleExprContext::textOrIdentifier() {
  return getRuleContext<MySQLStatementParser::TextOrIdentifierContext>(0);
}


size_t MySQLStatementParser::SimpleExprContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSimpleExpr;
}

void MySQLStatementParser::SimpleExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExpr(this);
}

void MySQLStatementParser::SimpleExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExpr(this);
}


antlrcpp::Any MySQLStatementParser::SimpleExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExpr(this);
  else
    return visitor->visitChildren(this);
}


MySQLStatementParser::SimpleExprContext* MySQLStatementParser::simpleExpr() {
   return simpleExpr(0);
}

MySQLStatementParser::SimpleExprContext* MySQLStatementParser::simpleExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLStatementParser::SimpleExprContext *_localctx = _tracker.createInstance<SimpleExprContext>(_ctx, parentState);
  MySQLStatementParser::SimpleExprContext *previousContext = _localctx;
  size_t startState = 946;
  enterRecursionRule(_localctx, 946, MySQLStatementParser::RuleSimpleExpr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6838);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 878, _ctx)) {
    case 1: {
      setState(6795);
      functionCall();
      break;
    }

    case 2: {
      setState(6796);
      parameterMarker();
      break;
    }

    case 3: {
      setState(6797);
      literals();
      break;
    }

    case 4: {
      setState(6798);
      columnRef();
      break;
    }

    case 5: {
      setState(6799);
      variable();
      break;
    }

    case 6: {
      setState(6805);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::PLUS_: {
          setState(6800);
          match(MySQLStatementParser::PLUS_);
          break;
        }

        case MySQLStatementParser::MINUS_: {
          setState(6801);
          match(MySQLStatementParser::MINUS_);
          break;
        }

        case MySQLStatementParser::TILDE_: {
          setState(6802);
          match(MySQLStatementParser::TILDE_);
          break;
        }

        case MySQLStatementParser::NOT:
        case MySQLStatementParser::NOT_: {
          setState(6803);
          notOperator();
          break;
        }

        case MySQLStatementParser::BINARY: {
          setState(6804);
          match(MySQLStatementParser::BINARY);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6807);
      simpleExpr(8);
      break;
    }

    case 7: {
      setState(6809);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::ROW) {
        setState(6808);
        match(MySQLStatementParser::ROW);
      }
      setState(6811);
      match(MySQLStatementParser::LP_);
      setState(6812);
      expr(0);
      setState(6817);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(6813);
        match(MySQLStatementParser::COMMA_);
        setState(6814);
        expr(0);
        setState(6819);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(6820);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 8: {
      setState(6823);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::EXISTS) {
        setState(6822);
        match(MySQLStatementParser::EXISTS);
      }
      setState(6825);
      subquery();
      break;
    }

    case 9: {
      setState(6826);
      match(MySQLStatementParser::LBE_);
      setState(6827);
      identifier();
      setState(6828);
      expr(0);
      setState(6829);
      match(MySQLStatementParser::RBE_);
      break;
    }

    case 10: {
      setState(6831);
      identifier();
      setState(6832);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::JSON_SEPARATOR

      || _la == MySQLStatementParser::JSON_UNQUOTED_SEPARATOR)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6833);
      string_();
      break;
    }

    case 11: {
      setState(6835);
      matchExpression();
      break;
    }

    case 12: {
      setState(6836);
      caseExpression();
      break;
    }

    case 13: {
      setState(6837);
      intervalExpression();
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(6848);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 880, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6846);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 879, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<SimpleExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSimpleExpr);
          setState(6840);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(6841);
          match(MySQLStatementParser::OR_);
          setState(6842);
          simpleExpr(10);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<SimpleExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSimpleExpr);
          setState(6843);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(6844);
          match(MySQLStatementParser::COLLATE);
          setState(6845);
          textOrIdentifier();
          break;
        }

        } 
      }
      setState(6850);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 880, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ColumnRefContext ------------------------------------------------------------------

MySQLStatementParser::ColumnRefContext::ColumnRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::ColumnRefContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ColumnRefContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ColumnRefContext::DOT_() {
  return getTokens(MySQLStatementParser::DOT_);
}

tree::TerminalNode* MySQLStatementParser::ColumnRefContext::DOT_(size_t i) {
  return getToken(MySQLStatementParser::DOT_, i);
}


size_t MySQLStatementParser::ColumnRefContext::getRuleIndex() const {
  return MySQLStatementParser::RuleColumnRef;
}

void MySQLStatementParser::ColumnRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnRef(this);
}

void MySQLStatementParser::ColumnRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnRef(this);
}


antlrcpp::Any MySQLStatementParser::ColumnRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitColumnRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ColumnRefContext* MySQLStatementParser::columnRef() {
  ColumnRefContext *_localctx = _tracker.createInstance<ColumnRefContext>(_ctx, getState());
  enterRule(_localctx, 948, MySQLStatementParser::RuleColumnRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6851);
    identifier();
    setState(6854);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 881, _ctx)) {
    case 1: {
      setState(6852);
      match(MySQLStatementParser::DOT_);
      setState(6853);
      identifier();
      break;
    }

    }
    setState(6858);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 882, _ctx)) {
    case 1: {
      setState(6856);
      match(MySQLStatementParser::DOT_);
      setState(6857);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnRefListContext ------------------------------------------------------------------

MySQLStatementParser::ColumnRefListContext::ColumnRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::ColumnRefContext *> MySQLStatementParser::ColumnRefListContext::columnRef() {
  return getRuleContexts<MySQLStatementParser::ColumnRefContext>();
}

MySQLStatementParser::ColumnRefContext* MySQLStatementParser::ColumnRefListContext::columnRef(size_t i) {
  return getRuleContext<MySQLStatementParser::ColumnRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ColumnRefListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ColumnRefListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::ColumnRefListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleColumnRefList;
}

void MySQLStatementParser::ColumnRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnRefList(this);
}

void MySQLStatementParser::ColumnRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnRefList(this);
}


antlrcpp::Any MySQLStatementParser::ColumnRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitColumnRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ColumnRefListContext* MySQLStatementParser::columnRefList() {
  ColumnRefListContext *_localctx = _tracker.createInstance<ColumnRefListContext>(_ctx, getState());
  enterRule(_localctx, 950, MySQLStatementParser::RuleColumnRefList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6860);
    columnRef();
    setState(6865);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(6861);
      match(MySQLStatementParser::COMMA_);
      setState(6862);
      columnRef();
      setState(6867);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

MySQLStatementParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::AggregationFunctionContext* MySQLStatementParser::FunctionCallContext::aggregationFunction() {
  return getRuleContext<MySQLStatementParser::AggregationFunctionContext>(0);
}

MySQLStatementParser::SpecialFunctionContext* MySQLStatementParser::FunctionCallContext::specialFunction() {
  return getRuleContext<MySQLStatementParser::SpecialFunctionContext>(0);
}

MySQLStatementParser::RegularFunctionContext* MySQLStatementParser::FunctionCallContext::regularFunction() {
  return getRuleContext<MySQLStatementParser::RegularFunctionContext>(0);
}


size_t MySQLStatementParser::FunctionCallContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFunctionCall;
}

void MySQLStatementParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void MySQLStatementParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}


antlrcpp::Any MySQLStatementParser::FunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FunctionCallContext* MySQLStatementParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 952, MySQLStatementParser::RuleFunctionCall);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6871);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 884, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6868);
      aggregationFunction();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6869);
      specialFunction();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6870);
      regularFunction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregationFunctionContext ------------------------------------------------------------------

MySQLStatementParser::AggregationFunctionContext::AggregationFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::AggregationFunctionNameContext* MySQLStatementParser::AggregationFunctionContext::aggregationFunctionName() {
  return getRuleContext<MySQLStatementParser::AggregationFunctionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::DistinctContext* MySQLStatementParser::AggregationFunctionContext::distinct() {
  return getRuleContext<MySQLStatementParser::DistinctContext>(0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::AggregationFunctionContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::AggregationFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}

MySQLStatementParser::OverClauseContext* MySQLStatementParser::AggregationFunctionContext::overClause() {
  return getRuleContext<MySQLStatementParser::OverClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::AggregationFunctionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::AggregationFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAggregationFunction;
}

void MySQLStatementParser::AggregationFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregationFunction(this);
}

void MySQLStatementParser::AggregationFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregationFunction(this);
}


antlrcpp::Any MySQLStatementParser::AggregationFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAggregationFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AggregationFunctionContext* MySQLStatementParser::aggregationFunction() {
  AggregationFunctionContext *_localctx = _tracker.createInstance<AggregationFunctionContext>(_ctx, getState());
  enterRule(_localctx, 954, MySQLStatementParser::RuleAggregationFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6873);
    aggregationFunctionName();
    setState(6874);
    match(MySQLStatementParser::LP_);
    setState(6876);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DISTINCT) {
      setState(6875);
      distinct();
    }
    setState(6887);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CASE:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CONVERT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CUME_DIST:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURRENT_DATE:
      case MySQLStatementParser::CURRENT_TIME:
      case MySQLStatementParser::CURRENT_TIMESTAMP:
      case MySQLStatementParser::CURRENT_USER:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATABASE:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DENSE_RANK:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXISTS:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FALSE:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIRST_VALUE:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IF:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INTERVAL:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LAG:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LAST_VALUE:
      case MySQLStatementParser::LEAD:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LEFT:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCALTIME:
      case MySQLStatementParser::LOCALTIMESTAMP:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MATCH:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MOD:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOT:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NTH_VALUE:
      case MySQLStatementParser::NTILE:
      case MySQLStatementParser::NULL:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERCENT_RANK:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::RANK:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLACE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::RIGHT:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::ROW_NUMBER:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUE:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VALUES:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::NOT_:
      case MySQLStatementParser::TILDE_:
      case MySQLStatementParser::PLUS_:
      case MySQLStatementParser::MINUS_:
      case MySQLStatementParser::DOT_:
      case MySQLStatementParser::LP_:
      case MySQLStatementParser::LBE_:
      case MySQLStatementParser::QUESTION_:
      case MySQLStatementParser::AT_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
      case MySQLStatementParser::NCHAR_TEXT:
      case MySQLStatementParser::UNDERSCORE_CHARSET:
      case MySQLStatementParser::NUMBER_:
      case MySQLStatementParser::HEX_DIGIT_:
      case MySQLStatementParser::BIT_NUM_: {
        setState(6878);
        expr(0);
        setState(6883);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(6879);
          match(MySQLStatementParser::COMMA_);
          setState(6880);
          expr(0);
          setState(6885);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::ASTERISK_: {
        setState(6886);
        match(MySQLStatementParser::ASTERISK_);
        break;
      }

      case MySQLStatementParser::RP_: {
        break;
      }

    default:
      break;
    }
    setState(6889);
    match(MySQLStatementParser::RP_);
    setState(6891);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 888, _ctx)) {
    case 1: {
      setState(6890);
      overClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregationFunctionNameContext ------------------------------------------------------------------

MySQLStatementParser::AggregationFunctionNameContext::AggregationFunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionNameContext::MAX() {
  return getToken(MySQLStatementParser::MAX, 0);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionNameContext::MIN() {
  return getToken(MySQLStatementParser::MIN, 0);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionNameContext::SUM() {
  return getToken(MySQLStatementParser::SUM, 0);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionNameContext::COUNT() {
  return getToken(MySQLStatementParser::COUNT, 0);
}

tree::TerminalNode* MySQLStatementParser::AggregationFunctionNameContext::AVG() {
  return getToken(MySQLStatementParser::AVG, 0);
}


size_t MySQLStatementParser::AggregationFunctionNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAggregationFunctionName;
}

void MySQLStatementParser::AggregationFunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregationFunctionName(this);
}

void MySQLStatementParser::AggregationFunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregationFunctionName(this);
}


antlrcpp::Any MySQLStatementParser::AggregationFunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAggregationFunctionName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AggregationFunctionNameContext* MySQLStatementParser::aggregationFunctionName() {
  AggregationFunctionNameContext *_localctx = _tracker.createInstance<AggregationFunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 956, MySQLStatementParser::RuleAggregationFunctionName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6893);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::AVG))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DistinctContext ------------------------------------------------------------------

MySQLStatementParser::DistinctContext::DistinctContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DistinctContext::DISTINCT() {
  return getToken(MySQLStatementParser::DISTINCT, 0);
}


size_t MySQLStatementParser::DistinctContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDistinct;
}

void MySQLStatementParser::DistinctContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDistinct(this);
}

void MySQLStatementParser::DistinctContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDistinct(this);
}


antlrcpp::Any MySQLStatementParser::DistinctContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDistinct(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DistinctContext* MySQLStatementParser::distinct() {
  DistinctContext *_localctx = _tracker.createInstance<DistinctContext>(_ctx, getState());
  enterRule(_localctx, 958, MySQLStatementParser::RuleDistinct);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6895);
    match(MySQLStatementParser::DISTINCT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OverClauseContext ------------------------------------------------------------------

MySQLStatementParser::OverClauseContext::OverClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OverClauseContext::OVER() {
  return getToken(MySQLStatementParser::OVER, 0);
}

tree::TerminalNode* MySQLStatementParser::OverClauseContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::WindowSpecificationContext* MySQLStatementParser::OverClauseContext::windowSpecification() {
  return getRuleContext<MySQLStatementParser::WindowSpecificationContext>(0);
}

tree::TerminalNode* MySQLStatementParser::OverClauseContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::OverClauseContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::OverClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOverClause;
}

void MySQLStatementParser::OverClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverClause(this);
}

void MySQLStatementParser::OverClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverClause(this);
}


antlrcpp::Any MySQLStatementParser::OverClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOverClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OverClauseContext* MySQLStatementParser::overClause() {
  OverClauseContext *_localctx = _tracker.createInstance<OverClauseContext>(_ctx, getState());
  enterRule(_localctx, 960, MySQLStatementParser::RuleOverClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6897);
    match(MySQLStatementParser::OVER);
    setState(6903);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::LP_: {
        setState(6898);
        match(MySQLStatementParser::LP_);
        setState(6899);
        windowSpecification();
        setState(6900);
        match(MySQLStatementParser::RP_);
        break;
      }

      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(6902);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecificationContext ------------------------------------------------------------------

MySQLStatementParser::WindowSpecificationContext::WindowSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WindowSpecificationContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowSpecificationContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::WindowSpecificationContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WindowSpecificationContext::PARTITION() {
  return getToken(MySQLStatementParser::PARTITION, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowSpecificationContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::WindowSpecificationContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::WindowSpecificationContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

MySQLStatementParser::OrderByClauseContext* MySQLStatementParser::WindowSpecificationContext::orderByClause() {
  return getRuleContext<MySQLStatementParser::OrderByClauseContext>(0);
}

MySQLStatementParser::FrameClauseContext* MySQLStatementParser::WindowSpecificationContext::frameClause() {
  return getRuleContext<MySQLStatementParser::FrameClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::WindowSpecificationContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::WindowSpecificationContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::WindowSpecificationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWindowSpecification;
}

void MySQLStatementParser::WindowSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpecification(this);
}

void MySQLStatementParser::WindowSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpecification(this);
}


antlrcpp::Any MySQLStatementParser::WindowSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWindowSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WindowSpecificationContext* MySQLStatementParser::windowSpecification() {
  WindowSpecificationContext *_localctx = _tracker.createInstance<WindowSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 962, MySQLStatementParser::RuleWindowSpecification);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6905);
    match(MySQLStatementParser::LP_);
    setState(6907);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(6906);
      identifier();
    }
    setState(6919);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::PARTITION) {
      setState(6909);
      match(MySQLStatementParser::PARTITION);
      setState(6910);
      match(MySQLStatementParser::BY);
      setState(6911);
      expr(0);
      setState(6916);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(6912);
        match(MySQLStatementParser::COMMA_);
        setState(6913);
        expr(0);
        setState(6918);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(6922);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ORDER) {
      setState(6921);
      orderByClause();
    }
    setState(6925);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::RANGE

    || _la == MySQLStatementParser::ROWS) {
      setState(6924);
      frameClause();
    }
    setState(6927);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameClauseContext ------------------------------------------------------------------

MySQLStatementParser::FrameClauseContext::FrameClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FrameClauseContext::ROWS() {
  return getToken(MySQLStatementParser::ROWS, 0);
}

tree::TerminalNode* MySQLStatementParser::FrameClauseContext::RANGE() {
  return getToken(MySQLStatementParser::RANGE, 0);
}

MySQLStatementParser::FrameStartContext* MySQLStatementParser::FrameClauseContext::frameStart() {
  return getRuleContext<MySQLStatementParser::FrameStartContext>(0);
}

MySQLStatementParser::FrameBetweenContext* MySQLStatementParser::FrameClauseContext::frameBetween() {
  return getRuleContext<MySQLStatementParser::FrameBetweenContext>(0);
}


size_t MySQLStatementParser::FrameClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFrameClause;
}

void MySQLStatementParser::FrameClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameClause(this);
}

void MySQLStatementParser::FrameClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameClause(this);
}


antlrcpp::Any MySQLStatementParser::FrameClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFrameClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FrameClauseContext* MySQLStatementParser::frameClause() {
  FrameClauseContext *_localctx = _tracker.createInstance<FrameClauseContext>(_ctx, getState());
  enterRule(_localctx, 964, MySQLStatementParser::RuleFrameClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6929);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::RANGE

    || _la == MySQLStatementParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6932);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CASE:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CONVERT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CUME_DIST:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURRENT_DATE:
      case MySQLStatementParser::CURRENT_TIME:
      case MySQLStatementParser::CURRENT_TIMESTAMP:
      case MySQLStatementParser::CURRENT_USER:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATABASE:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DENSE_RANK:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXISTS:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FALSE:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIRST_VALUE:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IF:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INTERVAL:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LAG:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LAST_VALUE:
      case MySQLStatementParser::LEAD:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LEFT:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCALTIME:
      case MySQLStatementParser::LOCALTIMESTAMP:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MATCH:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MOD:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOT:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NTH_VALUE:
      case MySQLStatementParser::NTILE:
      case MySQLStatementParser::NULL:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERCENT_RANK:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::RANK:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLACE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::RIGHT:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::ROW_NUMBER:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUE:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VALUES:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::NOT_:
      case MySQLStatementParser::TILDE_:
      case MySQLStatementParser::PLUS_:
      case MySQLStatementParser::MINUS_:
      case MySQLStatementParser::DOT_:
      case MySQLStatementParser::LP_:
      case MySQLStatementParser::LBE_:
      case MySQLStatementParser::QUESTION_:
      case MySQLStatementParser::AT_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
      case MySQLStatementParser::NCHAR_TEXT:
      case MySQLStatementParser::UNDERSCORE_CHARSET:
      case MySQLStatementParser::NUMBER_:
      case MySQLStatementParser::HEX_DIGIT_:
      case MySQLStatementParser::BIT_NUM_: {
        setState(6930);
        frameStart();
        break;
      }

      case MySQLStatementParser::BETWEEN: {
        setState(6931);
        frameBetween();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameStartContext ------------------------------------------------------------------

MySQLStatementParser::FrameStartContext::FrameStartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FrameStartContext::CURRENT() {
  return getToken(MySQLStatementParser::CURRENT, 0);
}

tree::TerminalNode* MySQLStatementParser::FrameStartContext::ROW() {
  return getToken(MySQLStatementParser::ROW, 0);
}

tree::TerminalNode* MySQLStatementParser::FrameStartContext::UNBOUNDED() {
  return getToken(MySQLStatementParser::UNBOUNDED, 0);
}

tree::TerminalNode* MySQLStatementParser::FrameStartContext::PRECEDING() {
  return getToken(MySQLStatementParser::PRECEDING, 0);
}

tree::TerminalNode* MySQLStatementParser::FrameStartContext::FOLLOWING() {
  return getToken(MySQLStatementParser::FOLLOWING, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::FrameStartContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::FrameStartContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFrameStart;
}

void MySQLStatementParser::FrameStartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameStart(this);
}

void MySQLStatementParser::FrameStartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameStart(this);
}


antlrcpp::Any MySQLStatementParser::FrameStartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFrameStart(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FrameStartContext* MySQLStatementParser::frameStart() {
  FrameStartContext *_localctx = _tracker.createInstance<FrameStartContext>(_ctx, getState());
  enterRule(_localctx, 966, MySQLStatementParser::RuleFrameStart);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6946);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 896, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6934);
      match(MySQLStatementParser::CURRENT);
      setState(6935);
      match(MySQLStatementParser::ROW);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6936);
      match(MySQLStatementParser::UNBOUNDED);
      setState(6937);
      match(MySQLStatementParser::PRECEDING);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6938);
      match(MySQLStatementParser::UNBOUNDED);
      setState(6939);
      match(MySQLStatementParser::FOLLOWING);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6940);
      expr(0);
      setState(6941);
      match(MySQLStatementParser::PRECEDING);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6943);
      expr(0);
      setState(6944);
      match(MySQLStatementParser::FOLLOWING);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameEndContext ------------------------------------------------------------------

MySQLStatementParser::FrameEndContext::FrameEndContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::FrameStartContext* MySQLStatementParser::FrameEndContext::frameStart() {
  return getRuleContext<MySQLStatementParser::FrameStartContext>(0);
}


size_t MySQLStatementParser::FrameEndContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFrameEnd;
}

void MySQLStatementParser::FrameEndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameEnd(this);
}

void MySQLStatementParser::FrameEndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameEnd(this);
}


antlrcpp::Any MySQLStatementParser::FrameEndContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFrameEnd(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FrameEndContext* MySQLStatementParser::frameEnd() {
  FrameEndContext *_localctx = _tracker.createInstance<FrameEndContext>(_ctx, getState());
  enterRule(_localctx, 968, MySQLStatementParser::RuleFrameEnd);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6948);
    frameStart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameBetweenContext ------------------------------------------------------------------

MySQLStatementParser::FrameBetweenContext::FrameBetweenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FrameBetweenContext::BETWEEN() {
  return getToken(MySQLStatementParser::BETWEEN, 0);
}

MySQLStatementParser::FrameStartContext* MySQLStatementParser::FrameBetweenContext::frameStart() {
  return getRuleContext<MySQLStatementParser::FrameStartContext>(0);
}

tree::TerminalNode* MySQLStatementParser::FrameBetweenContext::AND() {
  return getToken(MySQLStatementParser::AND, 0);
}

MySQLStatementParser::FrameEndContext* MySQLStatementParser::FrameBetweenContext::frameEnd() {
  return getRuleContext<MySQLStatementParser::FrameEndContext>(0);
}


size_t MySQLStatementParser::FrameBetweenContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFrameBetween;
}

void MySQLStatementParser::FrameBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameBetween(this);
}

void MySQLStatementParser::FrameBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameBetween(this);
}


antlrcpp::Any MySQLStatementParser::FrameBetweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFrameBetween(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FrameBetweenContext* MySQLStatementParser::frameBetween() {
  FrameBetweenContext *_localctx = _tracker.createInstance<FrameBetweenContext>(_ctx, getState());
  enterRule(_localctx, 970, MySQLStatementParser::RuleFrameBetween);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6950);
    match(MySQLStatementParser::BETWEEN);
    setState(6951);
    frameStart();
    setState(6952);
    match(MySQLStatementParser::AND);
    setState(6953);
    frameEnd();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpecialFunctionContext ------------------------------------------------------------------

MySQLStatementParser::SpecialFunctionContext::SpecialFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::GroupConcatFunctionContext* MySQLStatementParser::SpecialFunctionContext::groupConcatFunction() {
  return getRuleContext<MySQLStatementParser::GroupConcatFunctionContext>(0);
}

MySQLStatementParser::WindowFunctionContext* MySQLStatementParser::SpecialFunctionContext::windowFunction() {
  return getRuleContext<MySQLStatementParser::WindowFunctionContext>(0);
}

MySQLStatementParser::CastFunctionContext* MySQLStatementParser::SpecialFunctionContext::castFunction() {
  return getRuleContext<MySQLStatementParser::CastFunctionContext>(0);
}

MySQLStatementParser::ConvertFunctionContext* MySQLStatementParser::SpecialFunctionContext::convertFunction() {
  return getRuleContext<MySQLStatementParser::ConvertFunctionContext>(0);
}

MySQLStatementParser::PositionFunctionContext* MySQLStatementParser::SpecialFunctionContext::positionFunction() {
  return getRuleContext<MySQLStatementParser::PositionFunctionContext>(0);
}

MySQLStatementParser::SubstringFunctionContext* MySQLStatementParser::SpecialFunctionContext::substringFunction() {
  return getRuleContext<MySQLStatementParser::SubstringFunctionContext>(0);
}

MySQLStatementParser::ExtractFunctionContext* MySQLStatementParser::SpecialFunctionContext::extractFunction() {
  return getRuleContext<MySQLStatementParser::ExtractFunctionContext>(0);
}

MySQLStatementParser::CharFunctionContext* MySQLStatementParser::SpecialFunctionContext::charFunction() {
  return getRuleContext<MySQLStatementParser::CharFunctionContext>(0);
}

MySQLStatementParser::TrimFunctionContext* MySQLStatementParser::SpecialFunctionContext::trimFunction() {
  return getRuleContext<MySQLStatementParser::TrimFunctionContext>(0);
}

MySQLStatementParser::WeightStringFunctionContext* MySQLStatementParser::SpecialFunctionContext::weightStringFunction() {
  return getRuleContext<MySQLStatementParser::WeightStringFunctionContext>(0);
}

MySQLStatementParser::ValuesFunctionContext* MySQLStatementParser::SpecialFunctionContext::valuesFunction() {
  return getRuleContext<MySQLStatementParser::ValuesFunctionContext>(0);
}

MySQLStatementParser::CurrentUserFunctionContext* MySQLStatementParser::SpecialFunctionContext::currentUserFunction() {
  return getRuleContext<MySQLStatementParser::CurrentUserFunctionContext>(0);
}


size_t MySQLStatementParser::SpecialFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSpecialFunction;
}

void MySQLStatementParser::SpecialFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecialFunction(this);
}

void MySQLStatementParser::SpecialFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecialFunction(this);
}


antlrcpp::Any MySQLStatementParser::SpecialFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSpecialFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SpecialFunctionContext* MySQLStatementParser::specialFunction() {
  SpecialFunctionContext *_localctx = _tracker.createInstance<SpecialFunctionContext>(_ctx, getState());
  enterRule(_localctx, 972, MySQLStatementParser::RuleSpecialFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6967);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::GROUP_CONCAT: {
        enterOuterAlt(_localctx, 1);
        setState(6955);
        groupConcatFunction();
        break;
      }

      case MySQLStatementParser::CUME_DIST:
      case MySQLStatementParser::DENSE_RANK:
      case MySQLStatementParser::FIRST_VALUE:
      case MySQLStatementParser::LAG:
      case MySQLStatementParser::LAST_VALUE:
      case MySQLStatementParser::LEAD:
      case MySQLStatementParser::NTH_VALUE:
      case MySQLStatementParser::NTILE:
      case MySQLStatementParser::PERCENT_RANK:
      case MySQLStatementParser::RANK:
      case MySQLStatementParser::ROW_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(6956);
        windowFunction();
        break;
      }

      case MySQLStatementParser::CAST: {
        enterOuterAlt(_localctx, 3);
        setState(6957);
        castFunction();
        break;
      }

      case MySQLStatementParser::CONVERT: {
        enterOuterAlt(_localctx, 4);
        setState(6958);
        convertFunction();
        break;
      }

      case MySQLStatementParser::POSITION: {
        enterOuterAlt(_localctx, 5);
        setState(6959);
        positionFunction();
        break;
      }

      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR: {
        enterOuterAlt(_localctx, 6);
        setState(6960);
        substringFunction();
        break;
      }

      case MySQLStatementParser::EXTRACT: {
        enterOuterAlt(_localctx, 7);
        setState(6961);
        extractFunction();
        break;
      }

      case MySQLStatementParser::CHAR: {
        enterOuterAlt(_localctx, 8);
        setState(6962);
        charFunction();
        break;
      }

      case MySQLStatementParser::TRIM: {
        enterOuterAlt(_localctx, 9);
        setState(6963);
        trimFunction();
        break;
      }

      case MySQLStatementParser::WEIGHT_STRING: {
        enterOuterAlt(_localctx, 10);
        setState(6964);
        weightStringFunction();
        break;
      }

      case MySQLStatementParser::VALUES: {
        enterOuterAlt(_localctx, 11);
        setState(6965);
        valuesFunction();
        break;
      }

      case MySQLStatementParser::CURRENT_USER: {
        enterOuterAlt(_localctx, 12);
        setState(6966);
        currentUserFunction();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CurrentUserFunctionContext ------------------------------------------------------------------

MySQLStatementParser::CurrentUserFunctionContext::CurrentUserFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CurrentUserFunctionContext::CURRENT_USER() {
  return getToken(MySQLStatementParser::CURRENT_USER, 0);
}

tree::TerminalNode* MySQLStatementParser::CurrentUserFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CurrentUserFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::CurrentUserFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCurrentUserFunction;
}

void MySQLStatementParser::CurrentUserFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCurrentUserFunction(this);
}

void MySQLStatementParser::CurrentUserFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCurrentUserFunction(this);
}


antlrcpp::Any MySQLStatementParser::CurrentUserFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCurrentUserFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CurrentUserFunctionContext* MySQLStatementParser::currentUserFunction() {
  CurrentUserFunctionContext *_localctx = _tracker.createInstance<CurrentUserFunctionContext>(_ctx, getState());
  enterRule(_localctx, 974, MySQLStatementParser::RuleCurrentUserFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6969);
    match(MySQLStatementParser::CURRENT_USER);
    setState(6972);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 898, _ctx)) {
    case 1: {
      setState(6970);
      match(MySQLStatementParser::LP_);
      setState(6971);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupConcatFunctionContext ------------------------------------------------------------------

MySQLStatementParser::GroupConcatFunctionContext::GroupConcatFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::GroupConcatFunctionContext::GROUP_CONCAT() {
  return getToken(MySQLStatementParser::GROUP_CONCAT, 0);
}

tree::TerminalNode* MySQLStatementParser::GroupConcatFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::GroupConcatFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::DistinctContext* MySQLStatementParser::GroupConcatFunctionContext::distinct() {
  return getRuleContext<MySQLStatementParser::DistinctContext>(0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::GroupConcatFunctionContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::GroupConcatFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::GroupConcatFunctionContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}

MySQLStatementParser::OrderByClauseContext* MySQLStatementParser::GroupConcatFunctionContext::orderByClause() {
  return getRuleContext<MySQLStatementParser::OrderByClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::GroupConcatFunctionContext::SEPARATOR() {
  return getToken(MySQLStatementParser::SEPARATOR, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::GroupConcatFunctionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::GroupConcatFunctionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::GroupConcatFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleGroupConcatFunction;
}

void MySQLStatementParser::GroupConcatFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupConcatFunction(this);
}

void MySQLStatementParser::GroupConcatFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupConcatFunction(this);
}


antlrcpp::Any MySQLStatementParser::GroupConcatFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitGroupConcatFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::GroupConcatFunctionContext* MySQLStatementParser::groupConcatFunction() {
  GroupConcatFunctionContext *_localctx = _tracker.createInstance<GroupConcatFunctionContext>(_ctx, getState());
  enterRule(_localctx, 976, MySQLStatementParser::RuleGroupConcatFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6974);
    match(MySQLStatementParser::GROUP_CONCAT);
    setState(6975);
    match(MySQLStatementParser::LP_);
    setState(6977);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DISTINCT) {
      setState(6976);
      distinct();
    }
    setState(6988);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CASE:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CONVERT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CUME_DIST:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURRENT_DATE:
      case MySQLStatementParser::CURRENT_TIME:
      case MySQLStatementParser::CURRENT_TIMESTAMP:
      case MySQLStatementParser::CURRENT_USER:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATABASE:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DENSE_RANK:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXISTS:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FALSE:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIRST_VALUE:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IF:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INTERVAL:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LAG:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LAST_VALUE:
      case MySQLStatementParser::LEAD:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LEFT:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCALTIME:
      case MySQLStatementParser::LOCALTIMESTAMP:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MATCH:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MOD:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOT:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NTH_VALUE:
      case MySQLStatementParser::NTILE:
      case MySQLStatementParser::NULL:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERCENT_RANK:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::RANK:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLACE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::RIGHT:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::ROW_NUMBER:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUE:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VALUES:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::NOT_:
      case MySQLStatementParser::TILDE_:
      case MySQLStatementParser::PLUS_:
      case MySQLStatementParser::MINUS_:
      case MySQLStatementParser::DOT_:
      case MySQLStatementParser::LP_:
      case MySQLStatementParser::LBE_:
      case MySQLStatementParser::QUESTION_:
      case MySQLStatementParser::AT_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
      case MySQLStatementParser::NCHAR_TEXT:
      case MySQLStatementParser::UNDERSCORE_CHARSET:
      case MySQLStatementParser::NUMBER_:
      case MySQLStatementParser::HEX_DIGIT_:
      case MySQLStatementParser::BIT_NUM_: {
        setState(6979);
        expr(0);
        setState(6984);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(6980);
          match(MySQLStatementParser::COMMA_);
          setState(6981);
          expr(0);
          setState(6986);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::ASTERISK_: {
        setState(6987);
        match(MySQLStatementParser::ASTERISK_);
        break;
      }

      case MySQLStatementParser::ORDER:
      case MySQLStatementParser::SEPARATOR:
      case MySQLStatementParser::RP_: {
        break;
      }

    default:
      break;
    }
    setState(6991);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ORDER) {
      setState(6990);
      orderByClause();
    }
    setState(6995);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::SEPARATOR) {
      setState(6993);
      match(MySQLStatementParser::SEPARATOR);
      setState(6994);
      expr(0);
    }
    setState(6997);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFunctionContext ------------------------------------------------------------------

MySQLStatementParser::WindowFunctionContext::WindowFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

MySQLStatementParser::WindowingClauseContext* MySQLStatementParser::WindowFunctionContext::windowingClause() {
  return getRuleContext<MySQLStatementParser::WindowingClauseContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::ROW_NUMBER() {
  return getToken(MySQLStatementParser::ROW_NUMBER, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::RANK() {
  return getToken(MySQLStatementParser::RANK, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::DENSE_RANK() {
  return getToken(MySQLStatementParser::DENSE_RANK, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::CUME_DIST() {
  return getToken(MySQLStatementParser::CUME_DIST, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::PERCENT_RANK() {
  return getToken(MySQLStatementParser::PERCENT_RANK, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::NTILE() {
  return getToken(MySQLStatementParser::NTILE, 0);
}

MySQLStatementParser::SimpleExprContext* MySQLStatementParser::WindowFunctionContext::simpleExpr() {
  return getRuleContext<MySQLStatementParser::SimpleExprContext>(0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::WindowFunctionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::LEAD() {
  return getToken(MySQLStatementParser::LEAD, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::LAG() {
  return getToken(MySQLStatementParser::LAG, 0);
}

MySQLStatementParser::LeadLagInfoContext* MySQLStatementParser::WindowFunctionContext::leadLagInfo() {
  return getRuleContext<MySQLStatementParser::LeadLagInfoContext>(0);
}

MySQLStatementParser::NullTreatmentContext* MySQLStatementParser::WindowFunctionContext::nullTreatment() {
  return getRuleContext<MySQLStatementParser::NullTreatmentContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::FIRST_VALUE() {
  return getToken(MySQLStatementParser::FIRST_VALUE, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::LAST_VALUE() {
  return getToken(MySQLStatementParser::LAST_VALUE, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::NTH_VALUE() {
  return getToken(MySQLStatementParser::NTH_VALUE, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::FIRST() {
  return getToken(MySQLStatementParser::FIRST, 0);
}

tree::TerminalNode* MySQLStatementParser::WindowFunctionContext::LAST() {
  return getToken(MySQLStatementParser::LAST, 0);
}


size_t MySQLStatementParser::WindowFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWindowFunction;
}

void MySQLStatementParser::WindowFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFunction(this);
}

void MySQLStatementParser::WindowFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFunction(this);
}


antlrcpp::Any MySQLStatementParser::WindowFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWindowFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WindowFunctionContext* MySQLStatementParser::windowFunction() {
  WindowFunctionContext *_localctx = _tracker.createInstance<WindowFunctionContext>(_ctx, getState());
  enterRule(_localctx, 978, MySQLStatementParser::RuleWindowFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7043);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CUME_DIST:
      case MySQLStatementParser::DENSE_RANK:
      case MySQLStatementParser::PERCENT_RANK:
      case MySQLStatementParser::RANK:
      case MySQLStatementParser::ROW_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(6999);
        dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::CUME_DIST

        || _la == MySQLStatementParser::DENSE_RANK || _la == MySQLStatementParser::PERCENT_RANK

        || _la == MySQLStatementParser::RANK || _la == MySQLStatementParser::ROW_NUMBER)) {
          dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7000);
        match(MySQLStatementParser::LP_);
        setState(7001);
        match(MySQLStatementParser::RP_);
        setState(7002);
        windowingClause();
        break;
      }

      case MySQLStatementParser::NTILE: {
        enterOuterAlt(_localctx, 2);
        setState(7003);
        dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = match(MySQLStatementParser::NTILE);

        setState(7004);
        simpleExpr(0);
        setState(7005);
        windowingClause();
        break;
      }

      case MySQLStatementParser::LAG:
      case MySQLStatementParser::LEAD: {
        enterOuterAlt(_localctx, 3);
        setState(7007);
        dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::LAG

        || _la == MySQLStatementParser::LEAD)) {
          dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7008);
        match(MySQLStatementParser::LP_);
        setState(7009);
        expr(0);
        setState(7011);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::COMMA_) {
          setState(7010);
          leadLagInfo();
        }
        setState(7013);
        match(MySQLStatementParser::RP_);
        setState(7015);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::RESPECT) {
          setState(7014);
          nullTreatment();
        }
        setState(7017);
        windowingClause();
        break;
      }

      case MySQLStatementParser::FIRST_VALUE:
      case MySQLStatementParser::LAST_VALUE: {
        enterOuterAlt(_localctx, 4);
        setState(7019);
        dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::FIRST_VALUE || _la == MySQLStatementParser::LAST_VALUE)) {
          dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7020);
        match(MySQLStatementParser::LP_);
        setState(7021);
        expr(0);
        setState(7022);
        match(MySQLStatementParser::RP_);
        setState(7024);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::RESPECT) {
          setState(7023);
          nullTreatment();
        }
        setState(7026);
        windowingClause();
        break;
      }

      case MySQLStatementParser::NTH_VALUE: {
        enterOuterAlt(_localctx, 5);
        setState(7028);
        dynamic_cast<WindowFunctionContext *>(_localctx)->funcName = match(MySQLStatementParser::NTH_VALUE);
        setState(7029);
        match(MySQLStatementParser::LP_);
        setState(7030);
        expr(0);
        setState(7031);
        match(MySQLStatementParser::COMMA_);
        setState(7032);
        simpleExpr(0);
        setState(7033);
        match(MySQLStatementParser::RP_);
        setState(7036);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::FROM) {
          setState(7034);
          match(MySQLStatementParser::FROM);
          setState(7035);
          _la = _input->LA(1);
          if (!(_la == MySQLStatementParser::FIRST || _la == MySQLStatementParser::LAST)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(7039);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::RESPECT) {
          setState(7038);
          nullTreatment();
        }
        setState(7041);
        windowingClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowingClauseContext ------------------------------------------------------------------

MySQLStatementParser::WindowingClauseContext::WindowingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WindowingClauseContext::OVER() {
  return getToken(MySQLStatementParser::OVER, 0);
}

MySQLStatementParser::WindowSpecificationContext* MySQLStatementParser::WindowingClauseContext::windowSpecification() {
  return getRuleContext<MySQLStatementParser::WindowSpecificationContext>(0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::WindowingClauseContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::WindowingClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWindowingClause;
}

void MySQLStatementParser::WindowingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowingClause(this);
}

void MySQLStatementParser::WindowingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowingClause(this);
}


antlrcpp::Any MySQLStatementParser::WindowingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWindowingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WindowingClauseContext* MySQLStatementParser::windowingClause() {
  WindowingClauseContext *_localctx = _tracker.createInstance<WindowingClauseContext>(_ctx, getState());
  enterRule(_localctx, 980, MySQLStatementParser::RuleWindowingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7045);
    match(MySQLStatementParser::OVER);
    setState(7048);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(7046);
        dynamic_cast<WindowingClauseContext *>(_localctx)->windowName = identifier();
        break;
      }

      case MySQLStatementParser::LP_: {
        setState(7047);
        windowSpecification();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeadLagInfoContext ------------------------------------------------------------------

MySQLStatementParser::LeadLagInfoContext::LeadLagInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LeadLagInfoContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::LeadLagInfoContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::LeadLagInfoContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::LeadLagInfoContext::QUESTION_() {
  return getToken(MySQLStatementParser::QUESTION_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::LeadLagInfoContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::LeadLagInfoContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLeadLagInfo;
}

void MySQLStatementParser::LeadLagInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeadLagInfo(this);
}

void MySQLStatementParser::LeadLagInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeadLagInfo(this);
}


antlrcpp::Any MySQLStatementParser::LeadLagInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLeadLagInfo(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LeadLagInfoContext* MySQLStatementParser::leadLagInfo() {
  LeadLagInfoContext *_localctx = _tracker.createInstance<LeadLagInfoContext>(_ctx, getState());
  enterRule(_localctx, 982, MySQLStatementParser::RuleLeadLagInfo);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7050);
    match(MySQLStatementParser::COMMA_);
    setState(7051);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::QUESTION_

    || _la == MySQLStatementParser::NUMBER_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7054);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::COMMA_) {
      setState(7052);
      match(MySQLStatementParser::COMMA_);
      setState(7053);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullTreatmentContext ------------------------------------------------------------------

MySQLStatementParser::NullTreatmentContext::NullTreatmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NullTreatmentContext::NULLS() {
  return getToken(MySQLStatementParser::NULLS, 0);
}

tree::TerminalNode* MySQLStatementParser::NullTreatmentContext::RESPECT() {
  return getToken(MySQLStatementParser::RESPECT, 0);
}

tree::TerminalNode* MySQLStatementParser::NullTreatmentContext::IGNORE() {
  return getToken(MySQLStatementParser::IGNORE, 0);
}


size_t MySQLStatementParser::NullTreatmentContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNullTreatment;
}

void MySQLStatementParser::NullTreatmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullTreatment(this);
}

void MySQLStatementParser::NullTreatmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullTreatment(this);
}


antlrcpp::Any MySQLStatementParser::NullTreatmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNullTreatment(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NullTreatmentContext* MySQLStatementParser::nullTreatment() {
  NullTreatmentContext *_localctx = _tracker.createInstance<NullTreatmentContext>(_ctx, getState());
  enterRule(_localctx, 984, MySQLStatementParser::RuleNullTreatment);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7056);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::IGNORE || _la == MySQLStatementParser::RESPECT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7057);
    match(MySQLStatementParser::NULLS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckTypeContext ------------------------------------------------------------------

MySQLStatementParser::CheckTypeContext::CheckTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CheckTypeContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTypeContext::UPGRADE() {
  return getToken(MySQLStatementParser::UPGRADE, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTypeContext::QUICK() {
  return getToken(MySQLStatementParser::QUICK, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTypeContext::FAST() {
  return getToken(MySQLStatementParser::FAST, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTypeContext::MEDIUM() {
  return getToken(MySQLStatementParser::MEDIUM, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTypeContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

tree::TerminalNode* MySQLStatementParser::CheckTypeContext::CHANGED() {
  return getToken(MySQLStatementParser::CHANGED, 0);
}


size_t MySQLStatementParser::CheckTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCheckType;
}

void MySQLStatementParser::CheckTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckType(this);
}

void MySQLStatementParser::CheckTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckType(this);
}


antlrcpp::Any MySQLStatementParser::CheckTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCheckType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CheckTypeContext* MySQLStatementParser::checkType() {
  CheckTypeContext *_localctx = _tracker.createInstance<CheckTypeContext>(_ctx, getState());
  enterRule(_localctx, 986, MySQLStatementParser::RuleCheckType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7066);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(7059);
        match(MySQLStatementParser::FOR);
        setState(7060);
        match(MySQLStatementParser::UPGRADE);
        break;
      }

      case MySQLStatementParser::QUICK: {
        enterOuterAlt(_localctx, 2);
        setState(7061);
        match(MySQLStatementParser::QUICK);
        break;
      }

      case MySQLStatementParser::FAST: {
        enterOuterAlt(_localctx, 3);
        setState(7062);
        match(MySQLStatementParser::FAST);
        break;
      }

      case MySQLStatementParser::MEDIUM: {
        enterOuterAlt(_localctx, 4);
        setState(7063);
        match(MySQLStatementParser::MEDIUM);
        break;
      }

      case MySQLStatementParser::EXTENDED: {
        enterOuterAlt(_localctx, 5);
        setState(7064);
        match(MySQLStatementParser::EXTENDED);
        break;
      }

      case MySQLStatementParser::CHANGED: {
        enterOuterAlt(_localctx, 6);
        setState(7065);
        match(MySQLStatementParser::CHANGED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepairTypeContext ------------------------------------------------------------------

MySQLStatementParser::RepairTypeContext::RepairTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RepairTypeContext::QUICK() {
  return getToken(MySQLStatementParser::QUICK, 0);
}

tree::TerminalNode* MySQLStatementParser::RepairTypeContext::EXTENDED() {
  return getToken(MySQLStatementParser::EXTENDED, 0);
}

tree::TerminalNode* MySQLStatementParser::RepairTypeContext::USE_FRM() {
  return getToken(MySQLStatementParser::USE_FRM, 0);
}


size_t MySQLStatementParser::RepairTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRepairType;
}

void MySQLStatementParser::RepairTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepairType(this);
}

void MySQLStatementParser::RepairTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepairType(this);
}


antlrcpp::Any MySQLStatementParser::RepairTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRepairType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RepairTypeContext* MySQLStatementParser::repairType() {
  RepairTypeContext *_localctx = _tracker.createInstance<RepairTypeContext>(_ctx, getState());
  enterRule(_localctx, 988, MySQLStatementParser::RuleRepairType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7068);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::EXTENDED || _la == MySQLStatementParser::QUICK || _la == MySQLStatementParser::USE_FRM)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastFunctionContext ------------------------------------------------------------------

MySQLStatementParser::CastFunctionContext::CastFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CastFunctionContext::CAST() {
  return getToken(MySQLStatementParser::CAST, 0);
}

tree::TerminalNode* MySQLStatementParser::CastFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CastFunctionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CastFunctionContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::DataTypeContext* MySQLStatementParser::CastFunctionContext::dataType() {
  return getRuleContext<MySQLStatementParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CastFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::CastFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCastFunction;
}

void MySQLStatementParser::CastFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastFunction(this);
}

void MySQLStatementParser::CastFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastFunction(this);
}


antlrcpp::Any MySQLStatementParser::CastFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCastFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CastFunctionContext* MySQLStatementParser::castFunction() {
  CastFunctionContext *_localctx = _tracker.createInstance<CastFunctionContext>(_ctx, getState());
  enterRule(_localctx, 990, MySQLStatementParser::RuleCastFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7070);
    match(MySQLStatementParser::CAST);
    setState(7071);
    match(MySQLStatementParser::LP_);
    setState(7072);
    expr(0);
    setState(7073);
    match(MySQLStatementParser::AS);
    setState(7074);
    dataType();
    setState(7075);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConvertFunctionContext ------------------------------------------------------------------

MySQLStatementParser::ConvertFunctionContext::ConvertFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConvertFunctionContext::CONVERT() {
  return getToken(MySQLStatementParser::CONVERT, 0);
}

tree::TerminalNode* MySQLStatementParser::ConvertFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::ConvertFunctionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ConvertFunctionContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}

MySQLStatementParser::CastTypeContext* MySQLStatementParser::ConvertFunctionContext::castType() {
  return getRuleContext<MySQLStatementParser::CastTypeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ConvertFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ConvertFunctionContext::USING() {
  return getToken(MySQLStatementParser::USING, 0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::ConvertFunctionContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}


size_t MySQLStatementParser::ConvertFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConvertFunction;
}

void MySQLStatementParser::ConvertFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConvertFunction(this);
}

void MySQLStatementParser::ConvertFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConvertFunction(this);
}


antlrcpp::Any MySQLStatementParser::ConvertFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConvertFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConvertFunctionContext* MySQLStatementParser::convertFunction() {
  ConvertFunctionContext *_localctx = _tracker.createInstance<ConvertFunctionContext>(_ctx, getState());
  enterRule(_localctx, 992, MySQLStatementParser::RuleConvertFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7091);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 913, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7077);
      match(MySQLStatementParser::CONVERT);
      setState(7078);
      match(MySQLStatementParser::LP_);
      setState(7079);
      expr(0);
      setState(7080);
      match(MySQLStatementParser::COMMA_);
      setState(7081);
      castType();
      setState(7082);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7084);
      match(MySQLStatementParser::CONVERT);
      setState(7085);
      match(MySQLStatementParser::LP_);
      setState(7086);
      expr(0);
      setState(7087);
      match(MySQLStatementParser::USING);
      setState(7088);
      charsetName();
      setState(7089);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastTypeContext ------------------------------------------------------------------

MySQLStatementParser::CastTypeContext::CastTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}

MySQLStatementParser::FieldLengthContext* MySQLStatementParser::CastTypeContext::fieldLength() {
  return getRuleContext<MySQLStatementParser::FieldLengthContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::CHAR() {
  return getToken(MySQLStatementParser::CHAR, 0);
}

MySQLStatementParser::CharsetWithOptBinaryContext* MySQLStatementParser::CastTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLStatementParser::CharsetWithOptBinaryContext>(0);
}

MySQLStatementParser::NcharContext* MySQLStatementParser::CastTypeContext::nchar() {
  return getRuleContext<MySQLStatementParser::NcharContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::SIGNED() {
  return getToken(MySQLStatementParser::SIGNED, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::INT() {
  return getToken(MySQLStatementParser::INT, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::UNSIGNED() {
  return getToken(MySQLStatementParser::UNSIGNED, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::DATE() {
  return getToken(MySQLStatementParser::DATE, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::TIME() {
  return getToken(MySQLStatementParser::TIME, 0);
}

MySQLStatementParser::TypeDatetimePrecisionContext* MySQLStatementParser::CastTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLStatementParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::DATETIME() {
  return getToken(MySQLStatementParser::DATETIME, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::DECIMAL() {
  return getToken(MySQLStatementParser::DECIMAL, 0);
}

MySQLStatementParser::PrecisionContext* MySQLStatementParser::CastTypeContext::precision() {
  return getRuleContext<MySQLStatementParser::PrecisionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::JSON() {
  return getToken(MySQLStatementParser::JSON, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::REAL() {
  return getToken(MySQLStatementParser::REAL, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::DOUBLE() {
  return getToken(MySQLStatementParser::DOUBLE, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::PRECISION() {
  return getToken(MySQLStatementParser::PRECISION, 0);
}

tree::TerminalNode* MySQLStatementParser::CastTypeContext::FLOAT() {
  return getToken(MySQLStatementParser::FLOAT, 0);
}


size_t MySQLStatementParser::CastTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCastType;
}

void MySQLStatementParser::CastTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastType(this);
}

void MySQLStatementParser::CastTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastType(this);
}


antlrcpp::Any MySQLStatementParser::CastTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCastType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CastTypeContext* MySQLStatementParser::castType() {
  CastTypeContext *_localctx = _tracker.createInstance<CastTypeContext>(_ctx, getState());
  enterRule(_localctx, 994, MySQLStatementParser::RuleCastType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7138);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::BINARY: {
        enterOuterAlt(_localctx, 1);
        setState(7093);
        match(MySQLStatementParser::BINARY);
        setState(7095);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(7094);
          fieldLength();
        }
        break;
      }

      case MySQLStatementParser::CHAR: {
        enterOuterAlt(_localctx, 2);
        setState(7097);
        match(MySQLStatementParser::CHAR);
        setState(7099);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(7098);
          fieldLength();
        }
        setState(7102);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 44) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 44)) & ((1ULL << (MySQLStatementParser::ASCII - 44))
          | (1ULL << (MySQLStatementParser::BINARY - 44))
          | (1ULL << (MySQLStatementParser::BYTE - 44))
          | (1ULL << (MySQLStatementParser::CHAR - 44))
          | (1ULL << (MySQLStatementParser::CHARACTER - 44))
          | (1ULL << (MySQLStatementParser::CHARSET - 44)))) != 0) || _la == MySQLStatementParser::UNICODE) {
          setState(7101);
          charsetWithOptBinary();
        }
        break;
      }

      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR: {
        enterOuterAlt(_localctx, 3);
        setState(7104);
        nchar();
        setState(7106);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(7105);
          fieldLength();
        }
        break;
      }

      case MySQLStatementParser::SIGNED: {
        enterOuterAlt(_localctx, 4);
        setState(7108);
        match(MySQLStatementParser::SIGNED);
        setState(7110);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::INT) {
          setState(7109);
          match(MySQLStatementParser::INT);
        }
        break;
      }

      case MySQLStatementParser::UNSIGNED: {
        enterOuterAlt(_localctx, 5);
        setState(7112);
        match(MySQLStatementParser::UNSIGNED);
        setState(7114);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::INT) {
          setState(7113);
          match(MySQLStatementParser::INT);
        }
        break;
      }

      case MySQLStatementParser::DATE: {
        enterOuterAlt(_localctx, 6);
        setState(7116);
        match(MySQLStatementParser::DATE);
        break;
      }

      case MySQLStatementParser::TIME: {
        enterOuterAlt(_localctx, 7);
        setState(7117);
        match(MySQLStatementParser::TIME);
        setState(7119);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(7118);
          typeDatetimePrecision();
        }
        break;
      }

      case MySQLStatementParser::DATETIME: {
        enterOuterAlt(_localctx, 8);
        setState(7121);
        match(MySQLStatementParser::DATETIME);
        setState(7123);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(7122);
          typeDatetimePrecision();
        }
        break;
      }

      case MySQLStatementParser::DECIMAL: {
        enterOuterAlt(_localctx, 9);
        setState(7125);
        match(MySQLStatementParser::DECIMAL);
        setState(7128);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 922, _ctx)) {
        case 1: {
          setState(7126);
          fieldLength();
          break;
        }

        case 2: {
          setState(7127);
          precision();
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::JSON: {
        enterOuterAlt(_localctx, 10);
        setState(7130);
        match(MySQLStatementParser::JSON);
        break;
      }

      case MySQLStatementParser::REAL: {
        enterOuterAlt(_localctx, 11);
        setState(7131);
        match(MySQLStatementParser::REAL);
        break;
      }

      case MySQLStatementParser::DOUBLE: {
        enterOuterAlt(_localctx, 12);
        setState(7132);
        match(MySQLStatementParser::DOUBLE);
        setState(7133);
        match(MySQLStatementParser::PRECISION);
        break;
      }

      case MySQLStatementParser::FLOAT: {
        enterOuterAlt(_localctx, 13);
        setState(7134);
        match(MySQLStatementParser::FLOAT);
        setState(7136);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::LP_) {
          setState(7135);
          precision();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NcharContext ------------------------------------------------------------------

MySQLStatementParser::NcharContext::NcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NcharContext::NCHAR() {
  return getToken(MySQLStatementParser::NCHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::NcharContext::NATIONAL() {
  return getToken(MySQLStatementParser::NATIONAL, 0);
}

tree::TerminalNode* MySQLStatementParser::NcharContext::CHAR() {
  return getToken(MySQLStatementParser::CHAR, 0);
}


size_t MySQLStatementParser::NcharContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNchar;
}

void MySQLStatementParser::NcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNchar(this);
}

void MySQLStatementParser::NcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNchar(this);
}


antlrcpp::Any MySQLStatementParser::NcharContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNchar(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NcharContext* MySQLStatementParser::nchar() {
  NcharContext *_localctx = _tracker.createInstance<NcharContext>(_ctx, getState());
  enterRule(_localctx, 996, MySQLStatementParser::RuleNchar);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7143);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::NCHAR: {
        enterOuterAlt(_localctx, 1);
        setState(7140);
        match(MySQLStatementParser::NCHAR);
        break;
      }

      case MySQLStatementParser::NATIONAL: {
        enterOuterAlt(_localctx, 2);
        setState(7141);
        match(MySQLStatementParser::NATIONAL);
        setState(7142);
        match(MySQLStatementParser::CHAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PositionFunctionContext ------------------------------------------------------------------

MySQLStatementParser::PositionFunctionContext::PositionFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PositionFunctionContext::POSITION() {
  return getToken(MySQLStatementParser::POSITION, 0);
}

tree::TerminalNode* MySQLStatementParser::PositionFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::PositionFunctionContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::PositionFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::PositionFunctionContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

tree::TerminalNode* MySQLStatementParser::PositionFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::PositionFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RulePositionFunction;
}

void MySQLStatementParser::PositionFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPositionFunction(this);
}

void MySQLStatementParser::PositionFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPositionFunction(this);
}


antlrcpp::Any MySQLStatementParser::PositionFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPositionFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PositionFunctionContext* MySQLStatementParser::positionFunction() {
  PositionFunctionContext *_localctx = _tracker.createInstance<PositionFunctionContext>(_ctx, getState());
  enterRule(_localctx, 998, MySQLStatementParser::RulePositionFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7145);
    match(MySQLStatementParser::POSITION);
    setState(7146);
    match(MySQLStatementParser::LP_);
    setState(7147);
    expr(0);
    setState(7148);
    match(MySQLStatementParser::IN);
    setState(7149);
    expr(0);
    setState(7150);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubstringFunctionContext ------------------------------------------------------------------

MySQLStatementParser::SubstringFunctionContext::SubstringFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::SubstringFunctionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SubstringFunctionContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::SUBSTRING() {
  return getToken(MySQLStatementParser::SUBSTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::SUBSTR() {
  return getToken(MySQLStatementParser::SUBSTR, 0);
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::SubstringFunctionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::SubstringFunctionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::SubstringFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSubstringFunction;
}

void MySQLStatementParser::SubstringFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstringFunction(this);
}

void MySQLStatementParser::SubstringFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstringFunction(this);
}


antlrcpp::Any MySQLStatementParser::SubstringFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSubstringFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SubstringFunctionContext* MySQLStatementParser::substringFunction() {
  SubstringFunctionContext *_localctx = _tracker.createInstance<SubstringFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1000, MySQLStatementParser::RuleSubstringFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7174);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 928, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7152);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::SUBSTRING

      || _la == MySQLStatementParser::SUBSTR)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7153);
      match(MySQLStatementParser::LP_);
      setState(7154);
      expr(0);
      setState(7155);
      match(MySQLStatementParser::FROM);
      setState(7156);
      match(MySQLStatementParser::NUMBER_);
      setState(7159);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::FOR) {
        setState(7157);
        match(MySQLStatementParser::FOR);
        setState(7158);
        match(MySQLStatementParser::NUMBER_);
      }
      setState(7161);
      match(MySQLStatementParser::RP_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7163);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::SUBSTRING

      || _la == MySQLStatementParser::SUBSTR)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7164);
      match(MySQLStatementParser::LP_);
      setState(7165);
      expr(0);
      setState(7166);
      match(MySQLStatementParser::COMMA_);
      setState(7167);
      match(MySQLStatementParser::NUMBER_);
      setState(7170);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::COMMA_) {
        setState(7168);
        match(MySQLStatementParser::COMMA_);
        setState(7169);
        match(MySQLStatementParser::NUMBER_);
      }
      setState(7172);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExtractFunctionContext ------------------------------------------------------------------

MySQLStatementParser::ExtractFunctionContext::ExtractFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ExtractFunctionContext::EXTRACT() {
  return getToken(MySQLStatementParser::EXTRACT, 0);
}

tree::TerminalNode* MySQLStatementParser::ExtractFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ExtractFunctionContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ExtractFunctionContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::ExtractFunctionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ExtractFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::ExtractFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExtractFunction;
}

void MySQLStatementParser::ExtractFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtractFunction(this);
}

void MySQLStatementParser::ExtractFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtractFunction(this);
}


antlrcpp::Any MySQLStatementParser::ExtractFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExtractFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExtractFunctionContext* MySQLStatementParser::extractFunction() {
  ExtractFunctionContext *_localctx = _tracker.createInstance<ExtractFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1002, MySQLStatementParser::RuleExtractFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7176);
    match(MySQLStatementParser::EXTRACT);
    setState(7177);
    match(MySQLStatementParser::LP_);
    setState(7178);
    identifier();
    setState(7179);
    match(MySQLStatementParser::FROM);
    setState(7180);
    expr(0);
    setState(7181);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharFunctionContext ------------------------------------------------------------------

MySQLStatementParser::CharFunctionContext::CharFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CharFunctionContext::CHAR() {
  return getToken(MySQLStatementParser::CHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::CharFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::CharFunctionContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CharFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CharFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CharFunctionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CharFunctionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}

tree::TerminalNode* MySQLStatementParser::CharFunctionContext::USING() {
  return getToken(MySQLStatementParser::USING, 0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::CharFunctionContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}


size_t MySQLStatementParser::CharFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCharFunction;
}

void MySQLStatementParser::CharFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharFunction(this);
}

void MySQLStatementParser::CharFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharFunction(this);
}


antlrcpp::Any MySQLStatementParser::CharFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCharFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CharFunctionContext* MySQLStatementParser::charFunction() {
  CharFunctionContext *_localctx = _tracker.createInstance<CharFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1004, MySQLStatementParser::RuleCharFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7183);
    match(MySQLStatementParser::CHAR);
    setState(7184);
    match(MySQLStatementParser::LP_);
    setState(7185);
    expr(0);
    setState(7190);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(7186);
      match(MySQLStatementParser::COMMA_);
      setState(7187);
      expr(0);
      setState(7192);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7195);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::USING) {
      setState(7193);
      match(MySQLStatementParser::USING);
      setState(7194);
      charsetName();
    }
    setState(7197);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrimFunctionContext ------------------------------------------------------------------

MySQLStatementParser::TrimFunctionContext::TrimFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TrimFunctionContext::TRIM() {
  return getToken(MySQLStatementParser::TRIM, 0);
}

tree::TerminalNode* MySQLStatementParser::TrimFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::String_Context *> MySQLStatementParser::TrimFunctionContext::string_() {
  return getRuleContexts<MySQLStatementParser::String_Context>();
}

MySQLStatementParser::String_Context* MySQLStatementParser::TrimFunctionContext::string_(size_t i) {
  return getRuleContext<MySQLStatementParser::String_Context>(i);
}

tree::TerminalNode* MySQLStatementParser::TrimFunctionContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

tree::TerminalNode* MySQLStatementParser::TrimFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::TrimFunctionContext::LEADING() {
  return getToken(MySQLStatementParser::LEADING, 0);
}

tree::TerminalNode* MySQLStatementParser::TrimFunctionContext::BOTH() {
  return getToken(MySQLStatementParser::BOTH, 0);
}

tree::TerminalNode* MySQLStatementParser::TrimFunctionContext::TRAILING() {
  return getToken(MySQLStatementParser::TRAILING, 0);
}


size_t MySQLStatementParser::TrimFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTrimFunction;
}

void MySQLStatementParser::TrimFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrimFunction(this);
}

void MySQLStatementParser::TrimFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrimFunction(this);
}


antlrcpp::Any MySQLStatementParser::TrimFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTrimFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TrimFunctionContext* MySQLStatementParser::trimFunction() {
  TrimFunctionContext *_localctx = _tracker.createInstance<TrimFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1006, MySQLStatementParser::RuleTrimFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7199);
    match(MySQLStatementParser::TRIM);
    setState(7200);
    match(MySQLStatementParser::LP_);
    setState(7201);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::BOTH || _la == MySQLStatementParser::LEADING || _la == MySQLStatementParser::TRAILING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7202);
    string_();
    setState(7203);
    match(MySQLStatementParser::FROM);
    setState(7204);
    string_();
    setState(7205);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValuesFunctionContext ------------------------------------------------------------------

MySQLStatementParser::ValuesFunctionContext::ValuesFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ValuesFunctionContext::VALUES() {
  return getToken(MySQLStatementParser::VALUES, 0);
}

tree::TerminalNode* MySQLStatementParser::ValuesFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ColumnRefListContext* MySQLStatementParser::ValuesFunctionContext::columnRefList() {
  return getRuleContext<MySQLStatementParser::ColumnRefListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ValuesFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::ValuesFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleValuesFunction;
}

void MySQLStatementParser::ValuesFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValuesFunction(this);
}

void MySQLStatementParser::ValuesFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValuesFunction(this);
}


antlrcpp::Any MySQLStatementParser::ValuesFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitValuesFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ValuesFunctionContext* MySQLStatementParser::valuesFunction() {
  ValuesFunctionContext *_localctx = _tracker.createInstance<ValuesFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1008, MySQLStatementParser::RuleValuesFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7207);
    match(MySQLStatementParser::VALUES);
    setState(7208);
    match(MySQLStatementParser::LP_);
    setState(7209);
    columnRefList();
    setState(7210);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WeightStringFunctionContext ------------------------------------------------------------------

MySQLStatementParser::WeightStringFunctionContext::WeightStringFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::WeightStringFunctionContext::WEIGHT_STRING() {
  return getToken(MySQLStatementParser::WEIGHT_STRING, 0);
}

tree::TerminalNode* MySQLStatementParser::WeightStringFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::WeightStringFunctionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

tree::TerminalNode* MySQLStatementParser::WeightStringFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::WeightStringFunctionContext::AS() {
  return getToken(MySQLStatementParser::AS, 0);
}

MySQLStatementParser::DataTypeContext* MySQLStatementParser::WeightStringFunctionContext::dataType() {
  return getRuleContext<MySQLStatementParser::DataTypeContext>(0);
}

MySQLStatementParser::LevelClauseContext* MySQLStatementParser::WeightStringFunctionContext::levelClause() {
  return getRuleContext<MySQLStatementParser::LevelClauseContext>(0);
}


size_t MySQLStatementParser::WeightStringFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleWeightStringFunction;
}

void MySQLStatementParser::WeightStringFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightStringFunction(this);
}

void MySQLStatementParser::WeightStringFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightStringFunction(this);
}


antlrcpp::Any MySQLStatementParser::WeightStringFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitWeightStringFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::WeightStringFunctionContext* MySQLStatementParser::weightStringFunction() {
  WeightStringFunctionContext *_localctx = _tracker.createInstance<WeightStringFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1010, MySQLStatementParser::RuleWeightStringFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7212);
    match(MySQLStatementParser::WEIGHT_STRING);
    setState(7213);
    match(MySQLStatementParser::LP_);
    setState(7214);
    expr(0);
    setState(7217);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::AS) {
      setState(7215);
      match(MySQLStatementParser::AS);
      setState(7216);
      dataType();
    }
    setState(7220);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::LEVEL) {
      setState(7219);
      levelClause();
    }
    setState(7222);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LevelClauseContext ------------------------------------------------------------------

MySQLStatementParser::LevelClauseContext::LevelClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LevelClauseContext::LEVEL() {
  return getToken(MySQLStatementParser::LEVEL, 0);
}

std::vector<MySQLStatementParser::LevelInWeightListElementContext *> MySQLStatementParser::LevelClauseContext::levelInWeightListElement() {
  return getRuleContexts<MySQLStatementParser::LevelInWeightListElementContext>();
}

MySQLStatementParser::LevelInWeightListElementContext* MySQLStatementParser::LevelClauseContext::levelInWeightListElement(size_t i) {
  return getRuleContext<MySQLStatementParser::LevelInWeightListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LevelClauseContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::LevelClauseContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::LevelClauseContext::MINUS_() {
  return getToken(MySQLStatementParser::MINUS_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::LevelClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::LevelClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::LevelClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLevelClause;
}

void MySQLStatementParser::LevelClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevelClause(this);
}

void MySQLStatementParser::LevelClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevelClause(this);
}


antlrcpp::Any MySQLStatementParser::LevelClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLevelClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LevelClauseContext* MySQLStatementParser::levelClause() {
  LevelClauseContext *_localctx = _tracker.createInstance<LevelClauseContext>(_ctx, getState());
  enterRule(_localctx, 1012, MySQLStatementParser::RuleLevelClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7224);
    match(MySQLStatementParser::LEVEL);
    setState(7236);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 934, _ctx)) {
    case 1: {
      setState(7225);
      levelInWeightListElement();
      setState(7230);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(7226);
        match(MySQLStatementParser::COMMA_);
        setState(7227);
        levelInWeightListElement();
        setState(7232);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(7233);
      match(MySQLStatementParser::NUMBER_);
      setState(7234);
      match(MySQLStatementParser::MINUS_);
      setState(7235);
      match(MySQLStatementParser::NUMBER_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LevelInWeightListElementContext ------------------------------------------------------------------

MySQLStatementParser::LevelInWeightListElementContext::LevelInWeightListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::LevelInWeightListElementContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

MySQLStatementParser::DirectionContext* MySQLStatementParser::LevelInWeightListElementContext::direction() {
  return getRuleContext<MySQLStatementParser::DirectionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::LevelInWeightListElementContext::REVERSE() {
  return getToken(MySQLStatementParser::REVERSE, 0);
}


size_t MySQLStatementParser::LevelInWeightListElementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLevelInWeightListElement;
}

void MySQLStatementParser::LevelInWeightListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevelInWeightListElement(this);
}

void MySQLStatementParser::LevelInWeightListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevelInWeightListElement(this);
}


antlrcpp::Any MySQLStatementParser::LevelInWeightListElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLevelInWeightListElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LevelInWeightListElementContext* MySQLStatementParser::levelInWeightListElement() {
  LevelInWeightListElementContext *_localctx = _tracker.createInstance<LevelInWeightListElementContext>(_ctx, getState());
  enterRule(_localctx, 1014, MySQLStatementParser::RuleLevelInWeightListElement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7238);
    match(MySQLStatementParser::NUMBER_);
    setState(7240);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ASC || _la == MySQLStatementParser::DESC) {
      setState(7239);
      direction();
    }
    setState(7243);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::REVERSE) {
      setState(7242);
      match(MySQLStatementParser::REVERSE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegularFunctionContext ------------------------------------------------------------------

MySQLStatementParser::RegularFunctionContext::RegularFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CompleteRegularFunctionContext* MySQLStatementParser::RegularFunctionContext::completeRegularFunction() {
  return getRuleContext<MySQLStatementParser::CompleteRegularFunctionContext>(0);
}

MySQLStatementParser::ShorthandRegularFunctionContext* MySQLStatementParser::RegularFunctionContext::shorthandRegularFunction() {
  return getRuleContext<MySQLStatementParser::ShorthandRegularFunctionContext>(0);
}


size_t MySQLStatementParser::RegularFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRegularFunction;
}

void MySQLStatementParser::RegularFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRegularFunction(this);
}

void MySQLStatementParser::RegularFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRegularFunction(this);
}


antlrcpp::Any MySQLStatementParser::RegularFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRegularFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RegularFunctionContext* MySQLStatementParser::regularFunction() {
  RegularFunctionContext *_localctx = _tracker.createInstance<RegularFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1016, MySQLStatementParser::RuleRegularFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7247);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 937, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7245);
      completeRegularFunction();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7246);
      shorthandRegularFunction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShorthandRegularFunctionContext ------------------------------------------------------------------

MySQLStatementParser::ShorthandRegularFunctionContext::ShorthandRegularFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::CURRENT_DATE() {
  return getToken(MySQLStatementParser::CURRENT_DATE, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::CURRENT_TIME() {
  return getToken(MySQLStatementParser::CURRENT_TIME, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::CURRENT_TIMESTAMP() {
  return getToken(MySQLStatementParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::LAST_DAY() {
  return getToken(MySQLStatementParser::LAST_DAY, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::LOCALTIME() {
  return getToken(MySQLStatementParser::LOCALTIME, 0);
}

tree::TerminalNode* MySQLStatementParser::ShorthandRegularFunctionContext::LOCALTIMESTAMP() {
  return getToken(MySQLStatementParser::LOCALTIMESTAMP, 0);
}


size_t MySQLStatementParser::ShorthandRegularFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleShorthandRegularFunction;
}

void MySQLStatementParser::ShorthandRegularFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShorthandRegularFunction(this);
}

void MySQLStatementParser::ShorthandRegularFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShorthandRegularFunction(this);
}


antlrcpp::Any MySQLStatementParser::ShorthandRegularFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitShorthandRegularFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ShorthandRegularFunctionContext* MySQLStatementParser::shorthandRegularFunction() {
  ShorthandRegularFunctionContext *_localctx = _tracker.createInstance<ShorthandRegularFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1018, MySQLStatementParser::RuleShorthandRegularFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7262);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CURRENT_DATE: {
        enterOuterAlt(_localctx, 1);
        setState(7249);
        match(MySQLStatementParser::CURRENT_DATE);
        break;
      }

      case MySQLStatementParser::CURRENT_TIME: {
        enterOuterAlt(_localctx, 2);
        setState(7250);
        match(MySQLStatementParser::CURRENT_TIME);
        setState(7256);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 939, _ctx)) {
        case 1: {
          setState(7251);
          match(MySQLStatementParser::LP_);
          setState(7253);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::NUMBER_) {
            setState(7252);
            match(MySQLStatementParser::NUMBER_);
          }
          setState(7255);
          match(MySQLStatementParser::RP_);
          break;
        }

        }
        break;
      }

      case MySQLStatementParser::CURRENT_TIMESTAMP: {
        enterOuterAlt(_localctx, 3);
        setState(7258);
        match(MySQLStatementParser::CURRENT_TIMESTAMP);
        break;
      }

      case MySQLStatementParser::LAST_DAY: {
        enterOuterAlt(_localctx, 4);
        setState(7259);
        match(MySQLStatementParser::LAST_DAY);
        break;
      }

      case MySQLStatementParser::LOCALTIME: {
        enterOuterAlt(_localctx, 5);
        setState(7260);
        match(MySQLStatementParser::LOCALTIME);
        break;
      }

      case MySQLStatementParser::LOCALTIMESTAMP: {
        enterOuterAlt(_localctx, 6);
        setState(7261);
        match(MySQLStatementParser::LOCALTIMESTAMP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompleteRegularFunctionContext ------------------------------------------------------------------

MySQLStatementParser::CompleteRegularFunctionContext::CompleteRegularFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::RegularFunctionNameContext* MySQLStatementParser::CompleteRegularFunctionContext::regularFunctionName() {
  return getRuleContext<MySQLStatementParser::RegularFunctionNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CompleteRegularFunctionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::CompleteRegularFunctionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::CompleteRegularFunctionContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CompleteRegularFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CompleteRegularFunctionContext::ASTERISK_() {
  return getToken(MySQLStatementParser::ASTERISK_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::CompleteRegularFunctionContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::CompleteRegularFunctionContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::CompleteRegularFunctionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCompleteRegularFunction;
}

void MySQLStatementParser::CompleteRegularFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompleteRegularFunction(this);
}

void MySQLStatementParser::CompleteRegularFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompleteRegularFunction(this);
}


antlrcpp::Any MySQLStatementParser::CompleteRegularFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCompleteRegularFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CompleteRegularFunctionContext* MySQLStatementParser::completeRegularFunction() {
  CompleteRegularFunctionContext *_localctx = _tracker.createInstance<CompleteRegularFunctionContext>(_ctx, getState());
  enterRule(_localctx, 1020, MySQLStatementParser::RuleCompleteRegularFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7264);
    regularFunctionName();

    setState(7265);
    match(MySQLStatementParser::LP_);
    setState(7275);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINARY:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CASE:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CONVERT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CUME_DIST:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURRENT_DATE:
      case MySQLStatementParser::CURRENT_TIME:
      case MySQLStatementParser::CURRENT_TIMESTAMP:
      case MySQLStatementParser::CURRENT_USER:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATABASE:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DENSE_RANK:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXISTS:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FALSE:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIRST_VALUE:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IF:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INTERVAL:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LAG:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LAST_VALUE:
      case MySQLStatementParser::LEAD:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LEFT:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCALTIME:
      case MySQLStatementParser::LOCALTIMESTAMP:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MATCH:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MOD:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOT:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NTH_VALUE:
      case MySQLStatementParser::NTILE:
      case MySQLStatementParser::NULL:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERCENT_RANK:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::RANK:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLACE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::RIGHT:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::ROW_NUMBER:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUE:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VALUES:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::NOT_:
      case MySQLStatementParser::TILDE_:
      case MySQLStatementParser::PLUS_:
      case MySQLStatementParser::MINUS_:
      case MySQLStatementParser::DOT_:
      case MySQLStatementParser::LP_:
      case MySQLStatementParser::LBE_:
      case MySQLStatementParser::QUESTION_:
      case MySQLStatementParser::AT_:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
      case MySQLStatementParser::NCHAR_TEXT:
      case MySQLStatementParser::UNDERSCORE_CHARSET:
      case MySQLStatementParser::NUMBER_:
      case MySQLStatementParser::HEX_DIGIT_:
      case MySQLStatementParser::BIT_NUM_: {
        setState(7266);
        expr(0);
        setState(7271);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLStatementParser::COMMA_) {
          setState(7267);
          match(MySQLStatementParser::COMMA_);
          setState(7268);
          expr(0);
          setState(7273);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLStatementParser::ASTERISK_: {
        setState(7274);
        match(MySQLStatementParser::ASTERISK_);
        break;
      }

      case MySQLStatementParser::RP_: {
        break;
      }

    default:
      break;
    }
    setState(7277);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegularFunctionNameContext ------------------------------------------------------------------

MySQLStatementParser::RegularFunctionNameContext::RegularFunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::LOCALTIME() {
  return getToken(MySQLStatementParser::LOCALTIME, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::LOCALTIMESTAMP() {
  return getToken(MySQLStatementParser::LOCALTIMESTAMP, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::REPLACE() {
  return getToken(MySQLStatementParser::REPLACE, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::INTERVAL() {
  return getToken(MySQLStatementParser::INTERVAL, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::MOD() {
  return getToken(MySQLStatementParser::MOD, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::DATABASE() {
  return getToken(MySQLStatementParser::DATABASE, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::LEFT() {
  return getToken(MySQLStatementParser::LEFT, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::RIGHT() {
  return getToken(MySQLStatementParser::RIGHT, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::DATE() {
  return getToken(MySQLStatementParser::DATE, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::DAY() {
  return getToken(MySQLStatementParser::DAY, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::GEOMCOLLECTION() {
  return getToken(MySQLStatementParser::GEOMCOLLECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::GEOMETRYCOLLECTION() {
  return getToken(MySQLStatementParser::GEOMETRYCOLLECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::LINESTRING() {
  return getToken(MySQLStatementParser::LINESTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::MULTILINESTRING() {
  return getToken(MySQLStatementParser::MULTILINESTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::MULTIPOINT() {
  return getToken(MySQLStatementParser::MULTIPOINT, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::MULTIPOLYGON() {
  return getToken(MySQLStatementParser::MULTIPOLYGON, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::POINT() {
  return getToken(MySQLStatementParser::POINT, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::POLYGON() {
  return getToken(MySQLStatementParser::POLYGON, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::TIME() {
  return getToken(MySQLStatementParser::TIME, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::TIMESTAMP() {
  return getToken(MySQLStatementParser::TIMESTAMP, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::TIMESTAMPADD() {
  return getToken(MySQLStatementParser::TIMESTAMPADD, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::TIMESTAMPDIFF() {
  return getToken(MySQLStatementParser::TIMESTAMPDIFF, 0);
}

tree::TerminalNode* MySQLStatementParser::RegularFunctionNameContext::CURRENT_TIMESTAMP() {
  return getToken(MySQLStatementParser::CURRENT_TIMESTAMP, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::RegularFunctionNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::RegularFunctionNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleRegularFunctionName;
}

void MySQLStatementParser::RegularFunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRegularFunctionName(this);
}

void MySQLStatementParser::RegularFunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRegularFunctionName(this);
}


antlrcpp::Any MySQLStatementParser::RegularFunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitRegularFunctionName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::RegularFunctionNameContext* MySQLStatementParser::regularFunctionName() {
  RegularFunctionNameContext *_localctx = _tracker.createInstance<RegularFunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 1022, MySQLStatementParser::RuleRegularFunctionName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7305);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 943, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7279);
      match(MySQLStatementParser::IF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7280);
      match(MySQLStatementParser::LOCALTIME);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7281);
      match(MySQLStatementParser::LOCALTIMESTAMP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7282);
      match(MySQLStatementParser::REPLACE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7283);
      match(MySQLStatementParser::INTERVAL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7284);
      match(MySQLStatementParser::MOD);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7285);
      match(MySQLStatementParser::DATABASE);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7286);
      match(MySQLStatementParser::LEFT);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7287);
      match(MySQLStatementParser::RIGHT);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(7288);
      match(MySQLStatementParser::DATE);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(7289);
      match(MySQLStatementParser::DAY);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(7290);
      match(MySQLStatementParser::GEOMCOLLECTION);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(7291);
      match(MySQLStatementParser::GEOMETRYCOLLECTION);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(7292);
      match(MySQLStatementParser::LINESTRING);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(7293);
      match(MySQLStatementParser::MULTILINESTRING);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(7294);
      match(MySQLStatementParser::MULTIPOINT);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(7295);
      match(MySQLStatementParser::MULTIPOLYGON);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(7296);
      match(MySQLStatementParser::POINT);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(7297);
      match(MySQLStatementParser::POLYGON);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(7298);
      match(MySQLStatementParser::TIME);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(7299);
      match(MySQLStatementParser::TIMESTAMP);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(7300);
      match(MySQLStatementParser::TIMESTAMPADD);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(7301);
      match(MySQLStatementParser::TIMESTAMPDIFF);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(7302);
      match(MySQLStatementParser::DATE);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(7303);
      match(MySQLStatementParser::CURRENT_TIMESTAMP);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(7304);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchExpressionContext ------------------------------------------------------------------

MySQLStatementParser::MatchExpressionContext::MatchExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::MatchExpressionContext::MATCH() {
  return getToken(MySQLStatementParser::MATCH, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchExpressionContext::AGAINST() {
  return getToken(MySQLStatementParser::AGAINST, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::MatchExpressionContext::LP_() {
  return getTokens(MySQLStatementParser::LP_);
}

tree::TerminalNode* MySQLStatementParser::MatchExpressionContext::LP_(size_t i) {
  return getToken(MySQLStatementParser::LP_, i);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::MatchExpressionContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::MatchExpressionContext::RP_() {
  return getTokens(MySQLStatementParser::RP_);
}

tree::TerminalNode* MySQLStatementParser::MatchExpressionContext::RP_(size_t i) {
  return getToken(MySQLStatementParser::RP_, i);
}

MySQLStatementParser::ColumnRefListContext* MySQLStatementParser::MatchExpressionContext::columnRefList() {
  return getRuleContext<MySQLStatementParser::ColumnRefListContext>(0);
}

MySQLStatementParser::MatchSearchModifierContext* MySQLStatementParser::MatchExpressionContext::matchSearchModifier() {
  return getRuleContext<MySQLStatementParser::MatchSearchModifierContext>(0);
}


size_t MySQLStatementParser::MatchExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleMatchExpression;
}

void MySQLStatementParser::MatchExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchExpression(this);
}

void MySQLStatementParser::MatchExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchExpression(this);
}


antlrcpp::Any MySQLStatementParser::MatchExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitMatchExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::MatchExpressionContext* MySQLStatementParser::matchExpression() {
  MatchExpressionContext *_localctx = _tracker.createInstance<MatchExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1024, MySQLStatementParser::RuleMatchExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7307);
    match(MySQLStatementParser::MATCH);
    setState(7313);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::MAX:
      case MySQLStatementParser::MIN:
      case MySQLStatementParser::SUM:
      case MySQLStatementParser::COUNT:
      case MySQLStatementParser::GROUP_CONCAT:
      case MySQLStatementParser::CAST:
      case MySQLStatementParser::POSITION:
      case MySQLStatementParser::SUBSTRING:
      case MySQLStatementParser::SUBSTR:
      case MySQLStatementParser::EXTRACT:
      case MySQLStatementParser::TRIM:
      case MySQLStatementParser::LAST_DAY:
      case MySQLStatementParser::TRADITIONAL:
      case MySQLStatementParser::TREE:
      case MySQLStatementParser::MYSQL_ADMIN:
      case MySQLStatementParser::INSTANT:
      case MySQLStatementParser::INPLACE:
      case MySQLStatementParser::COPY:
      case MySQLStatementParser::UL_BINARY:
      case MySQLStatementParser::AUTOCOMMIT:
      case MySQLStatementParser::INNODB:
      case MySQLStatementParser::REDO_LOG:
      case MySQLStatementParser::ACCOUNT:
      case MySQLStatementParser::ACTION:
      case MySQLStatementParser::ACTIVE:
      case MySQLStatementParser::ADMIN:
      case MySQLStatementParser::AFTER:
      case MySQLStatementParser::AGAINST:
      case MySQLStatementParser::AGGREGATE:
      case MySQLStatementParser::ALGORITHM:
      case MySQLStatementParser::ALWAYS:
      case MySQLStatementParser::ANY:
      case MySQLStatementParser::ASCII:
      case MySQLStatementParser::AT:
      case MySQLStatementParser::ATTRIBUTE:
      case MySQLStatementParser::AUTOEXTEND_SIZE:
      case MySQLStatementParser::AUTO_INCREMENT:
      case MySQLStatementParser::AVG:
      case MySQLStatementParser::AVG_ROW_LENGTH:
      case MySQLStatementParser::BACKUP:
      case MySQLStatementParser::BEGIN:
      case MySQLStatementParser::BINLOG:
      case MySQLStatementParser::BIT:
      case MySQLStatementParser::BLOCK:
      case MySQLStatementParser::BOOL:
      case MySQLStatementParser::BOOLEAN:
      case MySQLStatementParser::BTREE:
      case MySQLStatementParser::BUCKETS:
      case MySQLStatementParser::BYTE:
      case MySQLStatementParser::CACHE:
      case MySQLStatementParser::CASCADED:
      case MySQLStatementParser::CATALOG_NAME:
      case MySQLStatementParser::CHAIN:
      case MySQLStatementParser::CHANGED:
      case MySQLStatementParser::CHANNEL:
      case MySQLStatementParser::CHARSET:
      case MySQLStatementParser::CHECKSUM:
      case MySQLStatementParser::CIPHER:
      case MySQLStatementParser::CLASS_ORIGIN:
      case MySQLStatementParser::CLIENT:
      case MySQLStatementParser::CLONE:
      case MySQLStatementParser::CLOSE:
      case MySQLStatementParser::COALESCE:
      case MySQLStatementParser::CODE:
      case MySQLStatementParser::COLLATION:
      case MySQLStatementParser::COLUMNS:
      case MySQLStatementParser::COLUMN_FORMAT:
      case MySQLStatementParser::COLUMN_NAME:
      case MySQLStatementParser::COMMENT:
      case MySQLStatementParser::COMMIT:
      case MySQLStatementParser::COMMITTED:
      case MySQLStatementParser::COMPACT:
      case MySQLStatementParser::COMPLETION:
      case MySQLStatementParser::COMPONENT:
      case MySQLStatementParser::COMPRESSED:
      case MySQLStatementParser::COMPRESSION:
      case MySQLStatementParser::CONCURRENT:
      case MySQLStatementParser::CONNECTION:
      case MySQLStatementParser::CONSISTENT:
      case MySQLStatementParser::CONSTRAINT_CATALOG:
      case MySQLStatementParser::CONSTRAINT_NAME:
      case MySQLStatementParser::CONSTRAINT_SCHEMA:
      case MySQLStatementParser::CONTAINS:
      case MySQLStatementParser::CONTEXT:
      case MySQLStatementParser::CPU:
      case MySQLStatementParser::CURRENT:
      case MySQLStatementParser::CURSOR_NAME:
      case MySQLStatementParser::DATA:
      case MySQLStatementParser::DATAFILE:
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::DATETIME:
      case MySQLStatementParser::DAY:
      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DEFAULT_AUTH:
      case MySQLStatementParser::DEFINER:
      case MySQLStatementParser::DEFINITION:
      case MySQLStatementParser::DELAY_KEY_WRITE:
      case MySQLStatementParser::DESCRIPTION:
      case MySQLStatementParser::DIAGNOSTICS:
      case MySQLStatementParser::DIRECTORY:
      case MySQLStatementParser::DISABLE:
      case MySQLStatementParser::DISCARD:
      case MySQLStatementParser::DISK:
      case MySQLStatementParser::DO:
      case MySQLStatementParser::DUMPFILE:
      case MySQLStatementParser::DUPLICATE:
      case MySQLStatementParser::DYNAMIC:
      case MySQLStatementParser::ENABLE:
      case MySQLStatementParser::ENCRYPTION:
      case MySQLStatementParser::END:
      case MySQLStatementParser::ENDS:
      case MySQLStatementParser::ENFORCED:
      case MySQLStatementParser::ENGINE:
      case MySQLStatementParser::ENGINES:
      case MySQLStatementParser::ENGINE_ATTRIBUTE:
      case MySQLStatementParser::ENUM:
      case MySQLStatementParser::ERROR:
      case MySQLStatementParser::ERRORS:
      case MySQLStatementParser::ESCAPE:
      case MySQLStatementParser::EVENT:
      case MySQLStatementParser::EVENTS:
      case MySQLStatementParser::EVERY:
      case MySQLStatementParser::EXCHANGE:
      case MySQLStatementParser::EXCLUDE:
      case MySQLStatementParser::EXECUTE:
      case MySQLStatementParser::EXPANSION:
      case MySQLStatementParser::EXPIRE:
      case MySQLStatementParser::EXPORT:
      case MySQLStatementParser::EXTENDED:
      case MySQLStatementParser::EXTENT_SIZE:
      case MySQLStatementParser::FAILED_LOGIN_ATTEMPTS:
      case MySQLStatementParser::FAST:
      case MySQLStatementParser::FAULTS:
      case MySQLStatementParser::FIELDS:
      case MySQLStatementParser::FILE:
      case MySQLStatementParser::FILE_BLOCK_SIZE:
      case MySQLStatementParser::FILTER:
      case MySQLStatementParser::FIRST:
      case MySQLStatementParser::FIXED:
      case MySQLStatementParser::FLUSH:
      case MySQLStatementParser::FOLLOWING:
      case MySQLStatementParser::FOLLOWS:
      case MySQLStatementParser::FORMAT:
      case MySQLStatementParser::FULL:
      case MySQLStatementParser::GENERAL:
      case MySQLStatementParser::GEOMCOLLECTION:
      case MySQLStatementParser::GEOMETRY:
      case MySQLStatementParser::GEOMETRYCOLLECTION:
      case MySQLStatementParser::GET_FORMAT:
      case MySQLStatementParser::GET_MASTER_PUBLIC_KEY:
      case MySQLStatementParser::GLOBAL:
      case MySQLStatementParser::GRANTS:
      case MySQLStatementParser::GROUP_REPLICATION:
      case MySQLStatementParser::HANDLER:
      case MySQLStatementParser::HASH:
      case MySQLStatementParser::HELP:
      case MySQLStatementParser::HISTOGRAM:
      case MySQLStatementParser::HISTORY:
      case MySQLStatementParser::HOST:
      case MySQLStatementParser::HOSTS:
      case MySQLStatementParser::HOUR:
      case MySQLStatementParser::IDENTIFIED:
      case MySQLStatementParser::IGNORE_SERVER_IDS:
      case MySQLStatementParser::IMPORT:
      case MySQLStatementParser::INACTIVE:
      case MySQLStatementParser::INDEXES:
      case MySQLStatementParser::INITIAL_SIZE:
      case MySQLStatementParser::INSERT_METHOD:
      case MySQLStatementParser::INSTALL:
      case MySQLStatementParser::INSTANCE:
      case MySQLStatementParser::INVISIBLE:
      case MySQLStatementParser::INVOKER:
      case MySQLStatementParser::IO:
      case MySQLStatementParser::IO_THREAD:
      case MySQLStatementParser::IPC:
      case MySQLStatementParser::ISOLATION:
      case MySQLStatementParser::ISSUER:
      case MySQLStatementParser::JSON:
      case MySQLStatementParser::JSON_VALUE:
      case MySQLStatementParser::KEY_BLOCK_SIZE:
      case MySQLStatementParser::LANGUAGE:
      case MySQLStatementParser::LAST:
      case MySQLStatementParser::LEAVES:
      case MySQLStatementParser::LESS:
      case MySQLStatementParser::LEVEL:
      case MySQLStatementParser::LINESTRING:
      case MySQLStatementParser::LIST:
      case MySQLStatementParser::LOCAL:
      case MySQLStatementParser::LOCKED:
      case MySQLStatementParser::LOCKS:
      case MySQLStatementParser::LOGFILE:
      case MySQLStatementParser::LOGS:
      case MySQLStatementParser::MANAGED:
      case MySQLStatementParser::MASTER:
      case MySQLStatementParser::MASTER_AUTO_POSITION:
      case MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS:
      case MySQLStatementParser::MASTER_CONNECT_RETRY:
      case MySQLStatementParser::MASTER_DELAY:
      case MySQLStatementParser::MASTER_HEARTBEAT_PERIOD:
      case MySQLStatementParser::MASTER_HOST:
      case MySQLStatementParser::MASTER_LOG_FILE:
      case MySQLStatementParser::MASTER_LOG_POS:
      case MySQLStatementParser::MASTER_PASSWORD:
      case MySQLStatementParser::MASTER_PORT:
      case MySQLStatementParser::MASTER_PUBLIC_KEY_PATH:
      case MySQLStatementParser::MASTER_RETRY_COUNT:
      case MySQLStatementParser::MASTER_SERVER_ID:
      case MySQLStatementParser::MASTER_SSL:
      case MySQLStatementParser::MASTER_SSL_CA:
      case MySQLStatementParser::MASTER_SSL_CAPATH:
      case MySQLStatementParser::MASTER_SSL_CERT:
      case MySQLStatementParser::MASTER_SSL_CIPHER:
      case MySQLStatementParser::MASTER_SSL_CRL:
      case MySQLStatementParser::MASTER_SSL_CRLPATH:
      case MySQLStatementParser::MASTER_SSL_KEY:
      case MySQLStatementParser::MASTER_TLS_CIPHERSUITES:
      case MySQLStatementParser::MASTER_TLS_VERSION:
      case MySQLStatementParser::MASTER_USER:
      case MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL:
      case MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR:
      case MySQLStatementParser::MAX_QUERIES_PER_HOUR:
      case MySQLStatementParser::MAX_ROWS:
      case MySQLStatementParser::MAX_SIZE:
      case MySQLStatementParser::MAX_UPDATES_PER_HOUR:
      case MySQLStatementParser::MAX_USER_CONNECTIONS:
      case MySQLStatementParser::MEDIUM:
      case MySQLStatementParser::MEMBER:
      case MySQLStatementParser::MEMORY:
      case MySQLStatementParser::MERGE:
      case MySQLStatementParser::MESSAGE_TEXT:
      case MySQLStatementParser::MICROSECOND:
      case MySQLStatementParser::MIGRATE:
      case MySQLStatementParser::MINUTE:
      case MySQLStatementParser::MIN_ROWS:
      case MySQLStatementParser::MODE:
      case MySQLStatementParser::MODIFY:
      case MySQLStatementParser::MONTH:
      case MySQLStatementParser::MULTILINESTRING:
      case MySQLStatementParser::MULTIPOINT:
      case MySQLStatementParser::MULTIPOLYGON:
      case MySQLStatementParser::MUTEX:
      case MySQLStatementParser::MYSQL_ERRNO:
      case MySQLStatementParser::NAME:
      case MySQLStatementParser::NAMES:
      case MySQLStatementParser::NATIONAL:
      case MySQLStatementParser::NCHAR:
      case MySQLStatementParser::NDB:
      case MySQLStatementParser::NDBCLUSTER:
      case MySQLStatementParser::NESTED:
      case MySQLStatementParser::NETWORK_NAMESPACE:
      case MySQLStatementParser::NEVER:
      case MySQLStatementParser::NEW:
      case MySQLStatementParser::NEXT:
      case MySQLStatementParser::NO:
      case MySQLStatementParser::NODEGROUP:
      case MySQLStatementParser::NONE:
      case MySQLStatementParser::NOWAIT:
      case MySQLStatementParser::NO_WAIT:
      case MySQLStatementParser::NULLS:
      case MySQLStatementParser::NUMBER:
      case MySQLStatementParser::NVARCHAR:
      case MySQLStatementParser::OFF:
      case MySQLStatementParser::OFFSET:
      case MySQLStatementParser::OJ:
      case MySQLStatementParser::OLD:
      case MySQLStatementParser::ONE:
      case MySQLStatementParser::ONLY:
      case MySQLStatementParser::OPEN:
      case MySQLStatementParser::OPTIONAL:
      case MySQLStatementParser::OPTIONS:
      case MySQLStatementParser::ORDINALITY:
      case MySQLStatementParser::OTHERS:
      case MySQLStatementParser::OWNER:
      case MySQLStatementParser::PACK_KEYS:
      case MySQLStatementParser::PAGE:
      case MySQLStatementParser::PARSER:
      case MySQLStatementParser::PARTIAL:
      case MySQLStatementParser::PARTITIONING:
      case MySQLStatementParser::PASSWORD:
      case MySQLStatementParser::PASSWORD_LOCK_TIME:
      case MySQLStatementParser::PATH:
      case MySQLStatementParser::PERSIST:
      case MySQLStatementParser::PERSIST_ONLY:
      case MySQLStatementParser::PHASE:
      case MySQLStatementParser::PLUGIN:
      case MySQLStatementParser::PLUGINS:
      case MySQLStatementParser::PLUGIN_DIR:
      case MySQLStatementParser::POINT:
      case MySQLStatementParser::POLYGON:
      case MySQLStatementParser::PORT:
      case MySQLStatementParser::PRECEDES:
      case MySQLStatementParser::PRECEDING:
      case MySQLStatementParser::PREPARE:
      case MySQLStatementParser::PRESERVE:
      case MySQLStatementParser::PREV:
      case MySQLStatementParser::PRIVILEGES:
      case MySQLStatementParser::PRIVILEGE_CHECKS_USER:
      case MySQLStatementParser::PROCESS:
      case MySQLStatementParser::PROCESSLIST:
      case MySQLStatementParser::PROFILE:
      case MySQLStatementParser::PROFILES:
      case MySQLStatementParser::PROXY:
      case MySQLStatementParser::QUARTER:
      case MySQLStatementParser::QUERY:
      case MySQLStatementParser::QUICK:
      case MySQLStatementParser::RANDOM:
      case MySQLStatementParser::READ_ONLY:
      case MySQLStatementParser::REBUILD:
      case MySQLStatementParser::RECOVER:
      case MySQLStatementParser::REDO_BUFFER_SIZE:
      case MySQLStatementParser::REDUNDANT:
      case MySQLStatementParser::REFERENCE:
      case MySQLStatementParser::RELAY:
      case MySQLStatementParser::RELAYLOG:
      case MySQLStatementParser::RELAY_LOG_FILE:
      case MySQLStatementParser::RELAY_LOG_POS:
      case MySQLStatementParser::RELAY_THREAD:
      case MySQLStatementParser::RELOAD:
      case MySQLStatementParser::REMOVE:
      case MySQLStatementParser::REORGANIZE:
      case MySQLStatementParser::REPAIR:
      case MySQLStatementParser::REPEATABLE:
      case MySQLStatementParser::REPLICATE_DO_DB:
      case MySQLStatementParser::REPLICATE_DO_TABLE:
      case MySQLStatementParser::REPLICATE_IGNORE_DB:
      case MySQLStatementParser::REPLICATE_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATE_REWRITE_DB:
      case MySQLStatementParser::REPLICATE_WILD_DO_TABLE:
      case MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySQLStatementParser::REPLICATION:
      case MySQLStatementParser::REQUIRE_ROW_FORMAT:
      case MySQLStatementParser::RESET:
      case MySQLStatementParser::RESOURCE:
      case MySQLStatementParser::RESPECT:
      case MySQLStatementParser::RESTART:
      case MySQLStatementParser::RESTORE:
      case MySQLStatementParser::RESUME:
      case MySQLStatementParser::RETAIN:
      case MySQLStatementParser::RETURNED_SQLSTATE:
      case MySQLStatementParser::RETURNING:
      case MySQLStatementParser::RETURNS:
      case MySQLStatementParser::REUSE:
      case MySQLStatementParser::REVERSE:
      case MySQLStatementParser::ROLE:
      case MySQLStatementParser::ROLLBACK:
      case MySQLStatementParser::ROLLUP:
      case MySQLStatementParser::ROTATE:
      case MySQLStatementParser::ROUTINE:
      case MySQLStatementParser::ROW_COUNT:
      case MySQLStatementParser::ROW_FORMAT:
      case MySQLStatementParser::RTREE:
      case MySQLStatementParser::SAVEPOINT:
      case MySQLStatementParser::SCHEDULE:
      case MySQLStatementParser::SCHEMA_NAME:
      case MySQLStatementParser::SECOND:
      case MySQLStatementParser::SECONDARY:
      case MySQLStatementParser::SECONDARY_ENGINE:
      case MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySQLStatementParser::SECONDARY_LOAD:
      case MySQLStatementParser::SECONDARY_UNLOAD:
      case MySQLStatementParser::SECURITY:
      case MySQLStatementParser::SERIAL:
      case MySQLStatementParser::SERIALIZABLE:
      case MySQLStatementParser::SERVER:
      case MySQLStatementParser::SESSION:
      case MySQLStatementParser::SHARE:
      case MySQLStatementParser::SHUTDOWN:
      case MySQLStatementParser::SIGNED:
      case MySQLStatementParser::SIMPLE:
      case MySQLStatementParser::SLAVE:
      case MySQLStatementParser::SLOW:
      case MySQLStatementParser::SNAPSHOT:
      case MySQLStatementParser::SOCKET:
      case MySQLStatementParser::SOME:
      case MySQLStatementParser::SONAME:
      case MySQLStatementParser::SOUNDS:
      case MySQLStatementParser::SOURCE:
      case MySQLStatementParser::SQL_CACHE:
      case MySQLStatementParser::SQL_AFTER_GTIDS:
      case MySQLStatementParser::SQL_AFTER_MTS_GAPS:
      case MySQLStatementParser::SQL_BEFORE_GTIDS:
      case MySQLStatementParser::SQL_BUFFER_RESULT:
      case MySQLStatementParser::SQL_NO_CACHE:
      case MySQLStatementParser::SQL_THREAD:
      case MySQLStatementParser::SQL_TSI_DAY:
      case MySQLStatementParser::SQL_TSI_HOUR:
      case MySQLStatementParser::SQL_TSI_MINUTE:
      case MySQLStatementParser::SQL_TSI_MONTH:
      case MySQLStatementParser::SQL_TSI_QUARTER:
      case MySQLStatementParser::SQL_TSI_SECOND:
      case MySQLStatementParser::SQL_TSI_WEEK:
      case MySQLStatementParser::SQL_TSI_YEAR:
      case MySQLStatementParser::SRID:
      case MySQLStatementParser::STACKED:
      case MySQLStatementParser::START:
      case MySQLStatementParser::STARTS:
      case MySQLStatementParser::STATS_AUTO_RECALC:
      case MySQLStatementParser::STATS_PERSISTENT:
      case MySQLStatementParser::STATS_SAMPLE_PAGES:
      case MySQLStatementParser::STATUS:
      case MySQLStatementParser::STOP:
      case MySQLStatementParser::STORAGE:
      case MySQLStatementParser::STREAM:
      case MySQLStatementParser::STRING:
      case MySQLStatementParser::SUBCLASS_ORIGIN:
      case MySQLStatementParser::SUBJECT:
      case MySQLStatementParser::SUBPARTITION:
      case MySQLStatementParser::SUBPARTITIONS:
      case MySQLStatementParser::SUPER:
      case MySQLStatementParser::SUSPEND:
      case MySQLStatementParser::SWAPS:
      case MySQLStatementParser::SWITCHES:
      case MySQLStatementParser::TABLES:
      case MySQLStatementParser::TABLESPACE:
      case MySQLStatementParser::TABLE_CHECKSUM:
      case MySQLStatementParser::TABLE_NAME:
      case MySQLStatementParser::TEMPORARY:
      case MySQLStatementParser::TEMPTABLE:
      case MySQLStatementParser::TEXT:
      case MySQLStatementParser::THAN:
      case MySQLStatementParser::THREAD_PRIORITY:
      case MySQLStatementParser::TIES:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TIMESTAMPADD:
      case MySQLStatementParser::TIMESTAMPDIFF:
      case MySQLStatementParser::TLS:
      case MySQLStatementParser::TRANSACTION:
      case MySQLStatementParser::TRIGGERS:
      case MySQLStatementParser::TRUNCATE:
      case MySQLStatementParser::TYPE:
      case MySQLStatementParser::TYPES:
      case MySQLStatementParser::UNBOUNDED:
      case MySQLStatementParser::UNCOMMITTED:
      case MySQLStatementParser::UNDEFINED:
      case MySQLStatementParser::UNDOFILE:
      case MySQLStatementParser::UNDO_BUFFER_SIZE:
      case MySQLStatementParser::UNICODE:
      case MySQLStatementParser::UNINSTALL:
      case MySQLStatementParser::UNKNOWN:
      case MySQLStatementParser::UNTIL:
      case MySQLStatementParser::UPGRADE:
      case MySQLStatementParser::USER:
      case MySQLStatementParser::USER_RESOURCES:
      case MySQLStatementParser::USE_FRM:
      case MySQLStatementParser::VALIDATION:
      case MySQLStatementParser::VALUE:
      case MySQLStatementParser::VARIABLES:
      case MySQLStatementParser::VCPU:
      case MySQLStatementParser::VIEW:
      case MySQLStatementParser::VISIBLE:
      case MySQLStatementParser::WAIT:
      case MySQLStatementParser::WARNINGS:
      case MySQLStatementParser::WEEK:
      case MySQLStatementParser::WEIGHT_STRING:
      case MySQLStatementParser::WITHOUT:
      case MySQLStatementParser::WORK:
      case MySQLStatementParser::WRAPPER:
      case MySQLStatementParser::X509:
      case MySQLStatementParser::XA:
      case MySQLStatementParser::XID:
      case MySQLStatementParser::XML:
      case MySQLStatementParser::YEAR:
      case MySQLStatementParser::IDENTIFIER_:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        setState(7308);
        columnRefList();
        break;
      }

      case MySQLStatementParser::LP_: {
        setState(7309);
        match(MySQLStatementParser::LP_);
        setState(7310);
        columnRefList();
        setState(7311);
        match(MySQLStatementParser::RP_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(7315);
    match(MySQLStatementParser::AGAINST);
    setState(7316);
    match(MySQLStatementParser::LP_);
    setState(7317);
    expr(0);
    setState(7319);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::IN || _la == MySQLStatementParser::WITH) {
      setState(7318);
      matchSearchModifier();
    }
    setState(7321);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchSearchModifierContext ------------------------------------------------------------------

MySQLStatementParser::MatchSearchModifierContext::MatchSearchModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::IN() {
  return getToken(MySQLStatementParser::IN, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::NATURAL() {
  return getToken(MySQLStatementParser::NATURAL, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::LANGUAGE() {
  return getToken(MySQLStatementParser::LANGUAGE, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::MODE() {
  return getToken(MySQLStatementParser::MODE, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::WITH() {
  return getToken(MySQLStatementParser::WITH, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::QUERY() {
  return getToken(MySQLStatementParser::QUERY, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::EXPANSION() {
  return getToken(MySQLStatementParser::EXPANSION, 0);
}

tree::TerminalNode* MySQLStatementParser::MatchSearchModifierContext::BOOLEAN() {
  return getToken(MySQLStatementParser::BOOLEAN, 0);
}


size_t MySQLStatementParser::MatchSearchModifierContext::getRuleIndex() const {
  return MySQLStatementParser::RuleMatchSearchModifier;
}

void MySQLStatementParser::MatchSearchModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchSearchModifier(this);
}

void MySQLStatementParser::MatchSearchModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchSearchModifier(this);
}


antlrcpp::Any MySQLStatementParser::MatchSearchModifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitMatchSearchModifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::MatchSearchModifierContext* MySQLStatementParser::matchSearchModifier() {
  MatchSearchModifierContext *_localctx = _tracker.createInstance<MatchSearchModifierContext>(_ctx, getState());
  enterRule(_localctx, 1026, MySQLStatementParser::RuleMatchSearchModifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7340);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 946, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7323);
      match(MySQLStatementParser::IN);
      setState(7324);
      match(MySQLStatementParser::NATURAL);
      setState(7325);
      match(MySQLStatementParser::LANGUAGE);
      setState(7326);
      match(MySQLStatementParser::MODE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7327);
      match(MySQLStatementParser::IN);
      setState(7328);
      match(MySQLStatementParser::NATURAL);
      setState(7329);
      match(MySQLStatementParser::LANGUAGE);
      setState(7330);
      match(MySQLStatementParser::MODE);
      setState(7331);
      match(MySQLStatementParser::WITH);
      setState(7332);
      match(MySQLStatementParser::QUERY);
      setState(7333);
      match(MySQLStatementParser::EXPANSION);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7334);
      match(MySQLStatementParser::IN);
      setState(7335);
      match(MySQLStatementParser::BOOLEAN);
      setState(7336);
      match(MySQLStatementParser::MODE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7337);
      match(MySQLStatementParser::WITH);
      setState(7338);
      match(MySQLStatementParser::QUERY);
      setState(7339);
      match(MySQLStatementParser::EXPANSION);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseExpressionContext ------------------------------------------------------------------

MySQLStatementParser::CaseExpressionContext::CaseExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CaseExpressionContext::CASE() {
  return getToken(MySQLStatementParser::CASE, 0);
}

tree::TerminalNode* MySQLStatementParser::CaseExpressionContext::END() {
  return getToken(MySQLStatementParser::END, 0);
}

MySQLStatementParser::SimpleExprContext* MySQLStatementParser::CaseExpressionContext::simpleExpr() {
  return getRuleContext<MySQLStatementParser::SimpleExprContext>(0);
}

std::vector<MySQLStatementParser::CaseWhenContext *> MySQLStatementParser::CaseExpressionContext::caseWhen() {
  return getRuleContexts<MySQLStatementParser::CaseWhenContext>();
}

MySQLStatementParser::CaseWhenContext* MySQLStatementParser::CaseExpressionContext::caseWhen(size_t i) {
  return getRuleContext<MySQLStatementParser::CaseWhenContext>(i);
}

MySQLStatementParser::CaseElseContext* MySQLStatementParser::CaseExpressionContext::caseElse() {
  return getRuleContext<MySQLStatementParser::CaseElseContext>(0);
}


size_t MySQLStatementParser::CaseExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCaseExpression;
}

void MySQLStatementParser::CaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseExpression(this);
}

void MySQLStatementParser::CaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseExpression(this);
}


antlrcpp::Any MySQLStatementParser::CaseExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCaseExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CaseExpressionContext* MySQLStatementParser::caseExpression() {
  CaseExpressionContext *_localctx = _tracker.createInstance<CaseExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1028, MySQLStatementParser::RuleCaseExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7342);
    match(MySQLStatementParser::CASE);
    setState(7344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINARY)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CASE - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHAR - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CONVERT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CUME_DIST - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_DATE - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_TIME - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_TIMESTAMP - 65))
      | (1ULL << (MySQLStatementParser::CURRENT_USER - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATABASE - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DENSE_RANK - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXISTS - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FALSE - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIRST_VALUE - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IF - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INTERVAL - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LAG - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LAST_VALUE - 259))
      | (1ULL << (MySQLStatementParser::LEAD - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LEFT - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCALTIME - 324))
      | (1ULL << (MySQLStatementParser::LOCALTIMESTAMP - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MATCH - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MOD - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOT - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NTH_VALUE - 388))
      | (1ULL << (MySQLStatementParser::NTILE - 388))
      | (1ULL << (MySQLStatementParser::NULL - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERCENT_RANK - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::RANK - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLACE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::RIGHT - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::ROW_NUMBER - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUE - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VALUES - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710))
      | (1ULL << (MySQLStatementParser::NOT_ - 710))
      | (1ULL << (MySQLStatementParser::TILDE_ - 710))
      | (1ULL << (MySQLStatementParser::PLUS_ - 710))
      | (1ULL << (MySQLStatementParser::MINUS_ - 710))
      | (1ULL << (MySQLStatementParser::DOT_ - 710))
      | (1ULL << (MySQLStatementParser::LP_ - 710))
      | (1ULL << (MySQLStatementParser::LBE_ - 710))
      | (1ULL << (MySQLStatementParser::QUESTION_ - 710))
      | (1ULL << (MySQLStatementParser::AT_ - 710)))) != 0) || ((((_la - 780) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 780)) & ((1ULL << (MySQLStatementParser::IDENTIFIER_ - 780))
      | (1ULL << (MySQLStatementParser::SINGLE_QUOTED_TEXT - 780))
      | (1ULL << (MySQLStatementParser::DOUBLE_QUOTED_TEXT - 780))
      | (1ULL << (MySQLStatementParser::NCHAR_TEXT - 780))
      | (1ULL << (MySQLStatementParser::UNDERSCORE_CHARSET - 780))
      | (1ULL << (MySQLStatementParser::NUMBER_ - 780))
      | (1ULL << (MySQLStatementParser::HEX_DIGIT_ - 780))
      | (1ULL << (MySQLStatementParser::BIT_NUM_ - 780)))) != 0)) {
      setState(7343);
      simpleExpr(0);
    }
    setState(7347); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(7346);
      caseWhen();
      setState(7349); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLStatementParser::WHEN);
    setState(7352);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::ELSE) {
      setState(7351);
      caseElse();
    }
    setState(7354);
    match(MySQLStatementParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DatetimeExprContext ------------------------------------------------------------------

MySQLStatementParser::DatetimeExprContext::DatetimeExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ExprContext* MySQLStatementParser::DatetimeExprContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::DatetimeExprContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDatetimeExpr;
}

void MySQLStatementParser::DatetimeExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatetimeExpr(this);
}

void MySQLStatementParser::DatetimeExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatetimeExpr(this);
}


antlrcpp::Any MySQLStatementParser::DatetimeExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDatetimeExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DatetimeExprContext* MySQLStatementParser::datetimeExpr() {
  DatetimeExprContext *_localctx = _tracker.createInstance<DatetimeExprContext>(_ctx, getState());
  enterRule(_localctx, 1030, MySQLStatementParser::RuleDatetimeExpr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7356);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryLogFileIndexNumberContext ------------------------------------------------------------------

MySQLStatementParser::BinaryLogFileIndexNumberContext::BinaryLogFileIndexNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::BinaryLogFileIndexNumberContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::BinaryLogFileIndexNumberContext::getRuleIndex() const {
  return MySQLStatementParser::RuleBinaryLogFileIndexNumber;
}

void MySQLStatementParser::BinaryLogFileIndexNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryLogFileIndexNumber(this);
}

void MySQLStatementParser::BinaryLogFileIndexNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryLogFileIndexNumber(this);
}


antlrcpp::Any MySQLStatementParser::BinaryLogFileIndexNumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitBinaryLogFileIndexNumber(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::BinaryLogFileIndexNumberContext* MySQLStatementParser::binaryLogFileIndexNumber() {
  BinaryLogFileIndexNumberContext *_localctx = _tracker.createInstance<BinaryLogFileIndexNumberContext>(_ctx, getState());
  enterRule(_localctx, 1032, MySQLStatementParser::RuleBinaryLogFileIndexNumber);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7358);
    match(MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseWhenContext ------------------------------------------------------------------

MySQLStatementParser::CaseWhenContext::CaseWhenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CaseWhenContext::WHEN() {
  return getToken(MySQLStatementParser::WHEN, 0);
}

std::vector<MySQLStatementParser::ExprContext *> MySQLStatementParser::CaseWhenContext::expr() {
  return getRuleContexts<MySQLStatementParser::ExprContext>();
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CaseWhenContext::expr(size_t i) {
  return getRuleContext<MySQLStatementParser::ExprContext>(i);
}

tree::TerminalNode* MySQLStatementParser::CaseWhenContext::THEN() {
  return getToken(MySQLStatementParser::THEN, 0);
}


size_t MySQLStatementParser::CaseWhenContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCaseWhen;
}

void MySQLStatementParser::CaseWhenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseWhen(this);
}

void MySQLStatementParser::CaseWhenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseWhen(this);
}


antlrcpp::Any MySQLStatementParser::CaseWhenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCaseWhen(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CaseWhenContext* MySQLStatementParser::caseWhen() {
  CaseWhenContext *_localctx = _tracker.createInstance<CaseWhenContext>(_ctx, getState());
  enterRule(_localctx, 1034, MySQLStatementParser::RuleCaseWhen);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7360);
    match(MySQLStatementParser::WHEN);
    setState(7361);
    expr(0);
    setState(7362);
    match(MySQLStatementParser::THEN);
    setState(7363);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseElseContext ------------------------------------------------------------------

MySQLStatementParser::CaseElseContext::CaseElseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CaseElseContext::ELSE() {
  return getToken(MySQLStatementParser::ELSE, 0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::CaseElseContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}


size_t MySQLStatementParser::CaseElseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCaseElse;
}

void MySQLStatementParser::CaseElseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseElse(this);
}

void MySQLStatementParser::CaseElseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseElse(this);
}


antlrcpp::Any MySQLStatementParser::CaseElseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCaseElse(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CaseElseContext* MySQLStatementParser::caseElse() {
  CaseElseContext *_localctx = _tracker.createInstance<CaseElseContext>(_ctx, getState());
  enterRule(_localctx, 1036, MySQLStatementParser::RuleCaseElse);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7365);
    match(MySQLStatementParser::ELSE);
    setState(7366);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalExpressionContext ------------------------------------------------------------------

MySQLStatementParser::IntervalExpressionContext::IntervalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IntervalExpressionContext::INTERVAL() {
  return getToken(MySQLStatementParser::INTERVAL, 0);
}

MySQLStatementParser::IntervalValueContext* MySQLStatementParser::IntervalExpressionContext::intervalValue() {
  return getRuleContext<MySQLStatementParser::IntervalValueContext>(0);
}


size_t MySQLStatementParser::IntervalExpressionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIntervalExpression;
}

void MySQLStatementParser::IntervalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalExpression(this);
}

void MySQLStatementParser::IntervalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalExpression(this);
}


antlrcpp::Any MySQLStatementParser::IntervalExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIntervalExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IntervalExpressionContext* MySQLStatementParser::intervalExpression() {
  IntervalExpressionContext *_localctx = _tracker.createInstance<IntervalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1038, MySQLStatementParser::RuleIntervalExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7368);
    match(MySQLStatementParser::INTERVAL);
    setState(7369);
    intervalValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalValueContext ------------------------------------------------------------------

MySQLStatementParser::IntervalValueContext::IntervalValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::ExprContext* MySQLStatementParser::IntervalValueContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

MySQLStatementParser::IntervalUnitContext* MySQLStatementParser::IntervalValueContext::intervalUnit() {
  return getRuleContext<MySQLStatementParser::IntervalUnitContext>(0);
}


size_t MySQLStatementParser::IntervalValueContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIntervalValue;
}

void MySQLStatementParser::IntervalValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalValue(this);
}

void MySQLStatementParser::IntervalValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalValue(this);
}


antlrcpp::Any MySQLStatementParser::IntervalValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIntervalValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IntervalValueContext* MySQLStatementParser::intervalValue() {
  IntervalValueContext *_localctx = _tracker.createInstance<IntervalValueContext>(_ctx, getState());
  enterRule(_localctx, 1040, MySQLStatementParser::RuleIntervalValue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7371);
    expr(0);
    setState(7372);
    intervalUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalUnitContext ------------------------------------------------------------------

MySQLStatementParser::IntervalUnitContext::IntervalUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::MICROSECOND() {
  return getToken(MySQLStatementParser::MICROSECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::SECOND() {
  return getToken(MySQLStatementParser::SECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::MINUTE() {
  return getToken(MySQLStatementParser::MINUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::HOUR() {
  return getToken(MySQLStatementParser::HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::DAY() {
  return getToken(MySQLStatementParser::DAY, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::WEEK() {
  return getToken(MySQLStatementParser::WEEK, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::MONTH() {
  return getToken(MySQLStatementParser::MONTH, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::QUARTER() {
  return getToken(MySQLStatementParser::QUARTER, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::YEAR() {
  return getToken(MySQLStatementParser::YEAR, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::SECOND_MICROSECOND() {
  return getToken(MySQLStatementParser::SECOND_MICROSECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::MINUTE_MICROSECOND() {
  return getToken(MySQLStatementParser::MINUTE_MICROSECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::MINUTE_SECOND() {
  return getToken(MySQLStatementParser::MINUTE_SECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::HOUR_MICROSECOND() {
  return getToken(MySQLStatementParser::HOUR_MICROSECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::HOUR_SECOND() {
  return getToken(MySQLStatementParser::HOUR_SECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::HOUR_MINUTE() {
  return getToken(MySQLStatementParser::HOUR_MINUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::DAY_MICROSECOND() {
  return getToken(MySQLStatementParser::DAY_MICROSECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::DAY_SECOND() {
  return getToken(MySQLStatementParser::DAY_SECOND, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::DAY_MINUTE() {
  return getToken(MySQLStatementParser::DAY_MINUTE, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::DAY_HOUR() {
  return getToken(MySQLStatementParser::DAY_HOUR, 0);
}

tree::TerminalNode* MySQLStatementParser::IntervalUnitContext::YEAR_MONTH() {
  return getToken(MySQLStatementParser::YEAR_MONTH, 0);
}


size_t MySQLStatementParser::IntervalUnitContext::getRuleIndex() const {
  return MySQLStatementParser::RuleIntervalUnit;
}

void MySQLStatementParser::IntervalUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalUnit(this);
}

void MySQLStatementParser::IntervalUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalUnit(this);
}


antlrcpp::Any MySQLStatementParser::IntervalUnitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitIntervalUnit(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::IntervalUnitContext* MySQLStatementParser::intervalUnit() {
  IntervalUnitContext *_localctx = _tracker.createInstance<IntervalUnitContext>(_ctx, getState());
  enterRule(_localctx, 1042, MySQLStatementParser::RuleIntervalUnit);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7374);
    _la = _input->LA(1);
    if (!(((((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & ((1ULL << (MySQLStatementParser::DAY - 135))
      | (1ULL << (MySQLStatementParser::DAY_HOUR - 135))
      | (1ULL << (MySQLStatementParser::DAY_MICROSECOND - 135))
      | (1ULL << (MySQLStatementParser::DAY_MINUTE - 135))
      | (1ULL << (MySQLStatementParser::DAY_SECOND - 135)))) != 0) || ((((_la - 255) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 255)) & ((1ULL << (MySQLStatementParser::HOUR - 255))
      | (1ULL << (MySQLStatementParser::HOUR_MICROSECOND - 255))
      | (1ULL << (MySQLStatementParser::HOUR_MINUTE - 255))
      | (1ULL << (MySQLStatementParser::HOUR_SECOND - 255)))) != 0) || ((((_la - 382) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 382)) & ((1ULL << (MySQLStatementParser::MICROSECOND - 382))
      | (1ULL << (MySQLStatementParser::MINUTE - 382))
      | (1ULL << (MySQLStatementParser::MINUTE_MICROSECOND - 382))
      | (1ULL << (MySQLStatementParser::MINUTE_SECOND - 382))
      | (1ULL << (MySQLStatementParser::MONTH - 382)))) != 0) || _la == MySQLStatementParser::QUARTER || _la == MySQLStatementParser::SECOND

    || _la == MySQLStatementParser::SECOND_MICROSECOND || ((((_la - 713) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 713)) & ((1ULL << (MySQLStatementParser::WEEK - 713))
      | (1ULL << (MySQLStatementParser::YEAR - 713))
      | (1ULL << (MySQLStatementParser::YEAR_MONTH - 713)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderByClauseContext ------------------------------------------------------------------

MySQLStatementParser::OrderByClauseContext::OrderByClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::OrderByClauseContext::ORDER() {
  return getToken(MySQLStatementParser::ORDER, 0);
}

tree::TerminalNode* MySQLStatementParser::OrderByClauseContext::BY() {
  return getToken(MySQLStatementParser::BY, 0);
}

std::vector<MySQLStatementParser::OrderByItemContext *> MySQLStatementParser::OrderByClauseContext::orderByItem() {
  return getRuleContexts<MySQLStatementParser::OrderByItemContext>();
}

MySQLStatementParser::OrderByItemContext* MySQLStatementParser::OrderByClauseContext::orderByItem(size_t i) {
  return getRuleContext<MySQLStatementParser::OrderByItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::OrderByClauseContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::OrderByClauseContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::OrderByClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOrderByClause;
}

void MySQLStatementParser::OrderByClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderByClause(this);
}

void MySQLStatementParser::OrderByClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderByClause(this);
}


antlrcpp::Any MySQLStatementParser::OrderByClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOrderByClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OrderByClauseContext* MySQLStatementParser::orderByClause() {
  OrderByClauseContext *_localctx = _tracker.createInstance<OrderByClauseContext>(_ctx, getState());
  enterRule(_localctx, 1044, MySQLStatementParser::RuleOrderByClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7376);
    match(MySQLStatementParser::ORDER);
    setState(7377);
    match(MySQLStatementParser::BY);
    setState(7378);
    orderByItem();
    setState(7383);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(7379);
      match(MySQLStatementParser::COMMA_);
      setState(7380);
      orderByItem();
      setState(7385);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderByItemContext ------------------------------------------------------------------

MySQLStatementParser::OrderByItemContext::OrderByItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::OrderByItemContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

MySQLStatementParser::ExprContext* MySQLStatementParser::OrderByItemContext::expr() {
  return getRuleContext<MySQLStatementParser::ExprContext>(0);
}

MySQLStatementParser::DirectionContext* MySQLStatementParser::OrderByItemContext::direction() {
  return getRuleContext<MySQLStatementParser::DirectionContext>(0);
}


size_t MySQLStatementParser::OrderByItemContext::getRuleIndex() const {
  return MySQLStatementParser::RuleOrderByItem;
}

void MySQLStatementParser::OrderByItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderByItem(this);
}

void MySQLStatementParser::OrderByItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderByItem(this);
}


antlrcpp::Any MySQLStatementParser::OrderByItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitOrderByItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::OrderByItemContext* MySQLStatementParser::orderByItem() {
  OrderByItemContext *_localctx = _tracker.createInstance<OrderByItemContext>(_ctx, getState());
  enterRule(_localctx, 1046, MySQLStatementParser::RuleOrderByItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7388);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 951, _ctx)) {
    case 1: {
      setState(7386);
      numberLiterals();
      break;
    }

    case 2: {
      setState(7387);
      expr(0);
      break;
    }

    }
    setState(7391);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 952, _ctx)) {
    case 1: {
      setState(7390);
      direction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeContext ------------------------------------------------------------------

MySQLStatementParser::DataTypeContext::DataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::INTEGER() {
  return getToken(MySQLStatementParser::INTEGER, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::INT() {
  return getToken(MySQLStatementParser::INT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::TINYINT() {
  return getToken(MySQLStatementParser::TINYINT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::SMALLINT() {
  return getToken(MySQLStatementParser::SMALLINT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::MIDDLEINT() {
  return getToken(MySQLStatementParser::MIDDLEINT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::MEDIUMINT() {
  return getToken(MySQLStatementParser::MEDIUMINT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::BIGINT() {
  return getToken(MySQLStatementParser::BIGINT, 0);
}

MySQLStatementParser::FieldLengthContext* MySQLStatementParser::DataTypeContext::fieldLength() {
  return getRuleContext<MySQLStatementParser::FieldLengthContext>(0);
}

MySQLStatementParser::FieldOptionsContext* MySQLStatementParser::DataTypeContext::fieldOptions() {
  return getRuleContext<MySQLStatementParser::FieldOptionsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::REAL() {
  return getToken(MySQLStatementParser::REAL, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::DOUBLE() {
  return getToken(MySQLStatementParser::DOUBLE, 0);
}

MySQLStatementParser::PrecisionContext* MySQLStatementParser::DataTypeContext::precision() {
  return getRuleContext<MySQLStatementParser::PrecisionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::PRECISION() {
  return getToken(MySQLStatementParser::PRECISION, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::FLOAT() {
  return getToken(MySQLStatementParser::FLOAT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::DECIMAL() {
  return getToken(MySQLStatementParser::DECIMAL, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::NUMERIC() {
  return getToken(MySQLStatementParser::NUMERIC, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::FIXED() {
  return getToken(MySQLStatementParser::FIXED, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::BIT() {
  return getToken(MySQLStatementParser::BIT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::BOOL() {
  return getToken(MySQLStatementParser::BOOL, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::BOOLEAN() {
  return getToken(MySQLStatementParser::BOOLEAN, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::CHAR() {
  return getToken(MySQLStatementParser::CHAR, 0);
}

MySQLStatementParser::CharsetWithOptBinaryContext* MySQLStatementParser::DataTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLStatementParser::CharsetWithOptBinaryContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::NCHAR() {
  return getToken(MySQLStatementParser::NCHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::NATIONAL() {
  return getToken(MySQLStatementParser::NATIONAL, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::VARYING() {
  return getToken(MySQLStatementParser::VARYING, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::VARCHAR() {
  return getToken(MySQLStatementParser::VARCHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::NVARCHAR() {
  return getToken(MySQLStatementParser::NVARCHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::VARBINARY() {
  return getToken(MySQLStatementParser::VARBINARY, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::YEAR() {
  return getToken(MySQLStatementParser::YEAR, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::DATE() {
  return getToken(MySQLStatementParser::DATE, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::TIME() {
  return getToken(MySQLStatementParser::TIME, 0);
}

MySQLStatementParser::TypeDatetimePrecisionContext* MySQLStatementParser::DataTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLStatementParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::TIMESTAMP() {
  return getToken(MySQLStatementParser::TIMESTAMP, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::DATETIME() {
  return getToken(MySQLStatementParser::DATETIME, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::TINYBLOB() {
  return getToken(MySQLStatementParser::TINYBLOB, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::BLOB() {
  return getToken(MySQLStatementParser::BLOB, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::MEDIUMBLOB() {
  return getToken(MySQLStatementParser::MEDIUMBLOB, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::LONGBLOB() {
  return getToken(MySQLStatementParser::LONGBLOB, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::LONG() {
  return getToken(MySQLStatementParser::LONG, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::TINYTEXT() {
  return getToken(MySQLStatementParser::TINYTEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::TEXT() {
  return getToken(MySQLStatementParser::TEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::MEDIUMTEXT() {
  return getToken(MySQLStatementParser::MEDIUMTEXT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::LONGTEXT() {
  return getToken(MySQLStatementParser::LONGTEXT, 0);
}

MySQLStatementParser::StringListContext* MySQLStatementParser::DataTypeContext::stringList() {
  return getRuleContext<MySQLStatementParser::StringListContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::ENUM() {
  return getToken(MySQLStatementParser::ENUM, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::SERIAL() {
  return getToken(MySQLStatementParser::SERIAL, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::JSON() {
  return getToken(MySQLStatementParser::JSON, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::GEOMETRY() {
  return getToken(MySQLStatementParser::GEOMETRY, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::GEOMETRYCOLLECTION() {
  return getToken(MySQLStatementParser::GEOMETRYCOLLECTION, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::POINT() {
  return getToken(MySQLStatementParser::POINT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::MULTIPOINT() {
  return getToken(MySQLStatementParser::MULTIPOINT, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::LINESTRING() {
  return getToken(MySQLStatementParser::LINESTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::MULTILINESTRING() {
  return getToken(MySQLStatementParser::MULTILINESTRING, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::POLYGON() {
  return getToken(MySQLStatementParser::POLYGON, 0);
}

tree::TerminalNode* MySQLStatementParser::DataTypeContext::MULTIPOLYGON() {
  return getToken(MySQLStatementParser::MULTIPOLYGON, 0);
}


size_t MySQLStatementParser::DataTypeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDataType;
}

void MySQLStatementParser::DataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataType(this);
}

void MySQLStatementParser::DataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataType(this);
}


antlrcpp::Any MySQLStatementParser::DataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDataType(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DataTypeContext* MySQLStatementParser::dataType() {
  DataTypeContext *_localctx = _tracker.createInstance<DataTypeContext>(_ctx, getState());
  enterRule(_localctx, 1048, MySQLStatementParser::RuleDataType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7544);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 988, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7393);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::BIGINT || _la == MySQLStatementParser::INT

      || _la == MySQLStatementParser::INTEGER || _la == MySQLStatementParser::MEDIUMINT

      || _la == MySQLStatementParser::MIDDLEINT || _la == MySQLStatementParser::SMALLINT || _la == MySQLStatementParser::TINYINT)) {
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7395);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 953, _ctx)) {
      case 1: {
        setState(7394);
        fieldLength();
        break;
      }

      }
      setState(7398);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 954, _ctx)) {
      case 1: {
        setState(7397);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7405);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::REAL: {
          setState(7400);
          dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::REAL);
          break;
        }

        case MySQLStatementParser::DOUBLE: {
          setState(7401);
          dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::DOUBLE);
          setState(7403);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLStatementParser::PRECISION) {
            setState(7402);
            match(MySQLStatementParser::PRECISION);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(7408);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 957, _ctx)) {
      case 1: {
        setState(7407);
        precision();
        break;
      }

      }
      setState(7411);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 958, _ctx)) {
      case 1: {
        setState(7410);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7413);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::DECIMAL || _la == MySQLStatementParser::FIXED

      || _la == MySQLStatementParser::FLOAT || _la == MySQLStatementParser::NUMERIC)) {
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7416);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 959, _ctx)) {
      case 1: {
        setState(7414);
        fieldLength();
        break;
      }

      case 2: {
        setState(7415);
        precision();
        break;
      }

      }
      setState(7419);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 960, _ctx)) {
      case 1: {
        setState(7418);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7421);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::BIT);
      setState(7423);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 961, _ctx)) {
      case 1: {
        setState(7422);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7425);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::BOOL

      || _la == MySQLStatementParser::BOOLEAN)) {
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7426);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::CHAR);
      setState(7428);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 962, _ctx)) {
      case 1: {
        setState(7427);
        fieldLength();
        break;
      }

      }
      setState(7431);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 963, _ctx)) {
      case 1: {
        setState(7430);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7436);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::NCHAR: {
          setState(7433);
          dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::NCHAR);
          break;
        }

        case MySQLStatementParser::NATIONAL: {
          setState(7434);
          dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::NATIONAL);
          setState(7435);
          match(MySQLStatementParser::CHAR);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(7439);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 965, _ctx)) {
      case 1: {
        setState(7438);
        fieldLength();
        break;
      }

      }
      setState(7442);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::BINARY) {
        setState(7441);
        match(MySQLStatementParser::BINARY);
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7444);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::BINARY);
      setState(7446);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 967, _ctx)) {
      case 1: {
        setState(7445);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7451);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLStatementParser::CHAR: {
          setState(7448);
          dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::CHAR);
          setState(7449);
          match(MySQLStatementParser::VARYING);
          break;
        }

        case MySQLStatementParser::VARCHAR: {
          setState(7450);
          dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::VARCHAR);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(7453);
      fieldLength();
      setState(7455);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 969, _ctx)) {
      case 1: {
        setState(7454);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(7467);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 970, _ctx)) {
      case 1: {
        setState(7457);
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::NATIONAL);
        setState(7458);
        match(MySQLStatementParser::VARCHAR);
        break;
      }

      case 2: {
        setState(7459);
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::NVARCHAR);
        break;
      }

      case 3: {
        setState(7460);
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::NCHAR);
        setState(7461);
        match(MySQLStatementParser::VARCHAR);
        break;
      }

      case 4: {
        setState(7462);
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::NATIONAL);
        setState(7463);
        match(MySQLStatementParser::CHAR);
        setState(7464);
        match(MySQLStatementParser::VARYING);
        break;
      }

      case 5: {
        setState(7465);
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::NCHAR);
        setState(7466);
        match(MySQLStatementParser::VARYING);
        break;
      }

      }
      setState(7469);
      fieldLength();
      setState(7471);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::BINARY) {
        setState(7470);
        match(MySQLStatementParser::BINARY);
      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(7473);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::VARBINARY);
      setState(7475);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 972, _ctx)) {
      case 1: {
        setState(7474);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(7477);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::YEAR);
      setState(7479);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 973, _ctx)) {
      case 1: {
        setState(7478);
        fieldLength();
        break;
      }

      }
      setState(7482);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 974, _ctx)) {
      case 1: {
        setState(7481);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(7484);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::DATE);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(7485);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::TIME);
      setState(7487);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 975, _ctx)) {
      case 1: {
        setState(7486);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(7489);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::TIMESTAMP);
      setState(7491);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 976, _ctx)) {
      case 1: {
        setState(7490);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(7493);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::DATETIME);
      setState(7495);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 977, _ctx)) {
      case 1: {
        setState(7494);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(7497);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::TINYBLOB);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(7498);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::BLOB);
      setState(7500);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 978, _ctx)) {
      case 1: {
        setState(7499);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(7502);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::LONGBLOB

      || _la == MySQLStatementParser::MEDIUMBLOB)) {
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(7503);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::LONG);
      setState(7504);
      match(MySQLStatementParser::VARBINARY);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(7505);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::LONG);
      setState(7509);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 979, _ctx)) {
      case 1: {
        setState(7506);
        match(MySQLStatementParser::CHAR);
        setState(7507);
        match(MySQLStatementParser::VARYING);
        break;
      }

      case 2: {
        setState(7508);
        match(MySQLStatementParser::VARCHAR);
        break;
      }

      }
      setState(7512);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 980, _ctx)) {
      case 1: {
        setState(7511);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(7514);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::TINYTEXT);
      setState(7516);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 981, _ctx)) {
      case 1: {
        setState(7515);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(7518);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::TEXT);
      setState(7520);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 982, _ctx)) {
      case 1: {
        setState(7519);
        fieldLength();
        break;
      }

      }
      setState(7523);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx)) {
      case 1: {
        setState(7522);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(7525);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::MEDIUMTEXT);
      setState(7527);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 984, _ctx)) {
      case 1: {
        setState(7526);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(7529);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::LONGTEXT);
      setState(7531);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 985, _ctx)) {
      case 1: {
        setState(7530);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(7533);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::ENUM);
      setState(7534);
      stringList();
      setState(7536);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 986, _ctx)) {
      case 1: {
        setState(7535);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(7538);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = match(MySQLStatementParser::SET);
      setState(7539);
      stringList();
      setState(7541);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 987, _ctx)) {
      case 1: {
        setState(7540);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(7543);
      dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLStatementParser::GEOMETRY

      || _la == MySQLStatementParser::GEOMETRYCOLLECTION || _la == MySQLStatementParser::JSON

      || _la == MySQLStatementParser::LINESTRING || ((((_la - 394) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 394)) & ((1ULL << (MySQLStatementParser::MULTILINESTRING - 394))
        | (1ULL << (MySQLStatementParser::MULTIPOINT - 394))
        | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 394)))) != 0) || _la == MySQLStatementParser::POINT

      || _la == MySQLStatementParser::POLYGON || _la == MySQLStatementParser::SERIAL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->dataTypeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringListContext ------------------------------------------------------------------

MySQLStatementParser::StringListContext::StringListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StringListContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<MySQLStatementParser::TextStringContext *> MySQLStatementParser::StringListContext::textString() {
  return getRuleContexts<MySQLStatementParser::TextStringContext>();
}

MySQLStatementParser::TextStringContext* MySQLStatementParser::StringListContext::textString(size_t i) {
  return getRuleContext<MySQLStatementParser::TextStringContext>(i);
}

tree::TerminalNode* MySQLStatementParser::StringListContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::StringListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::StringListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::StringListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStringList;
}

void MySQLStatementParser::StringListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringList(this);
}

void MySQLStatementParser::StringListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringList(this);
}


antlrcpp::Any MySQLStatementParser::StringListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStringList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StringListContext* MySQLStatementParser::stringList() {
  StringListContext *_localctx = _tracker.createInstance<StringListContext>(_ctx, getState());
  enterRule(_localctx, 1050, MySQLStatementParser::RuleStringList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7546);
    match(MySQLStatementParser::LP_);
    setState(7547);
    textString();
    setState(7552);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(7548);
      match(MySQLStatementParser::COMMA_);
      setState(7549);
      textString();
      setState(7554);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7555);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringContext ------------------------------------------------------------------

MySQLStatementParser::TextStringContext::TextStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::String_Context* MySQLStatementParser::TextStringContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::TextStringContext::HEX_DIGIT_() {
  return getToken(MySQLStatementParser::HEX_DIGIT_, 0);
}

tree::TerminalNode* MySQLStatementParser::TextStringContext::BIT_NUM_() {
  return getToken(MySQLStatementParser::BIT_NUM_, 0);
}


size_t MySQLStatementParser::TextStringContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTextString;
}

void MySQLStatementParser::TextStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextString(this);
}

void MySQLStatementParser::TextStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextString(this);
}


antlrcpp::Any MySQLStatementParser::TextStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTextString(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TextStringContext* MySQLStatementParser::textString() {
  TextStringContext *_localctx = _tracker.createInstance<TextStringContext>(_ctx, getState());
  enterRule(_localctx, 1052, MySQLStatementParser::RuleTextString);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7560);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(7557);
        string_();
        break;
      }

      case MySQLStatementParser::HEX_DIGIT_: {
        enterOuterAlt(_localctx, 2);
        setState(7558);
        match(MySQLStatementParser::HEX_DIGIT_);
        break;
      }

      case MySQLStatementParser::BIT_NUM_: {
        enterOuterAlt(_localctx, 3);
        setState(7559);
        match(MySQLStatementParser::BIT_NUM_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringHashContext ------------------------------------------------------------------

MySQLStatementParser::TextStringHashContext::TextStringHashContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::String_Context* MySQLStatementParser::TextStringHashContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::TextStringHashContext::HEX_DIGIT_() {
  return getToken(MySQLStatementParser::HEX_DIGIT_, 0);
}


size_t MySQLStatementParser::TextStringHashContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTextStringHash;
}

void MySQLStatementParser::TextStringHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringHash(this);
}

void MySQLStatementParser::TextStringHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringHash(this);
}


antlrcpp::Any MySQLStatementParser::TextStringHashContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTextStringHash(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TextStringHashContext* MySQLStatementParser::textStringHash() {
  TextStringHashContext *_localctx = _tracker.createInstance<TextStringHashContext>(_ctx, getState());
  enterRule(_localctx, 1054, MySQLStatementParser::RuleTextStringHash);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7564);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT: {
        enterOuterAlt(_localctx, 1);
        setState(7562);
        string_();
        break;
      }

      case MySQLStatementParser::HEX_DIGIT_: {
        enterOuterAlt(_localctx, 2);
        setState(7563);
        match(MySQLStatementParser::HEX_DIGIT_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOptionsContext ------------------------------------------------------------------

MySQLStatementParser::FieldOptionsContext::FieldOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLStatementParser::FieldOptionsContext::UNSIGNED() {
  return getTokens(MySQLStatementParser::UNSIGNED);
}

tree::TerminalNode* MySQLStatementParser::FieldOptionsContext::UNSIGNED(size_t i) {
  return getToken(MySQLStatementParser::UNSIGNED, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::FieldOptionsContext::SIGNED() {
  return getTokens(MySQLStatementParser::SIGNED);
}

tree::TerminalNode* MySQLStatementParser::FieldOptionsContext::SIGNED(size_t i) {
  return getToken(MySQLStatementParser::SIGNED, i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::FieldOptionsContext::ZEROFILL() {
  return getTokens(MySQLStatementParser::ZEROFILL);
}

tree::TerminalNode* MySQLStatementParser::FieldOptionsContext::ZEROFILL(size_t i) {
  return getToken(MySQLStatementParser::ZEROFILL, i);
}


size_t MySQLStatementParser::FieldOptionsContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFieldOptions;
}

void MySQLStatementParser::FieldOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOptions(this);
}

void MySQLStatementParser::FieldOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOptions(this);
}


antlrcpp::Any MySQLStatementParser::FieldOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFieldOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FieldOptionsContext* MySQLStatementParser::fieldOptions() {
  FieldOptionsContext *_localctx = _tracker.createInstance<FieldOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1056, MySQLStatementParser::RuleFieldOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7567); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7566);
              _la = _input->LA(1);
              if (!(_la == MySQLStatementParser::SIGNED || _la == MySQLStatementParser::UNSIGNED

              || _la == MySQLStatementParser::ZEROFILL)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7569); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 992, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrecisionContext ------------------------------------------------------------------

MySQLStatementParser::PrecisionContext::PrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PrecisionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::PrecisionContext::NUMBER_() {
  return getTokens(MySQLStatementParser::NUMBER_);
}

tree::TerminalNode* MySQLStatementParser::PrecisionContext::NUMBER_(size_t i) {
  return getToken(MySQLStatementParser::NUMBER_, i);
}

tree::TerminalNode* MySQLStatementParser::PrecisionContext::COMMA_() {
  return getToken(MySQLStatementParser::COMMA_, 0);
}

tree::TerminalNode* MySQLStatementParser::PrecisionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::PrecisionContext::getRuleIndex() const {
  return MySQLStatementParser::RulePrecision;
}

void MySQLStatementParser::PrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecision(this);
}

void MySQLStatementParser::PrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecision(this);
}


antlrcpp::Any MySQLStatementParser::PrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PrecisionContext* MySQLStatementParser::precision() {
  PrecisionContext *_localctx = _tracker.createInstance<PrecisionContext>(_ctx, getState());
  enterRule(_localctx, 1058, MySQLStatementParser::RulePrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7571);
    match(MySQLStatementParser::LP_);
    setState(7572);
    match(MySQLStatementParser::NUMBER_);
    setState(7573);
    match(MySQLStatementParser::COMMA_);
    setState(7574);
    match(MySQLStatementParser::NUMBER_);
    setState(7575);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDatetimePrecisionContext ------------------------------------------------------------------

MySQLStatementParser::TypeDatetimePrecisionContext::TypeDatetimePrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::TypeDatetimePrecisionContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::TypeDatetimePrecisionContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}

tree::TerminalNode* MySQLStatementParser::TypeDatetimePrecisionContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}


size_t MySQLStatementParser::TypeDatetimePrecisionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleTypeDatetimePrecision;
}

void MySQLStatementParser::TypeDatetimePrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeDatetimePrecision(this);
}

void MySQLStatementParser::TypeDatetimePrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeDatetimePrecision(this);
}


antlrcpp::Any MySQLStatementParser::TypeDatetimePrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitTypeDatetimePrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::TypeDatetimePrecisionContext* MySQLStatementParser::typeDatetimePrecision() {
  TypeDatetimePrecisionContext *_localctx = _tracker.createInstance<TypeDatetimePrecisionContext>(_ctx, getState());
  enterRule(_localctx, 1060, MySQLStatementParser::RuleTypeDatetimePrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7577);
    match(MySQLStatementParser::LP_);
    setState(7578);
    match(MySQLStatementParser::NUMBER_);
    setState(7579);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetWithOptBinaryContext ------------------------------------------------------------------

MySQLStatementParser::CharsetWithOptBinaryContext::CharsetWithOptBinaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::AsciiContext* MySQLStatementParser::CharsetWithOptBinaryContext::ascii() {
  return getRuleContext<MySQLStatementParser::AsciiContext>(0);
}

MySQLStatementParser::UnicodeContext* MySQLStatementParser::CharsetWithOptBinaryContext::unicode() {
  return getRuleContext<MySQLStatementParser::UnicodeContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CharsetWithOptBinaryContext::BYTE() {
  return getToken(MySQLStatementParser::BYTE, 0);
}

MySQLStatementParser::CharsetContext* MySQLStatementParser::CharsetWithOptBinaryContext::charset() {
  return getRuleContext<MySQLStatementParser::CharsetContext>(0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::CharsetWithOptBinaryContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::CharsetWithOptBinaryContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}


size_t MySQLStatementParser::CharsetWithOptBinaryContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCharsetWithOptBinary;
}

void MySQLStatementParser::CharsetWithOptBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetWithOptBinary(this);
}

void MySQLStatementParser::CharsetWithOptBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetWithOptBinary(this);
}


antlrcpp::Any MySQLStatementParser::CharsetWithOptBinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCharsetWithOptBinary(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CharsetWithOptBinaryContext* MySQLStatementParser::charsetWithOptBinary() {
  CharsetWithOptBinaryContext *_localctx = _tracker.createInstance<CharsetWithOptBinaryContext>(_ctx, getState());
  enterRule(_localctx, 1062, MySQLStatementParser::RuleCharsetWithOptBinary);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7595);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 995, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7581);
      ascii();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7582);
      unicode();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7583);
      match(MySQLStatementParser::BYTE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7584);
      charset();
      setState(7585);
      charsetName();
      setState(7587);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::BINARY) {
        setState(7586);
        match(MySQLStatementParser::BINARY);
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7589);
      match(MySQLStatementParser::BINARY);
      setState(7593);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 994, _ctx)) {
      case 1: {
        setState(7590);
        charset();
        setState(7591);
        charsetName();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsciiContext ------------------------------------------------------------------

MySQLStatementParser::AsciiContext::AsciiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::AsciiContext::ASCII() {
  return getToken(MySQLStatementParser::ASCII, 0);
}

tree::TerminalNode* MySQLStatementParser::AsciiContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}


size_t MySQLStatementParser::AsciiContext::getRuleIndex() const {
  return MySQLStatementParser::RuleAscii;
}

void MySQLStatementParser::AsciiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAscii(this);
}

void MySQLStatementParser::AsciiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAscii(this);
}


antlrcpp::Any MySQLStatementParser::AsciiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitAscii(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::AsciiContext* MySQLStatementParser::ascii() {
  AsciiContext *_localctx = _tracker.createInstance<AsciiContext>(_ctx, getState());
  enterRule(_localctx, 1064, MySQLStatementParser::RuleAscii);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7603);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::ASCII: {
        enterOuterAlt(_localctx, 1);
        setState(7597);
        match(MySQLStatementParser::ASCII);
        setState(7599);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::BINARY) {
          setState(7598);
          match(MySQLStatementParser::BINARY);
        }
        break;
      }

      case MySQLStatementParser::BINARY: {
        enterOuterAlt(_localctx, 2);
        setState(7601);
        match(MySQLStatementParser::BINARY);
        setState(7602);
        match(MySQLStatementParser::ASCII);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnicodeContext ------------------------------------------------------------------

MySQLStatementParser::UnicodeContext::UnicodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UnicodeContext::UNICODE() {
  return getToken(MySQLStatementParser::UNICODE, 0);
}

tree::TerminalNode* MySQLStatementParser::UnicodeContext::BINARY() {
  return getToken(MySQLStatementParser::BINARY, 0);
}


size_t MySQLStatementParser::UnicodeContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUnicode;
}

void MySQLStatementParser::UnicodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnicode(this);
}

void MySQLStatementParser::UnicodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnicode(this);
}


antlrcpp::Any MySQLStatementParser::UnicodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUnicode(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UnicodeContext* MySQLStatementParser::unicode() {
  UnicodeContext *_localctx = _tracker.createInstance<UnicodeContext>(_ctx, getState());
  enterRule(_localctx, 1066, MySQLStatementParser::RuleUnicode);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7611);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::UNICODE: {
        enterOuterAlt(_localctx, 1);
        setState(7605);
        match(MySQLStatementParser::UNICODE);
        setState(7607);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLStatementParser::BINARY) {
          setState(7606);
          match(MySQLStatementParser::BINARY);
        }
        break;
      }

      case MySQLStatementParser::BINARY: {
        enterOuterAlt(_localctx, 2);
        setState(7609);
        match(MySQLStatementParser::BINARY);
        setState(7610);
        match(MySQLStatementParser::UNICODE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetContext ------------------------------------------------------------------

MySQLStatementParser::CharsetContext::CharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CharsetContext::SET() {
  return getToken(MySQLStatementParser::SET, 0);
}

tree::TerminalNode* MySQLStatementParser::CharsetContext::CHAR() {
  return getToken(MySQLStatementParser::CHAR, 0);
}

tree::TerminalNode* MySQLStatementParser::CharsetContext::CHARACTER() {
  return getToken(MySQLStatementParser::CHARACTER, 0);
}

tree::TerminalNode* MySQLStatementParser::CharsetContext::CHARSET() {
  return getToken(MySQLStatementParser::CHARSET, 0);
}


size_t MySQLStatementParser::CharsetContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCharset;
}

void MySQLStatementParser::CharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharset(this);
}

void MySQLStatementParser::CharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharset(this);
}


antlrcpp::Any MySQLStatementParser::CharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCharset(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CharsetContext* MySQLStatementParser::charset() {
  CharsetContext *_localctx = _tracker.createInstance<CharsetContext>(_ctx, getState());
  enterRule(_localctx, 1068, MySQLStatementParser::RuleCharset);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7616);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::CHAR:
      case MySQLStatementParser::CHARACTER: {
        enterOuterAlt(_localctx, 1);
        setState(7613);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::CHAR

        || _la == MySQLStatementParser::CHARACTER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7614);
        match(MySQLStatementParser::SET);
        break;
      }

      case MySQLStatementParser::CHARSET: {
        enterOuterAlt(_localctx, 2);
        setState(7615);
        match(MySQLStatementParser::CHARSET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCollationContext ------------------------------------------------------------------

MySQLStatementParser::DefaultCollationContext::DefaultCollationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DefaultCollationContext::COLLATE() {
  return getToken(MySQLStatementParser::COLLATE, 0);
}

MySQLStatementParser::CollationNameContext* MySQLStatementParser::DefaultCollationContext::collationName() {
  return getRuleContext<MySQLStatementParser::CollationNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DefaultCollationContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::DefaultCollationContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::DefaultCollationContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDefaultCollation;
}

void MySQLStatementParser::DefaultCollationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCollation(this);
}

void MySQLStatementParser::DefaultCollationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCollation(this);
}


antlrcpp::Any MySQLStatementParser::DefaultCollationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDefaultCollation(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DefaultCollationContext* MySQLStatementParser::defaultCollation() {
  DefaultCollationContext *_localctx = _tracker.createInstance<DefaultCollationContext>(_ctx, getState());
  enterRule(_localctx, 1070, MySQLStatementParser::RuleDefaultCollation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFAULT) {
      setState(7618);
      match(MySQLStatementParser::DEFAULT);
    }
    setState(7621);
    match(MySQLStatementParser::COLLATE);
    setState(7623);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EQ_) {
      setState(7622);
      match(MySQLStatementParser::EQ_);
    }
    setState(7625);
    collationName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultEncryptionContext ------------------------------------------------------------------

MySQLStatementParser::DefaultEncryptionContext::DefaultEncryptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DefaultEncryptionContext::ENCRYPTION() {
  return getToken(MySQLStatementParser::ENCRYPTION, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::DefaultEncryptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}

tree::TerminalNode* MySQLStatementParser::DefaultEncryptionContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::DefaultEncryptionContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::DefaultEncryptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDefaultEncryption;
}

void MySQLStatementParser::DefaultEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultEncryption(this);
}

void MySQLStatementParser::DefaultEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultEncryption(this);
}


antlrcpp::Any MySQLStatementParser::DefaultEncryptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDefaultEncryption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DefaultEncryptionContext* MySQLStatementParser::defaultEncryption() {
  DefaultEncryptionContext *_localctx = _tracker.createInstance<DefaultEncryptionContext>(_ctx, getState());
  enterRule(_localctx, 1072, MySQLStatementParser::RuleDefaultEncryption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7628);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFAULT) {
      setState(7627);
      match(MySQLStatementParser::DEFAULT);
    }
    setState(7630);
    match(MySQLStatementParser::ENCRYPTION);
    setState(7632);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EQ_) {
      setState(7631);
      match(MySQLStatementParser::EQ_);
    }
    setState(7634);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCharsetContext ------------------------------------------------------------------

MySQLStatementParser::DefaultCharsetContext::DefaultCharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CharsetContext* MySQLStatementParser::DefaultCharsetContext::charset() {
  return getRuleContext<MySQLStatementParser::CharsetContext>(0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::DefaultCharsetContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLStatementParser::DefaultCharsetContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}

tree::TerminalNode* MySQLStatementParser::DefaultCharsetContext::EQ_() {
  return getToken(MySQLStatementParser::EQ_, 0);
}


size_t MySQLStatementParser::DefaultCharsetContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDefaultCharset;
}

void MySQLStatementParser::DefaultCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCharset(this);
}

void MySQLStatementParser::DefaultCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCharset(this);
}


antlrcpp::Any MySQLStatementParser::DefaultCharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDefaultCharset(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DefaultCharsetContext* MySQLStatementParser::defaultCharset() {
  DefaultCharsetContext *_localctx = _tracker.createInstance<DefaultCharsetContext>(_ctx, getState());
  enterRule(_localctx, 1074, MySQLStatementParser::RuleDefaultCharset);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::DEFAULT) {
      setState(7636);
      match(MySQLStatementParser::DEFAULT);
    }
    setState(7639);
    charset();
    setState(7641);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::EQ_) {
      setState(7640);
      match(MySQLStatementParser::EQ_);
    }
    setState(7643);
    charsetName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignedLiteralContext ------------------------------------------------------------------

MySQLStatementParser::SignedLiteralContext::SignedLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::LiteralsContext* MySQLStatementParser::SignedLiteralContext::literals() {
  return getRuleContext<MySQLStatementParser::LiteralsContext>(0);
}

MySQLStatementParser::NumberLiteralsContext* MySQLStatementParser::SignedLiteralContext::numberLiterals() {
  return getRuleContext<MySQLStatementParser::NumberLiteralsContext>(0);
}

tree::TerminalNode* MySQLStatementParser::SignedLiteralContext::PLUS_() {
  return getToken(MySQLStatementParser::PLUS_, 0);
}

tree::TerminalNode* MySQLStatementParser::SignedLiteralContext::MINUS_() {
  return getToken(MySQLStatementParser::MINUS_, 0);
}


size_t MySQLStatementParser::SignedLiteralContext::getRuleIndex() const {
  return MySQLStatementParser::RuleSignedLiteral;
}

void MySQLStatementParser::SignedLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignedLiteral(this);
}

void MySQLStatementParser::SignedLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignedLiteral(this);
}


antlrcpp::Any MySQLStatementParser::SignedLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitSignedLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::SignedLiteralContext* MySQLStatementParser::signedLiteral() {
  SignedLiteralContext *_localctx = _tracker.createInstance<SignedLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1076, MySQLStatementParser::RuleSignedLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7648);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::DATE:
      case MySQLStatementParser::FALSE:
      case MySQLStatementParser::NULL:
      case MySQLStatementParser::TIME:
      case MySQLStatementParser::TIMESTAMP:
      case MySQLStatementParser::TRUE:
      case MySQLStatementParser::SINGLE_QUOTED_TEXT:
      case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
      case MySQLStatementParser::NCHAR_TEXT:
      case MySQLStatementParser::UNDERSCORE_CHARSET:
      case MySQLStatementParser::NUMBER_:
      case MySQLStatementParser::HEX_DIGIT_:
      case MySQLStatementParser::BIT_NUM_: {
        enterOuterAlt(_localctx, 1);
        setState(7645);
        literals();
        break;
      }

      case MySQLStatementParser::PLUS_:
      case MySQLStatementParser::MINUS_: {
        enterOuterAlt(_localctx, 2);
        setState(7646);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::PLUS_

        || _la == MySQLStatementParser::MINUS_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7647);
        numberLiterals();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NowContext ------------------------------------------------------------------

MySQLStatementParser::NowContext::NowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NowContext::CURRENT_TIMESTAMP() {
  return getToken(MySQLStatementParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* MySQLStatementParser::NowContext::LOCALTIME() {
  return getToken(MySQLStatementParser::LOCALTIME, 0);
}

tree::TerminalNode* MySQLStatementParser::NowContext::LOCALTIMESTAMP() {
  return getToken(MySQLStatementParser::LOCALTIMESTAMP, 0);
}

tree::TerminalNode* MySQLStatementParser::NowContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::NowContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::NowContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::NowContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNow;
}

void MySQLStatementParser::NowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNow(this);
}

void MySQLStatementParser::NowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNow(this);
}


antlrcpp::Any MySQLStatementParser::NowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNow(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NowContext* MySQLStatementParser::now() {
  NowContext *_localctx = _tracker.createInstance<NowContext>(_ctx, getState());
  enterRule(_localctx, 1078, MySQLStatementParser::RuleNow);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7650);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::CURRENT_TIMESTAMP || _la == MySQLStatementParser::LOCALTIME

    || _la == MySQLStatementParser::LOCALTIMESTAMP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7656);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1009, _ctx)) {
    case 1: {
      setState(7651);
      match(MySQLStatementParser::LP_);
      setState(7653);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLStatementParser::NUMBER_) {
        setState(7652);
        match(MySQLStatementParser::NUMBER_);
      }
      setState(7655);
      match(MySQLStatementParser::RP_);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnFormatContext ------------------------------------------------------------------

MySQLStatementParser::ColumnFormatContext::ColumnFormatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ColumnFormatContext::FIXED() {
  return getToken(MySQLStatementParser::FIXED, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnFormatContext::DYNAMIC() {
  return getToken(MySQLStatementParser::DYNAMIC, 0);
}

tree::TerminalNode* MySQLStatementParser::ColumnFormatContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}


size_t MySQLStatementParser::ColumnFormatContext::getRuleIndex() const {
  return MySQLStatementParser::RuleColumnFormat;
}

void MySQLStatementParser::ColumnFormatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnFormat(this);
}

void MySQLStatementParser::ColumnFormatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnFormat(this);
}


antlrcpp::Any MySQLStatementParser::ColumnFormatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitColumnFormat(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ColumnFormatContext* MySQLStatementParser::columnFormat() {
  ColumnFormatContext *_localctx = _tracker.createInstance<ColumnFormatContext>(_ctx, getState());
  enterRule(_localctx, 1080, MySQLStatementParser::RuleColumnFormat);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7658);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DEFAULT

    || _la == MySQLStatementParser::DYNAMIC || _la == MySQLStatementParser::FIXED)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageMediaContext ------------------------------------------------------------------

MySQLStatementParser::StorageMediaContext::StorageMediaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::StorageMediaContext::DISK() {
  return getToken(MySQLStatementParser::DISK, 0);
}

tree::TerminalNode* MySQLStatementParser::StorageMediaContext::MEMORY() {
  return getToken(MySQLStatementParser::MEMORY, 0);
}

tree::TerminalNode* MySQLStatementParser::StorageMediaContext::DEFAULT() {
  return getToken(MySQLStatementParser::DEFAULT, 0);
}


size_t MySQLStatementParser::StorageMediaContext::getRuleIndex() const {
  return MySQLStatementParser::RuleStorageMedia;
}

void MySQLStatementParser::StorageMediaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageMedia(this);
}

void MySQLStatementParser::StorageMediaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageMedia(this);
}


antlrcpp::Any MySQLStatementParser::StorageMediaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitStorageMedia(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::StorageMediaContext* MySQLStatementParser::storageMedia() {
  StorageMediaContext *_localctx = _tracker.createInstance<StorageMediaContext>(_ctx, getState());
  enterRule(_localctx, 1082, MySQLStatementParser::RuleStorageMedia);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7660);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::DEFAULT

    || _la == MySQLStatementParser::DISK || _la == MySQLStatementParser::MEMORY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectionContext ------------------------------------------------------------------

MySQLStatementParser::DirectionContext::DirectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::DirectionContext::ASC() {
  return getToken(MySQLStatementParser::ASC, 0);
}

tree::TerminalNode* MySQLStatementParser::DirectionContext::DESC() {
  return getToken(MySQLStatementParser::DESC, 0);
}


size_t MySQLStatementParser::DirectionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleDirection;
}

void MySQLStatementParser::DirectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirection(this);
}

void MySQLStatementParser::DirectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirection(this);
}


antlrcpp::Any MySQLStatementParser::DirectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitDirection(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::DirectionContext* MySQLStatementParser::direction() {
  DirectionContext *_localctx = _tracker.createInstance<DirectionContext>(_ctx, getState());
  enterRule(_localctx, 1084, MySQLStatementParser::RuleDirection);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7662);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::ASC || _la == MySQLStatementParser::DESC)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyOrIndexContext ------------------------------------------------------------------

MySQLStatementParser::KeyOrIndexContext::KeyOrIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::KeyOrIndexContext::KEY() {
  return getToken(MySQLStatementParser::KEY, 0);
}

tree::TerminalNode* MySQLStatementParser::KeyOrIndexContext::INDEX() {
  return getToken(MySQLStatementParser::INDEX, 0);
}


size_t MySQLStatementParser::KeyOrIndexContext::getRuleIndex() const {
  return MySQLStatementParser::RuleKeyOrIndex;
}

void MySQLStatementParser::KeyOrIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyOrIndex(this);
}

void MySQLStatementParser::KeyOrIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyOrIndex(this);
}


antlrcpp::Any MySQLStatementParser::KeyOrIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitKeyOrIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::KeyOrIndexContext* MySQLStatementParser::keyOrIndex() {
  KeyOrIndexContext *_localctx = _tracker.createInstance<KeyOrIndexContext>(_ctx, getState());
  enterRule(_localctx, 1086, MySQLStatementParser::RuleKeyOrIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7664);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::INDEX

    || _la == MySQLStatementParser::KEY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldLengthContext ------------------------------------------------------------------

MySQLStatementParser::FieldLengthContext::FieldLengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FieldLengthContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::FieldLengthContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

tree::TerminalNode* MySQLStatementParser::FieldLengthContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::FieldLengthContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFieldLength;
}

void MySQLStatementParser::FieldLengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldLength(this);
}

void MySQLStatementParser::FieldLengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldLength(this);
}


antlrcpp::Any MySQLStatementParser::FieldLengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFieldLength(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FieldLengthContext* MySQLStatementParser::fieldLength() {
  FieldLengthContext *_localctx = _tracker.createInstance<FieldLengthContext>(_ctx, getState());
  enterRule(_localctx, 1088, MySQLStatementParser::RuleFieldLength);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7666);
    match(MySQLStatementParser::LP_);
    setState(7667);
    dynamic_cast<FieldLengthContext *>(_localctx)->length = match(MySQLStatementParser::NUMBER_);
    setState(7668);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterSetContext ------------------------------------------------------------------

MySQLStatementParser::CharacterSetContext::CharacterSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::CharsetContext* MySQLStatementParser::CharacterSetContext::charset() {
  return getRuleContext<MySQLStatementParser::CharsetContext>(0);
}

MySQLStatementParser::CharsetNameContext* MySQLStatementParser::CharacterSetContext::charsetName() {
  return getRuleContext<MySQLStatementParser::CharsetNameContext>(0);
}


size_t MySQLStatementParser::CharacterSetContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCharacterSet;
}

void MySQLStatementParser::CharacterSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacterSet(this);
}

void MySQLStatementParser::CharacterSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacterSet(this);
}


antlrcpp::Any MySQLStatementParser::CharacterSetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCharacterSet(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CharacterSetContext* MySQLStatementParser::characterSet() {
  CharacterSetContext *_localctx = _tracker.createInstance<CharacterSetContext>(_ctx, getState());
  enterRule(_localctx, 1090, MySQLStatementParser::RuleCharacterSet);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7670);
    charset();
    setState(7671);
    charsetName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollateClauseContext ------------------------------------------------------------------

MySQLStatementParser::CollateClauseContext::CollateClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::CollateClauseContext::COLLATE() {
  return getToken(MySQLStatementParser::COLLATE, 0);
}

MySQLStatementParser::CollationNameContext* MySQLStatementParser::CollateClauseContext::collationName() {
  return getRuleContext<MySQLStatementParser::CollationNameContext>(0);
}


size_t MySQLStatementParser::CollateClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCollateClause;
}

void MySQLStatementParser::CollateClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollateClause(this);
}

void MySQLStatementParser::CollateClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollateClause(this);
}


antlrcpp::Any MySQLStatementParser::CollateClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCollateClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CollateClauseContext* MySQLStatementParser::collateClause() {
  CollateClauseContext *_localctx = _tracker.createInstance<CollateClauseContext>(_ctx, getState());
  enterRule(_localctx, 1092, MySQLStatementParser::RuleCollateClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7673);
    match(MySQLStatementParser::COLLATE);
    setState(7674);
    collationName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOrVarSpecContext ------------------------------------------------------------------

MySQLStatementParser::FieldOrVarSpecContext::FieldOrVarSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::FieldOrVarSpecContext::LP_() {
  return getToken(MySQLStatementParser::LP_, 0);
}

tree::TerminalNode* MySQLStatementParser::FieldOrVarSpecContext::RP_() {
  return getToken(MySQLStatementParser::RP_, 0);
}

std::vector<MySQLStatementParser::IdentifierContext *> MySQLStatementParser::FieldOrVarSpecContext::identifier() {
  return getRuleContexts<MySQLStatementParser::IdentifierContext>();
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::FieldOrVarSpecContext::identifier(size_t i) {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::FieldOrVarSpecContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::FieldOrVarSpecContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::FieldOrVarSpecContext::getRuleIndex() const {
  return MySQLStatementParser::RuleFieldOrVarSpec;
}

void MySQLStatementParser::FieldOrVarSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOrVarSpec(this);
}

void MySQLStatementParser::FieldOrVarSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOrVarSpec(this);
}


antlrcpp::Any MySQLStatementParser::FieldOrVarSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitFieldOrVarSpec(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::FieldOrVarSpecContext* MySQLStatementParser::fieldOrVarSpec() {
  FieldOrVarSpecContext *_localctx = _tracker.createInstance<FieldOrVarSpecContext>(_ctx, getState());
  enterRule(_localctx, 1094, MySQLStatementParser::RuleFieldOrVarSpec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7676);
    match(MySQLStatementParser::LP_);
    setState(7685);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLStatementParser::MAX)
      | (1ULL << MySQLStatementParser::MIN)
      | (1ULL << MySQLStatementParser::SUM)
      | (1ULL << MySQLStatementParser::COUNT)
      | (1ULL << MySQLStatementParser::GROUP_CONCAT)
      | (1ULL << MySQLStatementParser::CAST)
      | (1ULL << MySQLStatementParser::POSITION)
      | (1ULL << MySQLStatementParser::SUBSTRING)
      | (1ULL << MySQLStatementParser::SUBSTR)
      | (1ULL << MySQLStatementParser::EXTRACT)
      | (1ULL << MySQLStatementParser::TRIM)
      | (1ULL << MySQLStatementParser::LAST_DAY)
      | (1ULL << MySQLStatementParser::TRADITIONAL)
      | (1ULL << MySQLStatementParser::TREE)
      | (1ULL << MySQLStatementParser::MYSQL_ADMIN)
      | (1ULL << MySQLStatementParser::INSTANT)
      | (1ULL << MySQLStatementParser::INPLACE)
      | (1ULL << MySQLStatementParser::COPY)
      | (1ULL << MySQLStatementParser::UL_BINARY)
      | (1ULL << MySQLStatementParser::AUTOCOMMIT)
      | (1ULL << MySQLStatementParser::INNODB)
      | (1ULL << MySQLStatementParser::REDO_LOG)
      | (1ULL << MySQLStatementParser::ACCOUNT)
      | (1ULL << MySQLStatementParser::ACTION)
      | (1ULL << MySQLStatementParser::ACTIVE)
      | (1ULL << MySQLStatementParser::ADMIN)
      | (1ULL << MySQLStatementParser::AFTER)
      | (1ULL << MySQLStatementParser::AGAINST)
      | (1ULL << MySQLStatementParser::AGGREGATE)
      | (1ULL << MySQLStatementParser::ALGORITHM)
      | (1ULL << MySQLStatementParser::ALWAYS)
      | (1ULL << MySQLStatementParser::ANY)
      | (1ULL << MySQLStatementParser::ASCII)
      | (1ULL << MySQLStatementParser::AT)
      | (1ULL << MySQLStatementParser::ATTRIBUTE)
      | (1ULL << MySQLStatementParser::AUTOEXTEND_SIZE)
      | (1ULL << MySQLStatementParser::AUTO_INCREMENT)
      | (1ULL << MySQLStatementParser::AVG)
      | (1ULL << MySQLStatementParser::AVG_ROW_LENGTH)
      | (1ULL << MySQLStatementParser::BACKUP)
      | (1ULL << MySQLStatementParser::BEGIN)
      | (1ULL << MySQLStatementParser::BINLOG)
      | (1ULL << MySQLStatementParser::BIT)
      | (1ULL << MySQLStatementParser::BLOCK)
      | (1ULL << MySQLStatementParser::BOOL)
      | (1ULL << MySQLStatementParser::BOOLEAN))) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & ((1ULL << (MySQLStatementParser::BTREE - 65))
      | (1ULL << (MySQLStatementParser::BUCKETS - 65))
      | (1ULL << (MySQLStatementParser::BYTE - 65))
      | (1ULL << (MySQLStatementParser::CACHE - 65))
      | (1ULL << (MySQLStatementParser::CASCADED - 65))
      | (1ULL << (MySQLStatementParser::CATALOG_NAME - 65))
      | (1ULL << (MySQLStatementParser::CHAIN - 65))
      | (1ULL << (MySQLStatementParser::CHANGED - 65))
      | (1ULL << (MySQLStatementParser::CHANNEL - 65))
      | (1ULL << (MySQLStatementParser::CHARSET - 65))
      | (1ULL << (MySQLStatementParser::CHECKSUM - 65))
      | (1ULL << (MySQLStatementParser::CIPHER - 65))
      | (1ULL << (MySQLStatementParser::CLASS_ORIGIN - 65))
      | (1ULL << (MySQLStatementParser::CLIENT - 65))
      | (1ULL << (MySQLStatementParser::CLONE - 65))
      | (1ULL << (MySQLStatementParser::CLOSE - 65))
      | (1ULL << (MySQLStatementParser::COALESCE - 65))
      | (1ULL << (MySQLStatementParser::CODE - 65))
      | (1ULL << (MySQLStatementParser::COLLATION - 65))
      | (1ULL << (MySQLStatementParser::COLUMNS - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_FORMAT - 65))
      | (1ULL << (MySQLStatementParser::COLUMN_NAME - 65))
      | (1ULL << (MySQLStatementParser::COMMENT - 65))
      | (1ULL << (MySQLStatementParser::COMMIT - 65))
      | (1ULL << (MySQLStatementParser::COMMITTED - 65))
      | (1ULL << (MySQLStatementParser::COMPACT - 65))
      | (1ULL << (MySQLStatementParser::COMPLETION - 65))
      | (1ULL << (MySQLStatementParser::COMPONENT - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSED - 65))
      | (1ULL << (MySQLStatementParser::COMPRESSION - 65))
      | (1ULL << (MySQLStatementParser::CONCURRENT - 65))
      | (1ULL << (MySQLStatementParser::CONNECTION - 65))
      | (1ULL << (MySQLStatementParser::CONSISTENT - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_CATALOG - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_NAME - 65))
      | (1ULL << (MySQLStatementParser::CONSTRAINT_SCHEMA - 65))
      | (1ULL << (MySQLStatementParser::CONTAINS - 65))
      | (1ULL << (MySQLStatementParser::CONTEXT - 65))
      | (1ULL << (MySQLStatementParser::CPU - 65))
      | (1ULL << (MySQLStatementParser::CURRENT - 65))
      | (1ULL << (MySQLStatementParser::CURSOR_NAME - 65)))) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & ((1ULL << (MySQLStatementParser::DATA - 129))
      | (1ULL << (MySQLStatementParser::DATAFILE - 129))
      | (1ULL << (MySQLStatementParser::DATE - 129))
      | (1ULL << (MySQLStatementParser::DATETIME - 129))
      | (1ULL << (MySQLStatementParser::DAY - 129))
      | (1ULL << (MySQLStatementParser::DEALLOCATE - 129))
      | (1ULL << (MySQLStatementParser::DEFAULT_AUTH - 129))
      | (1ULL << (MySQLStatementParser::DEFINER - 129))
      | (1ULL << (MySQLStatementParser::DEFINITION - 129))
      | (1ULL << (MySQLStatementParser::DELAY_KEY_WRITE - 129))
      | (1ULL << (MySQLStatementParser::DESCRIPTION - 129))
      | (1ULL << (MySQLStatementParser::DIAGNOSTICS - 129))
      | (1ULL << (MySQLStatementParser::DIRECTORY - 129))
      | (1ULL << (MySQLStatementParser::DISABLE - 129))
      | (1ULL << (MySQLStatementParser::DISCARD - 129))
      | (1ULL << (MySQLStatementParser::DISK - 129))
      | (1ULL << (MySQLStatementParser::DO - 129))
      | (1ULL << (MySQLStatementParser::DUMPFILE - 129))
      | (1ULL << (MySQLStatementParser::DUPLICATE - 129))
      | (1ULL << (MySQLStatementParser::DYNAMIC - 129))
      | (1ULL << (MySQLStatementParser::ENABLE - 129))
      | (1ULL << (MySQLStatementParser::ENCRYPTION - 129))
      | (1ULL << (MySQLStatementParser::END - 129))
      | (1ULL << (MySQLStatementParser::ENDS - 129))
      | (1ULL << (MySQLStatementParser::ENFORCED - 129))
      | (1ULL << (MySQLStatementParser::ENGINE - 129))
      | (1ULL << (MySQLStatementParser::ENGINES - 129))
      | (1ULL << (MySQLStatementParser::ENGINE_ATTRIBUTE - 129))
      | (1ULL << (MySQLStatementParser::ENUM - 129))
      | (1ULL << (MySQLStatementParser::ERROR - 129))
      | (1ULL << (MySQLStatementParser::ERRORS - 129))
      | (1ULL << (MySQLStatementParser::ESCAPE - 129))
      | (1ULL << (MySQLStatementParser::EVENT - 129))
      | (1ULL << (MySQLStatementParser::EVENTS - 129))
      | (1ULL << (MySQLStatementParser::EVERY - 129)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & ((1ULL << (MySQLStatementParser::EXCHANGE - 193))
      | (1ULL << (MySQLStatementParser::EXCLUDE - 193))
      | (1ULL << (MySQLStatementParser::EXECUTE - 193))
      | (1ULL << (MySQLStatementParser::EXPANSION - 193))
      | (1ULL << (MySQLStatementParser::EXPIRE - 193))
      | (1ULL << (MySQLStatementParser::EXPORT - 193))
      | (1ULL << (MySQLStatementParser::EXTENDED - 193))
      | (1ULL << (MySQLStatementParser::EXTENT_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FAILED_LOGIN_ATTEMPTS - 193))
      | (1ULL << (MySQLStatementParser::FAST - 193))
      | (1ULL << (MySQLStatementParser::FAULTS - 193))
      | (1ULL << (MySQLStatementParser::FIELDS - 193))
      | (1ULL << (MySQLStatementParser::FILE - 193))
      | (1ULL << (MySQLStatementParser::FILE_BLOCK_SIZE - 193))
      | (1ULL << (MySQLStatementParser::FILTER - 193))
      | (1ULL << (MySQLStatementParser::FIRST - 193))
      | (1ULL << (MySQLStatementParser::FIXED - 193))
      | (1ULL << (MySQLStatementParser::FLUSH - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWING - 193))
      | (1ULL << (MySQLStatementParser::FOLLOWS - 193))
      | (1ULL << (MySQLStatementParser::FORMAT - 193))
      | (1ULL << (MySQLStatementParser::FULL - 193))
      | (1ULL << (MySQLStatementParser::GENERAL - 193))
      | (1ULL << (MySQLStatementParser::GEOMCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRY - 193))
      | (1ULL << (MySQLStatementParser::GEOMETRYCOLLECTION - 193))
      | (1ULL << (MySQLStatementParser::GET_FORMAT - 193))
      | (1ULL << (MySQLStatementParser::GET_MASTER_PUBLIC_KEY - 193))
      | (1ULL << (MySQLStatementParser::GLOBAL - 193))
      | (1ULL << (MySQLStatementParser::GRANTS - 193))
      | (1ULL << (MySQLStatementParser::GROUP_REPLICATION - 193))
      | (1ULL << (MySQLStatementParser::HANDLER - 193))
      | (1ULL << (MySQLStatementParser::HASH - 193))
      | (1ULL << (MySQLStatementParser::HELP - 193))
      | (1ULL << (MySQLStatementParser::HISTOGRAM - 193))
      | (1ULL << (MySQLStatementParser::HISTORY - 193))
      | (1ULL << (MySQLStatementParser::HOST - 193))
      | (1ULL << (MySQLStatementParser::HOSTS - 193))
      | (1ULL << (MySQLStatementParser::HOUR - 193)))) != 0) || ((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & ((1ULL << (MySQLStatementParser::IDENTIFIED - 259))
      | (1ULL << (MySQLStatementParser::IGNORE_SERVER_IDS - 259))
      | (1ULL << (MySQLStatementParser::IMPORT - 259))
      | (1ULL << (MySQLStatementParser::INACTIVE - 259))
      | (1ULL << (MySQLStatementParser::INDEXES - 259))
      | (1ULL << (MySQLStatementParser::INITIAL_SIZE - 259))
      | (1ULL << (MySQLStatementParser::INSERT_METHOD - 259))
      | (1ULL << (MySQLStatementParser::INSTALL - 259))
      | (1ULL << (MySQLStatementParser::INSTANCE - 259))
      | (1ULL << (MySQLStatementParser::INVISIBLE - 259))
      | (1ULL << (MySQLStatementParser::INVOKER - 259))
      | (1ULL << (MySQLStatementParser::IO - 259))
      | (1ULL << (MySQLStatementParser::IO_THREAD - 259))
      | (1ULL << (MySQLStatementParser::IPC - 259))
      | (1ULL << (MySQLStatementParser::ISOLATION - 259))
      | (1ULL << (MySQLStatementParser::ISSUER - 259))
      | (1ULL << (MySQLStatementParser::JSON - 259))
      | (1ULL << (MySQLStatementParser::JSON_VALUE - 259))
      | (1ULL << (MySQLStatementParser::KEY_BLOCK_SIZE - 259))
      | (1ULL << (MySQLStatementParser::LANGUAGE - 259))
      | (1ULL << (MySQLStatementParser::LAST - 259))
      | (1ULL << (MySQLStatementParser::LEAVES - 259))
      | (1ULL << (MySQLStatementParser::LESS - 259))
      | (1ULL << (MySQLStatementParser::LEVEL - 259))
      | (1ULL << (MySQLStatementParser::LINESTRING - 259))
      | (1ULL << (MySQLStatementParser::LIST - 259)))) != 0) || ((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & ((1ULL << (MySQLStatementParser::LOCAL - 324))
      | (1ULL << (MySQLStatementParser::LOCKED - 324))
      | (1ULL << (MySQLStatementParser::LOCKS - 324))
      | (1ULL << (MySQLStatementParser::LOGFILE - 324))
      | (1ULL << (MySQLStatementParser::LOGS - 324))
      | (1ULL << (MySQLStatementParser::MANAGED - 324))
      | (1ULL << (MySQLStatementParser::MASTER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_AUTO_POSITION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_COMPRESSION_ALGORITHMS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_CONNECT_RETRY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_DELAY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HEARTBEAT_PERIOD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_HOST - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_FILE - 324))
      | (1ULL << (MySQLStatementParser::MASTER_LOG_POS - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PASSWORD - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PORT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_PUBLIC_KEY_PATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_RETRY_COUNT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SERVER_ID - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CA - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CAPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CERT - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CIPHER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRL - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_CRLPATH - 324))
      | (1ULL << (MySQLStatementParser::MASTER_SSL_KEY - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_CIPHERSUITES - 324))
      | (1ULL << (MySQLStatementParser::MASTER_TLS_VERSION - 324))
      | (1ULL << (MySQLStatementParser::MASTER_USER - 324))
      | (1ULL << (MySQLStatementParser::MASTER_ZSTD_COMPRESSION_LEVEL - 324))
      | (1ULL << (MySQLStatementParser::MAX_CONNECTIONS_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_QUERIES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_ROWS - 324))
      | (1ULL << (MySQLStatementParser::MAX_SIZE - 324))
      | (1ULL << (MySQLStatementParser::MAX_UPDATES_PER_HOUR - 324))
      | (1ULL << (MySQLStatementParser::MAX_USER_CONNECTIONS - 324))
      | (1ULL << (MySQLStatementParser::MEDIUM - 324))
      | (1ULL << (MySQLStatementParser::MEMBER - 324))
      | (1ULL << (MySQLStatementParser::MEMORY - 324))
      | (1ULL << (MySQLStatementParser::MERGE - 324))
      | (1ULL << (MySQLStatementParser::MESSAGE_TEXT - 324))
      | (1ULL << (MySQLStatementParser::MICROSECOND - 324))
      | (1ULL << (MySQLStatementParser::MIGRATE - 324))
      | (1ULL << (MySQLStatementParser::MINUTE - 324)))) != 0) || ((((_la - 388) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 388)) & ((1ULL << (MySQLStatementParser::MIN_ROWS - 388))
      | (1ULL << (MySQLStatementParser::MODE - 388))
      | (1ULL << (MySQLStatementParser::MODIFY - 388))
      | (1ULL << (MySQLStatementParser::MONTH - 388))
      | (1ULL << (MySQLStatementParser::MULTILINESTRING - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOINT - 388))
      | (1ULL << (MySQLStatementParser::MULTIPOLYGON - 388))
      | (1ULL << (MySQLStatementParser::MUTEX - 388))
      | (1ULL << (MySQLStatementParser::MYSQL_ERRNO - 388))
      | (1ULL << (MySQLStatementParser::NAME - 388))
      | (1ULL << (MySQLStatementParser::NAMES - 388))
      | (1ULL << (MySQLStatementParser::NATIONAL - 388))
      | (1ULL << (MySQLStatementParser::NCHAR - 388))
      | (1ULL << (MySQLStatementParser::NDB - 388))
      | (1ULL << (MySQLStatementParser::NDBCLUSTER - 388))
      | (1ULL << (MySQLStatementParser::NESTED - 388))
      | (1ULL << (MySQLStatementParser::NETWORK_NAMESPACE - 388))
      | (1ULL << (MySQLStatementParser::NEVER - 388))
      | (1ULL << (MySQLStatementParser::NEW - 388))
      | (1ULL << (MySQLStatementParser::NEXT - 388))
      | (1ULL << (MySQLStatementParser::NO - 388))
      | (1ULL << (MySQLStatementParser::NODEGROUP - 388))
      | (1ULL << (MySQLStatementParser::NONE - 388))
      | (1ULL << (MySQLStatementParser::NOWAIT - 388))
      | (1ULL << (MySQLStatementParser::NO_WAIT - 388))
      | (1ULL << (MySQLStatementParser::NULLS - 388))
      | (1ULL << (MySQLStatementParser::NUMBER - 388))
      | (1ULL << (MySQLStatementParser::NVARCHAR - 388))
      | (1ULL << (MySQLStatementParser::OFF - 388))
      | (1ULL << (MySQLStatementParser::OFFSET - 388))
      | (1ULL << (MySQLStatementParser::OJ - 388))
      | (1ULL << (MySQLStatementParser::OLD - 388))
      | (1ULL << (MySQLStatementParser::ONE - 388))
      | (1ULL << (MySQLStatementParser::ONLY - 388))
      | (1ULL << (MySQLStatementParser::OPEN - 388))
      | (1ULL << (MySQLStatementParser::OPTIONAL - 388))
      | (1ULL << (MySQLStatementParser::OPTIONS - 388))
      | (1ULL << (MySQLStatementParser::ORDINALITY - 388))
      | (1ULL << (MySQLStatementParser::OTHERS - 388))
      | (1ULL << (MySQLStatementParser::OWNER - 388))
      | (1ULL << (MySQLStatementParser::PACK_KEYS - 388))
      | (1ULL << (MySQLStatementParser::PAGE - 388)))) != 0) || ((((_la - 452) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 452)) & ((1ULL << (MySQLStatementParser::PARSER - 452))
      | (1ULL << (MySQLStatementParser::PARTIAL - 452))
      | (1ULL << (MySQLStatementParser::PARTITIONING - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD - 452))
      | (1ULL << (MySQLStatementParser::PASSWORD_LOCK_TIME - 452))
      | (1ULL << (MySQLStatementParser::PATH - 452))
      | (1ULL << (MySQLStatementParser::PERSIST - 452))
      | (1ULL << (MySQLStatementParser::PERSIST_ONLY - 452))
      | (1ULL << (MySQLStatementParser::PHASE - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN - 452))
      | (1ULL << (MySQLStatementParser::PLUGINS - 452))
      | (1ULL << (MySQLStatementParser::PLUGIN_DIR - 452))
      | (1ULL << (MySQLStatementParser::POINT - 452))
      | (1ULL << (MySQLStatementParser::POLYGON - 452))
      | (1ULL << (MySQLStatementParser::PORT - 452))
      | (1ULL << (MySQLStatementParser::PRECEDES - 452))
      | (1ULL << (MySQLStatementParser::PRECEDING - 452))
      | (1ULL << (MySQLStatementParser::PREPARE - 452))
      | (1ULL << (MySQLStatementParser::PRESERVE - 452))
      | (1ULL << (MySQLStatementParser::PREV - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGES - 452))
      | (1ULL << (MySQLStatementParser::PRIVILEGE_CHECKS_USER - 452))
      | (1ULL << (MySQLStatementParser::PROCESS - 452))
      | (1ULL << (MySQLStatementParser::PROCESSLIST - 452))
      | (1ULL << (MySQLStatementParser::PROFILE - 452))
      | (1ULL << (MySQLStatementParser::PROFILES - 452))
      | (1ULL << (MySQLStatementParser::PROXY - 452))
      | (1ULL << (MySQLStatementParser::QUARTER - 452))
      | (1ULL << (MySQLStatementParser::QUERY - 452))
      | (1ULL << (MySQLStatementParser::QUICK - 452))
      | (1ULL << (MySQLStatementParser::RANDOM - 452))
      | (1ULL << (MySQLStatementParser::READ_ONLY - 452))
      | (1ULL << (MySQLStatementParser::REBUILD - 452))
      | (1ULL << (MySQLStatementParser::RECOVER - 452))
      | (1ULL << (MySQLStatementParser::REDO_BUFFER_SIZE - 452))
      | (1ULL << (MySQLStatementParser::REDUNDANT - 452))
      | (1ULL << (MySQLStatementParser::REFERENCE - 452))
      | (1ULL << (MySQLStatementParser::RELAY - 452))
      | (1ULL << (MySQLStatementParser::RELAYLOG - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_FILE - 452))
      | (1ULL << (MySQLStatementParser::RELAY_LOG_POS - 452))
      | (1ULL << (MySQLStatementParser::RELAY_THREAD - 452))
      | (1ULL << (MySQLStatementParser::RELOAD - 452))
      | (1ULL << (MySQLStatementParser::REMOVE - 452))
      | (1ULL << (MySQLStatementParser::REORGANIZE - 452))
      | (1ULL << (MySQLStatementParser::REPAIR - 452)))) != 0) || ((((_la - 517) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 517)) & ((1ULL << (MySQLStatementParser::REPEATABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_REWRITE_DB - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_DO_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATE_WILD_IGNORE_TABLE - 517))
      | (1ULL << (MySQLStatementParser::REPLICATION - 517))
      | (1ULL << (MySQLStatementParser::REQUIRE_ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RESET - 517))
      | (1ULL << (MySQLStatementParser::RESOURCE - 517))
      | (1ULL << (MySQLStatementParser::RESPECT - 517))
      | (1ULL << (MySQLStatementParser::RESTART - 517))
      | (1ULL << (MySQLStatementParser::RESTORE - 517))
      | (1ULL << (MySQLStatementParser::RESUME - 517))
      | (1ULL << (MySQLStatementParser::RETAIN - 517))
      | (1ULL << (MySQLStatementParser::RETURNED_SQLSTATE - 517))
      | (1ULL << (MySQLStatementParser::RETURNING - 517))
      | (1ULL << (MySQLStatementParser::RETURNS - 517))
      | (1ULL << (MySQLStatementParser::REUSE - 517))
      | (1ULL << (MySQLStatementParser::REVERSE - 517))
      | (1ULL << (MySQLStatementParser::ROLE - 517))
      | (1ULL << (MySQLStatementParser::ROLLBACK - 517))
      | (1ULL << (MySQLStatementParser::ROLLUP - 517))
      | (1ULL << (MySQLStatementParser::ROTATE - 517))
      | (1ULL << (MySQLStatementParser::ROUTINE - 517))
      | (1ULL << (MySQLStatementParser::ROW_COUNT - 517))
      | (1ULL << (MySQLStatementParser::ROW_FORMAT - 517))
      | (1ULL << (MySQLStatementParser::RTREE - 517))
      | (1ULL << (MySQLStatementParser::SAVEPOINT - 517))
      | (1ULL << (MySQLStatementParser::SCHEDULE - 517))
      | (1ULL << (MySQLStatementParser::SCHEMA_NAME - 517))
      | (1ULL << (MySQLStatementParser::SECOND - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_ENGINE_ATTRIBUTE - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_LOAD - 517))
      | (1ULL << (MySQLStatementParser::SECONDARY_UNLOAD - 517))
      | (1ULL << (MySQLStatementParser::SECURITY - 517))
      | (1ULL << (MySQLStatementParser::SERIAL - 517))
      | (1ULL << (MySQLStatementParser::SERIALIZABLE - 517))
      | (1ULL << (MySQLStatementParser::SERVER - 517))
      | (1ULL << (MySQLStatementParser::SESSION - 517))
      | (1ULL << (MySQLStatementParser::SHARE - 517)))) != 0) || ((((_la - 581) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 581)) & ((1ULL << (MySQLStatementParser::SHUTDOWN - 581))
      | (1ULL << (MySQLStatementParser::SIGNED - 581))
      | (1ULL << (MySQLStatementParser::SIMPLE - 581))
      | (1ULL << (MySQLStatementParser::SLAVE - 581))
      | (1ULL << (MySQLStatementParser::SLOW - 581))
      | (1ULL << (MySQLStatementParser::SNAPSHOT - 581))
      | (1ULL << (MySQLStatementParser::SOCKET - 581))
      | (1ULL << (MySQLStatementParser::SOME - 581))
      | (1ULL << (MySQLStatementParser::SONAME - 581))
      | (1ULL << (MySQLStatementParser::SOUNDS - 581))
      | (1ULL << (MySQLStatementParser::SOURCE - 581))
      | (1ULL << (MySQLStatementParser::SQL_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_AFTER_MTS_GAPS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BEFORE_GTIDS - 581))
      | (1ULL << (MySQLStatementParser::SQL_BUFFER_RESULT - 581))
      | (1ULL << (MySQLStatementParser::SQL_NO_CACHE - 581))
      | (1ULL << (MySQLStatementParser::SQL_THREAD - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_DAY - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_HOUR - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MINUTE - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_MONTH - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_QUARTER - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_SECOND - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_WEEK - 581))
      | (1ULL << (MySQLStatementParser::SQL_TSI_YEAR - 581))
      | (1ULL << (MySQLStatementParser::SRID - 581))
      | (1ULL << (MySQLStatementParser::STACKED - 581))
      | (1ULL << (MySQLStatementParser::START - 581))
      | (1ULL << (MySQLStatementParser::STARTS - 581))
      | (1ULL << (MySQLStatementParser::STATS_AUTO_RECALC - 581))
      | (1ULL << (MySQLStatementParser::STATS_PERSISTENT - 581))
      | (1ULL << (MySQLStatementParser::STATS_SAMPLE_PAGES - 581))
      | (1ULL << (MySQLStatementParser::STATUS - 581))
      | (1ULL << (MySQLStatementParser::STOP - 581))
      | (1ULL << (MySQLStatementParser::STORAGE - 581))
      | (1ULL << (MySQLStatementParser::STREAM - 581))
      | (1ULL << (MySQLStatementParser::STRING - 581))
      | (1ULL << (MySQLStatementParser::SUBCLASS_ORIGIN - 581))
      | (1ULL << (MySQLStatementParser::SUBJECT - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITION - 581))
      | (1ULL << (MySQLStatementParser::SUBPARTITIONS - 581))
      | (1ULL << (MySQLStatementParser::SUPER - 581))
      | (1ULL << (MySQLStatementParser::SUSPEND - 581))
      | (1ULL << (MySQLStatementParser::SWAPS - 581))
      | (1ULL << (MySQLStatementParser::SWITCHES - 581)))) != 0) || ((((_la - 645) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 645)) & ((1ULL << (MySQLStatementParser::TABLES - 645))
      | (1ULL << (MySQLStatementParser::TABLESPACE - 645))
      | (1ULL << (MySQLStatementParser::TABLE_CHECKSUM - 645))
      | (1ULL << (MySQLStatementParser::TABLE_NAME - 645))
      | (1ULL << (MySQLStatementParser::TEMPORARY - 645))
      | (1ULL << (MySQLStatementParser::TEMPTABLE - 645))
      | (1ULL << (MySQLStatementParser::TEXT - 645))
      | (1ULL << (MySQLStatementParser::THAN - 645))
      | (1ULL << (MySQLStatementParser::THREAD_PRIORITY - 645))
      | (1ULL << (MySQLStatementParser::TIES - 645))
      | (1ULL << (MySQLStatementParser::TIME - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMP - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPADD - 645))
      | (1ULL << (MySQLStatementParser::TIMESTAMPDIFF - 645))
      | (1ULL << (MySQLStatementParser::TLS - 645))
      | (1ULL << (MySQLStatementParser::TRANSACTION - 645))
      | (1ULL << (MySQLStatementParser::TRIGGERS - 645))
      | (1ULL << (MySQLStatementParser::TRUNCATE - 645))
      | (1ULL << (MySQLStatementParser::TYPE - 645))
      | (1ULL << (MySQLStatementParser::TYPES - 645))
      | (1ULL << (MySQLStatementParser::UNBOUNDED - 645))
      | (1ULL << (MySQLStatementParser::UNCOMMITTED - 645))
      | (1ULL << (MySQLStatementParser::UNDEFINED - 645))
      | (1ULL << (MySQLStatementParser::UNDOFILE - 645))
      | (1ULL << (MySQLStatementParser::UNDO_BUFFER_SIZE - 645))
      | (1ULL << (MySQLStatementParser::UNICODE - 645))
      | (1ULL << (MySQLStatementParser::UNINSTALL - 645))
      | (1ULL << (MySQLStatementParser::UNKNOWN - 645))
      | (1ULL << (MySQLStatementParser::UNTIL - 645))
      | (1ULL << (MySQLStatementParser::UPGRADE - 645))
      | (1ULL << (MySQLStatementParser::USER - 645))
      | (1ULL << (MySQLStatementParser::USER_RESOURCES - 645))
      | (1ULL << (MySQLStatementParser::USE_FRM - 645))
      | (1ULL << (MySQLStatementParser::VALIDATION - 645))
      | (1ULL << (MySQLStatementParser::VALUE - 645))
      | (1ULL << (MySQLStatementParser::VARIABLES - 645))
      | (1ULL << (MySQLStatementParser::VCPU - 645))
      | (1ULL << (MySQLStatementParser::VIEW - 645)))) != 0) || ((((_la - 710) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 710)) & ((1ULL << (MySQLStatementParser::VISIBLE - 710))
      | (1ULL << (MySQLStatementParser::WAIT - 710))
      | (1ULL << (MySQLStatementParser::WARNINGS - 710))
      | (1ULL << (MySQLStatementParser::WEEK - 710))
      | (1ULL << (MySQLStatementParser::WEIGHT_STRING - 710))
      | (1ULL << (MySQLStatementParser::WITHOUT - 710))
      | (1ULL << (MySQLStatementParser::WORK - 710))
      | (1ULL << (MySQLStatementParser::WRAPPER - 710))
      | (1ULL << (MySQLStatementParser::X509 - 710))
      | (1ULL << (MySQLStatementParser::XA - 710))
      | (1ULL << (MySQLStatementParser::XID - 710))
      | (1ULL << (MySQLStatementParser::XML - 710))
      | (1ULL << (MySQLStatementParser::YEAR - 710)))) != 0) || _la == MySQLStatementParser::IDENTIFIER_

    || _la == MySQLStatementParser::DOUBLE_QUOTED_TEXT) {
      setState(7677);
      identifier();
      setState(7682);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLStatementParser::COMMA_) {
        setState(7678);
        match(MySQLStatementParser::COMMA_);
        setState(7679);
        identifier();
        setState(7684);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(7687);
    match(MySQLStatementParser::RP_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotExistClauseContext ------------------------------------------------------------------

MySQLStatementParser::NotExistClauseContext::NotExistClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NotExistClauseContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::NotExistClauseContext::NOT() {
  return getToken(MySQLStatementParser::NOT, 0);
}

tree::TerminalNode* MySQLStatementParser::NotExistClauseContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}


size_t MySQLStatementParser::NotExistClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNotExistClause;
}

void MySQLStatementParser::NotExistClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotExistClause(this);
}

void MySQLStatementParser::NotExistClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotExistClause(this);
}


antlrcpp::Any MySQLStatementParser::NotExistClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNotExistClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NotExistClauseContext* MySQLStatementParser::notExistClause() {
  NotExistClauseContext *_localctx = _tracker.createInstance<NotExistClauseContext>(_ctx, getState());
  enterRule(_localctx, 1096, MySQLStatementParser::RuleNotExistClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7689);
    match(MySQLStatementParser::IF);
    setState(7690);
    match(MySQLStatementParser::NOT);
    setState(7691);
    match(MySQLStatementParser::EXISTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExistClauseContext ------------------------------------------------------------------

MySQLStatementParser::ExistClauseContext::ExistClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ExistClauseContext::IF() {
  return getToken(MySQLStatementParser::IF, 0);
}

tree::TerminalNode* MySQLStatementParser::ExistClauseContext::EXISTS() {
  return getToken(MySQLStatementParser::EXISTS, 0);
}


size_t MySQLStatementParser::ExistClauseContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExistClause;
}

void MySQLStatementParser::ExistClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExistClause(this);
}

void MySQLStatementParser::ExistClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExistClause(this);
}


antlrcpp::Any MySQLStatementParser::ExistClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExistClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExistClauseContext* MySQLStatementParser::existClause() {
  ExistClauseContext *_localctx = _tracker.createInstance<ExistClauseContext>(_ctx, getState());
  enterRule(_localctx, 1098, MySQLStatementParser::RuleExistClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7693);
    match(MySQLStatementParser::IF);
    setState(7694);
    match(MySQLStatementParser::EXISTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectionIdContext ------------------------------------------------------------------

MySQLStatementParser::ConnectionIdContext::ConnectionIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ConnectionIdContext::NUMBER_() {
  return getToken(MySQLStatementParser::NUMBER_, 0);
}


size_t MySQLStatementParser::ConnectionIdContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConnectionId;
}

void MySQLStatementParser::ConnectionIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnectionId(this);
}

void MySQLStatementParser::ConnectionIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnectionId(this);
}


antlrcpp::Any MySQLStatementParser::ConnectionIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConnectionId(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConnectionIdContext* MySQLStatementParser::connectionId() {
  ConnectionIdContext *_localctx = _tracker.createInstance<ConnectionIdContext>(_ctx, getState());
  enterRule(_localctx, 1100, MySQLStatementParser::RuleConnectionId);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7696);
    match(MySQLStatementParser::NUMBER_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelNameContext ------------------------------------------------------------------

MySQLStatementParser::LabelNameContext::LabelNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::LabelNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::LabelNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleLabelName;
}

void MySQLStatementParser::LabelNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelName(this);
}

void MySQLStatementParser::LabelNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelName(this);
}


antlrcpp::Any MySQLStatementParser::LabelNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitLabelName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::LabelNameContext* MySQLStatementParser::labelName() {
  LabelNameContext *_localctx = _tracker.createInstance<LabelNameContext>(_ctx, getState());
  enterRule(_localctx, 1102, MySQLStatementParser::RuleLabelName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7698);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorNameContext ------------------------------------------------------------------

MySQLStatementParser::CursorNameContext::CursorNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::CursorNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::CursorNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleCursorName;
}

void MySQLStatementParser::CursorNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorName(this);
}

void MySQLStatementParser::CursorNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorName(this);
}


antlrcpp::Any MySQLStatementParser::CursorNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitCursorName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::CursorNameContext* MySQLStatementParser::cursorName() {
  CursorNameContext *_localctx = _tracker.createInstance<CursorNameContext>(_ctx, getState());
  enterRule(_localctx, 1104, MySQLStatementParser::RuleCursorName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7700);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionNameContext ------------------------------------------------------------------

MySQLStatementParser::ConditionNameContext::ConditionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ConditionNameContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}


size_t MySQLStatementParser::ConditionNameContext::getRuleIndex() const {
  return MySQLStatementParser::RuleConditionName;
}

void MySQLStatementParser::ConditionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionName(this);
}

void MySQLStatementParser::ConditionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionName(this);
}


antlrcpp::Any MySQLStatementParser::ConditionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitConditionName(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ConditionNameContext* MySQLStatementParser::conditionName() {
  ConditionNameContext *_localctx = _tracker.createInstance<ConditionNameContext>(_ctx, getState());
  enterRule(_localctx, 1106, MySQLStatementParser::RuleConditionName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7702);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionOptionContext ------------------------------------------------------------------

MySQLStatementParser::UnionOptionContext::UnionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::UnionOptionContext::ALL() {
  return getToken(MySQLStatementParser::ALL, 0);
}

tree::TerminalNode* MySQLStatementParser::UnionOptionContext::DISTINCT() {
  return getToken(MySQLStatementParser::DISTINCT, 0);
}


size_t MySQLStatementParser::UnionOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleUnionOption;
}

void MySQLStatementParser::UnionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionOption(this);
}

void MySQLStatementParser::UnionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionOption(this);
}


antlrcpp::Any MySQLStatementParser::UnionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitUnionOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::UnionOptionContext* MySQLStatementParser::unionOption() {
  UnionOptionContext *_localctx = _tracker.createInstance<UnionOptionContext>(_ctx, getState());
  enterRule(_localctx, 1108, MySQLStatementParser::RuleUnionOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7704);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::ALL || _la == MySQLStatementParser::DISTINCT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoWriteToBinLogContext ------------------------------------------------------------------

MySQLStatementParser::NoWriteToBinLogContext::NoWriteToBinLogContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::NoWriteToBinLogContext::LOCAL() {
  return getToken(MySQLStatementParser::LOCAL, 0);
}

tree::TerminalNode* MySQLStatementParser::NoWriteToBinLogContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySQLStatementParser::NO_WRITE_TO_BINLOG, 0);
}


size_t MySQLStatementParser::NoWriteToBinLogContext::getRuleIndex() const {
  return MySQLStatementParser::RuleNoWriteToBinLog;
}

void MySQLStatementParser::NoWriteToBinLogContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoWriteToBinLog(this);
}

void MySQLStatementParser::NoWriteToBinLogContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoWriteToBinLog(this);
}


antlrcpp::Any MySQLStatementParser::NoWriteToBinLogContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitNoWriteToBinLog(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::NoWriteToBinLogContext* MySQLStatementParser::noWriteToBinLog() {
  NoWriteToBinLogContext *_localctx = _tracker.createInstance<NoWriteToBinLogContext>(_ctx, getState());
  enterRule(_localctx, 1110, MySQLStatementParser::RuleNoWriteToBinLog);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7706);
    _la = _input->LA(1);
    if (!(_la == MySQLStatementParser::LOCAL || _la == MySQLStatementParser::NO_WRITE_TO_BINLOG)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelOptionContext ------------------------------------------------------------------

MySQLStatementParser::ChannelOptionContext::ChannelOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ChannelOptionContext::FOR() {
  return getToken(MySQLStatementParser::FOR, 0);
}

tree::TerminalNode* MySQLStatementParser::ChannelOptionContext::CHANNEL() {
  return getToken(MySQLStatementParser::CHANNEL, 0);
}

MySQLStatementParser::String_Context* MySQLStatementParser::ChannelOptionContext::string_() {
  return getRuleContext<MySQLStatementParser::String_Context>(0);
}


size_t MySQLStatementParser::ChannelOptionContext::getRuleIndex() const {
  return MySQLStatementParser::RuleChannelOption;
}

void MySQLStatementParser::ChannelOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannelOption(this);
}

void MySQLStatementParser::ChannelOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannelOption(this);
}


antlrcpp::Any MySQLStatementParser::ChannelOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitChannelOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ChannelOptionContext* MySQLStatementParser::channelOption() {
  ChannelOptionContext *_localctx = _tracker.createInstance<ChannelOptionContext>(_ctx, getState());
  enterRule(_localctx, 1112, MySQLStatementParser::RuleChannelOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7708);
    match(MySQLStatementParser::FOR);
    setState(7709);
    match(MySQLStatementParser::CHANNEL);
    setState(7710);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreparedStatementContext ------------------------------------------------------------------

MySQLStatementParser::PreparedStatementContext::PreparedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::PreparedStatementContext::PREPARE() {
  return getToken(MySQLStatementParser::PREPARE, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::PreparedStatementContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PreparedStatementContext::FROM() {
  return getToken(MySQLStatementParser::FROM, 0);
}

MySQLStatementParser::StringLiteralsContext* MySQLStatementParser::PreparedStatementContext::stringLiterals() {
  return getRuleContext<MySQLStatementParser::StringLiteralsContext>(0);
}

MySQLStatementParser::UserVariableContext* MySQLStatementParser::PreparedStatementContext::userVariable() {
  return getRuleContext<MySQLStatementParser::UserVariableContext>(0);
}

MySQLStatementParser::ExecuteStatementContext* MySQLStatementParser::PreparedStatementContext::executeStatement() {
  return getRuleContext<MySQLStatementParser::ExecuteStatementContext>(0);
}

tree::TerminalNode* MySQLStatementParser::PreparedStatementContext::DEALLOCATE() {
  return getToken(MySQLStatementParser::DEALLOCATE, 0);
}

tree::TerminalNode* MySQLStatementParser::PreparedStatementContext::DROP() {
  return getToken(MySQLStatementParser::DROP, 0);
}


size_t MySQLStatementParser::PreparedStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RulePreparedStatement;
}

void MySQLStatementParser::PreparedStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreparedStatement(this);
}

void MySQLStatementParser::PreparedStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreparedStatement(this);
}


antlrcpp::Any MySQLStatementParser::PreparedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitPreparedStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::PreparedStatementContext* MySQLStatementParser::preparedStatement() {
  PreparedStatementContext *_localctx = _tracker.createInstance<PreparedStatementContext>(_ctx, getState());
  enterRule(_localctx, 1114, MySQLStatementParser::RulePreparedStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7723);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLStatementParser::PREPARE: {
        enterOuterAlt(_localctx, 1);
        setState(7712);
        match(MySQLStatementParser::PREPARE);
        setState(7713);
        identifier();
        setState(7714);
        match(MySQLStatementParser::FROM);
        setState(7717);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLStatementParser::SINGLE_QUOTED_TEXT:
          case MySQLStatementParser::DOUBLE_QUOTED_TEXT:
          case MySQLStatementParser::NCHAR_TEXT:
          case MySQLStatementParser::UNDERSCORE_CHARSET: {
            setState(7715);
            stringLiterals();
            break;
          }

          case MySQLStatementParser::AT_: {
            setState(7716);
            userVariable();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySQLStatementParser::EXECUTE: {
        enterOuterAlt(_localctx, 2);
        setState(7719);
        executeStatement();
        break;
      }

      case MySQLStatementParser::DEALLOCATE:
      case MySQLStatementParser::DROP: {
        enterOuterAlt(_localctx, 3);
        setState(7720);
        _la = _input->LA(1);
        if (!(_la == MySQLStatementParser::DEALLOCATE

        || _la == MySQLStatementParser::DROP)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7721);
        match(MySQLStatementParser::PREPARE);
        setState(7722);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteStatementContext ------------------------------------------------------------------

MySQLStatementParser::ExecuteStatementContext::ExecuteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLStatementParser::ExecuteStatementContext::EXECUTE() {
  return getToken(MySQLStatementParser::EXECUTE, 0);
}

MySQLStatementParser::IdentifierContext* MySQLStatementParser::ExecuteStatementContext::identifier() {
  return getRuleContext<MySQLStatementParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLStatementParser::ExecuteStatementContext::USING() {
  return getToken(MySQLStatementParser::USING, 0);
}

MySQLStatementParser::ExecuteVarListContext* MySQLStatementParser::ExecuteStatementContext::executeVarList() {
  return getRuleContext<MySQLStatementParser::ExecuteVarListContext>(0);
}


size_t MySQLStatementParser::ExecuteStatementContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExecuteStatement;
}

void MySQLStatementParser::ExecuteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteStatement(this);
}

void MySQLStatementParser::ExecuteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteStatement(this);
}


antlrcpp::Any MySQLStatementParser::ExecuteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExecuteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExecuteStatementContext* MySQLStatementParser::executeStatement() {
  ExecuteStatementContext *_localctx = _tracker.createInstance<ExecuteStatementContext>(_ctx, getState());
  enterRule(_localctx, 1116, MySQLStatementParser::RuleExecuteStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7725);
    match(MySQLStatementParser::EXECUTE);
    setState(7726);
    identifier();
    setState(7729);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLStatementParser::USING) {
      setState(7727);
      match(MySQLStatementParser::USING);
      setState(7728);
      executeVarList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteVarListContext ------------------------------------------------------------------

MySQLStatementParser::ExecuteVarListContext::ExecuteVarListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLStatementParser::UserVariableContext *> MySQLStatementParser::ExecuteVarListContext::userVariable() {
  return getRuleContexts<MySQLStatementParser::UserVariableContext>();
}

MySQLStatementParser::UserVariableContext* MySQLStatementParser::ExecuteVarListContext::userVariable(size_t i) {
  return getRuleContext<MySQLStatementParser::UserVariableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLStatementParser::ExecuteVarListContext::COMMA_() {
  return getTokens(MySQLStatementParser::COMMA_);
}

tree::TerminalNode* MySQLStatementParser::ExecuteVarListContext::COMMA_(size_t i) {
  return getToken(MySQLStatementParser::COMMA_, i);
}


size_t MySQLStatementParser::ExecuteVarListContext::getRuleIndex() const {
  return MySQLStatementParser::RuleExecuteVarList;
}

void MySQLStatementParser::ExecuteVarListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteVarList(this);
}

void MySQLStatementParser::ExecuteVarListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLStatementParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteVarList(this);
}


antlrcpp::Any MySQLStatementParser::ExecuteVarListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLStatementParserVisitor*>(visitor))
    return parserVisitor->visitExecuteVarList(this);
  else
    return visitor->visitChildren(this);
}

MySQLStatementParser::ExecuteVarListContext* MySQLStatementParser::executeVarList() {
  ExecuteVarListContext *_localctx = _tracker.createInstance<ExecuteVarListContext>(_ctx, getState());
  enterRule(_localctx, 1118, MySQLStatementParser::RuleExecuteVarList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7731);
    userVariable();
    setState(7736);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLStatementParser::COMMA_) {
      setState(7732);
      match(MySQLStatementParser::COMMA_);
      setState(7733);
      userVariable();
      setState(7738);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool MySQLStatementParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 29: return queryExpressionBodySempred(dynamic_cast<QueryExpressionBodyContext *>(context), predicateIndex);
    case 466: return exprSempred(dynamic_cast<ExprContext *>(context), predicateIndex);
    case 469: return booleanPrimarySempred(dynamic_cast<BooleanPrimaryContext *>(context), predicateIndex);
    case 472: return bitExprSempred(dynamic_cast<BitExprContext *>(context), predicateIndex);
    case 473: return simpleExprSempred(dynamic_cast<SimpleExprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool MySQLStatementParser::queryExpressionBodySempred(QueryExpressionBodyContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool MySQLStatementParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 3);
    case 2: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool MySQLStatementParser::booleanPrimarySempred(BooleanPrimaryContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return precpred(_ctx, 5);
    case 4: return precpred(_ctx, 4);
    case 5: return precpred(_ctx, 3);
    case 6: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool MySQLStatementParser::bitExprSempred(BitExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return precpred(_ctx, 15);
    case 8: return precpred(_ctx, 14);
    case 9: return precpred(_ctx, 13);
    case 10: return precpred(_ctx, 12);
    case 11: return precpred(_ctx, 11);
    case 12: return precpred(_ctx, 10);
    case 13: return precpred(_ctx, 9);
    case 14: return precpred(_ctx, 8);
    case 15: return precpred(_ctx, 7);
    case 16: return precpred(_ctx, 6);
    case 17: return precpred(_ctx, 5);
    case 18: return precpred(_ctx, 4);
    case 19: return precpred(_ctx, 3);
    case 20: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool MySQLStatementParser::simpleExprSempred(SimpleExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 21: return precpred(_ctx, 9);
    case 22: return precpred(_ctx, 11);

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> MySQLStatementParser::_decisionToDFA;
atn::PredictionContextCache MySQLStatementParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN MySQLStatementParser::_atn;
std::vector<uint16_t> MySQLStatementParser::_serializedATN;

std::vector<std::string> MySQLStatementParser::_ruleNames = {
  "execute", "insert", "insertSpecification", "insertValuesClause", "fields", 
  "insertIdentifier", "tableWild", "insertSelectClause", "onDuplicateKeyClause", 
  "valueReference", "derivedColumns", "replace", "replaceSpecification", 
  "replaceValuesClause", "replaceSelectClause", "update", "updateSpecification_", 
  "assignment", "setAssignmentsClause", "assignmentValues", "assignmentValue", 
  "blobValue", "delete_stmt", "deleteSpecification", "singleTableClause", 
  "multipleTablesClause", "select", "selectWithInto", "queryExpression", 
  "queryExpressionBody", "queryExpressionParens", "queryPrimary", "querySpecification", 
  "call", "doStatement", "handlerStatement", "handlerOpenStatement", "handlerReadIndexStatement", 
  "handlerReadStatement", "handlerCloseStatement", "importStatement", "loadStatement", 
  "loadDataStatement", "loadXmlStatement", "explicitTable", "tableValueConstructor", 
  "rowConstructorList", "withClause", "cteClause", "selectSpecification", 
  "duplicateSpecification", "projections", "projection", "unqualifiedShorthand", 
  "qualifiedShorthand", "fromClause", "tableReferences", "escapedTableReference", 
  "tableReference", "tableFactor", "partitionNames", "indexHintList", "indexHint", 
  "joinedTable", "innerJoinType", "outerJoinType", "naturalJoinType", "joinSpecification", 
  "whereClause", "groupByClause", "havingClause", "limitClause", "limitRowCount", 
  "limitOffset", "windowClause", "windowItem", "subquery", "selectLinesInto", 
  "selectFieldsInto", "selectIntoExpression", "lockClause", "lockClauseList", 
  "lockStrength", "lockedRowAction", "tableLockingList", "tableIdentOptWild", 
  "tableAliasRefList", "alterStatement", "createTable", "partitionClause", 
  "partitionTypeDef", "subPartitions", "partitionKeyAlgorithm", "duplicateAsQueryExpression", 
  "alterTable", "standaloneAlterTableAction", "alterTableActions", "alterTablePartitionOptions", 
  "alterCommandList", "alterList", "createTableOptionsSpaceSeparated", "alterListItem", 
  "alterOrderList", "tableConstraintDef", "alterCommandsModifierList", "alterCommandsModifier", 
  "withValidation", "standaloneAlterCommands", "alterPartition", "constraintName", 
  "tableElementList", "tableElement", "restrict", "fulltextIndexOption", 
  "dropTable", "dropIndex", "alterAlgorithmOption", "alterLockOption", "truncateTable", 
  "createIndex", "createDatabase", "alterDatabase", "createDatabaseSpecification_", 
  "alterDatabaseSpecification_", "dropDatabase", "alterInstance", "instanceAction", 
  "channel", "createEvent", "alterEvent", "dropEvent", "createFunction", 
  "alterFunction", "dropFunction", "createProcedure", "alterProcedure", 
  "dropProcedure", "createServer", "alterServer", "dropServer", "createView", 
  "alterView", "dropView", "createTablespaceInnodb", "createTablespaceNdb", 
  "alterTablespaceNdb", "alterTablespaceInnodb", "dropTablespace", "createLogfileGroup", 
  "alterLogfileGroup", "dropLogfileGroup", "createTrigger", "dropTrigger", 
  "renameTable", "createDefinitionClause", "columnDefinition", "fieldDefinition", 
  "columnAttribute", "checkConstraint", "constraintEnforcement", "generatedOption", 
  "referenceDefinition", "onUpdateDelete", "referenceOption", "indexNameAndType", 
  "indexType", "indexTypeClause", "keyParts", "keyPart", "keyPartWithExpression", 
  "keyListWithExpression", "indexOption", "commonIndexOption", "visibility", 
  "createLikeClause", "createIndexSpecification", "createTableOptions", 
  "createTableOption", "createSRSStatement", "dropSRSStatement", "srsAttribute", 
  "place", "partitionDefinitions", "partitionDefinition", "partitionLessThanValue", 
  "partitionValueList", "partitionDefinitionOption", "subpartitionDefinition", 
  "ownerStatement", "scheduleExpression", "timestampValue", "routineBody", 
  "serverOption", "routineOption", "procedureParameter", "fileSizeLiteral", 
  "simpleStatement", "compoundStatement", "validStatement", "beginStatement", 
  "declareStatement", "flowControlStatement", "caseStatement", "ifStatement", 
  "iterateStatement", "leaveStatement", "loopStatement", "repeatStatement", 
  "returnStatement", "whileStatement", "cursorStatement", "cursorCloseStatement", 
  "cursorDeclareStatement", "cursorFetchStatement", "cursorOpenStatement", 
  "conditionHandlingStatement", "declareConditionStatement", "declareHandlerStatement", 
  "getDiagnosticsStatement", "statementInformationItem", "conditionInformationItem", 
  "conditionNumber", "statementInformationItemName", "conditionInformationItemName", 
  "handlerAction", "conditionValue", "resignalStatement", "signalStatement", 
  "signalInformationItem", "setTransaction", "setAutoCommit", "autoCommitValue", 
  "beginTransaction", "commit", "rollback", "savepoint", "begin", "lock", 
  "unlock", "releaseSavepoint", "xa", "transactionCharacteristic", "level", 
  "accessMode", "optionChain", "optionRelease", "tableLock", "lockOption", 
  "xid", "grant", "revoke", "proxyClause", "privilegeClause", "roleClause", 
  "allClause", "privileges", "privilege", "privilegeType", "onObjectClause", 
  "objectType", "privilegeLevel", "createUser", "defaultRoleClause", "requireClause", 
  "connectOptions", "accountLockPasswordExpireOptions", "accountLockPasswordExpireOption", 
  "alterUser", "alterUserEntry", "alterUserList", "dropUser", "createRole", 
  "dropRole", "renameUser", "setDefaultRole", "setRole", "setPassword", 
  "authOption", "withGrantOption", "userOrRoles", "roles", "grantOption", 
  "userAuthOption", "identifiedBy", "identifiedWith", "connectOption", "tlsOption", 
  "userFuncAuthOption", "use", "help", "explain", "showDatabases", "showTables", 
  "showTableStatus", "showColumns", "showIndex", "showCreateTable", "fromSchema", 
  "fromTable", "showLike", "showColumnLike", "showWhereClause", "showFilter", 
  "showProfileType", "setVariable", "variableAssign", "showBinaryLogs", 
  "showBinlogEvents", "showCharacterSet", "showCollation", "showCreateDatabase", 
  "showCreateEvent", "showCreateFunction", "showCreateProcedure", "showCreateTrigger", 
  "showCreateUser", "showCreateView", "showEngine", "showEngines", "showErrors", 
  "showEvents", "showFunctionCode", "showFunctionStatus", "showGrant", "showMasterStatus", 
  "showOpenTables", "showPlugins", "showPrivileges", "showProcedureCode", 
  "showProcedureStatus", "showProcesslist", "showProfile", "showProfiles", 
  "showRelaylogEvent", "showSlavehost", "showSlaveStatus", "showStatus", 
  "showTrriggers", "showVariables", "showWarnings", "setCharacter", "setName", 
  "clone", "cloneAction", "createUdf", "install", "uninstall", "installComponent", 
  "installPlugin", "uninstallComponent", "uninstallPlugin", "analyzeTable", 
  "histogram", "checkTable", "checkTableOption", "checksumTable", "optimizeTable", 
  "repairTable", "alterResourceGroup", "vcpuSpec", "createResourceGroup", 
  "dropResourceGroup", "setResourceGroup", "binlog", "cacheIndex", "tableIndexList", 
  "partitionList", "flush", "flushOption", "tablesOption", "kill", "loadIndexInfo", 
  "resetStatement", "resetOption", "resetPersist", "restart", "shutdown", 
  "explainType", "explainableStatement", "formatName", "show", "change", 
  "changeMasterTo", "changeReplicationFilter", "startSlave", "stopSlave", 
  "groupReplication", "startGroupReplication", "stopGroupReplication", "purgeBinaryLog", 
  "threadTypes", "threadType", "utilOption", "connectionOptions", "masterDefs", 
  "masterDef", "ignoreServerIds", "ignoreServerId", "filterDefs", "filterDef", 
  "wildTables", "wildTable", "parameterMarker", "customKeyword", "literals", 
  "string_", "stringLiterals", "numberLiterals", "temporalLiterals", "hexadecimalLiterals", 
  "bitValueLiterals", "booleanLiterals", "nullValueLiterals", "collationName", 
  "identifier", "unreservedWord", "textOrIdentifier", "variable", "userVariable", 
  "systemVariable", "scope", "internalVariableName", "setExprOrDefault", 
  "schemaName", "schemaNames", "charsetName", "schemaPairs", "schemaPair", 
  "tableName", "columnName", "indexName", "userIdentifierOrText", "userName", 
  "eventName", "serverName", "wrapperName", "functionName", "viewName", 
  "owner", "alias", "name", "tableList", "viewNames", "columnNames", "groupName", 
  "routineName", "shardLibraryName", "componentName", "pluginName", "hostName", 
  "port", "cloneInstance", "cloneDir", "channelName", "logName", "roleName", 
  "engineRef", "triggerName", "triggerTime", "tableOrTables", "userOrRole", 
  "partitionName", "identifierList", "allOrPartitionNameList", "triggerEvent", 
  "triggerOrder", "expr", "logicalOperator", "notOperator", "booleanPrimary", 
  "comparisonOperator", "predicate", "bitExpr", "simpleExpr", "columnRef", 
  "columnRefList", "functionCall", "aggregationFunction", "aggregationFunctionName", 
  "distinct", "overClause", "windowSpecification", "frameClause", "frameStart", 
  "frameEnd", "frameBetween", "specialFunction", "currentUserFunction", 
  "groupConcatFunction", "windowFunction", "windowingClause", "leadLagInfo", 
  "nullTreatment", "checkType", "repairType", "castFunction", "convertFunction", 
  "castType", "nchar", "positionFunction", "substringFunction", "extractFunction", 
  "charFunction", "trimFunction", "valuesFunction", "weightStringFunction", 
  "levelClause", "levelInWeightListElement", "regularFunction", "shorthandRegularFunction", 
  "completeRegularFunction", "regularFunctionName", "matchExpression", "matchSearchModifier", 
  "caseExpression", "datetimeExpr", "binaryLogFileIndexNumber", "caseWhen", 
  "caseElse", "intervalExpression", "intervalValue", "intervalUnit", "orderByClause", 
  "orderByItem", "dataType", "stringList", "textString", "textStringHash", 
  "fieldOptions", "precision", "typeDatetimePrecision", "charsetWithOptBinary", 
  "ascii", "unicode", "charset", "defaultCollation", "defaultEncryption", 
  "defaultCharset", "signedLiteral", "now", "columnFormat", "storageMedia", 
  "direction", "keyOrIndex", "fieldLength", "characterSet", "collateClause", 
  "fieldOrVarSpec", "notExistClause", "existClause", "connectionId", "labelName", 
  "cursorName", "conditionName", "unionOption", "noWriteToBinLog", "channelOption", 
  "preparedStatement", "executeStatement", "executeVarList"
};

std::vector<std::string> MySQLStatementParser::_literalNames = {
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "'INNODB'", "'REDO_LOG'", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'SHARED'", 
  "'EXCLUSIVE'", "'&&'", "'||'", "'!'", "'~'", "'|'", "'&'", "'<<'", "'>>'", 
  "'^'", "'%'", "':'", "'+'", "'-'", "'*'", "'/'", "'\\'", "'.'", "'.*'", 
  "'<=>'", "'=='", "'='", "", "'>'", "'>='", "'<'", "'<='", "'#'", "'('", 
  "')'", "'{'", "'}'", "'['", "']'", "','", "'\"'", "'''", "'`'", "'?'", 
  "'@'", "';'", "'->'", "'->>'", "", "", "'DO NOT MATCH ANY THING, JUST FOR GENERATOR'", 
  "", "", "", "", "", "", "", "", "", "", "", "", "'not support'"
};

std::vector<std::string> MySQLStatementParser::_symbolicNames = {
  "", "WS", "MAX", "MIN", "SUM", "COUNT", "GROUP_CONCAT", "CAST", "POSITION", 
  "SUBSTRING", "SUBSTR", "EXTRACT", "TRIM", "LAST_DAY", "TRADITIONAL", "TREE", 
  "MYSQL_MAIN", "MYSQL_ADMIN", "INSTANT", "INPLACE", "COPY", "UL_BINARY", 
  "AUTOCOMMIT", "INNODB", "REDO_LOG", "ACCESSIBLE", "ACCOUNT", "ACTION", 
  "ACTIVE", "ADD", "ADMIN", "AFTER", "AGAINST", "AGGREGATE", "ALGORITHM", 
  "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", 
  "ASCII", "ASENSITIVE", "AT", "ATTRIBUTE", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", 
  "AVG", "AVG_ROW_LENGTH", "BACKUP", "BEFORE", "BEGIN", "BETWEEN", "BIGINT", 
  "BINARY", "BINLOG", "BIT", "BLOB", "BLOCK", "BOOL", "BOOLEAN", "BOTH", 
  "BTREE", "BUCKETS", "BY", "BYTE", "CACHE", "CALL", "CASCADE", "CASCADED", 
  "CASE", "CATALOG_NAME", "CHAIN", "CHANGE", "CHANGED", "CHANNEL", "CHAR", 
  "CHARACTER", "CHARSET", "CHECK", "CHECKSUM", "CIPHER", "CLASS_ORIGIN", 
  "CLIENT", "CLONE", "CLOSE", "COALESCE", "CODE", "COLLATE", "COLLATION", 
  "COLUMN", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMIT", 
  "COMMITTED", "COMPACT", "COMPLETION", "COMPONENT", "COMPRESSED", "COMPRESSION", 
  "CONCURRENT", "CONDITION", "CONNECTION", "CONSISTENT", "CONSTRAINT", "CONSTRAINT_CATALOG", 
  "CONSTRAINT_NAME", "CONSTRAINT_SCHEMA", "CONTAINS", "CONTEXT", "CONTINUE", 
  "CONVERT", "CPU", "CREATE", "CROSS", "CUBE", "CUME_DIST", "CURRENT", "CURRENT_DATE", 
  "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "CURSOR_NAME", 
  "DATA", "DATABASE", "DATABASES", "DATAFILE", "DATE", "DATETIME", "DAY", 
  "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DEALLOCATE", 
  "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFAULT_AUTH", "DEFINER", "DEFINITION", 
  "DELAYED", "DELAY_KEY_WRITE", "DELETE", "DENSE_RANK", "DESC", "DESCRIBE", 
  "DESCRIPTION", "DETERMINISTIC", "DIAGNOSTICS", "DIRECTORY", "DISABLE", 
  "DISCARD", "DISK", "DISTINCT", "DISTINCTROW", "DIV", "DO", "DOUBLE", "DROP", 
  "DUAL", "DUMPFILE", "DUPLICATE", "DYNAMIC", "EACH", "ELSE", "ELSEIF", 
  "EMPTY", "ENABLE", "ENCLOSED", "ENCRYPTION", "END", "ENDS", "ENFORCED", 
  "ENGINE", "ENGINES", "ENGINE_ATTRIBUTE", "ENUM", "ERROR", "ERRORS", "ESCAPE", 
  "ESCAPED", "EVENT", "EVENTS", "EVERY", "EXCEPT", "EXCHANGE", "EXCLUDE", 
  "EXECUTE", "EXISTS", "EXIT", "EXPANSION", "EXPIRE", "EXPLAIN", "EXPORT", 
  "EXTENDED", "EXTENT_SIZE", "FAILED_LOGIN_ATTEMPTS", "FALSE", "FAST", "FAULTS", 
  "FETCH", "FIELDS", "FILE", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIRST_VALUE", 
  "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "FLUSH", "FOLLOWING", "FOLLOWS", 
  "FOR", "FORCE", "FOREIGN", "FORMAT", "FOUND", "FROM", "FULL", "FULLTEXT", 
  "FUNCTION", "GENERAL", "GENERATED", "GEOMCOLLECTION", "GEOMETRY", "GEOMETRYCOLLECTION", 
  "GET", "GET_FORMAT", "GET_MASTER_PUBLIC_KEY", "GLOBAL", "GRANT", "GRANTS", 
  "GROUP", "GROUPING", "GROUPS", "GROUP_REPLICATION", "HANDLER", "HASH", 
  "HAVING", "HELP", "HIGH_PRIORITY", "HISTOGRAM", "HISTORY", "HOST", "HOSTS", 
  "HOUR", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IDENTIFIED", 
  "IF", "IGNORE", "IGNORE_SERVER_IDS", "IMPORT", "IN", "INACTIVE", "INDEX", 
  "INDEXES", "INFILE", "INITIAL_SIZE", "INNER", "INOUT", "INSENSITIVE", 
  "INSERT", "INSERT_METHOD", "INSTALL", "INSTANCE", "INT", "INT1", "INT2", 
  "INT3", "INT4", "INT8", "INTEGER", "INTERVAL", "INTO", "INVISIBLE", "INVOKER", 
  "IO", "IO_AFTER_GTIDS", "IO_BEFORE_GTIDS", "IO_THREAD", "IPC", "IS", "ISOLATION", 
  "ISSUER", "ITERATE", "JOIN", "JSON", "JSON_TABLE", "JSON_VALUE", "KEY", 
  "KEYS", "KEY_BLOCK_SIZE", "KILL", "LAG", "LANGUAGE", "LAST", "LAST_VALUE", 
  "LATERAL", "LEAD", "LEADING", "LEAVE", "LEAVES", "LEFT", "LESS", "LEVEL", 
  "LIKE", "LIMIT", "LINEAR", "LINES", "LINESTRING", "LIST", "LOAD", "LOCAL", 
  "LOCALTIME", "LOCALTIMESTAMP", "LOCK", "LOCKED", "LOCKS", "LOGFILE", "LOGS", 
  "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY", "MANAGED", "MASTER", 
  "MASTER_AUTO_POSITION", "MASTER_BIND", "MASTER_COMPRESSION_ALGORITHMS", 
  "MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", 
  "MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", 
  "MASTER_PUBLIC_KEY_PATH", "MASTER_RETRY_COUNT", "MASTER_SERVER_ID", "MASTER_SSL", 
  "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT", "MASTER_SSL_CIPHER", 
  "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY", "MASTER_SSL_VERIFY_SERVER_CERT", 
  "MASTER_TLS_CIPHERSUITES", "MASTER_TLS_VERSION", "MASTER_USER", "MASTER_ZSTD_COMPRESSION_LEVEL", 
  "MATCH", "MAXVALUE", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR", 
  "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", 
  "MEDIUM", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MEMBER", "MEMORY", 
  "MERGE", "MESSAGE_TEXT", "MICROSECOND", "MIDDLEINT", "MIGRATE", "MINUTE", 
  "MINUTE_MICROSECOND", "MINUTE_SECOND", "MIN_ROWS", "MOD", "MODE", "MODIFIES", 
  "MODIFY", "MONTH", "MULTILINESTRING", "MULTIPOINT", "MULTIPOLYGON", "MUTEX", 
  "MYSQL_ERRNO", "NAME", "NAMES", "NATIONAL", "NATURAL", "NCHAR", "NDB", 
  "NDBCLUSTER", "NESTED", "NETWORK_NAMESPACE", "NEVER", "NEW", "NEXT", "NO", 
  "NODEGROUP", "NONE", "NOT", "NOWAIT", "NO_WAIT", "NO_WRITE_TO_BINLOG", 
  "NTH_VALUE", "NTILE", "NULL", "NULLS", "NUMBER", "NUMERIC", "NVARCHAR", 
  "OF", "OFF", "OFFSET", "OJ", "OLD", "ON", "ONE", "ONLY", "OPEN", "OPTIMIZE", 
  "OPTIMIZER_COSTS", "OPTION", "OPTIONAL", "OPTIONALLY", "OPTIONS", "OR", 
  "ORDER", "ORDINALITY", "ORGANIZATION", "OTHERS", "OUT", "OUTER", "OUTFILE", 
  "OVER", "OWNER", "PACK_KEYS", "PAGE", "PARSER", "PARTIAL", "PARTITION", 
  "PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", "PATH", 
  "PERCENT_RANK", "PERSIST", "PERSIST_ONLY", "PHASE", "PLUGIN", "PLUGINS", 
  "PLUGIN_DIR", "POINT", "POLYGON", "PORT", "PRECEDES", "PRECEDING", "PRECISION", 
  "PREPARE", "PRESERVE", "PREV", "PRIMARY", "PRIVILEGES", "PRIVILEGE_CHECKS_USER", 
  "PROCEDURE", "PROCESS", "PROCESSLIST", "PROFILE", "PROFILES", "PROXY", 
  "PURGE", "QUARTER", "QUERY", "QUICK", "RANDOM", "RANGE", "RANK", "READ", 
  "READS", "READ_ONLY", "READ_WRITE", "REAL", "REBUILD", "RECOVER", "RECURSIVE", 
  "REDO_BUFFER_SIZE", "REDUNDANT", "REFERENCE", "REFERENCES", "REGEXP", 
  "RELAY", "RELAYLOG", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAY_THREAD", 
  "RELEASE", "RELOAD", "REMOVE", "RENAME", "REORGANIZE", "REPAIR", "REPEAT", 
  "REPEATABLE", "REPLACE", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", 
  "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", 
  "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION", "REQUIRE", "REQUIRE_ROW_FORMAT", 
  "RESET", "RESIGNAL", "RESOURCE", "RESPECT", "RESTART", "RESTORE", "RESTRICT", 
  "RESUME", "RETAIN", "RETURN", "RETURNED_SQLSTATE", "RETURNING", "RETURNS", 
  "REUSE", "REVERSE", "REVOKE", "RIGHT", "RLIKE", "ROLE", "ROLLBACK", "ROLLUP", 
  "ROTATE", "ROUTINE", "ROW", "ROWS", "ROW_COUNT", "ROW_FORMAT", "ROW_NUMBER", 
  "RTREE", "SAVEPOINT", "SCHEDULE", "SCHEMA", "SCHEMAS", "SCHEMA_NAME", 
  "SECOND", "SECONDARY", "SECONDARY_ENGINE", "SECONDARY_ENGINE_ATTRIBUTE", 
  "SECONDARY_LOAD", "SECONDARY_UNLOAD", "SECOND_MICROSECOND", "SECURITY", 
  "SELECT", "SENSITIVE", "SEPARATOR", "SERIAL", "SERIALIZABLE", "SERVER", 
  "SESSION", "SET", "SHARE", "SHOW", "SHUTDOWN", "SIGNAL", "SIGNED", "SIMPLE", 
  "SKIP_SYMBOL", "SLAVE", "SLOW", "SMALLINT", "SNAPSHOT", "SOCKET", "SOME", 
  "SONAME", "SOUNDS", "SOURCE", "SPATIAL", "SPECIFIC", "SQL", "SQL_CACHE", 
  "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", 
  "SQL_BEFORE_GTIDS", "SQL_BIG_RESULT", "SQL_BUFFER_RESULT", "SQL_CALC_FOUND_ROWS", 
  "SQL_NO_CACHE", "SQL_SMALL_RESULT", "SQL_THREAD", "SQL_TSI_DAY", "SQL_TSI_HOUR", 
  "SQL_TSI_MINUTE", "SQL_TSI_MONTH", "SQL_TSI_QUARTER", "SQL_TSI_SECOND", 
  "SQL_TSI_WEEK", "SQL_TSI_YEAR", "SRID", "SSL", "STACKED", "START", "STARTING", 
  "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT", "STATS_SAMPLE_PAGES", 
  "STATUS", "STOP", "STORAGE", "STORED", "STRAIGHT_JOIN", "STREAM", "STRING", 
  "SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUPER", 
  "SUSPEND", "SWAPS", "SWITCHES", "SYSTEM", "TABLE", "TABLES", "TABLESPACE", 
  "TABLE_CHECKSUM", "TABLE_NAME", "TEMPORARY", "TEMPTABLE", "TERMINATED", 
  "TEXT", "THAN", "THEN", "THREAD_PRIORITY", "TIES", "TIME", "TIMESTAMP", 
  "TIMESTAMPADD", "TIMESTAMPDIFF", "TINYBLOB", "TINYINT", "TINYTEXT", "TLS", 
  "TO", "TRAILING", "TRANSACTION", "TRIGGER", "TRIGGERS", "TRUE", "TRUNCATE", 
  "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNDEFINED", "UNDO", "UNDOFILE", 
  "UNDO_BUFFER_SIZE", "UNICODE", "UNINSTALL", "UNION", "UNIQUE", "UNKNOWN", 
  "UNLOCK", "UNSIGNED", "UNTIL", "UPDATE", "UPGRADE", "USAGE", "USE", "USER", 
  "USER_RESOURCES", "USE_FRM", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", 
  "VALIDATION", "VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARCHARACTER", 
  "VARIABLES", "VARYING", "VCPU", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", 
  "WARNINGS", "WEEK", "WEIGHT_STRING", "WHEN", "WHERE", "WHILE", "WINDOW", 
  "WITH", "WITHOUT", "WORK", "WRAPPER", "WRITE", "X509", "XA", "XID", "XML", 
  "XOR", "YEAR", "YEAR_MONTH", "ZEROFILL", "M_SHARED", "M_EXCLUSIVE", "AND_", 
  "OR_", "NOT_", "TILDE_", "VERTICAL_BAR_", "AMPERSAND_", "SIGNED_LEFT_SHIFT_", 
  "SIGNED_RIGHT_SHIFT_", "CARET_", "MOD_", "COLON_", "PLUS_", "MINUS_", 
  "ASTERISK_", "SLASH_", "BACKSLASH_", "DOT_", "DOT_ASTERISK_", "SAFE_EQ_", 
  "DEQ_", "EQ_", "NEQ_", "GT_", "GTE_", "LT_", "LTE_", "POUND_", "LP_", 
  "RP_", "LBE_", "RBE_", "LBT_", "RBT_", "COMMA_", "DQ_", "SQ_", "BQ_", 
  "QUESTION_", "AT_", "SEMI_", "JSON_SEPARATOR", "JSON_UNQUOTED_SEPARATOR", 
  "BLOCK_COMMENT", "INLINE_COMMENT", "FOR_GENERATOR", "FILESIZE_LITERAL", 
  "IDENTIFIER_", "SINGLE_QUOTED_TEXT", "DOUBLE_QUOTED_TEXT", "NCHAR_TEXT", 
  "UNDERSCORE_CHARSET", "NUMBER_", "INT_NUM_", "FLOAT_NUM_", "DECIMAL_NUM_", 
  "HEX_DIGIT_", "BIT_NUM_", "NOT_SUPPORT_"
};

dfa::Vocabulary MySQLStatementParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> MySQLStatementParser::_tokenNames;

MySQLStatementParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x319, 0x1e3e, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 
       0x4, 0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 
       0x9, 0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 
       0xa, 0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 
       0x4, 0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 
       0x11, 0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 
       0x14, 0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 
       0x17, 0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 
       0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 
       0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 
       0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 
       0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 
       0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 
       0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 
       0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 
       0x2f, 0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 
       0x32, 0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 
       0x35, 0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 
       0x38, 0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 
       0x3b, 0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 
       0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 
       0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 
       0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 
       0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 
       0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 
       0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 
       0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 
       0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 
       0x56, 0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 
       0x59, 0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 
       0x5c, 0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 
       0x5f, 0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 
       0x62, 0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 
       0x65, 0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 
       0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 
       0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 
       0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 
       0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 
       0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 
       0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 
       0x7a, 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 
       0x7d, 0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 
       0x80, 0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 
       0x83, 0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 
       0x86, 0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 
       0x89, 0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 
       0x8c, 0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 
       0x8f, 0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 
       0x92, 0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 
       0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 
       0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 
       0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 
       0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 
       0xa1, 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 
       0xa4, 0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 
       0xa7, 0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 
       0xaa, 0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 
       0xad, 0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 
       0xb0, 0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 
       0xb3, 0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 
       0xb6, 0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 
       0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 
       0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 
       0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 
       0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 
       0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 
       0xc8, 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 
       0xcb, 0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 
       0xce, 0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 
       0xd1, 0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 
       0xd4, 0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 
       0xd7, 0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 
       0xda, 0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 
       0xdd, 0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 
       0xe0, 0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 
       0xe3, 0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, 0x4, 0xe5, 0x9, 0xe5, 0x4, 
       0xe6, 0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, 0xe8, 0x9, 0xe8, 0x4, 
       0xe9, 0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, 0x9, 0xeb, 0x4, 
       0xec, 0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, 0xee, 0x4, 
       0xef, 0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, 0x4, 
       0xf2, 0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, 
       0xf5, 0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 
       0xf8, 0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 
       0xfb, 0x9, 0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x4, 
       0xfe, 0x9, 0xfe, 0x4, 0xff, 0x9, 0xff, 0x4, 0x100, 0x9, 0x100, 0x4, 
       0x101, 0x9, 0x101, 0x4, 0x102, 0x9, 0x102, 0x4, 0x103, 0x9, 0x103, 
       0x4, 0x104, 0x9, 0x104, 0x4, 0x105, 0x9, 0x105, 0x4, 0x106, 0x9, 
       0x106, 0x4, 0x107, 0x9, 0x107, 0x4, 0x108, 0x9, 0x108, 0x4, 0x109, 
       0x9, 0x109, 0x4, 0x10a, 0x9, 0x10a, 0x4, 0x10b, 0x9, 0x10b, 0x4, 
       0x10c, 0x9, 0x10c, 0x4, 0x10d, 0x9, 0x10d, 0x4, 0x10e, 0x9, 0x10e, 
       0x4, 0x10f, 0x9, 0x10f, 0x4, 0x110, 0x9, 0x110, 0x4, 0x111, 0x9, 
       0x111, 0x4, 0x112, 0x9, 0x112, 0x4, 0x113, 0x9, 0x113, 0x4, 0x114, 
       0x9, 0x114, 0x4, 0x115, 0x9, 0x115, 0x4, 0x116, 0x9, 0x116, 0x4, 
       0x117, 0x9, 0x117, 0x4, 0x118, 0x9, 0x118, 0x4, 0x119, 0x9, 0x119, 
       0x4, 0x11a, 0x9, 0x11a, 0x4, 0x11b, 0x9, 0x11b, 0x4, 0x11c, 0x9, 
       0x11c, 0x4, 0x11d, 0x9, 0x11d, 0x4, 0x11e, 0x9, 0x11e, 0x4, 0x11f, 
       0x9, 0x11f, 0x4, 0x120, 0x9, 0x120, 0x4, 0x121, 0x9, 0x121, 0x4, 
       0x122, 0x9, 0x122, 0x4, 0x123, 0x9, 0x123, 0x4, 0x124, 0x9, 0x124, 
       0x4, 0x125, 0x9, 0x125, 0x4, 0x126, 0x9, 0x126, 0x4, 0x127, 0x9, 
       0x127, 0x4, 0x128, 0x9, 0x128, 0x4, 0x129, 0x9, 0x129, 0x4, 0x12a, 
       0x9, 0x12a, 0x4, 0x12b, 0x9, 0x12b, 0x4, 0x12c, 0x9, 0x12c, 0x4, 
       0x12d, 0x9, 0x12d, 0x4, 0x12e, 0x9, 0x12e, 0x4, 0x12f, 0x9, 0x12f, 
       0x4, 0x130, 0x9, 0x130, 0x4, 0x131, 0x9, 0x131, 0x4, 0x132, 0x9, 
       0x132, 0x4, 0x133, 0x9, 0x133, 0x4, 0x134, 0x9, 0x134, 0x4, 0x135, 
       0x9, 0x135, 0x4, 0x136, 0x9, 0x136, 0x4, 0x137, 0x9, 0x137, 0x4, 
       0x138, 0x9, 0x138, 0x4, 0x139, 0x9, 0x139, 0x4, 0x13a, 0x9, 0x13a, 
       0x4, 0x13b, 0x9, 0x13b, 0x4, 0x13c, 0x9, 0x13c, 0x4, 0x13d, 0x9, 
       0x13d, 0x4, 0x13e, 0x9, 0x13e, 0x4, 0x13f, 0x9, 0x13f, 0x4, 0x140, 
       0x9, 0x140, 0x4, 0x141, 0x9, 0x141, 0x4, 0x142, 0x9, 0x142, 0x4, 
       0x143, 0x9, 0x143, 0x4, 0x144, 0x9, 0x144, 0x4, 0x145, 0x9, 0x145, 
       0x4, 0x146, 0x9, 0x146, 0x4, 0x147, 0x9, 0x147, 0x4, 0x148, 0x9, 
       0x148, 0x4, 0x149, 0x9, 0x149, 0x4, 0x14a, 0x9, 0x14a, 0x4, 0x14b, 
       0x9, 0x14b, 0x4, 0x14c, 0x9, 0x14c, 0x4, 0x14d, 0x9, 0x14d, 0x4, 
       0x14e, 0x9, 0x14e, 0x4, 0x14f, 0x9, 0x14f, 0x4, 0x150, 0x9, 0x150, 
       0x4, 0x151, 0x9, 0x151, 0x4, 0x152, 0x9, 0x152, 0x4, 0x153, 0x9, 
       0x153, 0x4, 0x154, 0x9, 0x154, 0x4, 0x155, 0x9, 0x155, 0x4, 0x156, 
       0x9, 0x156, 0x4, 0x157, 0x9, 0x157, 0x4, 0x158, 0x9, 0x158, 0x4, 
       0x159, 0x9, 0x159, 0x4, 0x15a, 0x9, 0x15a, 0x4, 0x15b, 0x9, 0x15b, 
       0x4, 0x15c, 0x9, 0x15c, 0x4, 0x15d, 0x9, 0x15d, 0x4, 0x15e, 0x9, 
       0x15e, 0x4, 0x15f, 0x9, 0x15f, 0x4, 0x160, 0x9, 0x160, 0x4, 0x161, 
       0x9, 0x161, 0x4, 0x162, 0x9, 0x162, 0x4, 0x163, 0x9, 0x163, 0x4, 
       0x164, 0x9, 0x164, 0x4, 0x165, 0x9, 0x165, 0x4, 0x166, 0x9, 0x166, 
       0x4, 0x167, 0x9, 0x167, 0x4, 0x168, 0x9, 0x168, 0x4, 0x169, 0x9, 
       0x169, 0x4, 0x16a, 0x9, 0x16a, 0x4, 0x16b, 0x9, 0x16b, 0x4, 0x16c, 
       0x9, 0x16c, 0x4, 0x16d, 0x9, 0x16d, 0x4, 0x16e, 0x9, 0x16e, 0x4, 
       0x16f, 0x9, 0x16f, 0x4, 0x170, 0x9, 0x170, 0x4, 0x171, 0x9, 0x171, 
       0x4, 0x172, 0x9, 0x172, 0x4, 0x173, 0x9, 0x173, 0x4, 0x174, 0x9, 
       0x174, 0x4, 0x175, 0x9, 0x175, 0x4, 0x176, 0x9, 0x176, 0x4, 0x177, 
       0x9, 0x177, 0x4, 0x178, 0x9, 0x178, 0x4, 0x179, 0x9, 0x179, 0x4, 
       0x17a, 0x9, 0x17a, 0x4, 0x17b, 0x9, 0x17b, 0x4, 0x17c, 0x9, 0x17c, 
       0x4, 0x17d, 0x9, 0x17d, 0x4, 0x17e, 0x9, 0x17e, 0x4, 0x17f, 0x9, 
       0x17f, 0x4, 0x180, 0x9, 0x180, 0x4, 0x181, 0x9, 0x181, 0x4, 0x182, 
       0x9, 0x182, 0x4, 0x183, 0x9, 0x183, 0x4, 0x184, 0x9, 0x184, 0x4, 
       0x185, 0x9, 0x185, 0x4, 0x186, 0x9, 0x186, 0x4, 0x187, 0x9, 0x187, 
       0x4, 0x188, 0x9, 0x188, 0x4, 0x189, 0x9, 0x189, 0x4, 0x18a, 0x9, 
       0x18a, 0x4, 0x18b, 0x9, 0x18b, 0x4, 0x18c, 0x9, 0x18c, 0x4, 0x18d, 
       0x9, 0x18d, 0x4, 0x18e, 0x9, 0x18e, 0x4, 0x18f, 0x9, 0x18f, 0x4, 
       0x190, 0x9, 0x190, 0x4, 0x191, 0x9, 0x191, 0x4, 0x192, 0x9, 0x192, 
       0x4, 0x193, 0x9, 0x193, 0x4, 0x194, 0x9, 0x194, 0x4, 0x195, 0x9, 
       0x195, 0x4, 0x196, 0x9, 0x196, 0x4, 0x197, 0x9, 0x197, 0x4, 0x198, 
       0x9, 0x198, 0x4, 0x199, 0x9, 0x199, 0x4, 0x19a, 0x9, 0x19a, 0x4, 
       0x19b, 0x9, 0x19b, 0x4, 0x19c, 0x9, 0x19c, 0x4, 0x19d, 0x9, 0x19d, 
       0x4, 0x19e, 0x9, 0x19e, 0x4, 0x19f, 0x9, 0x19f, 0x4, 0x1a0, 0x9, 
       0x1a0, 0x4, 0x1a1, 0x9, 0x1a1, 0x4, 0x1a2, 0x9, 0x1a2, 0x4, 0x1a3, 
       0x9, 0x1a3, 0x4, 0x1a4, 0x9, 0x1a4, 0x4, 0x1a5, 0x9, 0x1a5, 0x4, 
       0x1a6, 0x9, 0x1a6, 0x4, 0x1a7, 0x9, 0x1a7, 0x4, 0x1a8, 0x9, 0x1a8, 
       0x4, 0x1a9, 0x9, 0x1a9, 0x4, 0x1aa, 0x9, 0x1aa, 0x4, 0x1ab, 0x9, 
       0x1ab, 0x4, 0x1ac, 0x9, 0x1ac, 0x4, 0x1ad, 0x9, 0x1ad, 0x4, 0x1ae, 
       0x9, 0x1ae, 0x4, 0x1af, 0x9, 0x1af, 0x4, 0x1b0, 0x9, 0x1b0, 0x4, 
       0x1b1, 0x9, 0x1b1, 0x4, 0x1b2, 0x9, 0x1b2, 0x4, 0x1b3, 0x9, 0x1b3, 
       0x4, 0x1b4, 0x9, 0x1b4, 0x4, 0x1b5, 0x9, 0x1b5, 0x4, 0x1b6, 0x9, 
       0x1b6, 0x4, 0x1b7, 0x9, 0x1b7, 0x4, 0x1b8, 0x9, 0x1b8, 0x4, 0x1b9, 
       0x9, 0x1b9, 0x4, 0x1ba, 0x9, 0x1ba, 0x4, 0x1bb, 0x9, 0x1bb, 0x4, 
       0x1bc, 0x9, 0x1bc, 0x4, 0x1bd, 0x9, 0x1bd, 0x4, 0x1be, 0x9, 0x1be, 
       0x4, 0x1bf, 0x9, 0x1bf, 0x4, 0x1c0, 0x9, 0x1c0, 0x4, 0x1c1, 0x9, 
       0x1c1, 0x4, 0x1c2, 0x9, 0x1c2, 0x4, 0x1c3, 0x9, 0x1c3, 0x4, 0x1c4, 
       0x9, 0x1c4, 0x4, 0x1c5, 0x9, 0x1c5, 0x4, 0x1c6, 0x9, 0x1c6, 0x4, 
       0x1c7, 0x9, 0x1c7, 0x4, 0x1c8, 0x9, 0x1c8, 0x4, 0x1c9, 0x9, 0x1c9, 
       0x4, 0x1ca, 0x9, 0x1ca, 0x4, 0x1cb, 0x9, 0x1cb, 0x4, 0x1cc, 0x9, 
       0x1cc, 0x4, 0x1cd, 0x9, 0x1cd, 0x4, 0x1ce, 0x9, 0x1ce, 0x4, 0x1cf, 
       0x9, 0x1cf, 0x4, 0x1d0, 0x9, 0x1d0, 0x4, 0x1d1, 0x9, 0x1d1, 0x4, 
       0x1d2, 0x9, 0x1d2, 0x4, 0x1d3, 0x9, 0x1d3, 0x4, 0x1d4, 0x9, 0x1d4, 
       0x4, 0x1d5, 0x9, 0x1d5, 0x4, 0x1d6, 0x9, 0x1d6, 0x4, 0x1d7, 0x9, 
       0x1d7, 0x4, 0x1d8, 0x9, 0x1d8, 0x4, 0x1d9, 0x9, 0x1d9, 0x4, 0x1da, 
       0x9, 0x1da, 0x4, 0x1db, 0x9, 0x1db, 0x4, 0x1dc, 0x9, 0x1dc, 0x4, 
       0x1dd, 0x9, 0x1dd, 0x4, 0x1de, 0x9, 0x1de, 0x4, 0x1df, 0x9, 0x1df, 
       0x4, 0x1e0, 0x9, 0x1e0, 0x4, 0x1e1, 0x9, 0x1e1, 0x4, 0x1e2, 0x9, 
       0x1e2, 0x4, 0x1e3, 0x9, 0x1e3, 0x4, 0x1e4, 0x9, 0x1e4, 0x4, 0x1e5, 
       0x9, 0x1e5, 0x4, 0x1e6, 0x9, 0x1e6, 0x4, 0x1e7, 0x9, 0x1e7, 0x4, 
       0x1e8, 0x9, 0x1e8, 0x4, 0x1e9, 0x9, 0x1e9, 0x4, 0x1ea, 0x9, 0x1ea, 
       0x4, 0x1eb, 0x9, 0x1eb, 0x4, 0x1ec, 0x9, 0x1ec, 0x4, 0x1ed, 0x9, 
       0x1ed, 0x4, 0x1ee, 0x9, 0x1ee, 0x4, 0x1ef, 0x9, 0x1ef, 0x4, 0x1f0, 
       0x9, 0x1f0, 0x4, 0x1f1, 0x9, 0x1f1, 0x4, 0x1f2, 0x9, 0x1f2, 0x4, 
       0x1f3, 0x9, 0x1f3, 0x4, 0x1f4, 0x9, 0x1f4, 0x4, 0x1f5, 0x9, 0x1f5, 
       0x4, 0x1f6, 0x9, 0x1f6, 0x4, 0x1f7, 0x9, 0x1f7, 0x4, 0x1f8, 0x9, 
       0x1f8, 0x4, 0x1f9, 0x9, 0x1f9, 0x4, 0x1fa, 0x9, 0x1fa, 0x4, 0x1fb, 
       0x9, 0x1fb, 0x4, 0x1fc, 0x9, 0x1fc, 0x4, 0x1fd, 0x9, 0x1fd, 0x4, 
       0x1fe, 0x9, 0x1fe, 0x4, 0x1ff, 0x9, 0x1ff, 0x4, 0x200, 0x9, 0x200, 
       0x4, 0x201, 0x9, 0x201, 0x4, 0x202, 0x9, 0x202, 0x4, 0x203, 0x9, 
       0x203, 0x4, 0x204, 0x9, 0x204, 0x4, 0x205, 0x9, 0x205, 0x4, 0x206, 
       0x9, 0x206, 0x4, 0x207, 0x9, 0x207, 0x4, 0x208, 0x9, 0x208, 0x4, 
       0x209, 0x9, 0x209, 0x4, 0x20a, 0x9, 0x20a, 0x4, 0x20b, 0x9, 0x20b, 
       0x4, 0x20c, 0x9, 0x20c, 0x4, 0x20d, 0x9, 0x20d, 0x4, 0x20e, 0x9, 
       0x20e, 0x4, 0x20f, 0x9, 0x20f, 0x4, 0x210, 0x9, 0x210, 0x4, 0x211, 
       0x9, 0x211, 0x4, 0x212, 0x9, 0x212, 0x4, 0x213, 0x9, 0x213, 0x4, 
       0x214, 0x9, 0x214, 0x4, 0x215, 0x9, 0x215, 0x4, 0x216, 0x9, 0x216, 
       0x4, 0x217, 0x9, 0x217, 0x4, 0x218, 0x9, 0x218, 0x4, 0x219, 0x9, 
       0x219, 0x4, 0x21a, 0x9, 0x21a, 0x4, 0x21b, 0x9, 0x21b, 0x4, 0x21c, 
       0x9, 0x21c, 0x4, 0x21d, 0x9, 0x21d, 0x4, 0x21e, 0x9, 0x21e, 0x4, 
       0x21f, 0x9, 0x21f, 0x4, 0x220, 0x9, 0x220, 0x4, 0x221, 0x9, 0x221, 
       0x4, 0x222, 0x9, 0x222, 0x4, 0x223, 0x9, 0x223, 0x4, 0x224, 0x9, 
       0x224, 0x4, 0x225, 0x9, 0x225, 0x4, 0x226, 0x9, 0x226, 0x4, 0x227, 
       0x9, 0x227, 0x4, 0x228, 0x9, 0x228, 0x4, 0x229, 0x9, 0x229, 0x4, 
       0x22a, 0x9, 0x22a, 0x4, 0x22b, 0x9, 0x22b, 0x4, 0x22c, 0x9, 0x22c, 
       0x4, 0x22d, 0x9, 0x22d, 0x4, 0x22e, 0x9, 0x22e, 0x4, 0x22f, 0x9, 
       0x22f, 0x4, 0x230, 0x9, 0x230, 0x4, 0x231, 0x9, 0x231, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x5, 0x2, 0x4c4, 
       0xa, 0x2, 0x3, 0x2, 0x3, 0x2, 0x5, 0x2, 0x4c8, 0xa, 0x2, 0x3, 0x2, 
       0x5, 0x2, 0x4cb, 0xa, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 
       0x4d0, 0xa, 0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x4d4, 0xa, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x4d9, 0xa, 0x3, 0x3, 0x3, 0x5, 
       0x3, 0x4dc, 0xa, 0x3, 0x3, 0x4, 0x5, 0x4, 0x4df, 0xa, 0x4, 0x3, 0x4, 
       0x5, 0x4, 0x4e2, 0xa, 0x4, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x4e6, 0xa, 
       0x5, 0x3, 0x5, 0x5, 0x5, 0x4e9, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 
       0x5, 0x3, 0x5, 0x7, 0x5, 0x4ef, 0xa, 0x5, 0xc, 0x5, 0xe, 0x5, 0x4f2, 
       0xb, 0x5, 0x3, 0x5, 0x5, 0x5, 0x4f5, 0xa, 0x5, 0x3, 0x5, 0x5, 0x5, 
       0x4f8, 0xa, 0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x7, 0x6, 0x4fd, 0xa, 
       0x6, 0xc, 0x6, 0xe, 0x6, 0x500, 0xb, 0x6, 0x3, 0x7, 0x3, 0x7, 0x5, 
       0x7, 0x504, 0xa, 0x7, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x5, 0x8, 0x50b, 0xa, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x9, 0x5, 
       0x9, 0x510, 0xa, 0x9, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x514, 0xa, 0x9, 
       0x3, 0x9, 0x5, 0x9, 0x517, 0xa, 0x9, 0x3, 0x9, 0x3, 0x9, 0x3, 0xa, 
       0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x7, 
       0xa, 0x522, 0xa, 0xa, 0xc, 0xa, 0xe, 0xa, 0x525, 0xb, 0xa, 0x3, 0xb, 
       0x3, 0xb, 0x3, 0xb, 0x5, 0xb, 0x52a, 0xa, 0xb, 0x3, 0xc, 0x3, 0xc, 
       0x3, 0xc, 0x3, 0xc, 0x7, 0xc, 0x530, 0xa, 0xc, 0xc, 0xc, 0xe, 0xc, 
       0x533, 0xb, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 
       0x539, 0xa, 0xd, 0x3, 0xd, 0x5, 0xd, 0x53c, 0xa, 0xd, 0x3, 0xd, 0x3, 
       0xd, 0x5, 0xd, 0x540, 0xa, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 
       0xd, 0x545, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xf, 0x3, 0xf, 0x5, 
       0xf, 0x54b, 0xa, 0xf, 0x3, 0xf, 0x5, 0xf, 0x54e, 0xa, 0xf, 0x3, 0xf, 
       0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x7, 0xf, 0x554, 0xa, 0xf, 0xc, 0xf, 
       0xe, 0xf, 0x557, 0xb, 0xf, 0x3, 0xf, 0x5, 0xf, 0x55a, 0xa, 0xf, 0x3, 
       0xf, 0x5, 0xf, 0x55d, 0xa, 0xf, 0x3, 0x10, 0x5, 0x10, 0x560, 0xa, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x564, 0xa, 0x10, 0x3, 0x10, 
       0x5, 0x10, 0x567, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x11, 0x5, 
       0x11, 0x56c, 0xa, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
       0x3, 0x11, 0x5, 0x11, 0x573, 0xa, 0x11, 0x3, 0x11, 0x5, 0x11, 0x576, 
       0xa, 0x11, 0x3, 0x11, 0x5, 0x11, 0x579, 0xa, 0x11, 0x3, 0x12, 0x5, 
       0x12, 0x57c, 0xa, 0x12, 0x3, 0x12, 0x5, 0x12, 0x57f, 0xa, 0x12, 0x3, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x14, 0x5, 0x14, 0x586, 
       0xa, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x7, 0x14, 
       0x58c, 0xa, 0x14, 0xc, 0x14, 0xe, 0x14, 0x58f, 0xb, 0x14, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x7, 0x15, 0x595, 0xa, 0x15, 0xc, 
       0x15, 0xe, 0x15, 0x598, 0xb, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x5, 0x15, 0x59e, 0xa, 0x15, 0x3, 0x16, 0x3, 0x16, 0x3, 
       0x16, 0x5, 0x16, 0x5a3, 0xa, 0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 0x5ac, 0xa, 
       0x18, 0x3, 0x18, 0x5, 0x18, 0x5af, 0xa, 0x18, 0x3, 0x18, 0x5, 0x18, 
       0x5b2, 0xa, 0x18, 0x3, 0x18, 0x5, 0x18, 0x5b5, 0xa, 0x18, 0x3, 0x19, 
       0x5, 0x19, 0x5b8, 0xa, 0x19, 0x3, 0x19, 0x5, 0x19, 0x5bb, 0xa, 0x19, 
       0x3, 0x19, 0x5, 0x19, 0x5be, 0xa, 0x19, 0x3, 0x1a, 0x3, 0x1a, 0x3, 
       0x1a, 0x5, 0x1a, 0x5c3, 0xa, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x5c6, 0xa, 
       0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x5c9, 0xa, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 
       0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 
       0x3, 0x1b, 0x5, 0x1b, 0x5d4, 0xa, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x5, 
       0x1c, 0x5d8, 0xa, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x5dc, 0xa, 
       0x1c, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 
       0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x5e5, 0xa, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 
       0x3, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x5eb, 0xa, 0x1d, 0x3, 0x1e, 0x5, 
       0x1e, 0x5ee, 0xa, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x5f2, 0xa, 
       0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x5f5, 0xa, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 
       0x5f8, 0xa, 0x1e, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 
       0x1f, 0x5, 0x1f, 0x5ff, 0xa, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x5, 0x1f, 
       0x603, 0xa, 0x1f, 0x5, 0x1f, 0x605, 0xa, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 
       0x3, 0x1f, 0x5, 0x1f, 0x60a, 0xa, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x5, 
       0x1f, 0x60e, 0xa, 0x1f, 0x7, 0x1f, 0x610, 0xa, 0x1f, 0xc, 0x1f, 0xe, 
       0x1f, 0x613, 0xb, 0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 
       0x5, 0x20, 0x619, 0xa, 0x20, 0x5, 0x20, 0x61b, 0xa, 0x20, 0x3, 0x20, 
       0x3, 0x20, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x622, 0xa, 
       0x21, 0x3, 0x22, 0x3, 0x22, 0x7, 0x22, 0x626, 0xa, 0x22, 0xc, 0x22, 
       0xe, 0x22, 0x629, 0xb, 0x22, 0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x62d, 
       0xa, 0x22, 0x3, 0x22, 0x5, 0x22, 0x630, 0xa, 0x22, 0x3, 0x22, 0x5, 
       0x22, 0x633, 0xa, 0x22, 0x3, 0x22, 0x5, 0x22, 0x636, 0xa, 0x22, 0x3, 
       0x22, 0x5, 0x22, 0x639, 0xa, 0x22, 0x3, 0x22, 0x5, 0x22, 0x63c, 0xa, 
       0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 
       0x23, 0x7, 0x23, 0x644, 0xa, 0x23, 0xc, 0x23, 0xe, 0x23, 0x647, 0xb, 
       0x23, 0x5, 0x23, 0x649, 0xa, 0x23, 0x3, 0x23, 0x5, 0x23, 0x64c, 0xa, 
       0x23, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x7, 0x24, 0x652, 
       0xa, 0x24, 0xc, 0x24, 0xe, 0x24, 0x655, 0xb, 0x24, 0x3, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x65b, 0xa, 0x25, 0x3, 0x26, 
       0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x5, 0x26, 0x661, 0xa, 0x26, 0x3, 
       0x26, 0x5, 0x26, 0x664, 0xa, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 
       0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 
       0x3, 0x27, 0x5, 0x27, 0x670, 0xa, 0x27, 0x3, 0x27, 0x5, 0x27, 0x673, 
       0xa, 0x27, 0x3, 0x27, 0x5, 0x27, 0x676, 0xa, 0x27, 0x3, 0x28, 0x3, 
       0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x67d, 0xa, 0x28, 
       0x3, 0x28, 0x5, 0x28, 0x680, 0xa, 0x28, 0x3, 0x29, 0x3, 0x29, 0x3, 
       0x29, 0x3, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 
       0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x68c, 0xa, 0x2a, 0x3, 0x2b, 0x3, 0x2b, 
       0x5, 0x2b, 0x690, 0xa, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 
       0x2c, 0x695, 0xa, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x698, 0xa, 0x2c, 0x3, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x69d, 0xa, 0x2c, 0x3, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x6a3, 0xa, 0x2c, 0x3, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x6a8, 0xa, 0x2c, 0x3, 0x2c, 
       0x3, 0x2c, 0x6, 0x2c, 0x6ac, 0xa, 0x2c, 0xd, 0x2c, 0xe, 0x2c, 0x6ad, 
       0x5, 0x2c, 0x6b0, 0xa, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x6, 0x2c, 0x6b4, 
       0xa, 0x2c, 0xd, 0x2c, 0xe, 0x2c, 0x6b5, 0x5, 0x2c, 0x6b8, 0xa, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x6be, 0xa, 
       0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x6c1, 0xa, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 
       0x6c4, 0xa, 0x2c, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x6c9, 
       0xa, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x6cc, 0xa, 0x2d, 0x3, 0x2d, 0x3, 
       0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x6d1, 0xa, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 
       0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x6d9, 0xa, 
       0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 
       0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x6e2, 0xa, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 
       0x3, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x6e8, 0xa, 0x2d, 0x3, 0x2d, 0x5, 
       0x2d, 0x6eb, 0xa, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x6ee, 0xa, 0x2d, 0x3, 
       0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 
       0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x7, 0x30, 0x6fb, 
       0xa, 0x30, 0xc, 0x30, 0xe, 0x30, 0x6fe, 0xb, 0x30, 0x3, 0x31, 0x3, 
       0x31, 0x5, 0x31, 0x702, 0xa, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 
       0x7, 0x31, 0x707, 0xa, 0x31, 0xc, 0x31, 0xe, 0x31, 0x70a, 0xb, 0x31, 
       0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x5, 0x32, 
       0x711, 0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x33, 0x3, 
       0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 
       0x33, 0x5, 0x33, 0x71e, 0xa, 0x33, 0x3, 0x34, 0x3, 0x34, 0x3, 0x35, 
       0x3, 0x35, 0x5, 0x35, 0x724, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x7, 
       0x35, 0x728, 0xa, 0x35, 0xc, 0x35, 0xe, 0x35, 0x72b, 0xb, 0x35, 0x3, 
       0x36, 0x3, 0x36, 0x5, 0x36, 0x72f, 0xa, 0x36, 0x3, 0x36, 0x5, 0x36, 
       0x732, 0xa, 0x36, 0x3, 0x36, 0x5, 0x36, 0x735, 0xa, 0x36, 0x3, 0x37, 
       0x3, 0x37, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x39, 0x3, 0x39, 
       0x3, 0x39, 0x5, 0x39, 0x73f, 0xa, 0x39, 0x3, 0x3a, 0x3, 0x3a, 0x3, 
       0x3a, 0x7, 0x3a, 0x744, 0xa, 0x3a, 0xc, 0x3a, 0xe, 0x3a, 0x747, 0xb, 
       0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x7, 0x3b, 0x74b, 0xa, 0x3b, 0xc, 0x3b, 
       0xe, 0x3b, 0x74e, 0xb, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 
       0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x5, 0x3c, 0x756, 0xa, 0x3c, 0x3, 0x3c, 
       0x7, 0x3c, 0x759, 0xa, 0x3c, 0xc, 0x3c, 0xe, 0x3c, 0x75c, 0xb, 0x3c, 
       0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x760, 0xa, 0x3d, 0x3, 0x3d, 0x5, 
       0x3d, 0x763, 0xa, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x766, 0xa, 0x3d, 0x3, 
       0x3d, 0x5, 0x3d, 0x769, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 
       0x76d, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x5, 0x3d, 0x774, 0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x5, 0x3d, 0x77a, 0xa, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 0x3, 
       0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x7, 0x3e, 0x781, 0xa, 0x3e, 0xc, 0x3e, 
       0xe, 0x3e, 0x784, 0xb, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3f, 0x3, 
       0x3f, 0x3, 0x3f, 0x7, 0x3f, 0x78b, 0xa, 0x3f, 0xc, 0x3f, 0xe, 0x3f, 
       0x78e, 0xb, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x5, 0x40, 0x798, 0xa, 0x40, 
       0x5, 0x40, 0x79a, 0xa, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x7, 0x40, 0x7a0, 0xa, 0x40, 0xc, 0x40, 0xe, 0x40, 0x7a3, 0xb, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 
       0x41, 0x7aa, 0xa, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 
       0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 0x41, 0x7b3, 0xa, 0x41, 0x3, 
       0x42, 0x5, 0x42, 0x7b6, 0xa, 0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 0x42, 
       0x7ba, 0xa, 0x42, 0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x7be, 0xa, 0x43, 
       0x3, 0x43, 0x3, 0x43, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x7c4, 0xa, 
       0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x7ca, 
       0xa, 0x44, 0x3, 0x44, 0x5, 0x44, 0x7cd, 0xa, 0x44, 0x3, 0x45, 0x3, 
       0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 
       0x45, 0x7d6, 0xa, 0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x47, 
       0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x7, 0x47, 0x7e0, 0xa, 
       0x47, 0xc, 0x47, 0xe, 0x47, 0x7e3, 0xb, 0x47, 0x3, 0x47, 0x3, 0x47, 
       0x5, 0x47, 0x7e7, 0xa, 0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 
       0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x5, 0x49, 0x7f0, 0xa, 0x49, 
       0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x5, 0x49, 
       0x7f7, 0xa, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x7fb, 0xa, 0x4a, 
       0x3, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x7ff, 0xa, 0x4b, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x7, 0x4c, 0x805, 0xa, 0x4c, 0xc, 0x4c, 
       0xe, 0x4c, 0x808, 0xb, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 
       0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4f, 0x3, 
       0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 0x818, 
       0xa, 0x4f, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 
       0x81e, 0xa, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 
       0x50, 0x3, 0x50, 0x5, 0x50, 0x826, 0xa, 0x50, 0x3, 0x51, 0x3, 0x51, 
       0x3, 0x51, 0x3, 0x51, 0x7, 0x51, 0x82c, 0xa, 0x51, 0xc, 0x51, 0xe, 
       0x51, 0x82f, 0xb, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 
       0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 
       0x83a, 0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x6, 0x51, 0x83e, 0xa, 0x51, 
       0xd, 0x51, 0xe, 0x51, 0x83f, 0x5, 0x51, 0x842, 0xa, 0x51, 0x3, 0x51, 
       0x3, 0x51, 0x6, 0x51, 0x846, 0xa, 0x51, 0xd, 0x51, 0xe, 0x51, 0x847, 
       0x5, 0x51, 0x84a, 0xa, 0x51, 0x5, 0x51, 0x84c, 0xa, 0x51, 0x3, 0x52, 
       0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x851, 0xa, 0x52, 0x3, 0x52, 0x5, 
       0x52, 0x854, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 
       0x5, 0x52, 0x85a, 0xa, 0x52, 0x3, 0x53, 0x6, 0x53, 0x85d, 0xa, 0x53, 
       0xd, 0x53, 0xe, 0x53, 0x85e, 0x3, 0x54, 0x3, 0x54, 0x3, 0x55, 0x3, 
       0x55, 0x3, 0x55, 0x5, 0x55, 0x866, 0xa, 0x55, 0x3, 0x56, 0x3, 0x56, 
       0x3, 0x56, 0x3, 0x57, 0x3, 0x57, 0x5, 0x57, 0x86d, 0xa, 0x57, 0x3, 
       0x58, 0x3, 0x58, 0x3, 0x58, 0x7, 0x58, 0x872, 0xa, 0x58, 0xc, 0x58, 
       0xe, 0x58, 0x875, 0xb, 0x58, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 
       0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 
       0x59, 0x3, 0x59, 0x5, 0x59, 0x882, 0xa, 0x59, 0x3, 0x5a, 0x3, 0x5a, 
       0x5, 0x5a, 0x886, 0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x88a, 
       0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x88e, 0xa, 0x5a, 0x3, 
       0x5a, 0x5, 0x5a, 0x891, 0xa, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x894, 0xa, 
       0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x897, 0xa, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 
       0x89a, 0xa, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 
       0x5b, 0x5, 0x5b, 0x8a1, 0xa, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x8a4, 0xa, 
       0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x8a7, 0xa, 0x5b, 0x3, 0x5c, 0x5, 0x5c, 
       0x8aa, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x5, 0x5c, 0x8ae, 0xa, 0x5c, 
       0x3, 0x5c, 0x3, 0x5c, 0x5, 0x5c, 0x8b2, 0xa, 0x5c, 0x3, 0x5c, 0x3, 
       0x5c, 0x5, 0x5c, 0x8b6, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 
       0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 
       0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 
       0x5, 0x5c, 0x8c7, 0xa, 0x5c, 0x5, 0x5c, 0x8c9, 0xa, 0x5c, 0x3, 0x5d, 
       0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x8ce, 0xa, 0x5d, 0x3, 0x5d, 0x3, 
       0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 
       0x5d, 0x8d7, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 
       0x5, 0x5d, 0x8dd, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x8e1, 
       0xa, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5f, 
       0x5, 0x5f, 0x8e8, 0xa, 0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x8eb, 0xa, 0x5f, 
       0x3, 0x5f, 0x5, 0x5f, 0x8ee, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, 
       0x5f, 0x8f2, 0xa, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 
       0x5, 0x60, 0x8f8, 0xa, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 
       0x60, 0x3, 0x60, 0x5, 0x60, 0x8ff, 0xa, 0x60, 0x3, 0x61, 0x3, 0x61, 
       0x3, 0x61, 0x5, 0x61, 0x904, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 
       0x62, 0x3, 0x62, 0x5, 0x62, 0x90a, 0xa, 0x62, 0x3, 0x62, 0x5, 0x62, 
       0x90d, 0xa, 0x62, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x912, 
       0xa, 0x63, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x5, 0x64, 
       0x918, 0xa, 0x64, 0x3, 0x64, 0x5, 0x64, 0x91b, 0xa, 0x64, 0x3, 0x65, 
       0x3, 0x65, 0x5, 0x65, 0x91f, 0xa, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 
       0x65, 0x3, 0x65, 0x5, 0x65, 0x925, 0xa, 0x65, 0x7, 0x65, 0x927, 0xa, 
       0x65, 0xc, 0x65, 0xe, 0x65, 0x92a, 0xb, 0x65, 0x3, 0x66, 0x6, 0x66, 
       0x92d, 0xa, 0x66, 0xd, 0x66, 0xe, 0x66, 0x92e, 0x3, 0x67, 0x3, 0x67, 
       0x5, 0x67, 0x933, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x937, 
       0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 
       0x93d, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 
       0x67, 0x943, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 
       0x948, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x94c, 0xa, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x951, 0xa, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x5, 0x67, 0x955, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x5, 0x67, 0x959, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x967, 0xa, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 
       0x96f, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x979, 0xa, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x97d, 0xa, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x996, 0xa, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x5, 0x67, 0x9a4, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x5, 0x67, 0x9aa, 0xa, 0x67, 0x3, 0x68, 0x3, 0x68, 0x5, 0x68, 
       0x9ae, 0xa, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x5, 0x68, 0x9b3, 
       0xa, 0x68, 0x7, 0x68, 0x9b5, 0xa, 0x68, 0xc, 0x68, 0xe, 0x68, 0x9b8, 
       0xb, 0x68, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x9bc, 0xa, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x7, 0x69, 0x9c0, 0xa, 0x69, 0xc, 0x69, 0xe, 0x69, 
       0x9c3, 0xb, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x9c7, 0xa, 0x69, 
       0x3, 0x69, 0x5, 0x69, 0x9ca, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x7, 
       0x69, 0x9ce, 0xa, 0x69, 0xc, 0x69, 0xe, 0x69, 0x9d1, 0xb, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x5, 0x69, 0x9d5, 0xa, 0x69, 0x3, 0x69, 0x5, 0x69, 
       0x9d8, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x7, 0x69, 0x9dc, 0xa, 0x69, 
       0xc, 0x69, 0xe, 0x69, 0x9df, 0xb, 0x69, 0x3, 0x69, 0x5, 0x69, 0x9e2, 
       0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 
       0x9e8, 0xa, 0x69, 0x5, 0x69, 0x9ea, 0xa, 0x69, 0x3, 0x69, 0x5, 0x69, 
       0x9ed, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x7, 0x69, 0x9f1, 0xa, 0x69, 
       0xc, 0x69, 0xe, 0x69, 0x9f4, 0xb, 0x69, 0x3, 0x69, 0x5, 0x69, 0x9f7, 
       0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x9fc, 0xa, 
       0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0xa02, 
       0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0xa06, 0xa, 0x69, 0x5, 
       0x69, 0xa08, 0xa, 0x69, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x7, 0x6a, 
       0xa0d, 0xa, 0x6a, 0xc, 0x6a, 0xe, 0x6a, 0xa10, 0xb, 0x6a, 0x3, 0x6b, 
       0x3, 0x6b, 0x3, 0x6b, 0x5, 0x6b, 0xa15, 0xa, 0x6b, 0x3, 0x6c, 0x3, 
       0x6c, 0x3, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 
       0x6d, 0x3, 0x6d, 0x5, 0x6d, 0xa20, 0xa, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x5, 0x6e, 0xa25, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 
       0x6e, 0x5, 0x6e, 0xa2a, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0xa32, 0xa, 0x6e, 0x3, 
       0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0xa38, 0xa, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0xa3c, 0xa, 0x6e, 0x3, 0x6e, 0x3, 
       0x6e, 0x3, 0x6e, 0x5, 0x6e, 0xa41, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x7, 0x6e, 0xa48, 0xa, 0x6e, 0xc, 
       0x6e, 0xe, 0x6e, 0xa4b, 0xb, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x5, 0x6e, 0xa50, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x7, 0x6e, 0xa54, 
       0xa, 0x6e, 0xc, 0x6e, 0xe, 0x6e, 0xa57, 0xb, 0x6e, 0x3, 0x6e, 0x3, 
       0x6e, 0x3, 0x6e, 0x5, 0x6e, 0xa5c, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 
       0xa65, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 
       0x6e, 0xa6b, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0xa74, 0xa, 0x6e, 0x3, 
       0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 
       0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0xa80, 0xa, 0x6e, 
       0x3, 0x6f, 0x3, 0x6f, 0x5, 0x6f, 0xa84, 0xa, 0x6f, 0x3, 0x70, 0x3, 
       0x70, 0x3, 0x70, 0x7, 0x70, 0xa89, 0xa, 0x70, 0xc, 0x70, 0xe, 0x70, 
       0xa8c, 0xb, 0x70, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 0xa90, 0xa, 0x71, 
       0x3, 0x72, 0x3, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 
       0x5, 0x73, 0xa98, 0xa, 0x73, 0x3, 0x74, 0x3, 0x74, 0x5, 0x74, 0xa9c, 
       0xa, 0x74, 0x3, 0x74, 0x3, 0x74, 0x5, 0x74, 0xaa0, 0xa, 0x74, 0x3, 
       0x74, 0x3, 0x74, 0x5, 0x74, 0xaa4, 0xa, 0x74, 0x3, 0x75, 0x3, 0x75, 
       0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0xaab, 0xa, 0x75, 0x3, 
       0x75, 0x3, 0x75, 0x7, 0x75, 0xaaf, 0xa, 0x75, 0xc, 0x75, 0xe, 0x75, 
       0xab2, 0xb, 0x75, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 0xab6, 0xa, 0x76, 
       0x3, 0x76, 0x3, 0x76, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 0xabc, 0xa, 
       0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x78, 0x3, 0x78, 0x5, 0x78, 0xac2, 
       0xa, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 
       0xac8, 0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xacd, 
       0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 
       0xad3, 0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x7, 0x79, 0xad7, 0xa, 0x79, 
       0xc, 0x79, 0xe, 0x79, 0xada, 0xb, 0x79, 0x3, 0x7a, 0x3, 0x7a, 0x3, 
       0x7a, 0x5, 0x7a, 0xadf, 0xa, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x7, 0x7a, 
       0xae3, 0xa, 0x7a, 0xc, 0x7a, 0xe, 0x7a, 0xae6, 0xb, 0x7a, 0x3, 0x7b, 
       0x3, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 0xaeb, 0xa, 0x7b, 0x3, 0x7b, 0x7, 
       0x7b, 0xaee, 0xa, 0x7b, 0xc, 0x7b, 0xe, 0x7b, 0xaf1, 0xb, 0x7b, 0x3, 
       0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x5, 0x7c, 0xaf6, 0xa, 0x7c, 0x3, 0x7d, 
       0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 0xafc, 0xa, 0x7d, 0x3, 
       0x7d, 0x5, 0x7d, 0xaff, 0xa, 0x7d, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 
       0x5, 0x7e, 0xb04, 0xa, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7f, 0x3, 
       0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 
       0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 
       0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 
       0x80, 0x5, 0x80, 0xb1c, 0xa, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 
       0x3, 0x80, 0x5, 0x80, 0xb22, 0xa, 0x80, 0x5, 0x80, 0xb24, 0xa, 0x80, 
       0x3, 0x81, 0x3, 0x81, 0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb2a, 0xa, 
       0x82, 0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb2e, 0xa, 0x82, 0x3, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x5, 0x82, 0xb37, 0xa, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb3a, 0xa, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 
       0xb41, 0xa, 0x82, 0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb45, 0xa, 0x82, 
       0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 
       0xb4c, 0xa, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 
       0x83, 0x5, 0x83, 0xb53, 0xa, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x5, 0x83, 0xb58, 0xa, 0x83, 0x3, 0x83, 0x5, 0x83, 0xb5b, 0xa, 0x83, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0xb60, 0xa, 0x83, 0x3, 
       0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0xb67, 
       0xa, 0x83, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0xb6b, 0xa, 0x83, 0x3, 
       0x83, 0x3, 0x83, 0x5, 0x83, 0xb6f, 0xa, 0x83, 0x3, 0x84, 0x3, 0x84, 
       0x3, 0x84, 0x5, 0x84, 0xb74, 0xa, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 
       0x85, 0x3, 0x85, 0x5, 0x85, 0xb7a, 0xa, 0x85, 0x3, 0x85, 0x3, 0x85, 
       0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x5, 0x85, 0xb82, 0xa, 
       0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x7, 0x85, 0xb88, 
       0xa, 0x85, 0xc, 0x85, 0xe, 0x85, 0xb8b, 0xb, 0x85, 0x3, 0x85, 0x3, 
       0x85, 0x3, 0x85, 0x3, 0x85, 0x7, 0x85, 0xb91, 0xa, 0x85, 0xc, 0x85, 
       0xe, 0x85, 0xb94, 0xb, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x86, 0x3, 
       0x86, 0x3, 0x86, 0x3, 0x86, 0x7, 0x86, 0xb9c, 0xa, 0x86, 0xc, 0x86, 
       0xe, 0x86, 0xb9f, 0xb, 0x86, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x5, 
       0x87, 0xba4, 0xa, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x88, 0x3, 0x88, 
       0x5, 0x88, 0xbaa, 0xa, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 
       0x88, 0x5, 0x88, 0xbb0, 0xa, 0x88, 0x3, 0x88, 0x3, 0x88, 0x7, 0x88, 
       0xbb4, 0xa, 0x88, 0xc, 0x88, 0xe, 0x88, 0xbb7, 0xb, 0x88, 0x3, 0x88, 
       0x3, 0x88, 0x7, 0x88, 0xbbb, 0xa, 0x88, 0xc, 0x88, 0xe, 0x88, 0xbbe, 
       0xb, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x3, 0x89, 0x7, 0x89, 0xbc6, 0xa, 0x89, 0xc, 0x89, 0xe, 0x89, 0xbc9, 
       0xb, 0x89, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0xbce, 0xa, 
       0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x7, 0x8b, 0xbde, 0xa, 0x8b, 0xc, 0x8b, 
       0xe, 0x8b, 0xbe1, 0xb, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8c, 0x3, 
       0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 
       0x8c, 0x7, 0x8c, 0xbed, 0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 0xbf0, 0xb, 
       0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x5, 
       0x8d, 0xbf7, 0xa, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8e, 0x3, 0x8e, 
       0x3, 0x8e, 0x5, 0x8e, 0xbfe, 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 
       0x8e, 0x5, 0x8e, 0xc03, 0xa, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0xc06, 0xa, 
       0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0xc0b, 0xa, 0x8e, 
       0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 
       0x5, 0x8e, 0xc13, 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 
       0x8e, 0x5, 0x8e, 0xc19, 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 
       0xc1d, 0xa, 0x8e, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 
       0x8f, 0xc23, 0xa, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xc26, 0xa, 0x8f, 0x3, 
       0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xc2b, 0xa, 0x8f, 0x3, 0x8f, 
       0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 
       0xc33, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 
       0x8f, 0xc39, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0xc3d, 0xa, 
       0x8f, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 0xc42, 0xa, 0x90, 
       0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 0xc46, 0xa, 0x90, 0x3, 0x91, 0x3, 
       0x91, 0x5, 0x91, 0xc4a, 0xa, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 
       0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 
       0xc54, 0xa, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 0xc59, 
       0xa, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 0xc5d, 0xa, 0x91, 0x3, 
       0x91, 0x5, 0x91, 0xc60, 0xa, 0x91, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 
       0xc64, 0xa, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x5, 0x92, 0xc71, 0xa, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc74, 0xa, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc78, 0xa, 0x92, 0x3, 0x92, 
       0x5, 0x92, 0xc7b, 0xa, 0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc7f, 
       0xa, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc82, 0xa, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x5, 0x92, 0xc86, 0xa, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc89, 0xa, 
       0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc8d, 0xa, 0x92, 0x3, 0x92, 
       0x5, 0x92, 0xc90, 0xa, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc93, 0xa, 0x92, 
       0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc97, 0xa, 0x92, 0x3, 0x92, 0x5, 
       0x92, 0xc9a, 0xa, 0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 0x92, 0xc9e, 0xa, 
       0x92, 0x3, 0x92, 0x5, 0x92, 0xca1, 0xa, 0x92, 0x3, 0x93, 0x3, 0x93, 
       0x5, 0x93, 0xca5, 0xa, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0xcaf, 
       0xa, 0x93, 0x3, 0x93, 0x5, 0x93, 0xcb2, 0xa, 0x93, 0x3, 0x93, 0x3, 
       0x93, 0x3, 0x93, 0x5, 0x93, 0xcb7, 0xa, 0x93, 0x3, 0x93, 0x3, 0x93, 
       0x5, 0x93, 0xcbb, 0xa, 0x93, 0x3, 0x93, 0x5, 0x93, 0xcbe, 0xa, 0x93, 
       0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xcc2, 0xa, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xcc8, 0xa, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x5, 0x94, 0xccc, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xcd3, 0xa, 0x94, 0x3, 0x94, 
       0x3, 0x94, 0x5, 0x94, 0xcd7, 0xa, 0x94, 0x3, 0x94, 0x5, 0x94, 0xcda, 
       0xa, 0x94, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xcde, 0xa, 0x95, 0x3, 
       0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xce4, 0xa, 0x95, 
       0x3, 0x95, 0x5, 0x95, 0xce7, 0xa, 0x95, 0x3, 0x96, 0x3, 0x96, 0x3, 
       0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 
       0x96, 0x5, 0x96, 0xcf2, 0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 0xcf5, 0xa, 
       0x96, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xcf9, 0xa, 0x96, 0x3, 0x96, 
       0x5, 0x96, 0xcfc, 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xd00, 
       0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 0xd03, 0xa, 0x96, 0x3, 0x96, 0x3, 
       0x96, 0x5, 0x96, 0xd07, 0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 0xd0a, 0xa, 
       0x96, 0x3, 0x96, 0x5, 0x96, 0xd0d, 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 
       0x5, 0x96, 0xd11, 0xa, 0x96, 0x3, 0x96, 0x5, 0x96, 0xd14, 0xa, 0x96, 
       0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xd18, 0xa, 0x96, 0x3, 0x96, 0x5, 
       0x96, 0xd1b, 0xa, 0x96, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 
       0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x5, 0x97, 
       0xd26, 0xa, 0x97, 0x3, 0x97, 0x5, 0x97, 0xd29, 0xa, 0x97, 0x3, 0x97, 
       0x5, 0x97, 0xd2c, 0xa, 0x97, 0x3, 0x97, 0x3, 0x97, 0x5, 0x97, 0xd30, 
       0xa, 0x97, 0x3, 0x97, 0x5, 0x97, 0xd33, 0xa, 0x97, 0x3, 0x98, 0x3, 
       0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x5, 0x98, 0xd3b, 
       0xa, 0x98, 0x3, 0x98, 0x5, 0x98, 0xd3e, 0xa, 0x98, 0x3, 0x99, 0x3, 
       0x99, 0x5, 0x99, 0xd42, 0xa, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 
       0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 
       0x3, 0x99, 0x5, 0x99, 0xd4e, 0xa, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 
       0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xd55, 0xa, 0x9a, 0x3, 0x9a, 
       0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0xd5a, 0xa, 0x9a, 0x3, 0x9a, 0x3, 
       0x9a, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 
       0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x7, 0x9b, 0xd67, 0xa, 0x9b, 
       0xc, 0x9b, 0xe, 0x9b, 0xd6a, 0xb, 0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x3, 
       0x9c, 0x3, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x5, 0x9d, 0xd73, 
       0xa, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 0x7, 0x9e, 0xd77, 0xa, 0x9e, 0xc, 
       0x9e, 0xe, 0x9e, 0xd7a, 0xb, 0x9e, 0x3, 0x9e, 0x5, 0x9e, 0xd7d, 0xa, 
       0x9e, 0x3, 0x9e, 0x5, 0x9e, 0xd80, 0xa, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 
       0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x5, 0x9e, 0xd87, 0xa, 0x9e, 0x3, 
       0x9e, 0x7, 0x9e, 0xd8a, 0xa, 0x9e, 0xc, 0x9e, 0xe, 0x9e, 0xd8d, 0xb, 
       0x9e, 0x5, 0x9e, 0xd8f, 0xa, 0x9e, 0x3, 0x9f, 0x5, 0x9f, 0xd92, 0xa, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xd9e, 
       0xa, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xda8, 0xa, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xdad, 0xa, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xdb9, 0xa, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xdbd, 0xa, 0x9f, 0x3, 0xa0, 0x3, 0xa0, 
       0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa1, 0x5, 0xa1, 0xdc5, 0xa, 
       0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0xdd5, 0xa, 0xa3, 0x3, 0xa3, 
       0x5, 0xa3, 0xdd8, 0xa, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 
       0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 0xde0, 0xa, 0xa4, 0x3, 0xa4, 
       0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 
       0xde8, 0xa, 0xa4, 0x5, 0xa4, 0xdea, 0xa, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x5, 0xa5, 0xdf4, 0xa, 0xa5, 0x3, 0xa6, 0x3, 0xa6, 0x5, 0xa6, 0xdf8, 
       0xa, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 
       0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x7, 0xa9, 0xe03, 0xa, 
       0xa9, 0xc, 0xa9, 0xe, 0xa9, 0xe06, 0xb, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 
       0x3, 0xaa, 0x3, 0xaa, 0x5, 0xaa, 0xe0c, 0xa, 0xaa, 0x3, 0xaa, 0x5, 
       0xaa, 0xe0f, 0xa, 0xaa, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 
       0x3, 0xab, 0x5, 0xab, 0xe16, 0xa, 0xab, 0x5, 0xab, 0xe18, 0xa, 0xab, 
       0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x7, 0xac, 0xe1e, 0xa, 
       0xac, 0xc, 0xac, 0xe, 0xac, 0xe21, 0xb, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xad, 0x3, 0xad, 0x5, 0xad, 0xe27, 0xa, 0xad, 0x3, 0xae, 0x3, 
       0xae, 0x5, 0xae, 0xe2b, 0xa, 0xae, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 
       0x3, 0xae, 0x5, 0xae, 0xe31, 0xa, 0xae, 0x3, 0xaf, 0x3, 0xaf, 0x3, 
       0xb0, 0x5, 0xb0, 0xe36, 0xa, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 
       0x5, 0xb0, 0xe3b, 0xa, 0xb0, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb2, 0x3, 
       0xb2, 0x5, 0xb2, 0xe41, 0xa, 0xb2, 0x3, 0xb2, 0x7, 0xb2, 0xe44, 0xa, 
       0xb2, 0xc, 0xb2, 0xe, 0xb2, 0xe47, 0xb, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 
       0x5, 0xb3, 0xe4b, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 
       0xb3, 0xe50, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 
       0xe55, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe59, 0xa, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe5e, 0xa, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe63, 0xa, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe68, 0xa, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe6d, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x5, 0xb3, 0xe72, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x5, 0xb3, 0xe77, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x5, 0xb3, 0xe7c, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 
       0xb3, 0xe81, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 
       0xe86, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe8b, 
       0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe90, 0xa, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe95, 0xa, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xe9a, 0xa, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xea4, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xeaa, 0xa, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xeb0, 0xa, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xeb5, 0xa, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xebc, 0xa, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xec1, 0xa, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xec6, 0xa, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xecc, 0xa, 0xb3, 0x3, 
       0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 
       0xb4, 0x3, 0xb4, 0x7, 0xb4, 0xed6, 0xa, 0xb4, 0xc, 0xb4, 0xe, 0xb4, 
       0xed9, 0xb, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 
       0xb4, 0x5, 0xb4, 0xee0, 0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x7, 0xb4, 
       0xee4, 0xa, 0xb4, 0xc, 0xb4, 0xe, 0xb4, 0xee7, 0xb, 0xb4, 0x5, 0xb4, 
       0xee9, 0xa, 0xb4, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 
       0xb5, 0x5, 0xb5, 0xef0, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb6, 
       0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 
       0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x5, 0xb6, 
       0xf00, 0xa, 0xb6, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x5, 0xb7, 0xf05, 
       0xa, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x7, 0xb8, 
       0xf0b, 0xa, 0xb8, 0xc, 0xb8, 0xe, 0xb8, 0xf0e, 0xb, 0xb8, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 
       0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 
       0x5, 0xb9, 0xf1d, 0xa, 0xb9, 0x5, 0xb9, 0xf1f, 0xa, 0xb9, 0x3, 0xb9, 
       0x7, 0xb9, 0xf22, 0xa, 0xb9, 0xc, 0xb9, 0xe, 0xb9, 0xf25, 0xb, 0xb9, 
       0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x7, 0xb9, 0xf2b, 0xa, 
       0xb9, 0xc, 0xb9, 0xe, 0xb9, 0xf2e, 0xb, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 
       0x5, 0xb9, 0xf32, 0xa, 0xb9, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 
       0xba, 0xf37, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 
       0xf3c, 0xa, 0xba, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x7, 0xbb, 0xf41, 
       0xa, 0xbb, 0xc, 0xbb, 0xe, 0xbb, 0xf44, 0xb, 0xbb, 0x3, 0xbc, 0x5, 
       0xbc, 0xf47, 0xa, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xf4b, 0xa, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xf50, 0xa, 0xbc, 
       0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xf56, 0xa, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xf5c, 
       0xa, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xf61, 0xa, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xf66, 0xa, 0xbc, 
       0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xf6b, 0xa, 0xbc, 0x3, 
       0xbc, 0x5, 0xbc, 0xf6e, 0xa, 0xbc, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 
       0x7, 0xbd, 0xf73, 0xa, 0xbd, 0xc, 0xbd, 0xe, 0xbd, 0xf76, 0xb, 0xbd, 
       0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 
       0x5, 0xbe, 0xf7e, 0xa, 0xbe, 0x5, 0xbe, 0xf80, 0xa, 0xbe, 0x3, 0xbf, 
       0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x7, 0xbf, 0xf86, 0xa, 0xbf, 0xc, 
       0xbf, 0xe, 0xbf, 0xf89, 0xb, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 
       0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x7, 0xbf, 0xf91, 0xa, 0xbf, 0xc, 
       0xbf, 0xe, 0xbf, 0xf94, 0xb, 0xbf, 0x5, 0xbf, 0xf96, 0xa, 0xbf, 0x3, 
       0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x7, 0xbf, 0xf9c, 0xa, 0xbf, 
       0xc, 0xbf, 0xe, 0xbf, 0xf9f, 0xb, 0xbf, 0x5, 0xbf, 0xfa1, 0xa, 0xbf, 
       0x5, 0xbf, 0xfa3, 0xa, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x5, 0xc0, 0xfa9, 0xa, 0xc0, 0x3, 0xc1, 0x3, 0xc1, 0x5, 0xc1, 
       0xfad, 0xa, 0xc1, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 
       0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 
       0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x5, 0xc2, 0xfbd, 0xa, 0xc2, 
       0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x5, 0xc3, 
       0xfc4, 0xa, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 
       0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 
       0xc3, 0x5, 0xc3, 0xfd1, 0xa, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 
       0x5, 0xc3, 0xfd6, 0xa, 0xc3, 0x3, 0xc4, 0x5, 0xc4, 0xfd9, 0xa, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 
       0xfe0, 0xa, 0xc5, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 
       0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 
       0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0xff6, 0xa, 0xc8, 
       0x3, 0xc8, 0x5, 0xc8, 0xff9, 0xa, 0xc8, 0x3, 0xc9, 0x3, 0xc9, 0x3, 
       0xc9, 0x5, 0xc9, 0xffe, 0xa, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x7, 0xc9, 
       0x1002, 0xa, 0xc9, 0xc, 0xc9, 0xe, 0xc9, 0x1005, 0xb, 0xc9, 0x3, 
       0xc9, 0x3, 0xc9, 0x5, 0xc9, 0x1009, 0xa, 0xc9, 0x3, 0xc9, 0x5, 0xc9, 
       0x100c, 0xa, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x7, 
       0xca, 0x1012, 0xa, 0xca, 0xc, 0xca, 0xe, 0xca, 0x1015, 0xb, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x7, 0xca, 0x101a, 0xa, 0xca, 0xc, 
       0xca, 0xe, 0xca, 0x101d, 0xb, 0xca, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 
       0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x5, 0xcb, 
       0x1027, 0xa, 0xcb, 0x3, 0xcc, 0x3, 0xcc, 0x5, 0xcc, 0x102b, 0xa, 
       0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x6, 0xcc, 0x1031, 
       0xa, 0xcc, 0xd, 0xcc, 0xe, 0xcc, 0x1032, 0x6, 0xcc, 0x1035, 0xa, 
       0xcc, 0xd, 0xcc, 0xe, 0xcc, 0x1036, 0x3, 0xcc, 0x3, 0xcc, 0x6, 0xcc, 
       0x103b, 0xa, 0xcc, 0xd, 0xcc, 0xe, 0xcc, 0x103c, 0x5, 0xcc, 0x103f, 
       0xa, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcd, 0x3, 0xcd, 
       0x3, 0xcd, 0x3, 0xcd, 0x6, 0xcd, 0x1048, 0xa, 0xcd, 0xd, 0xcd, 0xe, 
       0xcd, 0x1049, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x6, 0xcd, 
       0x1050, 0xa, 0xcd, 0xd, 0xcd, 0xe, 0xcd, 0x1051, 0x7, 0xcd, 0x1054, 
       0xa, 0xcd, 0xc, 0xcd, 0xe, 0xcd, 0x1057, 0xb, 0xcd, 0x3, 0xcd, 0x3, 
       0xcd, 0x6, 0xcd, 0x105b, 0xa, 0xcd, 0xd, 0xcd, 0xe, 0xcd, 0x105c, 
       0x5, 0xcd, 0x105f, 0xa, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 
       0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x5, 0xd0, 0x106d, 0xa, 0xd0, 0x3, 0xd0, 
       0x3, 0xd0, 0x6, 0xd0, 0x1071, 0xa, 0xd0, 0xd, 0xd0, 0xe, 0xd0, 0x1072, 
       0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x5, 0xd0, 0x1078, 0xa, 0xd0, 0x3, 
       0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x5, 0xd1, 0x107d, 0xa, 0xd1, 0x3, 0xd1, 
       0x3, 0xd1, 0x6, 0xd1, 0x1081, 0xa, 0xd1, 0xd, 0xd1, 0xe, 0xd1, 0x1082, 
       0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x5, 0xd1, 
       0x108a, 0xa, 0xd1, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd3, 0x3, 
       0xd3, 0x3, 0xd3, 0x5, 0xd3, 0x1092, 0xa, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 
       0x3, 0xd3, 0x3, 0xd3, 0x6, 0xd3, 0x1098, 0xa, 0xd3, 0xd, 0xd3, 0xe, 
       0xd3, 0x1099, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x5, 0xd3, 0x109f, 
       0xa, 0xd3, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 
       0x10a5, 0xa, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd6, 0x3, 
       0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd7, 0x3, 
       0xd7, 0x5, 0xd7, 0x10b2, 0xa, 0xd7, 0x3, 0xd7, 0x5, 0xd7, 0x10b5, 
       0xa, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 
       0x7, 0xd7, 0x10bc, 0xa, 0xd7, 0xc, 0xd7, 0xe, 0xd7, 0x10bf, 0xb, 
       0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd9, 0x3, 0xd9, 0x3, 
       0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x5, 0xd9, 0x10c9, 0xa, 0xd9, 0x3, 0xda, 
       0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xdb, 
       0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 
       0x7, 0xdb, 0x10d8, 0xa, 0xdb, 0xc, 0xdb, 0xe, 0xdb, 0x10db, 0xb, 
       0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdc, 0x3, 0xdc, 0x5, 0xdc, 0x10e1, 
       0xa, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x7, 0xdc, 
       0x10e7, 0xa, 0xdc, 0xc, 0xdc, 0xe, 0xdc, 0x10ea, 0xb, 0xdc, 0x3, 
       0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x7, 0xdc, 0x10f1, 
       0xa, 0xdc, 0xc, 0xdc, 0xe, 0xdc, 0x10f4, 0xb, 0xdc, 0x5, 0xdc, 0x10f6, 
       0xa, 0xdc, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xde, 
       0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xdf, 0x3, 0xdf, 0x5, 0xdf, 
       0x1102, 0xa, 0xdf, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe2, 0x3, 0xe2, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x5, 0xe3, 0x110d, 
       0xa, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x5, 0xe3, 0x1115, 0xa, 0xe3, 0x3, 0xe4, 0x3, 0xe4, 0x5, 
       0xe4, 0x1119, 0xa, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 
       0x7, 0xe4, 0x111f, 0xa, 0xe4, 0xc, 0xe4, 0xe, 0xe4, 0x1122, 0xb, 
       0xe4, 0x5, 0xe4, 0x1124, 0xa, 0xe4, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 
       0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x7, 0xe5, 0x112c, 0xa, 0xe5, 0xc, 
       0xe5, 0xe, 0xe5, 0x112f, 0xb, 0xe5, 0x5, 0xe5, 0x1131, 0xa, 0xe5, 
       0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe7, 0x3, 0xe7, 
       0x5, 0xe7, 0x1139, 0xa, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 
       0xe7, 0x7, 0xe7, 0x113f, 0xa, 0xe7, 0xc, 0xe7, 0xe, 0xe7, 0x1142, 
       0xb, 0xe7, 0x3, 0xe8, 0x3, 0xe8, 0x5, 0xe8, 0x1146, 0xa, 0xe8, 0x3, 
       0xe8, 0x5, 0xe8, 0x1149, 0xa, 0xe8, 0x3, 0xe8, 0x5, 0xe8, 0x114c, 
       0xa, 0xe8, 0x3, 0xe8, 0x5, 0xe8, 0x114f, 0xa, 0xe8, 0x3, 0xe8, 0x3, 
       0xe8, 0x3, 0xe8, 0x3, 0xe8, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xea, 0x3, 
       0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x7, 0xea, 0x115d, 
       0xa, 0xea, 0xc, 0xea, 0xe, 0xea, 0x1160, 0xb, 0xea, 0x5, 0xea, 0x1162, 
       0xa, 0xea, 0x5, 0xea, 0x1164, 0xa, 0xea, 0x3, 0xeb, 0x3, 0xeb, 0x5, 
       0xeb, 0x1168, 0xa, 0xeb, 0x3, 0xeb, 0x5, 0xeb, 0x116b, 0xa, 0xeb, 
       0x3, 0xeb, 0x5, 0xeb, 0x116e, 0xa, 0xeb, 0x3, 0xec, 0x3, 0xec, 0x5, 
       0xec, 0x1172, 0xa, 0xec, 0x3, 0xec, 0x3, 0xec, 0x5, 0xec, 0x1176, 
       0xa, 0xec, 0x3, 0xec, 0x3, 0xec, 0x5, 0xec, 0x117a, 0xa, 0xec, 0x3, 
       0xec, 0x5, 0xec, 0x117d, 0xa, 0xec, 0x3, 0xec, 0x5, 0xec, 0x1180, 
       0xa, 0xec, 0x5, 0xec, 0x1182, 0xa, 0xec, 0x3, 0xed, 0x3, 0xed, 0x3, 
       0xed, 0x3, 0xee, 0x3, 0xee, 0x5, 0xee, 0x1189, 0xa, 0xee, 0x3, 0xef, 
       0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 
       0x3, 0xef, 0x7, 0xef, 0x1193, 0xa, 0xef, 0xc, 0xef, 0xe, 0xef, 0x1196, 
       0xb, 0xef, 0x5, 0xef, 0x1198, 0xa, 0xef, 0x3, 0xf0, 0x3, 0xf0, 0x3, 
       0xf0, 0x3, 0xf1, 0x3, 0xf1, 0x3, 0xf1, 0x3, 0xf1, 0x3, 0xf2, 0x3, 
       0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 
       0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x5, 0xf2, 0x11ab, 0xa, 0xf2, 0x5, 0xf2, 
       0x11ad, 0xa, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 
       0xf2, 0x3, 0xf2, 0x5, 0xf2, 0x11b5, 0xa, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 
       0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x5, 0xf2, 0x11bc, 0xa, 0xf2, 0x5, 
       0xf2, 0x11be, 0xa, 0xf2, 0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 
       0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x5, 0xf3, 0x11c7, 0xa, 0xf3, 0x3, 
       0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 
       0xf4, 0x5, 0xf4, 0x11d0, 0xa, 0xf4, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 
       0x3, 0xf6, 0x3, 0xf6, 0x5, 0xf6, 0x11d7, 0xa, 0xf6, 0x3, 0xf6, 0x3, 
       0xf6, 0x3, 0xf7, 0x5, 0xf7, 0x11dc, 0xa, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 
       0x3, 0xf8, 0x3, 0xf8, 0x5, 0xf8, 0x11e2, 0xa, 0xf8, 0x3, 0xf8, 0x5, 
       0xf8, 0x11e5, 0xa, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf9, 0x3, 0xf9, 
       0x5, 0xf9, 0x11eb, 0xa, 0xf9, 0x3, 0xf9, 0x5, 0xf9, 0x11ee, 0xa, 
       0xf9, 0x3, 0xf9, 0x5, 0xf9, 0x11f1, 0xa, 0xf9, 0x3, 0xfa, 0x3, 0xfa, 
       0x3, 0xfa, 0x7, 0xfa, 0x11f6, 0xa, 0xfa, 0xc, 0xfa, 0xe, 0xfa, 0x11f9, 
       0xb, 0xfa, 0x3, 0xfa, 0x5, 0xfa, 0x11fc, 0xa, 0xfa, 0x3, 0xfb, 0x3, 
       0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x5, 0xfb, 0x1202, 0xa, 0xfb, 0x3, 0xfc, 
       0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x5, 0xfc, 0x1209, 0xa, 
       0xfc, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 
       0xfd, 0x5, 0xfd, 0x1211, 0xa, 0xfd, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 
       0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x5, 0xfe, 0x1219, 0xa, 0xfe, 0x3, 
       0xfe, 0x5, 0xfe, 0x121c, 0xa, 0xfe, 0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 
       0x3, 0xff, 0x5, 0xff, 0x1222, 0xa, 0xff, 0x3, 0x100, 0x3, 0x100, 
       0x5, 0x100, 0x1226, 0xa, 0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 
       0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x101, 0x3, 0x101, 0x3, 
       0x101, 0x7, 0x101, 0x1231, 0xa, 0x101, 0xc, 0x101, 0xe, 0x101, 0x1234, 
       0xb, 0x101, 0x3, 0x102, 0x3, 0x102, 0x3, 0x102, 0x3, 0x102, 0x3, 
       0x102, 0x5, 0x102, 0x123b, 0xa, 0x102, 0x3, 0x103, 0x3, 0x103, 0x5, 
       0x103, 0x123f, 0xa, 0x103, 0x3, 0x103, 0x3, 0x103, 0x5, 0x103, 0x1243, 
       0xa, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 
       0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 
       0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 
       0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 
       0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x5, 0x103, 0x1271, 0xa, 0x103, 0x3, 0x104, 0x5, 0x104, 
       0x1274, 0xa, 0x104, 0x3, 0x104, 0x3, 0x104, 0x3, 0x105, 0x3, 0x105, 
       0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 
       0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x106, 
       0x5, 0x106, 0x1285, 0xa, 0x106, 0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 
       0x3, 0x107, 0x3, 0x107, 0x5, 0x107, 0x128c, 0xa, 0x107, 0x3, 0x107, 
       0x3, 0x107, 0x5, 0x107, 0x1290, 0xa, 0x107, 0x3, 0x107, 0x5, 0x107, 
       0x1293, 0xa, 0x107, 0x3, 0x107, 0x5, 0x107, 0x1296, 0xa, 0x107, 0x3, 
       0x107, 0x5, 0x107, 0x1299, 0xa, 0x107, 0x3, 0x108, 0x3, 0x108, 0x3, 
       0x108, 0x3, 0x108, 0x3, 0x108, 0x7, 0x108, 0x12a0, 0xa, 0x108, 0xc, 
       0x108, 0xe, 0x108, 0x12a3, 0xb, 0x108, 0x3, 0x109, 0x3, 0x109, 0x3, 
       0x109, 0x3, 0x109, 0x5, 0x109, 0x12a9, 0xa, 0x109, 0x3, 0x109, 0x7, 
       0x109, 0x12ac, 0xa, 0x109, 0xc, 0x109, 0xe, 0x109, 0x12af, 0xb, 0x109, 
       0x5, 0x109, 0x12b1, 0xa, 0x109, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 
       0x7, 0x10a, 0x12b6, 0xa, 0x10a, 0xc, 0x10a, 0xe, 0x10a, 0x12b9, 0xb, 
       0x10a, 0x3, 0x10b, 0x6, 0x10b, 0x12bc, 0xa, 0x10b, 0xd, 0x10b, 0xe, 
       0x10b, 0x12bd, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 
       0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x5, 0x10c, 
       0x12c9, 0xa, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 
       0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x5, 
       0x10c, 0x12d4, 0xa, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 
       0x10c, 0x5, 0x10c, 0x12da, 0xa, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 
       0x10c, 0x3, 0x10c, 0x5, 0x10c, 0x12e0, 0xa, 0x10c, 0x3, 0x10d, 0x3, 
       0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x5, 0x10d, 0x12e6, 0xa, 0x10d, 0x3, 
       0x10d, 0x3, 0x10d, 0x5, 0x10d, 0x12ea, 0xa, 0x10d, 0x3, 0x10d, 0x5, 
       0x10d, 0x12ed, 0xa, 0x10d, 0x3, 0x10d, 0x5, 0x10d, 0x12f0, 0xa, 0x10d, 
       0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x5, 0x10d, 0x12f6, 
       0xa, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 
       0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x5, 0x10d, 0x1300, 0xa, 
       0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 
       0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x7, 0x10d, 0x130a, 0xa, 0x10d, 
       0xc, 0x10d, 0xe, 0x10d, 0x130d, 0xb, 0x10d, 0x5, 0x10d, 0x130f, 0xa, 
       0x10d, 0x5, 0x10d, 0x1311, 0xa, 0x10d, 0x3, 0x10e, 0x3, 0x10e, 0x5, 
       0x10e, 0x1315, 0xa, 0x10e, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x7, 
       0x10f, 0x131a, 0xa, 0x10f, 0xc, 0x10f, 0xe, 0x10f, 0x131d, 0xb, 0x10f, 
       0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x5, 0x110, 0x1323, 
       0xa, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x7, 0x110, 0x1328, 
       0xa, 0x110, 0xc, 0x110, 0xe, 0x110, 0x132b, 0xb, 0x110, 0x3, 0x111, 
       0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 0x1332, 
       0xa, 0x111, 0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x7, 0x111, 0x1337, 
       0xa, 0x111, 0xc, 0x111, 0xe, 0x111, 0x133a, 0xb, 0x111, 0x3, 0x112, 
       0x3, 0x112, 0x3, 0x112, 0x3, 0x112, 0x5, 0x112, 0x1340, 0xa, 0x112, 
       0x3, 0x112, 0x3, 0x112, 0x3, 0x112, 0x7, 0x112, 0x1345, 0xa, 0x112, 
       0xc, 0x112, 0xe, 0x112, 0x1348, 0xb, 0x112, 0x3, 0x113, 0x3, 0x113, 
       0x3, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x3, 0x113, 0x3, 0x113, 0x7, 0x113, 0x1354, 0xa, 0x113, 0xc, 
       0x113, 0xe, 0x113, 0x1357, 0xb, 0x113, 0x3, 0x114, 0x3, 0x114, 0x3, 
       0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 
       0x7, 0x114, 0x1361, 0xa, 0x114, 0xc, 0x114, 0xe, 0x114, 0x1364, 0xb, 
       0x114, 0x5, 0x114, 0x1366, 0xa, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 
       0x114, 0x3, 0x114, 0x7, 0x114, 0x136c, 0xa, 0x114, 0xc, 0x114, 0xe, 
       0x114, 0x136f, 0xb, 0x114, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 
       0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 
       0x5, 0x115, 0x137a, 0xa, 0x115, 0x3, 0x116, 0x3, 0x116, 0x3, 0x116, 
       0x3, 0x116, 0x5, 0x116, 0x1380, 0xa, 0x116, 0x3, 0x116, 0x3, 0x116, 
       0x3, 0x116, 0x5, 0x116, 0x1385, 0xa, 0x116, 0x3, 0x116, 0x3, 0x116, 
       0x3, 0x116, 0x5, 0x116, 0x138a, 0xa, 0x116, 0x3, 0x117, 0x3, 0x117, 
       0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 
       0x117, 0x3, 0x117, 0x3, 0x117, 0x5, 0x117, 0x1396, 0xa, 0x117, 0x3, 
       0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x119, 0x3, 0x119, 
       0x3, 0x119, 0x7, 0x119, 0x139f, 0xa, 0x119, 0xc, 0x119, 0xe, 0x119, 
       0x13a2, 0xb, 0x119, 0x3, 0x11a, 0x3, 0x11a, 0x3, 0x11a, 0x7, 0x11a, 
       0x13a7, 0xa, 0x11a, 0xc, 0x11a, 0xe, 0x11a, 0x13aa, 0xb, 0x11a, 0x3, 
       0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 
       0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x5, 
       0x11b, 0x13b7, 0xa, 0x11b, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 
       0x11c, 0x3, 0x11c, 0x5, 0x11c, 0x13be, 0xa, 0x11c, 0x3, 0x11d, 0x3, 
       0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x5, 0x11d, 0x13c5, 0xa, 
       0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x5, 0x11d, 0x13c9, 0xa, 0x11d, 0x3, 
       0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x5, 0x11d, 0x13ce, 0xa, 0x11d, 0x3, 
       0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 
       0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x5, 0x11e, 0x13da, 
       0xa, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x5, 0x11e, 0x13de, 0xa, 0x11e, 
       0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x5, 0x11e, 0x13e3, 0xa, 0x11e, 
       0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 
       0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x5, 0x11e, 0x13ed, 0xa, 0x11e, 0x5, 
       0x11e, 0x13ef, 0xa, 0x11e, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 
       0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 
       0x13f9, 0xa, 0x11f, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 
       0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 0x5, 0x120, 0x1403, 
       0xa, 0x120, 0x3, 0x121, 0x3, 0x121, 0x3, 0x121, 0x3, 0x121, 0x5, 
       0x121, 0x1409, 0xa, 0x121, 0x3, 0x122, 0x3, 0x122, 0x3, 0x122, 0x3, 
       0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x5, 0x124, 0x1415, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 
       0x1418, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 
       0x5, 0x124, 0x141e, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 
       0x1422, 0xa, 0x124, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 0x125, 
       0x1427, 0xa, 0x125, 0x3, 0x126, 0x3, 0x126, 0x5, 0x126, 0x142b, 0xa, 
       0x126, 0x3, 0x126, 0x5, 0x126, 0x142e, 0xa, 0x126, 0x3, 0x126, 0x3, 
       0x126, 0x5, 0x126, 0x1432, 0xa, 0x126, 0x3, 0x126, 0x5, 0x126, 0x1435, 
       0xa, 0x126, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 0x5, 
       0x127, 0x143b, 0xa, 0x127, 0x3, 0x127, 0x5, 0x127, 0x143e, 0xa, 0x127, 
       0x3, 0x128, 0x3, 0x128, 0x5, 0x128, 0x1442, 0xa, 0x128, 0x3, 0x128, 
       0x5, 0x128, 0x1445, 0xa, 0x128, 0x3, 0x128, 0x3, 0x128, 0x3, 0x128, 
       0x5, 0x128, 0x144a, 0xa, 0x128, 0x3, 0x128, 0x3, 0x128, 0x5, 0x128, 
       0x144e, 0xa, 0x128, 0x3, 0x129, 0x3, 0x129, 0x5, 0x129, 0x1452, 0xa, 
       0x129, 0x3, 0x129, 0x3, 0x129, 0x3, 0x129, 0x5, 0x129, 0x1457, 0xa, 
       0x129, 0x3, 0x129, 0x5, 0x129, 0x145a, 0xa, 0x129, 0x3, 0x12a, 0x3, 
       0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12b, 0x3, 0x12b, 
       0x3, 0x12b, 0x3, 0x12c, 0x3, 0x12c, 0x3, 0x12c, 0x3, 0x12d, 0x3, 
       0x12d, 0x3, 0x12d, 0x3, 0x12e, 0x3, 0x12e, 0x3, 0x12e, 0x3, 0x12f, 
       0x3, 0x12f, 0x3, 0x12f, 0x3, 0x130, 0x3, 0x130, 0x5, 0x130, 0x1472, 
       0xa, 0x130, 0x3, 0x131, 0x3, 0x131, 0x3, 0x131, 0x3, 0x131, 0x3, 
       0x131, 0x3, 0x131, 0x3, 0x131, 0x3, 0x131, 0x3, 0x131, 0x3, 0x131, 
       0x3, 0x131, 0x3, 0x131, 0x5, 0x131, 0x1480, 0xa, 0x131, 0x3, 0x132, 
       0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x7, 0x132, 0x1486, 0xa, 0x132, 
       0xc, 0x132, 0xe, 0x132, 0x1489, 0xb, 0x132, 0x3, 0x133, 0x3, 0x133, 
       0x3, 0x133, 0x3, 0x133, 0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 
       0x134, 0x3, 0x135, 0x3, 0x135, 0x3, 0x135, 0x3, 0x135, 0x3, 0x135, 
       0x5, 0x135, 0x1498, 0xa, 0x135, 0x3, 0x135, 0x3, 0x135, 0x5, 0x135, 
       0x149c, 0xa, 0x135, 0x3, 0x135, 0x3, 0x135, 0x3, 0x135, 0x5, 0x135, 
       0x14a1, 0xa, 0x135, 0x3, 0x135, 0x5, 0x135, 0x14a4, 0xa, 0x135, 0x3, 
       0x136, 0x3, 0x136, 0x3, 0x136, 0x3, 0x136, 0x5, 0x136, 0x14aa, 0xa, 
       0x136, 0x3, 0x137, 0x3, 0x137, 0x3, 0x137, 0x5, 0x137, 0x14af, 0xa, 
       0x137, 0x3, 0x138, 0x3, 0x138, 0x3, 0x138, 0x3, 0x138, 0x5, 0x138, 
       0x14b5, 0xa, 0x138, 0x3, 0x138, 0x3, 0x138, 0x3, 0x139, 0x3, 0x139, 
       0x3, 0x139, 0x3, 0x139, 0x3, 0x139, 0x3, 0x13a, 0x3, 0x13a, 0x3, 
       0x13a, 0x3, 0x13a, 0x3, 0x13a, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 
       0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13c, 0x3, 0x13c, 0x3, 0x13c, 0x3, 
       0x13c, 0x3, 0x13c, 0x3, 0x13d, 0x3, 0x13d, 0x3, 0x13d, 0x3, 0x13d, 
       0x3, 0x13d, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 
       0x13e, 0x3, 0x13f, 0x3, 0x13f, 0x3, 0x13f, 0x3, 0x13f, 0x3, 0x13f, 
       0x3, 0x140, 0x3, 0x140, 0x5, 0x140, 0x14de, 0xa, 0x140, 0x3, 0x140, 
       0x3, 0x140, 0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 
       0x141, 0x5, 0x141, 0x14e7, 0xa, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 
       0x141, 0x3, 0x141, 0x5, 0x141, 0x14ed, 0xa, 0x141, 0x3, 0x141, 0x5, 
       0x141, 0x14f0, 0xa, 0x141, 0x3, 0x142, 0x3, 0x142, 0x3, 0x142, 0x5, 
       0x142, 0x14f5, 0xa, 0x142, 0x3, 0x142, 0x5, 0x142, 0x14f8, 0xa, 0x142, 
       0x3, 0x143, 0x3, 0x143, 0x3, 0x143, 0x3, 0x143, 0x3, 0x143, 0x3, 
       0x144, 0x3, 0x144, 0x3, 0x144, 0x3, 0x144, 0x5, 0x144, 0x1503, 0xa, 
       0x144, 0x3, 0x145, 0x3, 0x145, 0x3, 0x145, 0x3, 0x145, 0x3, 0x145, 
       0x3, 0x145, 0x3, 0x145, 0x3, 0x145, 0x6, 0x145, 0x150d, 0xa, 0x145, 
       0xd, 0x145, 0xe, 0x145, 0x150e, 0x5, 0x145, 0x1511, 0xa, 0x145, 0x5, 
       0x145, 0x1513, 0xa, 0x145, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 
       0x146, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x5, 0x147, 
       0x151d, 0xa, 0x147, 0x3, 0x147, 0x5, 0x147, 0x1520, 0xa, 0x147, 0x3, 
       0x148, 0x3, 0x148, 0x3, 0x148, 0x3, 0x149, 0x3, 0x149, 0x3, 0x149, 
       0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14a, 0x3, 
       0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14c, 
       0x3, 0x14c, 0x5, 0x14c, 0x1534, 0xa, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x7, 
       0x14d, 0x153d, 0xa, 0x14d, 0xc, 0x14d, 0xe, 0x14d, 0x1540, 0xb, 0x14d, 
       0x5, 0x14d, 0x1542, 0xa, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 
       0x5, 0x14d, 0x1547, 0xa, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 
       0x3, 0x14d, 0x5, 0x14d, 0x154d, 0xa, 0x14d, 0x5, 0x14d, 0x154f, 0xa, 
       0x14d, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14f, 0x3, 0x14f, 
       0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x5, 0x14f, 0x1559, 0xa, 0x14f, 
       0x3, 0x14f, 0x3, 0x14f, 0x5, 0x14f, 0x155d, 0xa, 0x14f, 0x3, 0x14f, 
       0x3, 0x14f, 0x3, 0x14f, 0x5, 0x14f, 0x1562, 0xa, 0x14f, 0x3, 0x14f, 
       0x5, 0x14f, 0x1565, 0xa, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 
       0x3, 0x14f, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x5, 0x151, 0x1575, 0xa, 0x151, 0x3, 0x152, 0x3, 0x152, 0x5, 0x152, 
       0x1579, 0xa, 0x152, 0x3, 0x152, 0x3, 0x152, 0x5, 0x152, 0x157d, 0xa, 
       0x152, 0x3, 0x153, 0x3, 0x153, 0x3, 0x153, 0x5, 0x153, 0x1582, 0xa, 
       0x153, 0x3, 0x153, 0x5, 0x153, 0x1585, 0xa, 0x153, 0x3, 0x154, 0x3, 
       0x154, 0x5, 0x154, 0x1589, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 
       0x154, 0x158d, 0xa, 0x154, 0x3, 0x155, 0x3, 0x155, 0x3, 0x155, 0x3, 
       0x155, 0x3, 0x155, 0x5, 0x155, 0x1594, 0xa, 0x155, 0x3, 0x155, 0x3, 
       0x155, 0x3, 0x155, 0x3, 0x155, 0x5, 0x155, 0x159a, 0xa, 0x155, 0x3, 
       0x155, 0x5, 0x155, 0x159d, 0xa, 0x155, 0x3, 0x156, 0x3, 0x156, 0x3, 
       0x156, 0x3, 0x156, 0x5, 0x156, 0x15a3, 0xa, 0x156, 0x3, 0x156, 0x3, 
       0x156, 0x5, 0x156, 0x15a7, 0xa, 0x156, 0x3, 0x157, 0x3, 0x157, 0x3, 
       0x157, 0x3, 0x157, 0x3, 0x157, 0x3, 0x157, 0x5, 0x157, 0x15af, 0xa, 
       0x157, 0x3, 0x157, 0x5, 0x157, 0x15b2, 0xa, 0x157, 0x3, 0x158, 0x3, 
       0x158, 0x3, 0x158, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x5, 0x159, 0x15bb, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 0x3, 
       0x159, 0x3, 0x159, 0x5, 0x159, 0x15c7, 0xa, 0x159, 0x3, 0x159, 0x5, 
       0x159, 0x15ca, 0xa, 0x159, 0x3, 0x159, 0x3, 0x159, 0x5, 0x159, 0x15ce, 
       0xa, 0x159, 0x3, 0x159, 0x5, 0x159, 0x15d1, 0xa, 0x159, 0x5, 0x159, 
       0x15d3, 0xa, 0x159, 0x3, 0x15a, 0x3, 0x15a, 0x5, 0x15a, 0x15d7, 0xa, 
       0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 
       0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15b, 0x3, 0x15b, 0x5, 0x15b, 0x15e2, 
       0xa, 0x15b, 0x3, 0x15c, 0x3, 0x15c, 0x5, 0x15c, 0x15e6, 0xa, 0x15c, 
       0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x7, 
       0x15d, 0x15ed, 0xa, 0x15d, 0xc, 0x15d, 0xe, 0x15d, 0x15f0, 0xb, 0x15d, 
       0x3, 0x15e, 0x3, 0x15e, 0x3, 0x15e, 0x3, 0x15e, 0x3, 0x15e, 0x3, 
       0x15e, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x7, 0x15f, 0x15fd, 0xa, 0x15f, 0xc, 0x15f, 0xe, 0x15f, 0x1600, 0xb, 
       0x15f, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x161, 
       0x3, 0x161, 0x5, 0x161, 0x1608, 0xa, 0x161, 0x3, 0x161, 0x3, 0x161, 
       0x3, 0x161, 0x5, 0x161, 0x160d, 0xa, 0x161, 0x3, 0x162, 0x3, 0x162, 
       0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x5, 
       0x162, 0x1616, 0xa, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 
       0x162, 0x5, 0x162, 0x161c, 0xa, 0x162, 0x3, 0x163, 0x3, 0x163, 0x3, 
       0x163, 0x3, 0x163, 0x5, 0x163, 0x1622, 0xa, 0x163, 0x3, 0x164, 0x3, 
       0x164, 0x3, 0x164, 0x3, 0x164, 0x3, 0x164, 0x3, 0x164, 0x3, 0x164, 
       0x5, 0x164, 0x162b, 0xa, 0x164, 0x3, 0x165, 0x3, 0x165, 0x3, 0x165, 
       0x3, 0x165, 0x5, 0x165, 0x1631, 0xa, 0x165, 0x3, 0x166, 0x3, 0x166, 
       0x5, 0x166, 0x1635, 0xa, 0x166, 0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 
       0x3, 0x167, 0x3, 0x167, 0x5, 0x167, 0x163c, 0xa, 0x167, 0x3, 0x167, 
       0x3, 0x167, 0x3, 0x167, 0x5, 0x167, 0x1641, 0xa, 0x167, 0x3, 0x167, 
       0x5, 0x167, 0x1644, 0xa, 0x167, 0x3, 0x167, 0x5, 0x167, 0x1647, 0xa, 
       0x167, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 
       0x3, 0x168, 0x5, 0x168, 0x164f, 0xa, 0x168, 0x3, 0x168, 0x3, 0x168, 
       0x3, 0x168, 0x7, 0x168, 0x1654, 0xa, 0x168, 0xc, 0x168, 0xe, 0x168, 
       0x1657, 0xb, 0x168, 0x5, 0x168, 0x1659, 0xa, 0x168, 0x3, 0x168, 0x3, 
       0x168, 0x5, 0x168, 0x165d, 0xa, 0x168, 0x3, 0x168, 0x5, 0x168, 0x1660, 
       0xa, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x5, 0x168, 0x1665, 
       0xa, 0x168, 0x5, 0x168, 0x1667, 0xa, 0x168, 0x3, 0x169, 0x3, 0x169, 
       0x3, 0x169, 0x3, 0x169, 0x5, 0x169, 0x166d, 0xa, 0x169, 0x3, 0x16a, 
       0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x3, 
       0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x1678, 0xa, 0x16a, 0x3, 
       0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x7, 0x16a, 0x167d, 0xa, 0x16a, 0xc, 
       0x16a, 0xe, 0x16a, 0x1680, 0xb, 0x16a, 0x5, 0x16a, 0x1682, 0xa, 0x16a, 
       0x3, 0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x1686, 0xa, 0x16a, 0x3, 0x16a, 
       0x5, 0x16a, 0x1689, 0xa, 0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x168c, 0xa, 
       0x16a, 0x3, 0x16b, 0x3, 0x16b, 0x3, 0x16b, 0x3, 0x16b, 0x3, 0x16b, 
       0x5, 0x16b, 0x1693, 0xa, 0x16b, 0x3, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 
       0x3, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x7, 
       0x16c, 0x169d, 0xa, 0x16c, 0xc, 0x16c, 0xe, 0x16c, 0x16a0, 0xb, 0x16c, 
       0x5, 0x16c, 0x16a2, 0xa, 0x16c, 0x3, 0x16d, 0x3, 0x16d, 0x3, 0x16d, 
       0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x7, 
       0x16e, 0x16ac, 0xa, 0x16e, 0xc, 0x16e, 0xe, 0x16e, 0x16af, 0xb, 0x16e, 
       0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 
       0x16e, 0x5, 0x16e, 0x16b7, 0xa, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x3, 
       0x16e, 0x5, 0x16e, 0x16bc, 0xa, 0x16e, 0x3, 0x16f, 0x3, 0x16f, 0x3, 
       0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x5, 0x16f, 0x16c4, 0xa, 
       0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x16f, 
       0x7, 0x16f, 0x16cb, 0xa, 0x16f, 0xc, 0x16f, 0xe, 0x16f, 0x16ce, 0xb, 
       0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x5, 0x16f, 0x16d2, 0xa, 0x16f, 0x3, 
       0x16f, 0x3, 0x16f, 0x5, 0x16f, 0x16d6, 0xa, 0x16f, 0x3, 0x170, 0x3, 
       0x170, 0x3, 0x170, 0x7, 0x170, 0x16db, 0xa, 0x170, 0xc, 0x170, 0xe, 
       0x170, 0x16de, 0xb, 0x170, 0x3, 0x170, 0x5, 0x170, 0x16e1, 0xa, 0x170, 
       0x3, 0x171, 0x3, 0x171, 0x5, 0x171, 0x16e5, 0xa, 0x171, 0x3, 0x171, 
       0x3, 0x171, 0x3, 0x171, 0x7, 0x171, 0x16ea, 0xa, 0x171, 0xc, 0x171, 
       0xe, 0x171, 0x16ed, 0xb, 0x171, 0x3, 0x171, 0x5, 0x171, 0x16f0, 0xa, 
       0x171, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 
       0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 
       0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 
       0x3, 0x172, 0x5, 0x172, 0x1703, 0xa, 0x172, 0x3, 0x172, 0x3, 0x172, 
       0x3, 0x172, 0x3, 0x172, 0x5, 0x172, 0x1709, 0xa, 0x172, 0x3, 0x173, 
       0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x7, 0x173, 0x1710, 
       0xa, 0x173, 0xc, 0x173, 0xe, 0x173, 0x1713, 0xb, 0x173, 0x3, 0x173, 
       0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 
       0x173, 0x3, 0x173, 0x7, 0x173, 0x171d, 0xa, 0x173, 0xc, 0x173, 0xe, 
       0x173, 0x1720, 0xb, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 
       0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 0x7, 0x173, 
       0x172a, 0xa, 0x173, 0xc, 0x173, 0xe, 0x173, 0x172d, 0xb, 0x173, 0x3, 
       0x173, 0x3, 0x173, 0x3, 0x173, 0x5, 0x173, 0x1732, 0xa, 0x173, 0x3, 
       0x174, 0x3, 0x174, 0x5, 0x174, 0x1736, 0xa, 0x174, 0x3, 0x174, 0x6, 
       0x174, 0x1739, 0xa, 0x174, 0xd, 0x174, 0xe, 0x174, 0x173a, 0x3, 0x175, 
       0x3, 0x175, 0x3, 0x175, 0x3, 0x175, 0x3, 0x175, 0x3, 0x175, 0x3, 
       0x175, 0x7, 0x175, 0x1744, 0xa, 0x175, 0xc, 0x175, 0xe, 0x175, 0x1747, 
       0xb, 0x175, 0x3, 0x176, 0x3, 0x176, 0x3, 0x176, 0x3, 0x176, 0x7, 
       0x176, 0x174d, 0xa, 0x176, 0xc, 0x176, 0xe, 0x176, 0x1750, 0xb, 0x176, 
       0x3, 0x176, 0x5, 0x176, 0x1753, 0xa, 0x176, 0x3, 0x177, 0x3, 0x177, 
       0x3, 0x177, 0x5, 0x177, 0x1758, 0xa, 0x177, 0x3, 0x177, 0x3, 0x177, 
       0x5, 0x177, 0x175c, 0xa, 0x177, 0x3, 0x177, 0x5, 0x177, 0x175f, 0xa, 
       0x177, 0x5, 0x177, 0x1761, 0xa, 0x177, 0x3, 0x178, 0x3, 0x178, 0x3, 
       0x178, 0x5, 0x178, 0x1766, 0xa, 0x178, 0x3, 0x178, 0x5, 0x178, 0x1769, 
       0xa, 0x178, 0x3, 0x179, 0x3, 0x179, 0x3, 0x17a, 0x3, 0x17a, 0x3, 
       0x17b, 0x3, 0x17b, 0x3, 0x17b, 0x3, 0x17b, 0x3, 0x17c, 0x3, 0x17c, 
       0x3, 0x17c, 0x3, 0x17c, 0x3, 0x17c, 0x5, 0x17c, 0x1778, 0xa, 0x17c, 
       0x3, 0x17d, 0x3, 0x17d, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 
       0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 
       0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 
       0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 
       0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 
       0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 
       0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 
       0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x3, 0x17e, 0x5, 0x17e, 0x17a4, 0xa, 
       0x17e, 0x3, 0x17f, 0x3, 0x17f, 0x5, 0x17f, 0x17a8, 0xa, 0x17f, 0x3, 
       0x180, 0x3, 0x180, 0x3, 0x180, 0x3, 0x180, 0x3, 0x180, 0x5, 0x180, 
       0x17af, 0xa, 0x180, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 
       0x3, 0x181, 0x5, 0x181, 0x17b6, 0xa, 0x181, 0x3, 0x182, 0x3, 0x182, 
       0x3, 0x182, 0x5, 0x182, 0x17bb, 0xa, 0x182, 0x3, 0x182, 0x5, 0x182, 
       0x17be, 0xa, 0x182, 0x3, 0x182, 0x3, 0x182, 0x5, 0x182, 0x17c2, 0xa, 
       0x182, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x7, 0x183, 
       0x17c8, 0xa, 0x183, 0xc, 0x183, 0xe, 0x183, 0x17cb, 0xb, 0x183, 0x3, 
       0x184, 0x3, 0x184, 0x5, 0x184, 0x17cf, 0xa, 0x184, 0x3, 0x185, 0x3, 
       0x185, 0x3, 0x185, 0x3, 0x186, 0x3, 0x186, 0x3, 0x186, 0x3, 0x187, 
       0x3, 0x187, 0x3, 0x187, 0x3, 0x187, 0x3, 0x187, 0x3, 0x187, 0x3, 
       0x187, 0x5, 0x187, 0x17de, 0xa, 0x187, 0x3, 0x188, 0x6, 0x188, 0x17e1, 
       0xa, 0x188, 0xd, 0x188, 0xe, 0x188, 0x17e2, 0x3, 0x189, 0x3, 0x189, 
       0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 
       0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 
       0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 
       0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x5, 0x18a, 
       0x17fc, 0xa, 0x18a, 0x3, 0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x5, 0x18b, 
       0x1801, 0xa, 0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x5, 0x18b, 
       0x1806, 0xa, 0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x5, 0x18b, 
       0x180b, 0xa, 0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x3, 0x18b, 0x5, 0x18b, 
       0x1810, 0xa, 0x18b, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18c, 0x7, 0x18c, 
       0x1815, 0xa, 0x18c, 0xc, 0x18c, 0xe, 0x18c, 0x1818, 0xb, 0x18c, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 
       0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 
       0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x5, 
       0x18d, 0x187d, 0xa, 0x18d, 0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18e, 0x3, 
       0x18e, 0x3, 0x18f, 0x3, 0x18f, 0x3, 0x190, 0x3, 0x190, 0x3, 0x190, 
       0x7, 0x190, 0x1888, 0xa, 0x190, 0xc, 0x190, 0xe, 0x190, 0x188b, 0xb, 
       0x190, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x5, 0x191, 
       0x1891, 0xa, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 
       0x3, 0x191, 0x5, 0x191, 0x1898, 0xa, 0x191, 0x3, 0x191, 0x3, 0x191, 
       0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x5, 0x191, 0x189f, 0xa, 0x191, 
       0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x5, 
       0x191, 0x18a6, 0xa, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 
       0x191, 0x3, 0x191, 0x5, 0x191, 0x18ad, 0xa, 0x191, 0x3, 0x191, 0x3, 
       0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x5, 0x191, 0x18b4, 0xa, 
       0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 
       0x5, 0x191, 0x18bb, 0xa, 0x191, 0x3, 0x191, 0x5, 0x191, 0x18be, 0xa, 
       0x191, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x7, 0x192, 0x18c3, 0xa, 
       0x192, 0xc, 0x192, 0xe, 0x192, 0x18c6, 0xb, 0x192, 0x3, 0x193, 0x3, 
       0x193, 0x3, 0x194, 0x3, 0x194, 0x3, 0x195, 0x3, 0x195, 0x3, 0x196, 
       0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 0x196, 0x3, 
       0x196, 0x5, 0x196, 0x18d5, 0xa, 0x196, 0x3, 0x197, 0x3, 0x197, 0x3, 
       0x198, 0x5, 0x198, 0x18da, 0xa, 0x198, 0x3, 0x198, 0x3, 0x198, 0x5, 
       0x198, 0x18de, 0xa, 0x198, 0x3, 0x199, 0x3, 0x199, 0x3, 0x19a, 0x3, 
       0x19a, 0x3, 0x19a, 0x3, 0x19b, 0x5, 0x19b, 0x18e6, 0xa, 0x19b, 0x3, 
       0x19b, 0x3, 0x19b, 0x5, 0x19b, 0x18ea, 0xa, 0x19b, 0x3, 0x19c, 0x5, 
       0x19c, 0x18ed, 0xa, 0x19c, 0x3, 0x19c, 0x3, 0x19c, 0x5, 0x19c, 0x18f1, 
       0xa, 0x19c, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19e, 0x3, 0x19e, 0x3, 
       0x19f, 0x3, 0x19f, 0x5, 0x19f, 0x18f9, 0xa, 0x19f, 0x3, 0x1a0, 0x3, 
       0x1a0, 0x3, 0x1a0, 0x3, 0x1a0, 0x5, 0x1a0, 0x18ff, 0xa, 0x1a0, 0x3, 
       0x1a1, 0x3, 0x1a1, 0x3, 0x1a2, 0x3, 0x1a2, 0x5, 0x1a2, 0x1905, 0xa, 
       0x1a2, 0x3, 0x1a3, 0x5, 0x1a3, 0x1908, 0xa, 0x1a3, 0x3, 0x1a3, 0x5, 
       0x1a3, 0x190b, 0xa, 0x1a3, 0x3, 0x1a3, 0x5, 0x1a3, 0x190e, 0xa, 0x1a3, 
       0x3, 0x1a3, 0x5, 0x1a3, 0x1911, 0xa, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 
       0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a5, 0x3, 0x1a5, 0x3, 
       0x1a5, 0x5, 0x1a5, 0x191b, 0xa, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a5, 0x3, 
       0x1a5, 0x5, 0x1a5, 0x1920, 0xa, 0x1a5, 0x3, 0x1a6, 0x3, 0x1a6, 0x3, 
       0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 
       0x3, 0x1a7, 0x3, 0x1a7, 0x5, 0x1a7, 0x192c, 0xa, 0x1a7, 0x3, 0x1a8, 
       0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 
       0x1a8, 0x5, 0x1a8, 0x1935, 0xa, 0x1a8, 0x3, 0x1a9, 0x3, 0x1a9, 0x3, 
       0x1aa, 0x3, 0x1aa, 0x3, 0x1aa, 0x7, 0x1aa, 0x193c, 0xa, 0x1aa, 0xc, 
       0x1aa, 0xe, 0x1aa, 0x193f, 0xb, 0x1aa, 0x3, 0x1ab, 0x3, 0x1ab, 0x5, 
       0x1ab, 0x1943, 0xa, 0x1ab, 0x3, 0x1ac, 0x3, 0x1ac, 0x3, 0x1ac, 0x7, 
       0x1ac, 0x1948, 0xa, 0x1ac, 0xc, 0x1ac, 0xe, 0x1ac, 0x194b, 0xb, 0x1ac, 
       0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 
       0x1ad, 0x3, 0x1ae, 0x3, 0x1ae, 0x3, 0x1ae, 0x5, 0x1ae, 0x1956, 0xa, 
       0x1ae, 0x3, 0x1ae, 0x3, 0x1ae, 0x3, 0x1af, 0x3, 0x1af, 0x3, 0x1b0, 
       0x3, 0x1b0, 0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b1, 0x5, 0x1b1, 0x1961, 
       0xa, 0x1b1, 0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b2, 0x5, 
       0x1b2, 0x1967, 0xa, 0x1b2, 0x5, 0x1b2, 0x1969, 0xa, 0x1b2, 0x3, 0x1b3, 
       0x3, 0x1b3, 0x3, 0x1b3, 0x5, 0x1b3, 0x196e, 0xa, 0x1b3, 0x3, 0x1b4, 
       0x3, 0x1b4, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b6, 0x3, 0x1b6, 0x3, 
       0x1b6, 0x3, 0x1b6, 0x5, 0x1b6, 0x1978, 0xa, 0x1b6, 0x3, 0x1b6, 0x5, 
       0x1b6, 0x197b, 0xa, 0x1b6, 0x3, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b7, 0x3, 
       0x1b7, 0x5, 0x1b7, 0x1981, 0xa, 0x1b7, 0x3, 0x1b7, 0x5, 0x1b7, 0x1984, 
       0xa, 0x1b7, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b9, 0x3, 0x1b9, 0x3, 
       0x1ba, 0x3, 0x1ba, 0x3, 0x1bb, 0x3, 0x1bb, 0x3, 0x1bb, 0x7, 0x1bb, 
       0x198f, 0xa, 0x1bb, 0xc, 0x1bb, 0xe, 0x1bb, 0x1992, 0xb, 0x1bb, 0x3, 
       0x1bc, 0x3, 0x1bc, 0x3, 0x1bc, 0x7, 0x1bc, 0x1997, 0xa, 0x1bc, 0xc, 
       0x1bc, 0xe, 0x1bc, 0x199a, 0xb, 0x1bc, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 
       0x1bd, 0x7, 0x1bd, 0x199f, 0xa, 0x1bd, 0xc, 0x1bd, 0xe, 0x1bd, 0x19a2, 
       0xb, 0x1bd, 0x3, 0x1be, 0x3, 0x1be, 0x3, 0x1bf, 0x3, 0x1bf, 0x3, 
       0x1c0, 0x3, 0x1c0, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c2, 0x3, 0x1c2, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c4, 0x3, 0x1c4, 0x3, 0x1c5, 0x3, 
       0x1c5, 0x3, 0x1c5, 0x3, 0x1c5, 0x3, 0x1c5, 0x3, 0x1c5, 0x3, 0x1c6, 
       0x3, 0x1c6, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x19bd, 
       0xa, 0x1c7, 0x3, 0x1c8, 0x3, 0x1c8, 0x3, 0x1c9, 0x3, 0x1c9, 0x5, 
       0x1c9, 0x19c3, 0xa, 0x1c9, 0x3, 0x1c9, 0x3, 0x1c9, 0x3, 0x1c9, 0x5, 
       0x1c9, 0x19c8, 0xa, 0x1c9, 0x3, 0x1c9, 0x5, 0x1c9, 0x19cb, 0xa, 0x1c9, 
       0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1cb, 0x3, 0x1cb, 0x3, 0x1cb, 0x5, 
       0x1cb, 0x19d2, 0xa, 0x1cb, 0x3, 0x1cc, 0x3, 0x1cc, 0x3, 0x1cd, 0x3, 
       0x1cd, 0x3, 0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 0x19da, 0xa, 0x1ce, 0x3, 
       0x1cf, 0x3, 0x1cf, 0x3, 0x1d0, 0x3, 0x1d0, 0x3, 0x1d0, 0x7, 0x1d0, 
       0x19e1, 0xa, 0x1d0, 0xc, 0x1d0, 0xe, 0x1d0, 0x19e4, 0xb, 0x1d0, 0x3, 
       0x1d1, 0x3, 0x1d1, 0x5, 0x1d1, 0x19e8, 0xa, 0x1d1, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d4, 0x3, 0x1d4, 
       0x3, 0x1d4, 0x3, 0x1d4, 0x3, 0x1d4, 0x5, 0x1d4, 0x19f4, 0xa, 0x1d4, 
       0x3, 0x1d4, 0x3, 0x1d4, 0x3, 0x1d4, 0x3, 0x1d4, 0x3, 0x1d4, 0x3, 
       0x1d4, 0x3, 0x1d4, 0x7, 0x1d4, 0x19fd, 0xa, 0x1d4, 0xc, 0x1d4, 0xe, 
       0x1d4, 0x1a00, 0xb, 0x1d4, 0x3, 0x1d5, 0x3, 0x1d5, 0x3, 0x1d6, 0x3, 
       0x1d6, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 
       0x3, 0x1d7, 0x5, 0x1d7, 0x1a0c, 0xa, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 
       0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 
       0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 
       0x7, 0x1d7, 0x1a1b, 0xa, 0x1d7, 0xc, 0x1d7, 0xe, 0x1d7, 0x1a1e, 0xb, 
       0x1d7, 0x3, 0x1d8, 0x3, 0x1d8, 0x3, 0x1d9, 0x3, 0x1d9, 0x5, 0x1d9, 
       0x1a24, 0xa, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x5, 0x1d9, 0x1a2b, 0xa, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x7, 0x1d9, 0x1a32, 0xa, 0x1d9, 
       0xc, 0x1d9, 0xe, 0x1d9, 0x1a35, 0xb, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x3, 0x1d9, 0x5, 0x1d9, 0x1a3b, 0xa, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 
       0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x5, 0x1d9, 0x1a49, 0xa, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x5, 0x1d9, 0x1a4f, 0xa, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x5, 0x1d9, 0x1a53, 0xa, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x5, 0x1d9, 0x1a59, 0xa, 0x1d9, 0x3, 0x1da, 0x3, 0x1da, 
       0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 
       0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 
       0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 
       0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 
       0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 
       0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 
       0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 
       0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x7, 0x1da, 
       0x1a88, 0xa, 0x1da, 0xc, 0x1da, 0xe, 0x1da, 0x1a8b, 0xb, 0x1da, 0x3, 
       0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 
       0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x5, 
       0x1db, 0x1a98, 0xa, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x5, 0x1db, 0x1a9c, 
       0xa, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x7, 
       0x1db, 0x1aa2, 0xa, 0x1db, 0xc, 0x1db, 0xe, 0x1db, 0x1aa5, 0xb, 0x1db, 
       0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x5, 0x1db, 0x1aaa, 0xa, 0x1db, 
       0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 
       0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 
       0x3, 0x1db, 0x3, 0x1db, 0x5, 0x1db, 0x1ab9, 0xa, 0x1db, 0x3, 0x1db, 
       0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x7, 
       0x1db, 0x1ac1, 0xa, 0x1db, 0xc, 0x1db, 0xe, 0x1db, 0x1ac4, 0xb, 0x1db, 
       0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dc, 0x5, 0x1dc, 0x1ac9, 0xa, 0x1dc, 
       0x3, 0x1dc, 0x3, 0x1dc, 0x5, 0x1dc, 0x1acd, 0xa, 0x1dc, 0x3, 0x1dd, 
       0x3, 0x1dd, 0x3, 0x1dd, 0x7, 0x1dd, 0x1ad2, 0xa, 0x1dd, 0xc, 0x1dd, 
       0xe, 0x1dd, 0x1ad5, 0xb, 0x1dd, 0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 
       0x5, 0x1de, 0x1ada, 0xa, 0x1de, 0x3, 0x1df, 0x3, 0x1df, 0x3, 0x1df, 
       0x5, 0x1df, 0x1adf, 0xa, 0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x3, 0x1df, 
       0x7, 0x1df, 0x1ae4, 0xa, 0x1df, 0xc, 0x1df, 0xe, 0x1df, 0x1ae7, 0xb, 
       0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1aea, 0xa, 0x1df, 0x3, 0x1df, 0x3, 
       0x1df, 0x5, 0x1df, 0x1aee, 0xa, 0x1df, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 
       0x1e1, 0x3, 0x1e1, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 
       0x3, 0x1e2, 0x3, 0x1e2, 0x5, 0x1e2, 0x1afa, 0xa, 0x1e2, 0x3, 0x1e3, 
       0x3, 0x1e3, 0x5, 0x1e3, 0x1afe, 0xa, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 
       0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x7, 0x1e3, 0x1b05, 0xa, 0x1e3, 
       0xc, 0x1e3, 0xe, 0x1e3, 0x1b08, 0xb, 0x1e3, 0x5, 0x1e3, 0x1b0a, 0xa, 
       0x1e3, 0x3, 0x1e3, 0x5, 0x1e3, 0x1b0d, 0xa, 0x1e3, 0x3, 0x1e3, 0x5, 
       0x1e3, 0x1b10, 0xa, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e4, 0x3, 
       0x1e4, 0x3, 0x1e4, 0x5, 0x1e4, 0x1b17, 0xa, 0x1e4, 0x3, 0x1e5, 0x3, 
       0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 
       0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x5, 
       0x1e5, 0x1b25, 0xa, 0x1e5, 0x3, 0x1e6, 0x3, 0x1e6, 0x3, 0x1e7, 0x3, 
       0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e8, 0x3, 0x1e8, 
       0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 
       0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x5, 0x1e8, 
       0x1b3a, 0xa, 0x1e8, 0x3, 0x1e9, 0x3, 0x1e9, 0x3, 0x1e9, 0x5, 0x1e9, 
       0x1b3f, 0xa, 0x1e9, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x5, 0x1ea, 
       0x1b44, 0xa, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x7, 0x1ea, 
       0x1b49, 0xa, 0x1ea, 0xc, 0x1ea, 0xe, 0x1ea, 0x1b4c, 0xb, 0x1ea, 0x3, 
       0x1ea, 0x5, 0x1ea, 0x1b4f, 0xa, 0x1ea, 0x3, 0x1ea, 0x5, 0x1ea, 0x1b52, 
       0xa, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x5, 0x1ea, 0x1b56, 0xa, 0x1ea, 
       0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 
       0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 
       0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x5, 0x1eb, 0x1b66, 0xa, 0x1eb, 
       0x3, 0x1eb, 0x3, 0x1eb, 0x5, 0x1eb, 0x1b6a, 0xa, 0x1eb, 0x3, 0x1eb, 
       0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 
       0x1eb, 0x5, 0x1eb, 0x1b73, 0xa, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 
       0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 
       0x3, 0x1eb, 0x3, 0x1eb, 0x5, 0x1eb, 0x1b7f, 0xa, 0x1eb, 0x3, 0x1eb, 
       0x5, 0x1eb, 0x1b82, 0xa, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x5, 0x1eb, 
       0x1b86, 0xa, 0x1eb, 0x3, 0x1ec, 0x3, 0x1ec, 0x3, 0x1ec, 0x5, 0x1ec, 
       0x1b8b, 0xa, 0x1ec, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 
       0x5, 0x1ed, 0x1b91, 0xa, 0x1ed, 0x3, 0x1ee, 0x3, 0x1ee, 0x3, 0x1ee, 
       0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 
       0x1ef, 0x3, 0x1ef, 0x5, 0x1ef, 0x1b9d, 0xa, 0x1ef, 0x3, 0x1f0, 0x3, 
       0x1f0, 0x3, 0x1f1, 0x3, 0x1f1, 0x3, 0x1f1, 0x3, 0x1f1, 0x3, 0x1f1, 
       0x3, 0x1f1, 0x3, 0x1f1, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 
       0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 
       0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x5, 
       0x1f2, 0x1bb6, 0xa, 0x1f2, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 0x1bba, 
       0xa, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 0x1bbe, 0xa, 0x1f3, 
       0x3, 0x1f3, 0x5, 0x1f3, 0x1bc1, 0xa, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 
       0x5, 0x1f3, 0x1bc5, 0xa, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 
       0x1bc9, 0xa, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 0x1bcd, 0xa, 
       0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 0x1bd2, 0xa, 
       0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 0x1bd6, 0xa, 0x1f3, 0x3, 
       0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 0x1bdb, 0xa, 0x1f3, 0x3, 
       0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 
       0x5, 0x1f3, 0x1be3, 0xa, 0x1f3, 0x5, 0x1f3, 0x1be5, 0xa, 0x1f3, 0x3, 
       0x1f4, 0x3, 0x1f4, 0x3, 0x1f4, 0x5, 0x1f4, 0x1bea, 0xa, 0x1f4, 0x3, 
       0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 
       0x3, 0x1f5, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 
       0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x5, 0x1f6, 0x1bfa, 0xa, 0x1f6, 0x3, 
       0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 
       0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x5, 0x1f6, 0x1c05, 0xa, 0x1f6, 
       0x3, 0x1f6, 0x3, 0x1f6, 0x5, 0x1f6, 0x1c09, 0xa, 0x1f6, 0x3, 0x1f7, 
       0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 
       0x1f7, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 
       0x7, 0x1f8, 0x1c17, 0xa, 0x1f8, 0xc, 0x1f8, 0xe, 0x1f8, 0x1c1a, 0xb, 
       0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x5, 0x1f8, 0x1c1e, 0xa, 0x1f8, 0x3, 
       0x1f8, 0x3, 0x1f8, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 
       0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1fa, 0x3, 
       0x1fa, 0x3, 0x1fa, 0x3, 0x1fa, 0x3, 0x1fa, 0x3, 0x1fb, 0x3, 0x1fb, 
       0x3, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 0x5, 0x1fb, 0x1c34, 0xa, 0x1fb, 
       0x3, 0x1fb, 0x5, 0x1fb, 0x1c37, 0xa, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 
       0x3, 0x1fc, 0x3, 0x1fc, 0x3, 0x1fc, 0x3, 0x1fc, 0x7, 0x1fc, 0x1c3f, 
       0xa, 0x1fc, 0xc, 0x1fc, 0xe, 0x1fc, 0x1c42, 0xb, 0x1fc, 0x3, 0x1fc, 
       0x3, 0x1fc, 0x3, 0x1fc, 0x5, 0x1fc, 0x1c47, 0xa, 0x1fc, 0x3, 0x1fd, 
       0x3, 0x1fd, 0x5, 0x1fd, 0x1c4b, 0xa, 0x1fd, 0x3, 0x1fd, 0x5, 0x1fd, 
       0x1c4e, 0xa, 0x1fd, 0x3, 0x1fe, 0x3, 0x1fe, 0x5, 0x1fe, 0x1c52, 0xa, 
       0x1fe, 0x3, 0x1ff, 0x3, 0x1ff, 0x3, 0x1ff, 0x3, 0x1ff, 0x5, 0x1ff, 
       0x1c58, 0xa, 0x1ff, 0x3, 0x1ff, 0x5, 0x1ff, 0x1c5b, 0xa, 0x1ff, 0x3, 
       0x1ff, 0x3, 0x1ff, 0x3, 0x1ff, 0x3, 0x1ff, 0x5, 0x1ff, 0x1c61, 0xa, 
       0x1ff, 0x3, 0x200, 0x3, 0x200, 0x3, 0x200, 0x3, 0x200, 0x3, 0x200, 
       0x7, 0x200, 0x1c68, 0xa, 0x200, 0xc, 0x200, 0xe, 0x200, 0x1c6b, 0xb, 
       0x200, 0x3, 0x200, 0x5, 0x200, 0x1c6e, 0xa, 0x200, 0x3, 0x200, 0x3, 
       0x200, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 
       0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 
       0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 
       0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 
       0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x5, 0x201, 
       0x1c8c, 0xa, 0x201, 0x3, 0x202, 0x3, 0x202, 0x3, 0x202, 0x3, 0x202, 
       0x3, 0x202, 0x3, 0x202, 0x5, 0x202, 0x1c94, 0xa, 0x202, 0x3, 0x202, 
       0x3, 0x202, 0x3, 0x202, 0x3, 0x202, 0x5, 0x202, 0x1c9a, 0xa, 0x202, 
       0x3, 0x202, 0x3, 0x202, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 
       0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 
       0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 
       0x203, 0x3, 0x203, 0x3, 0x203, 0x5, 0x203, 0x1caf, 0xa, 0x203, 0x3, 
       0x204, 0x3, 0x204, 0x5, 0x204, 0x1cb3, 0xa, 0x204, 0x3, 0x204, 0x6, 
       0x204, 0x1cb6, 0xa, 0x204, 0xd, 0x204, 0xe, 0x204, 0x1cb7, 0x3, 0x204, 
       0x5, 0x204, 0x1cbb, 0xa, 0x204, 0x3, 0x204, 0x3, 0x204, 0x3, 0x205, 
       0x3, 0x205, 0x3, 0x206, 0x3, 0x206, 0x3, 0x207, 0x3, 0x207, 0x3, 
       0x207, 0x3, 0x207, 0x3, 0x207, 0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 
       0x3, 0x209, 0x3, 0x209, 0x3, 0x209, 0x3, 0x20a, 0x3, 0x20a, 0x3, 
       0x20a, 0x3, 0x20b, 0x3, 0x20b, 0x3, 0x20c, 0x3, 0x20c, 0x3, 0x20c, 
       0x3, 0x20c, 0x3, 0x20c, 0x7, 0x20c, 0x1cd8, 0xa, 0x20c, 0xc, 0x20c, 
       0xe, 0x20c, 0x1cdb, 0xb, 0x20c, 0x3, 0x20d, 0x3, 0x20d, 0x5, 0x20d, 
       0x1cdf, 0xa, 0x20d, 0x3, 0x20d, 0x5, 0x20d, 0x1ce2, 0xa, 0x20d, 0x3, 
       0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1ce6, 0xa, 0x20e, 0x3, 0x20e, 0x5, 
       0x20e, 0x1ce9, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 
       0x20e, 0x1cee, 0xa, 0x20e, 0x5, 0x20e, 0x1cf0, 0xa, 0x20e, 0x3, 0x20e, 
       0x5, 0x20e, 0x1cf3, 0xa, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1cf6, 0xa, 
       0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1cfb, 0xa, 
       0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1cfe, 0xa, 0x20e, 0x3, 0x20e, 0x3, 
       0x20e, 0x5, 0x20e, 0x1d02, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 
       0x20e, 0x5, 0x20e, 0x1d07, 0xa, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d0a, 
       0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d0f, 
       0xa, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d12, 0xa, 0x20e, 0x3, 0x20e, 
       0x5, 0x20e, 0x1d15, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 
       0x1d19, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 
       0x1d1e, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d22, 0xa, 
       0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 
       0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 
       0x20e, 0x1d2e, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d32, 
       0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d36, 0xa, 0x20e, 
       0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d3a, 0xa, 0x20e, 0x3, 0x20e, 
       0x5, 0x20e, 0x1d3d, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 
       0x5, 0x20e, 0x1d42, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 
       0x1d46, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d4a, 0xa, 
       0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d4f, 0xa, 
       0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 
       0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d58, 0xa, 0x20e, 0x3, 0x20e, 
       0x5, 0x20e, 0x1d5b, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 
       0x1d5f, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d63, 0xa, 
       0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d66, 0xa, 0x20e, 0x3, 0x20e, 0x3, 
       0x20e, 0x5, 0x20e, 0x1d6a, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 
       0x20e, 0x1d6e, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 
       0x20e, 0x1d73, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 
       0x20e, 0x1d78, 0xa, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x1d7b, 0xa, 0x20e, 
       0x3, 0x20f, 0x3, 0x20f, 0x3, 0x20f, 0x3, 0x20f, 0x7, 0x20f, 0x1d81, 
       0xa, 0x20f, 0xc, 0x20f, 0xe, 0x20f, 0x1d84, 0xb, 0x20f, 0x3, 0x20f, 
       0x3, 0x20f, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x5, 0x210, 0x1d8b, 
       0xa, 0x210, 0x3, 0x211, 0x3, 0x211, 0x5, 0x211, 0x1d8f, 0xa, 0x211, 
       0x3, 0x212, 0x6, 0x212, 0x1d92, 0xa, 0x212, 0xd, 0x212, 0xe, 0x212, 
       0x1d93, 0x3, 0x213, 0x3, 0x213, 0x3, 0x213, 0x3, 0x213, 0x3, 0x213, 
       0x3, 0x213, 0x3, 0x214, 0x3, 0x214, 0x3, 0x214, 0x3, 0x214, 0x3, 
       0x215, 0x3, 0x215, 0x3, 0x215, 0x3, 0x215, 0x3, 0x215, 0x3, 0x215, 
       0x5, 0x215, 0x1da6, 0xa, 0x215, 0x3, 0x215, 0x3, 0x215, 0x3, 0x215, 
       0x3, 0x215, 0x5, 0x215, 0x1dac, 0xa, 0x215, 0x5, 0x215, 0x1dae, 0xa, 
       0x215, 0x3, 0x216, 0x3, 0x216, 0x5, 0x216, 0x1db2, 0xa, 0x216, 0x3, 
       0x216, 0x3, 0x216, 0x5, 0x216, 0x1db6, 0xa, 0x216, 0x3, 0x217, 0x3, 
       0x217, 0x5, 0x217, 0x1dba, 0xa, 0x217, 0x3, 0x217, 0x3, 0x217, 0x5, 
       0x217, 0x1dbe, 0xa, 0x217, 0x3, 0x218, 0x3, 0x218, 0x3, 0x218, 0x5, 
       0x218, 0x1dc3, 0xa, 0x218, 0x3, 0x219, 0x5, 0x219, 0x1dc6, 0xa, 0x219, 
       0x3, 0x219, 0x3, 0x219, 0x5, 0x219, 0x1dca, 0xa, 0x219, 0x3, 0x219, 
       0x3, 0x219, 0x3, 0x21a, 0x5, 0x21a, 0x1dcf, 0xa, 0x21a, 0x3, 0x21a, 
       0x3, 0x21a, 0x5, 0x21a, 0x1dd3, 0xa, 0x21a, 0x3, 0x21a, 0x3, 0x21a, 
       0x3, 0x21b, 0x5, 0x21b, 0x1dd8, 0xa, 0x21b, 0x3, 0x21b, 0x3, 0x21b, 
       0x5, 0x21b, 0x1ddc, 0xa, 0x21b, 0x3, 0x21b, 0x3, 0x21b, 0x3, 0x21c, 
       0x3, 0x21c, 0x3, 0x21c, 0x5, 0x21c, 0x1de3, 0xa, 0x21c, 0x3, 0x21d, 
       0x3, 0x21d, 0x3, 0x21d, 0x5, 0x21d, 0x1de8, 0xa, 0x21d, 0x3, 0x21d, 
       0x5, 0x21d, 0x1deb, 0xa, 0x21d, 0x3, 0x21e, 0x3, 0x21e, 0x3, 0x21f, 
       0x3, 0x21f, 0x3, 0x220, 0x3, 0x220, 0x3, 0x221, 0x3, 0x221, 0x3, 
       0x222, 0x3, 0x222, 0x3, 0x222, 0x3, 0x222, 0x3, 0x223, 0x3, 0x223, 
       0x3, 0x223, 0x3, 0x224, 0x3, 0x224, 0x3, 0x224, 0x3, 0x225, 0x3, 
       0x225, 0x3, 0x225, 0x3, 0x225, 0x7, 0x225, 0x1e03, 0xa, 0x225, 0xc, 
       0x225, 0xe, 0x225, 0x1e06, 0xb, 0x225, 0x5, 0x225, 0x1e08, 0xa, 0x225, 
       0x3, 0x225, 0x3, 0x225, 0x3, 0x226, 0x3, 0x226, 0x3, 0x226, 0x3, 
       0x226, 0x3, 0x227, 0x3, 0x227, 0x3, 0x227, 0x3, 0x228, 0x3, 0x228, 
       0x3, 0x229, 0x3, 0x229, 0x3, 0x22a, 0x3, 0x22a, 0x3, 0x22b, 0x3, 
       0x22b, 0x3, 0x22c, 0x3, 0x22c, 0x3, 0x22d, 0x3, 0x22d, 0x3, 0x22e, 
       0x3, 0x22e, 0x3, 0x22e, 0x3, 0x22e, 0x3, 0x22f, 0x3, 0x22f, 0x3, 
       0x22f, 0x3, 0x22f, 0x3, 0x22f, 0x5, 0x22f, 0x1e28, 0xa, 0x22f, 0x3, 
       0x22f, 0x3, 0x22f, 0x3, 0x22f, 0x3, 0x22f, 0x5, 0x22f, 0x1e2e, 0xa, 
       0x22f, 0x3, 0x230, 0x3, 0x230, 0x3, 0x230, 0x3, 0x230, 0x5, 0x230, 
       0x1e34, 0xa, 0x230, 0x3, 0x231, 0x3, 0x231, 0x3, 0x231, 0x7, 0x231, 
       0x1e39, 0xa, 0x231, 0xc, 0x231, 0xe, 0x231, 0x1e3c, 0xb, 0x231, 0x3, 
       0x231, 0x2, 0x7, 0x3c, 0x3a6, 0x3ac, 0x3b2, 0x3b4, 0x232, 0x2, 0x4, 
       0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 
       0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 
       0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 
       0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 
       0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 
       0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 
       0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 
       0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 
       0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 
       0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 
       0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 
       0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 
       0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 
       0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x132, 0x134, 
       0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 0x142, 0x144, 0x146, 0x148, 
       0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15a, 0x15c, 
       0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 0x16c, 0x16e, 0x170, 
       0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 0x17e, 0x180, 0x182, 0x184, 
       0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 0x192, 0x194, 0x196, 0x198, 
       0x19a, 0x19c, 0x19e, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 0x1a8, 0x1aa, 0x1ac, 
       0x1ae, 0x1b0, 0x1b2, 0x1b4, 0x1b6, 0x1b8, 0x1ba, 0x1bc, 0x1be, 0x1c0, 
       0x1c2, 0x1c4, 0x1c6, 0x1c8, 0x1ca, 0x1cc, 0x1ce, 0x1d0, 0x1d2, 0x1d4, 
       0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1de, 0x1e0, 0x1e2, 0x1e4, 0x1e6, 0x1e8, 
       0x1ea, 0x1ec, 0x1ee, 0x1f0, 0x1f2, 0x1f4, 0x1f6, 0x1f8, 0x1fa, 0x1fc, 
       0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c, 0x20e, 0x210, 
       0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 0x220, 0x222, 0x224, 
       0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 0x234, 0x236, 0x238, 
       0x23a, 0x23c, 0x23e, 0x240, 0x242, 0x244, 0x246, 0x248, 0x24a, 0x24c, 
       0x24e, 0x250, 0x252, 0x254, 0x256, 0x258, 0x25a, 0x25c, 0x25e, 0x260, 
       0x262, 0x264, 0x266, 0x268, 0x26a, 0x26c, 0x26e, 0x270, 0x272, 0x274, 
       0x276, 0x278, 0x27a, 0x27c, 0x27e, 0x280, 0x282, 0x284, 0x286, 0x288, 
       0x28a, 0x28c, 0x28e, 0x290, 0x292, 0x294, 0x296, 0x298, 0x29a, 0x29c, 
       0x29e, 0x2a0, 0x2a2, 0x2a4, 0x2a6, 0x2a8, 0x2aa, 0x2ac, 0x2ae, 0x2b0, 
       0x2b2, 0x2b4, 0x2b6, 0x2b8, 0x2ba, 0x2bc, 0x2be, 0x2c0, 0x2c2, 0x2c4, 
       0x2c6, 0x2c8, 0x2ca, 0x2cc, 0x2ce, 0x2d0, 0x2d2, 0x2d4, 0x2d6, 0x2d8, 
       0x2da, 0x2dc, 0x2de, 0x2e0, 0x2e2, 0x2e4, 0x2e6, 0x2e8, 0x2ea, 0x2ec, 
       0x2ee, 0x2f0, 0x2f2, 0x2f4, 0x2f6, 0x2f8, 0x2fa, 0x2fc, 0x2fe, 0x300, 
       0x302, 0x304, 0x306, 0x308, 0x30a, 0x30c, 0x30e, 0x310, 0x312, 0x314, 
       0x316, 0x318, 0x31a, 0x31c, 0x31e, 0x320, 0x322, 0x324, 0x326, 0x328, 
       0x32a, 0x32c, 0x32e, 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 0x33c, 
       0x33e, 0x340, 0x342, 0x344, 0x346, 0x348, 0x34a, 0x34c, 0x34e, 0x350, 
       0x352, 0x354, 0x356, 0x358, 0x35a, 0x35c, 0x35e, 0x360, 0x362, 0x364, 
       0x366, 0x368, 0x36a, 0x36c, 0x36e, 0x370, 0x372, 0x374, 0x376, 0x378, 
       0x37a, 0x37c, 0x37e, 0x380, 0x382, 0x384, 0x386, 0x388, 0x38a, 0x38c, 
       0x38e, 0x390, 0x392, 0x394, 0x396, 0x398, 0x39a, 0x39c, 0x39e, 0x3a0, 
       0x3a2, 0x3a4, 0x3a6, 0x3a8, 0x3aa, 0x3ac, 0x3ae, 0x3b0, 0x3b2, 0x3b4, 
       0x3b6, 0x3b8, 0x3ba, 0x3bc, 0x3be, 0x3c0, 0x3c2, 0x3c4, 0x3c6, 0x3c8, 
       0x3ca, 0x3cc, 0x3ce, 0x3d0, 0x3d2, 0x3d4, 0x3d6, 0x3d8, 0x3da, 0x3dc, 
       0x3de, 0x3e0, 0x3e2, 0x3e4, 0x3e6, 0x3e8, 0x3ea, 0x3ec, 0x3ee, 0x3f0, 
       0x3f2, 0x3f4, 0x3f6, 0x3f8, 0x3fa, 0x3fc, 0x3fe, 0x400, 0x402, 0x404, 
       0x406, 0x408, 0x40a, 0x40c, 0x40e, 0x410, 0x412, 0x414, 0x416, 0x418, 
       0x41a, 0x41c, 0x41e, 0x420, 0x422, 0x424, 0x426, 0x428, 0x42a, 0x42c, 
       0x42e, 0x430, 0x432, 0x434, 0x436, 0x438, 0x43a, 0x43c, 0x43e, 0x440, 
       0x442, 0x444, 0x446, 0x448, 0x44a, 0x44c, 0x44e, 0x450, 0x452, 0x454, 
       0x456, 0x458, 0x45a, 0x45c, 0x45e, 0x460, 0x2, 0x75, 0x5, 0x2, 0x96, 
       0x96, 0xfc, 0xfc, 0x152, 0x152, 0x3, 0x2, 0x2be, 0x2bf, 0x4, 0x2, 
       0x96, 0x96, 0x152, 0x152, 0x6, 0x2, 0xd7, 0xd7, 0x135, 0x135, 0x19c, 
       0x19c, 0x1dd, 0x1dd, 0x4, 0x2, 0xd7, 0xd7, 0x19c, 0x19c, 0x4, 0x2, 
       0x6b, 0x6b, 0x152, 0x152, 0x4, 0x2, 0x107, 0x107, 0x208, 0x208, 0x4, 
       0x2, 0x60, 0x60, 0xd3, 0xd3, 0x4, 0x2, 0x142, 0x142, 0x22b, 0x22b, 
       0x4, 0x2, 0x258, 0x258, 0x262, 0x262, 0x4, 0x2, 0x25, 0x25, 0xa3, 
       0xa4, 0x5, 0x2, 0xe1, 0xe1, 0x107, 0x107, 0x2b5, 0x2b5, 0x4, 0x2, 
       0x10c, 0x10c, 0x12f, 0x12f, 0x4, 0x2, 0x79, 0x79, 0x110, 0x110, 0x4, 
       0x2, 0x13c, 0x13c, 0x223, 0x223, 0x4, 0x2, 0x245, 0x245, 0x2b2, 0x2b2, 
       0x4, 0x2, 0x144, 0x144, 0x1ec, 0x1ec, 0x4, 0x2, 0x2c, 0x2c, 0x29b, 
       0x29b, 0x3, 0x2, 0x2d1, 0x2d2, 0x3, 0x2, 0x239, 0x23a, 0x4, 0x2, 
       0x49, 0x49, 0x219, 0x219, 0x4, 0x2, 0x14, 0x16, 0x92, 0x92, 0x5, 
       0x2, 0x92, 0x92, 0x19f, 0x19f, 0x2de, 0x2df, 0x4, 0x2, 0x84, 0x84, 
       0x232, 0x232, 0x4, 0x2, 0x92, 0x92, 0x313, 0x313, 0x4, 0x2, 0xa0, 
       0xa0, 0xb1, 0xb1, 0x3, 0x2, 0x12, 0x13, 0x5, 0x2, 0x17e, 0x17e, 0x28c, 
       0x28c, 0x2a6, 0x2a6, 0x4, 0x2, 0x94, 0x94, 0x121, 0x121, 0x4, 0x2, 
       0x4a, 0x4a, 0x146, 0x146, 0x4, 0x2, 0x1f, 0x1f, 0xa8, 0xa8, 0x4, 
       0x2, 0x1e, 0x1e, 0x10b, 0x10b, 0x4, 0x2, 0x279, 0x279, 0x2c7, 0x2c7, 
       0x5, 0x2, 0x43, 0x43, 0xf9, 0xf9, 0x22f, 0x22f, 0x4, 0x2, 0x2a2, 
       0x2a2, 0x2b9, 0x2b9, 0x4, 0x2, 0x120, 0x120, 0x2c8, 0x2c8, 0x5, 0x2, 
       0xe7, 0xe7, 0x255, 0x255, 0x2ad, 0x2ad, 0x3, 0x2, 0x273, 0x275, 0x4, 
       0x2, 0x55, 0x55, 0x289, 0x289, 0x8, 0x2, 0x66, 0x66, 0x69, 0x69, 
       0x92, 0x92, 0xac, 0xac, 0xd9, 0xd9, 0x1f7, 0x1f7, 0x5, 0x2, 0xd7, 
       0xd7, 0x135, 0x135, 0x19d, 0x19d, 0x4, 0x2, 0xa2, 0xa2, 0x17d, 0x17d, 
       0x5, 0x2, 0x10a, 0x10a, 0x111, 0x111, 0x1bf, 0x1bf, 0x4, 0x2, 0x7c, 
       0x7c, 0x26f, 0x26f, 0x4, 0x2, 0x1a8, 0x1a8, 0x22c, 0x22c, 0xd, 0x2, 
       0x4c, 0x4c, 0x57, 0x57, 0x62, 0x62, 0x70, 0x72, 0x82, 0x82, 0x17f, 
       0x17f, 0x190, 0x190, 0x21d, 0x21d, 0x234, 0x234, 0x27d, 0x27d, 0x28a, 
       0x28a, 0x5, 0x2, 0x75, 0x75, 0xc7, 0xc7, 0x2a7, 0x2a7, 0x5, 0x2, 
       0x1ac, 0x1ac, 0x1b0, 0x1b0, 0x313, 0x313, 0x3, 0x2, 0x286, 0x287, 
       0x4, 0x2, 0x116, 0x116, 0x286, 0x287, 0x4, 0x2, 0x38, 0x38, 0x270, 
       0x270, 0x4, 0x2, 0x12b, 0x12b, 0x21a, 0x21a, 0x4, 0x2, 0x1b2, 0x1b2, 
       0x2d5, 0x2d5, 0x4, 0x2, 0xe5, 0xe5, 0x29b, 0x29b, 0x5, 0x2, 0xe8, 
       0xe8, 0x1e1, 0x1e1, 0x286, 0x286, 0x4, 0x2, 0x149, 0x149, 0x2af, 
       0x2af, 0x4, 0x2, 0x92, 0x92, 0x1b7, 0x1b7, 0x4, 0x2, 0x2a4, 0x2a4, 
       0x313, 0x313, 0x4, 0x2, 0x9a, 0x9b, 0xca, 0xca, 0x4, 0x2, 0x85, 0x85, 
       0x233, 0x233, 0x4, 0x2, 0x10c, 0x10d, 0x130, 0x130, 0x4, 0x2, 0xe5, 
       0xe5, 0x10a, 0x10a, 0x4, 0x2, 0x3b, 0x3b, 0x154, 0x154, 0x4, 0x2, 
       0x18f, 0x18f, 0x276, 0x276, 0x4, 0x2, 0xf1, 0xf1, 0x243, 0x243, 0x6, 
       0x2, 0x90, 0x90, 0x11d, 0x11d, 0x1f2, 0x1f2, 0x27c, 0x27c, 0x4, 0x2, 
       0x146, 0x146, 0x1a3, 0x1a3, 0x4, 0x2, 0xcc, 0xcc, 0x1ea, 0x1ea, 0x4, 
       0x2, 0x285, 0x285, 0x2b6, 0x2b6, 0x4, 0x2, 0x6d, 0x6d, 0x1e9, 0x1e9, 
       0x4, 0x2, 0x10, 0x11, 0x12c, 0x12c, 0x4, 0x2, 0x125, 0x125, 0x264, 
       0x264, 0x4, 0x2, 0x25c, 0x25c, 0x25e, 0x25e, 0x4, 0x2, 0x1c, 0x1c, 
       0x1a6, 0x1a6, 0x4, 0x2, 0x4, 0x11, 0x13, 0x1a, 0x3, 0x2, 0x30f, 0x310, 
       0x4, 0x2, 0x87, 0x87, 0x293, 0x294, 0x4, 0x2, 0xcf, 0xcf, 0x2a0, 
       0x2a0, 0x93, 0x2, 0x1c, 0x1e, 0x20, 0x24, 0x27, 0x27, 0x2a, 0x2a, 
       0x2e, 0x2e, 0x30, 0x36, 0x38, 0x38, 0x3c, 0x3d, 0x3f, 0x41, 0x43, 
       0x44, 0x46, 0x47, 0x4a, 0x4a, 0x4c, 0x4d, 0x4f, 0x50, 0x53, 0x53, 
       0x55, 0x5c, 0x5e, 0x5e, 0x60, 0x6b, 0x6d, 0x6e, 0x70, 0x74, 0x77, 
       0x77, 0x7c, 0x7c, 0x82, 0x83, 0x86, 0x89, 0x8e, 0x8e, 0x93, 0x95, 
       0x97, 0x97, 0x9c, 0x9c, 0x9e, 0xa2, 0xa6, 0xa6, 0xaa, 0xac, 0xb1, 
       0xb1, 0xb3, 0xbd, 0xbf, 0xc1, 0xc3, 0xc5, 0xc8, 0xc9, 0xcb, 0xce, 
       0xd0, 0xd1, 0xd3, 0xd7, 0xd9, 0xd9, 0xdd, 0xdf, 0xe3, 0xe3, 0xe6, 
       0xe6, 0xe9, 0xe9, 0xeb, 0xed, 0xef, 0xf1, 0xf3, 0xf3, 0xf7, 0xf9, 
       0xfb, 0xfb, 0xfd, 0x101, 0x105, 0x105, 0x108, 0x109, 0x10b, 0x10b, 
       0x10d, 0x10d, 0x10f, 0x10f, 0x114, 0x116, 0x120, 0x122, 0x125, 0x126, 
       0x128, 0x129, 0x12c, 0x12c, 0x12e, 0x12e, 0x131, 0x131, 0x134, 0x135, 
       0x13b, 0x13b, 0x13d, 0x13e, 0x143, 0x144, 0x146, 0x146, 0x14a, 0x14d, 
       0x153, 0x155, 0x157, 0x16a, 0x16c, 0x16f, 0x172, 0x178, 0x17c, 0x180, 
       0x182, 0x183, 0x186, 0x186, 0x188, 0x188, 0x18a, 0x193, 0x195, 0x19f, 
       0x1a1, 0x1a2, 0x1a7, 0x1a8, 0x1aa, 0x1aa, 0x1ac, 0x1af, 0x1b1, 0x1b3, 
       0x1b7, 0x1b7, 0x1b9, 0x1b9, 0x1bc, 0x1bc, 0x1be, 0x1be, 0x1c3, 0x1c7, 
       0x1c9, 0x1c9, 0x1cb, 0x1cd, 0x1cf, 0x1d9, 0x1db, 0x1dd, 0x1df, 0x1e0, 
       0x1e2, 0x1e6, 0x1e8, 0x1eb, 0x1f0, 0x1f0, 0x1f3, 0x1f4, 0x1f6, 0x1f8, 
       0x1fb, 0x1ff, 0x201, 0x202, 0x204, 0x205, 0x207, 0x207, 0x209, 0x210, 
       0x212, 0x213, 0x215, 0x218, 0x21a, 0x21b, 0x21d, 0x221, 0x225, 0x229, 
       0x22c, 0x22d, 0x22f, 0x231, 0x234, 0x23a, 0x23c, 0x23c, 0x240, 0x243, 
       0x245, 0x245, 0x247, 0x247, 0x249, 0x24a, 0x24c, 0x24d, 0x24f, 0x254, 
       0x258, 0x258, 0x25c, 0x25e, 0x260, 0x260, 0x262, 0x262, 0x264, 0x26d, 
       0x26f, 0x270, 0x272, 0x278, 0x27b, 0x284, 0x287, 0x28c, 0x28e, 0x28f, 
       0x291, 0x296, 0x29a, 0x29a, 0x29d, 0x29d, 0x29f, 0x29f, 0x2a1, 0x2a6, 
       0x2a8, 0x2ab, 0x2ae, 0x2ae, 0x2b1, 0x2b1, 0x2b3, 0x2b3, 0x2b6, 0x2b8, 
       0x2bd, 0x2be, 0x2c3, 0x2c3, 0x2c5, 0x2c6, 0x2c8, 0x2cc, 0x2d2, 0x2d4, 
       0x2d6, 0x2d9, 0x2db, 0x2db, 0x6, 0x2, 0xf1, 0xf1, 0x146, 0x146, 0x1cf, 
       0x1d0, 0x243, 0x243, 0x4, 0x2, 0x21, 0x21, 0x37, 0x37, 0x5, 0x2, 
       0x98, 0x98, 0x113, 0x113, 0x2b2, 0x2b2, 0x4, 0x2, 0xdf, 0xdf, 0x1d8, 
       0x1d8, 0x5, 0x2, 0x29, 0x29, 0x1ba, 0x1ba, 0x2e0, 0x2e1, 0x4, 0x2, 
       0x1a0, 0x1a0, 0x2e2, 0x2e2, 0x6, 0x2, 0xcf, 0xcf, 0x1a6, 0x1a6, 0x2a0, 
       0x2a0, 0x2ae, 0x2ae, 0x4, 0x2, 0x25, 0x25, 0x2a, 0x2a, 0x3, 0x2, 
       0x2f4, 0x2f9, 0x3, 0x2, 0x308, 0x309, 0x4, 0x2, 0x4, 0x7, 0x34, 0x34, 
       0x4, 0x2, 0x1ec, 0x1ec, 0x22b, 0x22b, 0x7, 0x2, 0x7b, 0x7b, 0x99, 
       0x99, 0x1ce, 0x1ce, 0x1ed, 0x1ed, 0x22e, 0x22e, 0x4, 0x2, 0x133, 
       0x133, 0x138, 0x138, 0x4, 0x2, 0xd8, 0xd8, 0x136, 0x136, 0x4, 0x2, 
       0xd7, 0xd7, 0x135, 0x135, 0x4, 0x2, 0x305, 0x305, 0x313, 0x313, 0x4, 
       0x2, 0x107, 0x107, 0x216, 0x216, 0x5, 0x2, 0xcc, 0xcc, 0x1ea, 0x1ea, 
       0x2b8, 0x2b8, 0x3, 0x2, 0xb, 0xc, 0x5, 0x2, 0x42, 0x42, 0x139, 0x139, 
       0x29c, 0x29c, 0xc, 0x2, 0x89, 0x8d, 0x101, 0x104, 0x180, 0x180, 0x183, 
       0x185, 0x18b, 0x18b, 0x1e8, 0x1e8, 0x235, 0x235, 0x23b, 0x23b, 0x2cb, 
       0x2cb, 0x2db, 0x2dc, 0x9, 0x2, 0x3a, 0x3a, 0x117, 0x117, 0x11d, 0x11d, 
       0x17a, 0x17a, 0x181, 0x181, 0x24e, 0x24e, 0x298, 0x298, 0x5, 0x2, 
       0x90, 0x90, 0xd9, 0xda, 0x1a9, 0x1a9, 0x3, 0x2, 0x40, 0x41, 0x4, 
       0x2, 0x14f, 0x14f, 0x179, 0x179, 0x8, 0x2, 0xec, 0xed, 0x12c, 0x12c, 
       0x143, 0x143, 0x18c, 0x18e, 0x1d5, 0x1d6, 0x240, 0x240, 0x5, 0x2, 
       0x249, 0x249, 0x2b0, 0x2b0, 0x2dd, 0x2dd, 0x3, 0x2, 0x51, 0x52, 0x3, 
       0x2, 0x2eb, 0x2ec, 0x4, 0x2, 0x7f, 0x7f, 0x147, 0x148, 0x5, 0x2, 
       0x92, 0x92, 0xac, 0xac, 0xd9, 0xd9, 0x5, 0x2, 0x92, 0x92, 0xa2, 0xa2, 
       0x17d, 0x17d, 0x4, 0x2, 0x2d, 0x2d, 0x9a, 0x9a, 0x4, 0x2, 0x25, 0x25, 
       0xa3, 0xa3, 0x4, 0x2, 0x8e, 0x8e, 0xa8, 0xa8, 0x2, 0x2250, 0x2, 0x4c3, 
       0x3, 0x2, 0x2, 0x2, 0x4, 0x4cc, 0x3, 0x2, 0x2, 0x2, 0x6, 0x4de, 0x3, 
       0x2, 0x2, 0x2, 0x8, 0x4e8, 0x3, 0x2, 0x2, 0x2, 0xa, 0x4f9, 0x3, 0x2, 
       0x2, 0x2, 0xc, 0x503, 0x3, 0x2, 0x2, 0x2, 0xe, 0x505, 0x3, 0x2, 0x2, 
       0x2, 0x10, 0x50f, 0x3, 0x2, 0x2, 0x2, 0x12, 0x51a, 0x3, 0x2, 0x2, 
       0x2, 0x14, 0x526, 0x3, 0x2, 0x2, 0x2, 0x16, 0x52b, 0x3, 0x2, 0x2, 
       0x2, 0x18, 0x536, 0x3, 0x2, 0x2, 0x2, 0x1a, 0x546, 0x3, 0x2, 0x2, 
       0x2, 0x1c, 0x54d, 0x3, 0x2, 0x2, 0x2, 0x1e, 0x55f, 0x3, 0x2, 0x2, 
       0x2, 0x20, 0x56b, 0x3, 0x2, 0x2, 0x2, 0x22, 0x57b, 0x3, 0x2, 0x2, 
       0x2, 0x24, 0x580, 0x3, 0x2, 0x2, 0x2, 0x26, 0x585, 0x3, 0x2, 0x2, 
       0x2, 0x28, 0x59d, 0x3, 0x2, 0x2, 0x2, 0x2a, 0x5a2, 0x3, 0x2, 0x2, 
       0x2, 0x2c, 0x5a4, 0x3, 0x2, 0x2, 0x2, 0x2e, 0x5a7, 0x3, 0x2, 0x2, 
       0x2, 0x30, 0x5b7, 0x3, 0x2, 0x2, 0x2, 0x32, 0x5bf, 0x3, 0x2, 0x2, 
       0x2, 0x34, 0x5d3, 0x3, 0x2, 0x2, 0x2, 0x36, 0x5db, 0x3, 0x2, 0x2, 
       0x2, 0x38, 0x5ea, 0x3, 0x2, 0x2, 0x2, 0x3a, 0x5ed, 0x3, 0x2, 0x2, 
       0x2, 0x3c, 0x604, 0x3, 0x2, 0x2, 0x2, 0x3e, 0x614, 0x3, 0x2, 0x2, 
       0x2, 0x40, 0x621, 0x3, 0x2, 0x2, 0x2, 0x42, 0x623, 0x3, 0x2, 0x2, 
       0x2, 0x44, 0x63d, 0x3, 0x2, 0x2, 0x2, 0x46, 0x64d, 0x3, 0x2, 0x2, 
       0x2, 0x48, 0x65a, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x65c, 0x3, 0x2, 0x2, 
       0x2, 0x4c, 0x665, 0x3, 0x2, 0x2, 0x2, 0x4e, 0x677, 0x3, 0x2, 0x2, 
       0x2, 0x50, 0x681, 0x3, 0x2, 0x2, 0x2, 0x52, 0x685, 0x3, 0x2, 0x2, 
       0x2, 0x54, 0x68f, 0x3, 0x2, 0x2, 0x2, 0x56, 0x691, 0x3, 0x2, 0x2, 
       0x2, 0x58, 0x6c5, 0x3, 0x2, 0x2, 0x2, 0x5a, 0x6ef, 0x3, 0x2, 0x2, 
       0x2, 0x5c, 0x6f2, 0x3, 0x2, 0x2, 0x2, 0x5e, 0x6f5, 0x3, 0x2, 0x2, 
       0x2, 0x60, 0x6ff, 0x3, 0x2, 0x2, 0x2, 0x62, 0x70b, 0x3, 0x2, 0x2, 
       0x2, 0x64, 0x71d, 0x3, 0x2, 0x2, 0x2, 0x66, 0x71f, 0x3, 0x2, 0x2, 
       0x2, 0x68, 0x723, 0x3, 0x2, 0x2, 0x2, 0x6a, 0x734, 0x3, 0x2, 0x2, 
       0x2, 0x6c, 0x736, 0x3, 0x2, 0x2, 0x2, 0x6e, 0x738, 0x3, 0x2, 0x2, 
       0x2, 0x70, 0x73b, 0x3, 0x2, 0x2, 0x2, 0x72, 0x740, 0x3, 0x2, 0x2, 
       0x2, 0x74, 0x748, 0x3, 0x2, 0x2, 0x2, 0x76, 0x755, 0x3, 0x2, 0x2, 
       0x2, 0x78, 0x779, 0x3, 0x2, 0x2, 0x2, 0x7a, 0x77b, 0x3, 0x2, 0x2, 
       0x2, 0x7c, 0x787, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x78f, 0x3, 0x2, 0x2, 
       0x2, 0x80, 0x7b2, 0x3, 0x2, 0x2, 0x2, 0x82, 0x7b9, 0x3, 0x2, 0x2, 
       0x2, 0x84, 0x7bb, 0x3, 0x2, 0x2, 0x2, 0x86, 0x7cc, 0x3, 0x2, 0x2, 
       0x2, 0x88, 0x7d5, 0x3, 0x2, 0x2, 0x2, 0x8a, 0x7d7, 0x3, 0x2, 0x2, 
       0x2, 0x8c, 0x7da, 0x3, 0x2, 0x2, 0x2, 0x8e, 0x7e8, 0x3, 0x2, 0x2, 
       0x2, 0x90, 0x7eb, 0x3, 0x2, 0x2, 0x2, 0x92, 0x7fa, 0x3, 0x2, 0x2, 
       0x2, 0x94, 0x7fe, 0x3, 0x2, 0x2, 0x2, 0x96, 0x800, 0x3, 0x2, 0x2, 
       0x2, 0x98, 0x809, 0x3, 0x2, 0x2, 0x2, 0x9a, 0x80f, 0x3, 0x2, 0x2, 
       0x2, 0x9c, 0x817, 0x3, 0x2, 0x2, 0x2, 0x9e, 0x825, 0x3, 0x2, 0x2, 
       0x2, 0xa0, 0x84b, 0x3, 0x2, 0x2, 0x2, 0xa2, 0x859, 0x3, 0x2, 0x2, 
       0x2, 0xa4, 0x85c, 0x3, 0x2, 0x2, 0x2, 0xa6, 0x860, 0x3, 0x2, 0x2, 
       0x2, 0xa8, 0x865, 0x3, 0x2, 0x2, 0x2, 0xaa, 0x867, 0x3, 0x2, 0x2, 
       0x2, 0xac, 0x86a, 0x3, 0x2, 0x2, 0x2, 0xae, 0x86e, 0x3, 0x2, 0x2, 
       0x2, 0xb0, 0x881, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x883, 0x3, 0x2, 0x2, 
       0x2, 0xb4, 0x89b, 0x3, 0x2, 0x2, 0x2, 0xb6, 0x8c8, 0x3, 0x2, 0x2, 
       0x2, 0xb8, 0x8ca, 0x3, 0x2, 0x2, 0x2, 0xba, 0x8e2, 0x3, 0x2, 0x2, 
       0x2, 0xbc, 0x8e7, 0x3, 0x2, 0x2, 0x2, 0xbe, 0x8fe, 0x3, 0x2, 0x2, 
       0x2, 0xc0, 0x903, 0x3, 0x2, 0x2, 0x2, 0xc2, 0x90c, 0x3, 0x2, 0x2, 
       0x2, 0xc4, 0x911, 0x3, 0x2, 0x2, 0x2, 0xc6, 0x91a, 0x3, 0x2, 0x2, 
       0x2, 0xc8, 0x91e, 0x3, 0x2, 0x2, 0x2, 0xca, 0x92c, 0x3, 0x2, 0x2, 
       0x2, 0xcc, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0xce, 0x9ab, 0x3, 0x2, 0x2, 
       0x2, 0xd0, 0xa07, 0x3, 0x2, 0x2, 0x2, 0xd2, 0xa09, 0x3, 0x2, 0x2, 
       0x2, 0xd4, 0xa14, 0x3, 0x2, 0x2, 0x2, 0xd6, 0xa16, 0x3, 0x2, 0x2, 
       0x2, 0xd8, 0xa1f, 0x3, 0x2, 0x2, 0x2, 0xda, 0xa7f, 0x3, 0x2, 0x2, 
       0x2, 0xdc, 0xa81, 0x3, 0x2, 0x2, 0x2, 0xde, 0xa85, 0x3, 0x2, 0x2, 
       0x2, 0xe0, 0xa8f, 0x3, 0x2, 0x2, 0x2, 0xe2, 0xa91, 0x3, 0x2, 0x2, 
       0x2, 0xe4, 0xa97, 0x3, 0x2, 0x2, 0x2, 0xe6, 0xa99, 0x3, 0x2, 0x2, 
       0x2, 0xe8, 0xaa5, 0x3, 0x2, 0x2, 0x2, 0xea, 0xab3, 0x3, 0x2, 0x2, 
       0x2, 0xec, 0xab9, 0x3, 0x2, 0x2, 0x2, 0xee, 0xabf, 0x3, 0x2, 0x2, 
       0x2, 0xf0, 0xac5, 0x3, 0x2, 0x2, 0x2, 0xf2, 0xadb, 0x3, 0x2, 0x2, 
       0x2, 0xf4, 0xae7, 0x3, 0x2, 0x2, 0x2, 0xf6, 0xaf5, 0x3, 0x2, 0x2, 
       0x2, 0xf8, 0xafe, 0x3, 0x2, 0x2, 0x2, 0xfa, 0xb00, 0x3, 0x2, 0x2, 
       0x2, 0xfc, 0xb07, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xb23, 0x3, 0x2, 0x2, 
       0x2, 0x100, 0xb25, 0x3, 0x2, 0x2, 0x2, 0x102, 0xb27, 0x3, 0x2, 0x2, 
       0x2, 0x104, 0xb49, 0x3, 0x2, 0x2, 0x2, 0x106, 0xb70, 0x3, 0x2, 0x2, 
       0x2, 0x108, 0xb77, 0x3, 0x2, 0x2, 0x2, 0x10a, 0xb97, 0x3, 0x2, 0x2, 
       0x2, 0x10c, 0xba0, 0x3, 0x2, 0x2, 0x2, 0x10e, 0xba7, 0x3, 0x2, 0x2, 
       0x2, 0x110, 0xbc1, 0x3, 0x2, 0x2, 0x2, 0x112, 0xbca, 0x3, 0x2, 0x2, 
       0x2, 0x114, 0xbd1, 0x3, 0x2, 0x2, 0x2, 0x116, 0xbe4, 0x3, 0x2, 0x2, 
       0x2, 0x118, 0xbf3, 0x3, 0x2, 0x2, 0x2, 0x11a, 0xbfa, 0x3, 0x2, 0x2, 
       0x2, 0x11c, 0xc1e, 0x3, 0x2, 0x2, 0x2, 0x11e, 0xc3e, 0x3, 0x2, 0x2, 
       0x2, 0x120, 0xc47, 0x3, 0x2, 0x2, 0x2, 0x122, 0xc61, 0x3, 0x2, 0x2, 
       0x2, 0x124, 0xca2, 0x3, 0x2, 0x2, 0x2, 0x126, 0xcbf, 0x3, 0x2, 0x2, 
       0x2, 0x128, 0xcdb, 0x3, 0x2, 0x2, 0x2, 0x12a, 0xce8, 0x3, 0x2, 0x2, 
       0x2, 0x12c, 0xd1c, 0x3, 0x2, 0x2, 0x2, 0x12e, 0xd34, 0x3, 0x2, 0x2, 
       0x2, 0x130, 0xd3f, 0x3, 0x2, 0x2, 0x2, 0x132, 0xd51, 0x3, 0x2, 0x2, 
       0x2, 0x134, 0xd5d, 0x3, 0x2, 0x2, 0x2, 0x136, 0xd6b, 0x3, 0x2, 0x2, 
       0x2, 0x138, 0xd6f, 0x3, 0x2, 0x2, 0x2, 0x13a, 0xd74, 0x3, 0x2, 0x2, 
       0x2, 0x13c, 0xdbc, 0x3, 0x2, 0x2, 0x2, 0x13e, 0xdbe, 0x3, 0x2, 0x2, 
       0x2, 0x140, 0xdc4, 0x3, 0x2, 0x2, 0x2, 0x142, 0xdc8, 0x3, 0x2, 0x2, 
       0x2, 0x144, 0xdcb, 0x3, 0x2, 0x2, 0x2, 0x146, 0xde9, 0x3, 0x2, 0x2, 
       0x2, 0x148, 0xdf3, 0x3, 0x2, 0x2, 0x2, 0x14a, 0xdf5, 0x3, 0x2, 0x2, 
       0x2, 0x14c, 0xdf9, 0x3, 0x2, 0x2, 0x2, 0x14e, 0xdfb, 0x3, 0x2, 0x2, 
       0x2, 0x150, 0xdfe, 0x3, 0x2, 0x2, 0x2, 0x152, 0xe09, 0x3, 0x2, 0x2, 
       0x2, 0x154, 0xe17, 0x3, 0x2, 0x2, 0x2, 0x156, 0xe19, 0x3, 0x2, 0x2, 
       0x2, 0x158, 0xe26, 0x3, 0x2, 0x2, 0x2, 0x15a, 0xe30, 0x3, 0x2, 0x2, 
       0x2, 0x15c, 0xe32, 0x3, 0x2, 0x2, 0x2, 0x15e, 0xe35, 0x3, 0x2, 0x2, 
       0x2, 0x160, 0xe3c, 0x3, 0x2, 0x2, 0x2, 0x162, 0xe3e, 0x3, 0x2, 0x2, 
       0x2, 0x164, 0xecb, 0x3, 0x2, 0x2, 0x2, 0x166, 0xee8, 0x3, 0x2, 0x2, 
       0x2, 0x168, 0xeea, 0x3, 0x2, 0x2, 0x2, 0x16a, 0xeff, 0x3, 0x2, 0x2, 
       0x2, 0x16c, 0xf04, 0x3, 0x2, 0x2, 0x2, 0x16e, 0xf06, 0x3, 0x2, 0x2, 
       0x2, 0x170, 0xf11, 0x3, 0x2, 0x2, 0x2, 0x172, 0xf3b, 0x3, 0x2, 0x2, 
       0x2, 0x174, 0xf3d, 0x3, 0x2, 0x2, 0x2, 0x176, 0xf6d, 0x3, 0x2, 0x2, 
       0x2, 0x178, 0xf6f, 0x3, 0x2, 0x2, 0x2, 0x17a, 0xf77, 0x3, 0x2, 0x2, 
       0x2, 0x17c, 0xfa2, 0x3, 0x2, 0x2, 0x2, 0x17e, 0xfa8, 0x3, 0x2, 0x2, 
       0x2, 0x180, 0xfac, 0x3, 0x2, 0x2, 0x2, 0x182, 0xfbc, 0x3, 0x2, 0x2, 
       0x2, 0x184, 0xfd5, 0x3, 0x2, 0x2, 0x2, 0x186, 0xfd8, 0x3, 0x2, 0x2, 
       0x2, 0x188, 0xfdf, 0x3, 0x2, 0x2, 0x2, 0x18a, 0xfe1, 0x3, 0x2, 0x2, 
       0x2, 0x18c, 0xfe3, 0x3, 0x2, 0x2, 0x2, 0x18e, 0xff5, 0x3, 0x2, 0x2, 
       0x2, 0x190, 0xffd, 0x3, 0x2, 0x2, 0x2, 0x192, 0x100d, 0x3, 0x2, 0x2, 
       0x2, 0x194, 0x1026, 0x3, 0x2, 0x2, 0x2, 0x196, 0x1028, 0x3, 0x2, 
       0x2, 0x2, 0x198, 0x1043, 0x3, 0x2, 0x2, 0x2, 0x19a, 0x1063, 0x3, 
       0x2, 0x2, 0x2, 0x19c, 0x1066, 0x3, 0x2, 0x2, 0x2, 0x19e, 0x106c, 
       0x3, 0x2, 0x2, 0x2, 0x1a0, 0x107c, 0x3, 0x2, 0x2, 0x2, 0x1a2, 0x108b, 
       0x3, 0x2, 0x2, 0x2, 0x1a4, 0x1091, 0x3, 0x2, 0x2, 0x2, 0x1a6, 0x10a4, 
       0x3, 0x2, 0x2, 0x2, 0x1a8, 0x10a6, 0x3, 0x2, 0x2, 0x2, 0x1aa, 0x10a9, 
       0x3, 0x2, 0x2, 0x2, 0x1ac, 0x10af, 0x3, 0x2, 0x2, 0x2, 0x1ae, 0x10c0, 
       0x3, 0x2, 0x2, 0x2, 0x1b0, 0x10c8, 0x3, 0x2, 0x2, 0x2, 0x1b2, 0x10ca, 
       0x3, 0x2, 0x2, 0x2, 0x1b4, 0x10d0, 0x3, 0x2, 0x2, 0x2, 0x1b6, 0x10de, 
       0x3, 0x2, 0x2, 0x2, 0x1b8, 0x10f7, 0x3, 0x2, 0x2, 0x2, 0x1ba, 0x10fb, 
       0x3, 0x2, 0x2, 0x2, 0x1bc, 0x1101, 0x3, 0x2, 0x2, 0x2, 0x1be, 0x1103, 
       0x3, 0x2, 0x2, 0x2, 0x1c0, 0x1105, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0x1107, 
       0x3, 0x2, 0x2, 0x2, 0x1c4, 0x1114, 0x3, 0x2, 0x2, 0x2, 0x1c6, 0x1116, 
       0x3, 0x2, 0x2, 0x2, 0x1c8, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x1ca, 0x1132, 
       0x3, 0x2, 0x2, 0x2, 0x1cc, 0x1136, 0x3, 0x2, 0x2, 0x2, 0x1ce, 0x1143, 
       0x3, 0x2, 0x2, 0x2, 0x1d0, 0x1154, 0x3, 0x2, 0x2, 0x2, 0x1d2, 0x1163, 
       0x3, 0x2, 0x2, 0x2, 0x1d4, 0x1165, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0x116f, 
       0x3, 0x2, 0x2, 0x2, 0x1d8, 0x1183, 0x3, 0x2, 0x2, 0x2, 0x1da, 0x1186, 
       0x3, 0x2, 0x2, 0x2, 0x1dc, 0x118a, 0x3, 0x2, 0x2, 0x2, 0x1de, 0x1199, 
       0x3, 0x2, 0x2, 0x2, 0x1e0, 0x119c, 0x3, 0x2, 0x2, 0x2, 0x1e2, 0x11a0, 
       0x3, 0x2, 0x2, 0x2, 0x1e4, 0x11c6, 0x3, 0x2, 0x2, 0x2, 0x1e6, 0x11cf, 
       0x3, 0x2, 0x2, 0x2, 0x1e8, 0x11d1, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0x11d4, 
       0x3, 0x2, 0x2, 0x2, 0x1ec, 0x11db, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0x11df, 
       0x3, 0x2, 0x2, 0x2, 0x1f0, 0x11f0, 0x3, 0x2, 0x2, 0x2, 0x1f2, 0x11f2, 
       0x3, 0x2, 0x2, 0x2, 0x1f4, 0x11fd, 0x3, 0x2, 0x2, 0x2, 0x1f6, 0x1203, 
       0x3, 0x2, 0x2, 0x2, 0x1f8, 0x120a, 0x3, 0x2, 0x2, 0x2, 0x1fa, 0x1212, 
       0x3, 0x2, 0x2, 0x2, 0x1fc, 0x121d, 0x3, 0x2, 0x2, 0x2, 0x1fe, 0x1223, 
       0x3, 0x2, 0x2, 0x2, 0x200, 0x122d, 0x3, 0x2, 0x2, 0x2, 0x202, 0x1235, 
       0x3, 0x2, 0x2, 0x2, 0x204, 0x1270, 0x3, 0x2, 0x2, 0x2, 0x206, 0x1273, 
       0x3, 0x2, 0x2, 0x2, 0x208, 0x1277, 0x3, 0x2, 0x2, 0x2, 0x20a, 0x1284, 
       0x3, 0x2, 0x2, 0x2, 0x20c, 0x1286, 0x3, 0x2, 0x2, 0x2, 0x20e, 0x129a, 
       0x3, 0x2, 0x2, 0x2, 0x210, 0x12a4, 0x3, 0x2, 0x2, 0x2, 0x212, 0x12b2, 
       0x3, 0x2, 0x2, 0x2, 0x214, 0x12bb, 0x3, 0x2, 0x2, 0x2, 0x216, 0x12df, 
       0x3, 0x2, 0x2, 0x2, 0x218, 0x1310, 0x3, 0x2, 0x2, 0x2, 0x21a, 0x1312, 
       0x3, 0x2, 0x2, 0x2, 0x21c, 0x1316, 0x3, 0x2, 0x2, 0x2, 0x21e, 0x131e, 
       0x3, 0x2, 0x2, 0x2, 0x220, 0x132c, 0x3, 0x2, 0x2, 0x2, 0x222, 0x133b, 
       0x3, 0x2, 0x2, 0x2, 0x224, 0x1349, 0x3, 0x2, 0x2, 0x2, 0x226, 0x1358, 
       0x3, 0x2, 0x2, 0x2, 0x228, 0x1370, 0x3, 0x2, 0x2, 0x2, 0x22a, 0x137b, 
       0x3, 0x2, 0x2, 0x2, 0x22c, 0x1395, 0x3, 0x2, 0x2, 0x2, 0x22e, 0x1397, 
       0x3, 0x2, 0x2, 0x2, 0x230, 0x139b, 0x3, 0x2, 0x2, 0x2, 0x232, 0x13a3, 
       0x3, 0x2, 0x2, 0x2, 0x234, 0x13ab, 0x3, 0x2, 0x2, 0x2, 0x236, 0x13bd, 
       0x3, 0x2, 0x2, 0x2, 0x238, 0x13bf, 0x3, 0x2, 0x2, 0x2, 0x23a, 0x13ee, 
       0x3, 0x2, 0x2, 0x2, 0x23c, 0x13f8, 0x3, 0x2, 0x2, 0x2, 0x23e, 0x1402, 
       0x3, 0x2, 0x2, 0x2, 0x240, 0x1408, 0x3, 0x2, 0x2, 0x2, 0x242, 0x140a, 
       0x3, 0x2, 0x2, 0x2, 0x244, 0x140d, 0x3, 0x2, 0x2, 0x2, 0x246, 0x1410, 
       0x3, 0x2, 0x2, 0x2, 0x248, 0x1423, 0x3, 0x2, 0x2, 0x2, 0x24a, 0x1428, 
       0x3, 0x2, 0x2, 0x2, 0x24c, 0x1436, 0x3, 0x2, 0x2, 0x2, 0x24e, 0x143f, 
       0x3, 0x2, 0x2, 0x2, 0x250, 0x144f, 0x3, 0x2, 0x2, 0x2, 0x252, 0x145b, 
       0x3, 0x2, 0x2, 0x2, 0x254, 0x1460, 0x3, 0x2, 0x2, 0x2, 0x256, 0x1463, 
       0x3, 0x2, 0x2, 0x2, 0x258, 0x1466, 0x3, 0x2, 0x2, 0x2, 0x25a, 0x1469, 
       0x3, 0x2, 0x2, 0x2, 0x25c, 0x146c, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x1471, 
       0x3, 0x2, 0x2, 0x2, 0x260, 0x147f, 0x3, 0x2, 0x2, 0x2, 0x262, 0x1481, 
       0x3, 0x2, 0x2, 0x2, 0x264, 0x148a, 0x3, 0x2, 0x2, 0x2, 0x266, 0x148e, 
       0x3, 0x2, 0x2, 0x2, 0x268, 0x1492, 0x3, 0x2, 0x2, 0x2, 0x26a, 0x14a5, 
       0x3, 0x2, 0x2, 0x2, 0x26c, 0x14ab, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x14b0, 
       0x3, 0x2, 0x2, 0x2, 0x270, 0x14b8, 0x3, 0x2, 0x2, 0x2, 0x272, 0x14bd, 
       0x3, 0x2, 0x2, 0x2, 0x274, 0x14c2, 0x3, 0x2, 0x2, 0x2, 0x276, 0x14c7, 
       0x3, 0x2, 0x2, 0x2, 0x278, 0x14cc, 0x3, 0x2, 0x2, 0x2, 0x27a, 0x14d1, 
       0x3, 0x2, 0x2, 0x2, 0x27c, 0x14d6, 0x3, 0x2, 0x2, 0x2, 0x27e, 0x14db, 
       0x3, 0x2, 0x2, 0x2, 0x280, 0x14e1, 0x3, 0x2, 0x2, 0x2, 0x282, 0x14f1, 
       0x3, 0x2, 0x2, 0x2, 0x284, 0x14f9, 0x3, 0x2, 0x2, 0x2, 0x286, 0x14fe, 
       0x3, 0x2, 0x2, 0x2, 0x288, 0x1504, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x1514, 
       0x3, 0x2, 0x2, 0x2, 0x28c, 0x1518, 0x3, 0x2, 0x2, 0x2, 0x28e, 0x1521, 
       0x3, 0x2, 0x2, 0x2, 0x290, 0x1524, 0x3, 0x2, 0x2, 0x2, 0x292, 0x1527, 
       0x3, 0x2, 0x2, 0x2, 0x294, 0x152c, 0x3, 0x2, 0x2, 0x2, 0x296, 0x1531, 
       0x3, 0x2, 0x2, 0x2, 0x298, 0x1537, 0x3, 0x2, 0x2, 0x2, 0x29a, 0x1550, 
       0x3, 0x2, 0x2, 0x2, 0x29c, 0x1553, 0x3, 0x2, 0x2, 0x2, 0x29e, 0x156a, 
       0x3, 0x2, 0x2, 0x2, 0x2a0, 0x156e, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x1576, 
       0x3, 0x2, 0x2, 0x2, 0x2a4, 0x157e, 0x3, 0x2, 0x2, 0x2, 0x2a6, 0x1586, 
       0x3, 0x2, 0x2, 0x2, 0x2a8, 0x158e, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x159e, 
       0x3, 0x2, 0x2, 0x2, 0x2ac, 0x15a8, 0x3, 0x2, 0x2, 0x2, 0x2ae, 0x15b3, 
       0x3, 0x2, 0x2, 0x2, 0x2b0, 0x15d2, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0x15d4, 
       0x3, 0x2, 0x2, 0x2, 0x2b4, 0x15e1, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x15e5, 
       0x3, 0x2, 0x2, 0x2, 0x2b8, 0x15e7, 0x3, 0x2, 0x2, 0x2, 0x2ba, 0x15f1, 
       0x3, 0x2, 0x2, 0x2, 0x2bc, 0x15f7, 0x3, 0x2, 0x2, 0x2, 0x2be, 0x1601, 
       0x3, 0x2, 0x2, 0x2, 0x2c0, 0x1605, 0x3, 0x2, 0x2, 0x2, 0x2c2, 0x161b, 
       0x3, 0x2, 0x2, 0x2, 0x2c4, 0x161d, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x162a, 
       0x3, 0x2, 0x2, 0x2, 0x2c8, 0x162c, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0x1632, 
       0x3, 0x2, 0x2, 0x2, 0x2cc, 0x1639, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0x1648, 
       0x3, 0x2, 0x2, 0x2, 0x2d0, 0x166c, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x166e, 
       0x3, 0x2, 0x2, 0x2, 0x2d4, 0x168d, 0x3, 0x2, 0x2, 0x2, 0x2d6, 0x1694, 
       0x3, 0x2, 0x2, 0x2, 0x2d8, 0x16a3, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x16a6, 
       0x3, 0x2, 0x2, 0x2, 0x2dc, 0x16bd, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x16e0, 
       0x3, 0x2, 0x2, 0x2, 0x2e0, 0x16e2, 0x3, 0x2, 0x2, 0x2, 0x2e2, 0x1708, 
       0x3, 0x2, 0x2, 0x2, 0x2e4, 0x1731, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x1733, 
       0x3, 0x2, 0x2, 0x2, 0x2e8, 0x173c, 0x3, 0x2, 0x2, 0x2, 0x2ea, 0x1752, 
       0x3, 0x2, 0x2, 0x2, 0x2ec, 0x1760, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x1762, 
       0x3, 0x2, 0x2, 0x2, 0x2f0, 0x176a, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x176c, 
       0x3, 0x2, 0x2, 0x2, 0x2f4, 0x176e, 0x3, 0x2, 0x2, 0x2, 0x2f6, 0x1777, 
       0x3, 0x2, 0x2, 0x2, 0x2f8, 0x1779, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x17a3, 
       0x3, 0x2, 0x2, 0x2, 0x2fc, 0x17a7, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x17a9, 
       0x3, 0x2, 0x2, 0x2, 0x300, 0x17b0, 0x3, 0x2, 0x2, 0x2, 0x302, 0x17b7, 
       0x3, 0x2, 0x2, 0x2, 0x304, 0x17c3, 0x3, 0x2, 0x2, 0x2, 0x306, 0x17ce, 
       0x3, 0x2, 0x2, 0x2, 0x308, 0x17d0, 0x3, 0x2, 0x2, 0x2, 0x30a, 0x17d3, 
       0x3, 0x2, 0x2, 0x2, 0x30c, 0x17d6, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x17e0, 
       0x3, 0x2, 0x2, 0x2, 0x310, 0x17e4, 0x3, 0x2, 0x2, 0x2, 0x312, 0x17e6, 
       0x3, 0x2, 0x2, 0x2, 0x314, 0x1800, 0x3, 0x2, 0x2, 0x2, 0x316, 0x1811, 
       0x3, 0x2, 0x2, 0x2, 0x318, 0x187c, 0x3, 0x2, 0x2, 0x2, 0x31a, 0x187e, 
       0x3, 0x2, 0x2, 0x2, 0x31c, 0x1882, 0x3, 0x2, 0x2, 0x2, 0x31e, 0x1884, 
       0x3, 0x2, 0x2, 0x2, 0x320, 0x18bd, 0x3, 0x2, 0x2, 0x2, 0x322, 0x18bf, 
       0x3, 0x2, 0x2, 0x2, 0x324, 0x18c7, 0x3, 0x2, 0x2, 0x2, 0x326, 0x18c9, 
       0x3, 0x2, 0x2, 0x2, 0x328, 0x18cb, 0x3, 0x2, 0x2, 0x2, 0x32a, 0x18d4, 
       0x3, 0x2, 0x2, 0x2, 0x32c, 0x18d6, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x18dd, 
       0x3, 0x2, 0x2, 0x2, 0x330, 0x18df, 0x3, 0x2, 0x2, 0x2, 0x332, 0x18e1, 
       0x3, 0x2, 0x2, 0x2, 0x334, 0x18e5, 0x3, 0x2, 0x2, 0x2, 0x336, 0x18ec, 
       0x3, 0x2, 0x2, 0x2, 0x338, 0x18f2, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x18f4, 
       0x3, 0x2, 0x2, 0x2, 0x33c, 0x18f8, 0x3, 0x2, 0x2, 0x2, 0x33e, 0x18fe, 
       0x3, 0x2, 0x2, 0x2, 0x340, 0x1900, 0x3, 0x2, 0x2, 0x2, 0x342, 0x1904, 
       0x3, 0x2, 0x2, 0x2, 0x344, 0x190a, 0x3, 0x2, 0x2, 0x2, 0x346, 0x1914, 
       0x3, 0x2, 0x2, 0x2, 0x348, 0x1917, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x1921, 
       0x3, 0x2, 0x2, 0x2, 0x34c, 0x192b, 0x3, 0x2, 0x2, 0x2, 0x34e, 0x1934, 
       0x3, 0x2, 0x2, 0x2, 0x350, 0x1936, 0x3, 0x2, 0x2, 0x2, 0x352, 0x1938, 
       0x3, 0x2, 0x2, 0x2, 0x354, 0x1942, 0x3, 0x2, 0x2, 0x2, 0x356, 0x1944, 
       0x3, 0x2, 0x2, 0x2, 0x358, 0x194c, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x1955, 
       0x3, 0x2, 0x2, 0x2, 0x35c, 0x1959, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x195b, 
       0x3, 0x2, 0x2, 0x2, 0x360, 0x195d, 0x3, 0x2, 0x2, 0x2, 0x362, 0x1968, 
       0x3, 0x2, 0x2, 0x2, 0x364, 0x196a, 0x3, 0x2, 0x2, 0x2, 0x366, 0x196f, 
       0x3, 0x2, 0x2, 0x2, 0x368, 0x1971, 0x3, 0x2, 0x2, 0x2, 0x36a, 0x197a, 
       0x3, 0x2, 0x2, 0x2, 0x36c, 0x1983, 0x3, 0x2, 0x2, 0x2, 0x36e, 0x1985, 
       0x3, 0x2, 0x2, 0x2, 0x370, 0x1987, 0x3, 0x2, 0x2, 0x2, 0x372, 0x1989, 
       0x3, 0x2, 0x2, 0x2, 0x374, 0x198b, 0x3, 0x2, 0x2, 0x2, 0x376, 0x1993, 
       0x3, 0x2, 0x2, 0x2, 0x378, 0x199b, 0x3, 0x2, 0x2, 0x2, 0x37a, 0x19a3, 
       0x3, 0x2, 0x2, 0x2, 0x37c, 0x19a5, 0x3, 0x2, 0x2, 0x2, 0x37e, 0x19a7, 
       0x3, 0x2, 0x2, 0x2, 0x380, 0x19a9, 0x3, 0x2, 0x2, 0x2, 0x382, 0x19ab, 
       0x3, 0x2, 0x2, 0x2, 0x384, 0x19ad, 0x3, 0x2, 0x2, 0x2, 0x386, 0x19af, 
       0x3, 0x2, 0x2, 0x2, 0x388, 0x19b1, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x19b7, 
       0x3, 0x2, 0x2, 0x2, 0x38c, 0x19b9, 0x3, 0x2, 0x2, 0x2, 0x38e, 0x19be, 
       0x3, 0x2, 0x2, 0x2, 0x390, 0x19ca, 0x3, 0x2, 0x2, 0x2, 0x392, 0x19cc, 
       0x3, 0x2, 0x2, 0x2, 0x394, 0x19ce, 0x3, 0x2, 0x2, 0x2, 0x396, 0x19d3, 
       0x3, 0x2, 0x2, 0x2, 0x398, 0x19d5, 0x3, 0x2, 0x2, 0x2, 0x39a, 0x19d9, 
       0x3, 0x2, 0x2, 0x2, 0x39c, 0x19db, 0x3, 0x2, 0x2, 0x2, 0x39e, 0x19dd, 
       0x3, 0x2, 0x2, 0x2, 0x3a0, 0x19e7, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x19e9, 
       0x3, 0x2, 0x2, 0x2, 0x3a4, 0x19eb, 0x3, 0x2, 0x2, 0x2, 0x3a6, 0x19f3, 
       0x3, 0x2, 0x2, 0x2, 0x3a8, 0x1a01, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x1a03, 
       0x3, 0x2, 0x2, 0x2, 0x3ac, 0x1a05, 0x3, 0x2, 0x2, 0x2, 0x3ae, 0x1a1f, 
       0x3, 0x2, 0x2, 0x2, 0x3b0, 0x1a58, 0x3, 0x2, 0x2, 0x2, 0x3b2, 0x1a5a, 
       0x3, 0x2, 0x2, 0x2, 0x3b4, 0x1ab8, 0x3, 0x2, 0x2, 0x2, 0x3b6, 0x1ac5, 
       0x3, 0x2, 0x2, 0x2, 0x3b8, 0x1ace, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x1ad9, 
       0x3, 0x2, 0x2, 0x2, 0x3bc, 0x1adb, 0x3, 0x2, 0x2, 0x2, 0x3be, 0x1aef, 
       0x3, 0x2, 0x2, 0x2, 0x3c0, 0x1af1, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x1af3, 
       0x3, 0x2, 0x2, 0x2, 0x3c4, 0x1afb, 0x3, 0x2, 0x2, 0x2, 0x3c6, 0x1b13, 
       0x3, 0x2, 0x2, 0x2, 0x3c8, 0x1b24, 0x3, 0x2, 0x2, 0x2, 0x3ca, 0x1b26, 
       0x3, 0x2, 0x2, 0x2, 0x3cc, 0x1b28, 0x3, 0x2, 0x2, 0x2, 0x3ce, 0x1b39, 
       0x3, 0x2, 0x2, 0x2, 0x3d0, 0x1b3b, 0x3, 0x2, 0x2, 0x2, 0x3d2, 0x1b40, 
       0x3, 0x2, 0x2, 0x2, 0x3d4, 0x1b85, 0x3, 0x2, 0x2, 0x2, 0x3d6, 0x1b87, 
       0x3, 0x2, 0x2, 0x2, 0x3d8, 0x1b8c, 0x3, 0x2, 0x2, 0x2, 0x3da, 0x1b92, 
       0x3, 0x2, 0x2, 0x2, 0x3dc, 0x1b9c, 0x3, 0x2, 0x2, 0x2, 0x3de, 0x1b9e, 
       0x3, 0x2, 0x2, 0x2, 0x3e0, 0x1ba0, 0x3, 0x2, 0x2, 0x2, 0x3e2, 0x1bb5, 
       0x3, 0x2, 0x2, 0x2, 0x3e4, 0x1be4, 0x3, 0x2, 0x2, 0x2, 0x3e6, 0x1be9, 
       0x3, 0x2, 0x2, 0x2, 0x3e8, 0x1beb, 0x3, 0x2, 0x2, 0x2, 0x3ea, 0x1c08, 
       0x3, 0x2, 0x2, 0x2, 0x3ec, 0x1c0a, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x1c11, 
       0x3, 0x2, 0x2, 0x2, 0x3f0, 0x1c21, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x1c29, 
       0x3, 0x2, 0x2, 0x2, 0x3f4, 0x1c2e, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x1c3a, 
       0x3, 0x2, 0x2, 0x2, 0x3f8, 0x1c48, 0x3, 0x2, 0x2, 0x2, 0x3fa, 0x1c51, 
       0x3, 0x2, 0x2, 0x2, 0x3fc, 0x1c60, 0x3, 0x2, 0x2, 0x2, 0x3fe, 0x1c62, 
       0x3, 0x2, 0x2, 0x2, 0x400, 0x1c8b, 0x3, 0x2, 0x2, 0x2, 0x402, 0x1c8d, 
       0x3, 0x2, 0x2, 0x2, 0x404, 0x1cae, 0x3, 0x2, 0x2, 0x2, 0x406, 0x1cb0, 
       0x3, 0x2, 0x2, 0x2, 0x408, 0x1cbe, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x1cc0, 
       0x3, 0x2, 0x2, 0x2, 0x40c, 0x1cc2, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x1cc7, 
       0x3, 0x2, 0x2, 0x2, 0x410, 0x1cca, 0x3, 0x2, 0x2, 0x2, 0x412, 0x1ccd, 
       0x3, 0x2, 0x2, 0x2, 0x414, 0x1cd0, 0x3, 0x2, 0x2, 0x2, 0x416, 0x1cd2, 
       0x3, 0x2, 0x2, 0x2, 0x418, 0x1cde, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x1d7a, 
       0x3, 0x2, 0x2, 0x2, 0x41c, 0x1d7c, 0x3, 0x2, 0x2, 0x2, 0x41e, 0x1d8a, 
       0x3, 0x2, 0x2, 0x2, 0x420, 0x1d8e, 0x3, 0x2, 0x2, 0x2, 0x422, 0x1d91, 
       0x3, 0x2, 0x2, 0x2, 0x424, 0x1d95, 0x3, 0x2, 0x2, 0x2, 0x426, 0x1d9b, 
       0x3, 0x2, 0x2, 0x2, 0x428, 0x1dad, 0x3, 0x2, 0x2, 0x2, 0x42a, 0x1db5, 
       0x3, 0x2, 0x2, 0x2, 0x42c, 0x1dbd, 0x3, 0x2, 0x2, 0x2, 0x42e, 0x1dc2, 
       0x3, 0x2, 0x2, 0x2, 0x430, 0x1dc5, 0x3, 0x2, 0x2, 0x2, 0x432, 0x1dce, 
       0x3, 0x2, 0x2, 0x2, 0x434, 0x1dd7, 0x3, 0x2, 0x2, 0x2, 0x436, 0x1de2, 
       0x3, 0x2, 0x2, 0x2, 0x438, 0x1de4, 0x3, 0x2, 0x2, 0x2, 0x43a, 0x1dec, 
       0x3, 0x2, 0x2, 0x2, 0x43c, 0x1dee, 0x3, 0x2, 0x2, 0x2, 0x43e, 0x1df0, 
       0x3, 0x2, 0x2, 0x2, 0x440, 0x1df2, 0x3, 0x2, 0x2, 0x2, 0x442, 0x1df4, 
       0x3, 0x2, 0x2, 0x2, 0x444, 0x1df8, 0x3, 0x2, 0x2, 0x2, 0x446, 0x1dfb, 
       0x3, 0x2, 0x2, 0x2, 0x448, 0x1dfe, 0x3, 0x2, 0x2, 0x2, 0x44a, 0x1e0b, 
       0x3, 0x2, 0x2, 0x2, 0x44c, 0x1e0f, 0x3, 0x2, 0x2, 0x2, 0x44e, 0x1e12, 
       0x3, 0x2, 0x2, 0x2, 0x450, 0x1e14, 0x3, 0x2, 0x2, 0x2, 0x452, 0x1e16, 
       0x3, 0x2, 0x2, 0x2, 0x454, 0x1e18, 0x3, 0x2, 0x2, 0x2, 0x456, 0x1e1a, 
       0x3, 0x2, 0x2, 0x2, 0x458, 0x1e1c, 0x3, 0x2, 0x2, 0x2, 0x45a, 0x1e1e, 
       0x3, 0x2, 0x2, 0x2, 0x45c, 0x1e2d, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x1e2f, 
       0x3, 0x2, 0x2, 0x2, 0x460, 0x1e35, 0x3, 0x2, 0x2, 0x2, 0x462, 0x4c4, 
       0x5, 0x36, 0x1c, 0x2, 0x463, 0x4c4, 0x5, 0x4, 0x3, 0x2, 0x464, 0x4c4, 
       0x5, 0x20, 0x11, 0x2, 0x465, 0x4c4, 0x5, 0x2e, 0x18, 0x2, 0x466, 
       0x4c4, 0x5, 0x18, 0xd, 0x2, 0x467, 0x4c4, 0x5, 0x2d8, 0x16d, 0x2, 
       0x468, 0x4c4, 0x5, 0xb2, 0x5a, 0x2, 0x469, 0x4c4, 0x5, 0xb0, 0x59, 
       0x2, 0x46a, 0x4c4, 0x5, 0x2cc, 0x167, 0x2, 0x46b, 0x4c4, 0x5, 0xe6, 
       0x74, 0x2, 0x46c, 0x4c4, 0x5, 0xee, 0x78, 0x2, 0x46d, 0x4c4, 0x5, 
       0xf0, 0x79, 0x2, 0x46e, 0x4c4, 0x5, 0xe8, 0x75, 0x2, 0x46f, 0x4c4, 
       0x5, 0x10e, 0x88, 0x2, 0x470, 0x4c4, 0x5, 0x112, 0x8a, 0x2, 0x471, 
       0x4c4, 0x5, 0x108, 0x85, 0x2, 0x472, 0x4c4, 0x5, 0x10c, 0x87, 0x2, 
       0x473, 0x4c4, 0x5, 0xf2, 0x7a, 0x2, 0x474, 0x4c4, 0x5, 0xfa, 0x7e, 
       0x2, 0x475, 0x4c4, 0x5, 0x102, 0x82, 0x2, 0x476, 0x4c4, 0x5, 0x106, 
       0x84, 0x2, 0x477, 0x4c4, 0x5, 0x12a, 0x96, 0x2, 0x478, 0x4c4, 0x5, 
       0x12e, 0x98, 0x2, 0x479, 0x4c4, 0x5, 0x114, 0x8b, 0x2, 0x47a, 0x4c4, 
       0x5, 0x118, 0x8d, 0x2, 0x47b, 0x4c4, 0x5, 0x11a, 0x8e, 0x2, 0x47c, 
       0x4c4, 0x5, 0x11e, 0x90, 0x2, 0x47d, 0x4c4, 0x5, 0x130, 0x99, 0x2, 
       0x47e, 0x4c4, 0x5, 0x132, 0x9a, 0x2, 0x47f, 0x4c4, 0x5, 0x2ce, 0x168, 
       0x2, 0x480, 0x4c4, 0x5, 0x2d2, 0x16a, 0x2, 0x481, 
  };
  static uint16_t serializedATNSegment1[] = {
    0x4c4, 0x5, 0x2d4, 0x16b, 0x2, 0x482, 0x4c4, 0x5, 0x45c, 0x22f, 0x2, 
       0x483, 0x4c4, 0x5, 0x1cc, 0xe7, 0x2, 0x484, 0x4c4, 0x5, 0x1d2, 0xea, 
       0x2, 0x485, 0x4c4, 0x5, 0x1ce, 0xe8, 0x2, 0x486, 0x4c4, 0x5, 0x1d4, 
       0xeb, 0x2, 0x487, 0x4c4, 0x5, 0x1d6, 0xec, 0x2, 0x488, 0x4c4, 0x5, 
       0x1d8, 0xed, 0x2, 0x489, 0x4c4, 0x5, 0x1f4, 0xfb, 0x2, 0x48a, 0x4c4, 
       0x5, 0x1f6, 0xfc, 0x2, 0x48b, 0x4c4, 0x5, 0x20c, 0x107, 0x2, 0x48c, 
       0x4c4, 0x5, 0x21e, 0x110, 0x2, 0x48d, 0x4c4, 0x5, 0x218, 0x10d, 0x2, 
       0x48e, 0x4c4, 0x5, 0x224, 0x113, 0x2, 0x48f, 0x4c4, 0x5, 0x220, 0x111, 
       0x2, 0x490, 0x4c4, 0x5, 0x222, 0x112, 0x2, 0x491, 0x4c4, 0x5, 0x226, 
       0x114, 0x2, 0x492, 0x4c4, 0x5, 0x228, 0x115, 0x2, 0x493, 0x4c4, 0x5, 
       0x120, 0x91, 0x2, 0x494, 0x4c4, 0x5, 0x122, 0x92, 0x2, 0x495, 0x4c4, 
       0x5, 0x128, 0x95, 0x2, 0x496, 0x4c4, 0x5, 0x166, 0xb4, 0x2, 0x497, 
       0x4c4, 0x5, 0x168, 0xb5, 0x2, 0x498, 0x4c4, 0x5, 0x2e0, 0x171, 0x2, 
       0x499, 0x4c4, 0x5, 0x1b6, 0xdc, 0x2, 0x49a, 0x4c4, 0x5, 0x306, 0x184, 
       0x2, 0x49b, 0x4c4, 0x5, 0x48, 0x25, 0x2, 0x49c, 0x4c4, 0x5, 0x244, 
       0x123, 0x2, 0x49d, 0x4c4, 0x5, 0x52, 0x2a, 0x2, 0x49e, 0x4c4, 0x5, 
       0x2b4, 0x15b, 0x2, 0x49f, 0x4c4, 0x5, 0x2e6, 0x174, 0x2, 0x4a0, 0x4c4, 
       0x5, 0x54, 0x2b, 0x2, 0x4a1, 0x4c4, 0x5, 0x1dc, 0xef, 0x2, 0x4a2, 
       0x4c4, 0x5, 0x2da, 0x16e, 0x2, 0x4a3, 0x4c4, 0x5, 0x2e8, 0x175, 0x2, 
       0x4a4, 0x4c4, 0x5, 0x2ca, 0x166, 0x2, 0x4a5, 0x4c4, 0x5, 0x30c, 0x187, 
       0x2, 0x4a6, 0x4c4, 0x5, 0x1e0, 0xf1, 0x2, 0x4a7, 0x4c4, 0x5, 0x2ea, 
       0x176, 0x2, 0x4a8, 0x4c4, 0x5, 0x22a, 0x116, 0x2, 0x4a9, 0x4c4, 0x5, 
       0x1cc, 0xe7, 0x2, 0x4aa, 0x4c4, 0x5, 0x2d6, 0x16c, 0x2, 0x4ab, 0x4c4, 
       0x5, 0x1c6, 0xe4, 0x2, 0x4ac, 0x4c4, 0x5, 0x1c8, 0xe5, 0x2, 0x4ad, 
       0x4c4, 0x5, 0x2f0, 0x179, 0x2, 0x4ae, 0x4c4, 0x5, 0x2f2, 0x17a, 0x2, 
       0x4af, 0x4c4, 0x5, 0x1da, 0xee, 0x2, 0x4b0, 0x4c4, 0x5, 0x242, 0x122, 
       0x2, 0x4b1, 0x4c4, 0x5, 0x246, 0x124, 0x2, 0x4b2, 0x4c4, 0x5, 0x46, 
       0x24, 0x2, 0x4b3, 0x4c4, 0x5, 0x2fa, 0x17e, 0x2, 0x4b4, 0x4c4, 0x5, 
       0x262, 0x132, 0x2, 0x4b5, 0x4c4, 0x5, 0x2ac, 0x157, 0x2, 0x4b6, 0x4c4, 
       0x5, 0x2aa, 0x156, 0x2, 0x4b7, 0x4c4, 0x5, 0x44, 0x23, 0x2, 0x4b8, 
       0x4c4, 0x5, 0x2fc, 0x17f, 0x2, 0x4b9, 0x4c4, 0x5, 0x2c4, 0x163, 0x2, 
       0x4ba, 0x4c4, 0x5, 0x2c8, 0x165, 0x2, 0x4bb, 0x4c4, 0x5, 0x2ae, 0x158, 
       0x2, 0x4bc, 0x4c4, 0x5, 0x302, 0x182, 0x2, 0x4bd, 0x4c4, 0x5, 0x304, 
       0x183, 0x2, 0x4be, 0x4c4, 0x5, 0x2c0, 0x161, 0x2, 0x4bf, 0x4c4, 0x5, 
       0x134, 0x9b, 0x2, 0x4c0, 0x4c4, 0x5, 0x2b6, 0x15c, 0x2, 0x4c1, 0x4c4, 
       0x5, 0x1de, 0xf0, 0x2, 0x4c2, 0x4c4, 0x5, 0x1e2, 0xf2, 0x2, 0x4c3, 
       0x462, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x463, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x464, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x465, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x466, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x467, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x468, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x469, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x46a, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x46b, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x46c, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x46d, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x46e, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x46f, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x470, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x471, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x472, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x473, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x474, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x475, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x476, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x477, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x478, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x479, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x47a, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x47c, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x47d, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x47e, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x47f, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x480, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x481, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x482, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x483, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x484, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x485, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x486, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x487, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x488, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x489, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x48a, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x48b, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x48c, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x48d, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x48e, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x48f, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x490, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x491, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x492, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x493, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x494, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x495, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x496, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x497, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x498, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x499, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x49a, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x49b, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x49c, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x49e, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x49f, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4a0, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4a1, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4a2, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4a3, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4a4, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4a5, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4a6, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4a7, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4a8, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4a9, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4aa, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4ab, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4ac, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4ad, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4ae, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4af, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4b0, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4b1, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4b2, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4b3, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4b4, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4b5, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4b6, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4b7, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4b8, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4b9, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4ba, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4bb, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4bc, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4bd, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4be, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4bf, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4c0, 0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4c3, 
       0x4c2, 0x3, 0x2, 0x2, 0x2, 0x4c4, 0x4ca, 0x3, 0x2, 0x2, 0x2, 0x4c5, 
       0x4c7, 0x7, 0x307, 0x2, 0x2, 0x4c6, 0x4c8, 0x7, 0x2, 0x2, 0x3, 0x4c7, 
       0x4c6, 0x3, 0x2, 0x2, 0x2, 0x4c7, 0x4c8, 0x3, 0x2, 0x2, 0x2, 0x4c8, 
       0x4cb, 0x3, 0x2, 0x2, 0x2, 0x4c9, 0x4cb, 0x7, 0x2, 0x2, 0x3, 0x4ca, 
       0x4c5, 0x3, 0x2, 0x2, 0x2, 0x4ca, 0x4c9, 0x3, 0x2, 0x2, 0x2, 0x4cb, 
       0x3, 0x3, 0x2, 0x2, 0x2, 0x4cc, 0x4cd, 0x7, 0x113, 0x2, 0x2, 0x4cd, 
       0x4cf, 0x5, 0x6, 0x4, 0x2, 0x4ce, 0x4d0, 0x7, 0x11f, 0x2, 0x2, 0x4cf, 
       0x4ce, 0x3, 0x2, 0x2, 0x2, 0x4cf, 0x4d0, 0x3, 0x2, 0x2, 0x2, 0x4d0, 
       0x4d1, 0x3, 0x2, 0x2, 0x2, 0x4d1, 0x4d3, 0x5, 0x35a, 0x1ae, 0x2, 
       0x4d2, 0x4d4, 0x5, 0x7a, 0x3e, 0x2, 0x4d3, 0x4d2, 0x3, 0x2, 0x2, 
       0x2, 0x4d3, 0x4d4, 0x3, 0x2, 0x2, 0x2, 0x4d4, 0x4d8, 0x3, 0x2, 0x2, 
       0x2, 0x4d5, 0x4d9, 0x5, 0x8, 0x5, 0x2, 0x4d6, 0x4d9, 0x5, 0x26, 0x14, 
       0x2, 0x4d7, 0x4d9, 0x5, 0x10, 0x9, 0x2, 0x4d8, 0x4d5, 0x3, 0x2, 0x2, 
       0x2, 0x4d8, 0x4d6, 0x3, 0x2, 0x2, 0x2, 0x4d8, 0x4d7, 0x3, 0x2, 0x2, 
       0x2, 0x4d9, 0x4db, 0x3, 0x2, 0x2, 0x2, 0x4da, 0x4dc, 0x5, 0x12, 0xa, 
       0x2, 0x4db, 0x4da, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4dc, 0x3, 0x2, 0x2, 
       0x2, 0x4dc, 0x5, 0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4df, 0x9, 0x2, 0x2, 
       0x2, 0x4de, 0x4dd, 0x3, 0x2, 0x2, 0x2, 0x4de, 0x4df, 0x3, 0x2, 0x2, 
       0x2, 0x4df, 0x4e1, 0x3, 0x2, 0x2, 0x2, 0x4e0, 0x4e2, 0x7, 0x107, 
       0x2, 0x2, 0x4e1, 0x4e0, 0x3, 0x2, 0x2, 0x2, 0x4e1, 0x4e2, 0x3, 0x2, 
       0x2, 0x2, 0x4e2, 0x7, 0x3, 0x2, 0x2, 0x2, 0x4e3, 0x4e5, 0x7, 0x2fb, 
       0x2, 0x2, 0x4e4, 0x4e6, 0x5, 0xa, 0x6, 0x2, 0x4e5, 0x4e4, 0x3, 0x2, 
       0x2, 0x2, 0x4e5, 0x4e6, 0x3, 0x2, 0x2, 0x2, 0x4e6, 0x4e7, 0x3, 0x2, 
       0x2, 0x2, 0x4e7, 0x4e9, 0x7, 0x2fc, 0x2, 0x2, 0x4e8, 0x4e3, 0x3, 
       0x2, 0x2, 0x2, 0x4e8, 0x4e9, 0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4ea, 0x3, 
       0x2, 0x2, 0x2, 0x4ea, 0x4f4, 0x9, 0x3, 0x2, 0x2, 0x4eb, 0x4f0, 0x5, 
       0x28, 0x15, 0x2, 0x4ec, 0x4ed, 0x7, 0x301, 0x2, 0x2, 0x4ed, 0x4ef, 
       0x5, 0x28, 0x15, 0x2, 0x4ee, 0x4ec, 0x3, 0x2, 0x2, 0x2, 0x4ef, 0x4f2, 
       0x3, 0x2, 0x2, 0x2, 0x4f0, 0x4ee, 0x3, 0x2, 0x2, 0x2, 0x4f0, 0x4f1, 
       0x3, 0x2, 0x2, 0x2, 0x4f1, 0x4f5, 0x3, 0x2, 0x2, 0x2, 0x4f2, 0x4f0, 
       0x3, 0x2, 0x2, 0x2, 0x4f3, 0x4f5, 0x5, 0x5e, 0x30, 0x2, 0x4f4, 0x4eb, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f3, 0x3, 0x2, 0x2, 0x2, 0x4f5, 0x4f7, 
       0x3, 0x2, 0x2, 0x2, 0x4f6, 0x4f8, 0x5, 0x14, 0xb, 0x2, 0x4f7, 0x4f6, 
       0x3, 0x2, 0x2, 0x2, 0x4f7, 0x4f8, 0x3, 0x2, 0x2, 0x2, 0x4f8, 0x9, 
       0x3, 0x2, 0x2, 0x2, 0x4f9, 0x4fe, 0x5, 0xc, 0x7, 0x2, 0x4fa, 0x4fb, 
       0x7, 0x301, 0x2, 0x2, 0x4fb, 0x4fd, 0x5, 0xc, 0x7, 0x2, 0x4fc, 0x4fa, 
       0x3, 0x2, 0x2, 0x2, 0x4fd, 0x500, 0x3, 0x2, 0x2, 0x2, 0x4fe, 0x4fc, 
       0x3, 0x2, 0x2, 0x2, 0x4fe, 0x4ff, 0x3, 0x2, 0x2, 0x2, 0x4ff, 0xb, 
       0x3, 0x2, 0x2, 0x2, 0x500, 0x4fe, 0x3, 0x2, 0x2, 0x2, 0x501, 0x504, 
       0x5, 0x3b6, 0x1dc, 0x2, 0x502, 0x504, 0x5, 0xe, 0x8, 0x2, 0x503, 
       0x501, 0x3, 0x2, 0x2, 0x2, 0x503, 0x502, 0x3, 0x2, 0x2, 0x2, 0x504, 
       0xd, 0x3, 0x2, 0x2, 0x2, 0x505, 0x506, 0x5, 0x33e, 0x1a0, 0x2, 0x506, 
       0x50a, 0x7, 0x2f0, 0x2, 0x2, 0x507, 0x508, 0x5, 0x33e, 0x1a0, 0x2, 
       0x508, 0x509, 0x7, 0x2f0, 0x2, 0x2, 0x509, 0x50b, 0x3, 0x2, 0x2, 
       0x2, 0x50a, 0x507, 0x3, 0x2, 0x2, 0x2, 0x50a, 0x50b, 0x3, 0x2, 0x2, 
       0x2, 0x50b, 0x50c, 0x3, 0x2, 0x2, 0x2, 0x50c, 0x50d, 0x7, 0x2ed, 
       0x2, 0x2, 0x50d, 0xf, 0x3, 0x2, 0x2, 0x2, 0x50e, 0x510, 0x5, 0x14, 
       0xb, 0x2, 0x50f, 0x50e, 0x3, 0x2, 0x2, 0x2, 0x50f, 0x510, 0x3, 0x2, 
       0x2, 0x2, 0x510, 0x516, 0x3, 0x2, 0x2, 0x2, 0x511, 0x513, 0x7, 0x2fb, 
       0x2, 0x2, 0x512, 0x514, 0x5, 0xa, 0x6, 0x2, 0x513, 0x512, 0x3, 0x2, 
       0x2, 0x2, 0x513, 0x514, 0x3, 0x2, 0x2, 0x2, 0x514, 0x515, 0x3, 0x2, 
       0x2, 0x2, 0x515, 0x517, 0x7, 0x2fc, 0x2, 0x2, 0x516, 0x511, 0x3, 
       0x2, 0x2, 0x2, 0x516, 0x517, 0x3, 0x2, 0x2, 0x2, 0x517, 0x518, 0x3, 
       0x2, 0x2, 0x2, 0x518, 0x519, 0x5, 0x36, 0x1c, 0x2, 0x519, 0x11, 0x3, 
       0x2, 0x2, 0x2, 0x51a, 0x51b, 0x7, 0x1b0, 0x2, 0x2, 0x51b, 0x51c, 
       0x7, 0xab, 0x2, 0x2, 0x51c, 0x51d, 0x7, 0x12f, 0x2, 0x2, 0x51d, 0x51e, 
       0x7, 0x2b2, 0x2, 0x2, 0x51e, 0x523, 0x5, 0x24, 0x13, 0x2, 0x51f, 
       0x520, 0x7, 0x301, 0x2, 0x2, 0x520, 0x522, 0x5, 0x24, 0x13, 0x2, 
       0x521, 0x51f, 0x3, 0x2, 0x2, 0x2, 0x522, 0x525, 0x3, 0x2, 0x2, 0x2, 
       0x523, 0x521, 0x3, 0x2, 0x2, 0x2, 0x523, 0x524, 0x3, 0x2, 0x2, 0x2, 
       0x524, 0x13, 0x3, 0x2, 0x2, 0x2, 0x525, 0x523, 0x3, 0x2, 0x2, 0x2, 
       0x526, 0x527, 0x7, 0x2c, 0x2, 0x2, 0x527, 0x529, 0x5, 0x370, 0x1b9, 
       0x2, 0x528, 0x52a, 0x5, 0x16, 0xc, 0x2, 0x529, 0x528, 0x3, 0x2, 0x2, 
       0x2, 0x529, 0x52a, 0x3, 0x2, 0x2, 0x2, 0x52a, 0x15, 0x3, 0x2, 0x2, 
       0x2, 0x52b, 0x52c, 0x7, 0x2fb, 0x2, 0x2, 0x52c, 0x531, 0x5, 0x370, 
       0x1b9, 0x2, 0x52d, 0x52e, 0x7, 0x301, 0x2, 0x2, 0x52e, 0x530, 0x5, 
       0x370, 0x1b9, 0x2, 0x52f, 0x52d, 0x3, 0x2, 0x2, 0x2, 0x530, 0x533, 
       0x3, 0x2, 0x2, 0x2, 0x531, 0x52f, 0x3, 0x2, 0x2, 0x2, 0x531, 0x532, 
       0x3, 0x2, 0x2, 0x2, 0x532, 0x534, 0x3, 0x2, 0x2, 0x2, 0x533, 0x531, 
       0x3, 0x2, 0x2, 0x2, 0x534, 0x535, 0x7, 0x2fc, 0x2, 0x2, 0x535, 0x17, 
       0x3, 0x2, 0x2, 0x2, 0x536, 0x538, 0x7, 0x208, 0x2, 0x2, 0x537, 0x539, 
       0x5, 0x1a, 0xe, 0x2, 0x538, 0x537, 0x3, 0x2, 0x2, 0x2, 0x538, 0x539, 
       0x3, 0x2, 0x2, 0x2, 0x539, 0x53b, 0x3, 0x2, 0x2, 0x2, 0x53a, 0x53c, 
       0x7, 0x11f, 0x2, 0x2, 0x53b, 0x53a, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x53c, 
       0x3, 0x2, 0x2, 0x2, 0x53c, 0x53d, 0x3, 0x2, 0x2, 0x2, 0x53d, 0x53f, 
       0x5, 0x35a, 0x1ae, 0x2, 0x53e, 0x540, 0x5, 0x7a, 0x3e, 0x2, 0x53f, 
       0x53e, 0x3, 0x2, 0x2, 0x2, 0x53f, 0x540, 0x3, 0x2, 0x2, 0x2, 0x540, 
       0x544, 0x3, 0x2, 0x2, 0x2, 0x541, 0x545, 0x5, 0x1c, 0xf, 0x2, 0x542, 
       0x545, 0x5, 0x26, 0x14, 0x2, 0x543, 0x545, 0x5, 0x1e, 0x10, 0x2, 
       0x544, 0x541, 0x3, 0x2, 0x2, 0x2, 0x544, 0x542, 0x3, 0x2, 0x2, 0x2, 
       0x544, 0x543, 0x3, 0x2, 0x2, 0x2, 0x545, 0x19, 0x3, 0x2, 0x2, 0x2, 
       0x546, 0x547, 0x9, 0x4, 0x2, 0x2, 0x547, 0x1b, 0x3, 0x2, 0x2, 0x2, 
       0x548, 0x54a, 0x7, 0x2fb, 0x2, 0x2, 0x549, 0x54b, 0x5, 0xa, 0x6, 
       0x2, 0x54a, 0x549, 0x3, 0x2, 0x2, 0x2, 0x54a, 0x54b, 0x3, 0x2, 0x2, 
       0x2, 0x54b, 0x54c, 0x3, 0x2, 0x2, 0x2, 0x54c, 0x54e, 0x7, 0x2fc, 
       0x2, 0x2, 0x54d, 0x548, 0x3, 0x2, 0x2, 0x2, 0x54d, 0x54e, 0x3, 0x2, 
       0x2, 0x2, 0x54e, 0x54f, 0x3, 0x2, 0x2, 0x2, 0x54f, 0x559, 0x9, 0x3, 
       0x2, 0x2, 0x550, 0x555, 0x5, 0x28, 0x15, 0x2, 0x551, 0x552, 0x7, 
       0x301, 0x2, 0x2, 0x552, 0x554, 0x5, 0x28, 0x15, 0x2, 0x553, 0x551, 
       0x3, 0x2, 0x2, 0x2, 0x554, 0x557, 0x3, 0x2, 0x2, 0x2, 0x555, 0x553, 
       0x3, 0x2, 0x2, 0x2, 0x555, 0x556, 0x3, 0x2, 0x2, 0x2, 0x556, 0x55a, 
       0x3, 0x2, 0x2, 0x2, 0x557, 0x555, 0x3, 0x2, 0x2, 0x2, 0x558, 0x55a, 
       0x5, 0x5e, 0x30, 0x2, 0x559, 0x550, 0x3, 0x2, 0x2, 0x2, 0x559, 0x558, 
       0x3, 0x2, 0x2, 0x2, 0x55a, 0x55c, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x55d, 
       0x5, 0x14, 0xb, 0x2, 0x55c, 0x55b, 0x3, 0x2, 0x2, 0x2, 0x55c, 0x55d, 
       0x3, 0x2, 0x2, 0x2, 0x55d, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x55e, 0x560, 
       0x5, 0x14, 0xb, 0x2, 0x55f, 0x55e, 0x3, 0x2, 0x2, 0x2, 0x55f, 0x560, 
       0x3, 0x2, 0x2, 0x2, 0x560, 0x566, 0x3, 0x2, 0x2, 0x2, 0x561, 0x563, 
       0x7, 0x2fb, 0x2, 0x2, 0x562, 0x564, 0x5, 0xa, 0x6, 0x2, 0x563, 0x562, 
       0x3, 0x2, 0x2, 0x2, 0x563, 0x564, 0x3, 0x2, 0x2, 0x2, 0x564, 0x565, 
       0x3, 0x2, 0x2, 0x2, 0x565, 0x567, 0x7, 0x2fc, 0x2, 0x2, 0x566, 0x561, 
       0x3, 0x2, 0x2, 0x2, 0x566, 0x567, 0x3, 0x2, 0x2, 0x2, 0x567, 0x568, 
       0x3, 0x2, 0x2, 0x2, 0x568, 0x569, 0x5, 0x36, 0x1c, 0x2, 0x569, 0x1f, 
       0x3, 0x2, 0x2, 0x2, 0x56a, 0x56c, 0x5, 0x60, 0x31, 0x2, 0x56b, 0x56a, 
       0x3, 0x2, 0x2, 0x2, 0x56b, 0x56c, 0x3, 0x2, 0x2, 0x2, 0x56c, 0x56d, 
       0x3, 0x2, 0x2, 0x2, 0x56d, 0x56e, 0x7, 0x2b2, 0x2, 0x2, 0x56e, 0x56f, 
       0x5, 0x22, 0x12, 0x2, 0x56f, 0x570, 0x5, 0x72, 0x3a, 0x2, 0x570, 
       0x572, 0x5, 0x26, 0x14, 0x2, 0x571, 0x573, 0x5, 0x8a, 0x46, 0x2, 
       0x572, 0x571, 0x3, 0x2, 0x2, 0x2, 0x572, 0x573, 0x3, 0x2, 0x2, 0x2, 
       0x573, 0x575, 0x3, 0x2, 0x2, 0x2, 0x574, 0x576, 0x5, 0x416, 0x20c, 
       0x2, 0x575, 0x574, 0x3, 0x2, 0x2, 0x2, 0x575, 0x576, 0x3, 0x2, 0x2, 
       0x2, 0x576, 0x578, 0x3, 0x2, 0x2, 0x2, 0x577, 0x579, 0x5, 0x90, 0x49, 
       0x2, 0x578, 0x577, 0x3, 0x2, 0x2, 0x2, 0x578, 0x579, 0x3, 0x2, 0x2, 
       0x2, 0x579, 0x21, 0x3, 0x2, 0x2, 0x2, 0x57a, 0x57c, 0x7, 0x152, 0x2, 
       0x2, 0x57b, 0x57a, 0x3, 0x2, 0x2, 0x2, 0x57b, 0x57c, 0x3, 0x2, 0x2, 
       0x2, 0x57c, 0x57e, 0x3, 0x2, 0x2, 0x2, 0x57d, 0x57f, 0x7, 0x107, 
       0x2, 0x2, 0x57e, 0x57d, 0x3, 0x2, 0x2, 0x2, 0x57e, 0x57f, 0x3, 0x2, 
       0x2, 0x2, 0x57f, 0x23, 0x3, 0x2, 0x2, 0x2, 0x580, 0x581, 0x5, 0x3b6, 
       0x1dc, 0x2, 0x581, 0x582, 0x7, 0x2f4, 0x2, 0x2, 0x582, 0x583, 0x5, 
       0x2a, 0x16, 0x2, 0x583, 0x25, 0x3, 0x2, 0x2, 0x2, 0x584, 0x586, 0x5, 
       0x14, 0xb, 0x2, 0x585, 0x584, 0x3, 0x2, 0x2, 0x2, 0x585, 0x586, 0x3, 
       0x2, 0x2, 0x2, 0x586, 0x587, 0x3, 0x2, 0x2, 0x2, 0x587, 0x588, 0x7, 
       0x244, 0x2, 0x2, 0x588, 0x58d, 0x5, 0x24, 0x13, 0x2, 0x589, 0x58a, 
       0x7, 0x301, 0x2, 0x2, 0x58a, 0x58c, 0x5, 0x24, 0x13, 0x2, 0x58b, 
       0x589, 0x3, 0x2, 0x2, 0x2, 0x58c, 0x58f, 0x3, 0x2, 0x2, 0x2, 0x58d, 
       0x58b, 0x3, 0x2, 0x2, 0x2, 0x58d, 0x58e, 0x3, 0x2, 0x2, 0x2, 0x58e, 
       0x27, 0x3, 0x2, 0x2, 0x2, 0x58f, 0x58d, 0x3, 0x2, 0x2, 0x2, 0x590, 
       0x591, 0x7, 0x2fb, 0x2, 0x2, 0x591, 0x596, 0x5, 0x2a, 0x16, 0x2, 
       0x592, 0x593, 0x7, 0x301, 0x2, 0x2, 0x593, 0x595, 0x5, 0x2a, 0x16, 
       0x2, 0x594, 0x592, 0x3, 0x2, 0x2, 0x2, 0x595, 0x598, 0x3, 0x2, 0x2, 
       0x2, 0x596, 0x594, 0x3, 0x2, 0x2, 0x2, 0x596, 0x597, 0x3, 0x2, 0x2, 
       0x2, 0x597, 0x599, 0x3, 0x2, 0x2, 0x2, 0x598, 0x596, 0x3, 0x2, 0x2, 
       0x2, 0x599, 0x59a, 0x7, 0x2fc, 0x2, 0x2, 0x59a, 0x59e, 0x3, 0x2, 
       0x2, 0x2, 0x59b, 0x59c, 0x7, 0x2fb, 0x2, 0x2, 0x59c, 0x59e, 0x7, 
       0x2fc, 0x2, 0x2, 0x59d, 0x590, 0x3, 0x2, 0x2, 0x2, 0x59d, 0x59b, 
       0x3, 0x2, 0x2, 0x2, 0x59e, 0x29, 0x3, 0x2, 0x2, 0x2, 0x59f, 0x5a3, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x5a0, 0x5a3, 0x7, 0x92, 0x2, 0x2, 0x5a1, 
       0x5a3, 0x5, 0x2c, 0x17, 0x2, 0x5a2, 0x59f, 0x3, 0x2, 0x2, 0x2, 0x5a2, 
       0x5a0, 0x3, 0x2, 0x2, 0x2, 0x5a2, 0x5a1, 0x3, 0x2, 0x2, 0x2, 0x5a3, 
       0x2b, 0x3, 0x2, 0x2, 0x2, 0x5a4, 0x5a5, 0x7, 0x17, 0x2, 0x2, 0x5a5, 
       0x5a6, 0x5, 0x32c, 0x197, 0x2, 0x5a6, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x5a7, 
       0x5a8, 0x7, 0x98, 0x2, 0x2, 0x5a8, 0x5ab, 0x5, 0x30, 0x19, 0x2, 0x5a9, 
       0x5ac, 0x5, 0x32, 0x1a, 0x2, 0x5aa, 0x5ac, 0x5, 0x34, 0x1b, 0x2, 
       0x5ab, 0x5a9, 0x3, 0x2, 0x2, 0x2, 0x5ab, 0x5aa, 0x3, 0x2, 0x2, 0x2, 
       0x5ac, 0x5ae, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5af, 0x5, 0x8a, 0x46, 
       0x2, 0x5ae, 0x5ad, 0x3, 0x2, 0x2, 0x2, 0x5ae, 0x5af, 0x3, 0x2, 0x2, 
       0x2, 0x5af, 0x5b1, 0x3, 0x2, 0x2, 0x2, 0x5b0, 0x5b2, 0x5, 0x416, 
       0x20c, 0x2, 0x5b1, 0x5b0, 0x3, 0x2, 0x2, 0x2, 0x5b1, 0x5b2, 0x3, 
       0x2, 0x2, 0x2, 0x5b2, 0x5b4, 0x3, 0x2, 0x2, 0x2, 0x5b3, 0x5b5, 0x5, 
       0x90, 0x49, 0x2, 0x5b4, 0x5b3, 0x3, 0x2, 0x2, 0x2, 0x5b4, 0x5b5, 
       0x3, 0x2, 0x2, 0x2, 0x5b5, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x5b6, 0x5b8, 
       0x7, 0x152, 0x2, 0x2, 0x5b7, 0x5b6, 0x3, 0x2, 0x2, 0x2, 0x5b7, 0x5b8, 
       0x3, 0x2, 0x2, 0x2, 0x5b8, 0x5ba, 0x3, 0x2, 0x2, 0x2, 0x5b9, 0x5bb, 
       0x7, 0x1ea, 0x2, 0x2, 0x5ba, 0x5b9, 0x3, 0x2, 0x2, 0x2, 0x5ba, 0x5bb, 
       0x3, 0x2, 0x2, 0x2, 0x5bb, 0x5bd, 0x3, 0x2, 0x2, 0x2, 0x5bc, 0x5be, 
       0x7, 0x107, 0x2, 0x2, 0x5bd, 0x5bc, 0x3, 0x2, 0x2, 0x2, 0x5bd, 0x5be, 
       0x3, 0x2, 0x2, 0x2, 0x5be, 0x31, 0x3, 0x2, 0x2, 0x2, 0x5bf, 0x5c0, 
       0x7, 0xe5, 0x2, 0x2, 0x5c0, 0x5c5, 0x5, 0x35a, 0x1ae, 0x2, 0x5c1, 
       0x5c3, 0x7, 0x2c, 0x2, 0x2, 0x5c2, 0x5c1, 0x3, 0x2, 0x2, 0x2, 0x5c2, 
       0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5c3, 0x5c4, 0x3, 0x2, 0x2, 0x2, 0x5c4, 
       0x5c6, 0x5, 0x370, 0x1b9, 0x2, 0x5c5, 0x5c2, 0x3, 0x2, 0x2, 0x2, 
       0x5c5, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x5c6, 0x5c8, 0x3, 0x2, 0x2, 0x2, 
       0x5c7, 0x5c9, 0x5, 0x7a, 0x3e, 0x2, 0x5c8, 0x5c7, 0x3, 0x2, 0x2, 
       0x2, 0x5c8, 0x5c9, 0x3, 0x2, 0x2, 0x2, 0x5c9, 0x33, 0x3, 0x2, 0x2, 
       0x2, 0x5ca, 0x5cb, 0x5, 0xae, 0x58, 0x2, 0x5cb, 0x5cc, 0x7, 0xe5, 
       0x2, 0x2, 0x5cc, 0x5cd, 0x5, 0x72, 0x3a, 0x2, 0x5cd, 0x5d4, 0x3, 
       0x2, 0x2, 0x2, 0x5ce, 0x5cf, 0x7, 0xe5, 0x2, 0x2, 0x5cf, 0x5d0, 0x5, 
       0xae, 0x58, 0x2, 0x5d0, 0x5d1, 0x7, 0x2b9, 0x2, 0x2, 0x5d1, 0x5d2, 
       0x5, 0x72, 0x3a, 0x2, 0x5d2, 0x5d4, 0x3, 0x2, 0x2, 0x2, 0x5d3, 0x5ca, 
       0x3, 0x2, 0x2, 0x2, 0x5d3, 0x5ce, 0x3, 0x2, 0x2, 0x2, 0x5d4, 0x35, 
       0x3, 0x2, 0x2, 0x2, 0x5d5, 0x5d7, 0x5, 0x3a, 0x1e, 0x2, 0x5d6, 0x5d8, 
       0x5, 0xa4, 0x53, 0x2, 0x5d7, 0x5d6, 0x3, 0x2, 0x2, 0x2, 0x5d7, 0x5d8, 
       0x3, 0x2, 0x2, 0x2, 0x5d8, 0x5dc, 0x3, 0x2, 0x2, 0x2, 0x5d9, 0x5dc, 
       0x5, 0x3e, 0x20, 0x2, 0x5da, 0x5dc, 0x5, 0x38, 0x1d, 0x2, 0x5db, 
       0x5d5, 0x3, 0x2, 0x2, 0x2, 0x5db, 0x5d9, 0x3, 0x2, 0x2, 0x2, 0x5db, 
       0x5da, 0x3, 0x2, 0x2, 0x2, 0x5dc, 0x37, 0x3, 0x2, 0x2, 0x2, 0x5dd, 
       0x5de, 0x7, 0x2fb, 0x2, 0x2, 0x5de, 0x5df, 0x5, 0x38, 0x1d, 0x2, 
       0x5df, 0x5e0, 0x7, 0x2fc, 0x2, 0x2, 0x5e0, 0x5eb, 0x3, 0x2, 0x2, 
       0x2, 0x5e1, 0x5e2, 0x5, 0x3a, 0x1e, 0x2, 0x5e2, 0x5e4, 0x5, 0xa0, 
       0x51, 0x2, 0x5e3, 0x5e5, 0x5, 0xa4, 0x53, 0x2, 0x5e4, 0x5e3, 0x3, 
       0x2, 0x2, 0x2, 0x5e4, 0x5e5, 0x3, 0x2, 0x2, 0x2, 0x5e5, 0x5eb, 0x3, 
       0x2, 0x2, 0x2, 0x5e6, 0x5e7, 0x5, 0x3a, 0x1e, 0x2, 0x5e7, 0x5e8, 
       0x5, 0xa4, 0x53, 0x2, 0x5e8, 0x5e9, 0x5, 0xa0, 0x51, 0x2, 0x5e9, 
       0x5eb, 0x3, 0x2, 0x2, 0x2, 0x5ea, 0x5dd, 0x3, 0x2, 0x2, 0x2, 0x5ea, 
       0x5e1, 0x3, 0x2, 0x2, 0x2, 0x5ea, 0x5e6, 0x3, 0x2, 0x2, 0x2, 0x5eb, 
       0x39, 0x3, 0x2, 0x2, 0x2, 0x5ec, 0x5ee, 0x5, 0x60, 0x31, 0x2, 0x5ed, 
       0x5ec, 0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0x5ee, 
       0x5f1, 0x3, 0x2, 0x2, 0x2, 0x5ef, 0x5f2, 0x5, 0x3c, 0x1f, 0x2, 0x5f0, 
       0x5f2, 0x5, 0x3e, 0x20, 0x2, 0x5f1, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x5f1, 
       0x5f0, 0x3, 0x2, 0x2, 0x2, 0x5f2, 0x5f4, 0x3, 0x2, 0x2, 0x2, 0x5f3, 
       0x5f5, 0x5, 0x416, 0x20c, 0x2, 0x5f4, 0x5f3, 0x3, 0x2, 0x2, 0x2, 
       0x5f4, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0x5f5, 0x5f7, 0x3, 0x2, 0x2, 0x2, 
       0x5f6, 0x5f8, 0x5, 0x90, 0x49, 0x2, 0x5f7, 0x5f6, 0x3, 0x2, 0x2, 
       0x2, 0x5f7, 0x5f8, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x3b, 0x3, 0x2, 0x2, 
       0x2, 0x5f9, 0x5fa, 0x8, 0x1f, 0x1, 0x2, 0x5fa, 0x605, 0x5, 0x40, 
       0x21, 0x2, 0x5fb, 0x5fc, 0x5, 0x3e, 0x20, 0x2, 0x5fc, 0x5fe, 0x7, 
       0x2ac, 0x2, 0x2, 0x5fd, 0x5ff, 0x5, 0x456, 0x22c, 0x2, 0x5fe, 0x5fd, 
       0x3, 0x2, 0x2, 0x2, 0x5fe, 0x5ff, 0x3, 0x2, 0x2, 0x2, 0x5ff, 0x602, 
       0x3, 0x2, 0x2, 0x2, 0x600, 0x603, 0x5, 0x40, 0x21, 0x2, 0x601, 0x603, 
       0x5, 0x3e, 0x20, 0x2, 0x602, 0x600, 0x3, 0x2, 0x2, 0x2, 0x602, 0x601, 
       0x3, 0x2, 0x2, 0x2, 0x603, 0x605, 0x3, 0x2, 0x2, 0x2, 0x604, 0x5f9, 
       0x3, 0x2, 0x2, 0x2, 0x604, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x605, 0x611, 
       0x3, 0x2, 0x2, 0x2, 0x606, 0x607, 0xc, 0x3, 0x2, 0x2, 0x607, 0x609, 
       0x7, 0x2ac, 0x2, 0x2, 0x608, 0x60a, 0x5, 0x456, 0x22c, 0x2, 0x609, 
       0x608, 0x3, 0x2, 0x2, 0x2, 0x609, 0x60a, 0x3, 0x2, 0x2, 0x2, 0x60a, 
       0x60d, 0x3, 0x2, 0x2, 0x2, 0x60b, 0x60e, 0x5, 0x40, 0x21, 0x2, 0x60c, 
       0x60e, 0x5, 0x3e, 0x20, 0x2, 0x60d, 0x60b, 0x3, 0x2, 0x2, 0x2, 0x60d, 
       0x60c, 0x3, 0x2, 0x2, 0x2, 0x60e, 0x610, 0x3, 0x2, 0x2, 0x2, 0x60f, 
       0x606, 0x3, 0x2, 0x2, 0x2, 0x610, 0x613, 0x3, 0x2, 0x2, 0x2, 0x611, 
       0x60f, 0x3, 0x2, 0x2, 0x2, 0x611, 0x612, 0x3, 0x2, 0x2, 0x2, 0x612, 
       0x3d, 0x3, 0x2, 0x2, 0x2, 0x613, 0x611, 0x3, 0x2, 0x2, 0x2, 0x614, 
       0x61a, 0x7, 0x2fb, 0x2, 0x2, 0x615, 0x61b, 0x5, 0x3e, 0x20, 0x2, 
       0x616, 0x618, 0x5, 0x3a, 0x1e, 0x2, 0x617, 0x619, 0x5, 0xa4, 0x53, 
       0x2, 0x618, 0x617, 0x3, 0x2, 0x2, 0x2, 0x618, 0x619, 0x3, 0x2, 0x2, 
       0x2, 0x619, 0x61b, 0x3, 0x2, 0x2, 0x2, 0x61a, 0x615, 0x3, 0x2, 0x2, 
       0x2, 0x61a, 0x616, 0x3, 0x2, 0x2, 0x2, 0x61b, 0x61c, 0x3, 0x2, 0x2, 
       0x2, 0x61c, 0x61d, 0x7, 0x2fc, 0x2, 0x2, 0x61d, 0x3f, 0x3, 0x2, 0x2, 
       0x2, 0x61e, 0x622, 0x5, 0x42, 0x22, 0x2, 0x61f, 0x622, 0x5, 0x5c, 
       0x2f, 0x2, 0x620, 0x622, 0x5, 0x5a, 0x2e, 0x2, 0x621, 0x61e, 0x3, 
       0x2, 0x2, 0x2, 0x621, 0x61f, 0x3, 0x2, 0x2, 0x2, 0x621, 0x620, 0x3, 
       0x2, 0x2, 0x2, 0x622, 0x41, 0x3, 0x2, 0x2, 0x2, 0x623, 0x627, 0x7, 
       0x23d, 0x2, 0x2, 0x624, 0x626, 0x5, 0x64, 0x33, 0x2, 0x625, 0x624, 
       0x3, 0x2, 0x2, 0x2, 0x626, 0x629, 0x3, 0x2, 0x2, 0x2, 0x627, 0x625, 
       0x3, 0x2, 0x2, 0x2, 0x627, 0x628, 0x3, 0x2, 0x2, 0x2, 0x628, 0x62a, 
       0x3, 0x2, 0x2, 0x2, 0x629, 0x627, 0x3, 0x2, 0x2, 0x2, 0x62a, 0x62c, 
       0x5, 0x68, 0x35, 0x2, 0x62b, 0x62d, 0x5, 0xa0, 0x51, 0x2, 0x62c, 
       0x62b, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x62d, 0x3, 0x2, 0x2, 0x2, 0x62d, 
       0x62f, 0x3, 0x2, 0x2, 0x2, 0x62e, 0x630, 0x5, 0x70, 0x39, 0x2, 0x62f, 
       0x62e, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x630, 0x3, 0x2, 0x2, 0x2, 0x630, 
       0x632, 0x3, 0x2, 0x2, 0x2, 0x631, 0x633, 0x5, 0x8a, 0x46, 0x2, 0x632, 
       0x631, 0x3, 0x2, 0x2, 0x2, 0x632, 0x633, 0x3, 0x2, 0x2, 0x2, 0x633, 
       0x635, 0x3, 0x2, 0x2, 0x2, 0x634, 0x636, 0x5, 0x8c, 0x47, 0x2, 0x635, 
       0x634, 0x3, 0x2, 0x2, 0x2, 0x635, 0x636, 0x3, 0x2, 0x2, 0x2, 0x636, 
       0x638, 0x3, 0x2, 0x2, 0x2, 0x637, 0x639, 0x5, 0x8e, 0x48, 0x2, 0x638, 
       0x637, 0x3, 0x2, 0x2, 0x2, 0x638, 0x639, 0x3, 0x2, 0x2, 0x2, 0x639, 
       0x63b, 0x3, 0x2, 0x2, 0x2, 0x63a, 0x63c, 0x5, 0x96, 0x4c, 0x2, 0x63b, 
       0x63a, 0x3, 0x2, 0x2, 0x2, 0x63b, 0x63c, 0x3, 0x2, 0x2, 0x2, 0x63c, 
       0x43, 0x3, 0x2, 0x2, 0x2, 0x63d, 0x63e, 0x7, 0x48, 0x2, 0x2, 0x63e, 
       0x64b, 0x5, 0x33e, 0x1a0, 0x2, 0x63f, 0x648, 0x7, 0x2fb, 0x2, 0x2, 
       0x640, 0x645, 0x5, 0x3a6, 0x1d4, 0x2, 0x641, 0x642, 0x7, 0x301, 0x2, 
       0x2, 0x642, 0x644, 0x5, 0x3a6, 0x1d4, 0x2, 0x643, 0x641, 0x3, 0x2, 
       0x2, 0x2, 0x644, 0x647, 0x3, 0x2, 0x2, 0x2, 0x645, 0x643, 0x3, 0x2, 
       0x2, 0x2, 0x645, 0x646, 0x3, 0x2, 0x2, 0x2, 0x646, 0x649, 0x3, 0x2, 
       0x2, 0x2, 0x647, 0x645, 0x3, 0x2, 0x2, 0x2, 0x648, 0x640, 0x3, 0x2, 
       0x2, 0x2, 0x648, 0x649, 0x3, 0x2, 0x2, 0x2, 0x649, 0x64a, 0x3, 0x2, 
       0x2, 0x2, 0x64a, 0x64c, 0x7, 0x2fc, 0x2, 0x2, 0x64b, 0x63f, 0x3, 
       0x2, 0x2, 0x2, 0x64b, 0x64c, 0x3, 0x2, 0x2, 0x2, 0x64c, 0x45, 0x3, 
       0x2, 0x2, 0x2, 0x64d, 0x64e, 0x7, 0xa6, 0x2, 0x2, 0x64e, 0x653, 0x5, 
       0x3a6, 0x1d4, 0x2, 0x64f, 0x650, 0x7, 0x301, 0x2, 0x2, 0x650, 0x652, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x651, 0x64f, 0x3, 0x2, 0x2, 0x2, 0x652, 
       0x655, 0x3, 0x2, 0x2, 0x2, 0x653, 0x651, 0x3, 0x2, 0x2, 0x2, 0x653, 
       0x654, 0x3, 0x2, 0x2, 0x2, 0x654, 0x47, 0x3, 0x2, 0x2, 0x2, 0x655, 
       0x653, 0x3, 0x2, 0x2, 0x2, 0x656, 0x65b, 0x5, 0x4a, 0x26, 0x2, 0x657, 
       0x65b, 0x5, 0x4c, 0x27, 0x2, 0x658, 0x65b, 0x5, 0x4e, 0x28, 0x2, 
       0x659, 0x65b, 0x5, 0x50, 0x29, 0x2, 0x65a, 0x656, 0x3, 0x2, 0x2, 
       0x2, 0x65a, 0x657, 0x3, 0x2, 0x2, 0x2, 0x65a, 0x658, 0x3, 0x2, 0x2, 
       0x2, 0x65a, 0x659, 0x3, 0x2, 0x2, 0x2, 0x65b, 0x49, 0x3, 0x2, 0x2, 
       0x2, 0x65c, 0x65d, 0x7, 0xf8, 0x2, 0x2, 0x65d, 0x65e, 0x5, 0x35a, 
       0x1ae, 0x2, 0x65e, 0x663, 0x7, 0x1b3, 0x2, 0x2, 0x65f, 0x661, 0x7, 
       0x2c, 0x2, 0x2, 0x660, 0x65f, 0x3, 0x2, 0x2, 0x2, 0x660, 0x661, 0x3, 
       0x2, 0x2, 0x2, 0x661, 0x662, 0x3, 0x2, 0x2, 0x2, 0x662, 0x664, 0x5, 
       0x33e, 0x1a0, 0x2, 0x663, 0x660, 0x3, 0x2, 0x2, 0x2, 0x663, 0x664, 
       0x3, 0x2, 0x2, 0x2, 0x664, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x665, 0x666, 
       0x7, 0xf8, 0x2, 0x2, 0x666, 0x667, 0x5, 0x35a, 0x1ae, 0x2, 0x667, 
       0x668, 0x7, 0x1ee, 0x2, 0x2, 0x668, 0x66f, 0x5, 0x35e, 0x1b0, 0x2, 
       0x669, 0x66a, 0x5, 0x3ae, 0x1d8, 0x2, 0x66a, 0x66b, 0x7, 0x2fb, 0x2, 
       0x2, 0x66b, 0x66c, 0x5, 0x33e, 0x1a0, 0x2, 0x66c, 0x66d, 0x7, 0x2fc, 
       0x2, 0x2, 0x66d, 0x670, 0x3, 0x2, 0x2, 0x2, 0x66e, 0x670, 0x9, 0x5, 
       0x2, 0x2, 0x66f, 0x669, 0x3, 0x2, 0x2, 0x2, 0x66f, 0x66e, 0x3, 0x2, 
       0x2, 0x2, 0x670, 0x672, 0x3, 0x2, 0x2, 0x2, 0x671, 0x673, 0x5, 0x8a, 
       0x46, 0x2, 0x672, 0x671, 0x3, 0x2, 0x2, 0x2, 0x672, 0x673, 0x3, 0x2, 
       0x2, 0x2, 0x673, 0x675, 0x3, 0x2, 0x2, 0x2, 0x674, 0x676, 0x5, 0x90, 
       0x49, 0x2, 0x675, 0x674, 0x3, 0x2, 0x2, 0x2, 0x675, 0x676, 0x3, 0x2, 
       0x2, 0x2, 0x676, 0x4d, 0x3, 0x2, 0x2, 0x2, 0x677, 0x678, 0x7, 0xf8, 
       0x2, 0x2, 0x678, 0x679, 0x5, 0x35a, 0x1ae, 0x2, 0x679, 0x67a, 0x7, 
       0x1ee, 0x2, 0x2, 0x67a, 0x67c, 0x9, 0x6, 0x2, 0x2, 0x67b, 0x67d, 
       0x5, 0x8a, 0x46, 0x2, 0x67c, 0x67b, 0x3, 0x2, 0x2, 0x2, 0x67c, 0x67d, 
       0x3, 0x2, 0x2, 0x2, 0x67d, 0x67f, 0x3, 0x2, 0x2, 0x2, 0x67e, 0x680, 
       0x5, 0x90, 0x49, 0x2, 0x67f, 0x67e, 0x3, 0x2, 0x2, 0x2, 0x67f, 0x680, 
       0x3, 0x2, 0x2, 0x2, 0x680, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x681, 0x682, 
       0x7, 0xf8, 0x2, 0x2, 0x682, 0x683, 0x5, 0x35a, 0x1ae, 0x2, 0x683, 
       0x684, 0x7, 0x5a, 0x2, 0x2, 0x684, 0x51, 0x3, 0x2, 0x2, 0x2, 0x685, 
       0x686, 0x7, 0x109, 0x2, 0x2, 0x686, 0x687, 0x7, 0x286, 0x2, 0x2, 
       0x687, 0x688, 0x7, 0xe5, 0x2, 0x2, 0x688, 0x68b, 0x5, 0x32c, 0x197, 
       0x2, 0x689, 0x68a, 0x7, 0x301, 0x2, 0x2, 0x68a, 0x68c, 0x5, 0x32c, 
       0x197, 0x2, 0x68b, 0x689, 0x3, 0x2, 0x2, 0x2, 0x68b, 0x68c, 0x3, 
       0x2, 0x2, 0x2, 0x68c, 0x53, 0x3, 0x2, 0x2, 0x2, 0x68d, 0x690, 0x5, 
       0x56, 0x2c, 0x2, 0x68e, 0x690, 0x5, 0x58, 0x2d, 0x2, 0x68f, 0x68d, 
       0x3, 0x2, 0x2, 0x2, 0x68f, 0x68e, 0x3, 0x2, 0x2, 0x2, 0x690, 0x55, 
       0x3, 0x2, 0x2, 0x2, 0x691, 0x692, 0x7, 0x145, 0x2, 0x2, 0x692, 0x694, 
       0x7, 0x83, 0x2, 0x2, 0x693, 0x695, 0x9, 0x7, 0x2, 0x2, 0x694, 0x693, 
       0x3, 0x2, 0x2, 0x2, 0x694, 0x695, 0x3, 0x2, 0x2, 0x2, 0x695, 0x697, 
       0x3, 0x2, 0x2, 0x2, 0x696, 0x698, 0x7, 0x146, 0x2, 0x2, 0x697, 0x696, 
       0x3, 0x2, 0x2, 0x2, 0x697, 0x698, 0x3, 0x2, 0x2, 0x2, 0x698, 0x699, 
       0x3, 0x2, 0x2, 0x2, 0x699, 0x69a, 0x7, 0x10e, 0x2, 0x2, 0x69a, 0x69c, 
       0x5, 0x32c, 0x197, 0x2, 0x69b, 0x69d, 0x9, 0x8, 0x2, 0x2, 0x69c, 
       0x69b, 0x3, 0x2, 0x2, 0x2, 0x69c, 0x69d, 0x3, 0x2, 0x2, 0x2, 0x69d, 
       0x69e, 0x3, 0x2, 0x2, 0x2, 0x69e, 0x69f, 0x7, 0x11f, 0x2, 0x2, 0x69f, 
       0x6a0, 0x7, 0x286, 0x2, 0x2, 0x6a0, 0x6a2, 0x5, 0x35a, 0x1ae, 0x2, 
       0x6a1, 0x6a3, 0x5, 0x7a, 0x3e, 0x2, 0x6a2, 0x6a1, 0x3, 0x2, 0x2, 
       0x2, 0x6a2, 0x6a3, 0x3, 0x2, 0x2, 0x2, 0x6a3, 0x6a7, 0x3, 0x2, 0x2, 
       0x2, 0x6a4, 0x6a5, 0x7, 0x52, 0x2, 0x2, 0x6a5, 0x6a6, 0x7, 0x244, 
       0x2, 0x2, 0x6a6, 0x6a8, 0x5, 0x33e, 0x1a0, 0x2, 0x6a7, 0x6a4, 0x3, 
       0x2, 0x2, 0x2, 0x6a7, 0x6a8, 0x3, 0x2, 0x2, 0x2, 0x6a8, 0x6af, 0x3, 
       0x2, 0x2, 0x2, 0x6a9, 0x6ab, 0x9, 0x9, 0x2, 0x2, 0x6aa, 0x6ac, 0x5, 
       0x9e, 0x50, 0x2, 0x6ab, 0x6aa, 0x3, 0x2, 0x2, 0x2, 0x6ac, 0x6ad, 
       0x3, 0x2, 0x2, 0x2, 0x6ad, 0x6ab, 0x3, 0x2, 0x2, 0x2, 0x6ad, 0x6ae, 
       0x3, 0x2, 0x2, 0x2, 0x6ae, 0x6b0, 0x3, 0x2, 0x2, 0x2, 0x6af, 0x6a9, 
       0x3, 0x2, 0x2, 0x2, 0x6af, 0x6b0, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b7, 
       0x3, 0x2, 0x2, 0x2, 0x6b1, 0x6b3, 0x7, 0x142, 0x2, 0x2, 0x6b2, 0x6b4, 
       0x5, 0x9c, 0x4f, 0x2, 0x6b3, 0x6b2, 0x3, 0x2, 0x2, 0x2, 0x6b4, 0x6b5, 
       0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6b3, 0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6b6, 
       0x3, 0x2, 0x2, 0x2, 0x6b6, 0x6b8, 0x3, 0x2, 0x2, 0x2, 0x6b7, 0x6b1, 
       0x3, 0x2, 0x2, 0x2, 0x6b7, 0x6b8, 0x3, 0x2, 0x2, 0x2, 0x6b8, 0x6bd, 
       0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6ba, 0x7, 0x107, 0x2, 0x2, 0x6ba, 0x6bb, 
       0x5, 0x330, 0x199, 0x2, 0x6bb, 0x6bc, 0x9, 0xa, 0x2, 0x2, 0x6bc, 
       0x6be, 0x3, 0x2, 0x2, 0x2, 0x6bd, 0x6b9, 0x3, 0x2, 0x2, 0x2, 0x6bd, 
       0x6be, 0x3, 0x2, 0x2, 0x2, 0x6be, 0x6c0, 0x3, 0x2, 0x2, 0x2, 0x6bf, 
       0x6c1, 0x5, 0x448, 0x225, 0x2, 0x6c0, 0x6bf, 0x3, 0x2, 0x2, 0x2, 
       0x6c0, 0x6c1, 0x3, 0x2, 0x2, 0x2, 0x6c1, 0x6c3, 0x3, 0x2, 0x2, 0x2, 
       0x6c2, 0x6c4, 0x5, 0x26, 0x14, 0x2, 0x6c3, 0x6c2, 0x3, 0x2, 0x2, 
       0x2, 0x6c3, 0x6c4, 0x3, 0x2, 0x2, 0x2, 0x6c4, 0x57, 0x3, 0x2, 0x2, 
       0x2, 0x6c5, 0x6c6, 0x7, 0x145, 0x2, 0x2, 0x6c6, 0x6c8, 0x7, 0x2d9, 
       0x2, 0x2, 0x6c7, 0x6c9, 0x9, 0x7, 0x2, 0x2, 0x6c8, 0x6c7, 0x3, 0x2, 
       0x2, 0x2, 0x6c8, 0x6c9, 0x3, 0x2, 0x2, 0x2, 0x6c9, 0x6cb, 0x3, 0x2, 
       0x2, 0x2, 0x6ca, 0x6cc, 0x7, 0x146, 0x2, 0x2, 0x6cb, 0x6ca, 0x3, 
       0x2, 0x2, 0x2, 0x6cb, 0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6cc, 0x6cd, 0x3, 
       0x2, 0x2, 0x2, 0x6cd, 0x6ce, 0x7, 0x10e, 0x2, 0x2, 0x6ce, 0x6d0, 
       0x5, 0x32c, 0x197, 0x2, 0x6cf, 0x6d1, 0x9, 0x8, 0x2, 0x2, 0x6d0, 
       0x6cf, 0x3, 0x2, 0x2, 0x2, 0x6d0, 0x6d1, 0x3, 0x2, 0x2, 0x2, 0x6d1, 
       0x6d2, 0x3, 0x2, 0x2, 0x2, 0x6d2, 0x6d3, 0x7, 0x11f, 0x2, 0x2, 0x6d3, 
       0x6d4, 0x7, 0x286, 0x2, 0x2, 0x6d4, 0x6d8, 0x5, 0x35a, 0x1ae, 0x2, 
       0x6d5, 0x6d6, 0x7, 0x52, 0x2, 0x2, 0x6d6, 0x6d7, 0x7, 0x244, 0x2, 
       0x2, 0x6d7, 0x6d9, 0x5, 0x33e, 0x1a0, 0x2, 0x6d8, 0x6d5, 0x3, 0x2, 
       0x2, 0x2, 0x6d8, 0x6d9, 0x3, 0x2, 0x2, 0x2, 0x6d9, 0x6e1, 0x3, 0x2, 
       0x2, 0x2, 0x6da, 0x6db, 0x7, 0x22b, 0x2, 0x2, 0x6db, 0x6dc, 0x7, 
       0x105, 0x2, 0x2, 0x6dc, 0x6dd, 0x7, 0x45, 0x2, 0x2, 0x6dd, 0x6de, 
       0x7, 0x2f8, 0x2, 0x2, 0x6de, 0x6df, 0x5, 0x32c, 0x197, 0x2, 0x6df, 
       0x6e0, 0x7, 0x2f6, 0x2, 0x2, 0x6e0, 0x6e2, 0x3, 0x2, 0x2, 0x2, 0x6e1, 
       0x6da, 0x3, 0x2, 0x2, 0x2, 0x6e1, 0x6e2, 0x3, 0x2, 0x2, 0x2, 0x6e2, 
       0x6e7, 0x3, 0x2, 0x2, 0x2, 0x6e3, 0x6e4, 0x7, 0x107, 0x2, 0x2, 0x6e4, 
       0x6e5, 0x5, 0x330, 0x199, 0x2, 0x6e5, 0x6e6, 0x9, 0xa, 0x2, 0x2, 
       0x6e6, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6e7, 0x6e3, 0x3, 0x2, 0x2, 0x2, 
       0x6e7, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6e8, 0x6ea, 0x3, 0x2, 0x2, 0x2, 
       0x6e9, 0x6eb, 0x5, 0x448, 0x225, 0x2, 0x6ea, 0x6e9, 0x3, 0x2, 0x2, 
       0x2, 0x6ea, 0x6eb, 0x3, 0x2, 0x2, 0x2, 0x6eb, 0x6ed, 0x3, 0x2, 0x2, 
       0x2, 0x6ec, 0x6ee, 0x5, 0x26, 0x14, 0x2, 0x6ed, 0x6ec, 0x3, 0x2, 
       0x2, 0x2, 0x6ed, 0x6ee, 0x3, 0x2, 0x2, 0x2, 0x6ee, 0x59, 0x3, 0x2, 
       0x2, 0x2, 0x6ef, 0x6f0, 0x7, 0x286, 0x2, 0x2, 0x6f0, 0x6f1, 0x5, 
       0x35a, 0x1ae, 0x2, 0x6f1, 0x5b, 0x3, 0x2, 0x2, 0x2, 0x6f2, 0x6f3, 
       0x7, 0x2bf, 0x2, 0x2, 0x6f3, 0x6f4, 0x5, 0x5e, 0x30, 0x2, 0x6f4, 
       0x5d, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f6, 0x7, 0x22a, 0x2, 0x2, 0x6f6, 
       0x6fc, 0x5, 0x28, 0x15, 0x2, 0x6f7, 0x6f8, 0x7, 0x301, 0x2, 0x2, 
       0x6f8, 0x6f9, 0x7, 0x22a, 0x2, 0x2, 0x6f9, 0x6fb, 0x5, 0x28, 0x15, 
       0x2, 0x6fa, 0x6f7, 0x3, 0x2, 0x2, 0x2, 0x6fb, 0x6fe, 0x3, 0x2, 0x2, 
       0x2, 0x6fc, 0x6fa, 0x3, 0x2, 0x2, 0x2, 0x6fc, 0x6fd, 0x3, 0x2, 0x2, 
       0x2, 0x6fd, 0x5f, 0x3, 0x2, 0x2, 0x2, 0x6fe, 0x6fc, 0x3, 0x2, 0x2, 
       0x2, 0x6ff, 0x701, 0x7, 0x2d1, 0x2, 0x2, 0x700, 0x702, 0x7, 0x1f5, 
       0x2, 0x2, 0x701, 0x700, 0x3, 0x2, 0x2, 0x2, 0x701, 0x702, 0x3, 0x2, 
       0x2, 0x2, 0x702, 0x703, 0x3, 0x2, 0x2, 0x2, 0x703, 0x708, 0x5, 0x62, 
       0x32, 0x2, 0x704, 0x705, 0x7, 0x301, 0x2, 0x2, 0x705, 0x707, 0x5, 
       0x62, 0x32, 0x2, 0x706, 0x704, 0x3, 0x2, 0x2, 0x2, 0x707, 0x70a, 
       0x3, 0x2, 0x2, 0x2, 0x708, 0x706, 0x3, 0x2, 0x2, 0x2, 0x708, 0x709, 
       0x3, 0x2, 0x2, 0x2, 0x709, 0x61, 0x3, 0x2, 0x2, 0x2, 0x70a, 0x708, 
       0x3, 0x2, 0x2, 0x2, 0x70b, 0x710, 0x5, 0x33e, 0x1a0, 0x2, 0x70c, 
       0x70d, 0x7, 0x2fb, 0x2, 0x2, 0x70d, 0x70e, 0x5, 0x378, 0x1bd, 0x2, 
       0x70e, 0x70f, 0x7, 0x2fc, 0x2, 0x2, 0x70f, 0x711, 0x3, 0x2, 0x2, 
       0x2, 0x710, 0x70c, 0x3, 0x2, 0x2, 0x2, 0x710, 0x711, 0x3, 0x2, 0x2, 
       0x2, 0x711, 0x712, 0x3, 0x2, 0x2, 0x2, 0x712, 0x713, 0x7, 0x2c, 0x2, 
       0x2, 0x713, 0x714, 0x5, 0x9a, 0x4e, 0x2, 0x714, 0x63, 0x3, 0x2, 0x2, 
       0x2, 0x715, 0x71e, 0x5, 0x66, 0x34, 0x2, 0x716, 0x71e, 0x7, 0xfc, 
       0x2, 0x2, 0x717, 0x71e, 0x7, 0x27a, 0x2, 0x2, 0x718, 0x71e, 0x7, 
       0x263, 0x2, 0x2, 0x719, 0x71e, 0x7, 0x25f, 0x2, 0x2, 0x71a, 0x71e, 
       0x7, 0x260, 0x2, 0x2, 0x71b, 0x71e, 0x9, 0xb, 0x2, 0x2, 0x71c, 0x71e, 
       0x7, 0x261, 0x2, 0x2, 0x71d, 0x715, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x716, 
       0x3, 0x2, 0x2, 0x2, 0x71d, 0x717, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x718, 
       0x3, 0x2, 0x2, 0x2, 0x71d, 0x719, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x71a, 
       0x3, 0x2, 0x2, 0x2, 0x71d, 0x71b, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x71c, 
       0x3, 0x2, 0x2, 0x2, 0x71e, 0x65, 0x3, 0x2, 0x2, 0x2, 0x71f, 0x720, 
       0x9, 0xc, 0x2, 0x2, 0x720, 0x67, 0x3, 0x2, 0x2, 0x2, 0x721, 0x724, 
       0x5, 0x6c, 0x37, 0x2, 0x722, 0x724, 0x5, 0x6a, 0x36, 0x2, 0x723, 
       0x721, 0x3, 0x2, 0x2, 0x2, 0x723, 0x722, 0x3, 0x2, 0x2, 0x2, 0x724, 
       0x729, 0x3, 0x2, 0x2, 0x2, 0x725, 0x726, 0x7, 0x301, 0x2, 0x2, 0x726, 
       0x728, 0x5, 0x6a, 0x36, 0x2, 0x727, 0x725, 0x3, 0x2, 0x2, 0x2, 0x728, 
       0x72b, 0x3, 0x2, 0x2, 0x2, 0x729, 0x727, 0x3, 0x2, 0x2, 0x2, 0x729, 
       0x72a, 0x3, 0x2, 0x2, 0x2, 0x72a, 0x69, 0x3, 0x2, 0x2, 0x2, 0x72b, 
       0x729, 0x3, 0x2, 0x2, 0x2, 0x72c, 0x731, 0x5, 0x3a6, 0x1d4, 0x2, 
       0x72d, 0x72f, 0x7, 0x2c, 0x2, 0x2, 0x72e, 0x72d, 0x3, 0x2, 0x2, 0x2, 
       0x72e, 0x72f, 0x3, 0x2, 0x2, 0x2, 0x72f, 0x730, 0x3, 0x2, 0x2, 0x2, 
       0x730, 0x732, 0x5, 0x370, 0x1b9, 0x2, 0x731, 0x72e, 0x3, 0x2, 0x2, 
       0x2, 0x731, 0x732, 0x3, 0x2, 0x2, 0x2, 0x732, 0x735, 0x3, 0x2, 0x2, 
       0x2, 0x733, 0x735, 0x5, 0x6e, 0x38, 0x2, 0x734, 0x72c, 0x3, 0x2, 
       0x2, 0x2, 0x734, 0x733, 0x3, 0x2, 0x2, 0x2, 0x735, 0x6b, 0x3, 0x2, 
       0x2, 0x2, 0x736, 0x737, 0x7, 0x2ed, 0x2, 0x2, 0x737, 0x6d, 0x3, 0x2, 
       0x2, 0x2, 0x738, 0x739, 0x5, 0x33e, 0x1a0, 0x2, 0x739, 0x73a, 0x7, 
       0x2f1, 0x2, 0x2, 0x73a, 0x6f, 0x3, 0x2, 0x2, 0x2, 0x73b, 0x73e, 0x7, 
       0xe5, 0x2, 0x2, 0x73c, 0x73f, 0x7, 0xa9, 0x2, 0x2, 0x73d, 0x73f, 
       0x5, 0x72, 0x3a, 0x2, 0x73e, 0x73c, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x73d, 
       0x3, 0x2, 0x2, 0x2, 0x73f, 0x71, 0x3, 0x2, 0x2, 0x2, 0x740, 0x745, 
       0x5, 0x76, 0x3c, 0x2, 0x741, 0x742, 0x7, 0x301, 0x2, 0x2, 0x742, 
       0x744, 0x5, 0x76, 0x3c, 0x2, 0x743, 0x741, 0x3, 0x2, 0x2, 0x2, 0x744, 
       0x747, 0x3, 0x2, 0x2, 0x2, 0x745, 0x743, 0x3, 0x2, 0x2, 0x2, 0x745, 
       0x746, 0x3, 0x2, 0x2, 0x2, 0x746, 0x73, 0x3, 0x2, 0x2, 0x2, 0x747, 
       0x745, 0x3, 0x2, 0x2, 0x2, 0x748, 0x74c, 0x5, 0x78, 0x3d, 0x2, 0x749, 
       0x74b, 0x5, 0x80, 0x41, 0x2, 0x74a, 0x749, 0x3, 0x2, 0x2, 0x2, 0x74b, 
       0x74e, 0x3, 0x2, 0x2, 0x2, 0x74c, 0x74a, 0x3, 0x2, 0x2, 0x2, 0x74c, 
       0x74d, 0x3, 0x2, 0x2, 0x2, 0x74d, 0x75, 0x3, 0x2, 0x2, 0x2, 0x74e, 
       0x74c, 0x3, 0x2, 0x2, 0x2, 0x74f, 0x756, 0x5, 0x78, 0x3d, 0x2, 0x750, 
       0x751, 0x7, 0x2fd, 0x2, 0x2, 0x751, 0x752, 0x7, 0x1ae, 0x2, 0x2, 
       0x752, 0x753, 0x5, 0x74, 0x3b, 0x2, 0x753, 0x754, 0x7, 0x2fe, 0x2, 
       0x2, 0x754, 0x756, 0x3, 0x2, 0x2, 0x2, 0x755, 0x74f, 0x3, 0x2, 0x2, 
       0x2, 0x755, 0x750, 0x3, 0x2, 0x2, 0x2, 0x756, 0x75a, 0x3, 0x2, 0x2, 
       0x2, 0x757, 0x759, 0x5, 0x80, 0x41, 0x2, 0x758, 0x757, 0x3, 0x2, 
       0x2, 0x2, 0x759, 0x75c, 0x3, 0x2, 0x2, 0x2, 0x75a, 0x758, 0x3, 0x2, 
       0x2, 0x2, 0x75a, 0x75b, 0x3, 0x2, 0x2, 0x2, 0x75b, 0x77, 0x3, 0x2, 
       0x2, 0x2, 0x75c, 0x75a, 0x3, 0x2, 0x2, 0x2, 0x75d, 0x75f, 0x5, 0x35a, 
       0x1ae, 0x2, 0x75e, 0x760, 0x5, 0x7a, 0x3e, 0x2, 0x75f, 0x75e, 0x3, 
       0x2, 0x2, 0x2, 0x75f, 0x760, 0x3, 0x2, 0x2, 0x2, 0x760, 0x765, 0x3, 
       0x2, 0x2, 0x2, 0x761, 0x763, 0x7, 0x2c, 0x2, 0x2, 0x762, 0x761, 0x3, 
       0x2, 0x2, 0x2, 0x762, 0x763, 0x3, 0x2, 0x2, 0x2, 0x763, 0x764, 0x3, 
       0x2, 0x2, 0x2, 0x764, 0x766, 0x5, 0x370, 0x1b9, 0x2, 0x765, 0x762, 
       0x3, 0x2, 0x2, 0x2, 0x765, 0x766, 0x3, 0x2, 0x2, 0x2, 0x766, 0x768, 
       0x3, 0x2, 0x2, 0x2, 0x767, 0x769, 0x5, 0x7c, 0x3f, 0x2, 0x768, 0x767, 
       0x3, 0x2, 0x2, 0x2, 0x768, 0x769, 0x3, 0x2, 0x2, 0x2, 0x769, 0x77a, 
       0x3, 0x2, 0x2, 0x2, 0x76a, 0x76c, 0x5, 0x9a, 0x4e, 0x2, 0x76b, 0x76d, 
       0x7, 0x2c, 0x2, 0x2, 0x76c, 0x76b, 0x3, 0x2, 0x2, 0x2, 0x76c, 0x76d, 
       0x3, 0x2, 0x2, 0x2, 0x76d, 0x76e, 0x3, 0x2, 0x2, 0x2, 0x76e, 0x773, 
       0x5, 0x370, 0x1b9, 0x2, 0x76f, 0x770, 0x7, 0x2fb, 0x2, 0x2, 0x770, 
       0x771, 0x5, 0x378, 0x1bd, 0x2, 0x771, 0x772, 0x7, 0x2fc, 0x2, 0x2, 
       0x772, 0x774, 0x3, 0x2, 0x2, 0x2, 0x773, 0x76f, 0x3, 0x2, 0x2, 0x2, 
       0x773, 0x774, 0x3, 0x2, 0x2, 0x2, 0x774, 0x77a, 0x3, 0x2, 0x2, 0x2, 
       0x775, 0x776, 0x7, 0x2fb, 0x2, 0x2, 0x776, 0x777, 0x5, 0x72, 0x3a, 
       0x2, 0x777, 0x778, 0x7, 0x2fc, 0x2, 0x2, 0x778, 0x77a, 0x3, 0x2, 
       0x2, 0x2, 0x779, 0x75d, 0x3, 0x2, 0x2, 0x2, 0x779, 0x76a, 0x3, 0x2, 
       0x2, 0x2, 0x779, 0x775, 0x3, 0x2, 0x2, 0x2, 0x77a, 0x79, 0x3, 0x2, 
       0x2, 0x2, 0x77b, 0x77c, 0x7, 0x1c8, 0x2, 0x2, 0x77c, 0x77d, 0x7, 
       0x2fb, 0x2, 0x2, 0x77d, 0x782, 0x5, 0x33e, 0x1a0, 0x2, 0x77e, 0x77f, 
       0x7, 0x301, 0x2, 0x2, 0x77f, 0x781, 0x5, 0x33e, 0x1a0, 0x2, 0x780, 
       0x77e, 0x3, 0x2, 0x2, 0x2, 0x781, 0x784, 0x3, 0x2, 0x2, 0x2, 0x782, 
       0x780, 0x3, 0x2, 0x2, 0x2, 0x782, 0x783, 0x3, 0x2, 0x2, 0x2, 0x783, 
       0x785, 0x3, 0x2, 0x2, 0x2, 0x784, 0x782, 0x3, 0x2, 0x2, 0x2, 0x785, 
       0x786, 0x7, 0x2fc, 0x2, 0x2, 0x786, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x787, 
       0x78c, 0x5, 0x7e, 0x40, 0x2, 0x788, 0x789, 0x7, 0x301, 0x2, 0x2, 
       0x789, 0x78b, 0x5, 0x7e, 0x40, 0x2, 0x78a, 0x788, 0x3, 0x2, 0x2, 
       0x2, 0x78b, 0x78e, 0x3, 0x2, 0x2, 0x2, 0x78c, 0x78a, 0x3, 0x2, 0x2, 
       0x2, 0x78c, 0x78d, 0x3, 0x2, 0x2, 0x2, 0x78d, 0x7d, 0x3, 0x2, 0x2, 
       0x2, 0x78e, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x78f, 0x790, 0x9, 0xd, 0x2, 
       0x2, 0x790, 0x799, 0x9, 0xe, 0x2, 0x2, 0x791, 0x797, 0x7, 0xe0, 0x2, 
       0x2, 0x792, 0x798, 0x7, 0x12b, 0x2, 0x2, 0x793, 0x794, 0x7, 0x1bb, 
       0x2, 0x2, 0x794, 0x798, 0x7, 0x45, 0x2, 0x2, 0x795, 0x796, 0x7, 0xf4, 
       0x2, 0x2, 0x796, 0x798, 0x7, 0x45, 0x2, 0x2, 0x797, 0x792, 0x3, 0x2, 
       0x2, 0x2, 0x797, 0x793, 0x3, 0x2, 0x2, 0x2, 0x797, 0x795, 0x3, 0x2, 
       0x2, 0x2, 0x798, 0x79a, 0x3, 0x2, 0x2, 0x2, 0x799, 0x791, 0x3, 0x2, 
       0x2, 0x2, 0x799, 0x79a, 0x3, 0x2, 0x2, 0x2, 0x79a, 0x79b, 0x3, 0x2, 
       0x2, 0x2, 0x79b, 0x79c, 0x7, 0x2fb, 0x2, 0x2, 0x79c, 0x7a1, 0x5, 
       0x35e, 0x1b0, 0x2, 0x79d, 0x79e, 0x7, 0x301, 0x2, 0x2, 0x79e, 0x7a0, 
       0x5, 0x35e, 0x1b0, 0x2, 0x79f, 0x79d, 0x3, 0x2, 0x2, 0x2, 0x7a0, 
       0x7a3, 0x3, 0x2, 0x2, 0x2, 0x7a1, 0x79f, 0x3, 0x2, 0x2, 0x2, 0x7a1, 
       0x7a2, 0x3, 0x2, 0x2, 0x2, 0x7a2, 0x7a4, 0x3, 0x2, 0x2, 0x2, 0x7a3, 
       0x7a1, 0x3, 0x2, 0x2, 0x2, 0x7a4, 0x7a5, 0x7, 0x2fc, 0x2, 0x2, 0x7a5, 
       0x7f, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x7a7, 0x5, 0x82, 0x42, 0x2, 0x7a7, 
       0x7a9, 0x5, 0x76, 0x3c, 0x2, 0x7a8, 0x7aa, 0x5, 0x88, 0x45, 0x2, 
       0x7a9, 0x7a8, 0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7aa, 0x3, 0x2, 0x2, 0x2, 
       0x7aa, 0x7b3, 0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ac, 0x5, 0x84, 0x43, 
       0x2, 0x7ac, 0x7ad, 0x5, 0x76, 0x3c, 0x2, 0x7ad, 0x7ae, 0x5, 0x88, 
       0x45, 0x2, 0x7ae, 0x7b3, 0x3, 0x2, 0x2, 0x2, 0x7af, 0x7b0, 0x5, 0x86, 
       0x44, 0x2, 0x7b0, 0x7b1, 0x5, 0x78, 0x3d, 0x2, 0x7b1, 0x7b3, 0x3, 
       0x2, 0x2, 0x2, 0x7b2, 0x7a6, 0x3, 0x2, 0x2, 0x2, 0x7b2, 0x7ab, 0x3, 
       0x2, 0x2, 0x2, 0x7b2, 0x7af, 0x3, 0x2, 0x2, 0x2, 0x7b3, 0x81, 0x3, 
       0x2, 0x2, 0x2, 0x7b4, 0x7b6, 0x9, 0xf, 0x2, 0x2, 0x7b5, 0x7b4, 0x3, 
       0x2, 0x2, 0x2, 0x7b5, 0x7b6, 0x3, 0x2, 0x2, 0x2, 0x7b6, 0x7b7, 0x3, 
       0x2, 0x2, 0x2, 0x7b7, 0x7ba, 0x7, 0x12b, 0x2, 0x2, 0x7b8, 0x7ba, 
       0x7, 0x27a, 0x2, 0x2, 0x7b9, 0x7b5, 0x3, 0x2, 0x2, 0x2, 0x7b9, 0x7b8, 
       0x3, 0x2, 0x2, 0x2, 0x7ba, 0x83, 0x3, 0x2, 0x2, 0x2, 0x7bb, 0x7bd, 
       0x9, 0x10, 0x2, 0x2, 0x7bc, 0x7be, 0x7, 0x1c0, 0x2, 0x2, 0x7bd, 0x7bc, 
       0x3, 0x2, 0x2, 0x2, 0x7bd, 0x7be, 0x3, 0x2, 0x2, 0x2, 0x7be, 0x7bf, 
       0x3, 0x2, 0x2, 0x2, 0x7bf, 0x7c0, 0x7, 0x12b, 0x2, 0x2, 0x7c0, 0x85, 
       0x3, 0x2, 0x2, 0x2, 0x7c1, 0x7c3, 0x7, 0x194, 0x2, 0x2, 0x7c2, 0x7c4, 
       0x7, 0x110, 0x2, 0x2, 0x7c3, 0x7c2, 0x3, 0x2, 0x2, 0x2, 0x7c3, 0x7c4, 
       0x3, 0x2, 0x2, 0x2, 0x7c4, 0x7c5, 0x3, 0x2, 0x2, 0x2, 0x7c5, 0x7cd, 
       0x7, 0x12b, 0x2, 0x2, 0x7c6, 0x7c7, 0x7, 0x194, 0x2, 0x2, 0x7c7, 
       0x7c9, 0x9, 0x10, 0x2, 0x2, 0x7c8, 0x7ca, 0x7, 0x1c0, 0x2, 0x2, 0x7c9, 
       0x7c8, 0x3, 0x2, 0x2, 0x2, 0x7c9, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7ca, 
       0x7cb, 0x3, 0x2, 0x2, 0x2, 0x7cb, 0x7cd, 0x7, 0x12b, 0x2, 0x2, 0x7cc, 
       0x7c1, 0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7c6, 0x3, 0x2, 0x2, 0x2, 0x7cd, 
       0x87, 0x3, 0x2, 0x2, 0x2, 0x7ce, 0x7cf, 0x7, 0x1b0, 0x2, 0x2, 0x7cf, 
       0x7d6, 0x5, 0x3a6, 0x1d4, 0x2, 0x7d0, 0x7d1, 0x7, 0x2b9, 0x2, 0x2, 
       0x7d1, 0x7d2, 0x7, 0x2fb, 0x2, 0x2, 0x7d2, 0x7d3, 0x5, 0x378, 0x1bd, 
       0x2, 0x7d3, 0x7d4, 0x7, 0x2fc, 0x2, 0x2, 0x7d4, 0x7d6, 0x3, 0x2, 
       0x2, 0x2, 0x7d5, 0x7ce, 0x3, 0x2, 0x2, 0x2, 0x7d5, 0x7d0, 0x3, 0x2, 
       0x2, 0x2, 0x7d6, 0x89, 0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7d8, 0x7, 0x2ce, 
       0x2, 0x2, 0x7d8, 0x7d9, 0x5, 0x3a6, 0x1d4, 0x2, 0x7d9, 0x8b, 0x3, 
       0x2, 0x2, 0x2, 0x7da, 0x7db, 0x7, 0xf4, 0x2, 0x2, 0x7db, 0x7dc, 0x7, 
       0x45, 0x2, 0x2, 0x7dc, 0x7e1, 0x5, 0x418, 0x20d, 0x2, 0x7dd, 0x7de, 
       0x7, 0x301, 0x2, 0x2, 0x7de, 0x7e0, 0x5, 0x418, 0x20d, 0x2, 0x7df, 
       0x7dd, 0x3, 0x2, 0x2, 0x2, 0x7e0, 0x7e3, 0x3, 0x2, 0x2, 0x2, 0x7e1, 
       0x7df, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7e2, 
       0x7e6, 0x3, 0x2, 0x2, 0x2, 0x7e3, 0x7e1, 0x3, 0x2, 0x2, 0x2, 0x7e4, 
       0x7e5, 0x7, 0x2d1, 0x2, 0x2, 0x7e5, 0x7e7, 0x7, 0x227, 0x2, 0x2, 
       0x7e6, 0x7e4, 0x3, 0x2, 0x2, 0x2, 0x7e6, 0x7e7, 0x3, 0x2, 0x2, 0x2, 
       0x7e7, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x7e8, 0x7e9, 0x7, 0xfa, 0x2, 0x2, 
       0x7e9, 0x7ea, 0x5, 0x3a6, 0x1d4, 0x2, 0x7ea, 0x8f, 0x3, 0x2, 0x2, 
       0x2, 0x7eb, 0x7f6, 0x7, 0x140, 0x2, 0x2, 0x7ec, 0x7ed, 0x5, 0x94, 
       0x4b, 0x2, 0x7ed, 0x7ee, 0x7, 0x301, 0x2, 0x2, 0x7ee, 0x7f0, 0x3, 
       0x2, 0x2, 0x2, 0x7ef, 0x7ec, 0x3, 0x2, 0x2, 0x2, 0x7ef, 0x7f0, 0x3, 
       0x2, 0x2, 0x2, 0x7f0, 0x7f1, 0x3, 0x2, 0x2, 0x2, 0x7f1, 0x7f7, 0x5, 
       0x92, 0x4a, 0x2, 0x7f2, 0x7f3, 0x5, 0x92, 0x4a, 0x2, 0x7f3, 0x7f4, 
       0x7, 0x1ad, 0x2, 0x2, 0x7f4, 0x7f5, 0x5, 0x94, 0x4b, 0x2, 0x7f5, 
       0x7f7, 0x3, 0x2, 0x2, 0x2, 0x7f6, 0x7ef, 0x3, 0x2, 0x2, 0x2, 0x7f6, 
       0x7f2, 0x3, 0x2, 0x2, 0x2, 0x7f7, 0x91, 0x3, 0x2, 0x2, 0x2, 0x7f8, 
       0x7fb, 0x5, 0x330, 0x199, 0x2, 0x7f9, 0x7fb, 0x5, 0x326, 0x194, 0x2, 
       0x7fa, 0x7f8, 0x3, 0x2, 0x2, 0x2, 0x7fa, 0x7f9, 0x3, 0x2, 0x2, 0x2, 
       0x7fb, 0x93, 0x3, 0x2, 0x2, 0x2, 0x7fc, 0x7ff, 0x5, 0x330, 0x199, 
       0x2, 0x7fd, 0x7ff, 0x5, 0x326, 0x194, 0x2, 0x7fe, 0x7fc, 0x3, 0x2, 
       0x2, 0x2, 0x7fe, 0x7fd, 0x3, 0x2, 0x2, 0x2, 0x7ff, 0x95, 0x3, 0x2, 
       0x2, 0x2, 0x800, 0x801, 0x7, 0x2d0, 0x2, 0x2, 0x801, 0x806, 0x5, 
       0x98, 0x4d, 0x2, 0x802, 0x803, 0x7, 0x301, 0x2, 0x2, 0x803, 0x805, 
       0x5, 0x98, 0x4d, 0x2, 0x804, 0x802, 0x3, 0x2, 0x2, 0x2, 0x805, 0x808, 
       0x3, 0x2, 0x2, 0x2, 0x806, 0x804, 0x3, 0x2, 0x2, 0x2, 0x806, 0x807, 
       0x3, 0x2, 0x2, 0x2, 0x807, 0x97, 0x3, 0x2, 0x2, 0x2, 0x808, 0x806, 
       0x3, 0x2, 0x2, 0x2, 0x809, 0x80a, 0x5, 0x33e, 0x1a0, 0x2, 0x80a, 
       0x80b, 0x7, 0x2c, 0x2, 0x2, 0x80b, 0x80c, 0x7, 0x2fb, 0x2, 0x2, 0x80c, 
       0x80d, 0x5, 0x3c4, 0x1e3, 0x2, 0x80d, 0x80e, 0x7, 0x2fc, 0x2, 0x2, 
       0x80e, 0x99, 0x3, 0x2, 0x2, 0x2, 0x80f, 0x810, 0x5, 0x3e, 0x20, 0x2, 
       0x810, 0x9b, 0x3, 0x2, 0x2, 0x2, 0x811, 0x812, 0x7, 0x271, 0x2, 0x2, 
       0x812, 0x813, 0x7, 0x45, 0x2, 0x2, 0x813, 0x818, 0x5, 0x32c, 0x197, 
       0x2, 0x814, 0x815, 0x7, 0x28d, 0x2, 0x2, 0x815, 0x816, 0x7, 0x45, 
       0x2, 0x2, 0x816, 0x818, 0x5, 0x32c, 0x197, 0x2, 0x817, 0x811, 0x3, 
       0x2, 0x2, 0x2, 0x817, 0x814, 0x3, 0x2, 0x2, 0x2, 0x818, 0x9d, 0x3, 
       0x2, 0x2, 0x2, 0x819, 0x81a, 0x7, 0x28d, 0x2, 0x2, 0x81a, 0x81b, 
       0x7, 0x45, 0x2, 0x2, 0x81b, 0x826, 0x5, 0x32c, 0x197, 0x2, 0x81c, 
       0x81e, 0x7, 0x1b8, 0x2, 0x2, 0x81d, 0x81c, 0x3, 0x2, 0x2, 0x2, 0x81d, 
       0x81e, 0x3, 0x2, 0x2, 0x2, 0x81e, 0x81f, 0x3, 0x2, 0x2, 0x2, 0x81f, 
       0x820, 0x7, 0xb2, 0x2, 0x2, 0x820, 0x821, 0x7, 0x45, 0x2, 0x2, 0x821, 
       0x826, 0x5, 0x32c, 0x197, 0x2, 0x822, 0x823, 0x7, 0xbe, 0x2, 0x2, 
       0x823, 0x824, 0x7, 0x45, 0x2, 0x2, 0x824, 0x826, 0x5, 0x32c, 0x197, 
       0x2, 0x825, 0x819, 0x3, 0x2, 0x2, 0x2, 0x825, 0x81d, 0x3, 0x2, 0x2, 
       0x2, 0x825, 0x822, 0x3, 0x2, 0x2, 0x2, 0x826, 0x9f, 0x3, 0x2, 0x2, 
       0x2, 0x827, 0x828, 0x7, 0x11f, 0x2, 0x2, 0x828, 0x82d, 0x5, 0x344, 
       0x1a3, 0x2, 0x829, 0x82a, 0x7, 0x301, 0x2, 0x2, 0x82a, 0x82c, 0x5, 
       0x344, 0x1a3, 0x2, 0x82b, 0x829, 0x3, 0x2, 0x2, 0x2, 0x82c, 0x82f, 
       0x3, 0x2, 0x2, 0x2, 0x82d, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x82d, 0x82e, 
       0x3, 0x2, 0x2, 0x2, 0x82e, 0x84c, 0x3, 0x2, 0x2, 0x2, 0x82f, 0x82d, 
       0x3, 0x2, 0x2, 0x2, 0x830, 0x831, 0x7, 0x11f, 0x2, 0x2, 0x831, 0x832, 
       0x7, 0xaa, 0x2, 0x2, 0x832, 0x84c, 0x5, 0x32c, 0x197, 0x2, 0x833, 
       0x834, 0x7, 0x11f, 0x2, 0x2, 0x834, 0x835, 0x7, 0x1c1, 0x2, 0x2, 
       0x835, 0x839, 0x5, 0x32c, 0x197, 0x2, 0x836, 0x837, 0x7, 0x52, 0x2, 
       0x2, 0x837, 0x838, 0x7, 0x244, 0x2, 0x2, 0x838, 0x83a, 0x5, 0x354, 
       0x1ab, 0x2, 0x839, 0x836, 0x3, 0x2, 0x2, 0x2, 0x839, 0x83a, 0x3, 
       0x2, 0x2, 0x2, 0x83a, 0x841, 0x3, 0x2, 0x2, 0x2, 0x83b, 0x83d, 0x9, 
       0x9, 0x2, 0x2, 0x83c, 0x83e, 0x5, 0x9e, 0x50, 0x2, 0x83d, 0x83c, 
       0x3, 0x2, 0x2, 0x2, 0x83e, 0x83f, 0x3, 0x2, 0x2, 0x2, 0x83f, 0x83d, 
       0x3, 0x2, 0x2, 0x2, 0x83f, 0x840, 0x3, 0x2, 0x2, 0x2, 0x840, 0x842, 
       0x3, 0x2, 0x2, 0x2, 0x841, 0x83b, 0x3, 0x2, 0x2, 0x2, 0x841, 0x842, 
       0x3, 0x2, 0x2, 0x2, 0x842, 0x849, 0x3, 0x2, 0x2, 0x2, 0x843, 0x845, 
       0x7, 0x142, 0x2, 0x2, 0x844, 0x846, 0x5, 0x9c, 0x4f, 0x2, 0x845, 
       0x844, 0x3, 0x2, 0x2, 0x2, 0x846, 0x847, 0x3, 0x2, 0x2, 0x2, 0x847, 
       0x845, 0x3, 0x2, 0x2, 0x2, 0x847, 0x848, 0x3, 0x2, 0x2, 0x2, 0x848, 
       0x84a, 0x3, 0x2, 0x2, 0x2, 0x849, 0x843, 0x3, 0x2, 0x2, 0x2, 0x849, 
       0x84a, 0x3, 0x2, 0x2, 0x2, 0x84a, 0x84c, 0x3, 0x2, 0x2, 0x2, 0x84b, 
       0x827, 0x3, 0x2, 0x2, 0x2, 0x84b, 0x830, 0x3, 0x2, 0x2, 0x2, 0x84b, 
       0x833, 0x3, 0x2, 0x2, 0x2, 0x84c, 0xa1, 0x3, 0x2, 0x2, 0x2, 0x84d, 
       0x84e, 0x7, 0xe0, 0x2, 0x2, 0x84e, 0x850, 0x5, 0xa6, 0x54, 0x2, 0x84f, 
       0x851, 0x5, 0xaa, 0x56, 0x2, 0x850, 0x84f, 0x3, 0x2, 0x2, 0x2, 0x850, 
       0x851, 0x3, 0x2, 0x2, 0x2, 0x851, 0x853, 0x3, 0x2, 0x2, 0x2, 0x852, 
       0x854, 0x5, 0xa8, 0x55, 0x2, 0x853, 0x852, 0x3, 0x2, 0x2, 0x2, 0x853, 
       0x854, 0x3, 0x2, 0x2, 0x2, 0x854, 0x85a, 0x3, 0x2, 0x2, 0x2, 0x855, 
       0x856, 0x7, 0x149, 0x2, 0x2, 0x856, 0x857, 0x7, 0x10a, 0x2, 0x2, 
       0x857, 0x858, 0x7, 0x245, 0x2, 0x2, 0x858, 0x85a, 0x7, 0x188, 0x2, 
       0x2, 0x859, 0x84d, 0x3, 0x2, 0x2, 0x2, 0x859, 0x855, 0x3, 0x2, 0x2, 
       0x2, 0x85a, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x85b, 0x85d, 0x5, 0xa2, 0x52, 
       0x2, 0x85c, 0x85b, 0x3, 0x2, 0x2, 0x2, 0x85d, 0x85e, 0x3, 0x2, 0x2, 
       0x2, 0x85e, 0x85c, 0x3, 0x2, 0x2, 0x2, 0x85e, 0x85f, 0x3, 0x2, 0x2, 
       0x2, 0x85f, 0xa5, 0x3, 0x2, 0x2, 0x2, 0x860, 0x861, 0x9, 0x11, 0x2, 
       0x2, 0x861, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x862, 0x863, 0x7, 0x24b, 0x2, 
       0x2, 0x863, 0x866, 0x7, 0x14a, 0x2, 0x2, 0x864, 0x866, 0x7, 0x1a1, 
       0x2, 0x2, 0x865, 0x862, 0x3, 0x2, 0x2, 0x2, 0x865, 0x864, 0x3, 0x2, 
       0x2, 0x2, 0x866, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x867, 0x868, 0x7, 0x1ab, 
       0x2, 0x2, 0x868, 0x869, 0x5, 0xae, 0x58, 0x2, 0x869, 0xab, 0x3, 0x2, 
       0x2, 0x2, 0x86a, 0x86c, 0x5, 0x35a, 0x1ae, 0x2, 0x86b, 0x86d, 0x7, 
       0x2f1, 0x2, 0x2, 0x86c, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x86c, 0x86d, 
       0x3, 0x2, 0x2, 0x2, 0x86d, 0xad, 0x3, 0x2, 0x2, 0x2, 0x86e, 0x873, 
       0x5, 0xac, 0x57, 0x2, 0x86f, 0x870, 0x7, 0x301, 0x2, 0x2, 0x870, 
       0x872, 0x5, 0xac, 0x57, 0x2, 0x871, 0x86f, 0x3, 0x2, 0x2, 0x2, 0x872, 
       0x875, 0x3, 0x2, 0x2, 0x2, 0x873, 0x871, 0x3, 0x2, 0x2, 0x2, 0x873, 
       0x874, 0x3, 0x2, 0x2, 0x2, 0x874, 0xaf, 0x3, 0x2, 0x2, 0x2, 0x875, 
       0x873, 0x3, 0x2, 0x2, 0x2, 0x876, 0x882, 0x5, 0xbe, 0x60, 0x2, 0x877, 
       0x882, 0x5, 0xf4, 0x7b, 0x2, 0x878, 0x882, 0x5, 0x110, 0x89, 0x2, 
       0x879, 0x882, 0x5, 0x10a, 0x86, 0x2, 0x87a, 0x882, 0x5, 0x104, 0x83, 
       0x2, 0x87b, 0x882, 0x5, 0x11c, 0x8f, 0x2, 0x87c, 0x882, 0x5, 0x126, 
       0x94, 0x2, 0x87d, 0x882, 0x5, 0x124, 0x93, 0x2, 0x87e, 0x882, 0x5, 
       0x12c, 0x97, 0x2, 0x87f, 0x882, 0x5, 0xfc, 0x7f, 0x2, 0x880, 0x882, 
       0x5, 0x116, 0x8c, 0x2, 0x881, 0x876, 0x3, 0x2, 0x2, 0x2, 0x881, 0x877, 
       0x3, 0x2, 0x2, 0x2, 0x881, 0x878, 0x3, 0x2, 0x2, 0x2, 0x881, 0x879, 
       0x3, 0x2, 0x2, 0x2, 0x881, 0x87a, 0x3, 0x2, 0x2, 0x2, 0x881, 0x87b, 
       0x3, 0x2, 0x2, 0x2, 0x881, 0x87c, 0x3, 0x2, 0x2, 0x2, 0x881, 0x87d, 
       0x3, 0x2, 0x2, 0x2, 0x881, 0x87e, 0x3, 0x2, 0x2, 0x2, 0x881, 0x87f, 
       0x3, 0x2, 0x2, 0x2, 0x881, 0x880, 0x3, 0x2, 0x2, 0x2, 0x882, 0xb1, 
       0x3, 0x2, 0x2, 0x2, 0x883, 0x885, 0x7, 0x78, 0x2, 0x2, 0x884, 0x886, 
       0x7, 0x28b, 0x2, 0x2, 0x885, 0x884, 0x3, 0x2, 0x2, 0x2, 0x885, 0x886, 
       0x3, 0x2, 0x2, 0x2, 0x886, 0x887, 0x3, 0x2, 0x2, 0x2, 0x887, 0x889, 
       0x7, 0x286, 0x2, 0x2, 0x888, 0x88a, 0x5, 0x44a, 0x226, 0x2, 0x889, 
       0x888, 0x3, 0x2, 0x2, 0x2, 0x889, 0x88a, 0x3, 0x2, 0x2, 0x2, 0x88a, 
       0x88b, 0x3, 0x2, 0x2, 0x2, 0x88b, 0x899, 0x5, 0x35a, 0x1ae, 0x2, 
       0x88c, 0x88e, 0x5, 0x136, 0x9c, 0x2, 0x88d, 0x88c, 0x3, 0x2, 0x2, 
       0x2, 0x88d, 0x88e, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x890, 0x3, 0x2, 0x2, 
       0x2, 0x88f, 0x891, 0x5, 0x162, 0xb2, 0x2, 0x890, 0x88f, 0x3, 0x2, 
       0x2, 0x2, 0x890, 0x891, 0x3, 0x2, 0x2, 0x2, 0x891, 0x893, 0x3, 0x2, 
       0x2, 0x2, 0x892, 0x894, 0x5, 0xb4, 0x5b, 0x2, 0x893, 0x892, 0x3, 
       0x2, 0x2, 0x2, 0x893, 0x894, 0x3, 0x2, 0x2, 0x2, 0x894, 0x896, 0x3, 
       0x2, 0x2, 0x2, 0x895, 0x897, 0x5, 0xbc, 0x5f, 0x2, 0x896, 0x895, 
       0x3, 0x2, 0x2, 0x2, 0x896, 0x897, 0x3, 0x2, 0x2, 0x2, 0x897, 0x89a, 
       0x3, 0x2, 0x2, 0x2, 0x898, 0x89a, 0x5, 0x15e, 0xb0, 0x2, 0x899, 0x88d, 
       0x3, 0x2, 0x2, 0x2, 0x899, 0x898, 0x3, 0x2, 0x2, 0x2, 0x89a, 0xb3, 
       0x3, 0x2, 0x2, 0x2, 0x89b, 0x89c, 0x7, 0x1c8, 0x2, 0x2, 0x89c, 0x89d, 
       0x7, 0x45, 0x2, 0x2, 0x89d, 0x8a0, 0x5, 0xb6, 0x5c, 0x2, 0x89e, 0x89f, 
       0x7, 0x1ca, 0x2, 0x2, 0x89f, 0x8a1, 0x7, 0x313, 0x2, 0x2, 0x8a0, 
       0x89e, 0x3, 0x2, 0x2, 0x2, 0x8a0, 0x8a1, 0x3, 0x2, 0x2, 0x2, 0x8a1, 
       0x8a3, 0x3, 0x2, 0x2, 0x2, 0x8a2, 0x8a4, 0x5, 0xb8, 0x5d, 0x2, 0x8a3, 
       0x8a2, 0x3, 0x2, 0x2, 0x2, 0x8a3, 0x8a4, 0x3, 0x2, 0x2, 0x2, 0x8a4, 
       0x8a6, 0x3, 0x2, 0x2, 0x2, 0x8a5, 0x8a7, 0x5, 0x16e, 0xb8, 0x2, 0x8a6, 
       0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a6, 0x8a7, 0x3, 0x2, 0x2, 0x2, 0x8a7, 
       0xb5, 0x3, 0x2, 0x2, 0x2, 0x8a8, 0x8aa, 0x7, 0x141, 0x2, 0x2, 0x8a9, 
       0x8a8, 0x3, 0x2, 0x2, 0x2, 0x8a9, 0x8aa, 0x3, 0x2, 0x2, 0x2, 0x8aa, 
       0x8ab, 0x3, 0x2, 0x2, 0x2, 0x8ab, 0x8ad, 0x7, 0x12f, 0x2, 0x2, 0x8ac, 
       0x8ae, 0x5, 0xba, 0x5e, 0x2, 0x8ad, 0x8ac, 0x3, 0x2, 0x2, 0x2, 0x8ad, 
       0x8ae, 0x3, 0x2, 0x2, 0x2, 0x8ae, 0x8af, 0x3, 0x2, 0x2, 0x2, 0x8af, 
       0x8b1, 0x7, 0x2fb, 0x2, 0x2, 0x8b0, 0x8b2, 0x5, 0x378, 0x1bd, 0x2, 
       0x8b1, 0x8b0, 0x3, 0x2, 0x2, 0x2, 0x8b1, 0x8b2, 0x3, 0x2, 0x2, 0x2, 
       0x8b2, 0x8b3, 0x3, 0x2, 0x2, 0x2, 0x8b3, 0x8c9, 0x7, 0x2fc, 0x2, 
       0x2, 0x8b4, 0x8b6, 0x7, 0x141, 0x2, 0x2, 0x8b5, 0x8b4, 0x3, 0x2, 
       0x2, 0x2, 0x8b5, 0x8b6, 0x3, 0x2, 0x2, 0x2, 0x8b6, 0x8b7, 0x3, 0x2, 
       0x2, 0x2, 0x8b7, 0x8b8, 0x7, 0xf9, 0x2, 0x2, 0x8b8, 0x8b9, 0x7, 0x2fb, 
       0x2, 0x2, 0x8b9, 0x8ba, 0x5, 0x3b2, 0x1da, 0x2, 0x8ba, 0x8bb, 0x7, 
       0x2fc, 0x2, 0x2, 0x8bb, 0x8c9, 0x3, 0x2, 0x2, 0x2, 0x8bc, 0x8c6, 
       0x9, 0x12, 0x2, 0x2, 0x8bd, 0x8be, 0x7, 0x2fb, 0x2, 0x2, 0x8be, 0x8bf, 
       0x5, 0x3b2, 0x1da, 0x2, 0x8bf, 0x8c0, 0x7, 0x2fc, 0x2, 0x2, 0x8c0, 
       0x8c7, 0x3, 0x2, 0x2, 0x2, 0x8c1, 0x8c2, 0x7, 0x60, 0x2, 0x2, 0x8c2, 
       0x8c3, 0x7, 0x2fb, 0x2, 0x2, 0x8c3, 0x8c4, 0x5, 0x378, 0x1bd, 0x2, 
       0x8c4, 0x8c5, 0x7, 0x2fc, 0x2, 0x2, 0x8c5, 0x8c7, 0x3, 0x2, 0x2, 
       0x2, 0x8c6, 0x8bd, 0x3, 0x2, 0x2, 0x2, 0x8c6, 0x8c1, 0x3, 0x2, 0x2, 
       0x2, 0x8c7, 0x8c9, 0x3, 0x2, 0x2, 0x2, 0x8c8, 0x8a9, 0x3, 0x2, 0x2, 
       0x2, 0x8c8, 0x8b5, 0x3, 0x2, 0x2, 0x2, 0x8c8, 0x8bc, 0x3, 0x2, 0x2, 
       0x2, 0x8c9, 0xb7, 0x3, 0x2, 0x2, 0x2, 0x8ca, 0x8cb, 0x7, 0x27f, 0x2, 
       0x2, 0x8cb, 0x8cd, 0x7, 0x45, 0x2, 0x2, 0x8cc, 0x8ce, 0x7, 0x141, 
       0x2, 0x2, 0x8cd, 0x8cc, 0x3, 0x2, 0x2, 0x2, 0x8cd, 0x8ce, 0x3, 0x2, 
       0x2, 0x2, 0x8ce, 0x8dc, 0x3, 0x2, 0x2, 0x2, 0x8cf, 0x8d0, 0x7, 0xf9, 
       0x2, 0x2, 0x8d0, 0x8d1, 0x7, 0x2fb, 0x2, 0x2, 0x8d1, 0x8d2, 0x5, 
       0x3b2, 0x1da, 0x2, 0x8d2, 0x8d3, 0x7, 0x2fc, 0x2, 0x2, 0x8d3, 0x8dd, 
       0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8d6, 0x7, 0x12f, 0x2, 0x2, 0x8d5, 0x8d7, 
       0x5, 0xba, 0x5e, 0x2, 0x8d6, 0x8d5, 0x3, 0x2, 0x2, 0x2, 0x8d6, 0x8d7, 
       0x3, 0x2, 0x2, 0x2, 0x8d7, 0x8d8, 0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d9, 
       0x7, 0x2fb, 0x2, 0x2, 0x8d9, 0x8da, 0x5, 0x378, 0x1bd, 0x2, 0x8da, 
       0x8db, 0x7, 0x2fc, 0x2, 0x2, 0x8db, 0x8dd, 0x3, 0x2, 0x2, 0x2, 0x8dc, 
       0x8cf, 0x3, 0x2, 0x2, 0x2, 0x8dc, 0x8d4, 0x3, 0x2, 0x2, 0x2, 0x8dd, 
       0x8e0, 0x3, 0x2, 0x2, 0x2, 0x8de, 0x8df, 0x7, 0x280, 0x2, 0x2, 0x8df, 
       0x8e1, 0x7, 0x313, 0x2, 0x2, 0x8e0, 0x8de, 0x3, 0x2, 0x2, 0x2, 0x8e0, 
       0x8e1, 0x3, 0x2, 0x2, 0x2, 0x8e1, 0xb9, 0x3, 0x2, 0x2, 0x2, 0x8e2, 
       0x8e3, 0x7, 0x24, 0x2, 0x2, 0x8e3, 0x8e4, 0x7, 0x2f4, 0x2, 0x2, 0x8e4, 
       0x8e5, 0x7, 0x313, 0x2, 0x2, 0x8e5, 0xbb, 0x3, 0x2, 0x2, 0x2, 0x8e6, 
       0x8e8, 0x9, 0x8, 0x2, 0x2, 0x8e7, 0x8e6, 0x3, 0x2, 0x2, 0x2, 0x8e7, 
       0x8e8, 0x3, 0x2, 0x2, 0x2, 0x8e8, 0x8ea, 0x3, 0x2, 0x2, 0x2, 0x8e9, 
       0x8eb, 0x7, 0x2c, 0x2, 0x2, 0x8ea, 0x8e9, 0x3, 0x2, 0x2, 0x2, 0x8ea, 
       0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8eb, 0x8ed, 0x3, 0x2, 0x2, 0x2, 0x8ec, 
       0x8ee, 0x7, 0x2fb, 0x2, 0x2, 0x8ed, 0x8ec, 0x3, 0x2, 0x2, 0x2, 0x8ed, 
       0x8ee, 0x3, 0x2, 0x2, 0x2, 0x8ee, 0x8ef, 0x3, 0x2, 0x2, 0x2, 0x8ef, 
       0x8f1, 0x5, 0x36, 0x1c, 0x2, 0x8f0, 0x8f2, 0x7, 0x2fc, 0x2, 0x2, 
       0x8f1, 0x8f0, 0x3, 0x2, 0x2, 0x2, 0x8f1, 0x8f2, 0x3, 0x2, 0x2, 0x2, 
       0x8f2, 0xbd, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0x8f4, 0x7, 0x26, 0x2, 0x2, 
       0x8f4, 0x8f5, 0x7, 0x286, 0x2, 0x2, 0x8f5, 0x8f7, 0x5, 0x35a, 0x1ae, 
       0x2, 0x8f6, 0x8f8, 0x5, 0xc2, 0x62, 0x2, 0x8f7, 0x8f6, 0x3, 0x2, 
       0x2, 0x2, 0x8f7, 0x8f8, 0x3, 0x2, 0x2, 0x2, 0x8f8, 0x8ff, 0x3, 0x2, 
       0x2, 0x2, 0x8f9, 0x8fa, 0x7, 0x26, 0x2, 0x2, 0x8fa, 0x8fb, 0x7, 0x286, 
       0x2, 0x2, 0x8fb, 0x8fc, 0x5, 0x35a, 0x1ae, 0x2, 0x8fc, 0x8fd, 0x5, 
       0xc0, 0x61, 0x2, 0x8fd, 0x8ff, 0x3, 0x2, 0x2, 0x2, 0x8fe, 0x8f3, 
       0x3, 0x2, 0x2, 0x2, 0x8fe, 0x8f9, 0x3, 0x2, 0x2, 0x2, 0x8ff, 0xbf, 
       0x3, 0x2, 0x2, 0x2, 0x900, 0x901, 0x5, 0xd2, 0x6a, 0x2, 0x901, 0x902, 
       0x7, 0x301, 0x2, 0x2, 0x902, 0x904, 0x3, 0x2, 0x2, 0x2, 0x903, 0x900, 
       0x3, 0x2, 0x2, 0x2, 0x903, 0x904, 0x3, 0x2, 0x2, 0x2, 0x904, 0x905, 
       0x3, 0x2, 0x2, 0x2, 0x905, 0x906, 0x5, 0xd8, 0x6d, 0x2, 0x906, 0xc1, 
       0x3, 0x2, 0x2, 0x2, 0x907, 0x909, 0x5, 0xc6, 0x64, 0x2, 0x908, 0x90a, 
       0x5, 0xc4, 0x63, 0x2, 0x909, 0x908, 0x3, 0x2, 0x2, 0x2, 0x909, 0x90a, 
       0x3, 0x2, 0x2, 0x2, 0x90a, 0x90d, 0x3, 0x2, 0x2, 0x2, 0x90b, 0x90d, 
       0x5, 0xc4, 0x63, 0x2, 0x90c, 0x907, 0x3, 0x2, 0x2, 0x2, 0x90c, 0x90b, 
       0x3, 0x2, 0x2, 0x2, 0x90d, 0xc3, 0x3, 0x2, 0x2, 0x2, 0x90e, 0x912, 
       0x5, 0xb4, 0x5b, 0x2, 0x90f, 0x910, 0x7, 0x202, 0x2, 0x2, 0x910, 
       0x912, 0x7, 0x1c9, 0x2, 0x2, 0x911, 0x90e, 0x3, 0x2, 0x2, 0x2, 0x911, 
       0x90f, 0x3, 0x2, 0x2, 0x2, 0x912, 0xc5, 0x3, 0x2, 0x2, 0x2, 0x913, 
       0x91b, 0x5, 0xd2, 0x6a, 0x2, 0x914, 0x915, 0x5, 0xd2, 0x6a, 0x2, 
       0x915, 0x916, 0x7, 0x301, 0x2, 0x2, 0x916, 0x918, 0x3, 0x2, 0x2, 
       0x2, 0x917, 0x914, 0x3, 0x2, 0x2, 0x2, 0x917, 0x918, 0x3, 0x2, 0x2, 
       0x2, 0x918, 0x919, 0x3, 0x2, 0x2, 0x2, 0x919, 0x91b, 0x5, 0xc8, 0x65, 
       0x2, 0x91a, 0x913, 0x3, 0x2, 0x2, 0x2, 0x91a, 0x917, 0x3, 0x2, 0x2, 
       0x2, 0x91b, 0xc7, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x91f, 0x5, 0xcc, 0x67, 
       0x2, 0x91d, 0x91f, 0x5, 0xca, 0x66, 0x2, 0x91e, 0x91c, 0x3, 0x2, 
       0x2, 0x2, 0x91e, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x91f, 0x928, 0x3, 0x2, 
       0x2, 0x2, 0x920, 0x924, 0x7, 0x301, 0x2, 0x2, 0x921, 0x925, 0x5, 
       0xcc, 0x67, 0x2, 0x922, 0x925, 0x5, 0xd4, 0x6b, 0x2, 0x923, 0x925, 
       0x5, 0xca, 0x66, 0x2, 0x924, 0x921, 0x3, 0x2, 0x2, 0x2, 0x924, 0x922, 
       0x3, 0x2, 0x2, 0x2, 0x924, 0x923, 0x3, 0x2, 0x2, 0x2, 0x925, 0x927, 
       0x3, 0x2, 0x2, 0x2, 0x926, 0x920, 0x3, 0x2, 0x2, 0x2, 0x927, 0x92a, 
       0x3, 0x2, 0x2, 0x2, 0x928, 0x926, 0x3, 0x2, 0x2, 0x2, 0x928, 0x929, 
       0x3, 0x2, 0x2, 0x2, 0x929, 0xc9, 0x3, 0x2, 0x2, 0x2, 0x92a, 0x928, 
       0x3, 0x2, 0x2, 0x2, 0x92b, 0x92d, 0x5, 0x164, 0xb3, 0x2, 0x92c, 0x92b, 
       0x3, 0x2, 0x2, 0x2, 0x92d, 0x92e, 0x3, 0x2, 0x2, 0x2, 0x92e, 0x92c, 
       0x3, 0x2, 0x2, 0x2, 0x92e, 0x92f, 0x3, 0x2, 0x2, 0x2, 0x92f, 0xcb, 
       0x3, 0x2, 0x2, 0x2, 0x930, 0x932, 0x7, 0x1f, 0x2, 0x2, 0x931, 0x933, 
       0x7, 0x5f, 0x2, 0x2, 0x932, 0x931, 0x3, 0x2, 0x2, 0x2, 0x932, 0x933, 
       0x3, 0x2, 0x2, 0x2, 0x933, 0x93c, 0x3, 0x2, 0x2, 0x2, 0x934, 0x936, 
       0x5, 0x138, 0x9d, 0x2, 0x935, 0x937, 0x5, 0x16c, 0xb7, 0x2, 0x936, 
       0x935, 0x3, 0x2, 0x2, 0x2, 0x936, 0x937, 0x3, 0x2, 0x2, 0x2, 0x937, 
       0x93d, 0x3, 0x2, 0x2, 0x2, 0x938, 0x939, 0x7, 0x2fb, 0x2, 0x2, 0x939, 
       0x93a, 0x5, 0xde, 0x70, 0x2, 0x93a, 0x93b, 0x7, 0x2fc, 0x2, 0x2, 
       0x93b, 0x93d, 0x3, 0x2, 0x2, 0x2, 0x93c, 0x934, 0x3, 0x2, 0x2, 0x2, 
       0x93c, 0x938, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x9aa, 0x3, 0x2, 0x2, 0x2, 
       0x93e, 0x93f, 0x7, 0x1f, 0x2, 0x2, 0x93f, 0x9aa, 0x5, 0xd0, 0x69, 
       0x2, 0x940, 0x942, 0x7, 0x4e, 0x2, 0x2, 0x941, 0x943, 0x7, 0x5f, 
       0x2, 0x2, 0x942, 0x941, 0x3, 0x2, 0x2, 0x2, 0x942, 0x943, 0x3, 0x2, 
       0x2, 0x2, 0x943, 0x944, 0x3, 0x2, 0x2, 0x2, 0x944, 0x945, 0x5, 0x33e, 
       0x1a0, 0x2, 0x945, 0x947, 0x5, 0x138, 0x9d, 0x2, 0x946, 0x948, 0x5, 
       0x16c, 0xb7, 0x2, 0x947, 0x946, 0x3, 0x2, 0x2, 0x2, 0x947, 0x948, 
       0x3, 0x2, 0x2, 0x2, 0x948, 0x9aa, 0x3, 0x2, 0x2, 0x2, 0x949, 0x94b, 
       0x7, 0x18a, 0x2, 0x2, 0x94a, 0x94c, 0x7, 0x5f, 0x2, 0x2, 0x94b, 0x94a, 
       0x3, 0x2, 0x2, 0x2, 0x94b, 0x94c, 0x3, 0x2, 0x2, 0x2, 0x94c, 0x94d, 
       0x3, 0x2, 0x2, 0x2, 0x94d, 0x94e, 0x5, 0x33e, 0x1a0, 0x2, 0x94e, 
       0x950, 0x5, 0x13a, 0x9e, 0x2, 0x94f, 0x951, 0x5, 0x16c, 0xb7, 0x2, 
       0x950, 0x94f, 0x3, 0x2, 0x2, 0x2, 0x950, 0x951, 0x3, 0x2, 0x2, 0x2, 
       0x951, 0x9aa, 0x3, 0x2, 0x2, 0x2, 0x952, 0x966, 0x7, 0xa8, 0x2, 0x2, 
       0x953, 0x955, 0x7, 0x5f, 0x2, 0x2, 0x954, 0x953, 0x3, 0x2, 0x2, 0x2, 
       0x954, 0x955, 0x3, 0x2, 0x2, 0x2, 0x955, 0x956, 0x3, 0x2, 0x2, 0x2, 
       0x956, 0x958, 0x5, 0x33e, 0x1a0, 0x2, 0x957, 0x959, 0x5, 0xe2, 0x72, 
       0x2, 0x958, 0x957, 0x3, 0x2, 0x2, 0x2, 0x958, 0x959, 0x3, 0x2, 0x2, 
       0x2, 0x959, 0x967, 0x3, 0x2, 0x2, 0x2, 0x95a, 0x95b, 0x7, 0xe2, 0x2, 
       0x2, 0x95b, 0x95c, 0x7, 0x12f, 0x2, 0x2, 0x95c, 0x967, 0x5, 0x33e, 
       0x1a0, 0x2, 0x95d, 0x95e, 0x7, 0x1de, 0x2, 0x2, 0x95e, 0x967, 0x7, 
       0x12f, 0x2, 0x2, 0x95f, 0x960, 0x5, 0x440, 0x221, 0x2, 0x960, 0x961, 
       0x5, 0x35e, 0x1b0, 0x2, 0x961, 0x967, 0x3, 0x2, 0x2, 0x2, 0x962, 
       0x963, 0x7, 0x54, 0x2, 0x2, 0x963, 0x967, 0x5, 0x33e, 0x1a0, 0x2, 
       0x964, 0x965, 0x7, 0x6f, 0x2, 0x2, 0x965, 0x967, 0x5, 0x33e, 0x1a0, 
       0x2, 0x966, 0x954, 0x3, 0x2, 0x2, 0x2, 0x966, 0x95a, 0x3, 0x2, 0x2, 
       0x2, 0x966, 0x95d, 0x3, 0x2, 0x2, 0x2, 0x966, 0x95f, 0x3, 0x2, 0x2, 
       0x2, 0x966, 0x962, 0x3, 0x2, 0x2, 0x2, 0x966, 0x964, 0x3, 0x2, 0x2, 
       0x2, 0x967, 0x9aa, 0x3, 0x2, 0x2, 0x2, 0x968, 0x969, 0x7, 0xa0, 0x2, 
       0x2, 0x969, 0x9aa, 0x7, 0x130, 0x2, 0x2, 0x96a, 0x96b, 0x7, 0xb1, 
       0x2, 0x2, 0x96b, 0x9aa, 0x7, 0x130, 0x2, 0x2, 0x96c, 0x96e, 0x7, 
       0x26, 0x2, 0x2, 0x96d, 0x96f, 0x7, 0x5f, 0x2, 0x2, 0x96e, 0x96d, 
       0x3, 0x2, 0x2, 0x2, 0x96e, 0x96f, 0x3, 0x2, 0x2, 0x2, 0x96f, 0x970, 
       0x3, 0x2, 0x2, 0x2, 0x970, 0x97c, 0x5, 0x33e, 0x1a0, 0x2, 0x971, 
       0x972, 0x7, 0x244, 0x2, 0x2, 0x972, 0x978, 0x7, 0x92, 0x2, 0x2, 0x973, 
       0x974, 0x7, 0x2fb, 0x2, 0x2, 0x974, 0x975, 0x5, 0x3a6, 0x1d4, 0x2, 
       0x975, 0x976, 0x7, 0x2fc, 0x2, 0x2, 0x976, 0x979, 0x3, 0x2, 0x2, 
       0x2, 0x977, 0x979, 0x5, 0x436, 0x21c, 0x2, 0x978, 0x973, 0x3, 0x2, 
       0x2, 0x2, 0x978, 0x977, 0x3, 0x2, 0x2, 0x2, 0x979, 0x97d, 0x3, 0x2, 
       0x2, 0x2, 0x97a, 0x97b, 0x7, 0xa8, 0x2, 0x2, 0x97b, 0x97d, 0x7, 0x92, 
       0x2, 0x2, 0x97c, 0x971, 0x3, 0x2, 0x2, 0x2, 0x97c, 0x97a, 0x3, 0x2, 
       0x2, 0x2, 0x97d, 0x9aa, 0x3, 0x2, 0x2, 0x2, 0x97e, 0x97f, 0x7, 0x26, 
       0x2, 0x2, 0x97f, 0x980, 0x7, 0x10c, 0x2, 0x2, 0x980, 0x981, 0x5, 
       0x35e, 0x1b0, 0x2, 0x981, 0x982, 0x5, 0x15c, 0xaf, 0x2, 0x982, 0x9aa, 
       0x3, 0x2, 0x2, 0x2, 0x983, 0x984, 0x7, 0x26, 0x2, 0x2, 0x984, 0x985, 
       0x7, 0x54, 0x2, 0x2, 0x985, 0x986, 0x5, 0x33e, 0x1a0, 0x2, 0x986, 
       0x987, 0x5, 0x140, 0xa1, 0x2, 0x987, 0x9aa, 0x3, 0x2, 0x2, 0x2, 0x988, 
       0x989, 0x7, 0x26, 0x2, 0x2, 0x989, 0x98a, 0x7, 0x6f, 0x2, 0x2, 0x98a, 
       0x98b, 0x5, 0x33e, 0x1a0, 0x2, 0x98b, 0x98c, 0x5, 0x140, 0xa1, 0x2, 
       0x98c, 0x9aa, 0x3, 0x2, 0x2, 0x2, 0x98d, 0x98e, 0x7, 0x203, 0x2, 
       0x2, 0x98e, 0x98f, 0x7, 0x5f, 0x2, 0x2, 0x98f, 0x990, 0x5, 0x33e, 
       0x1a0, 0x2, 0x990, 0x991, 0x7, 0x29b, 0x2, 0x2, 0x991, 0x992, 0x5, 
       0x33e, 0x1a0, 0x2, 0x992, 0x9aa, 0x3, 0x2, 0x2, 0x2, 0x993, 0x995, 
       0x7, 0x203, 0x2, 0x2, 0x994, 0x996, 0x9, 0x13, 0x2, 0x2, 0x995, 0x994, 
       0x3, 0x2, 0x2, 0x2, 0x995, 0x996, 0x3, 0x2, 0x2, 0x2, 0x996, 0x997, 
       0x3, 0x2, 0x2, 0x2, 0x997, 0x9aa, 0x5, 0x35a, 0x1ae, 0x2, 0x998, 
       0x999, 0x7, 0x203, 0x2, 0x2, 0x999, 0x99a, 0x5, 0x440, 0x221, 0x2, 
       0x99a, 0x99b, 0x5, 0x35e, 0x1b0, 0x2, 0x99b, 0x99c, 0x7, 0x29b, 0x2, 
       0x2, 0x99c, 0x99d, 0x5, 0x35e, 0x1b0, 0x2, 0x99d, 0x9aa, 0x3, 0x2, 
       0x2, 0x2, 0x99e, 0x99f, 0x7, 0x76, 0x2, 0x2, 0x99f, 0x9a0, 0x7, 0x29b, 
       0x2, 0x2, 0x9a0, 0x9a1, 0x5, 0x42e, 0x218, 0x2, 0x9a1, 0x9a3, 0x5, 
       0x354, 0x1ab, 0x2, 0x9a2, 0x9a4, 0x5, 0x446, 0x224, 0x2, 0x9a3, 0x9a2, 
       0x3, 0x2, 0x2, 0x2, 0x9a3, 0x9a4, 0x3, 0x2, 0x2, 0x2, 0x9a4, 0x9aa, 
       0x3, 0x2, 0x2, 0x2, 0x9a5, 0x9aa, 0x7, 0xe1, 0x2, 0x2, 0x9a6, 0x9a7, 
       0x7, 0x1bb, 0x2, 0x2, 0x9a7, 0x9a8, 0x7, 0x45, 0x2, 0x2, 0x9a8, 0x9aa, 
       0x5, 0xce, 0x68, 0x2, 0x9a9, 0x930, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x93e, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x940, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x949, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x952, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x968, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x96a, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x96c, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x97e, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x983, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x988, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x98d, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x993, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x998, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x99e, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x9a5, 
       0x3, 0x2, 0x2, 0x2, 0x9a9, 0x9a6, 0x3, 0x2, 0x2, 0x2, 0x9aa, 0xcd, 
       0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9ad, 0x5, 0x33e, 0x1a0, 0x2, 0x9ac, 
       0x9ae, 0x5, 0x43e, 0x220, 0x2, 0x9ad, 0x9ac, 0x3, 0x2, 0x2, 0x2, 
       0x9ad, 0x9ae, 0x3, 0x2, 0x2, 0x2, 0x9ae, 0x9b6, 0x3, 0x2, 0x2, 0x2, 
       0x9af, 0x9b0, 0x7, 0x301, 0x2, 0x2, 0x9b0, 0x9b2, 0x5, 0x33e, 0x1a0, 
       0x2, 0x9b1, 0x9b3, 0x5, 0x43e, 0x220, 0x2, 0x9b2, 0x9b1, 0x3, 0x2, 
       0x2, 0x2, 0x9b2, 0x9b3, 0x3, 0x2, 0x2, 0x2, 0x9b3, 0x9b5, 0x3, 0x2, 
       0x2, 0x2, 0x9b4, 0x9af, 0x3, 0x2, 0x2, 0x2, 0x9b5, 0x9b8, 0x3, 0x2, 
       0x2, 0x2, 0x9b6, 0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b6, 0x9b7, 0x3, 0x2, 
       0x2, 0x2, 0x9b7, 0xcf, 0x3, 0x2, 0x2, 0x2, 0x9b8, 0x9b6, 0x3, 0x2, 
       0x2, 0x2, 0x9b9, 0x9bb, 0x5, 0x440, 0x221, 0x2, 0x9ba, 0x9bc, 0x5, 
       0x14a, 0xa6, 0x2, 0x9bb, 0x9ba, 0x3, 0x2, 0x2, 0x2, 0x9bb, 0x9bc, 
       0x3, 0x2, 0x2, 0x2, 0x9bc, 0x9bd, 0x3, 0x2, 0x2, 0x2, 0x9bd, 0x9c1, 
       0x5, 0x156, 0xac, 0x2, 0x9be, 0x9c0, 0x5, 0x158, 0xad, 0x2, 0x9bf, 
       0x9be, 0x3, 0x2, 0x2, 0x2, 0x9c0, 0x9c3, 0x3, 0x2, 0x2, 0x2, 0x9c1, 
       0x9bf, 0x3, 0x2, 0x2, 0x2, 0x9c1, 0x9c2, 0x3, 0x2, 0x2, 0x2, 0x9c2, 
       0xa08, 0x3, 0x2, 0x2, 0x2, 0x9c3, 0x9c1, 0x3, 0x2, 0x2, 0x2, 0x9c4, 
       0x9c6, 0x7, 0xe7, 0x2, 0x2, 0x9c5, 0x9c7, 0x5, 0x440, 0x221, 0x2, 
       0x9c6, 0x9c5, 0x3, 0x2, 0x2, 0x2, 0x9c6, 0x9c7, 0x3, 0x2, 0x2, 0x2, 
       0x9c7, 0x9c9, 0x3, 0x2, 0x2, 0x2, 0x9c8, 0x9ca, 0x5, 0x35e, 0x1b0, 
       0x2, 0x9c9, 0x9c8, 0x3, 0x2, 0x2, 0x2, 0x9c9, 0x9ca, 0x3, 0x2, 0x2, 
       0x2, 0x9ca, 0x9cb, 0x3, 0x2, 0x2, 0x2, 0x9cb, 0x9cf, 0x5, 0x156, 
       0xac, 0x2, 0x9cc, 0x9ce, 0x5, 0xe4, 0x73, 0x2, 0x9cd, 0x9cc, 0x3, 
       0x2, 0x2, 0x2, 0x9ce, 0x9d1, 0x3, 0x2, 0x2, 0x2, 0x9cf, 0x9cd, 0x3, 
       0x2, 0x2, 0x2, 0x9cf, 0x9d0, 0x3, 0x2, 0x2, 0x2, 0x9d0, 0xa08, 0x3, 
       0x2, 0x2, 0x2, 0x9d1, 0x9cf, 0x3, 0x2, 0x2, 0x2, 0x9d2, 0x9d4, 0x7, 
       0x255, 0x2, 0x2, 0x9d3, 0x9d5, 0x5, 0x440, 0x221, 0x2, 0x9d4, 0x9d3, 
       0x3, 0x2, 0x2, 0x2, 0x9d4, 0x9d5, 0x3, 0x2, 0x2, 0x2, 0x9d5, 0x9d7, 
       0x3, 0x2, 0x2, 0x2, 0x9d6, 0x9d8, 0x5, 0x35e, 0x1b0, 0x2, 0x9d7, 
       0x9d6, 0x3, 0x2, 0x2, 0x2, 0x9d7, 0x9d8, 0x3, 0x2, 0x2, 0x2, 0x9d8, 
       0x9d9, 0x3, 0x2, 0x2, 0x2, 0x9d9, 0x9dd, 0x5, 0x156, 0xac, 0x2, 0x9da, 
       0x9dc, 0x5, 0x15a, 0xae, 0x2, 0x9db, 0x9da, 0x3, 0x2, 0x2, 0x2, 0x9dc, 
       0x9df, 0x3, 0x2, 0x2, 0x2, 0x9dd, 0x9db, 0x3, 0x2, 0x2, 0x2, 0x9dd, 
       0x9de, 0x3, 0x2, 0x2, 0x2, 0x9de, 0xa08, 0x3, 0x2, 0x2, 0x2, 0x9df, 
       0x9dd, 0x3, 0x2, 0x2, 0x2, 0x9e0, 0x9e2, 0x5, 0xdc, 0x6f, 0x2, 0x9e1, 
       0x9e0, 0x3, 0x2, 0x2, 0x2, 0x9e1, 0x9e2, 0x3, 0x2, 0x2, 0x2, 0x9e2, 
       0x9e9, 0x3, 0x2, 0x2, 0x2, 0x9e3, 0x9e4, 0x7, 0x1de, 0x2, 0x2, 0x9e4, 
       0x9ea, 0x7, 0x12f, 0x2, 0x2, 0x9e5, 0x9e7, 0x7, 0x2ad, 0x2, 0x2, 
       0x9e6, 0x9e8, 0x5, 0x440, 0x221, 0x2, 0x9e7, 0x9e6, 0x3, 0x2, 0x2, 
       0x2, 0x9e7, 0x9e8, 0x3, 0x2, 0x2, 0x2, 0x9e8, 0x9ea, 0x3, 0x2, 0x2, 
       0x2, 0x9e9, 0x9e3, 0x3, 0x2, 0x2, 0x2, 0x9e9, 0x9e5, 0x3, 0x2, 0x2, 
       0x2, 0x9ea, 0x9ec, 0x3, 0x2, 0x2, 0x2, 0x9eb, 0x9ed, 0x5, 0x14a, 
       0xa6, 0x2, 0x9ec, 0x9eb, 0x3, 0x2, 0x2, 0x2, 0x9ec, 0x9ed, 0x3, 0x2, 
       0x2, 0x2, 0x9ed, 0x9ee, 0x3, 0x2, 0x2, 0x2, 0x9ee, 0x9f2, 0x5, 0x156, 
       0xac, 0x2, 0x9ef, 0x9f1, 0x5, 0x158, 0xad, 0x2, 0x9f0, 0x9ef, 0x3, 
       0x2, 0x2, 0x2, 0x9f1, 0x9f4, 0x3, 0x2, 0x2, 0x2, 0x9f2, 0x9f0, 0x3, 
       0x2, 0x2, 0x2, 0x9f2, 0x9f3, 0x3, 0x2, 0x2, 0x2, 0x9f3, 0xa08, 0x3, 
       0x2, 0x2, 0x2, 0x9f4, 0x9f2, 0x3, 0x2, 0x2, 0x2, 0x9f5, 0x9f7, 0x5, 
       0xdc, 0x6f, 0x2, 0x9f6, 0x9f5, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9f7, 
       0x3, 0x2, 0x2, 0x2, 0x9f7, 0x9f8, 0x3, 0x2, 0x2, 0x2, 0x9f8, 0x9f9, 
       0x7, 0xe2, 0x2, 0x2, 0x9f9, 0x9fb, 0x7, 0x12f, 0x2, 0x2, 0x9fa, 0x9fc, 
       0x5, 0x35e, 0x1b0, 0x2, 0x9fb, 0x9fa, 0x3, 0x2, 0x2, 0x2, 0x9fb, 
       0x9fc, 0x3, 0x2, 0x2, 0x2, 0x9fc, 0x9fd, 0x3, 0x2, 0x2, 0x2, 0x9fd, 
       0x9fe, 0x5, 0x150, 0xa9, 0x2, 0x9fe, 0x9ff, 0x5, 0x144, 0xa3, 0x2, 
       0x9ff, 0xa08, 0x3, 0x2, 0x2, 0x2, 0xa00, 0xa02, 0x5, 0xdc, 0x6f, 
       0x2, 0xa01, 0xa00, 0x3, 0x2, 0x2, 0x2, 0xa01, 0xa02, 0x3, 0x2, 0x2, 
       0x2, 0xa02, 0xa03, 0x3, 0x2, 0x2, 0x2, 0xa03, 0xa05, 0x5, 0x13e, 
       0xa0, 0x2, 0xa04, 0xa06, 0x5, 0x140, 0xa1, 0x2, 0xa05, 0xa04, 0x3, 
       0x2, 0x2, 0x2, 0xa05, 0xa06, 0x3, 0x2, 0x2, 0x2, 0xa06, 0xa08, 0x3, 
       0x2, 0x2, 0x2, 0xa07, 0x9b9, 0x3, 0x2, 0x2, 0x2, 0xa07, 0x9c4, 0x3, 
       0x2, 0x2, 0x2, 0xa07, 0x9d2, 0x3, 0x2, 0x2, 0x2, 0xa07, 0x9e1, 0x3, 
       0x2, 0x2, 0x2, 0xa07, 0x9f6, 0x3, 0x2, 0x2, 0x2, 0xa07, 0xa01, 0x3, 
       0x2, 0x2, 0x2, 0xa08, 0xd1, 0x3, 0x2, 0x2, 0x2, 0xa09, 0xa0e, 0x5, 
       0xd4, 0x6b, 0x2, 0xa0a, 0xa0b, 0x7, 0x301, 0x2, 0x2, 0xa0b, 0xa0d, 
       0x5, 0xd4, 0x6b, 0x2, 0xa0c, 0xa0a, 0x3, 0x2, 0x2, 0x2, 0xa0d, 0xa10, 
       0x3, 0x2, 0x2, 0x2, 0xa0e, 0xa0c, 0x3, 0x2, 0x2, 0x2, 0xa0e, 0xa0f, 
       0x3, 0x2, 0x2, 0x2, 0xa0f, 0xd3, 0x3, 0x2, 0x2, 0x2, 0xa10, 0xa0e, 
       0x3, 0x2, 0x2, 0x2, 0xa11, 0xa15, 0x5, 0xea, 0x76, 0x2, 0xa12, 0xa15, 
       0x5, 0xec, 0x77, 0x2, 0xa13, 0xa15, 0x5, 0xd6, 0x6c, 0x2, 0xa14, 
       0xa11, 0x3, 0x2, 0x2, 0x2, 0xa14, 0xa12, 0x3, 0x2, 0x2, 0x2, 0xa14, 
       0xa13, 0x3, 0x2, 0x2, 0x2, 0xa15, 0xd5, 0x3, 0x2, 0x2, 0x2, 0xa16, 
       0xa17, 0x9, 0x14, 0x2, 0x2, 0xa17, 0xa18, 0x7, 0x2bd, 0x2, 0x2, 0xa18, 
       0xd7, 0x3, 0x2, 0x2, 0x2, 0xa19, 0xa1a, 0x7, 0xa1, 0x2, 0x2, 0xa1a, 
       0xa20, 0x7, 0x288, 0x2, 0x2, 0xa1b, 0xa1c, 0x7, 0x109, 0x2, 0x2, 
       0xa1c, 0xa20, 0x7, 0x288, 0x2, 0x2, 0xa1d, 0xa20, 0x5, 0xda, 0x6e, 
       0x2, 0xa1e, 0xa20, 0x9, 0x15, 0x2, 0x2, 0xa1f, 0xa19, 0x3, 0x2, 0x2, 
       0x2, 0xa1f, 0xa1b, 0x3, 0x2, 0x2, 0x2, 0xa1f, 0xa1d, 0x3, 0x2, 0x2, 
       0x2, 0xa1f, 0xa1e, 0x3, 0x2, 0x2, 0x2, 0xa20, 0xd9, 0x3, 0x2, 0x2, 
       0x2, 0xa21, 0xa22, 0x7, 0x1f, 0x2, 0x2, 0xa22, 0xa24, 0x7, 0x1c8, 
       0x2, 0x2, 0xa23, 0xa25, 0x5, 0x458, 0x22d, 0x2, 0xa24, 0xa23, 0x3, 
       0x2, 0x2, 0x2, 0xa24, 0xa25, 0x3, 0x2, 0x2, 0x2, 0xa25, 0xa29, 0x3, 
       0x2, 0x2, 0x2, 0xa26, 0xa2a, 0x5, 0x16e, 0xb8, 0x2, 0xa27, 0xa28, 
       0x7, 0x1ca, 0x2, 0x2, 0xa28, 0xa2a, 0x7, 0x313, 0x2, 0x2, 0xa29, 
       0xa26, 0x3, 0x2, 0x2, 0x2, 0xa29, 0xa27, 0x3, 0x2, 0x2, 0x2, 0xa2a, 
       0xa80, 0x3, 0x2, 0x2, 0x2, 0xa2b, 0xa2c, 0x7, 0xa8, 0x2, 0x2, 0xa2c, 
       0xa2d, 0x7, 0x1c8, 0x2, 0x2, 0xa2d, 0xa80, 0x5, 0x39e, 0x1d0, 0x2, 
       0xa2e, 0xa2f, 0x7, 0x1f3, 0x2, 0x2, 0xa2f, 0xa31, 0x7, 0x1c8, 0x2, 
       0x2, 0xa30, 0xa32, 0x5, 0x458, 0x22d, 0x2, 0xa31, 0xa30, 0x3, 0x2, 
       0x2, 0x2, 0xa31, 0xa32, 0x3, 0x2, 0x2, 0x2, 0xa32, 0xa33, 0x3, 0x2, 
       0x2, 0x2, 0xa33, 0xa80, 0x5, 0x3a0, 0x1d1, 0x2, 0xa34, 0xa35, 0x7, 
       0x1b4, 0x2, 0x2, 0xa35, 0xa37, 0x7, 0x1c8, 0x2, 0x2, 0xa36, 0xa38, 
       0x5, 0x458, 0x22d, 0x2, 0xa37, 0xa36, 0x3, 0x2, 0x2, 0x2, 0xa37, 
       0xa38, 0x3, 0x2, 0x2, 0x2, 0xa38, 0xa39, 0x3, 0x2, 0x2, 0x2, 0xa39, 
       0xa3b, 0x5, 0x3a0, 0x1d1, 0x2, 0xa3a, 0xa3c, 0x5, 0x458, 0x22d, 0x2, 
       0xa3b, 0xa3a, 0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa3c, 0x3, 0x2, 0x2, 0x2, 
       0xa3c, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa3d, 0xa3e, 0x7, 0x28, 0x2, 0x2, 
       0xa3e, 0xa40, 0x7, 0x1c8, 0x2, 0x2, 0xa3f, 0xa41, 0x5, 0x458, 0x22d, 
       0x2, 0xa40, 0xa3f, 0x3, 0x2, 0x2, 0x2, 0xa40, 0xa41, 0x3, 0x2, 0x2, 
       0x2, 0xa41, 0xa42, 0x3, 0x2, 0x2, 0x2, 0xa42, 0xa80, 0x5, 0x3a0, 
       0x1d1, 0x2, 0xa43, 0xa44, 0x7, 0x54, 0x2, 0x2, 0xa44, 0xa45, 0x7, 
       0x1c8, 0x2, 0x2, 0xa45, 0xa49, 0x5, 0x3a0, 0x1d1, 0x2, 0xa46, 0xa48, 
       0x5, 0x3dc, 0x1ef, 0x2, 0xa47, 0xa46, 0x3, 0x2, 0x2, 0x2, 0xa48, 
       0xa4b, 0x3, 0x2, 0x2, 0x2, 0xa49, 0xa47, 0x3, 0x2, 0x2, 0x2, 0xa49, 
       0xa4a, 0x3, 0x2, 0x2, 0x2, 0xa4a, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa4b, 
       0xa49, 0x3, 0x2, 0x2, 0x2, 0xa4c, 0xa4d, 0x7, 0x205, 0x2, 0x2, 0xa4d, 
       0xa4f, 0x7, 0x1c8, 0x2, 0x2, 0xa4e, 0xa50, 0x5, 0x458, 0x22d, 0x2, 
       0xa4f, 0xa4e, 0x3, 0x2, 0x2, 0x2, 0xa4f, 0xa50, 0x3, 0x2, 0x2, 0x2, 
       0xa50, 0xa51, 0x3, 0x2, 0x2, 0x2, 0xa51, 0xa55, 0x5, 0x3a0, 0x1d1, 
       0x2, 0xa52, 0xa54, 0x5, 0x3de, 0x1f0, 0x2, 0xa53, 0xa52, 0x3, 0x2, 
       0x2, 0x2, 0xa54, 0xa57, 0x3, 0x2, 0x2, 0x2, 0xa55, 0xa53, 0x3, 0x2, 
       0x2, 0x2, 0xa55, 0xa56, 0x3, 0x2, 0x2, 0x2, 0xa56, 0xa80, 0x3, 0x2, 
       0x2, 0x2, 0xa57, 0xa55, 0x3, 0x2, 0x2, 0x2, 0xa58, 0xa59, 0x7, 0x5b, 
       0x2, 0x2, 0xa59, 0xa5b, 0x7, 0x1c8, 0x2, 0x2, 0xa5a, 0xa5c, 0x5, 
       0x458, 0x22d, 0x2, 0xa5b, 0xa5a, 0x3, 0x2, 0x2, 0x2, 0xa5b, 0xa5c, 
       0x3, 0x2, 0x2, 0x2, 0xa5c, 0xa5d, 0x3, 0x2, 0x2, 0x2, 0xa5d, 0xa80, 
       0x7, 0x313, 0x2, 0x2, 0xa5e, 0xa5f, 0x7, 0x2a1, 0x2, 0x2, 0xa5f, 
       0xa60, 0x7, 0x1c8, 0x2, 0x2, 0xa60, 0xa80, 0x5, 0x3a0, 0x1d1, 0x2, 
       0xa61, 0xa62, 0x7, 0x204, 0x2, 0x2, 0xa62, 0xa64, 0x7, 0x1c8, 0x2, 
       0x2, 0xa63, 0xa65, 0x5, 0x458, 0x22d, 0x2, 0xa64, 0xa63, 0x3, 0x2, 
       0x2, 0x2, 0xa64, 0xa65, 0x3, 0x2, 0x2, 0x2, 0xa65, 0xa6a, 0x3, 0x2, 
       0x2, 0x2, 0xa66, 0xa67, 0x5, 0x39e, 0x1d0, 0x2, 0xa67, 0xa68, 0x7, 
       0x11f, 0x2, 0x2, 0xa68, 0xa69, 0x5, 0x16e, 0xb8, 0x2, 0xa69, 0xa6b, 
       0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa66, 0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa6b, 
       0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa6c, 0xa6d, 
       0x7, 0xc3, 0x2, 0x2, 0xa6d, 0xa6e, 0x7, 0x1c8, 0x2, 0x2, 0xa6e, 0xa6f, 
       0x5, 0x33e, 0x1a0, 0x2, 0xa6f, 0xa70, 0x7, 0x2d1, 0x2, 0x2, 0xa70, 
       0xa71, 0x7, 0x286, 0x2, 0x2, 0xa71, 0xa73, 0x5, 0x35a, 0x1ae, 0x2, 
       0xa72, 0xa74, 0x5, 0xd6, 0x6c, 0x2, 0xa73, 0xa72, 0x3, 0x2, 0x2, 
       0x2, 0xa73, 0xa74, 0x3, 0x2, 0x2, 0x2, 0xa74, 0xa80, 0x3, 0x2, 0x2, 
       0x2, 0xa75, 0xa76, 0x7, 0xa1, 0x2, 0x2, 0xa76, 0xa77, 0x7, 0x1c8, 
       0x2, 0x2, 0xa77, 0xa78, 0x5, 0x3a0, 0x1d1, 0x2, 0xa78, 0xa79, 0x7, 
       0x288, 0x2, 0x2, 0xa79, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa7b, 
       0x7, 0x109, 0x2, 0x2, 0xa7b, 0xa7c, 0x7, 0x1c8, 0x2, 0x2, 0xa7c, 
       0xa7d, 0x5, 0x3a0, 0x1d1, 0x2, 0xa7d, 0xa7e, 0x7, 0x288, 0x2, 0x2, 
       0xa7e, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa21, 0x3, 0x2, 0x2, 0x2, 
       0xa7f, 0xa2b, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa2e, 0x3, 0x2, 0x2, 0x2, 
       0xa7f, 0xa34, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa3d, 0x3, 0x2, 0x2, 0x2, 
       0xa7f, 0xa43, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa4c, 0x3, 0x2, 0x2, 0x2, 
       0xa7f, 0xa58, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa5e, 0x3, 0x2, 0x2, 0x2, 
       0xa7f, 0xa61, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa6c, 0x3, 0x2, 0x2, 0x2, 
       0xa7f, 0xa75, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa7a, 0x3, 0x2, 0x2, 0x2, 
       0xa80, 0xdb, 0x3, 0x2, 0x2, 0x2, 0xa81, 0xa83, 0x7, 0x6f, 0x2, 0x2, 
       0xa82, 0xa84, 0x5, 0x33e, 0x1a0, 0x2, 0xa83, 0xa82, 0x3, 0x2, 0x2, 
       0x2, 0xa83, 0xa84, 0x3, 0x2, 0x2, 0x2, 0xa84, 0xdd, 0x3, 0x2, 0x2, 
       0x2, 0xa85, 0xa8a, 0x5, 0xe0, 0x71, 0x2, 0xa86, 0xa87, 0x7, 0x301, 
       0x2, 0x2, 0xa87, 0xa89, 0x5, 0xe0, 0x71, 0x2, 0xa88, 0xa86, 0x3, 
       0x2, 0x2, 0x2, 0xa89, 0xa8c, 0x3, 0x2, 0x2, 0x2, 0xa8a, 0xa88, 0x3, 
       0x2, 0x2, 0x2, 0xa8a, 0xa8b, 0x3, 0x2, 0x2, 0x2, 0xa8b, 0xdf, 0x3, 
       0x2, 0x2, 0x2, 0xa8c, 0xa8a, 0x3, 0x2, 0x2, 0x2, 0xa8d, 0xa90, 0x5, 
       0x138, 0x9d, 0x2, 0xa8e, 0xa90, 0x5, 0xd0, 0x69, 0x2, 0xa8f, 0xa8d, 
       0x3, 0x2, 0x2, 0x2, 0xa8f, 0xa8e, 0x3, 0x2, 0x2, 0x2, 0xa90, 0xe1, 
       0x3, 0x2, 0x2, 0x2, 0xa91, 0xa92, 0x9, 0x16, 0x2, 0x2, 0xa92, 0xe3, 
       0x3, 0x2, 0x2, 0x2, 0xa93, 0xa98, 0x5, 0x15a, 0xae, 0x2, 0xa94, 0xa95, 
       0x7, 0x2d1, 0x2, 0x2, 0xa95, 0xa96, 0x7, 0x1c6, 0x2, 0x2, 0xa96, 
       0xa98, 0x5, 0x33e, 0x1a0, 0x2, 0xa97, 0xa93, 0x3, 0x2, 0x2, 0x2, 
       0xa97, 0xa94, 0x3, 0x2, 0x2, 0x2, 0xa98, 0xe5, 0x3, 0x2, 0x2, 0x2, 
       0xa99, 0xa9b, 0x7, 0xa8, 0x2, 0x2, 0xa9a, 0xa9c, 0x7, 0x28b, 0x2, 
       0x2, 0xa9b, 0xa9a, 0x3, 0x2, 0x2, 0x2, 0xa9b, 0xa9c, 0x3, 0x2, 0x2, 
       0x2, 0xa9c, 0xa9d, 0x3, 0x2, 0x2, 0x2, 0xa9d, 0xa9f, 0x5, 0x398, 
       0x1cd, 0x2, 0xa9e, 0xaa0, 0x5, 0x44c, 0x227, 0x2, 0xa9f, 0xa9e, 0x3, 
       0x2, 0x2, 0x2, 0xa9f, 0xaa0, 0x3, 0x2, 0x2, 0x2, 0xaa0, 0xaa1, 0x3, 
       0x2, 0x2, 0x2, 0xaa1, 0xaa3, 0x5, 0x374, 0x1bb, 0x2, 0xaa2, 0xaa4, 
       0x5, 0xe2, 0x72, 0x2, 0xaa3, 0xaa2, 0x3, 0x2, 0x2, 0x2, 0xaa3, 0xaa4, 
       0x3, 0x2, 0x2, 0x2, 0xaa4, 0xe7, 0x3, 0x2, 0x2, 0x2, 0xaa5, 0xaa6, 
       0x7, 0xa8, 0x2, 0x2, 0xaa6, 0xaa7, 0x7, 0x10c, 0x2, 0x2, 0xaa7, 0xaaa, 
       0x5, 0x35e, 0x1b0, 0x2, 0xaa8, 0xaa9, 0x7, 0x1b0, 0x2, 0x2, 0xaa9, 
       0xaab, 0x5, 0x35a, 0x1ae, 0x2, 0xaaa, 0xaa8, 0x3, 0x2, 0x2, 0x2, 
       0xaaa, 0xaab, 0x3, 0x2, 0x2, 0x2, 0xaab, 0xab0, 0x3, 0x2, 0x2, 0x2, 
       0xaac, 0xaaf, 0x5, 0xea, 0x76, 0x2, 0xaad, 0xaaf, 0x5, 0xec, 0x77, 
       0x2, 0xaae, 0xaac, 0x3, 0x2, 0x2, 0x2, 0xaae, 0xaad, 0x3, 0x2, 0x2, 
       0x2, 0xaaf, 0xab2, 0x3, 0x2, 0x2, 0x2, 0xab0, 0xaae, 0x3, 0x2, 0x2, 
       0x2, 0xab0, 0xab1, 0x3, 0x2, 0x2, 0x2, 0xab1, 0xe9, 0x3, 0x2, 0x2, 
       0x2, 0xab2, 0xab0, 0x3, 0x2, 0x2, 0x2, 0xab3, 0xab5, 0x7, 0x24, 0x2, 
       0x2, 0xab4, 0xab6, 0x7, 0x2f4, 0x2, 0x2, 0xab5, 0xab4, 0x3, 0x2, 
       0x2, 0x2, 0xab5, 0xab6, 0x3, 0x2, 0x2, 0x2, 0xab6, 0xab7, 0x3, 0x2, 
       0x2, 0x2, 0xab7, 0xab8, 0x9, 0x17, 0x2, 0x2, 0xab8, 0xeb, 0x3, 0x2, 
       0x2, 0x2, 0xab9, 0xabb, 0x7, 0x149, 0x2, 0x2, 0xaba, 0xabc, 0x7, 
       0x2f4, 0x2, 0x2, 0xabb, 0xaba, 0x3, 0x2, 0x2, 0x2, 0xabb, 0xabc, 
       0x3, 0x2, 0x2, 0x2, 0xabc, 0xabd, 0x3, 0x2, 0x2, 0x2, 0xabd, 0xabe, 
       0x9, 0x18, 0x2, 0x2, 0xabe, 0xed, 0x3, 0x2, 0x2, 0x2, 0xabf, 0xac1, 
       0x7, 0x2a1, 0x2, 0x2, 0xac0, 0xac2, 0x7, 0x286, 0x2, 0x2, 0xac1, 
       0xac0, 0x3, 0x2, 0x2, 0x2, 0xac1, 0xac2, 0x3, 0x2, 0x2, 0x2, 0xac2, 
       0xac3, 0x3, 0x2, 0x2, 0x2, 0xac3, 0xac4, 0x5, 0x35a, 0x1ae, 0x2, 
       0xac4, 0xef, 0x3, 0x2, 0x2, 0x2, 0xac5, 0xac7, 0x7, 0x78, 0x2, 0x2, 
       0xac6, 0xac8, 0x5, 0x160, 0xb1, 0x2, 0xac7, 0xac6, 0x3, 0x2, 0x2, 
       0x2, 0xac7, 0xac8, 0x3, 0x2, 0x2, 0x2, 0xac8, 0xac9, 0x3, 0x2, 0x2, 
       0x2, 0xac9, 0xaca, 0x7, 0x10c, 0x2, 0x2, 0xaca, 0xacc, 0x5, 0x35e, 
       0x1b0, 0x2, 0xacb, 0xacd, 0x5, 0x14e, 0xa8, 0x2, 0xacc, 0xacb, 0x3, 
       0x2, 0x2, 0x2, 0xacc, 0xacd, 0x3, 0x2, 0x2, 0x2, 0xacd, 0xace, 0x3, 
       0x2, 0x2, 0x2, 0xace, 0xacf, 0x7, 0x1b0, 0x2, 0x2, 0xacf, 0xad0, 
       0x5, 0x35a, 0x1ae, 0x2, 0xad0, 0xad2, 0x5, 0x156, 0xac, 0x2, 0xad1, 
       0xad3, 0x5, 0x158, 0xad, 0x2, 0xad2, 0xad1, 0x3, 0x2, 0x2, 0x2, 0xad2, 
       0xad3, 0x3, 0x2, 0x2, 0x2, 0xad3, 0xad8, 0x3, 0x2, 0x2, 0x2, 0xad4, 
       0xad7, 0x5, 0xea, 0x76, 0x2, 0xad5, 0xad7, 0x5, 0xec, 0x77, 0x2, 
       0xad6, 0xad4, 0x3, 0x2, 0x2, 0x2, 0xad6, 0xad5, 0x3, 0x2, 0x2, 0x2, 
       0xad7, 0xada, 0x3, 0x2, 0x2, 0x2, 0xad8, 0xad6, 0x3, 0x2, 0x2, 0x2, 
       0xad8, 0xad9, 0x3, 0x2, 0x2, 0x2, 0xad9, 0xf1, 0x3, 0x2, 0x2, 0x2, 
       0xada, 0xad8, 0x3, 0x2, 0x2, 0x2, 0xadb, 0xadc, 0x7, 0x78, 0x2, 0x2, 
       0xadc, 0xade, 0x9, 0x19, 0x2, 0x2, 0xadd, 0xadf, 0x5, 0x44a, 0x226, 
       0x2, 0xade, 0xadd, 0x3, 0x2, 0x2, 0x2, 0xade, 0xadf, 0x3, 0x2, 0x2, 
       0x2, 0xadf, 0xae0, 0x3, 0x2, 0x2, 0x2, 0xae0, 0xae4, 0x5, 0x350, 
       0x1a9, 0x2, 0xae1, 0xae3, 0x5, 0xf6, 0x7c, 0x2, 0xae2, 0xae1, 0x3, 
       0x2, 0x2, 0x2, 0xae3, 0xae6, 0x3, 0x2, 0x2, 0x2, 0xae4, 0xae2, 0x3, 
       0x2, 0x2, 0x2, 0xae4, 0xae5, 0x3, 0x2, 0x2, 0x2, 0xae5, 0xf3, 0x3, 
       0x2, 0x2, 0x2, 0xae6, 0xae4, 0x3, 0x2, 0x2, 0x2, 0xae7, 0xae8, 0x7, 
       0x26, 0x2, 0x2, 0xae8, 0xaea, 0x9, 0x19, 0x2, 0x2, 0xae9, 0xaeb, 
       0x5, 0x350, 0x1a9, 0x2, 0xaea, 0xae9, 0x3, 0x2, 0x2, 0x2, 0xaea, 
       0xaeb, 0x3, 0x2, 0x2, 0x2, 0xaeb, 0xaef, 0x3, 0x2, 0x2, 0x2, 0xaec, 
       0xaee, 0x5, 0xf8, 0x7d, 0x2, 0xaed, 0xaec, 0x3, 0x2, 0x2, 0x2, 0xaee, 
       0xaf1, 0x3, 0x2, 0x2, 0x2, 0xaef, 0xaed, 0x3, 0x2, 0x2, 0x2, 0xaef, 
       0xaf0, 0x3, 0x2, 0x2, 0x2, 0xaf0, 0xf5, 0x3, 0x2, 0x2, 0x2, 0xaf1, 
       0xaef, 0x3, 0x2, 0x2, 0x2, 0xaf2, 0xaf6, 0x5, 0x434, 0x21b, 0x2, 
       0xaf3, 0xaf6, 0x5, 0x430, 0x219, 0x2, 0xaf4, 0xaf6, 0x5, 0x432, 0x21a, 
       0x2, 0xaf5, 0xaf2, 0x3, 0x2, 0x2, 0x2, 0xaf5, 0xaf3, 0x3, 0x2, 0x2, 
       0x2, 0xaf5, 0xaf4, 0x3, 0x2, 0x2, 0x2, 0xaf6, 0xf7, 0x3, 0x2, 0x2, 
       0x2, 0xaf7, 0xaff, 0x5, 0xf6, 0x7c, 0x2, 0xaf8, 0xaf9, 0x7, 0x1ee, 
       0x2, 0x2, 0xaf9, 0xafb, 0x7, 0x1b2, 0x2, 0x2, 0xafa, 0xafc, 0x7, 
       0x2f4, 0x2, 0x2, 0xafb, 0xafa, 0x3, 0x2, 0x2, 0x2, 0xafb, 0xafc, 
       0x3, 0x2, 0x2, 0x2, 0xafc, 0xafd, 0x3, 0x2, 0x2, 0x2, 0xafd, 0xaff, 
       0x9, 0x1a, 0x2, 0x2, 0xafe, 0xaf7, 0x3, 0x2, 0x2, 0x2, 0xafe, 0xaf8, 
       0x3, 0x2, 0x2, 0x2, 0xaff, 0xf9, 0x3, 0x2, 0x2, 0x2, 0xb00, 0xb01, 
       0x7, 0xa8, 0x2, 0x2, 0xb01, 0xb03, 0x9, 0x19, 0x2, 0x2, 0xb02, 0xb04, 
       0x5, 0x44c, 0x227, 0x2, 0xb03, 0xb02, 0x3, 0x2, 0x2, 0x2, 0xb03, 
       0xb04, 0x3, 0x2, 0x2, 0x2, 0xb04, 0xb05, 0x3, 0x2, 0x2, 0x2, 0xb05, 
       0xb06, 0x5, 0x350, 0x1a9, 0x2, 0xb06, 0xfb, 0x3, 0x2, 0x2, 0x2, 0xb07, 
       0xb08, 0x7, 0x26, 0x2, 0x2, 0xb08, 0xb09, 0x7, 0x116, 0x2, 0x2, 0xb09, 
       0xb0a, 0x5, 0xfe, 0x80, 0x2, 0xb0a, 0xfd, 0x3, 0x2, 0x2, 0x2, 0xb0b, 
       0xb0c, 0x9, 0x1b, 0x2, 0x2, 0xb0c, 0xb0d, 0x7, 0x19, 0x2, 0x2, 0xb0d, 
       0xb24, 0x7, 0x1a, 0x2, 0x2, 0xb0e, 0xb0f, 0x7, 0x228, 0x2, 0x2, 0xb0f, 
       0xb10, 0x7, 0x19, 0x2, 0x2, 0xb10, 0xb11, 0x7, 0x154, 0x2, 0x2, 0xb11, 
       0xb24, 0x7, 0x12f, 0x2, 0x2, 0xb12, 0xb13, 0x7, 0x228, 0x2, 0x2, 
       0xb13, 0xb14, 0x7, 0x3c, 0x2, 0x2, 0xb14, 0xb15, 0x7, 0x154, 0x2, 
       0x2, 0xb15, 0xb24, 0x7, 0x12f, 0x2, 0x2, 0xb16, 0xb17, 0x7, 0x201, 
       0x2, 0x2, 0xb17, 0xb1b, 0x7, 0x29a, 0x2, 0x2, 0xb18, 0xb19, 0x7, 
       0xe0, 0x2, 0x2, 0xb19, 0xb1a, 0x7, 0x50, 0x2, 0x2, 0xb1a, 0xb1c, 
       0x5, 0x100, 0x81, 0x2, 0xb1b, 0xb18, 0x3, 0x2, 0x2, 0x2, 0xb1b, 0xb1c, 
       0x3, 0x2, 0x2, 0x2, 0xb1c, 0xb21, 0x3, 0x2, 0x2, 0x2, 0xb1d, 0xb1e, 
       0x7, 0x19d, 0x2, 0x2, 0xb1e, 0xb1f, 0x7, 0x226, 0x2, 0x2, 0xb1f, 
       0xb20, 0x7, 0x1b0, 0x2, 0x2, 0xb20, 0xb22, 0x7, 0xbb, 0x2, 0x2, 0xb21, 
       0xb1d, 0x3, 0x2, 0x2, 0x2, 0xb21, 0xb22, 0x3, 0x2, 0x2, 0x2, 0xb22, 
       0xb24, 0x3, 0x2, 0x2, 0x2, 0xb23, 0xb0b, 0x3, 0x2, 0x2, 0x2, 0xb23, 
       0xb0e, 0x3, 0x2, 0x2, 0x2, 0xb23, 0xb12, 0x3, 0x2, 0x2, 0x2, 0xb23, 
       0xb16, 0x3, 0x2, 0x2, 0x2, 0xb24, 0xff, 0x3, 0x2, 0x2, 0x2, 0xb25, 
       0xb26, 0x9, 0x1c, 0x2, 0x2, 0xb26, 0x101, 0x3, 0x2, 0x2, 0x2, 0xb27, 
       0xb29, 0x7, 0x78, 0x2, 0x2, 0xb28, 0xb2a, 0x5, 0x17a, 0xbe, 0x2, 
       0xb29, 0xb28, 0x3, 0x2, 0x2, 0x2, 0xb29, 0xb2a, 0x3, 0x2, 0x2, 0x2, 
       0xb2a, 0xb2b, 0x3, 0x2, 0x2, 0x2, 0xb2b, 0xb2d, 0x7, 0xbf, 0x2, 0x2, 
       0xb2c, 0xb2e, 0x5, 0x44a, 0x226, 0x2, 0xb2d, 0xb2c, 0x3, 0x2, 0x2, 
       0x2, 0xb2d, 0xb2e, 0x3, 0x2, 0x2, 0x2, 0xb2e, 0xb2f, 0x3, 0x2, 0x2, 
       0x2, 0xb2f, 0xb30, 0x5, 0x364, 0x1b3, 0x2, 0xb30, 0xb31, 0x7, 0x1b0, 
       0x2, 0x2, 0xb31, 0xb32, 0x7, 0x231, 0x2, 0x2, 0xb32, 0xb39, 0x5, 
       0x17c, 0xbf, 0x2, 0xb33, 0xb34, 0x7, 0x1b0, 0x2, 0x2, 0xb34, 0xb36, 
       0x7, 0x67, 0x2, 0x2, 0xb35, 0xb37, 0x7, 0x1a0, 0x2, 0x2, 0xb36, 0xb35, 
       0x3, 0x2, 0x2, 0x2, 0xb36, 0xb37, 0x3, 0x2, 0x2, 0x2, 0xb37, 0xb38, 
       0x3, 0x2, 0x2, 0x2, 0xb38, 0xb3a, 0x7, 0x1dc, 0x2, 0x2, 0xb39, 0xb33, 
       0x3, 0x2, 0x2, 0x2, 0xb39, 0xb3a, 0x3, 0x2, 0x2, 0x2, 0xb3a, 0xb40, 
       0x3, 0x2, 0x2, 0x2, 0xb3b, 0xb41, 0x7, 0xb1, 0x2, 0x2, 0xb3c, 0xb41, 
       0x7, 0xa0, 0x2, 0x2, 0xb3d, 0xb3e, 0x7, 0xa0, 0x2, 0x2, 0xb3e, 0xb3f, 
       0x7, 0x1b0, 0x2, 0x2, 0xb3f, 0xb41, 0x7, 0x24c, 0x2, 0x2, 0xb40, 
       0xb3b, 0x3, 0x2, 0x2, 0x2, 0xb40, 0xb3c, 0x3, 0x2, 0x2, 0x2, 0xb40, 
       0xb3d, 0x3, 0x2, 0x2, 0x2, 0xb40, 0xb41, 0x3, 0x2, 0x2, 0x2, 0xb41, 
       0xb44, 0x3, 0x2, 0x2, 0x2, 0xb42, 0xb43, 0x7, 0x63, 0x2, 0x2, 0xb43, 
       0xb45, 0x5, 0x32c, 0x197, 0x2, 0xb44, 0xb42, 0x3, 0x2, 0x2, 0x2, 
       0xb44, 0xb45, 0x3, 0x2, 0x2, 0x2, 0xb45, 0xb46, 0x3, 0x2, 0x2, 0x2, 
       0xb46, 0xb47, 0x7, 0xa6, 0x2, 0x2, 0xb47, 0xb48, 0x5, 0x180, 0xc1, 
       0x2, 0xb48, 0x103, 0x3, 0x2, 0x2, 0x2, 0xb49, 0xb4b, 0x7, 0x26, 0x2, 
       0x2, 0xb4a, 0xb4c, 0x5, 0x17a, 0xbe, 0x2, 0xb4b, 0xb4a, 0x3, 0x2, 
       0x2, 0x2, 0xb4b, 0xb4c, 0x3, 0x2, 0x2, 0x2, 0xb4c, 0xb4d, 0x3, 0x2, 
       0x2, 0x2, 0xb4d, 0xb4e, 0x7, 0xbf, 0x2, 0x2, 0xb4e, 0xb52, 0x5, 0x364, 
       0x1b3, 0x2, 0xb4f, 0xb50, 0x7, 0x1b0, 0x2, 0x2, 0xb50, 0xb51, 0x7, 
       0x231, 0x2, 0x2, 0xb51, 0xb53, 0x5, 0x17c, 0xbf, 0x2, 0xb52, 0xb4f, 
       0x3, 0x2, 0x2, 0x2, 0xb52, 0xb53, 0x3, 0x2, 0x2, 0x2, 0xb53, 0xb5a, 
       0x3, 0x2, 0x2, 0x2, 0xb54, 0xb55, 0x7, 0x1b0, 0x2, 0x2, 0xb55, 0xb57, 
       0x7, 0x67, 0x2, 0x2, 0xb56, 0xb58, 0x7, 0x1a0, 0x2, 0x2, 0xb57, 0xb56, 
       0x3, 0x2, 0x2, 0x2, 0xb57, 0xb58, 0x3, 0x2, 0x2, 0x2, 0xb58, 0xb59, 
       0x3, 0x2, 0x2, 0x2, 0xb59, 0xb5b, 0x7, 0x1dc, 0x2, 0x2, 0xb5a, 0xb54, 
       0x3, 0x2, 0x2, 0x2, 0xb5a, 0xb5b, 0x3, 0x2, 0x2, 0x2, 0xb5b, 0xb5f, 
       0x3, 0x2, 0x2, 0x2, 0xb5c, 0xb5d, 0x7, 0x203, 0x2, 0x2, 0xb5d, 0xb5e, 
       0x7, 0x29b, 0x2, 0x2, 0xb5e, 0xb60, 0x5, 0x364, 0x1b3, 0x2, 0xb5f, 
       0xb5c, 0x3, 0x2, 0x2, 0x2, 0xb5f, 0xb60, 0x3, 0x2, 0x2, 0x2, 0xb60, 
       0xb66, 0x3, 0x2, 0x2, 0x2, 0xb61, 0xb67, 0x7, 0xb1, 0x2, 0x2, 0xb62, 
       0xb67, 0x7, 0xa0, 0x2, 0x2, 0xb63, 0xb64, 0x7, 0xa0, 0x2, 0x2, 0xb64, 
       0xb65, 0x7, 0x1b0, 0x2, 0x2, 0xb65, 0xb67, 0x7, 0x24c, 0x2, 0x2, 
       0xb66, 0xb61, 0x3, 0x2, 0x2, 0x2, 0xb66, 0xb62, 0x3, 0x2, 0x2, 0x2, 
       0xb66, 0xb63, 0x3, 0x2, 0x2, 0x2, 0xb66, 0xb67, 0x3, 0x2, 0x2, 0x2, 
       0xb67, 0xb6a, 0x3, 0x2, 0x2, 0x2, 0xb68, 0xb69, 0x7, 0x63, 0x2, 0x2, 
       0xb69, 0xb6b, 0x5, 0x32c, 0x197, 0x2, 0xb6a, 0xb68, 0x3, 0x2, 0x2, 
       0x2, 0xb6a, 0xb6b, 0x3, 0x2, 0x2, 0x2, 0xb6b, 0xb6e, 0x3, 0x2, 0x2, 
       0x2, 0xb6c, 0xb6d, 0x7, 0xa6, 0x2, 0x2, 0xb6d, 0xb6f, 0x5, 0x180, 
       0xc1, 0x2, 0xb6e, 0xb6c, 0x3, 0x2, 0x2, 0x2, 0xb6e, 0xb6f, 0x3, 0x2, 
       0x2, 0x2, 0xb6f, 0x105, 0x3, 0x2, 0x2, 0x2, 0xb70, 0xb71, 0x7, 0xa8, 
       0x2, 0x2, 0xb71, 0xb73, 0x7, 0xbf, 0x2, 0x2, 0xb72, 0xb74, 0x5, 0x44c, 
       0x227, 0x2, 0xb73, 0xb72, 0x3, 0x2, 0x2, 0x2, 0xb73, 0xb74, 0x3, 
       0x2, 0x2, 0x2, 0xb74, 0xb75, 0x3, 0x2, 0x2, 0x2, 0xb75, 0xb76, 0x5, 
       0x364, 0x1b3, 0x2, 0xb76, 0x107, 0x3, 0x2, 0x2, 0x2, 0xb77, 0xb79, 
       0x7, 0x78, 0x2, 0x2, 0xb78, 0xb7a, 0x5, 0x17a, 0xbe, 0x2, 0xb79, 
       0xb78, 0x3, 0x2, 0x2, 0x2, 0xb79, 0xb7a, 0x3, 0x2, 0x2, 0x2, 0xb7a, 
       0xb7b, 0x3, 0x2, 0x2, 0x2, 0xb7b, 0xb7c, 0x7, 0xe8, 0x2, 0x2, 0xb7c, 
       0xb7d, 0x5, 0x36a, 0x1b6, 0x2, 0xb7d, 0xb81, 0x7, 0x2fb, 0x2, 0x2, 
       0xb7e, 0xb7f, 0x5, 0x33e, 0x1a0, 0x2, 0xb7f, 0xb80, 0x5, 0x41a, 0x20e, 
       0x2, 0xb80, 0xb82, 0x3, 0x2, 0x2, 0x2, 0xb81, 0xb7e, 0x3, 0x2, 0x2, 
       0x2, 0xb81, 0xb82, 0x3, 0x2, 0x2, 0x2, 0xb82, 0xb89, 0x3, 0x2, 0x2, 
       0x2, 0xb83, 0xb84, 0x7, 0x301, 0x2, 0x2, 0xb84, 0xb85, 0x5, 0x33e, 
       0x1a0, 0x2, 0xb85, 0xb86, 0x5, 0x41a, 0x20e, 0x2, 0xb86, 0xb88, 0x3, 
       0x2, 0x2, 0x2, 0xb87, 0xb83, 0x3, 0x2, 0x2, 0x2, 0xb88, 0xb8b, 0x3, 
       0x2, 0x2, 0x2, 0xb89, 0xb87, 0x3, 0x2, 0x2, 0x2, 0xb89, 0xb8a, 0x3, 
       0x2, 0x2, 0x2, 0xb8a, 0xb8c, 0x3, 0x2, 0x2, 0x2, 0xb8b, 0xb89, 0x3, 
       0x2, 0x2, 0x2, 0xb8c, 0xb8d, 0x7, 0x2fc, 0x2, 0x2, 0xb8d, 0xb8e, 
       0x7, 0x21f, 0x2, 0x2, 0xb8e, 0xb92, 0x5, 0x41a, 0x20e, 0x2, 0xb8f, 
       0xb91, 0x5, 0x184, 0xc3, 0x2, 0xb90, 0xb8f, 0x3, 0x2, 0x2, 0x2, 0xb91, 
       0xb94, 0x3, 0x2, 0x2, 0x2, 0xb92, 0xb90, 0x3, 0x2, 0x2, 0x2, 0xb92, 
       0xb93, 0x3, 0x2, 0x2, 0x2, 0xb93, 0xb95, 0x3, 0x2, 0x2, 0x2, 0xb94, 
       0xb92, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb96, 0x5, 0x180, 0xc1, 0x2, 0xb96, 
       0x109, 0x3, 0x2, 0x2, 0x2, 0xb97, 0xb98, 0x7, 0x26, 0x2, 0x2, 0xb98, 
       0xb99, 0x7, 0xe8, 0x2, 0x2, 0xb99, 0xb9d, 0x5, 0x36a, 0x1b6, 0x2, 
       0xb9a, 0xb9c, 0x5, 0x184, 0xc3, 0x2, 0xb9b, 0xb9a, 0x3, 0x2, 0x2, 
       0x2, 0xb9c, 0xb9f, 0x3, 0x2, 0x2, 0x2, 0xb9d, 0xb9b, 0x3, 0x2, 0x2, 
       0x2, 0xb9d, 0xb9e, 0x3, 0x2, 0x2, 0x2, 0xb9e, 0x10b, 0x3, 0x2, 0x2, 
       0x2, 0xb9f, 0xb9d, 0x3, 0x2, 0x2, 0x2, 0xba0, 0xba1, 0x7, 0xa8, 0x2, 
       0x2, 0xba1, 0xba3, 0x7, 0xe8, 0x2, 0x2, 0xba2, 0xba4, 0x5, 0x44c, 
       0x227, 0x2, 0xba3, 0xba2, 0x3, 0x2, 0x2, 0x2, 0xba3, 0xba4, 0x3, 
       0x2, 0x2, 0x2, 0xba4, 0xba5, 0x3, 0x2, 0x2, 0x2, 0xba5, 0xba6, 0x5, 
       0x36a, 0x1b6, 0x2, 0xba6, 0x10d, 0x3, 0x2, 0x2, 0x2, 0xba7, 0xba9, 
       0x7, 0x78, 0x2, 0x2, 0xba8, 0xbaa, 0x5, 0x17a, 0xbe, 0x2, 0xba9, 
       0xba8, 0x3, 0x2, 0x2, 0x2, 0xba9, 0xbaa, 0x3, 0x2, 0x2, 0x2, 0xbaa, 
       0xbab, 0x3, 0x2, 0x2, 0x2, 0xbab, 0xbac, 0x7, 0x1e1, 0x2, 0x2, 0xbac, 
       0xbad, 0x5, 0x36a, 0x1b6, 0x2, 0xbad, 0xbaf, 0x7, 0x2fb, 0x2, 0x2, 
       0xbae, 0xbb0, 0x5, 0x186, 0xc4, 0x2, 0xbaf, 0xbae, 0x3, 0x2, 0x2, 
       0x2, 0xbaf, 0xbb0, 0x3, 0x2, 0x2, 0x2, 0xbb0, 0xbb5, 0x3, 0x2, 0x2, 
       0x2, 0xbb1, 0xbb2, 0x7, 0x301, 0x2, 0x2, 0xbb2, 0xbb4, 0x5, 0x186, 
       0xc4, 0x2, 0xbb3, 0xbb1, 0x3, 0x2, 0x2, 0x2, 0xbb4, 0xbb7, 0x3, 0x2, 
       0x2, 0x2, 0xbb5, 0xbb3, 0x3, 0x2, 0x2, 0x2, 0xbb5, 0xbb6, 0x3, 0x2, 
       0x2, 0x2, 0xbb6, 0xbb8, 0x3, 0x2, 0x2, 0x2, 0xbb7, 0xbb5, 0x3, 0x2, 
       0x2, 0x2, 0xbb8, 0xbbc, 0x7, 0x2fc, 0x2, 0x2, 0xbb9, 0xbbb, 0x5, 
       0x184, 0xc3, 0x2, 0xbba, 0xbb9, 0x3, 0x2, 0x2, 0x2, 0xbbb, 0xbbe, 
       0x3, 0x2, 0x2, 0x2, 0xbbc, 0xbba, 0x3, 0x2, 0x2, 0x2, 0xbbc, 0xbbd, 
       0x3, 0x2, 0x2, 0x2, 0xbbd, 0xbbf, 0x3, 0x2, 0x2, 0x2, 0xbbe, 0xbbc, 
       0x3, 0x2, 0x2, 0x2, 0xbbf, 0xbc0, 0x5, 0x180, 0xc1, 0x2, 0xbc0, 0x10f, 
       0x3, 0x2, 0x2, 0x2, 0xbc1, 0xbc2, 0x7, 0x26, 0x2, 0x2, 0xbc2, 0xbc3, 
       0x7, 0x1e1, 0x2, 0x2, 0xbc3, 0xbc7, 0x5, 0x36a, 0x1b6, 0x2, 0xbc4, 
       0xbc6, 0x5, 0x184, 0xc3, 0x2, 0xbc5, 0xbc4, 0x3, 0x2, 0x2, 0x2, 0xbc6, 
       0xbc9, 0x3, 0x2, 0x2, 0x2, 0xbc7, 0xbc5, 0x3, 0x2, 0x2, 0x2, 0xbc7, 
       0xbc8, 0x3, 0x2, 0x2, 0x2, 0xbc8, 0x111, 0x3, 0x2, 0x2, 0x2, 0xbc9, 
       0xbc7, 0x3, 0x2, 0x2, 0x2, 0xbca, 0xbcb, 0x7, 0xa8, 0x2, 0x2, 0xbcb, 
       0xbcd, 0x7, 0x1e1, 0x2, 0x2, 0xbcc, 0xbce, 0x5, 0x44c, 0x227, 0x2, 
       0xbcd, 0xbcc, 0x3, 0x2, 0x2, 0x2, 0xbcd, 0xbce, 0x3, 0x2, 0x2, 0x2, 
       0xbce, 0xbcf, 0x3, 0x2, 0x2, 0x2, 0xbcf, 0xbd0, 0x5, 0x36a, 0x1b6, 
       0x2, 0xbd0, 0x113, 0x3, 0x2, 0x2, 0x2, 0xbd1, 0xbd2, 0x7, 0x78, 0x2, 
       0x2, 0xbd2, 0xbd3, 0x7, 0x242, 0x2, 0x2, 0xbd3, 0xbd4, 0x5, 0x366, 
       0x1b4, 0x2, 0xbd4, 0xbd5, 0x7, 0xe2, 0x2, 0x2, 0xbd5, 0xbd6, 0x7, 
       0x83, 0x2, 0x2, 0xbd6, 0xbd7, 0x7, 0x2d4, 0x2, 0x2, 0xbd7, 0xbd8, 
       0x5, 0x368, 0x1b5, 0x2, 0xbd8, 0xbd9, 0x7, 0x1b9, 0x2, 0x2, 0xbd9, 
       0xbda, 0x7, 0x2fb, 0x2, 0x2, 0xbda, 0xbdf, 0x5, 0x182, 0xc2, 0x2, 
       0xbdb, 0xbdc, 0x7, 0x301, 0x2, 0x2, 0xbdc, 0xbde, 0x5, 0x182, 0xc2, 
       0x2, 0xbdd, 0xbdb, 0x3, 0x2, 0x2, 0x2, 0xbde, 0xbe1, 0x3, 0x2, 0x2, 
       0x2, 0xbdf, 0xbdd, 0x3, 0x2, 0x2, 0x2, 0xbdf, 0xbe0, 0x3, 0x2, 0x2, 
       0x2, 0xbe0, 0xbe2, 0x3, 0x2, 0x2, 0x2, 0xbe1, 0xbdf, 0x3, 0x2, 0x2, 
       0x2, 0xbe2, 0xbe3, 0x7, 0x2fc, 0x2, 0x2, 0xbe3, 0x115, 0x3, 0x2, 
       0x2, 0x2, 0xbe4, 0xbe5, 0x7, 0x26, 0x2, 0x2, 0xbe5, 0xbe6, 0x7, 0x242, 
       0x2, 0x2, 0xbe6, 0xbe7, 0x5, 0x366, 0x1b4, 0x2, 0xbe7, 0xbe8, 0x7, 
       0x1b9, 0x2, 0x2, 0xbe8, 0xbe9, 0x7, 0x2fb, 0x2, 0x2, 0xbe9, 0xbee, 
       0x5, 0x182, 0xc2, 0x2, 0xbea, 0xbeb, 0x7, 0x301, 0x2, 0x2, 0xbeb, 
       0xbed, 0x5, 0x182, 0xc2, 0x2, 0xbec, 0xbea, 0x3, 0x2, 0x2, 0x2, 0xbed, 
       0xbf0, 0x3, 0x2, 0x2, 0x2, 0xbee, 0xbec, 0x3, 0x2, 0x2, 0x2, 0xbee, 
       0xbef, 0x3, 0x2, 0x2, 0x2, 0xbef, 0xbf1, 0x3, 0x2, 0x2, 0x2, 0xbf0, 
       0xbee, 0x3, 0x2, 0x2, 0x2, 0xbf1, 0xbf2, 0x7, 0x2fc, 0x2, 0x2, 0xbf2, 
       0x117, 0x3, 0x2, 0x2, 0x2, 0xbf3, 0xbf4, 0x7, 0xa8, 0x2, 0x2, 0xbf4, 
       0xbf6, 0x7, 0x242, 0x2, 0x2, 0xbf5, 0xbf7, 0x5, 0x44c, 0x227, 0x2, 
       0xbf6, 0xbf5, 0x3, 0x2, 0x2, 0x2, 0xbf6, 0xbf7, 0x3, 0x2, 0x2, 0x2, 
       0xbf7, 0xbf8, 0x3, 0x2, 0x2, 0x2, 0xbf8, 0xbf9, 0x5, 0x366, 0x1b4, 
       0x2, 0xbf9, 0x119, 0x3, 0x2, 0x2, 0x2, 0xbfa, 0xbfd, 0x7, 0x78, 0x2, 
       0x2, 0xbfb, 0xbfc, 0x7, 0x1ba, 0x2, 0x2, 0xbfc, 0xbfe, 0x7, 0x208, 
       0x2, 0x2, 0xbfd, 0xbfb, 0x3, 0x2, 0x2, 0x2, 0xbfd, 0xbfe, 0x3, 0x2, 
       0x2, 0x2, 0xbfe, 0xc02, 0x3, 0x2, 0x2, 0x2, 0xbff, 0xc00, 0x7, 0x24, 
       0x2, 0x2, 0xc00, 0xc01, 0x7, 0x2f4, 0x2, 0x2, 0xc01, 0xc03, 0x9, 
       0x1d, 0x2, 0x2, 0xc02, 0xbff, 0x3, 0x2, 0x2, 0x2, 0xc02, 0xc03, 0x3, 
       0x2, 0x2, 0x2, 0xc03, 0xc05, 0x3, 0x2, 0x2, 0x2, 0xc04, 0xc06, 0x5, 
       0x17a, 0xbe, 0x2, 0xc05, 0xc04, 0x3, 0x2, 0x2, 0x2, 0xc05, 0xc06, 
       0x3, 0x2, 0x2, 0x2, 0xc06, 0xc0a, 0x3, 0x2, 0x2, 0x2, 0xc07, 0xc08, 
       0x7, 0x257, 0x2, 0x2, 0xc08, 0xc09, 0x7, 0x23c, 0x2, 0x2, 0xc09, 
       0xc0b, 0x9, 0x1e, 0x2, 0x2, 0xc0a, 0xc07, 0x3, 0x2, 0x2, 0x2, 0xc0a, 
       0xc0b, 0x3, 0x2, 0x2, 0x2, 0xc0b, 0xc0c, 0x3, 0x2, 0x2, 0x2, 0xc0c, 
       0xc0d, 0x7, 0x2c6, 0x2, 0x2, 0xc0d, 0xc12, 0x5, 0x36c, 0x1b7, 0x2, 
       0xc0e, 0xc0f, 0x7, 0x2fb, 0x2, 0x2, 0xc0f, 0xc10, 0x5, 0x378, 0x1bd, 
       0x2, 0xc10, 0xc11, 0x7, 0x2fc, 0x2, 0x2, 0xc11, 0xc13, 0x3, 0x2, 
       0x2, 0x2, 0xc12, 0xc0e, 0x3, 0x2, 0x2, 0x2, 0xc12, 0xc13, 0x3, 0x2, 
       0x2, 0x2, 0xc13, 0xc14, 0x3, 0x2, 0x2, 0x2, 0xc14, 0xc15, 0x7, 0x2c, 
       0x2, 0x2, 0xc15, 0xc1c, 0x5, 0x36, 0x1c, 0x2, 0xc16, 0xc18, 0x7, 
       0x2d1, 0x2, 0x2, 0xc17, 0xc19, 0x9, 0x1f, 0x2, 0x2, 0xc18, 0xc17, 
       0x3, 0x2, 0x2, 0x2, 0xc18, 0xc19, 0x3, 0x2, 0x2, 0x2, 0xc19, 0xc1a, 
       0x3, 0x2, 0x2, 0x2, 0xc1a, 0xc1b, 0x7, 0x54, 0x2, 0x2, 0xc1b, 0xc1d, 
       0x7, 0x1b6, 0x2, 0x2, 0xc1c, 0xc16, 0x3, 0x2, 0x2, 0x2, 0xc1c, 0xc1d, 
       0x3, 0x2, 0x2, 0x2, 0xc1d, 0x11b, 0x3, 0x2, 0x2, 0x2, 0xc1e, 0xc22, 
       0x7, 0x26, 0x2, 0x2, 0xc1f, 0xc20, 0x7, 0x24, 0x2, 0x2, 0xc20, 0xc21, 
       0x7, 0x2f4, 0x2, 0x2, 0xc21, 0xc23, 0x9, 0x1d, 0x2, 0x2, 0xc22, 0xc1f, 
       0x3, 0x2, 0x2, 0x2, 0xc22, 0xc23, 0x3, 0x2, 0x2, 0x2, 0xc23, 0xc25, 
       0x3, 0x2, 0x2, 0x2, 0xc24, 0xc26, 0x5, 0x17a, 0xbe, 0x2, 0xc25, 0xc24, 
       0x3, 0x2, 0x2, 0x2, 0xc25, 0xc26, 0x3, 0x2, 0x2, 0x2, 0xc26, 0xc2a, 
       0x3, 0x2, 0x2, 0x2, 0xc27, 0xc28, 0x7, 0x257, 0x2, 0x2, 0xc28, 0xc29, 
       0x7, 0x23c, 0x2, 0x2, 0xc29, 0xc2b, 0x9, 0x1e, 0x2, 0x2, 0xc2a, 0xc27, 
       0x3, 0x2, 0x2, 0x2, 0xc2a, 0xc2b, 0x3, 0x2, 0x2, 0x2, 0xc2b, 0xc2c, 
       0x3, 0x2, 0x2, 0x2, 0xc2c, 0xc2d, 0x7, 0x2c6, 0x2, 0x2, 0xc2d, 0xc32, 
       0x5, 0x36c, 0x1b7, 0x2, 0xc2e, 0xc2f, 0x7, 0x2fb, 0x2, 0x2, 0xc2f, 
       0xc30, 0x5, 0x378, 0x1bd, 0x2, 0xc30, 0xc31, 0x7, 0x2fc, 0x2, 0x2, 
       0xc31, 0xc33, 0x3, 0x2, 0x2, 0x2, 0xc32, 0xc2e, 0x3, 0x2, 0x2, 0x2, 
       0xc32, 0xc33, 0x3, 0x2, 0x2, 0x2, 0xc33, 0xc34, 0x3, 0x2, 0x2, 0x2, 
       0xc34, 0xc35, 0x7, 0x2c, 0x2, 0x2, 0xc35, 0xc3c, 0x5, 0x36, 0x1c, 
       0x2, 0xc36, 0xc38, 0x7, 0x2d1, 0x2, 0x2, 0xc37, 0xc39, 0x9, 0x1f, 
       0x2, 0x2, 0xc38, 0xc37, 0x3, 0x2, 0x2, 0x2, 0xc38, 0xc39, 0x3, 0x2, 
       0x2, 0x2, 0xc39, 0xc3a, 0x3, 0x2, 0x2, 0x2, 0xc3a, 0xc3b, 0x7, 0x54, 
       0x2, 0x2, 0xc3b, 0xc3d, 0x7, 0x1b6, 0x2, 0x2, 0xc3c, 0xc36, 0x3, 
       0x2, 0x2, 0x2, 0xc3c, 0xc3d, 0x3, 0x2, 0x2, 0x2, 0xc3d, 0x11d, 0x3, 
       0x2, 0x2, 0x2, 0xc3e, 0xc3f, 0x7, 0xa8, 0x2, 0x2, 0xc3f, 0xc41, 0x7, 
       0x2c6, 0x2, 0x2, 0xc40, 0xc42, 0x5, 0x44c, 0x227, 0x2, 0xc41, 0xc40, 
       0x3, 0x2, 0x2, 0x2, 0xc41, 0xc42, 0x3, 0x2, 0x2, 0x2, 0xc42, 0xc43, 
       0x3, 0x2, 0x2, 0x2, 0xc43, 0xc45, 0x5, 0x376, 0x1bc, 0x2, 0xc44, 
       0xc46, 0x5, 0xe2, 0x72, 0x2, 0xc45, 0xc44, 0x3, 0x2, 0x2, 0x2, 0xc45, 
       0xc46, 0x3, 0x2, 0x2, 0x2, 0xc46, 0x11f, 0x3, 0x2, 0x2, 0x2, 0xc47, 
       0xc49, 0x7, 0x78, 0x2, 0x2, 0xc48, 0xc4a, 0x7, 0x2a7, 0x2, 0x2, 0xc49, 
       0xc48, 0x3, 0x2, 0x2, 0x2, 0xc49, 0xc4a, 0x3, 0x2, 0x2, 0x2, 0xc4a, 
       0xc4b, 0x3, 0x2, 0x2, 0x2, 0xc4b, 0xc4c, 0x7, 0x288, 0x2, 0x2, 0xc4c, 
       0xc4d, 0x5, 0x33e, 0x1a0, 0x2, 0xc4d, 0xc4e, 0x7, 0x1f, 0x2, 0x2, 
       0xc4e, 0xc4f, 0x7, 0x86, 0x2, 0x2, 0xc4f, 0xc53, 0x5, 0x32c, 0x197, 
       0x2, 0xc50, 0xc51, 0x7, 0xd5, 0x2, 0x2, 0xc51, 0xc52, 0x7, 0x2f4, 
       0x2, 0x2, 0xc52, 0xc54, 0x5, 0x188, 0xc5, 0x2, 0xc53, 0xc50, 0x3, 
       0x2, 0x2, 0x2, 0xc53, 0xc54, 0x3, 0x2, 0x2, 0x2, 0xc54, 0xc58, 0x3, 
       0x2, 0x2, 0x2, 0xc55, 0xc56, 0x7, 0xb3, 0x2, 0x2, 0xc56, 0xc57, 0x7, 
       0x2f4, 0x2, 0x2, 0xc57, 0xc59, 0x5, 0x32c, 0x197, 0x2, 0xc58, 0xc55, 
       0x3, 0x2, 0x2, 0x2, 0xc58, 0xc59, 0x3, 0x2, 0x2, 0x2, 0xc59, 0xc5f, 
       0x3, 0x2, 0x2, 0x2, 0xc5a, 0xc5c, 0x7, 0xb7, 0x2, 0x2, 0xc5b, 0xc5d, 
       0x7, 0x2f4, 0x2, 0x2, 0xc5c, 0xc5b, 0x3, 0x2, 0x2, 0x2, 0xc5c, 0xc5d, 
       0x3, 0x2, 0x2, 0x2, 0xc5d, 0xc5e, 0x3, 0x2, 0x2, 0x2, 0xc5e, 0xc60, 
       0x5, 0x32c, 0x197, 0x2, 0xc5f, 0xc5a, 0x3, 0x2, 0x2, 0x2, 0xc5f, 
       0xc60, 0x3, 0x2, 0x2, 0x2, 0xc60, 0x121, 0x3, 0x2, 0x2, 0x2, 0xc61, 
       0xc63, 0x7, 0x78, 0x2, 0x2, 0xc62, 0xc64, 0x7, 0x2a7, 0x2, 0x2, 0xc63, 
       0xc62, 0x3, 0x2, 0x2, 0x2, 0xc63, 0xc64, 0x3, 0x2, 0x2, 0x2, 0xc64, 
       0xc65, 0x3, 0x2, 0x2, 0x2, 0xc65, 0xc66, 0x7, 0x288, 0x2, 0x2, 0xc66, 
       0xc67, 0x5, 0x33e, 0x1a0, 0x2, 0xc67, 0xc68, 0x7, 0x1f, 0x2, 0x2, 
       0xc68, 0xc69, 0x7, 0x86, 0x2, 0x2, 0xc69, 0xc6a, 0x5, 0x32c, 0x197, 
       0x2, 0xc6a, 0xc6b, 0x7, 0x2b5, 0x2, 0x2, 0xc6b, 0xc6c, 0x7, 0x14c, 
       0x2, 0x2, 0xc6c, 0xc6d, 0x7, 0xf4, 0x2, 0x2, 0xc6d, 0xc73, 0x5, 0x33e, 
       0x1a0, 0x2, 0xc6e, 0xc70, 0x7, 0xcd, 0x2, 0x2, 0xc6f, 0xc71, 0x7, 
       0x2f4, 0x2, 0x2, 0xc70, 0xc6f, 0x3, 0x2, 0x2, 0x2, 0xc70, 0xc71, 
       0x3, 0x2, 0x2, 0x2, 0xc71, 0xc72, 0x3, 0x2, 0x2, 0x2, 0xc72, 0xc74, 
       0x5, 0x188, 0xc5, 0x2, 0xc73, 0xc6e, 0x3, 0x2, 0x2, 0x2, 0xc73, 0xc74, 
       0x3, 0x2, 0x2, 0x2, 0xc74, 0xc7a, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xc77, 
       0x7, 0x10f, 0x2, 0x2, 0xc76, 0xc78, 0x7, 0x2f4, 0x2, 0x2, 0xc77, 
       0xc76, 0x3, 0x2, 0x2, 0x2, 0xc77, 0xc78, 0x3, 0x2, 0x2, 0x2, 0xc78, 
       0xc79, 0x3, 0x2, 0x2, 0x2, 0xc79, 0xc7b, 0x5, 0x188, 0xc5, 0x2, 0xc7a, 
       0xc75, 0x3, 0x2, 0x2, 0x2, 0xc7a, 0xc7b, 0x3, 0x2, 0x2, 0x2, 0xc7b, 
       0xc81, 0x3, 0x2, 0x2, 0x2, 0xc7c, 0xc7e, 0x7, 0x32, 0x2, 0x2, 0xc7d, 
       0xc7f, 0x7, 0x2f4, 0x2, 0x2, 0xc7e, 0xc7d, 0x3, 0x2, 0x2, 0x2, 0xc7e, 
       0xc7f, 0x3, 0x2, 0x2, 0x2, 0xc7f, 0xc80, 0x3, 0x2, 0x2, 0x2, 0xc80, 
       0xc82, 0x5, 0x188, 0xc5, 0x2, 0xc81, 0xc7c, 0x3, 0x2, 0x2, 0x2, 0xc81, 
       0xc82, 0x3, 0x2, 0x2, 0x2, 0xc82, 0xc88, 0x3, 0x2, 0x2, 0x2, 0xc83, 
       0xc85, 0x7, 0x175, 0x2, 0x2, 0xc84, 0xc86, 0x7, 0x2f4, 0x2, 0x2, 
       0xc85, 0xc84, 0x3, 0x2, 0x2, 0x2, 0xc85, 0xc86, 0x3, 0x2, 0x2, 0x2, 
       0xc86, 0xc87, 0x3, 0x2, 0x2, 0x2, 0xc87, 0xc89, 0x5, 0x188, 0xc5, 
       0x2, 0xc88, 0xc83, 0x3, 0x2, 0x2, 0x2, 0xc88, 0xc89, 0x3, 0x2, 0x2, 
       0x2, 0xc89, 0xc8f, 0x3, 0x2, 0x2, 0x2, 0xc8a, 0xc8c, 0x7, 0x19e, 
       0x2, 0x2, 0xc8b, 0xc8d, 0x7, 0x2f4, 0x2, 0x2, 0xc8c, 0xc8b, 0x3, 
       0x2, 0x2, 0x2, 0xc8c, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0xc8d, 0xc8e, 0x3, 
       0x2, 0x2, 0x2, 0xc8e, 0xc90, 0x5, 0x33e, 0x1a0, 0x2, 0xc8f, 0xc8a, 
       0x3, 0x2, 0x2, 0x2, 0xc8f, 0xc90, 0x3, 0x2, 0x2, 0x2, 0xc90, 0xc92, 
       0x3, 0x2, 0x2, 0x2, 0xc91, 0xc93, 0x7, 0x2c9, 0x2, 0x2, 0xc92, 0xc91, 
       0x3, 0x2, 0x2, 0x2, 0xc92, 0xc93, 0x3, 0x2, 0x2, 0x2, 0xc93, 0xc99, 
       0x3, 0x2, 0x2, 0x2, 0xc94, 0xc96, 0x7, 0x63, 0x2, 0x2, 0xc95, 0xc97, 
       0x7, 0x2f4, 0x2, 0x2, 0xc96, 0xc95, 0x3, 0x2, 0x2, 0x2, 0xc96, 0xc97, 
       0x3, 0x2, 0x2, 0x2, 0xc97, 0xc98, 0x3, 0x2, 0x2, 0x2, 0xc98, 0xc9a, 
       0x5, 0x32c, 0x197, 0x2, 0xc99, 0xc94, 0x3, 0x2, 0x2, 0x2, 0xc99, 
       0xc9a, 0x3, 0x2, 0x2, 0x2, 0xc9a, 0xca0, 0x3, 0x2, 0x2, 0x2, 0xc9b, 
       0xc9d, 0x7, 0xb7, 0x2, 0x2, 0xc9c, 0xc9e, 0x7, 0x2f4, 0x2, 0x2, 0xc9d, 
       0xc9c, 0x3, 0x2, 0x2, 0x2, 0xc9d, 0xc9e, 0x3, 0x2, 0x2, 0x2, 0xc9e, 
       0xc9f, 0x3, 0x2, 0x2, 0x2, 0xc9f, 0xca1, 0x5, 0x33e, 0x1a0, 0x2, 
       0xca0, 0xc9b, 0x3, 0x2, 0x2, 0x2, 0xca0, 0xca1, 0x3, 0x2, 0x2, 0x2, 
       0xca1, 0x123, 0x3, 0x2, 0x2, 0x2, 0xca2, 0xca4, 0x7, 0x26, 0x2, 0x2, 
       0xca3, 0xca5, 0x7, 0x2a7, 0x2, 0x2, 0xca4, 0xca3, 0x3, 0x2, 0x2, 
       0x2, 0xca4, 0xca5, 0x3, 0x2, 0x2, 0x2, 0xca5, 0xca6, 0x3, 0x2, 0x2, 
       0x2, 0xca6, 0xca7, 0x7, 0x288, 0x2, 0x2, 0xca7, 0xca8, 0x5, 0x33e, 
       0x1a0, 0x2, 0xca8, 0xca9, 0x9, 0x20, 0x2, 0x2, 0xca9, 0xcaa, 0x7, 
       0x86, 0x2, 0x2, 0xcaa, 0xcae, 0x5, 0x32c, 0x197, 0x2, 0xcab, 0xcac, 
       0x7, 0x10f, 0x2, 0x2, 0xcac, 0xcad, 0x7, 0x2f4, 0x2, 0x2, 0xcad, 
       0xcaf, 0x5, 0x188, 0xc5, 0x2, 0xcae, 0xcab, 0x3, 0x2, 0x2, 0x2, 0xcae, 
       0xcaf, 0x3, 0x2, 0x2, 0x2, 0xcaf, 0xcb1, 0x3, 0x2, 0x2, 0x2, 0xcb0, 
       0xcb2, 0x7, 0x2c9, 0x2, 0x2, 0xcb1, 0xcb0, 0x3, 0x2, 0x2, 0x2, 0xcb1, 
       0xcb2, 0x3, 0x2, 0x2, 0x2, 0xcb2, 0xcb6, 0x3, 0x2, 0x2, 0x2, 0xcb3, 
       0xcb4, 0x7, 0x203, 0x2, 0x2, 0xcb4, 0xcb5, 0x7, 0x29b, 0x2, 0x2, 
       0xcb5, 0xcb7, 0x5, 0x33e, 0x1a0, 0x2, 0xcb6, 0xcb3, 0x3, 0x2, 0x2, 
       0x2, 0xcb6, 0xcb7, 0x3, 0x2, 0x2, 0x2, 0xcb7, 0xcbd, 0x3, 0x2, 0x2, 
       0x2, 0xcb8, 0xcba, 0x7, 0xb7, 0x2, 0x2, 0xcb9, 0xcbb, 0x7, 0x2f4, 
       0x2, 0x2, 0xcba, 0xcb9, 0x3, 0x2, 0x2, 0x2, 0xcba, 0xcbb, 0x3, 0x2, 
       0x2, 0x2, 0xcbb, 0xcbc, 0x3, 0x2, 0x2, 0x2, 0xcbc, 0xcbe, 0x5, 0x33e, 
       0x1a0, 0x2, 0xcbd, 0xcb8, 0x3, 0x2, 0x2, 0x2, 0xcbd, 0xcbe, 0x3, 
       0x2, 0x2, 0x2, 0xcbe, 0x125, 0x3, 0x2, 0x2, 0x2, 0xcbf, 0xcc1, 0x7, 
       0x26, 0x2, 0x2, 0xcc0, 0xcc2, 0x7, 0x2a7, 0x2, 0x2, 0xcc1, 0xcc0, 
       0x3, 0x2, 0x2, 0x2, 0xcc1, 0xcc2, 0x3, 0x2, 0x2, 0x2, 0xcc2, 0xcc3, 
       0x3, 0x2, 0x2, 0x2, 0xcc3, 0xcc4, 0x7, 0x288, 0x2, 0x2, 0xcc4, 0xcc7, 
       0x5, 0x33e, 0x1a0, 0x2, 0xcc5, 0xcc6, 0x7, 0x244, 0x2, 0x2, 0xcc6, 
       0xcc8, 0x9, 0x21, 0x2, 0x2, 0xcc7, 0xcc5, 0x3, 0x2, 0x2, 0x2, 0xcc7, 
       0xcc8, 0x3, 0x2, 0x2, 0x2, 0xcc8, 0xcc9, 0x3, 0x2, 0x2, 0x2, 0xcc9, 
       0xccb, 0x7, 0xb3, 0x2, 0x2, 0xcca, 0xccc, 0x7, 0x2f4, 0x2, 0x2, 0xccb, 
       0xcca, 0x3, 0x2, 0x2, 0x2, 0xccb, 0xccc, 0x3, 0x2, 0x2, 0x2, 0xccc, 
       0xccd, 0x3, 0x2, 0x2, 0x2, 0xccd, 0xcce, 0x5, 0x32c, 0x197, 0x2, 
       0xcce, 0xcd2, 0x3, 0x2, 0x2, 0x2, 0xccf, 0xcd0, 0x7, 0x203, 0x2, 
       0x2, 0xcd0, 0xcd1, 0x7, 0x29b, 0x2, 0x2, 0xcd1, 0xcd3, 0x5, 0x33e, 
       0x1a0, 0x2, 0xcd2, 0xccf, 0x3, 0x2, 0x2, 0x2, 0xcd2, 0xcd3, 0x3, 
       0x2, 0x2, 0x2, 0xcd3, 0xcd9, 0x3, 0x2, 0x2, 0x2, 0xcd4, 0xcd6, 0x7, 
       0xb7, 0x2, 0x2, 0xcd5, 0xcd7, 0x7, 0x2f4, 0x2, 0x2, 0xcd6, 0xcd5, 
       0x3, 0x2, 0x2, 0x2, 0xcd6, 0xcd7, 0x3, 0x2, 0x2, 0x2, 0xcd7, 0xcd8, 
       0x3, 0x2, 0x2, 0x2, 0xcd8, 0xcda, 0x5, 0x33e, 0x1a0, 0x2, 0xcd9, 
       0xcd4, 0x3, 0x2, 0x2, 0x2, 0xcd9, 0xcda, 0x3, 0x2, 0x2, 0x2, 0xcda, 
       0x127, 0x3, 0x2, 0x2, 0x2, 0xcdb, 0xcdd, 0x7, 0xa8, 0x2, 0x2, 0xcdc, 
       0xcde, 0x7, 0x2a7, 0x2, 0x2, 0xcdd, 0xcdc, 0x3, 0x2, 0x2, 0x2, 0xcdd, 
       0xcde, 0x3, 0x2, 0x2, 0x2, 0xcde, 0xcdf, 0x3, 0x2, 0x2, 0x2, 0xcdf, 
       0xce0, 0x7, 0x288, 0x2, 0x2, 0xce0, 0xce6, 0x5, 0x33e, 0x1a0, 0x2, 
       0xce1, 0xce3, 0x7, 0xb7, 0x2, 0x2, 0xce2, 0xce4, 0x7, 0x2f4, 0x2, 
       0x2, 0xce3, 0xce2, 0x3, 0x2, 0x2, 0x2, 0xce3, 0xce4, 0x3, 0x2, 0x2, 
       0x2, 0xce4, 0xce5, 0x3, 0x2, 0x2, 0x2, 0xce5, 0xce7, 0x5, 0x33e, 
       0x1a0, 0x2, 0xce6, 0xce1, 0x3, 0x2, 0x2, 0x2, 0xce6, 0xce7, 0x3, 
       0x2, 0x2, 0x2, 0xce7, 0x129, 0x3, 0x2, 0x2, 0x2, 0xce8, 0xce9, 0x7, 
       0x78, 0x2, 0x2, 0xce9, 0xcea, 0x7, 0x14c, 0x2, 0x2, 0xcea, 0xceb, 
       0x7, 0xf4, 0x2, 0x2, 0xceb, 0xcec, 0x5, 0x33e, 0x1a0, 0x2, 0xcec, 
       0xced, 0x7, 0x1f, 0x2, 0x2, 0xced, 0xcee, 0x7, 0x2a8, 0x2, 0x2, 0xcee, 
       0xcf4, 0x5, 0x32c, 0x197, 0x2, 0xcef, 0xcf1, 0x7, 0x10f, 0x2, 0x2, 
       0xcf0, 0xcf2, 0x7, 0x2f4, 0x2, 0x2, 0xcf1, 0xcf0, 0x3, 0x2, 0x2, 
       0x2, 0xcf1, 0xcf2, 0x3, 0x2, 0x2, 0x2, 0xcf2, 0xcf3, 0x3, 0x2, 0x2, 
       0x2, 0xcf3, 0xcf5, 0x5, 0x188, 0xc5, 0x2, 0xcf4, 0xcef, 0x3, 0x2, 
       0x2, 0x2, 0xcf4, 0xcf5, 0x3, 0x2, 0x2, 0x2, 0xcf5, 0xcfb, 0x3, 0x2, 
       0x2, 0x2, 0xcf6, 0xcf8, 0x7, 0x2a9, 0x2, 0x2, 0xcf7, 0xcf9, 0x7, 
       0x2f4, 0x2, 0x2, 0xcf8, 0xcf7, 0x3, 0x2, 0x2, 0x2, 0xcf8, 0xcf9, 
       0x3, 0x2, 0x2, 0x2, 0xcf9, 0xcfa, 0x3, 0x2, 0x2, 0x2, 0xcfa, 0xcfc, 
       0x5, 0x188, 0xc5, 0x2, 0xcfb, 0xcf6, 0x3, 0x2, 0x2, 0x2, 0xcfb, 0xcfc, 
       0x3, 0x2, 0x2, 0x2, 0xcfc, 0xd02, 0x3, 0x2, 0x2, 0x2, 0xcfd, 0xcff, 
       0x7, 0x1f6, 0x2, 0x2, 0xcfe, 0xd00, 0x7, 0x2f4, 0x2, 0x2, 0xcff, 
       0xcfe, 0x3, 0x2, 0x2, 0x2, 0xcff, 0xd00, 0x3, 0x2, 0x2, 0x2, 0xd00, 
       0xd01, 0x3, 0x2, 0x2, 0x2, 0xd01, 0xd03, 0x5, 0x188, 0xc5, 0x2, 0xd02, 
       0xcfd, 0x3, 0x2, 0x2, 0x2, 0xd02, 0xd03, 0x3, 0x2, 0x2, 0x2, 0xd03, 
       0xd09, 0x3, 0x2, 0x2, 0x2, 0xd04, 0xd06, 0x7, 0x19e, 0x2, 0x2, 0xd05, 
       0xd07, 0x7, 0x2f4, 0x2, 0x2, 0xd06, 0xd05, 0x3, 0x2, 0x2, 0x2, 0xd06, 
       0xd07, 0x3, 0x2, 0x2, 0x2, 0xd07, 0xd08, 0x3, 0x2, 0x2, 0x2, 0xd08, 
       0xd0a, 0x5, 0x33e, 0x1a0, 0x2, 0xd09, 0xd04, 0x3, 0x2, 0x2, 0x2, 
       0xd09, 0xd0a, 0x3, 0x2, 0x2, 0x2, 0xd0a, 0xd0c, 0x3, 0x2, 0x2, 0x2, 
       0xd0b, 0xd0d, 0x7, 0x2c9, 0x2, 0x2, 0xd0c, 0xd0b, 0x3, 0x2, 0x2, 
       0x2, 0xd0c, 0xd0d, 0x3, 0x2, 0x2, 0x2, 0xd0d, 0xd13, 0x3, 0x2, 0x2, 
       0x2, 0xd0e, 0xd10, 0x7, 0x63, 0x2, 0x2, 0xd0f, 0xd11, 0x7, 0x2f4, 
       0x2, 0x2, 0xd10, 0xd0f, 0x3, 0x2, 0x2, 0x2, 0xd10, 0xd11, 0x3, 0x2, 
       0x2, 0x2, 0xd11, 0xd12, 0x3, 0x2, 0x2, 0x2, 0xd12, 0xd14, 0x5, 0x32c, 
       0x197, 0x2, 0xd13, 0xd0e, 0x3, 0x2, 0x2, 0x2, 0xd13, 0xd14, 0x3, 
       0x2, 0x2, 0x2, 0xd14, 0xd1a, 0x3, 0x2, 0x2, 0x2, 0xd15, 0xd17, 0x7, 
       0xb7, 0x2, 0x2, 0xd16, 0xd18, 0x7, 0x2f4, 0x2, 0x2, 0xd17, 0xd16, 
       0x3, 0x2, 0x2, 0x2, 0xd17, 0xd18, 0x3, 0x2, 0x2, 0x2, 0xd18, 0xd19, 
       0x3, 0x2, 0x2, 0x2, 0xd19, 0xd1b, 0x5, 0x33e, 0x1a0, 0x2, 0xd1a, 
       0xd15, 0x3, 0x2, 0x2, 0x2, 0xd1a, 0xd1b, 0x3, 0x2, 0x2, 0x2, 0xd1b, 
       0x12b, 0x3, 0x2, 0x2, 0x2, 0xd1c, 0xd1d, 0x7, 0x26, 0x2, 0x2, 0xd1d, 
       0xd1e, 0x7, 0x14c, 0x2, 0x2, 0xd1e, 0xd1f, 0x7, 0xf4, 0x2, 0x2, 0xd1f, 
       0xd20, 0x5, 0x33e, 0x1a0, 0x2, 0xd20, 0xd21, 0x7, 0x1f, 0x2, 0x2, 
       0xd21, 0xd22, 0x7, 0x2a8, 0x2, 0x2, 0xd22, 0xd28, 0x5, 0x32c, 0x197, 
       0x2, 0xd23, 0xd25, 0x7, 0x10f, 0x2, 0x2, 0xd24, 0xd26, 0x7, 0x2f4, 
       0x2, 0x2, 0xd25, 0xd24, 0x3, 0x2, 0x2, 0x2, 0xd25, 0xd26, 0x3, 0x2, 
       0x2, 0x2, 0xd26, 0xd27, 0x3, 0x2, 0x2, 0x2, 0xd27, 0xd29, 0x5, 0x188, 
       0xc5, 0x2, 0xd28, 0xd23, 0x3, 0x2, 0x2, 0x2, 0xd28, 0xd29, 0x3, 0x2, 
       0x2, 0x2, 0xd29, 0xd2b, 0x3, 0x2, 0x2, 0x2, 0xd2a, 0xd2c, 0x7, 0x2c9, 
       0x2, 0x2, 0xd2b, 0xd2a, 0x3, 0x2, 0x2, 0x2, 0xd2b, 0xd2c, 0x3, 0x2, 
       0x2, 0x2, 0xd2c, 0xd32, 0x3, 0x2, 0x2, 0x2, 0xd2d, 0xd2f, 0x7, 0xb7, 
       0x2, 0x2, 0xd2e, 0xd30, 0x7, 0x2f4, 0x2, 0x2, 0xd2f, 0xd2e, 0x3, 
       0x2, 0x2, 0x2, 0xd2f, 0xd30, 0x3, 0x2, 0x2, 0x2, 0xd30, 0xd31, 0x3, 
       0x2, 0x2, 0x2, 0xd31, 0xd33, 0x5, 0x33e, 0x1a0, 0x2, 0xd32, 0xd2d, 
       0x3, 0x2, 0x2, 0x2, 0xd32, 0xd33, 0x3, 0x2, 0x2, 0x2, 0xd33, 0x12d, 
       0x3, 0x2, 0x2, 0x2, 0xd34, 0xd35, 0x7, 0xa8, 0x2, 0x2, 0xd35, 0xd36, 
       0x7, 0x14c, 0x2, 0x2, 0xd36, 0xd37, 0x7, 0xf4, 0x2, 0x2, 0xd37, 0xd3d, 
       0x5, 0x33e, 0x1a0, 0x2, 0xd38, 0xd3a, 0x7, 0xb7, 0x2, 0x2, 0xd39, 
       0xd3b, 0x7, 0x2f4, 0x2, 0x2, 0xd3a, 0xd39, 0x3, 0x2, 0x2, 0x2, 0xd3a, 
       0xd3b, 0x3, 0x2, 0x2, 0x2, 0xd3b, 0xd3c, 0x3, 0x2, 0x2, 0x2, 0xd3c, 
       0xd3e, 0x5, 0x33e, 0x1a0, 0x2, 0xd3d, 0xd38, 0x3, 0x2, 0x2, 0x2, 
       0xd3d, 0xd3e, 0x3, 0x2, 0x2, 0x2, 0xd3e, 0x12f, 0x3, 0x2, 0x2, 0x2, 
       0xd3f, 0xd41, 0x7, 0x78, 0x2, 0x2, 0xd40, 0xd42, 0x5, 0x17a, 0xbe, 
       0x2, 0xd41, 0xd40, 0x3, 0x2, 0x2, 0x2, 0xd41, 0xd42, 0x3, 0x2, 0x2, 
       0x2, 0xd42, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd43, 0xd44, 0x7, 0x29e, 
       0x2, 0x2, 0xd44, 0xd45, 0x5, 0x394, 0x1cb, 0x2, 0xd45, 0xd46, 0x5, 
       0x396, 0x1cc, 0x2, 0xd46, 0xd47, 0x5, 0x3a2, 0x1d2, 0x2, 0xd47, 0xd48, 
       0x7, 0x1b0, 0x2, 0x2, 0xd48, 0xd49, 0x5, 0x35a, 0x1ae, 0x2, 0xd49, 
       0xd4a, 0x7, 0xe0, 0x2, 0x2, 0xd4a, 0xd4b, 0x7, 0xad, 0x2, 0x2, 0xd4b, 
       0xd4d, 0x7, 0x22a, 0x2, 0x2, 0xd4c, 0xd4e, 0x5, 0x3a4, 0x1d3, 0x2, 
       0xd4d, 0xd4c, 0x3, 0x2, 0x2, 0x2, 0xd4d, 0xd4e, 0x3, 0x2, 0x2, 0x2, 
       0xd4e, 0xd4f, 0x3, 0x2, 0x2, 0x2, 0xd4f, 0xd50, 0x5, 0x180, 0xc1, 
       0x2, 0xd50, 0x131, 0x3, 0x2, 0x2, 0x2, 0xd51, 0xd52, 0x7, 0xa8, 0x2, 
       0x2, 0xd52, 0xd54, 0x7, 0x29e, 0x2, 0x2, 0xd53, 0xd55, 0x5, 0x44c, 
       0x227, 0x2, 0xd54, 0xd53, 0x3, 0x2, 0x2, 0x2, 0xd54, 0xd55, 0x3, 
       0x2, 0x2, 0x2, 0xd55, 0xd59, 0x3, 0x2, 0x2, 0x2, 0xd56, 0xd57, 0x5, 
       0x350, 0x1a9, 0x2, 0xd57, 0xd58, 0x7, 0x2f0, 0x2, 0x2, 0xd58, 0xd5a, 
       0x3, 0x2, 0x2, 0x2, 0xd59, 0xd56, 0x3, 0x2, 0x2, 0x2, 0xd59, 0xd5a, 
       0x3, 0x2, 0x2, 0x2, 0xd5a, 0xd5b, 0x3, 0x2, 0x2, 0x2, 0xd5b, 0xd5c, 
       0x5, 0x394, 0x1cb, 0x2, 0xd5c, 0x133, 0x3, 0x2, 0x2, 0x2, 0xd5d, 
       0xd5e, 0x7, 0x203, 0x2, 0x2, 0xd5e, 0xd5f, 0x7, 0x286, 0x2, 0x2, 
       0xd5f, 0xd60, 0x5, 0x35a, 0x1ae, 0x2, 0xd60, 0xd61, 0x7, 0x29b, 0x2, 
       0x2, 0xd61, 0xd68, 0x5, 0x35a, 0x1ae, 0x2, 0xd62, 0xd63, 0x5, 0x35a, 
       0x1ae, 0x2, 0xd63, 0xd64, 0x7, 0x29b, 0x2, 0x2, 0xd64, 0xd65, 0x5, 
       0x35a, 0x1ae, 0x2, 0xd65, 0xd67, 0x3, 0x2, 0x2, 0x2, 0xd66, 0xd62, 
       0x3, 0x2, 0x2, 0x2, 0xd67, 0xd6a, 0x3, 0x2, 0x2, 0x2, 0xd68, 0xd66, 
       0x3, 0x2, 0x2, 0x2, 0xd68, 0xd69, 0x3, 0x2, 0x2, 0x2, 0xd69, 0x135, 
       0x3, 0x2, 0x2, 0x2, 0xd6a, 0xd68, 0x3, 0x2, 0x2, 0x2, 0xd6b, 0xd6c, 
       0x7, 0x2fb, 0x2, 0x2, 0xd6c, 0xd6d, 0x5, 0xde, 0x70, 0x2, 0xd6d, 
       0xd6e, 0x7, 0x2fc, 0x2, 0x2, 0xd6e, 0x137, 0x3, 0x2, 0x2, 0x2, 0xd6f, 
       0xd70, 0x5, 0x33e, 0x1a0, 0x2, 0xd70, 0xd72, 0x5, 0x13a, 0x9e, 0x2, 
       0xd71, 0xd73, 0x5, 0x144, 0xa3, 0x2, 0xd72, 0xd71, 0x3, 0x2, 0x2, 
       0x2, 0xd72, 0xd73, 0x3, 0x2, 0x2, 0x2, 0xd73, 0x139, 0x3, 0x2, 0x2, 
       0x2, 0xd74, 0xd8e, 0x5, 0x41a, 0x20e, 0x2, 0xd75, 0xd77, 0x5, 0x13c, 
       0x9f, 0x2, 0xd76, 0xd75, 0x3, 0x2, 0x2, 0x2, 0xd77, 0xd7a, 0x3, 0x2, 
       0x2, 0x2, 0xd78, 0xd76, 0x3, 0x2, 0x2, 0x2, 0xd78, 0xd79, 0x3, 0x2, 
       0x2, 0x2, 0xd79, 0xd8f, 0x3, 0x2, 0x2, 0x2, 0xd7a, 0xd78, 0x3, 0x2, 
       0x2, 0x2, 0xd7b, 0xd7d, 0x5, 0x446, 0x224, 0x2, 0xd7c, 0xd7b, 0x3, 
       0x2, 0x2, 0x2, 0xd7c, 0xd7d, 0x3, 0x2, 0x2, 0x2, 0xd7d, 0xd7f, 0x3, 
       0x2, 0x2, 0x2, 0xd7e, 0xd80, 0x5, 0x142, 0xa2, 0x2, 0xd7f, 0xd7e, 
       0x3, 0x2, 0x2, 0x2, 0xd7f, 0xd80, 0x3, 0x2, 0x2, 0x2, 0xd80, 0xd81, 
       0x3, 0x2, 0x2, 0x2, 0xd81, 0xd82, 0x7, 0x2c, 0x2, 0x2, 0xd82, 0xd83, 
       0x7, 0x2fb, 0x2, 0x2, 0xd83, 0xd84, 0x5, 0x3a6, 0x1d4, 0x2, 0xd84, 
       0xd86, 0x7, 0x2fc, 0x2, 0x2, 0xd85, 0xd87, 0x9, 0x22, 0x2, 0x2, 0xd86, 
       0xd85, 0x3, 0x2, 0x2, 0x2, 0xd86, 0xd87, 0x3, 0x2, 0x2, 0x2, 0xd87, 
       0xd8b, 0x3, 0x2, 0x2, 0x2, 0xd88, 0xd8a, 0x5, 0x13c, 0x9f, 0x2, 0xd89, 
       0xd88, 0x3, 0x2, 0x2, 0x2, 0xd8a, 0xd8d, 0x3, 0x2, 0x2, 0x2, 0xd8b, 
       0xd89, 0x3, 0x2, 0x2, 0x2, 0xd8b, 0xd8c, 0x3, 0x2, 0x2, 0x2, 0xd8c, 
       0xd8f, 0x3, 0x2, 0x2, 0x2, 0xd8d, 0xd8b, 0x3, 0x2, 0x2, 0x2, 0xd8e, 
       0xd78, 0x3, 0x2, 0x2, 0x2, 0xd8e, 0xd7c, 0x3, 0x2, 0x2, 0x2, 0xd8f, 
       0x13b, 0x3, 0x2, 0x2, 0x2, 0xd90, 0xd92, 0x7, 0x1a0, 0x2, 0x2, 0xd91, 
       0xd90, 0x3, 0x2, 0x2, 0x2, 0xd91, 0xd92, 0x3, 0x2, 0x2, 0x2, 0xd92, 
       0xd93, 0x3, 0x2, 0x2, 0x2, 0xd93, 0xdbd, 0x7, 0x1a6, 0x2, 0x2, 0xd94, 
       0xd95, 0x7, 0x1a0, 0x2, 0x2, 0xd95, 0xdbd, 0x7, 0x236, 0x2, 0x2, 
       0xd96, 0xd9d, 0x7, 0x92, 0x2, 0x2, 0xd97, 0xd9e, 0x5, 0x436, 0x21c, 
       0x2, 0xd98, 0xd9e, 0x5, 0x438, 0x21d, 0x2, 0xd99, 0xd9a, 0x7, 0x2fb, 
       0x2, 0x2, 0xd9a, 0xd9b, 0x5, 0x3a6, 0x1d4, 0x2, 0xd9b, 0xd9c, 0x7, 
       0x2fc, 0x2, 0x2, 0xd9c, 0xd9e, 0x3, 0x2, 0x2, 0x2, 0xd9d, 0xd97, 
       0x3, 0x2, 0x2, 0x2, 0xd9d, 0xd98, 0x3, 0x2, 0x2, 0x2, 0xd9d, 0xd99, 
       0x3, 0x2, 0x2, 0x2, 0xd9e, 0xdbd, 0x3, 0x2, 0x2, 0x2, 0xd9f, 0xda0, 
       0x7, 0x1b0, 0x2, 0x2, 0xda0, 0xda1, 0x7, 0x2b2, 0x2, 0x2, 0xda1, 
       0xdbd, 0x5, 0x438, 0x21d, 0x2, 0xda2, 0xdbd, 0x7, 0x33, 0x2, 0x2, 
       0xda3, 0xda4, 0x7, 0x240, 0x2, 0x2, 0xda4, 0xda5, 0x7, 0x92, 0x2, 
       0x2, 0xda5, 0xdbd, 0x7, 0x2be, 0x2, 0x2, 0xda6, 0xda8, 0x7, 0x1de, 
       0x2, 0x2, 0xda7, 0xda6, 0x3, 0x2, 0x2, 0x2, 0xda7, 0xda8, 0x3, 0x2, 
       0x2, 0x2, 0xda8, 0xda9, 0x3, 0x2, 0x2, 0x2, 0xda9, 0xdbd, 0x7, 0x12f, 
       0x2, 0x2, 0xdaa, 0xdac, 0x7, 0x2ad, 0x2, 0x2, 0xdab, 0xdad, 0x7, 
       0x12f, 0x2, 0x2, 0xdac, 0xdab, 0x3, 0x2, 0x2, 0x2, 0xdac, 0xdad, 
       0x3, 0x2, 0x2, 0x2, 0xdad, 0xdbd, 0x3, 0x2, 0x2, 0x2, 0xdae, 0xdaf, 
       0x7, 0x63, 0x2, 0x2, 0xdaf, 0xdbd, 0x5, 0x32c, 0x197, 0x2, 0xdb0, 
       0xdbd, 0x5, 0x446, 0x224, 0x2, 0xdb1, 0xdb2, 0x7, 0x61, 0x2, 0x2, 
       0xdb2, 0xdbd, 0x5, 0x43a, 0x21e, 0x2, 0xdb3, 0xdb4, 0x7, 0x278, 0x2, 
       0x2, 0xdb4, 0xdbd, 0x5, 0x43c, 0x21f, 0x2, 0xdb5, 0xdb6, 0x7, 0x26d, 
       0x2, 0x2, 0xdb6, 0xdbd, 0x7, 0x313, 0x2, 0x2, 0xdb7, 0xdb9, 0x5, 
       0xdc, 0x6f, 0x2, 0xdb8, 0xdb7, 0x3, 0x2, 0x2, 0x2, 0xdb8, 0xdb9, 
       0x3, 0x2, 0x2, 0x2, 0xdb9, 0xdba, 0x3, 0x2, 0x2, 0x2, 0xdba, 0xdbd, 
       0x5, 0x13e, 0xa0, 0x2, 0xdbb, 0xdbd, 0x5, 0x140, 0xa1, 0x2, 0xdbc, 
       0xd91, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xd94, 0x3, 0x2, 0x2, 0x2, 0xdbc, 
       0xd96, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xd9f, 0x3, 0x2, 0x2, 0x2, 0xdbc, 
       0xda2, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xda3, 0x3, 0x2, 0x2, 0x2, 0xdbc, 
       0xda7, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xdaa, 0x3, 0x2, 0x2, 0x2, 0xdbc, 
       0xdae, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xdb0, 0x3, 0x2, 0x2, 0x2, 0xdbc, 
       0xdb1, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xdb3, 0x3, 0x2, 0x2, 0x2, 0xdbc, 
       0xdb5, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xdb8, 0x3, 0x2, 0x2, 0x2, 0xdbc, 
       0xdbb, 0x3, 0x2, 0x2, 0x2, 0xdbd, 0x13d, 0x3, 0x2, 0x2, 0x2, 0xdbe, 
       0xdbf, 0x7, 0x54, 0x2, 0x2, 0xdbf, 0xdc0, 0x7, 0x2fb, 0x2, 0x2, 0xdc0, 
       0xdc1, 0x5, 0x3a6, 0x1d4, 0x2, 0xdc1, 0xdc2, 0x7, 0x2fc, 0x2, 0x2, 
       0xdc2, 0x13f, 0x3, 0x2, 0x2, 0x2, 0xdc3, 0xdc5, 0x7, 0x1a0, 0x2, 
       0x2, 0xdc4, 0xdc3, 0x3, 0x2, 0x2, 0x2, 0xdc4, 0xdc5, 0x3, 0x2, 0x2, 
       0x2, 0xdc5, 0xdc6, 0x3, 0x2, 0x2, 0x2, 0xdc6, 0xdc7, 0x7, 0xb6, 0x2, 
       0x2, 0xdc7, 0x141, 0x3, 0x2, 0x2, 0x2, 0xdc8, 0xdc9, 0x7, 0xea, 0x2, 
       0x2, 0xdc9, 0xdca, 0x7, 0x27, 0x2, 0x2, 0xdca, 0x143, 0x3, 0x2, 0x2, 
       0x2, 0xdcb, 0xdcc, 0x7, 0x1f9, 0x2, 0x2, 0xdcc, 0xdcd, 0x5, 0x35a, 
       0x1ae, 0x2, 0xdcd, 0xdd4, 0x5, 0x150, 0xa9, 0x2, 0xdce, 0xdcf, 0x7, 
       0x170, 0x2, 0x2, 0xdcf, 0xdd5, 0x7, 0xe6, 0x2, 0x2, 0xdd0, 0xdd1, 
       0x7, 0x170, 0x2, 0x2, 0xdd1, 0xdd5, 0x7, 0x1c7, 0x2, 0x2, 0xdd2, 
       0xdd3, 0x7, 0x170, 0x2, 0x2, 0xdd3, 0xdd5, 0x7, 0x24a, 0x2, 0x2, 
       0xdd4, 0xdce, 0x3, 0x2, 0x2, 0x2, 0xdd4, 0xdd0, 0x3, 0x2, 0x2, 0x2, 
       0xdd4, 0xdd2, 0x3, 0x2, 0x2, 0x2, 0xdd4, 0xdd5, 0x3, 0x2, 0x2, 0x2, 
       0xdd5, 0xdd7, 0x3, 0x2, 0x2, 0x2, 0xdd6, 0xdd8, 0x5, 0x146, 0xa4, 
       0x2, 0xdd7, 0xdd6, 0x3, 0x2, 0x2, 0x2, 0xdd7, 0xdd8, 0x3, 0x2, 0x2, 
       0x2, 0xdd8, 0x145, 0x3, 0x2, 0x2, 0x2, 0xdd9, 0xdda, 0x7, 0x1b0, 
       0x2, 0x2, 0xdda, 0xddb, 0x7, 0x2b2, 0x2, 0x2, 0xddb, 0xddf, 0x5, 
       0x148, 0xa5, 0x2, 0xddc, 0xddd, 0x7, 0x1b0, 0x2, 0x2, 0xddd, 0xdde, 
       0x7, 0x98, 0x2, 0x2, 0xdde, 0xde0, 0x5, 0x148, 0xa5, 0x2, 0xddf, 
       0xddc, 0x3, 0x2, 0x2, 0x2, 0xddf, 0xde0, 0x3, 0x2, 0x2, 0x2, 0xde0, 
       0xdea, 0x3, 0x2, 0x2, 0x2, 0xde1, 0xde2, 0x7, 0x1b0, 0x2, 0x2, 0xde2, 
       0xde3, 0x7, 0x98, 0x2, 0x2, 0xde3, 0xde7, 0x5, 0x148, 0xa5, 0x2, 
       0xde4, 0xde5, 0x7, 0x1b0, 0x2, 0x2, 0xde5, 0xde6, 0x7, 0x2b2, 0x2, 
       0x2, 0xde6, 0xde8, 0x5, 0x148, 0xa5, 0x2, 0xde7, 0xde4, 0x3, 0x2, 
       0x2, 0x2, 0xde7, 0xde8, 0x3, 0x2, 0x2, 0x2, 0xde8, 0xdea, 0x3, 0x2, 
       0x2, 0x2, 0xde9, 0xdd9, 0x3, 0x2, 0x2, 0x2, 0xde9, 0xde1, 0x3, 0x2, 
       0x2, 0x2, 0xdea, 0x147, 0x3, 0x2, 0x2, 0x2, 0xdeb, 0xdf4, 0x7, 0x219, 
       0x2, 0x2, 0xdec, 0xdf4, 0x7, 0x49, 0x2, 0x2, 0xded, 0xdee, 0x7, 0x244, 
       0x2, 0x2, 0xdee, 0xdf4, 0x7, 0x1a6, 0x2, 0x2, 0xdef, 0xdf0, 0x7, 
       0x19d, 0x2, 0x2, 0xdf0, 0xdf4, 0x7, 0x1d, 0x2, 0x2, 0xdf1, 0xdf2, 
       0x7, 0x244, 0x2, 0x2, 0xdf2, 0xdf4, 0x7, 0x92, 0x2, 0x2, 0xdf3, 0xdeb, 
       0x3, 0x2, 0x2, 0x2, 0xdf3, 0xdec, 0x3, 0x2, 0x2, 0x2, 0xdf3, 0xded, 
       0x3, 0x2, 0x2, 0x2, 0xdf3, 0xdef, 0x3, 0x2, 0x2, 0x2, 0xdf3, 0xdf1, 
       0x3, 0x2, 0x2, 0x2, 0xdf4, 0x149, 0x3, 0x2, 0x2, 0x2, 0xdf5, 0xdf7, 
       0x5, 0x35e, 0x1b0, 0x2, 0xdf6, 0xdf8, 0x5, 0x14e, 0xa8, 0x2, 0xdf7, 
       0xdf6, 0x3, 0x2, 0x2, 0x2, 0xdf7, 0xdf8, 0x3, 0x2, 0x2, 0x2, 0xdf8, 
       0x14b, 0x3, 0x2, 0x2, 0x2, 0xdf9, 0xdfa, 0x9, 0x23, 0x2, 0x2, 0xdfa, 
       0x14d, 0x3, 0x2, 0x2, 0x2, 0xdfb, 0xdfc, 0x9, 0x24, 0x2, 0x2, 0xdfc, 
       0xdfd, 0x5, 0x14c, 0xa7, 0x2, 0xdfd, 0x14f, 0x3, 0x2, 0x2, 0x2, 0xdfe, 
       0xdff, 0x7, 0x2fb, 0x2, 0x2, 0xdff, 0xe04, 0x5, 0x152, 0xaa, 0x2, 
       0xe00, 0xe01, 0x7, 0x301, 0x2, 0x2, 0xe01, 0xe03, 0x5, 0x152, 0xaa, 
       0x2, 0xe02, 0xe00, 0x3, 0x2, 0x2, 0x2, 0xe03, 0xe06, 0x3, 0x2, 0x2, 
       0x2, 0xe04, 0xe02, 0x3, 0x2, 0x2, 0x2, 0xe04, 0xe05, 0x3, 0x2, 0x2, 
       0x2, 0xe05, 0xe07, 0x3, 0x2, 0x2, 0x2, 0xe06, 0xe04, 0x3, 0x2, 0x2, 
       0x2, 0xe07, 0xe08, 0x7, 0x2fc, 0x2, 0x2, 0xe08, 0x151, 0x3, 0x2, 
       0x2, 0x2, 0xe09, 0xe0b, 0x5, 0x35c, 0x1af, 0x2, 0xe0a, 0xe0c, 0x5, 
       0x442, 0x222, 0x2, 0xe0b, 0xe0a, 0x3, 0x2, 0x2, 0x2, 0xe0b, 0xe0c, 
       0x3, 0x2, 0x2, 0x2, 0xe0c, 0xe0e, 0x3, 0x2, 0x2, 0x2, 0xe0d, 0xe0f, 
       0x5, 0x43e, 0x220, 0x2, 0xe0e, 0xe0d, 0x3, 0x2, 0x2, 0x2, 0xe0e, 
       0xe0f, 0x3, 0x2, 0x2, 0x2, 0xe0f, 0x153, 0x3, 0x2, 0x2, 0x2, 0xe10, 
       0xe18, 0x5, 0x152, 0xaa, 0x2, 0xe11, 0xe12, 0x7, 0x2fb, 0x2, 0x2, 
       0xe12, 0xe13, 0x5, 0x3a6, 0x1d4, 0x2, 0xe13, 0xe15, 0x7, 0x2fc, 0x2, 
       0x2, 0xe14, 0xe16, 0x5, 0x43e, 0x220, 0x2, 0xe15, 0xe14, 0x3, 0x2, 
       0x2, 0x2, 0xe15, 0xe16, 0x3, 0x2, 0x2, 0x2, 0xe16, 0xe18, 0x3, 0x2, 
       0x2, 0x2, 0xe17, 0xe10, 0x3, 0x2, 0x2, 0x2, 0xe17, 0xe11, 0x3, 0x2, 
       0x2, 0x2, 0xe18, 0x155, 0x3, 0x2, 0x2, 0x2, 0xe19, 0xe1a, 0x7, 0x2fb, 
       0x2, 0x2, 0xe1a, 0xe1f, 0x5, 0x154, 0xab, 0x2, 0xe1b, 0xe1c, 0x7, 
       0x301, 0x2, 0x2, 0xe1c, 0xe1e, 0x5, 0x154, 0xab, 0x2, 0xe1d, 0xe1b, 
       0x3, 0x2, 0x2, 0x2, 0xe1e, 0xe21, 0x3, 0x2, 0x2, 0x2, 0xe1f, 0xe1d, 
       0x3, 0x2, 0x2, 0x2, 0xe1f, 0xe20, 0x3, 0x2, 0x2, 0x2, 0xe20, 0xe22, 
       0x3, 0x2, 0x2, 0x2, 0xe21, 0xe1f, 0x3, 0x2, 0x2, 0x2, 0xe22, 0xe23, 
       0x7, 0x2fc, 0x2, 0x2, 0xe23, 0x157, 0x3, 0x2, 0x2, 0x2, 0xe24, 0xe27, 
       0x5, 0x15a, 0xae, 0x2, 0xe25, 0xe27, 0x5, 0x14e, 0xa8, 0x2, 0xe26, 
       0xe24, 0x3, 0x2, 0x2, 0x2, 0xe26, 0xe25, 0x3, 0x2, 0x2, 0x2, 0xe27, 
       0x159, 0x3, 0x2, 0x2, 0x2, 0xe28, 0xe2a, 0x7, 0x131, 0x2, 0x2, 0xe29, 
       0xe2b, 0x7, 0x2f4, 0x2, 0x2, 0xe2a, 0xe29, 0x3, 0x2, 0x2, 0x2, 0xe2a, 
       0xe2b, 0x3, 0x2, 0x2, 0x2, 0xe2b, 0xe2c, 0x3, 0x2, 0x2, 0x2, 0xe2c, 
       0xe31, 0x7, 0x313, 0x2, 0x2, 0xe2d, 0xe2e, 0x7, 0x63, 0x2, 0x2, 0xe2e, 
       0xe31, 0x5, 0x32e, 0x198, 0x2, 0xe2f, 0xe31, 0x5, 0x15c, 0xaf, 0x2, 
       0xe30, 0xe28, 0x3, 0x2, 0x2, 0x2, 0xe30, 0xe2d, 0x3, 0x2, 0x2, 0x2, 
       0xe30, 0xe2f, 0x3, 0x2, 0x2, 0x2, 0xe31, 0x15b, 0x3, 0x2, 0x2, 0x2, 
       0xe32, 0xe33, 0x9, 0x25, 0x2, 0x2, 0xe33, 0x15d, 0x3, 0x2, 0x2, 0x2, 
       0xe34, 0xe36, 0x7, 0x2fb, 0x2, 0x2, 0xe35, 0xe34, 0x3, 0x2, 0x2, 
       0x2, 0xe35, 0xe36, 0x3, 0x2, 0x2, 0x2, 0xe36, 0xe37, 0x3, 0x2, 0x2, 
       0x2, 0xe37, 0xe38, 0x7, 0x13f, 0x2, 0x2, 0xe38, 0xe3a, 0x5, 0x35a, 
       0x1ae, 0x2, 0xe39, 0xe3b, 0x7, 0x2fc, 0x2, 0x2, 0xe3a, 0xe39, 0x3, 
       0x2, 0x2, 0x2, 0xe3a, 0xe3b, 0x3, 0x2, 0x2, 0x2, 0xe3b, 0x15f, 0x3, 
       0x2, 0x2, 0x2, 0xe3c, 0xe3d, 0x9, 0x26, 0x2, 0x2, 0xe3d, 0x161, 0x3, 
       0x2, 0x2, 0x2, 0xe3e, 0xe45, 0x5, 0x164, 0xb3, 0x2, 0xe3f, 0xe41, 
       0x7, 0x301, 0x2, 0x2, 0xe40, 0xe3f, 0x3, 0x2, 0x2, 0x2, 0xe40, 0xe41, 
       0x3, 0x2, 0x2, 0x2, 0xe41, 0xe42, 0x3, 0x2, 0x2, 0x2, 0xe42, 0xe44, 
       0x5, 0x164, 0xb3, 0x2, 0xe43, 0xe40, 0x3, 0x2, 0x2, 0x2, 0xe44, 0xe47, 
       0x3, 0x2, 0x2, 0x2, 0xe45, 0xe43, 0x3, 0x2, 0x2, 0x2, 0xe45, 0xe46, 
       0x3, 0x2, 0x2, 0x2, 0xe46, 0x163, 0x3, 0x2, 0x2, 0x2, 0xe47, 0xe45, 
       0x3, 0x2, 0x2, 0x2, 0xe48, 0xe4a, 0x7, 0xb7, 0x2, 0x2, 0xe49, 0xe4b, 
       0x7, 0x2f4, 0x2, 0x2, 0xe4a, 0xe49, 0x3, 0x2, 0x2, 0x2, 0xe4a, 0xe4b, 
       0x3, 0x2, 0x2, 0x2, 0xe4b, 0xe4c, 0x3, 0x2, 0x2, 0x2, 0xe4c, 0xecc, 
       0x5, 0x392, 0x1ca, 0x2, 0xe4d, 0xe4f, 0x7, 0x237, 0x2, 0x2, 0xe4e, 
       0xe50, 0x7, 0x2f4, 0x2, 0x2, 0xe4f, 0xe4e, 0x3, 0x2, 0x2, 0x2, 0xe4f, 
       0xe50, 0x3, 0x2, 0x2, 0x2, 0xe50, 0xe54, 0x3, 0x2, 0x2, 0x2, 0xe51, 
       0xe55, 0x7, 0x1a6, 0x2, 0x2, 0xe52, 0xe55, 0x5, 0x32c, 0x197, 0x2, 
       0xe53, 0xe55, 0x5, 0x33e, 0x1a0, 0x2, 0xe54, 0xe51, 0x3, 0x2, 0x2, 
       0x2, 0xe54, 0xe52, 0x3, 0x2, 0x2, 0x2, 0xe54, 0xe53, 0x3, 0x2, 0x2, 
       0x2, 0xe55, 0xecc, 0x3, 0x2, 0x2, 0x2, 0xe56, 0xe58, 0x7, 0x174, 
       0x2, 0x2, 0xe57, 0xe59, 0x7, 0x2f4, 0x2, 0x2, 0xe58, 0xe57, 0x3, 
       0x2, 0x2, 0x2, 0xe58, 0xe59, 0x3, 0x2, 0x2, 0x2, 0xe59, 0xe5a, 0x3, 
       0x2, 0x2, 0x2, 0xe5a, 0xecc, 0x7, 0x313, 0x2, 0x2, 0xe5b, 0xe5d, 
       0x7, 0x186, 0x2, 0x2, 0xe5c, 0xe5e, 0x7, 0x2f4, 0x2, 0x2, 0xe5d, 
       0xe5c, 0x3, 0x2, 0x2, 0x2, 0xe5d, 0xe5e, 0x3, 0x2, 0x2, 0x2, 0xe5e, 
       0xe5f, 0x3, 0x2, 0x2, 0x2, 0xe5f, 0xecc, 0x7, 0x313, 0x2, 0x2, 0xe60, 
       0xe62, 0x7, 0x35, 0x2, 0x2, 0xe61, 0xe63, 0x7, 0x2f4, 0x2, 0x2, 0xe62, 
       0xe61, 0x3, 0x2, 0x2, 0x2, 0xe62, 0xe63, 0x3, 0x2, 0x2, 0x2, 0xe63, 
       0xe64, 0x3, 0x2, 0x2, 0x2, 0xe64, 0xecc, 0x7, 0x313, 0x2, 0x2, 0xe65, 
       0xe67, 0x7, 0x1cb, 0x2, 0x2, 0xe66, 0xe68, 0x7, 0x2f4, 0x2, 0x2, 
       0xe67, 0xe66, 0x3, 0x2, 0x2, 0x2, 0xe67, 0xe68, 0x3, 0x2, 0x2, 0x2, 
       0xe68, 0xe69, 0x3, 0x2, 0x2, 0x2, 0xe69, 0xecc, 0x5, 0x32c, 0x197, 
       0x2, 0xe6a, 0xe6c, 0x7, 0x63, 0x2, 0x2, 0xe6b, 0xe6d, 0x7, 0x2f4, 
       0x2, 0x2, 0xe6c, 0xe6b, 0x3, 0x2, 0x2, 0x2, 0xe6c, 0xe6d, 0x3, 0x2, 
       0x2, 0x2, 0xe6d, 0xe6e, 0x3, 0x2, 0x2, 0x2, 0xe6e, 0xecc, 0x5, 0x32c, 
       0x197, 0x2, 0xe6f, 0xe71, 0x7, 0x6a, 0x2, 0x2, 0xe70, 0xe72, 0x7, 
       0x2f4, 0x2, 0x2, 0xe71, 0xe70, 0x3, 0x2, 0x2, 0x2, 0xe71, 0xe72, 
       0x3, 0x2, 0x2, 0x2, 0xe72, 0xe73, 0x3, 0x2, 0x2, 0x2, 0xe73, 0xecc, 
       0x5, 0x41e, 0x210, 0x2, 0xe74, 0xe76, 0x7, 0xb3, 0x2, 0x2, 0xe75, 
       0xe77, 0x7, 0x2f4, 0x2, 0x2, 0xe76, 0xe75, 0x3, 0x2, 0x2, 0x2, 0xe76, 
       0xe77, 0x3, 0x2, 0x2, 0x2, 0xe77, 0xe78, 0x3, 0x2, 0x2, 0x2, 0xe78, 
       0xecc, 0x5, 0x41e, 0x210, 0x2, 0xe79, 0xe7b, 0x7, 0x33, 0x2, 0x2, 
       0xe7a, 0xe7c, 0x7, 0x2f4, 0x2, 0x2, 0xe7b, 0xe7a, 0x3, 0x2, 0x2, 
       0x2, 0xe7b, 0xe7c, 0x3, 0x2, 0x2, 0x2, 0xe7c, 0xe7d, 0x3, 0x2, 0x2, 
       0x2, 0xe7d, 0xecc, 0x7, 0x313, 0x2, 0x2, 0xe7e, 0xe80, 0x7, 0x1c4, 
       0x2, 0x2, 0xe7f, 0xe81, 0x7, 0x2f4, 0x2, 0x2, 0xe80, 0xe7f, 0x3, 
       0x2, 0x2, 0x2, 0xe80, 0xe81, 0x3, 0x2, 0x2, 0x2, 0xe81, 0xe82, 0x3, 
       0x2, 0x2, 0x2, 0xe82, 0xecc, 0x9, 0x1a, 0x2, 0x2, 0xe83, 0xe85, 0x9, 
       0x27, 0x2, 0x2, 0xe84, 0xe86, 0x7, 0x2f4, 0x2, 0x2, 0xe85, 0xe84, 
       0x3, 0x2, 0x2, 0x2, 0xe85, 0xe86, 0x3, 0x2, 0x2, 0x2, 0xe86, 0xe87, 
       0x3, 0x2, 0x2, 0x2, 0xe87, 0xecc, 0x9, 0x1a, 0x2, 0x2, 0xe88, 0xe8a, 
       0x9, 0x28, 0x2, 0x2, 0xe89, 0xe8b, 0x7, 0x2f4, 0x2, 0x2, 0xe8a, 0xe89, 
       0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe8b, 0x3, 0x2, 0x2, 0x2, 0xe8b, 0xe8c, 
       0x3, 0x2, 0x2, 0x2, 0xe8c, 0xecc, 0x7, 0x313, 0x2, 0x2, 0xe8d, 0xe8f, 
       0x7, 0x97, 0x2, 0x2, 0xe8e, 0xe90, 0x7, 0x2f4, 0x2, 0x2, 0xe8f, 0xe8e, 
       0x3, 0x2, 0x2, 0x2, 0xe8f, 0xe90, 0x3, 0x2, 0x2, 0x2, 0xe90, 0xe91, 
       0x3, 0x2, 0x2, 0x2, 0xe91, 0xecc, 0x7, 0x313, 0x2, 0x2, 0xe92, 0xe94, 
       0x7, 0x22d, 0x2, 0x2, 0xe93, 0xe95, 0x7, 0x2f4, 0x2, 0x2, 0xe94, 
       0xe93, 0x3, 0x2, 0x2, 0x2, 0xe94, 0xe95, 0x3, 0x2, 0x2, 0x2, 0xe95, 
       0xe96, 0x3, 0x2, 0x2, 0x2, 0xe96, 0xecc, 0x9, 0x29, 0x2, 0x2, 0xe97, 
       0xe99, 0x7, 0x2ac, 0x2, 0x2, 0xe98, 0xe9a, 0x7, 0x2f4, 0x2, 0x2, 
       0xe99, 0xe98, 0x3, 0x2, 0x2, 0x2, 0xe99, 0xe9a, 0x3, 0x2, 0x2, 0x2, 
       0xe9a, 0xe9b, 0x3, 0x2, 0x2, 0x2, 0xe9b, 0xe9c, 0x7, 0x2fb, 0x2, 
       0x2, 0xe9c, 0xe9d, 0x5, 0x374, 0x1bb, 0x2, 0xe9d, 0xe9e, 0x7, 0x2fc, 
       0x2, 0x2, 0xe9e, 0xecc, 0x3, 0x2, 0x2, 0x2, 0xe9f, 0xecc, 0x5, 0x434, 
       0x21b, 0x2, 0xea0, 0xecc, 0x5, 0x430, 0x219, 0x2, 0xea1, 0xea3, 0x7, 
       0x114, 0x2, 0x2, 0xea2, 0xea4, 0x7, 0x2f4, 0x2, 0x2, 0xea3, 0xea2, 
       0x3, 0x2, 0x2, 0x2, 0xea3, 0xea4, 0x3, 0x2, 0x2, 0x2, 0xea4, 0xea5, 
       0x3, 0x2, 0x2, 0x2, 0xea5, 0xecc, 0x9, 0x2a, 0x2, 0x2, 0xea6, 0xea7, 
       0x7, 0x83, 0x2, 0x2, 0xea7, 0xea9, 0x7, 0x9f, 0x2, 0x2, 0xea8, 0xeaa, 
       0x7, 0x2f4, 0x2, 0x2, 0xea9, 0xea8, 0x3, 0x2, 0x2, 0x2, 0xea9, 0xeaa, 
       0x3, 0x2, 0x2, 0x2, 0xeaa, 0xeab, 0x3, 0x2, 0x2, 0x2, 0xeab, 0xecc, 
       0x5, 0x41e, 0x210, 0x2, 0xeac, 0xead, 0x7, 0x10c, 0x2, 0x2, 0xead, 
       0xeaf, 0x7, 0x9f, 0x2, 0x2, 0xeae, 0xeb0, 0x7, 0x2f4, 0x2, 0x2, 0xeaf, 
       0xeae, 0x3, 0x2, 0x2, 0x2, 0xeaf, 0xeb0, 0x3, 0x2, 0x2, 0x2, 0xeb0, 
       0xeb1, 0x3, 0x2, 0x2, 0x2, 0xeb1, 0xecc, 0x5, 0x41e, 0x210, 0x2, 
       0xeb2, 0xeb4, 0x7, 0x288, 0x2, 0x2, 0xeb3, 0xeb5, 0x7, 0x2f4, 0x2, 
       0x2, 0xeb4, 0xeb3, 0x3, 0x2, 0x2, 0x2, 0xeb4, 0xeb5, 0x3, 0x2, 0x2, 
       0x2, 0xeb5, 0xeb6, 0x3, 0x2, 0x2, 0x2, 0xeb6, 0xecc, 0x5, 0x33e, 
       0x1a0, 0x2, 0xeb7, 0xeb8, 0x7, 0x278, 0x2, 0x2, 0xeb8, 0xecc, 0x9, 
       0x2b, 0x2, 0x2, 0xeb9, 0xebb, 0x7, 0x6d, 0x2, 0x2, 0xeba, 0xebc, 
       0x7, 0x2f4, 0x2, 0x2, 0xebb, 0xeba, 0x3, 0x2, 0x2, 0x2, 0xebb, 0xebc, 
       0x3, 0x2, 0x2, 0x2, 0xebc, 0xebd, 0x3, 0x2, 0x2, 0x2, 0xebd, 0xecc, 
       0x5, 0x41e, 0x210, 0x2, 0xebe, 0xec0, 0x7, 0x131, 0x2, 0x2, 0xebf, 
       0xec1, 0x7, 0x2f4, 0x2, 0x2, 0xec0, 0xebf, 0x3, 0x2, 0x2, 0x2, 0xec0, 
       0xec1, 0x3, 0x2, 0x2, 0x2, 0xec1, 0xec2, 0x3, 0x2, 0x2, 0x2, 0xec2, 
       0xecc, 0x7, 0x313, 0x2, 0x2, 0xec3, 0xec5, 0x7, 0xb9, 0x2, 0x2, 0xec4, 
       0xec6, 0x7, 0x2f4, 0x2, 0x2, 0xec5, 0xec4, 0x3, 0x2, 0x2, 0x2, 0xec5, 
       0xec6, 0x3, 0x2, 0x2, 0x2, 0xec6, 0xec7, 0x3, 0x2, 0x2, 0x2, 0xec7, 
       0xecc, 0x5, 0x32c, 0x197, 0x2, 0xec8, 0xec9, 0x7, 0x238, 0x2, 0x2, 
       0xec9, 0xeca, 0x7, 0x2f4, 0x2, 0x2, 0xeca, 0xecc, 0x5, 0x32c, 0x197, 
       0x2, 0xecb, 0xe48, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe4d, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe56, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe5b, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe60, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe65, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe6a, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe6f, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe74, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe79, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe7e, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe83, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe88, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe8d, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe92, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xe97, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xe9f, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xea0, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xea1, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xea6, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xeac, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xeb2, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xeb7, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xeb9, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xebe, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xec3, 0x3, 0x2, 0x2, 
       0x2, 0xecb, 0xec8, 0x3, 0x2, 0x2, 0x2, 0xecc, 0x165, 0x3, 0x2, 0x2, 
       0x2, 0xecd, 0xece, 0x7, 0x78, 0x2, 0x2, 0xece, 0xecf, 0x7, 0x1ba, 
       0x2, 0x2, 0xecf, 0xed0, 0x7, 0x208, 0x2, 0x2, 0xed0, 0xed1, 0x7, 
       0x255, 0x2, 0x2, 0xed1, 0xed2, 0x7, 0x1f8, 0x2, 0x2, 0xed2, 0xed3, 
       0x7, 0x285, 0x2, 0x2, 0xed3, 0xed7, 0x7, 0x313, 0x2, 0x2, 0xed4, 
       0xed6, 0x5, 0x16a, 0xb6, 0x2, 0xed5, 0xed4, 0x3, 0x2, 0x2, 0x2, 0xed6, 
       0xed9, 0x3, 0x2, 0x2, 0x2, 0xed7, 0xed5, 0x3, 0x2, 0x2, 0x2, 0xed7, 
       0xed8, 0x3, 0x2, 0x2, 0x2, 0xed8, 0xee9, 0x3, 0x2, 0x2, 0x2, 0xed9, 
       0xed7, 0x3, 0x2, 0x2, 0x2, 0xeda, 0xedb, 0x7, 0x78, 0x2, 0x2, 0xedb, 
       0xedc, 0x7, 0x255, 0x2, 0x2, 0xedc, 0xedd, 0x7, 0x1f8, 0x2, 0x2, 
       0xedd, 0xedf, 0x7, 0x285, 0x2, 0x2, 0xede, 0xee0, 0x5, 0x44a, 0x226, 
       0x2, 0xedf, 0xede, 0x3, 0x2, 0x2, 0x2, 0xedf, 0xee0, 0x3, 0x2, 0x2, 
       0x2, 0xee0, 0xee1, 0x3, 0x2, 0x2, 0x2, 0xee1, 0xee5, 0x7, 0x313, 
       0x2, 0x2, 0xee2, 0xee4, 0x5, 0x16a, 0xb6, 0x2, 0xee3, 0xee2, 0x3, 
       0x2, 0x2, 0x2, 0xee4, 0xee7, 0x3, 0x2, 0x2, 0x2, 0xee5, 0xee3, 0x3, 
       0x2, 0x2, 0x2, 0xee5, 0xee6, 0x3, 0x2, 0x2, 0x2, 0xee6, 0xee9, 0x3, 
       0x2, 0x2, 0x2, 0xee7, 0xee5, 0x3, 0x2, 0x2, 0x2, 0xee8, 0xecd, 0x3, 
       0x2, 0x2, 0x2, 0xee8, 0xeda, 0x3, 0x2, 0x2, 0x2, 0xee9, 0x167, 0x3, 
       0x2, 0x2, 0x2, 0xeea, 0xeeb, 0x7, 0xa8, 0x2, 0x2, 0xeeb, 0xeec, 0x7, 
       0x255, 0x2, 0x2, 0xeec, 0xeed, 0x7, 0x1f8, 0x2, 0x2, 0xeed, 0xeef, 
       0x7, 0x285, 0x2, 0x2, 0xeee, 0xef0, 0x5, 0x44a, 0x226, 0x2, 0xeef, 
       0xeee, 0x3, 0x2, 0x2, 0x2, 0xeef, 0xef0, 0x3, 0x2, 0x2, 0x2, 0xef0, 
       0xef1, 0x3, 0x2, 0x2, 0x2, 0xef1, 0xef2, 0x7, 0x313, 0x2, 0x2, 0xef2, 
       0x169, 0x3, 0x2, 0x2, 0x2, 0xef3, 0xef4, 0x7, 0x191, 0x2, 0x2, 0xef4, 
       0xf00, 0x5, 0x32c, 0x197, 0x2, 0xef5, 0xef6, 0x7, 0x95, 0x2, 0x2, 
       0xef6, 0xf00, 0x5, 0x32c, 0x197, 0x2, 0xef7, 0xef8, 0x7, 0x1bd, 0x2, 
       0x2, 0xef8, 0xef9, 0x5, 0x32c, 0x197, 0x2, 0xef9, 0xefa, 0x7, 0x105, 
       0x2, 0x2, 0xefa, 0xefb, 0x7, 0x45, 0x2, 0x2, 0xefb, 0xefc, 0x7, 0x313, 
       0x2, 0x2, 0xefc, 0xf00, 0x3, 0x2, 0x2, 0x2, 0xefd, 0xefe, 0x7, 0x9c, 
       0x2, 0x2, 0xefe, 0xf00, 0x5, 0x32c, 0x197, 0x2, 0xeff, 0xef3, 0x3, 
       0x2, 0x2, 0x2, 0xeff, 0xef5, 0x3, 0x2, 0x2, 0x2, 0xeff, 0xef7, 0x3, 
       0x2, 0x2, 0x2, 0xeff, 0xefd, 0x3, 0x2, 0x2, 0x2, 0xf00, 0x16b, 0x3, 
       0x2, 0x2, 0x2, 0xf01, 0xf05, 0x7, 0xd7, 0x2, 0x2, 0xf02, 0xf03, 0x7, 
       0x21, 0x2, 0x2, 0xf03, 0xf05, 0x5, 0x35c, 0x1af, 0x2, 0xf04, 0xf01, 
       0x3, 0x2, 0x2, 0x2, 0xf04, 0xf02, 0x3, 0x2, 0x2, 0x2, 0xf05, 0x16d, 
       0x3, 0x2, 0x2, 0x2, 0xf06, 0xf07, 0x7, 0x2fb, 0x2, 0x2, 0xf07, 0xf0c, 
       0x5, 0x170, 0xb9, 0x2, 0xf08, 0xf09, 0x7, 0x301, 0x2, 0x2, 0xf09, 
       0xf0b, 0x5, 0x170, 0xb9, 0x2, 0xf0a, 0xf08, 0x3, 0x2, 0x2, 0x2, 0xf0b, 
       0xf0e, 0x3, 0x2, 0x2, 0x2, 0xf0c, 0xf0a, 0x3, 0x2, 0x2, 0x2, 0xf0c, 
       0xf0d, 0x3, 0x2, 0x2, 0x2, 0xf0d, 0xf0f, 0x3, 0x2, 0x2, 0x2, 0xf0e, 
       0xf0c, 0x3, 0x2, 0x2, 0x2, 0xf0f, 0xf10, 0x7, 0x2fc, 0x2, 0x2, 0xf10, 
       0x16f, 0x3, 0x2, 0x2, 0x2, 0xf11, 0xf12, 0x7, 0x1c8, 0x2, 0x2, 0xf12, 
       0xf1e, 0x5, 0x39c, 0x1cf, 0x2, 0xf13, 0xf1c, 0x7, 0x2bf, 0x2, 0x2, 
       0xf14, 0xf15, 0x7, 0x13d, 0x2, 0x2, 0xf15, 0xf16, 0x7, 0x28f, 0x2, 
       0x2, 0xf16, 0xf1d, 0x5, 0x172, 0xba, 0x2, 0xf17, 0xf18, 0x7, 0x10a, 
       0x2, 0x2, 0xf18, 0xf19, 0x7, 0x2fb, 0x2, 0x2, 0xf19, 0xf1a, 0x5, 
       0x174, 0xbb, 0x2, 0xf1a, 0xf1b, 0x7, 0x2fc, 0x2, 0x2, 0xf1b, 0xf1d, 
       0x3, 0x2, 0x2, 0x2, 0xf1c, 0xf14, 0x3, 0x2, 0x2, 0x2, 0xf1c, 0xf17, 
       0x3, 0x2, 0x2, 0x2, 0xf1d, 0xf1f, 0x3, 0x2, 0x2, 0x2, 0xf1e, 0xf13, 
       0x3, 0x2, 0x2, 0x2, 0xf1e, 0xf1f, 0x3, 0x2, 0x2, 0x2, 0xf1f, 0xf23, 
       0x3, 0x2, 0x2, 0x2, 0xf20, 0xf22, 0x5, 0x176, 0xbc, 0x2, 0xf21, 0xf20, 
       0x3, 0x2, 0x2, 0x2, 0xf22, 0xf25, 0x3, 0x2, 0x2, 0x2, 0xf23, 0xf21, 
       0x3, 0x2, 0x2, 0x2, 0xf23, 0xf24, 0x3, 0x2, 0x2, 0x2, 0xf24, 0xf31, 
       0x3, 0x2, 0x2, 0x2, 0xf25, 0xf23, 0x3, 0x2, 0x2, 0x2, 0xf26, 0xf27, 
       0x7, 0x2fb, 0x2, 0x2, 0xf27, 0xf2c, 0x5, 0x178, 0xbd, 0x2, 0xf28, 
       0xf29, 0x7, 0x301, 0x2, 0x2, 0xf29, 0xf2b, 0x5, 0x178, 0xbd, 0x2, 
       0xf2a, 0xf28, 0x3, 0x2, 0x2, 0x2, 0xf2b, 0xf2e, 0x3, 0x2, 0x2, 0x2, 
       0xf2c, 0xf2a, 0x3, 0x2, 0x2, 0x2, 0xf2c, 0xf2d, 0x3, 0x2, 0x2, 0x2, 
       0xf2d, 0xf2f, 0x3, 0x2, 0x2, 0x2, 0xf2e, 0xf2c, 0x3, 0x2, 0x2, 0x2, 
       0xf2f, 0xf30, 0x7, 0x2fc, 0x2, 0x2, 0xf30, 0xf32, 0x3, 0x2, 0x2, 
       0x2, 0xf31, 0xf26, 0x3, 0x2, 0x2, 0x2, 0xf31, 0xf32, 0x3, 0x2, 0x2, 
       0x2, 0xf32, 0x171, 0x3, 0x2, 0x2, 0x2, 0xf33, 0xf36, 0x7, 0x2fb, 
       0x2, 0x2, 0xf34, 0xf37, 0x5, 0x3a6, 0x1d4, 0x2, 0xf35, 0xf37, 0x5, 
       0x174, 0xbb, 0x2, 0xf36, 0xf34, 0x3, 0x2, 0x2, 0x2, 0xf36, 0xf35, 
       0x3, 0x2, 0x2, 0x2, 0xf37, 0xf38, 0x3, 0x2, 0x2, 0x2, 0xf38, 0xf39, 
       0x7, 0x2fc, 0x2, 0x2, 0xf39, 0xf3c, 0x3, 0x2, 0x2, 0x2, 0xf3a, 0xf3c, 
       0x7, 0x171, 0x2, 0x2, 0xf3b, 0xf33, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf3a, 
       0x3, 0x2, 0x2, 0x2, 0xf3c, 0x173, 0x3, 0x2, 0x2, 0x2, 0xf3d, 0xf42, 
       0x5, 0x3a6, 0x1d4, 0x2, 0xf3e, 0xf3f, 0x7, 0x301, 0x2, 0x2, 0xf3f, 
       0xf41, 0x5, 0x3a6, 0x1d4, 0x2, 0xf40, 0xf3e, 0x3, 0x2, 0x2, 0x2, 
       0xf41, 0xf44, 0x3, 0x2, 0x2, 0x2, 0xf42, 0xf40, 0x3, 0x2, 0x2, 0x2, 
       0xf42, 0xf43, 0x3, 0x2, 0x2, 0x2, 0xf43, 0x175, 0x3, 0x2, 0x2, 0x2, 
       0xf44, 0xf42, 0x3, 0x2, 0x2, 0x2, 0xf45, 0xf47, 0x7, 0x278, 0x2, 
       0x2, 0xf46, 0xf45, 0x3, 0x2, 0x2, 0x2, 0xf46, 0xf47, 0x3, 0x2, 0x2, 
       0x2, 0xf47, 0xf48, 0x3, 0x2, 0x2, 0x2, 0xf48, 0xf4a, 0x7, 0xb7, 0x2, 
       0x2, 0xf49, 0xf4b, 0x7, 0x2f4, 0x2, 0x2, 0xf4a, 0xf49, 0x3, 0x2, 
       0x2, 0x2, 0xf4a, 0xf4b, 0x3, 0x2, 0x2, 0x2, 0xf4b, 0xf4c, 0x3, 0x2, 
       0x2, 0x2, 0xf4c, 0xf6e, 0x5, 0x33e, 0x1a0, 0x2, 0xf4d, 0xf4f, 0x7, 
       0x63, 0x2, 0x2, 0xf4e, 0xf50, 0x7, 0x2f4, 0x2, 0x2, 0xf4f, 0xf4e, 
       0x3, 0x2, 0x2, 0x2, 0xf4f, 0xf50, 0x3, 0x2, 0x2, 0x2, 0xf50, 0xf51, 
       0x3, 0x2, 0x2, 0x2, 0xf51, 0xf6e, 0x5, 0x32c, 0x197, 0x2, 0xf52, 
       0xf53, 0x7, 0x83, 0x2, 0x2, 0xf53, 0xf55, 0x7, 0x9f, 0x2, 0x2, 0xf54, 
       0xf56, 0x7, 0x2f4, 0x2, 0x2, 0xf55, 0xf54, 0x3, 0x2, 0x2, 0x2, 0xf55, 
       0xf56, 0x3, 0x2, 0x2, 0x2, 0xf56, 0xf57, 0x3, 0x2, 0x2, 0x2, 0xf57, 
       0xf6e, 0x5, 0x32c, 0x197, 0x2, 0xf58, 0xf59, 0x7, 0x10c, 0x2, 0x2, 
       0xf59, 0xf5b, 0x7, 0x9f, 0x2, 0x2, 0xf5a, 0xf5c, 0x7, 0x2f4, 0x2, 
       0x2, 0xf5b, 0xf5a, 0x3, 0x2, 0x2, 0x2, 0xf5b, 0xf5c, 0x3, 0x2, 0x2, 
       0x2, 0xf5c, 0xf5d, 0x3, 0x2, 0x2, 0x2, 0xf5d, 0xf6e, 0x5, 0x32c, 
       0x197, 0x2, 0xf5e, 0xf60, 0x7, 0x174, 0x2, 0x2, 0xf5f, 0xf61, 0x7, 
       0x2f4, 0x2, 0x2, 0xf60, 0xf5f, 0x3, 0x2, 0x2, 0x2, 0xf60, 0xf61, 
       0x3, 0x2, 0x2, 0x2, 0xf61, 0xf62, 0x3, 0x2, 0x2, 0x2, 0xf62, 0xf6e, 
       0x7, 0x313, 0x2, 0x2, 0xf63, 0xf65, 0x7, 0x186, 0x2, 0x2, 0xf64, 
       0xf66, 0x7, 0x2f4, 0x2, 0x2, 0xf65, 0xf64, 0x3, 0x2, 0x2, 0x2, 0xf65, 
       0xf66, 0x3, 0x2, 0x2, 0x2, 0xf66, 0xf67, 0x3, 0x2, 0x2, 0x2, 0xf67, 
       0xf6e, 0x7, 0x313, 0x2, 0x2, 0xf68, 0xf6a, 0x7, 0x288, 0x2, 0x2, 
       0xf69, 0xf6b, 0x7, 0x2f4, 0x2, 0x2, 0xf6a, 0xf69, 0x3, 0x2, 0x2, 
       0x2, 0xf6a, 0xf6b, 0x3, 0x2, 0x2, 0x2, 0xf6b, 0xf6c, 0x3, 0x2, 0x2, 
       0x2, 0xf6c, 0xf6e, 0x5, 0x33e, 0x1a0, 0x2, 0xf6d, 0xf46, 0x3, 0x2, 
       0x2, 0x2, 0xf6d, 0xf4d, 0x3, 0x2, 0x2, 0x2, 0xf6d, 0xf52, 0x3, 0x2, 
       0x2, 0x2, 0xf6d, 0xf58, 0x3, 0x2, 0x2, 0x2, 0xf6d, 0xf5e, 0x3, 0x2, 
       0x2, 0x2, 0xf6d, 0xf63, 0x3, 0x2, 0x2, 0x2, 0xf6d, 0xf68, 0x3, 0x2, 
       0x2, 0x2, 0xf6e, 0x177, 0x3, 0x2, 0x2, 0x2, 0xf6f, 0xf70, 0x7, 0x27f, 
       0x2, 0x2, 0xf70, 0xf74, 0x5, 0x33e, 0x1a0, 0x2, 0xf71, 0xf73, 0x5, 
       0x176, 0xbc, 0x2, 0xf72, 0xf71, 0x3, 0x2, 0x2, 0x2, 0xf73, 0xf76, 
       0x3, 0x2, 0x2, 0x2, 0xf74, 0xf72, 0x3, 0x2, 0x2, 0x2, 0xf74, 0xf75, 
       0x3, 0x2, 0x2, 0x2, 0xf75, 0x179, 0x3, 0x2, 0x2, 0x2, 0xf76, 0xf74, 
       0x3, 0x2, 0x2, 0x2, 0xf77, 0xf78, 0x7, 0x94, 0x2, 0x2, 0xf78, 0xf7f, 
       0x7, 0x2f4, 0x2, 0x2, 0xf79, 0xf80, 0x5, 0x362, 0x1b2, 0x2, 0xf7a, 
       0xf7d, 0x7, 0x80, 0x2, 0x2, 0xf7b, 0xf7c, 0x7, 0x2fb, 0x2, 0x2, 0xf7c, 
       0xf7e, 0x7, 0x2fc, 0x2, 0x2, 0xf7d, 0xf7b, 0x3, 0x2, 0x2, 0x2, 0xf7d, 
       0xf7e, 0x3, 0x2, 0x2, 0x2, 0xf7e, 0xf80, 0x3, 0x2, 0x2, 0x2, 0xf7f, 
       0xf79, 0x3, 0x2, 0x2, 0x2, 0xf7f, 0xf7a, 0x3, 0x2, 0x2, 0x2, 0xf80, 
       0x17b, 0x3, 0x2, 0x2, 0x2, 0xf81, 0xf82, 0x7, 0x30, 0x2, 0x2, 0xf82, 
       0xf87, 0x5, 0x17e, 0xc0, 0x2, 0xf83, 0xf84, 0x7, 0x2eb, 0x2, 0x2, 
       0xf84, 0xf86, 0x5, 0x410, 0x209, 0x2, 0xf85, 0xf83, 0x3, 0x2, 0x2, 
       0x2, 0xf86, 0xf89, 0x3, 0x2, 0x2, 0x2, 0xf87, 0xf85, 0x3, 0x2, 0x2, 
       0x2, 0xf87, 0xf88, 0x3, 0x2, 0x2, 0x2, 0xf88, 0xfa3, 0x3, 0x2, 0x2, 
       0x2, 0xf89, 0xf87, 0x3, 0x2, 0x2, 0x2, 0xf8a, 0xf8b, 0x7, 0xc1, 0x2, 
       0x2, 0xf8b, 0xf95, 0x5, 0x412, 0x20a, 0x2, 0xf8c, 0xf8d, 0x7, 0x272, 
       0x2, 0x2, 0xf8d, 0xf92, 0x5, 0x17e, 0xc0, 0x2, 0xf8e, 0xf8f, 0x7, 
       0x2eb, 0x2, 0x2, 0xf8f, 0xf91, 0x5, 0x410, 0x209, 0x2, 0xf90, 0xf8e, 
       0x3, 0x2, 0x2, 0x2, 0xf91, 0xf94, 0x3, 0x2, 0x2, 0x2, 0xf92, 0xf90, 
       0x3, 0x2, 0x2, 0x2, 0xf92, 0xf93, 0x3, 0x2, 0x2, 0x2, 0xf93, 0xf96, 
       0x3, 0x2, 0x2, 0x2, 0xf94, 0xf92, 0x3, 0x2, 0x2, 0x2, 0xf95, 0xf8c, 
       0x3, 0x2, 0x2, 0x2, 0xf95, 0xf96, 0x3, 0x2, 0x2, 0x2, 0xf96, 0xfa0, 
       0x3, 0x2, 0x2, 0x2, 0xf97, 0xf98, 0x7, 0xb5, 0x2, 0x2, 0xf98, 0xf9d, 
       0x5, 0x17e, 0xc0, 0x2, 0xf99, 0xf9a, 0x7, 0x2eb, 0x2, 0x2, 0xf9a, 
       0xf9c, 0x5, 0x410, 0x209, 0x2, 0xf9b, 0xf99, 0x3, 0x2, 0x2, 0x2, 
       0xf9c, 0xf9f, 0x3, 0x2, 0x2, 0x2, 0xf9d, 0xf9b, 0x3, 0x2, 0x2, 0x2, 
       0xf9d, 0xf9e, 0x3, 0x2, 0x2, 0x2, 0xf9e, 0xfa1, 0x3, 0x2, 0x2, 0x2, 
       0xf9f, 0xf9d, 0x3, 0x2, 0x2, 0x2, 0xfa0, 0xf97, 0x3, 0x2, 0x2, 0x2, 
       0xfa0, 0xfa1, 0x3, 0x2, 0x2, 0x2, 0xfa1, 0xfa3, 0x3, 0x2, 0x2, 0x2, 
       0xfa2, 0xf81, 0x3, 0x2, 0x2, 0x2, 0xfa2, 0xf8a, 0x3, 0x2, 0x2, 0x2, 
       0xfa3, 0x17d, 0x3, 0x2, 0x2, 0x2, 0xfa4, 0xfa9, 0x7, 0x7f, 0x2, 0x2, 
       0xfa5, 0xfa9, 0x5, 0x32e, 0x198, 0x2, 0xfa6, 0xfa9, 0x5, 0x330, 0x199, 
       0x2, 0xfa7, 0xfa9, 0x5, 0x3a6, 0x1d4, 0x2, 0xfa8, 0xfa4, 0x3, 0x2, 
       0x2, 0x2, 0xfa8, 0xfa5, 0x3, 0x2, 0x2, 0x2, 0xfa8, 0xfa6, 0x3, 0x2, 
       0x2, 0x2, 0xfa8, 0xfa7, 0x3, 0x2, 0x2, 0x2, 0xfa9, 0x17f, 0x3, 0x2, 
       0x2, 0x2, 0xfaa, 0xfad, 0x5, 0x18a, 0xc6, 0x2, 0xfab, 0xfad, 0x5, 
       0x18c, 0xc7, 0x2, 0xfac, 0xfaa, 0x3, 0x2, 0x2, 0x2, 0xfac, 0xfab, 
       0x3, 0x2, 0x2, 0x2, 0xfad, 0x181, 0x3, 0x2, 0x2, 0x2, 0xfae, 0xfaf, 
       0x7, 0xff, 0x2, 0x2, 0xfaf, 0xfbd, 0x5, 0x32c, 0x197, 0x2, 0xfb0, 
       0xfb1, 0x7, 0x84, 0x2, 0x2, 0xfb1, 0xfbd, 0x5, 0x32c, 0x197, 0x2, 
       0xfb2, 0xfb3, 0x7, 0x2b6, 0x2, 0x2, 0xfb3, 0xfbd, 0x5, 0x32c, 0x197, 
       0x2, 0xfb4, 0xfb5, 0x7, 0x1cb, 0x2, 0x2, 0xfb5, 0xfbd, 0x5, 0x32c, 
       0x197, 0x2, 0xfb6, 0xfb7, 0x7, 0x250, 0x2, 0x2, 0xfb7, 0xfbd, 0x5, 
       0x32c, 0x197, 0x2, 0xfb8, 0xfb9, 0x7, 0x1c3, 0x2, 0x2, 0xfb9, 0xfbd, 
       0x5, 0x32c, 0x197, 0x2, 0xfba, 0xfbb, 0x7, 0x1d7, 0x2, 0x2, 0xfbb, 
       0xfbd, 0x5, 0x330, 0x199, 0x2, 0xfbc, 0xfae, 0x3, 0x2, 0x2, 0x2, 
       0xfbc, 0xfb0, 0x3, 0x2, 0x2, 0x2, 0xfbc, 0xfb2, 0x3, 0x2, 0x2, 0x2, 
       0xfbc, 0xfb4, 0x3, 0x2, 0x2, 0x2, 0xfbc, 0xfb6, 0x3, 0x2, 0x2, 0x2, 
       0xfbc, 0xfb8, 0x3, 0x2, 0x2, 0x2, 0xfbc, 0xfba, 0x3, 0x2, 0x2, 0x2, 
       0xfbd, 0x183, 0x3, 0x2, 0x2, 0x2, 0xfbe, 0xfbf, 0x7, 0x63, 0x2, 0x2, 
       0xfbf, 0xfd6, 0x5, 0x32c, 0x197, 0x2, 0xfc0, 0xfc1, 0x7, 0x134, 0x2, 
       0x2, 0xfc1, 0xfd6, 0x7, 0x257, 0x2, 0x2, 0xfc2, 0xfc4, 0x7, 0x1a0, 
       0x2, 0x2, 0xfc3, 0xfc2, 0x3, 0x2, 0x2, 0x2, 0xfc3, 0xfc4, 0x3, 0x2, 
       0x2, 0x2, 0xfc4, 0xfc5, 0x3, 0x2, 0x2, 0x2, 0xfc5, 0xfd6, 0x7, 0x9d, 
       0x2, 0x2, 0xfc6, 0xfc7, 0x7, 0x73, 0x2, 0x2, 0xfc7, 0xfd1, 0x7, 0x257, 
       0x2, 0x2, 0xfc8, 0xfc9, 0x7, 0x19d, 0x2, 0x2, 0xfc9, 0xfd1, 0x7, 
       0x257, 0x2, 0x2, 0xfca, 0xfcb, 0x7, 0x1ef, 0x2, 0x2, 0xfcb, 0xfcc, 
       0x7, 0x257, 0x2, 0x2, 0xfcc, 0xfd1, 0x7, 0x83, 0x2, 0x2, 0xfcd, 0xfce, 
       0x7, 0x189, 0x2, 0x2, 0xfce, 0xfcf, 0x7, 0x257, 0x2, 0x2, 0xfcf, 
       0xfd1, 0x7, 0x83, 0x2, 0x2, 0xfd0, 0xfc6, 0x3, 0x2, 0x2, 0x2, 0xfd0, 
       0xfc8, 0x3, 0x2, 0x2, 0x2, 0xfd0, 0xfca, 0x3, 0x2, 0x2, 0x2, 0xfd0, 
       0xfcd, 0x3, 0x2, 0x2, 0x2, 0xfd1, 0xfd6, 0x3, 0x2, 0x2, 0x2, 0xfd2, 
       0xfd3, 0x7, 0x257, 0x2, 0x2, 0xfd3, 0xfd4, 0x7, 0x23c, 0x2, 0x2, 
       0xfd4, 0xfd6, 0x9, 0x1e, 0x2, 0x2, 0xfd5, 0xfbe, 0x3, 0x2, 0x2, 0x2, 
       0xfd5, 0xfc0, 0x3, 0x2, 0x2, 0x2, 0xfd5, 0xfc3, 0x3, 0x2, 0x2, 0x2, 
       0xfd5, 0xfd0, 0x3, 0x2, 0x2, 0x2, 0xfd5, 0xfd2, 0x3, 0x2, 0x2, 0x2, 
       0xfd6, 0x185, 0x3, 0x2, 0x2, 0x2, 0xfd7, 0xfd9, 0x9, 0x2c, 0x2, 0x2, 
       0xfd8, 0xfd7, 0x3, 0x2, 0x2, 0x2, 0xfd8, 0xfd9, 0x3, 0x2, 0x2, 0x2, 
       0xfd9, 0xfda, 0x3, 0x2, 0x2, 0x2, 0xfda, 0xfdb, 0x5, 0x33e, 0x1a0, 
       0x2, 
  };
  static uint16_t serializedATNSegment2[] = {
    0xfdb, 0xfdc, 0x5, 0x41a, 0x20e, 0x2, 0xfdc, 0x187, 0x3, 0x2, 0x2, 0x2, 
       0xfdd, 0xfe0, 0x7, 0x30d, 0x2, 0x2, 0xfde, 0xfe0, 0x5, 0x330, 0x199, 
       0x2, 0xfdf, 0xfdd, 0x3, 0x2, 0x2, 0x2, 0xfdf, 0xfde, 0x3, 0x2, 0x2, 
       0x2, 0xfe0, 0x189, 0x3, 0x2, 0x2, 0x2, 0xfe1, 0xfe2, 0x5, 0x18e, 
       0xc8, 0x2, 0xfe2, 0x18b, 0x3, 0x2, 0x2, 0x2, 0xfe3, 0xfe4, 0x5, 0x190, 
       0xc9, 0x2, 0xfe4, 0x18d, 0x3, 0x2, 0x2, 0x2, 0xfe5, 0xff6, 0x5, 0xb2, 
       0x5a, 0x2, 0xfe6, 0xff6, 0x5, 0xbe, 0x60, 0x2, 0xfe7, 0xff6, 0x5, 
       0xe6, 0x74, 0x2, 0xfe8, 0xff6, 0x5, 0xee, 0x78, 0x2, 0xfe9, 0xff6, 
       0x5, 0x4, 0x3, 0x2, 0xfea, 0xff6, 0x5, 0x18, 0xd, 0x2, 0xfeb, 0xff6, 
       0x5, 0x20, 0x11, 0x2, 0xfec, 0xff6, 0x5, 0x2e, 0x18, 0x2, 0xfed, 
       0xff6, 0x5, 0x36, 0x1c, 0x2, 0xfee, 0xff6, 0x5, 0x44, 0x23, 0x2, 
       0xfef, 0xff6, 0x5, 0x262, 0x132, 0x2, 0xff0, 0xff6, 0x5, 0x190, 0xc9, 
       0x2, 0xff1, 0xff6, 0x5, 0x192, 0xca, 0x2, 0xff2, 0xff6, 0x5, 0x194, 
       0xcb, 0x2, 0xff3, 0xff6, 0x5, 0x1a6, 0xd4, 0x2, 0xff4, 0xff6, 0x5, 
       0x1b0, 0xd9, 0x2, 0xff5, 0xfe5, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xfe6, 
       0x3, 0x2, 0x2, 0x2, 0xff5, 0xfe7, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xfe8, 
       0x3, 0x2, 0x2, 0x2, 0xff5, 0xfe9, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xfea, 
       0x3, 0x2, 0x2, 0x2, 0xff5, 0xfeb, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xfec, 
       0x3, 0x2, 0x2, 0x2, 0xff5, 0xfed, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xfee, 
       0x3, 0x2, 0x2, 0x2, 0xff5, 0xfef, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xff0, 
       0x3, 0x2, 0x2, 0x2, 0xff5, 0xff1, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xff2, 
       0x3, 0x2, 0x2, 0x2, 0xff5, 0xff3, 0x3, 0x2, 0x2, 0x2, 0xff5, 0xff4, 
       0x3, 0x2, 0x2, 0x2, 0xff6, 0xff8, 0x3, 0x2, 0x2, 0x2, 0xff7, 0xff9, 
       0x7, 0x307, 0x2, 0x2, 0xff8, 0xff7, 0x3, 0x2, 0x2, 0x2, 0xff8, 0xff9, 
       0x3, 0x2, 0x2, 0x2, 0xff9, 0x18f, 0x3, 0x2, 0x2, 0x2, 0xffa, 0xffb, 
       0x5, 0x450, 0x229, 0x2, 0xffb, 0xffc, 0x7, 0x2ea, 0x2, 0x2, 0xffc, 
       0xffe, 0x3, 0x2, 0x2, 0x2, 0xffd, 0xffa, 0x3, 0x2, 0x2, 0x2, 0xffd, 
       0xffe, 0x3, 0x2, 0x2, 0x2, 0xffe, 0xfff, 0x3, 0x2, 0x2, 0x2, 0xfff, 
       0x1003, 0x7, 0x38, 0x2, 0x2, 0x1000, 0x1002, 0x5, 0x18e, 0xc8, 0x2, 
       0x1001, 0x1000, 0x3, 0x2, 0x2, 0x2, 0x1002, 0x1005, 0x3, 0x2, 0x2, 
       0x2, 0x1003, 0x1001, 0x3, 0x2, 0x2, 0x2, 0x1003, 0x1004, 0x3, 0x2, 
       0x2, 0x2, 0x1004, 0x1006, 0x3, 0x2, 0x2, 0x2, 0x1005, 0x1003, 0x3, 
       0x2, 0x2, 0x2, 0x1006, 0x1008, 0x7, 0xb4, 0x2, 0x2, 0x1007, 0x1009, 
       0x5, 0x450, 0x229, 0x2, 0x1008, 0x1007, 0x3, 0x2, 0x2, 0x2, 0x1008, 
       0x1009, 0x3, 0x2, 0x2, 0x2, 0x1009, 0x100b, 0x3, 0x2, 0x2, 0x2, 0x100a, 
       0x100c, 0x7, 0x307, 0x2, 0x2, 0x100b, 0x100a, 0x3, 0x2, 0x2, 0x2, 
       0x100b, 0x100c, 0x3, 0x2, 0x2, 0x2, 0x100c, 0x191, 0x3, 0x2, 0x2, 
       0x2, 0x100d, 0x100e, 0x7, 0x91, 0x2, 0x2, 0x100e, 0x1013, 0x5, 0x344, 
       0x1a3, 0x2, 0x100f, 0x1010, 0x7, 0x301, 0x2, 0x2, 0x1010, 0x1012, 
       0x5, 0x344, 0x1a3, 0x2, 0x1011, 0x100f, 0x3, 0x2, 0x2, 0x2, 0x1012, 
       0x1015, 0x3, 0x2, 0x2, 0x2, 0x1013, 0x1011, 0x3, 0x2, 0x2, 0x2, 0x1013, 
       0x1014, 0x3, 0x2, 0x2, 0x2, 0x1014, 0x1016, 0x3, 0x2, 0x2, 0x2, 0x1015, 
       0x1013, 0x3, 0x2, 0x2, 0x2, 0x1016, 0x101b, 0x5, 0x41a, 0x20e, 0x2, 
       0x1017, 0x1018, 0x7, 0x92, 0x2, 0x2, 0x1018, 0x101a, 0x5, 0x3b4, 
       0x1db, 0x2, 0x1019, 0x1017, 0x3, 0x2, 0x2, 0x2, 0x101a, 0x101d, 0x3, 
       0x2, 0x2, 0x2, 0x101b, 0x1019, 0x3, 0x2, 0x2, 0x2, 0x101b, 0x101c, 
       0x3, 0x2, 0x2, 0x2, 0x101c, 0x193, 0x3, 0x2, 0x2, 0x2, 0x101d, 0x101b, 
       0x3, 0x2, 0x2, 0x2, 0x101e, 0x1027, 0x5, 0x196, 0xcc, 0x2, 0x101f, 
       0x1027, 0x5, 0x198, 0xcd, 0x2, 0x1020, 0x1027, 0x5, 0x19a, 0xce, 
       0x2, 0x1021, 0x1027, 0x5, 0x19c, 0xcf, 0x2, 0x1022, 0x1027, 0x5, 
       0x19e, 0xd0, 0x2, 0x1023, 0x1027, 0x5, 0x1a0, 0xd1, 0x2, 0x1024, 
       0x1027, 0x5, 0x1a2, 0xd2, 0x2, 0x1025, 0x1027, 0x5, 0x1a4, 0xd3, 
       0x2, 0x1026, 0x101e, 0x3, 0x2, 0x2, 0x2, 0x1026, 0x101f, 0x3, 0x2, 
       0x2, 0x2, 0x1026, 0x1020, 0x3, 0x2, 0x2, 0x2, 0x1026, 0x1021, 0x3, 
       0x2, 0x2, 0x2, 0x1026, 0x1022, 0x3, 0x2, 0x2, 0x2, 0x1026, 0x1023, 
       0x3, 0x2, 0x2, 0x2, 0x1026, 0x1024, 0x3, 0x2, 0x2, 0x2, 0x1026, 0x1025, 
       0x3, 0x2, 0x2, 0x2, 0x1027, 0x195, 0x3, 0x2, 0x2, 0x2, 0x1028, 0x102a, 
       0x7, 0x4b, 0x2, 0x2, 0x1029, 0x102b, 0x5, 0x3a6, 0x1d4, 0x2, 0x102a, 
       0x1029, 0x3, 0x2, 0x2, 0x2, 0x102a, 0x102b, 0x3, 0x2, 0x2, 0x2, 0x102b, 
       0x1034, 0x3, 0x2, 0x2, 0x2, 0x102c, 0x102d, 0x7, 0x2cd, 0x2, 0x2, 
       0x102d, 0x102e, 0x5, 0x3a6, 0x1d4, 0x2, 0x102e, 0x1030, 0x7, 0x290, 
       0x2, 0x2, 0x102f, 0x1031, 0x5, 0x18e, 0xc8, 0x2, 0x1030, 0x102f, 
       0x3, 0x2, 0x2, 0x2, 0x1031, 0x1032, 0x3, 0x2, 0x2, 0x2, 0x1032, 0x1030, 
       0x3, 0x2, 0x2, 0x2, 0x1032, 0x1033, 0x3, 0x2, 0x2, 0x2, 0x1033, 0x1035, 
       0x3, 0x2, 0x2, 0x2, 0x1034, 0x102c, 0x3, 0x2, 0x2, 0x2, 0x1035, 0x1036, 
       0x3, 0x2, 0x2, 0x2, 0x1036, 0x1034, 0x3, 0x2, 0x2, 0x2, 0x1036, 0x1037, 
       0x3, 0x2, 0x2, 0x2, 0x1037, 0x103e, 0x3, 0x2, 0x2, 0x2, 0x1038, 0x103a, 
       0x7, 0xae, 0x2, 0x2, 0x1039, 0x103b, 0x5, 0x18e, 0xc8, 0x2, 0x103a, 
       0x1039, 0x3, 0x2, 0x2, 0x2, 0x103b, 0x103c, 0x3, 0x2, 0x2, 0x2, 0x103c, 
       0x103a, 0x3, 0x2, 0x2, 0x2, 0x103c, 0x103d, 0x3, 0x2, 0x2, 0x2, 0x103d, 
       0x103f, 0x3, 0x2, 0x2, 0x2, 0x103e, 0x1038, 0x3, 0x2, 0x2, 0x2, 0x103e, 
       0x103f, 0x3, 0x2, 0x2, 0x2, 0x103f, 0x1040, 0x3, 0x2, 0x2, 0x2, 0x1040, 
       0x1041, 0x7, 0xb4, 0x2, 0x2, 0x1041, 0x1042, 0x7, 0x4b, 0x2, 0x2, 
       0x1042, 0x197, 0x3, 0x2, 0x2, 0x2, 0x1043, 0x1044, 0x7, 0x106, 0x2, 
       0x2, 0x1044, 0x1045, 0x5, 0x3a6, 0x1d4, 0x2, 0x1045, 0x1047, 0x7, 
       0x290, 0x2, 0x2, 0x1046, 0x1048, 0x5, 0x18e, 0xc8, 0x2, 0x1047, 0x1046, 
       0x3, 0x2, 0x2, 0x2, 0x1048, 0x1049, 0x3, 0x2, 0x2, 0x2, 0x1049, 0x1047, 
       0x3, 0x2, 0x2, 0x2, 0x1049, 0x104a, 0x3, 0x2, 0x2, 0x2, 0x104a, 0x1055, 
       0x3, 0x2, 0x2, 0x2, 0x104b, 0x104c, 0x7, 0xaf, 0x2, 0x2, 0x104c, 
       0x104d, 0x5, 0x3a6, 0x1d4, 0x2, 0x104d, 0x104f, 0x7, 0x290, 0x2, 
       0x2, 0x104e, 0x1050, 0x5, 0x18e, 0xc8, 0x2, 0x104f, 0x104e, 0x3, 
       0x2, 0x2, 0x2, 0x1050, 0x1051, 0x3, 0x2, 0x2, 0x2, 0x1051, 0x104f, 
       0x3, 0x2, 0x2, 0x2, 0x1051, 0x1052, 0x3, 0x2, 0x2, 0x2, 0x1052, 0x1054, 
       0x3, 0x2, 0x2, 0x2, 0x1053, 0x104b, 0x3, 0x2, 0x2, 0x2, 0x1054, 0x1057, 
       0x3, 0x2, 0x2, 0x2, 0x1055, 0x1053, 0x3, 0x2, 0x2, 0x2, 0x1055, 0x1056, 
       0x3, 0x2, 0x2, 0x2, 0x1056, 0x105e, 0x3, 0x2, 0x2, 0x2, 0x1057, 0x1055, 
       0x3, 0x2, 0x2, 0x2, 0x1058, 0x105a, 0x7, 0xae, 0x2, 0x2, 0x1059, 
       0x105b, 0x5, 0x18e, 0xc8, 0x2, 0x105a, 0x1059, 0x3, 0x2, 0x2, 0x2, 
       0x105b, 0x105c, 0x3, 0x2, 0x2, 0x2, 0x105c, 0x105a, 0x3, 0x2, 0x2, 
       0x2, 0x105c, 0x105d, 0x3, 0x2, 0x2, 0x2, 0x105d, 0x105f, 0x3, 0x2, 
       0x2, 0x2, 0x105e, 0x1058, 0x3, 0x2, 0x2, 0x2, 0x105e, 0x105f, 0x3, 
       0x2, 0x2, 0x2, 0x105f, 0x1060, 0x3, 0x2, 0x2, 0x2, 0x1060, 0x1061, 
       0x7, 0xb4, 0x2, 0x2, 0x1061, 0x1062, 0x7, 0x106, 0x2, 0x2, 0x1062, 
       0x199, 0x3, 0x2, 0x2, 0x2, 0x1063, 0x1064, 0x7, 0x12a, 0x2, 0x2, 
       0x1064, 0x1065, 0x5, 0x450, 0x229, 0x2, 0x1065, 0x19b, 0x3, 0x2, 
       0x2, 0x2, 0x1066, 0x1067, 0x7, 0x13a, 0x2, 0x2, 0x1067, 0x1068, 0x5, 
       0x450, 0x229, 0x2, 0x1068, 0x19d, 0x3, 0x2, 0x2, 0x2, 0x1069, 0x106a, 
       0x5, 0x450, 0x229, 0x2, 0x106a, 0x106b, 0x7, 0x2ea, 0x2, 0x2, 0x106b, 
       0x106d, 0x3, 0x2, 0x2, 0x2, 0x106c, 0x1069, 0x3, 0x2, 0x2, 0x2, 0x106c, 
       0x106d, 0x3, 0x2, 0x2, 0x2, 0x106d, 0x106e, 0x3, 0x2, 0x2, 0x2, 0x106e, 
       0x1070, 0x7, 0x151, 0x2, 0x2, 0x106f, 0x1071, 0x5, 0x18e, 0xc8, 0x2, 
       0x1070, 0x106f, 0x3, 0x2, 0x2, 0x2, 0x1071, 0x1072, 0x3, 0x2, 0x2, 
       0x2, 0x1072, 0x1070, 0x3, 0x2, 0x2, 0x2, 0x1072, 0x1073, 0x3, 0x2, 
       0x2, 0x2, 0x1073, 0x1074, 0x3, 0x2, 0x2, 0x2, 0x1074, 0x1075, 0x7, 
       0xb4, 0x2, 0x2, 0x1075, 0x1077, 0x7, 0x151, 0x2, 0x2, 0x1076, 0x1078, 
       0x5, 0x450, 0x229, 0x2, 0x1077, 0x1076, 0x3, 0x2, 0x2, 0x2, 0x1077, 
       0x1078, 0x3, 0x2, 0x2, 0x2, 0x1078, 0x19f, 0x3, 0x2, 0x2, 0x2, 0x1079, 
       0x107a, 0x5, 0x450, 0x229, 0x2, 0x107a, 0x107b, 0x7, 0x2ea, 0x2, 
       0x2, 0x107b, 0x107d, 0x3, 0x2, 0x2, 0x2, 0x107c, 0x1079, 0x3, 0x2, 
       0x2, 0x2, 0x107c, 0x107d, 0x3, 0x2, 0x2, 0x2, 0x107d, 0x107e, 0x3, 
       0x2, 0x2, 0x2, 0x107e, 0x1080, 0x7, 0x206, 0x2, 0x2, 0x107f, 0x1081, 
       0x5, 0x18e, 0xc8, 0x2, 0x1080, 0x107f, 0x3, 0x2, 0x2, 0x2, 0x1081, 
       0x1082, 0x3, 0x2, 0x2, 0x2, 0x1082, 0x1080, 0x3, 0x2, 0x2, 0x2, 0x1082, 
       0x1083, 0x3, 0x2, 0x2, 0x2, 0x1083, 0x1084, 0x3, 0x2, 0x2, 0x2, 0x1084, 
       0x1085, 0x7, 0x2b1, 0x2, 0x2, 0x1085, 0x1086, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1086, 0x1087, 0x7, 0xb4, 0x2, 0x2, 0x1087, 0x1089, 0x7, 0x206, 
       0x2, 0x2, 0x1088, 0x108a, 0x5, 0x450, 0x229, 0x2, 0x1089, 0x1088, 
       0x3, 0x2, 0x2, 0x2, 0x1089, 0x108a, 0x3, 0x2, 0x2, 0x2, 0x108a, 0x1a1, 
       0x3, 0x2, 0x2, 0x2, 0x108b, 0x108c, 0x7, 0x21c, 0x2, 0x2, 0x108c, 
       0x108d, 0x5, 0x3a6, 0x1d4, 0x2, 0x108d, 0x1a3, 0x3, 0x2, 0x2, 0x2, 
       0x108e, 0x108f, 0x5, 0x450, 0x229, 0x2, 0x108f, 0x1090, 0x7, 0x2ea, 
       0x2, 0x2, 0x1090, 0x1092, 0x3, 0x2, 0x2, 0x2, 0x1091, 0x108e, 0x3, 
       0x2, 0x2, 0x2, 0x1091, 0x1092, 0x3, 0x2, 0x2, 0x2, 0x1092, 0x1093, 
       0x3, 0x2, 0x2, 0x2, 0x1093, 0x1094, 0x7, 0x2cf, 0x2, 0x2, 0x1094, 
       0x1095, 0x5, 0x3a6, 0x1d4, 0x2, 0x1095, 0x1097, 0x7, 0xa6, 0x2, 0x2, 
       0x1096, 0x1098, 0x5, 0x18e, 0xc8, 0x2, 0x1097, 0x1096, 0x3, 0x2, 
       0x2, 0x2, 0x1098, 0x1099, 0x3, 0x2, 0x2, 0x2, 0x1099, 0x1097, 0x3, 
       0x2, 0x2, 0x2, 0x1099, 0x109a, 0x3, 0x2, 0x2, 0x2, 0x109a, 0x109b, 
       0x3, 0x2, 0x2, 0x2, 0x109b, 0x109c, 0x7, 0xb4, 0x2, 0x2, 0x109c, 
       0x109e, 0x7, 0x2cf, 0x2, 0x2, 0x109d, 0x109f, 0x5, 0x450, 0x229, 
       0x2, 0x109e, 0x109d, 0x3, 0x2, 0x2, 0x2, 0x109e, 0x109f, 0x3, 0x2, 
       0x2, 0x2, 0x109f, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0x10a0, 0x10a5, 0x5, 
       0x1a8, 0xd5, 0x2, 0x10a1, 0x10a5, 0x5, 0x1aa, 0xd6, 0x2, 0x10a2, 
       0x10a5, 0x5, 0x1ac, 0xd7, 0x2, 0x10a3, 0x10a5, 0x5, 0x1ae, 0xd8, 
       0x2, 0x10a4, 0x10a0, 0x3, 0x2, 0x2, 0x2, 0x10a4, 0x10a1, 0x3, 0x2, 
       0x2, 0x2, 0x10a4, 0x10a2, 0x3, 0x2, 0x2, 0x2, 0x10a4, 0x10a3, 0x3, 
       0x2, 0x2, 0x2, 0x10a5, 0x1a7, 0x3, 0x2, 0x2, 0x2, 0x10a6, 0x10a7, 
       0x7, 0x5a, 0x2, 0x2, 0x10a7, 0x10a8, 0x5, 0x452, 0x22a, 0x2, 0x10a8, 
       0x1a9, 0x3, 0x2, 0x2, 0x2, 0x10a9, 0x10aa, 0x7, 0x91, 0x2, 0x2, 0x10aa, 
       0x10ab, 0x5, 0x452, 0x22a, 0x2, 0x10ab, 0x10ac, 0x7, 0x81, 0x2, 0x2, 
       0x10ac, 0x10ad, 0x7, 0xe0, 0x2, 0x2, 0x10ad, 0x10ae, 0x5, 0x36, 0x1c, 
       0x2, 0x10ae, 0x1ab, 0x3, 0x2, 0x2, 0x2, 0x10af, 0x10b4, 0x7, 0xd2, 
       0x2, 0x2, 0x10b0, 0x10b2, 0x7, 0x19c, 0x2, 0x2, 0x10b1, 0x10b0, 0x3, 
       0x2, 0x2, 0x2, 0x10b1, 0x10b2, 0x3, 0x2, 0x2, 0x2, 0x10b2, 0x10b3, 
       0x3, 0x2, 0x2, 0x2, 0x10b3, 0x10b5, 0x7, 0xe5, 0x2, 0x2, 0x10b4, 
       0x10b1, 0x3, 0x2, 0x2, 0x2, 0x10b4, 0x10b5, 0x3, 0x2, 0x2, 0x2, 0x10b5, 
       0x10b6, 0x3, 0x2, 0x2, 0x2, 0x10b6, 0x10b7, 0x5, 0x452, 0x22a, 0x2, 
       0x10b7, 0x10b8, 0x7, 0x11f, 0x2, 0x2, 0x10b8, 0x10bd, 0x5, 0x344, 
       0x1a3, 0x2, 0x10b9, 0x10ba, 0x7, 0x301, 0x2, 0x2, 0x10ba, 0x10bc, 
       0x5, 0x344, 0x1a3, 0x2, 0x10bb, 0x10b9, 0x3, 0x2, 0x2, 0x2, 0x10bc, 
       0x10bf, 0x3, 0x2, 0x2, 0x2, 0x10bd, 0x10bb, 0x3, 0x2, 0x2, 0x2, 0x10bd, 
       0x10be, 0x3, 0x2, 0x2, 0x2, 0x10be, 0x1ad, 0x3, 0x2, 0x2, 0x2, 0x10bf, 
       0x10bd, 0x3, 0x2, 0x2, 0x2, 0x10c0, 0x10c1, 0x7, 0x1b3, 0x2, 0x2, 
       0x10c1, 0x10c2, 0x5, 0x452, 0x22a, 0x2, 0x10c2, 0x1af, 0x3, 0x2, 
       0x2, 0x2, 0x10c3, 0x10c9, 0x5, 0x1b2, 0xda, 0x2, 0x10c4, 0x10c9, 
       0x5, 0x1b4, 0xdb, 0x2, 0x10c5, 0x10c9, 0x5, 0x1b6, 0xdc, 0x2, 0x10c6, 
       0x10c9, 0x5, 0x1c6, 0xe4, 0x2, 0x10c7, 0x10c9, 0x5, 0x1c8, 0xe5, 
       0x2, 0x10c8, 0x10c3, 0x3, 0x2, 0x2, 0x2, 0x10c8, 0x10c4, 0x3, 0x2, 
       0x2, 0x2, 0x10c8, 0x10c5, 0x3, 0x2, 0x2, 0x2, 0x10c8, 0x10c6, 0x3, 
       0x2, 0x2, 0x2, 0x10c8, 0x10c7, 0x3, 0x2, 0x2, 0x2, 0x10c9, 0x1b1, 
       0x3, 0x2, 0x2, 0x2, 0x10ca, 0x10cb, 0x7, 0x91, 0x2, 0x2, 0x10cb, 
       0x10cc, 0x5, 0x454, 0x22b, 0x2, 0x10cc, 0x10cd, 0x7, 0x6c, 0x2, 0x2, 
       0x10cd, 0x10ce, 0x7, 0xe0, 0x2, 0x2, 0x10ce, 0x10cf, 0x5, 0x1c4, 
       0xe3, 0x2, 0x10cf, 0x1b3, 0x3, 0x2, 0x2, 0x2, 0x10d0, 0x10d1, 0x7, 
       0x91, 0x2, 0x2, 0x10d1, 0x10d2, 0x5, 0x1c2, 0xe2, 0x2, 0x10d2, 0x10d3, 
       0x7, 0xf8, 0x2, 0x2, 0x10d3, 0x10d4, 0x7, 0xe0, 0x2, 0x2, 0x10d4, 
       0x10d9, 0x5, 0x1c4, 0xe3, 0x2, 0x10d5, 0x10d6, 0x7, 0x301, 0x2, 0x2, 
       0x10d6, 0x10d8, 0x5, 0x1c4, 0xe3, 0x2, 0x10d7, 0x10d5, 0x3, 0x2, 
       0x2, 0x2, 0x10d8, 0x10db, 0x3, 0x2, 0x2, 0x2, 0x10d9, 0x10d7, 0x3, 
       0x2, 0x2, 0x2, 0x10d9, 0x10da, 0x3, 0x2, 0x2, 0x2, 0x10da, 0x10dc, 
       0x3, 0x2, 0x2, 0x2, 0x10db, 0x10d9, 0x3, 0x2, 0x2, 0x2, 0x10dc, 0x10dd, 
       0x5, 0x18e, 0xc8, 0x2, 0x10dd, 0x1b5, 0x3, 0x2, 0x2, 0x2, 0x10de, 
       0x10e0, 0x7, 0xee, 0x2, 0x2, 0x10df, 0x10e1, 0x9, 0x2d, 0x2, 0x2, 
       0x10e0, 0x10df, 0x3, 0x2, 0x2, 0x2, 0x10e0, 0x10e1, 0x3, 0x2, 0x2, 
       0x2, 0x10e1, 0x10e2, 0x3, 0x2, 0x2, 0x2, 0x10e2, 0x10f5, 0x7, 0x9e, 
       0x2, 0x2, 0x10e3, 0x10e8, 0x5, 0x1b8, 0xdd, 0x2, 0x10e4, 0x10e5, 
       0x7, 0x301, 0x2, 0x2, 0x10e5, 0x10e7, 0x5, 0x1b8, 0xdd, 0x2, 0x10e6, 
       0x10e4, 0x3, 0x2, 0x2, 0x2, 0x10e7, 0x10ea, 0x3, 0x2, 0x2, 0x2, 0x10e8, 
       0x10e6, 0x3, 0x2, 0x2, 0x2, 0x10e8, 0x10e9, 0x3, 0x2, 0x2, 0x2, 0x10e9, 
       0x10f6, 0x3, 0x2, 0x2, 0x2, 0x10ea, 0x10e8, 0x3, 0x2, 0x2, 0x2, 0x10eb, 
       0x10ec, 0x7, 0x6c, 0x2, 0x2, 0x10ec, 0x10ed, 0x5, 0x1bc, 0xdf, 0x2, 
       0x10ed, 0x10f2, 0x5, 0x1ba, 0xde, 0x2, 0x10ee, 0x10ef, 0x7, 0x301, 
       0x2, 0x2, 0x10ef, 0x10f1, 0x5, 0x1ba, 0xde, 0x2, 0x10f0, 0x10ee, 
       0x3, 0x2, 0x2, 0x2, 0x10f1, 0x10f4, 0x3, 0x2, 0x2, 0x2, 0x10f2, 0x10f0, 
       0x3, 0x2, 0x2, 0x2, 0x10f2, 0x10f3, 0x3, 0x2, 0x2, 0x2, 0x10f3, 0x10f6, 
       0x3, 0x2, 0x2, 0x2, 0x10f4, 0x10f2, 0x3, 0x2, 0x2, 0x2, 0x10f5, 0x10e3, 
       0x3, 0x2, 0x2, 0x2, 0x10f5, 0x10eb, 0x3, 0x2, 0x2, 0x2, 0x10f6, 0x1b7, 
       0x3, 0x2, 0x2, 0x2, 0x10f7, 0x10f8, 0x5, 0x344, 0x1a3, 0x2, 0x10f8, 
       0x10f9, 0x7, 0x2f4, 0x2, 0x2, 0x10f9, 0x10fa, 0x5, 0x1be, 0xe0, 0x2, 
       0x10fa, 0x1b9, 0x3, 0x2, 0x2, 0x2, 0x10fb, 0x10fc, 0x5, 0x344, 0x1a3, 
       0x2, 0x10fc, 0x10fd, 0x7, 0x2f4, 0x2, 0x2, 0x10fd, 0x10fe, 0x5, 0x1c0, 
       0xe1, 0x2, 0x10fe, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0x10ff, 0x1102, 0x5, 
       0x344, 0x1a3, 0x2, 0x1100, 0x1102, 0x5, 0x330, 0x199, 0x2, 0x1101, 
       0x10ff, 0x3, 0x2, 0x2, 0x2, 0x1101, 0x1100, 0x3, 0x2, 0x2, 0x2, 0x1102, 
       0x1bd, 0x3, 0x2, 0x2, 0x2, 0x1103, 0x1104, 0x9, 0x2e, 0x2, 0x2, 0x1104, 
       0x1bf, 0x3, 0x2, 0x2, 0x2, 0x1105, 0x1106, 0x9, 0x2f, 0x2, 0x2, 0x1106, 
       0x1c1, 0x3, 0x2, 0x2, 0x2, 0x1107, 0x1108, 0x9, 0x30, 0x2, 0x2, 0x1108, 
       0x1c3, 0x3, 0x2, 0x2, 0x2, 0x1109, 0x1115, 0x5, 0x330, 0x199, 0x2, 
       0x110a, 0x110c, 0x7, 0x25a, 0x2, 0x2, 0x110b, 0x110d, 0x7, 0x2be, 
       0x2, 0x2, 0x110c, 0x110b, 0x3, 0x2, 0x2, 0x2, 0x110c, 0x110d, 0x3, 
       0x2, 0x2, 0x2, 0x110d, 0x110e, 0x3, 0x2, 0x2, 0x2, 0x110e, 0x1115, 
       0x5, 0x32e, 0x198, 0x2, 0x110f, 0x1115, 0x5, 0x454, 0x22b, 0x2, 0x1110, 
       0x1115, 0x7, 0x25b, 0x2, 0x2, 0x1111, 0x1112, 0x7, 0x1a0, 0x2, 0x2, 
       0x1112, 0x1115, 0x7, 0xe4, 0x2, 0x2, 0x1113, 0x1115, 0x7, 0x259, 
       0x2, 0x2, 0x1114, 0x1109, 0x3, 0x2, 0x2, 0x2, 0x1114, 0x110a, 0x3, 
       0x2, 0x2, 0x2, 0x1114, 0x110f, 0x3, 0x2, 0x2, 0x2, 0x1114, 0x1110, 
       0x3, 0x2, 0x2, 0x2, 0x1114, 0x1111, 0x3, 0x2, 0x2, 0x2, 0x1114, 0x1113, 
       0x3, 0x2, 0x2, 0x2, 0x1115, 0x1c5, 0x3, 0x2, 0x2, 0x2, 0x1116, 0x1118, 
       0x7, 0x214, 0x2, 0x2, 0x1117, 0x1119, 0x5, 0x1c4, 0xe3, 0x2, 0x1118, 
       0x1117, 0x3, 0x2, 0x2, 0x2, 0x1118, 0x1119, 0x3, 0x2, 0x2, 0x2, 0x1119, 
       0x1123, 0x3, 0x2, 0x2, 0x2, 0x111a, 0x111b, 0x7, 0x244, 0x2, 0x2, 
       0x111b, 0x1120, 0x5, 0x1ca, 0xe6, 0x2, 0x111c, 0x111d, 0x7, 0x301, 
       0x2, 0x2, 0x111d, 0x111f, 0x5, 0x1ca, 0xe6, 0x2, 0x111e, 0x111c, 
       0x3, 0x2, 0x2, 0x2, 0x111f, 0x1122, 0x3, 0x2, 0x2, 0x2, 0x1120, 0x111e, 
       0x3, 0x2, 0x2, 0x2, 0x1120, 0x1121, 0x3, 0x2, 0x2, 0x2, 0x1121, 0x1124, 
       0x3, 0x2, 0x2, 0x2, 0x1122, 0x1120, 0x3, 0x2, 0x2, 0x2, 0x1123, 0x111a, 
       0x3, 0x2, 0x2, 0x2, 0x1123, 0x1124, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x1c7, 
       0x3, 0x2, 0x2, 0x2, 0x1125, 0x1126, 0x7, 0x248, 0x2, 0x2, 0x1126, 
       0x1130, 0x5, 0x1c4, 0xe3, 0x2, 0x1127, 0x1128, 0x7, 0x244, 0x2, 0x2, 
       0x1128, 0x112d, 0x5, 0x1ca, 0xe6, 0x2, 0x1129, 0x112a, 0x7, 0x301, 
       0x2, 0x2, 0x112a, 0x112c, 0x5, 0x1ca, 0xe6, 0x2, 0x112b, 0x1129, 
       0x3, 0x2, 0x2, 0x2, 0x112c, 0x112f, 0x3, 0x2, 0x2, 0x2, 0x112d, 0x112b, 
       0x3, 0x2, 0x2, 0x2, 0x112d, 0x112e, 0x3, 0x2, 0x2, 0x2, 0x112e, 0x1131, 
       0x3, 0x2, 0x2, 0x2, 0x112f, 0x112d, 0x3, 0x2, 0x2, 0x2, 0x1130, 0x1127, 
       0x3, 0x2, 0x2, 0x2, 0x1130, 0x1131, 0x3, 0x2, 0x2, 0x2, 0x1131, 0x1c9, 
       0x3, 0x2, 0x2, 0x2, 0x1132, 0x1133, 0x5, 0x1c0, 0xe1, 0x2, 0x1133, 
       0x1134, 0x7, 0x2f4, 0x2, 0x2, 0x1134, 0x1135, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1135, 0x1cb, 0x3, 0x2, 0x2, 0x2, 0x1136, 0x1138, 0x7, 0x244, 
       0x2, 0x2, 0x1137, 0x1139, 0x5, 0x34a, 0x1a6, 0x2, 0x1138, 0x1137, 
       0x3, 0x2, 0x2, 0x2, 0x1138, 0x1139, 0x3, 0x2, 0x2, 0x2, 0x1139, 0x113a, 
       0x3, 0x2, 0x2, 0x2, 0x113a, 0x113b, 0x7, 0x29d, 0x2, 0x2, 0x113b, 
       0x1140, 0x5, 0x1e4, 0xf3, 0x2, 0x113c, 0x113d, 0x7, 0x301, 0x2, 0x2, 
       0x113d, 0x113f, 0x5, 0x1e4, 0xf3, 0x2, 0x113e, 0x113c, 0x3, 0x2, 
       0x2, 0x2, 0x113f, 0x1142, 0x3, 0x2, 0x2, 0x2, 0x1140, 0x113e, 0x3, 
       0x2, 0x2, 0x2, 0x1140, 0x1141, 0x3, 0x2, 0x2, 0x2, 0x1141, 0x1cd, 
       0x3, 0x2, 0x2, 0x2, 0x1142, 0x1140, 0x3, 0x2, 0x2, 0x2, 0x1143, 0x1148, 
       0x7, 0x244, 0x2, 0x2, 0x1144, 0x1146, 0x7, 0x306, 0x2, 0x2, 0x1145, 
       0x1144, 0x3, 0x2, 0x2, 0x2, 0x1145, 0x1146, 0x3, 0x2, 0x2, 0x2, 0x1146, 
       0x1147, 0x3, 0x2, 0x2, 0x2, 0x1147, 0x1149, 0x7, 0x306, 0x2, 0x2, 
       0x1148, 0x1145, 0x3, 0x2, 0x2, 0x2, 0x1148, 0x1149, 0x3, 0x2, 0x2, 
       0x2, 0x1149, 0x114b, 0x3, 0x2, 0x2, 0x2, 0x114a, 0x114c, 0x5, 0x34a, 
       0x1a6, 0x2, 0x114b, 0x114a, 0x3, 0x2, 0x2, 0x2, 0x114b, 0x114c, 0x3, 
       0x2, 0x2, 0x2, 0x114c, 0x114e, 0x3, 0x2, 0x2, 0x2, 0x114d, 0x114f, 
       0x7, 0x2f0, 0x2, 0x2, 0x114e, 0x114d, 0x3, 0x2, 0x2, 0x2, 0x114e, 
       0x114f, 0x3, 0x2, 0x2, 0x2, 0x114f, 0x1150, 0x3, 0x2, 0x2, 0x2, 0x1150, 
       0x1151, 0x7, 0x18, 0x2, 0x2, 0x1151, 0x1152, 0x7, 0x2f4, 0x2, 0x2, 
       0x1152, 0x1153, 0x5, 0x1d0, 0xe9, 0x2, 0x1153, 0x1cf, 0x3, 0x2, 0x2, 
       0x2, 0x1154, 0x1155, 0x9, 0x31, 0x2, 0x2, 0x1155, 0x1d1, 0x3, 0x2, 
       0x2, 0x2, 0x1156, 0x1164, 0x7, 0x38, 0x2, 0x2, 0x1157, 0x1158, 0x7, 
       0x270, 0x2, 0x2, 0x1158, 0x1161, 0x7, 0x29d, 0x2, 0x2, 0x1159, 0x115e, 
       0x5, 0x1e4, 0xf3, 0x2, 0x115a, 0x115b, 0x7, 0x301, 0x2, 0x2, 0x115b, 
       0x115d, 0x5, 0x1e4, 0xf3, 0x2, 0x115c, 0x115a, 0x3, 0x2, 0x2, 0x2, 
       0x115d, 0x1160, 0x3, 0x2, 0x2, 0x2, 0x115e, 0x115c, 0x3, 0x2, 0x2, 
       0x2, 0x115e, 0x115f, 0x3, 0x2, 0x2, 0x2, 0x115f, 0x1162, 0x3, 0x2, 
       0x2, 0x2, 0x1160, 0x115e, 0x3, 0x2, 0x2, 0x2, 0x1161, 0x1159, 0x3, 
       0x2, 0x2, 0x2, 0x1161, 0x1162, 0x3, 0x2, 0x2, 0x2, 0x1162, 0x1164, 
       0x3, 0x2, 0x2, 0x2, 0x1163, 0x1156, 0x3, 0x2, 0x2, 0x2, 0x1163, 0x1157, 
       0x3, 0x2, 0x2, 0x2, 0x1164, 0x1d3, 0x3, 0x2, 0x2, 0x2, 0x1165, 0x1167, 
       0x7, 0x64, 0x2, 0x2, 0x1166, 0x1168, 0x7, 0x2d3, 0x2, 0x2, 0x1167, 
       0x1166, 0x3, 0x2, 0x2, 0x2, 0x1167, 0x1168, 0x3, 0x2, 0x2, 0x2, 0x1168, 
       0x116a, 0x3, 0x2, 0x2, 0x2, 0x1169, 0x116b, 0x5, 0x1ea, 0xf6, 0x2, 
       0x116a, 0x1169, 0x3, 0x2, 0x2, 0x2, 0x116a, 0x116b, 0x3, 0x2, 0x2, 
       0x2, 0x116b, 0x116d, 0x3, 0x2, 0x2, 0x2, 0x116c, 0x116e, 0x5, 0x1ec, 
       0xf7, 0x2, 0x116d, 0x116c, 0x3, 0x2, 0x2, 0x2, 0x116d, 0x116e, 0x3, 
       0x2, 0x2, 0x2, 0x116e, 0x1d5, 0x3, 0x2, 0x2, 0x2, 0x116f, 0x1181, 
       0x7, 0x226, 0x2, 0x2, 0x1170, 0x1172, 0x7, 0x2d3, 0x2, 0x2, 0x1171, 
       0x1170, 0x3, 0x2, 0x2, 0x2, 0x1171, 0x1172, 0x3, 0x2, 0x2, 0x2, 0x1172, 
       0x1173, 0x3, 0x2, 0x2, 0x2, 0x1173, 0x1175, 0x7, 0x29b, 0x2, 0x2, 
       0x1174, 0x1176, 0x7, 0x230, 0x2, 0x2, 0x1175, 0x1174, 0x3, 0x2, 0x2, 
       0x2, 0x1175, 0x1176, 0x3, 0x2, 0x2, 0x2, 0x1176, 0x1177, 0x3, 0x2, 
       0x2, 0x2, 0x1177, 0x1182, 0x5, 0x33e, 0x1a0, 0x2, 0x1178, 0x117a, 
       0x7, 0x2d3, 0x2, 0x2, 0x1179, 0x1178, 0x3, 0x2, 0x2, 0x2, 0x1179, 
       0x117a, 0x3, 0x2, 0x2, 0x2, 0x117a, 0x117c, 0x3, 0x2, 0x2, 0x2, 0x117b, 
       0x117d, 0x5, 0x1ea, 0xf6, 0x2, 0x117c, 0x117b, 0x3, 0x2, 0x2, 0x2, 
       0x117c, 0x117d, 0x3, 0x2, 0x2, 0x2, 0x117d, 0x117f, 0x3, 0x2, 0x2, 
       0x2, 0x117e, 0x1180, 0x5, 0x1ec, 0xf7, 0x2, 0x117f, 0x117e, 0x3, 
       0x2, 0x2, 0x2, 0x117f, 0x1180, 0x3, 0x2, 0x2, 0x2, 0x1180, 0x1182, 
       0x3, 0x2, 0x2, 0x2, 0x1181, 0x1171, 0x3, 0x2, 0x2, 0x2, 0x1181, 0x1179, 
       0x3, 0x2, 0x2, 0x2, 0x1182, 0x1d7, 0x3, 0x2, 0x2, 0x2, 0x1183, 0x1184, 
       0x7, 0x230, 0x2, 0x2, 0x1184, 0x1185, 0x5, 0x33e, 0x1a0, 0x2, 0x1185, 
       0x1d9, 0x3, 0x2, 0x2, 0x2, 0x1186, 0x1188, 0x7, 0x38, 0x2, 0x2, 0x1187, 
       0x1189, 0x7, 0x2d3, 0x2, 0x2, 0x1188, 0x1187, 0x3, 0x2, 0x2, 0x2, 
       0x1188, 0x1189, 0x3, 0x2, 0x2, 0x2, 0x1189, 0x1db, 0x3, 0x2, 0x2, 
       0x2, 0x118a, 0x1197, 0x7, 0x149, 0x2, 0x2, 0x118b, 0x118c, 0x7, 0x116, 
       0x2, 0x2, 0x118c, 0x118d, 0x7, 0xe0, 0x2, 0x2, 0x118d, 0x1198, 0x7, 
       0x36, 0x2, 0x2, 0x118e, 0x118f, 0x9, 0x32, 0x2, 0x2, 0x118f, 0x1194, 
       0x5, 0x1ee, 0xf8, 0x2, 0x1190, 0x1191, 0x7, 0x301, 0x2, 0x2, 0x1191, 
       0x1193, 0x5, 0x1ee, 0xf8, 0x2, 0x1192, 0x1190, 0x3, 0x2, 0x2, 0x2, 
       0x1193, 0x1196, 0x3, 0x2, 0x2, 0x2, 0x1194, 0x1192, 0x3, 0x2, 0x2, 
       0x2, 0x1194, 0x1195, 0x3, 0x2, 0x2, 0x2, 0x1195, 0x1198, 0x3, 0x2, 
       0x2, 0x2, 0x1196, 0x1194, 0x3, 0x2, 0x2, 0x2, 0x1197, 0x118b, 0x3, 
       0x2, 0x2, 0x2, 0x1197, 0x118e, 0x3, 0x2, 0x2, 0x2, 0x1198, 0x1dd, 
       0x3, 0x2, 0x2, 0x2, 0x1199, 0x119a, 0x7, 0x2af, 0x2, 0x2, 0x119a, 
       0x119b, 0x9, 0x33, 0x2, 0x2, 0x119b, 0x1df, 0x3, 0x2, 0x2, 0x2, 0x119c, 
       0x119d, 0x7, 0x200, 0x2, 0x2, 0x119d, 0x119e, 0x7, 0x230, 0x2, 0x2, 
       0x119e, 0x119f, 0x5, 0x33e, 0x1a0, 0x2, 0x119f, 0x1e1, 0x3, 0x2, 
       0x2, 0x2, 0x11a0, 0x11bd, 0x7, 0x2d7, 0x2, 0x2, 0x11a1, 0x11a2, 0x9, 
       0x34, 0x2, 0x2, 0x11a2, 0x11a3, 0x5, 0x1f2, 0xfa, 0x2, 0x11a3, 0x11a4, 
       0x9, 0x35, 0x2, 0x2, 0x11a4, 0x11be, 0x3, 0x2, 0x2, 0x2, 0x11a5, 
       0x11a6, 0x7, 0xb4, 0x2, 0x2, 0x11a6, 0x11ac, 0x5, 0x1f2, 0xfa, 0x2, 
       0x11a7, 0x11aa, 0x7, 0x282, 0x2, 0x2, 0x11a8, 0x11a9, 0x7, 0xe0, 
       0x2, 0x2, 0x11a9, 0x11ab, 0x7, 0x182, 0x2, 0x2, 0x11aa, 0x11a8, 0x3, 
       0x2, 0x2, 0x2, 0x11aa, 0x11ab, 0x3, 0x2, 0x2, 0x2, 0x11ab, 0x11ad, 
       0x3, 0x2, 0x2, 0x2, 0x11ac, 0x11a7, 0x3, 0x2, 0x2, 0x2, 0x11ac, 0x11ad, 
       0x3, 0x2, 0x2, 0x2, 0x11ad, 0x11be, 0x3, 0x2, 0x2, 0x2, 0x11ae, 0x11af, 
       0x7, 0x1db, 0x2, 0x2, 0x11af, 0x11be, 0x5, 0x1f2, 0xfa, 0x2, 0x11b0, 
       0x11b1, 0x7, 0x64, 0x2, 0x2, 0x11b1, 0x11b4, 0x5, 0x1f2, 0xfa, 0x2, 
       0x11b2, 0x11b3, 0x7, 0x1b1, 0x2, 0x2, 0x11b3, 0x11b5, 0x7, 0x1d1, 
       0x2, 0x2, 0x11b4, 0x11b2, 0x3, 0x2, 0x2, 0x2, 0x11b4, 0x11b5, 0x3, 
       0x2, 0x2, 0x2, 0x11b5, 0x11be, 0x3, 0x2, 0x2, 0x2, 0x11b6, 0x11b7, 
       0x7, 0x226, 0x2, 0x2, 0x11b7, 0x11be, 0x5, 0x1f2, 0xfa, 0x2, 0x11b8, 
       0x11bb, 0x7, 0x1f4, 0x2, 0x2, 0x11b9, 0x11ba, 0x7, 0x76, 0x2, 0x2, 
       0x11ba, 0x11bc, 0x5, 0x1f2, 0xfa, 0x2, 0x11bb, 0x11b9, 0x3, 0x2, 
       0x2, 0x2, 0x11bb, 0x11bc, 0x3, 0x2, 0x2, 0x2, 0x11bc, 0x11be, 0x3, 
       0x2, 0x2, 0x2, 0x11bd, 0x11a1, 0x3, 0x2, 0x2, 0x2, 0x11bd, 0x11a5, 
       0x3, 0x2, 0x2, 0x2, 0x11bd, 0x11ae, 0x3, 0x2, 0x2, 0x2, 0x11bd, 0x11b0, 
       0x3, 0x2, 0x2, 0x2, 0x11bd, 0x11b6, 0x3, 0x2, 0x2, 0x2, 0x11bd, 0x11b8, 
       0x3, 0x2, 0x2, 0x2, 0x11be, 0x1e3, 0x3, 0x2, 0x2, 0x2, 0x11bf, 0x11c0, 
       0x7, 0x128, 0x2, 0x2, 0x11c0, 0x11c1, 0x7, 0x13e, 0x2, 0x2, 0x11c1, 
       0x11c7, 0x5, 0x1e6, 0xf4, 0x2, 0x11c2, 0x11c7, 0x5, 0x1e8, 0xf5, 
       0x2, 0x11c3, 0x11c4, 0x7, 0x2d1, 0x2, 0x2, 0x11c4, 0x11c5, 0x7, 0x6e, 
       0x2, 0x2, 0x11c5, 0x11c7, 0x7, 0x24f, 0x2, 0x2, 0x11c6, 0x11bf, 0x3, 
       0x2, 0x2, 0x2, 0x11c6, 0x11c2, 0x3, 0x2, 0x2, 0x2, 0x11c6, 0x11c3, 
       0x3, 0x2, 0x2, 0x2, 0x11c7, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x11c8, 0x11c9, 
       0x7, 0x207, 0x2, 0x2, 0x11c9, 0x11d0, 0x7, 0x1ee, 0x2, 0x2, 0x11ca, 
       0x11cb, 0x7, 0x1ee, 0x2, 0x2, 0x11cb, 0x11d0, 0x7, 0x65, 0x2, 0x2, 
       0x11cc, 0x11cd, 0x7, 0x1ee, 0x2, 0x2, 0x11cd, 0x11d0, 0x7, 0x2a5, 
       0x2, 0x2, 0x11ce, 0x11d0, 0x7, 0x241, 0x2, 0x2, 0x11cf, 0x11c8, 0x3, 
       0x2, 0x2, 0x2, 0x11cf, 0x11ca, 0x3, 0x2, 0x2, 0x2, 0x11cf, 0x11cc, 
       0x3, 0x2, 0x2, 0x2, 0x11cf, 0x11ce, 0x3, 0x2, 0x2, 0x2, 0x11d0, 0x1e7, 
       0x3, 0x2, 0x2, 0x2, 0x11d1, 0x11d2, 0x7, 0x1ee, 0x2, 0x2, 0x11d2, 
       0x11d3, 0x9, 0x36, 0x2, 0x2, 0x11d3, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0x11d4, 
       0x11d6, 0x7, 0x29, 0x2, 0x2, 0x11d5, 0x11d7, 0x7, 0x19d, 0x2, 0x2, 
       0x11d6, 0x11d5, 0x3, 0x2, 0x2, 0x2, 0x11d6, 0x11d7, 0x3, 0x2, 0x2, 
       0x2, 0x11d7, 0x11d8, 0x3, 0x2, 0x2, 0x2, 0x11d8, 0x11d9, 0x7, 0x4d, 
       0x2, 0x2, 0x11d9, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0x11da, 0x11dc, 0x7, 
       0x19d, 0x2, 0x2, 0x11db, 0x11da, 0x3, 0x2, 0x2, 0x2, 0x11db, 0x11dc, 
       0x3, 0x2, 0x2, 0x2, 0x11dc, 0x11dd, 0x3, 0x2, 0x2, 0x2, 0x11dd, 0x11de, 
       0x7, 0x200, 0x2, 0x2, 0x11de, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x11df, 
       0x11e4, 0x5, 0x35a, 0x1ae, 0x2, 0x11e0, 0x11e2, 0x7, 0x2c, 0x2, 0x2, 
       0x11e1, 0x11e0, 0x3, 0x2, 0x2, 0x2, 0x11e1, 0x11e2, 0x3, 0x2, 0x2, 
       0x2, 0x11e2, 0x11e3, 0x3, 0x2, 0x2, 0x2, 0x11e3, 0x11e5, 0x5, 0x370, 
       0x1b9, 0x2, 0x11e4, 0x11e1, 0x3, 0x2, 0x2, 0x2, 0x11e4, 0x11e5, 0x3, 
       0x2, 0x2, 0x2, 0x11e5, 0x11e6, 0x3, 0x2, 0x2, 0x2, 0x11e6, 0x11e7, 
       0x5, 0x1f0, 0xf9, 0x2, 0x11e7, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0x11e8, 
       0x11ea, 0x7, 0x1ee, 0x2, 0x2, 0x11e9, 0x11eb, 0x7, 0x146, 0x2, 0x2, 
       0x11ea, 0x11e9, 0x3, 0x2, 0x2, 0x2, 0x11ea, 0x11eb, 0x3, 0x2, 0x2, 
       0x2, 0x11eb, 0x11f1, 0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11ee, 0x7, 0x152, 
       0x2, 0x2, 0x11ed, 0x11ec, 0x3, 0x2, 0x2, 0x2, 0x11ed, 0x11ee, 0x3, 
       0x2, 0x2, 0x2, 0x11ee, 0x11ef, 0x3, 0x2, 0x2, 0x2, 0x11ef, 0x11f1, 
       0x7, 0x2d5, 0x2, 0x2, 0x11f0, 0x11e8, 0x3, 0x2, 0x2, 0x2, 0x11f0, 
       0x11ed, 0x3, 0x2, 0x2, 0x2, 0x11f1, 0x1f1, 0x3, 0x2, 0x2, 0x2, 0x11f2, 
       0x11f7, 0x5, 0x32c, 0x197, 0x2, 0x11f3, 0x11f4, 0x7, 0x301, 0x2, 
       0x2, 0x11f4, 0x11f6, 0x5, 0x32c, 0x197, 0x2, 0x11f5, 0x11f3, 0x3, 
       0x2, 0x2, 0x2, 0x11f6, 0x11f9, 0x3, 0x2, 0x2, 0x2, 0x11f7, 0x11f5, 
       0x3, 0x2, 0x2, 0x2, 0x11f7, 0x11f8, 0x3, 0x2, 0x2, 0x2, 0x11f8, 0x11fb, 
       0x3, 0x2, 0x2, 0x2, 0x11f9, 0x11f7, 0x3, 0x2, 0x2, 0x2, 0x11fa, 0x11fc, 
       0x5, 0x330, 0x199, 0x2, 0x11fb, 0x11fa, 0x3, 0x2, 0x2, 0x2, 0x11fb, 
       0x11fc, 0x3, 0x2, 0x2, 0x2, 0x11fc, 0x1f3, 0x3, 0x2, 0x2, 0x2, 0x11fd, 
       0x1201, 0x7, 0xf2, 0x2, 0x2, 0x11fe, 0x1202, 0x5, 0x1f8, 0xfd, 0x2, 
       0x11ff, 0x1202, 0x5, 0x1fa, 0xfe, 0x2, 0x1200, 0x1202, 0x5, 0x1fc, 
       0xff, 0x2, 0x1201, 0x11fe, 0x3, 0x2, 0x2, 0x2, 0x1201, 0x11ff, 0x3, 
       0x2, 0x2, 0x2, 0x1201, 0x1200, 0x3, 0x2, 0x2, 0x2, 0x1202, 0x1f5, 
       0x3, 0x2, 0x2, 0x2, 0x1203, 0x1208, 0x7, 0x222, 0x2, 0x2, 0x1204, 
       0x1209, 0x5, 0x1f8, 0xfd, 0x2, 0x1205, 0x1209, 0x5, 0x1fa, 0xfe, 
       0x2, 0x1206, 0x1209, 0x5, 0x1fe, 0x100, 0x2, 0x1207, 0x1209, 0x5, 
       0x1fc, 0xff, 0x2, 0x1208, 0x1204, 0x3, 0x2, 0x2, 0x2, 0x1208, 0x1205, 
       0x3, 0x2, 0x2, 0x2, 0x1208, 0x1206, 0x3, 0x2, 0x2, 0x2, 0x1208, 0x1207, 
       0x3, 0x2, 0x2, 0x2, 0x1209, 0x1f7, 0x3, 0x2, 0x2, 0x2, 0x120a, 0x120b, 
       0x7, 0x1e6, 0x2, 0x2, 0x120b, 0x120c, 0x7, 0x1b0, 0x2, 0x2, 0x120c, 
       0x120d, 0x5, 0x39a, 0x1ce, 0x2, 0x120d, 0x120e, 0x7, 0x29b, 0x2, 
       0x2, 0x120e, 0x1210, 0x5, 0x230, 0x119, 0x2, 0x120f, 0x1211, 0x5, 
       0x22e, 0x118, 0x2, 0x1210, 0x120f, 0x3, 0x2, 0x2, 0x2, 0x1210, 0x1211, 
       0x3, 0x2, 0x2, 0x2, 0x1211, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0x1212, 0x1213, 
       0x5, 0x200, 0x101, 0x2, 0x1213, 0x1214, 0x7, 0x1b0, 0x2, 0x2, 0x1214, 
       0x1215, 0x5, 0x206, 0x104, 0x2, 0x1215, 0x1216, 0x9, 0x37, 0x2, 0x2, 
       0x1216, 0x1218, 0x5, 0x230, 0x119, 0x2, 0x1217, 0x1219, 0x5, 0x22e, 
       0x118, 0x2, 0x1218, 0x1217, 0x3, 0x2, 0x2, 0x2, 0x1218, 0x1219, 0x3, 
       0x2, 0x2, 0x2, 0x1219, 0x121b, 0x3, 0x2, 0x2, 0x2, 0x121a, 0x121c, 
       0x5, 0x234, 0x11b, 0x2, 0x121b, 0x121a, 0x3, 0x2, 0x2, 0x2, 0x121b, 
       0x121c, 0x3, 0x2, 0x2, 0x2, 0x121c, 0x1fb, 0x3, 0x2, 0x2, 0x2, 0x121d, 
       0x121e, 0x5, 0x232, 0x11a, 0x2, 0x121e, 0x121f, 0x9, 0x37, 0x2, 0x2, 
       0x121f, 0x1221, 0x5, 0x230, 0x119, 0x2, 0x1220, 0x1222, 0x5, 0x22e, 
       0x118, 0x2, 0x1221, 0x1220, 0x3, 0x2, 0x2, 0x2, 0x1221, 0x1222, 0x3, 
       0x2, 0x2, 0x2, 0x1222, 0x1fd, 0x3, 0x2, 0x2, 0x2, 0x1223, 0x1225, 
       0x7, 0x25, 0x2, 0x2, 0x1224, 0x1226, 0x7, 0x1df, 0x2, 0x2, 0x1225, 
       0x1224, 0x3, 0x2, 0x2, 0x2, 0x1225, 0x1226, 0x3, 0x2, 0x2, 0x2, 0x1226, 
       0x1227, 0x3, 0x2, 0x2, 0x2, 0x1227, 0x1228, 0x7, 0x301, 0x2, 0x2, 
       0x1228, 0x1229, 0x7, 0xf2, 0x2, 0x2, 0x1229, 0x122a, 0x7, 0x1b6, 
       0x2, 0x2, 0x122a, 0x122b, 0x7, 0xe5, 0x2, 0x2, 0x122b, 0x122c, 0x5, 
       0x230, 0x119, 0x2, 0x122c, 0x1ff, 0x3, 0x2, 0x2, 0x2, 0x122d, 0x1232, 
       0x5, 0x202, 0x102, 0x2, 0x122e, 0x122f, 0x7, 0x301, 0x2, 0x2, 0x122f, 
       0x1231, 0x5, 0x202, 0x102, 0x2, 0x1230, 0x122e, 0x3, 0x2, 0x2, 0x2, 
       0x1231, 0x1234, 0x3, 0x2, 0x2, 0x2, 0x1232, 0x1230, 0x3, 0x2, 0x2, 
       0x2, 0x1232, 0x1233, 0x3, 0x2, 0x2, 0x2, 0x1233, 0x201, 0x3, 0x2, 
       0x2, 0x2, 0x1234, 0x1232, 0x3, 0x2, 0x2, 0x2, 0x1235, 0x123a, 0x5, 
       0x204, 0x103, 0x2, 0x1236, 0x1237, 0x7, 0x2fb, 0x2, 0x2, 0x1237, 
       0x1238, 0x5, 0x378, 0x1bd, 0x2, 0x1238, 0x1239, 0x7, 0x2fc, 0x2, 
       0x2, 0x1239, 0x123b, 0x3, 0x2, 0x2, 0x2, 0x123a, 0x1236, 0x3, 0x2, 
       0x2, 0x2, 0x123a, 0x123b, 0x3, 0x2, 0x2, 0x2, 0x123b, 0x203, 0x3, 
       0x2, 0x2, 0x2, 0x123c, 0x123e, 0x7, 0x25, 0x2, 0x2, 0x123d, 0x123f, 
       0x7, 0x1df, 0x2, 0x2, 0x123e, 0x123d, 0x3, 0x2, 0x2, 0x2, 0x123e, 
       0x123f, 0x3, 0x2, 0x2, 0x2, 0x123f, 0x1271, 0x3, 0x2, 0x2, 0x2, 0x1240, 
       0x1242, 0x7, 0x26, 0x2, 0x2, 0x1241, 0x1243, 0x7, 0x229, 0x2, 0x2, 
       0x1242, 0x1241, 0x3, 0x2, 0x2, 0x2, 0x1242, 0x1243, 0x3, 0x2, 0x2, 
       0x2, 0x1243, 0x1271, 0x3, 0x2, 0x2, 0x2, 0x1244, 0x1271, 0x7, 0x78, 
       0x2, 0x2, 0x1245, 0x1246, 0x7, 0x78, 0x2, 0x2, 0x1246, 0x1271, 0x7, 
       0x229, 0x2, 0x2, 0x1247, 0x1248, 0x7, 0x78, 0x2, 0x2, 0x1248, 0x1271, 
       0x7, 0x288, 0x2, 0x2, 0x1249, 0x124a, 0x7, 0x78, 0x2, 0x2, 0x124a, 
       0x124b, 0x7, 0x28b, 0x2, 0x2, 0x124b, 0x1271, 0x7, 0x287, 0x2, 0x2, 
       0x124c, 0x124d, 0x7, 0x78, 0x2, 0x2, 0x124d, 0x1271, 0x7, 0x2b6, 
       0x2, 0x2, 0x124e, 0x124f, 0x7, 0x78, 0x2, 0x2, 0x124f, 0x1271, 0x7, 
       0x2c6, 0x2, 0x2, 0x1250, 0x1271, 0x7, 0x98, 0x2, 0x2, 0x1251, 0x1271, 
       0x7, 0xa8, 0x2, 0x2, 0x1252, 0x1253, 0x7, 0xa8, 0x2, 0x2, 0x1253, 
       0x1271, 0x7, 0x225, 0x2, 0x2, 0x1254, 0x1271, 0x7, 0xbf, 0x2, 0x2, 
       0x1255, 0x1271, 0x7, 0xc5, 0x2, 0x2, 0x1256, 0x1271, 0x7, 0xd4, 0x2, 
       0x2, 0x1257, 0x1258, 0x7, 0xf2, 0x2, 0x2, 0x1258, 0x1271, 0x7, 0x1b6, 
       0x2, 0x2, 0x1259, 0x1271, 0x7, 0x10c, 0x2, 0x2, 0x125a, 0x1271, 0x7, 
       0x113, 0x2, 0x2, 0x125b, 0x125c, 0x7, 0x149, 0x2, 0x2, 0x125c, 0x1271, 
       0x7, 0x287, 0x2, 0x2, 0x125d, 0x1271, 0x7, 0x1e2, 0x2, 0x2, 0x125e, 
       0x1271, 0x7, 0x1e6, 0x2, 0x2, 0x125f, 0x1271, 0x7, 0x1f9, 0x2, 0x2, 
       0x1260, 0x1271, 0x7, 0x201, 0x2, 0x2, 0x1261, 0x1262, 0x7, 0x210, 
       0x2, 0x2, 0x1262, 0x1271, 0x7, 0x58, 0x2, 0x2, 0x1263, 0x1264, 0x7, 
       0x210, 0x2, 0x2, 0x1264, 0x1271, 0x7, 0x24c, 0x2, 0x2, 0x1265, 0x1271, 
       0x7, 0x23d, 0x2, 0x2, 0x1266, 0x1267, 0x7, 0x246, 0x2, 0x2, 0x1267, 
       0x1271, 0x7, 0x85, 0x2, 0x2, 0x1268, 0x1269, 0x7, 0x246, 0x2, 0x2, 
       0x1269, 0x1271, 0x7, 0x2c6, 0x2, 0x2, 0x126a, 0x1271, 0x7, 0x247, 
       0x2, 0x2, 0x126b, 0x1271, 0x7, 0x281, 0x2, 0x2, 0x126c, 0x1271, 0x7, 
       0x29e, 0x2, 0x2, 0x126d, 0x1271, 0x7, 0x2b2, 0x2, 0x2, 0x126e, 0x1271, 
       0x7, 0x2b4, 0x2, 0x2, 0x126f, 0x1271, 0x5, 0x33e, 0x1a0, 0x2, 0x1270, 
       0x123c, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1240, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1244, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1245, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1247, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1249, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x124c, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x124e, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1250, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1251, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1252, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1254, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1255, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1256, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1257, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1259, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x125a, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x125b, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x125d, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x125e, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x125f, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1260, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1261, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1263, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1265, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x1266, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x1268, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x126a, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x126b, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x126c, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x126d, 0x3, 0x2, 0x2, 0x2, 0x1270, 0x126e, 0x3, 0x2, 0x2, 0x2, 0x1270, 
       0x126f, 0x3, 0x2, 0x2, 0x2, 0x1271, 0x205, 0x3, 0x2, 0x2, 0x2, 0x1272, 
       0x1274, 0x5, 0x208, 0x105, 0x2, 0x1273, 0x1272, 0x3, 0x2, 0x2, 0x2, 
       0x1273, 0x1274, 0x3, 0x2, 0x2, 0x2, 0x1274, 0x1275, 0x3, 0x2, 0x2, 
       0x2, 0x1275, 0x1276, 0x5, 0x20a, 0x106, 0x2, 0x1276, 0x207, 0x3, 
       0x2, 0x2, 0x2, 0x1277, 0x1278, 0x9, 0x38, 0x2, 0x2, 0x1278, 0x209, 
       0x3, 0x2, 0x2, 0x2, 0x1279, 0x1285, 0x7, 0x2ed, 0x2, 0x2, 0x127a, 
       0x127b, 0x7, 0x2ed, 0x2, 0x2, 0x127b, 0x1285, 0x7, 0x2f1, 0x2, 0x2, 
       0x127c, 0x127d, 0x5, 0x33e, 0x1a0, 0x2, 0x127d, 0x127e, 0x7, 0x2f1, 
       0x2, 0x2, 0x127e, 0x1285, 0x3, 0x2, 0x2, 0x2, 0x127f, 0x1285, 0x5, 
       0x35a, 0x1ae, 0x2, 0x1280, 0x1281, 0x5, 0x350, 0x1a9, 0x2, 0x1281, 
       0x1282, 0x7, 0x2f0, 0x2, 0x2, 0x1282, 0x1283, 0x5, 0x37c, 0x1bf, 
       0x2, 0x1283, 0x1285, 0x3, 0x2, 0x2, 0x2, 0x1284, 0x1279, 0x3, 0x2, 
       0x2, 0x2, 0x1284, 0x127a, 0x3, 0x2, 0x2, 0x2, 0x1284, 0x127c, 0x3, 
       0x2, 0x2, 0x2, 0x1284, 0x127f, 0x3, 0x2, 0x2, 0x2, 0x1284, 0x1280, 
       0x3, 0x2, 0x2, 0x2, 0x1285, 0x20b, 0x3, 0x2, 0x2, 0x2, 0x1286, 0x1287, 
       0x7, 0x78, 0x2, 0x2, 0x1287, 0x128b, 0x7, 0x2b6, 0x2, 0x2, 0x1288, 
       0x1289, 0x7, 0x106, 0x2, 0x2, 0x1289, 0x128a, 0x7, 0x1a0, 0x2, 0x2, 
       0x128a, 0x128c, 0x7, 0xc6, 0x2, 0x2, 0x128b, 0x1288, 0x3, 0x2, 0x2, 
       0x2, 0x128b, 0x128c, 0x3, 0x2, 0x2, 0x2, 0x128c, 0x128d, 0x3, 0x2, 
       0x2, 0x2, 0x128d, 0x128f, 0x5, 0x21c, 0x10f, 0x2, 0x128e, 0x1290, 
       0x5, 0x20e, 0x108, 0x2, 0x128f, 0x128e, 0x3, 0x2, 0x2, 0x2, 0x128f, 
       0x1290, 0x3, 0x2, 0x2, 0x2, 0x1290, 0x1292, 0x3, 0x2, 0x2, 0x2, 0x1291, 
       0x1293, 0x5, 0x210, 0x109, 0x2, 0x1292, 0x1291, 0x3, 0x2, 0x2, 0x2, 
       0x1292, 0x1293, 0x3, 0x2, 0x2, 0x2, 0x1293, 0x1295, 0x3, 0x2, 0x2, 
       0x2, 0x1294, 0x1296, 0x5, 0x212, 0x10a, 0x2, 0x1295, 0x1294, 0x3, 
       0x2, 0x2, 0x2, 0x1295, 0x1296, 0x3, 0x2, 0x2, 0x2, 0x1296, 0x1298, 
       0x3, 0x2, 0x2, 0x2, 0x1297, 0x1299, 0x5, 0x214, 0x10b, 0x2, 0x1298, 
       0x1297, 0x3, 0x2, 0x2, 0x2, 0x1298, 0x1299, 0x3, 0x2, 0x2, 0x2, 0x1299, 
       0x20d, 0x3, 0x2, 0x2, 0x2, 0x129a, 0x129b, 0x7, 0x92, 0x2, 0x2, 0x129b, 
       0x129c, 0x7, 0x225, 0x2, 0x2, 0x129c, 0x12a1, 0x5, 0x390, 0x1c9, 
       0x2, 0x129d, 0x129e, 0x7, 0x301, 0x2, 0x2, 0x129e, 0x12a0, 0x5, 0x390, 
       0x1c9, 0x2, 0x129f, 0x129d, 0x3, 0x2, 0x2, 0x2, 0x12a0, 0x12a3, 0x3, 
       0x2, 0x2, 0x2, 0x12a1, 0x129f, 0x3, 0x2, 0x2, 0x2, 0x12a1, 0x12a2, 
       0x3, 0x2, 0x2, 0x2, 0x12a2, 0x20f, 0x3, 0x2, 0x2, 0x2, 0x12a3, 0x12a1, 
       0x3, 0x2, 0x2, 0x2, 0x12a4, 0x12b0, 0x7, 0x211, 0x2, 0x2, 0x12a5, 
       0x12b1, 0x7, 0x19f, 0x2, 0x2, 0x12a6, 0x12ad, 0x5, 0x23e, 0x120, 
       0x2, 0x12a7, 0x12a9, 0x7, 0x29, 0x2, 0x2, 0x12a8, 0x12a7, 0x3, 0x2, 
       0x2, 0x2, 0x12a8, 0x12a9, 0x3, 0x2, 0x2, 0x2, 0x12a9, 0x12aa, 0x3, 
       0x2, 0x2, 0x2, 0x12aa, 0x12ac, 0x5, 0x23e, 0x120, 0x2, 0x12ab, 0x12a8, 
       0x3, 0x2, 0x2, 0x2, 0x12ac, 0x12af, 0x3, 0x2, 0x2, 0x2, 0x12ad, 0x12ab, 
       0x3, 0x2, 0x2, 0x2, 0x12ad, 0x12ae, 0x3, 0x2, 0x2, 0x2, 0x12ae, 0x12b1, 
       0x3, 0x2, 0x2, 0x2, 0x12af, 0x12ad, 0x3, 0x2, 0x2, 0x2, 0x12b0, 0x12a5, 
       0x3, 0x2, 0x2, 0x2, 0x12b0, 0x12a6, 0x3, 0x2, 0x2, 0x2, 0x12b1, 0x211, 
       0x3, 0x2, 0x2, 0x2, 0x12b2, 0x12b3, 0x7, 0x2d1, 0x2, 0x2, 0x12b3, 
       0x12b7, 0x5, 0x23c, 0x11f, 0x2, 0x12b4, 0x12b6, 0x5, 0x23c, 0x11f, 
       0x2, 0x12b5, 0x12b4, 0x3, 0x2, 0x2, 0x2, 0x12b6, 0x12b9, 0x3, 0x2, 
       0x2, 0x2, 0x12b7, 0x12b5, 0x3, 0x2, 0x2, 0x2, 0x12b7, 0x12b8, 0x3, 
       0x2, 0x2, 0x2, 0x12b8, 0x213, 0x3, 0x2, 0x2, 0x2, 0x12b9, 0x12b7, 
       0x3, 0x2, 0x2, 0x2, 0x12ba, 0x12bc, 0x5, 0x216, 0x10c, 0x2, 0x12bb, 
       0x12ba, 0x3, 0x2, 0x2, 0x2, 0x12bc, 0x12bd, 0x3, 0x2, 0x2, 0x2, 0x12bd, 
       0x12bb, 0x3, 0x2, 0x2, 0x2, 0x12bd, 0x12be, 0x3, 0x2, 0x2, 0x2, 0x12be, 
       0x215, 0x3, 0x2, 0x2, 0x2, 0x12bf, 0x12c0, 0x7, 0x1c, 0x2, 0x2, 0x12c0, 
       0x12e0, 0x9, 0x39, 0x2, 0x2, 0x12c1, 0x12c2, 0x7, 0x1cb, 0x2, 0x2, 
       0x12c2, 0x12c8, 0x7, 0xc9, 0x2, 0x2, 0x12c3, 0x12c9, 0x7, 0x92, 0x2, 
       0x2, 0x12c4, 0x12c9, 0x7, 0x19a, 0x2, 0x2, 0x12c5, 0x12c6, 0x7, 0x11e, 
       0x2, 0x2, 0x12c6, 0x12c7, 0x7, 0x313, 0x2, 0x2, 0x12c7, 0x12c9, 0x7, 
       0x89, 0x2, 0x2, 0x12c8, 0x12c3, 0x3, 0x2, 0x2, 0x2, 0x12c8, 0x12c4, 
       0x3, 0x2, 0x2, 0x2, 0x12c8, 0x12c5, 0x3, 0x2, 0x2, 0x2, 0x12c8, 0x12c9, 
       0x3, 0x2, 0x2, 0x2, 0x12c9, 0x12e0, 0x3, 0x2, 0x2, 0x2, 0x12ca, 0x12cb, 
       0x7, 0x1cb, 0x2, 0x2, 0x12cb, 0x12cc, 0x7, 0xfe, 0x2, 0x2, 0x12cc, 
       0x12e0, 0x9, 0x1a, 0x2, 0x2, 0x12cd, 0x12ce, 0x7, 0x1cb, 0x2, 0x2, 
       0x12ce, 0x12cf, 0x7, 0x220, 0x2, 0x2, 0x12cf, 0x12d3, 0x7, 0x11e, 
       0x2, 0x2, 0x12d0, 0x12d4, 0x7, 0x92, 0x2, 0x2, 0x12d1, 0x12d2, 0x7, 
       0x313, 0x2, 0x2, 0x12d2, 0x12d4, 0x7, 0x89, 0x2, 0x2, 0x12d3, 0x12d0, 
       0x3, 0x2, 0x2, 0x2, 0x12d3, 0x12d1, 0x3, 0x2, 0x2, 0x2, 0x12d4, 0x12e0, 
       0x3, 0x2, 0x2, 0x2, 0x12d5, 0x12d6, 0x7, 0x1cb, 0x2, 0x2, 0x12d6, 
       0x12d7, 0x7, 0x211, 0x2, 0x2, 0x12d7, 0x12d9, 0x7, 0x7c, 0x2, 0x2, 
       0x12d8, 0x12da, 0x9, 0x3a, 0x2, 0x2, 0x12d9, 0x12d8, 0x3, 0x2, 0x2, 
       0x2, 0x12d9, 0x12da, 0x3, 0x2, 0x2, 0x2, 0x12da, 0x12e0, 0x3, 0x2, 
       0x2, 0x2, 0x12db, 0x12dc, 0x7, 0xce, 0x2, 0x2, 0x12dc, 0x12e0, 0x7, 
       0x313, 0x2, 0x2, 0x12dd, 0x12de, 0x7, 0x1cc, 0x2, 0x2, 0x12de, 0x12e0, 
       0x9, 0x3b, 0x2, 0x2, 0x12df, 0x12bf, 0x3, 0x2, 0x2, 0x2, 0x12df, 
       0x12c1, 0x3, 0x2, 0x2, 0x2, 0x12df, 0x12ca, 0x3, 0x2, 0x2, 0x2, 0x12df, 
       0x12cd, 0x3, 0x2, 0x2, 0x2, 0x12df, 0x12d5, 0x3, 0x2, 0x2, 0x2, 0x12df, 
       0x12db, 0x3, 0x2, 0x2, 0x2, 0x12df, 0x12dd, 0x3, 0x2, 0x2, 0x2, 0x12e0, 
       0x217, 0x3, 0x2, 0x2, 0x2, 0x12e1, 0x12e2, 0x7, 0x26, 0x2, 0x2, 0x12e2, 
       0x12e5, 0x7, 0x2b6, 0x2, 0x2, 0x12e3, 0x12e4, 0x7, 0x106, 0x2, 0x2, 
       0x12e4, 0x12e6, 0x7, 0xc6, 0x2, 0x2, 0x12e5, 0x12e3, 0x3, 0x2, 0x2, 
       0x2, 0x12e5, 0x12e6, 0x3, 0x2, 0x2, 0x2, 0x12e6, 0x12e7, 0x3, 0x2, 
       0x2, 0x2, 0x12e7, 0x12e9, 0x5, 0x21c, 0x10f, 0x2, 0x12e8, 0x12ea, 
       0x5, 0x210, 0x109, 0x2, 0x12e9, 0x12e8, 0x3, 0x2, 0x2, 0x2, 0x12e9, 
       0x12ea, 0x3, 0x2, 0x2, 0x2, 0x12ea, 0x12ec, 0x3, 0x2, 0x2, 0x2, 0x12eb, 
       0x12ed, 0x5, 0x212, 0x10a, 0x2, 0x12ec, 0x12eb, 0x3, 0x2, 0x2, 0x2, 
       0x12ec, 0x12ed, 0x3, 0x2, 0x2, 0x2, 0x12ed, 0x12ef, 0x3, 0x2, 0x2, 
       0x2, 0x12ee, 0x12f0, 0x5, 0x214, 0x10b, 0x2, 0x12ef, 0x12ee, 0x3, 
       0x2, 0x2, 0x2, 0x12ef, 0x12f0, 0x3, 0x2, 0x2, 0x2, 0x12f0, 0x1311, 
       0x3, 0x2, 0x2, 0x2, 0x12f1, 0x12f2, 0x7, 0x26, 0x2, 0x2, 0x12f2, 
       0x12f5, 0x7, 0x2b6, 0x2, 0x2, 0x12f3, 0x12f4, 0x7, 0x106, 0x2, 0x2, 
       0x12f4, 0x12f6, 0x7, 0xc6, 0x2, 0x2, 0x12f5, 0x12f3, 0x3, 0x2, 0x2, 
       0x2, 0x12f5, 0x12f6, 0x3, 0x2, 0x2, 0x2, 0x12f6, 0x12f7, 0x3, 0x2, 
       0x2, 0x2, 0x12f7, 0x12f8, 0x7, 0x2b6, 0x2, 0x2, 0x12f8, 0x12f9, 0x7, 
       0x2fb, 0x2, 0x2, 0x12f9, 0x12fa, 0x7, 0x2fc, 0x2, 0x2, 0x12fa, 0x1311, 
       0x5, 0x240, 0x121, 0x2, 0x12fb, 0x12fc, 0x7, 0x26, 0x2, 0x2, 0x12fc, 
       0x12ff, 0x7, 0x2b6, 0x2, 0x2, 0x12fd, 0x12fe, 0x7, 0x106, 0x2, 0x2, 
       0x12fe, 0x1300, 0x7, 0xc6, 0x2, 0x2, 0x12ff, 0x12fd, 0x3, 0x2, 0x2, 
       0x2, 0x12ff, 0x1300, 0x3, 0x2, 0x2, 0x2, 0x1300, 0x1301, 0x3, 0x2, 
       0x2, 0x2, 0x1301, 0x1302, 0x5, 0x362, 0x1b2, 0x2, 0x1302, 0x1303, 
       0x7, 0x92, 0x2, 0x2, 0x1303, 0x130e, 0x7, 0x225, 0x2, 0x2, 0x1304, 
       0x130f, 0x7, 0x19f, 0x2, 0x2, 0x1305, 0x130f, 0x7, 0x25, 0x2, 0x2, 
       0x1306, 0x130b, 0x5, 0x390, 0x1c9, 0x2, 0x1307, 0x1308, 0x7, 0x301, 
       0x2, 0x2, 0x1308, 0x130a, 0x5, 0x390, 0x1c9, 0x2, 0x1309, 0x1307, 
       0x3, 0x2, 0x2, 0x2, 0x130a, 0x130d, 0x3, 0x2, 0x2, 0x2, 0x130b, 0x1309, 
       0x3, 0x2, 0x2, 0x2, 0x130b, 0x130c, 0x3, 0x2, 0x2, 0x2, 0x130c, 0x130f, 
       0x3, 0x2, 0x2, 0x2, 0x130d, 0x130b, 0x3, 0x2, 0x2, 0x2, 0x130e, 0x1304, 
       0x3, 0x2, 0x2, 0x2, 0x130e, 0x1305, 0x3, 0x2, 0x2, 0x2, 0x130e, 0x1306, 
       0x3, 0x2, 0x2, 0x2, 0x130f, 0x1311, 0x3, 0x2, 0x2, 0x2, 0x1310, 0x12e1, 
       0x3, 0x2, 0x2, 0x2, 0x1310, 0x12f1, 0x3, 0x2, 0x2, 0x2, 0x1310, 0x12fb, 
       0x3, 0x2, 0x2, 0x2, 0x1311, 0x219, 0x3, 0x2, 0x2, 0x2, 0x1312, 0x1314, 
       0x5, 0x362, 0x1b2, 0x2, 0x1313, 0x1315, 0x5, 0x236, 0x11c, 0x2, 0x1314, 
       0x1313, 0x3, 0x2, 0x2, 0x2, 0x1314, 0x1315, 0x3, 0x2, 0x2, 0x2, 0x1315, 
       0x21b, 0x3, 0x2, 0x2, 0x2, 0x1316, 0x131b, 0x5, 0x21a, 0x10e, 0x2, 
       0x1317, 0x1318, 0x7, 0x301, 0x2, 0x2, 0x1318, 0x131a, 0x5, 0x21a, 
       0x10e, 0x2, 0x1319, 0x1317, 0x3, 0x2, 0x2, 0x2, 0x131a, 0x131d, 0x3, 
       0x2, 0x2, 0x2, 0x131b, 0x1319, 0x3, 0x2, 0x2, 0x2, 0x131b, 0x131c, 
       0x3, 0x2, 0x2, 0x2, 0x131c, 0x21d, 0x3, 0x2, 0x2, 0x2, 0x131d, 0x131b, 
       0x3, 0x2, 0x2, 0x2, 0x131e, 0x131f, 0x7, 0xa8, 0x2, 0x2, 0x131f, 
       0x1322, 0x7, 0x2b6, 0x2, 0x2, 0x1320, 0x1321, 0x7, 0x106, 0x2, 0x2, 
       0x1321, 0x1323, 0x7, 0xc6, 0x2, 0x2, 0x1322, 0x1320, 0x3, 0x2, 0x2, 
       0x2, 0x1322, 0x1323, 0x3, 0x2, 0x2, 0x2, 0x1323, 0x1324, 0x3, 0x2, 
       0x2, 0x2, 0x1324, 0x1329, 0x5, 0x362, 0x1b2, 0x2, 0x1325, 0x1326, 
       0x7, 0x301, 0x2, 0x2, 0x1326, 0x1328, 0x5, 0x362, 0x1b2, 0x2, 0x1327, 
       0x1325, 0x3, 0x2, 0x2, 0x2, 0x1328, 0x132b, 0x3, 0x2, 0x2, 0x2, 0x1329, 
       0x1327, 0x3, 0x2, 0x2, 0x2, 0x1329, 0x132a, 0x3, 0x2, 0x2, 0x2, 0x132a, 
       0x21f, 0x3, 0x2, 0x2, 0x2, 0x132b, 0x1329, 0x3, 0x2, 0x2, 0x2, 0x132c, 
       0x132d, 0x7, 0x78, 0x2, 0x2, 0x132d, 0x1331, 0x7, 0x225, 0x2, 0x2, 
       0x132e, 0x132f, 0x7, 0x106, 0x2, 0x2, 0x132f, 0x1330, 0x7, 0x1a0, 
       0x2, 0x2, 0x1330, 0x1332, 0x7, 0xc6, 0x2, 0x2, 0x1331, 0x132e, 0x3, 
       0x2, 0x2, 0x2, 0x1331, 0x1332, 0x3, 0x2, 0x2, 0x2, 0x1332, 0x1333, 
       0x3, 0x2, 0x2, 0x2, 0x1333, 0x1338, 0x5, 0x390, 0x1c9, 0x2, 0x1334, 
       0x1335, 0x7, 0x301, 0x2, 0x2, 0x1335, 0x1337, 0x5, 0x390, 0x1c9, 
       0x2, 0x1336, 0x1334, 0x3, 0x2, 0x2, 0x2, 0x1337, 0x133a, 0x3, 0x2, 
       0x2, 0x2, 0x1338, 0x1336, 0x3, 0x2, 0x2, 0x2, 0x1338, 0x1339, 0x3, 
       0x2, 0x2, 0x2, 0x1339, 0x221, 0x3, 0x2, 0x2, 0x2, 0x133a, 0x1338, 
       0x3, 0x2, 0x2, 0x2, 0x133b, 0x133c, 0x7, 0xa8, 0x2, 0x2, 0x133c, 
       0x133f, 0x7, 0x225, 0x2, 0x2, 0x133d, 0x133e, 0x7, 0x106, 0x2, 0x2, 
       0x133e, 0x1340, 0x7, 0xc6, 0x2, 0x2, 0x133f, 0x133d, 0x3, 0x2, 0x2, 
       0x2, 0x133f, 0x1340, 0x3, 0x2, 0x2, 0x2, 0x1340, 0x1341, 0x3, 0x2, 
       0x2, 0x2, 0x1341, 0x1346, 0x5, 0x390, 0x1c9, 0x2, 0x1342, 0x1343, 
       0x7, 0x301, 0x2, 0x2, 0x1343, 0x1345, 0x5, 0x390, 0x1c9, 0x2, 0x1344, 
       0x1342, 0x3, 0x2, 0x2, 0x2, 0x1345, 0x1348, 0x3, 0x2, 0x2, 0x2, 0x1346, 
       0x1344, 0x3, 0x2, 0x2, 0x2, 0x1346, 0x1347, 0x3, 0x2, 0x2, 0x2, 0x1347, 
       0x223, 0x3, 0x2, 0x2, 0x2, 0x1348, 0x1346, 0x3, 0x2, 0x2, 0x2, 0x1349, 
       0x134a, 0x7, 0x203, 0x2, 0x2, 0x134a, 0x134b, 0x7, 0x2b6, 0x2, 0x2, 
       0x134b, 0x134c, 0x5, 0x362, 0x1b2, 0x2, 0x134c, 0x134d, 0x7, 0x29b, 
       0x2, 0x2, 0x134d, 0x1355, 0x5, 0x362, 0x1b2, 0x2, 0x134e, 0x134f, 
       0x7, 0x301, 0x2, 0x2, 0x134f, 0x1350, 0x5, 0x362, 0x1b2, 0x2, 0x1350, 
       0x1351, 0x7, 0x29b, 0x2, 0x2, 0x1351, 0x1352, 0x5, 0x362, 0x1b2, 
       0x2, 0x1352, 0x1354, 0x3, 0x2, 0x2, 0x2, 0x1353, 0x134e, 0x3, 0x2, 
       0x2, 0x2, 0x1354, 0x1357, 0x3, 0x2, 0x2, 0x2, 0x1355, 0x1353, 0x3, 
       0x2, 0x2, 0x2, 0x1355, 0x1356, 0x3, 0x2, 0x2, 0x2, 0x1356, 0x225, 
       0x3, 0x2, 0x2, 0x2, 0x1357, 0x1355, 0x3, 0x2, 0x2, 0x2, 0x1358, 0x1359, 
       0x7, 0x244, 0x2, 0x2, 0x1359, 0x135a, 0x7, 0x92, 0x2, 0x2, 0x135a, 
       0x1365, 0x7, 0x225, 0x2, 0x2, 0x135b, 0x1366, 0x7, 0x19f, 0x2, 0x2, 
       0x135c, 0x1366, 0x7, 0x25, 0x2, 0x2, 0x135d, 0x1362, 0x5, 0x390, 
       0x1c9, 0x2, 0x135e, 0x135f, 0x7, 0x301, 0x2, 0x2, 0x135f, 0x1361, 
       0x5, 0x390, 0x1c9, 0x2, 0x1360, 0x135e, 0x3, 0x2, 0x2, 0x2, 0x1361, 
       0x1364, 0x3, 0x2, 0x2, 0x2, 0x1362, 0x1360, 0x3, 0x2, 0x2, 0x2, 0x1362, 
       0x1363, 0x3, 0x2, 0x2, 0x2, 0x1363, 0x1366, 0x3, 0x2, 0x2, 0x2, 0x1364, 
       0x1362, 0x3, 0x2, 0x2, 0x2, 0x1365, 0x135b, 0x3, 0x2, 0x2, 0x2, 0x1365, 
       0x135c, 0x3, 0x2, 0x2, 0x2, 0x1365, 0x135d, 0x3, 0x2, 0x2, 0x2, 0x1366, 
       0x1367, 0x3, 0x2, 0x2, 0x2, 0x1367, 0x1368, 0x7, 0x29b, 0x2, 0x2, 
       0x1368, 0x136d, 0x5, 0x362, 0x1b2, 0x2, 0x1369, 0x136a, 0x7, 0x301, 
       0x2, 0x2, 0x136a, 0x136c, 0x5, 0x362, 0x1b2, 0x2, 0x136b, 0x1369, 
       0x3, 0x2, 0x2, 0x2, 0x136c, 0x136f, 0x3, 0x2, 0x2, 0x2, 0x136d, 0x136b, 
       0x3, 0x2, 0x2, 0x2, 0x136d, 0x136e, 0x3, 0x2, 0x2, 0x2, 0x136e, 0x227, 
       0x3, 0x2, 0x2, 0x2, 0x136f, 0x136d, 0x3, 0x2, 0x2, 0x2, 0x1370, 0x1371, 
       0x7, 0x244, 0x2, 0x2, 0x1371, 0x1379, 0x7, 0x225, 0x2, 0x2, 0x1372, 
       0x137a, 0x7, 0x92, 0x2, 0x2, 0x1373, 0x137a, 0x7, 0x19f, 0x2, 0x2, 
       0x1374, 0x137a, 0x7, 0x25, 0x2, 0x2, 0x1375, 0x1376, 0x7, 0x25, 0x2, 
       0x2, 0x1376, 0x1377, 0x7, 0xc2, 0x2, 0x2, 0x1377, 0x137a, 0x5, 0x232, 
       0x11a, 0x2, 0x1378, 0x137a, 0x5, 0x232, 0x11a, 0x2, 0x1379, 0x1372, 
       0x3, 0x2, 0x2, 0x2, 0x1379, 0x1373, 0x3, 0x2, 0x2, 0x2, 0x1379, 0x1374, 
       0x3, 0x2, 0x2, 0x2, 0x1379, 0x1375, 0x3, 0x2, 0x2, 0x2, 0x1379, 0x1378, 
       0x3, 0x2, 0x2, 0x2, 0x137a, 0x229, 0x3, 0x2, 0x2, 0x2, 0x137b, 0x137c, 
       0x7, 0x244, 0x2, 0x2, 0x137c, 0x137f, 0x7, 0x1cb, 0x2, 0x2, 0x137d, 
       0x137e, 0x7, 0xe0, 0x2, 0x2, 0x137e, 0x1380, 0x5, 0x362, 0x1b2, 0x2, 
       0x137f, 0x137d, 0x3, 0x2, 0x2, 0x2, 0x137f, 0x1380, 0x3, 0x2, 0x2, 
       0x2, 0x1380, 0x1381, 0x3, 0x2, 0x2, 0x2, 0x1381, 0x1384, 0x5, 0x22c, 
       0x117, 0x2, 0x1382, 0x1383, 0x7, 0x208, 0x2, 0x2, 0x1383, 0x1385, 
       0x5, 0x32c, 0x197, 0x2, 0x1384, 0x1382, 0x3, 0x2, 0x2, 0x2, 0x1384, 
       0x1385, 0x3, 0x2, 0x2, 0x2, 0x1385, 0x1389, 0x3, 0x2, 0x2, 0x2, 0x1386, 
       0x1387, 0x7, 0x21b, 0x2, 0x2, 0x1387, 0x1388, 0x7, 0x7c, 0x2, 0x2, 
       0x1388, 0x138a, 0x7, 0x1cb, 0x2, 0x2, 0x1389, 0x1386, 0x3, 0x2, 0x2, 
       0x2, 0x1389, 0x138a, 0x3, 0x2, 0x2, 0x2, 0x138a, 0x22b, 0x3, 0x2, 
       0x2, 0x2, 0x138b, 0x138c, 0x7, 0x2f4, 0x2, 0x2, 0x138c, 0x1396, 0x5, 
       0x32e, 0x198, 0x2, 0x138d, 0x138e, 0x7, 0x29b, 0x2, 0x2, 0x138e, 
       0x1396, 0x7, 0x1eb, 0x2, 0x2, 0x138f, 0x1390, 0x7, 0x2f4, 0x2, 0x2, 
       0x1390, 0x1391, 0x7, 0x1cb, 0x2, 0x2, 0x1391, 0x1392, 0x7, 0x2fb, 
       0x2, 0x2, 0x1392, 0x1393, 0x5, 0x32e, 0x198, 0x2, 0x1393, 0x1394, 
       0x7, 0x2fc, 0x2, 0x2, 0x1394, 0x1396, 0x3, 0x2, 0x2, 0x2, 0x1395, 
       0x138b, 0x3, 0x2, 0x2, 0x2, 0x1395, 0x138d, 0x3, 0x2, 0x2, 0x2, 0x1395, 
       0x138f, 0x3, 0x2, 0x2, 0x2, 0x1396, 0x22d, 0x3, 0x2, 0x2, 0x2, 0x1397, 
       0x1398, 0x7, 0x2d1, 0x2, 0x2, 0x1398, 0x1399, 0x7, 0xf2, 0x2, 0x2, 
       0x1399, 0x139a, 0x7, 0x1b6, 0x2, 0x2, 0x139a, 0x22f, 0x3, 0x2, 0x2, 
       0x2, 0x139b, 0x13a0, 0x5, 0x39a, 0x1ce, 0x2, 0x139c, 0x139d, 0x7, 
       0x301, 0x2, 0x2, 0x139d, 0x139f, 0x5, 0x39a, 0x1ce, 0x2, 0x139e, 
       0x139c, 0x3, 0x2, 0x2, 0x2, 0x139f, 0x13a2, 0x3, 0x2, 0x2, 0x2, 0x13a0, 
       0x139e, 0x3, 0x2, 0x2, 0x2, 0x13a0, 0x13a1, 0x3, 0x2, 0x2, 0x2, 0x13a1, 
       0x231, 0x3, 0x2, 0x2, 0x2, 0x13a2, 0x13a0, 0x3, 0x2, 0x2, 0x2, 0x13a3, 
       0x13a8, 0x5, 0x390, 0x1c9, 0x2, 0x13a4, 0x13a5, 0x7, 0x301, 0x2, 
       0x2, 0x13a5, 0x13a7, 0x5, 0x390, 0x1c9, 0x2, 0x13a6, 0x13a4, 0x3, 
       0x2, 0x2, 0x2, 0x13a7, 0x13aa, 0x3, 0x2, 0x2, 0x2, 0x13a8, 0x13a6, 
       0x3, 0x2, 0x2, 0x2, 0x13a8, 0x13a9, 0x3, 0x2, 0x2, 0x2, 0x13a9, 0x233, 
       0x3, 0x2, 0x2, 0x2, 0x13aa, 0x13a8, 0x3, 0x2, 0x2, 0x2, 0x13ab, 0x13ac, 
       0x7, 0x2c, 0x2, 0x2, 0x13ac, 0x13b6, 0x5, 0x362, 0x1b2, 0x2, 0x13ad, 
       0x13ae, 0x7, 0x2d1, 0x2, 0x2, 0x13ae, 0x13af, 0x7, 0x225, 0x2, 0x2, 
       0x13af, 0x13b7, 0x7, 0x92, 0x2, 0x2, 0x13b0, 0x13b7, 0x7, 0x19f, 
       0x2, 0x2, 0x13b1, 0x13b7, 0x7, 0x25, 0x2, 0x2, 0x13b2, 0x13b3, 0x7, 
       0x25, 0x2, 0x2, 0x13b3, 0x13b4, 0x7, 0xc2, 0x2, 0x2, 0x13b4, 0x13b7, 
       0x5, 0x232, 0x11a, 0x2, 0x13b5, 0x13b7, 0x5, 0x232, 0x11a, 0x2, 0x13b6, 
       0x13ad, 0x3, 0x2, 0x2, 0x2, 0x13b6, 0x13b0, 0x3, 0x2, 0x2, 0x2, 0x13b6, 
       0x13b1, 0x3, 0x2, 0x2, 0x2, 0x13b6, 0x13b2, 0x3, 0x2, 0x2, 0x2, 0x13b6, 
       0x13b5, 0x3, 0x2, 0x2, 0x2, 0x13b6, 0x13b7, 0x3, 0x2, 0x2, 0x2, 0x13b7, 
       0x235, 0x3, 0x2, 0x2, 0x2, 0x13b8, 0x13be, 0x5, 0x238, 0x11d, 0x2, 
       0x13b9, 0x13be, 0x5, 0x23a, 0x11e, 0x2, 0x13ba, 0x13bb, 0x7, 0xa1, 
       0x2, 0x2, 0x13bb, 0x13bc, 0x7, 0x1af, 0x2, 0x2, 0x13bc, 0x13be, 0x7, 
       0x1cb, 0x2, 0x2, 0x13bd, 0x13b8, 0x3, 0x2, 0x2, 0x2, 0x13bd, 0x13b9, 
       0x3, 0x2, 0x2, 0x2, 0x13bd, 0x13ba, 0x3, 0x2, 0x2, 0x2, 0x13be, 0x237, 
       0x3, 0x2, 0x2, 0x2, 0x13bf, 0x13c0, 0x7, 0x105, 0x2, 0x2, 0x13c0, 
       0x13c4, 0x7, 0x45, 0x2, 0x2, 0x13c1, 0x13c5, 0x5, 0x32c, 0x197, 0x2, 
       0x13c2, 0x13c3, 0x7, 0x1eb, 0x2, 0x2, 0x13c3, 0x13c5, 0x7, 0x1cb, 
       0x2, 0x2, 0x13c4, 0x13c1, 0x3, 0x2, 0x2, 0x2, 0x13c4, 0x13c2, 0x3, 
       0x2, 0x2, 0x2, 0x13c5, 0x13c8, 0x3, 0x2, 0x2, 0x2, 0x13c6, 0x13c7, 
       0x7, 0x208, 0x2, 0x2, 0x13c7, 0x13c9, 0x5, 0x32c, 0x197, 0x2, 0x13c8, 
       0x13c6, 0x3, 0x2, 0x2, 0x2, 0x13c8, 0x13c9, 0x3, 0x2, 0x2, 0x2, 0x13c9, 
       0x13cd, 0x3, 0x2, 0x2, 0x2, 0x13ca, 0x13cb, 0x7, 0x21b, 0x2, 0x2, 
       0x13cb, 0x13cc, 0x7, 0x7c, 0x2, 0x2, 0x13cc, 0x13ce, 0x7, 0x1cb, 
       0x2, 0x2, 0x13cd, 0x13ca, 0x3, 0x2, 0x2, 0x2, 0x13cd, 0x13ce, 0x3, 
       0x2, 0x2, 0x2, 0x13ce, 0x239, 0x3, 0x2, 0x2, 0x2, 0x13cf, 0x13d0, 
       0x7, 0x105, 0x2, 0x2, 0x13d0, 0x13d1, 0x7, 0x2d1, 0x2, 0x2, 0x13d1, 
       0x13ef, 0x5, 0x382, 0x1c2, 0x2, 0x13d2, 0x13d3, 0x7, 0x105, 0x2, 
       0x2, 0x13d3, 0x13d4, 0x7, 0x2d1, 0x2, 0x2, 0x13d4, 0x13d5, 0x5, 0x382, 
       0x1c2, 0x2, 0x13d5, 0x13d9, 0x7, 0x45, 0x2, 0x2, 0x13d6, 0x13da, 
       0x5, 0x32c, 0x197, 0x2, 0x13d7, 0x13d8, 0x7, 0x1eb, 0x2, 0x2, 0x13d8, 
       0x13da, 0x7, 0x1cb, 0x2, 0x2, 0x13d9, 0x13d6, 0x3, 0x2, 0x2, 0x2, 
       0x13d9, 0x13d7, 0x3, 0x2, 0x2, 0x2, 0x13da, 0x13dd, 0x3, 0x2, 0x2, 
       0x2, 0x13db, 0x13dc, 0x7, 0x208, 0x2, 0x2, 0x13dc, 0x13de, 0x5, 0x32e, 
       0x198, 0x2, 0x13dd, 0x13db, 0x3, 0x2, 0x2, 0x2, 0x13dd, 0x13de, 0x3, 
       0x2, 0x2, 0x2, 0x13de, 0x13e2, 0x3, 0x2, 0x2, 0x2, 0x13df, 0x13e0, 
       0x7, 0x21b, 0x2, 0x2, 0x13e0, 0x13e1, 0x7, 0x7c, 0x2, 0x2, 0x13e1, 
       0x13e3, 0x7, 0x1cb, 0x2, 0x2, 0x13e2, 0x13df, 0x3, 0x2, 0x2, 0x2, 
       0x13e2, 0x13e3, 0x3, 0x2, 0x2, 0x2, 0x13e3, 0x13ef, 0x3, 0x2, 0x2, 
       0x2, 0x13e4, 0x13e5, 0x7, 0x105, 0x2, 0x2, 0x13e5, 0x13e6, 0x7, 0x2d1, 
       0x2, 0x2, 0x13e6, 0x13e7, 0x5, 0x382, 0x1c2, 0x2, 0x13e7, 0x13e8, 
       0x7, 0x2c, 0x2, 0x2, 0x13e8, 0x13ec, 0x5, 0x420, 0x211, 0x2, 0x13e9, 
       0x13ea, 0x7, 0x21b, 0x2, 0x2, 0x13ea, 0x13eb, 0x7, 0x7c, 0x2, 0x2, 
       0x13eb, 0x13ed, 0x7, 0x1cb, 0x2, 0x2, 0x13ec, 0x13e9, 0x3, 0x2, 0x2, 
       0x2, 0x13ec, 0x13ed, 0x3, 0x2, 0x2, 0x2, 0x13ed, 0x13ef, 0x3, 0x2, 
       0x2, 0x2, 0x13ee, 0x13cf, 0x3, 0x2, 0x2, 0x2, 0x13ee, 0x13d2, 0x3, 
       0x2, 0x2, 0x2, 0x13ee, 0x13e4, 0x3, 0x2, 0x2, 0x2, 0x13ef, 0x23b, 
       0x3, 0x2, 0x2, 0x2, 0x13f0, 0x13f1, 0x7, 0x173, 0x2, 0x2, 0x13f1, 
       0x13f9, 0x7, 0x313, 0x2, 0x2, 0x13f2, 0x13f3, 0x7, 0x176, 0x2, 0x2, 
       0x13f3, 0x13f9, 0x7, 0x313, 0x2, 0x2, 0x13f4, 0x13f5, 0x7, 0x172, 
       0x2, 0x2, 0x13f5, 0x13f9, 0x7, 0x313, 0x2, 0x2, 0x13f6, 0x13f7, 0x7, 
       0x177, 0x2, 0x2, 0x13f7, 0x13f9, 0x7, 0x313, 0x2, 0x2, 0x13f8, 0x13f0, 
       0x3, 0x2, 0x2, 0x2, 0x13f8, 0x13f2, 0x3, 0x2, 0x2, 0x2, 0x13f8, 0x13f4, 
       0x3, 0x2, 0x2, 0x2, 0x13f8, 0x13f6, 0x3, 0x2, 0x2, 0x2, 0x13f9, 0x23d, 
       0x3, 0x2, 0x2, 0x2, 0x13fa, 0x1403, 0x7, 0x26e, 0x2, 0x2, 0x13fb, 
       0x1403, 0x7, 0x2d6, 0x2, 0x2, 0x13fc, 0x13fd, 0x7, 0x56, 0x2, 0x2, 
       0x13fd, 0x1403, 0x5, 0x32c, 0x197, 0x2, 0x13fe, 0x13ff, 0x7, 0x129, 
       0x2, 0x2, 0x13ff, 0x1403, 0x5, 0x32c, 0x197, 0x2, 0x1400, 0x1401, 
       0x7, 0x27e, 0x2, 0x2, 0x1401, 0x1403, 0x5, 0x32c, 0x197, 0x2, 0x1402, 
       0x13fa, 0x3, 0x2, 0x2, 0x2, 0x1402, 0x13fb, 0x3, 0x2, 0x2, 0x2, 0x1402, 
       0x13fc, 0x3, 0x2, 0x2, 0x2, 0x1402, 0x13fe, 0x3, 0x2, 0x2, 0x2, 0x1402, 
       0x1400, 0x3, 0x2, 0x2, 0x2, 0x1403, 0x23f, 0x3, 0x2, 0x2, 0x2, 0x1404, 
       0x1409, 0x5, 0x238, 0x11d, 0x2, 0x1405, 0x1406, 0x7, 0xa1, 0x2, 0x2, 
       0x1406, 0x1407, 0x7, 0x1af, 0x2, 0x2, 0x1407, 0x1409, 0x7, 0x1cb, 
       0x2, 0x2, 0x1408, 0x1404, 0x3, 0x2, 0x2, 0x2, 0x1408, 0x1405, 0x3, 
       0x2, 0x2, 0x2, 0x1409, 0x241, 0x3, 0x2, 0x2, 0x2, 0x140a, 0x140b, 
       0x7, 0x2b5, 0x2, 0x2, 0x140b, 0x140c, 0x5, 0x350, 0x1a9, 0x2, 0x140c, 
       0x243, 0x3, 0x2, 0x2, 0x2, 0x140d, 0x140e, 0x7, 0xfb, 0x2, 0x2, 0x140e, 
       0x140f, 0x5, 0x32c, 0x197, 0x2, 0x140f, 0x245, 0x3, 0x2, 0x2, 0x2, 
       0x1410, 0x1421, 0x9, 0x3c, 0x2, 0x2, 0x1411, 0x1414, 0x5, 0x35a, 
       0x1ae, 0x2, 0x1412, 0x1415, 0x5, 0x3b6, 0x1dc, 0x2, 0x1413, 0x1415, 
       0x5, 0x41e, 0x210, 0x2, 0x1414, 0x1412, 0x3, 0x2, 0x2, 0x2, 0x1414, 
       0x1413, 0x3, 0x2, 0x2, 0x2, 0x1414, 0x1415, 0x3, 0x2, 0x2, 0x2, 0x1415, 
       0x1422, 0x3, 0x2, 0x2, 0x2, 0x1416, 0x1418, 0x5, 0x2f4, 0x17b, 0x2, 
       0x1417, 0x1416, 0x3, 0x2, 0x2, 0x2, 0x1417, 0x1418, 0x3, 0x2, 0x2, 
       0x2, 0x1418, 0x141d, 0x3, 0x2, 0x2, 0x2, 0x1419, 0x141e, 0x5, 0x2f6, 
       0x17c, 0x2, 0x141a, 0x141b, 0x7, 0xe0, 0x2, 0x2, 0x141b, 0x141c, 
       0x7, 0x6d, 0x2, 0x2, 0x141c, 0x141e, 0x5, 0x44e, 0x228, 0x2, 0x141d, 
       0x1419, 0x3, 0x2, 0x2, 0x2, 0x141d, 0x141a, 0x3, 0x2, 0x2, 0x2, 0x141e, 
       0x1422, 0x3, 0x2, 0x2, 0x2, 0x141f, 0x1420, 0x7, 0x28, 0x2, 0x2, 
       0x1420, 0x1422, 0x5, 0x36, 0x1c, 0x2, 0x1421, 0x1411, 0x3, 0x2, 0x2, 
       0x2, 0x1421, 0x1417, 0x3, 0x2, 0x2, 0x2, 0x1421, 0x141f, 0x3, 0x2, 
       0x2, 0x2, 0x1422, 0x247, 0x3, 0x2, 0x2, 0x2, 0x1423, 0x1424, 0x7, 
       0x246, 0x2, 0x2, 0x1424, 0x1426, 0x9, 0x3d, 0x2, 0x2, 0x1425, 0x1427, 
       0x5, 0x25e, 0x130, 0x2, 0x1426, 0x1425, 0x3, 0x2, 0x2, 0x2, 0x1426, 
       0x1427, 0x3, 0x2, 0x2, 0x2, 0x1427, 0x249, 0x3, 0x2, 0x2, 0x2, 0x1428, 
       0x142a, 0x7, 0x246, 0x2, 0x2, 0x1429, 0x142b, 0x7, 0xcc, 0x2, 0x2, 
       0x142a, 0x1429, 0x3, 0x2, 0x2, 0x2, 0x142a, 0x142b, 0x3, 0x2, 0x2, 
       0x2, 0x142b, 0x142d, 0x3, 0x2, 0x2, 0x2, 0x142c, 0x142e, 0x7, 0xe6, 
       0x2, 0x2, 0x142d, 0x142c, 0x3, 0x2, 0x2, 0x2, 0x142d, 0x142e, 0x3, 
       0x2, 0x2, 0x2, 0x142e, 0x142f, 0x3, 0x2, 0x2, 0x2, 0x142f, 0x1431, 
       0x7, 0x287, 0x2, 0x2, 0x1430, 0x1432, 0x5, 0x254, 0x12b, 0x2, 0x1431, 
       0x1430, 0x3, 0x2, 0x2, 0x2, 0x1431, 0x1432, 0x3, 0x2, 0x2, 0x2, 0x1432, 
       0x1434, 0x3, 0x2, 0x2, 0x2, 0x1433, 0x1435, 0x5, 0x25e, 0x130, 0x2, 
       0x1434, 0x1433, 0x3, 0x2, 0x2, 0x2, 0x1434, 0x1435, 0x3, 0x2, 0x2, 
       0x2, 0x1435, 0x24b, 0x3, 0x2, 0x2, 0x2, 0x1436, 0x1437, 0x7, 0x246, 
       0x2, 0x2, 0x1437, 0x1438, 0x7, 0x286, 0x2, 0x2, 0x1438, 0x143a, 0x7, 
       0x276, 0x2, 0x2, 0x1439, 0x143b, 0x5, 0x254, 0x12b, 0x2, 0x143a, 
       0x1439, 0x3, 0x2, 0x2, 0x2, 0x143a, 0x143b, 0x3, 0x2, 0x2, 0x2, 0x143b, 
       0x143d, 0x3, 0x2, 0x2, 0x2, 0x143c, 0x143e, 0x5, 0x25e, 0x130, 0x2, 
       0x143d, 0x143c, 0x3, 0x2, 0x2, 0x2, 0x143d, 0x143e, 0x3, 0x2, 0x2, 
       0x2, 0x143e, 0x24d, 0x3, 0x2, 0x2, 0x2, 0x143f, 0x1441, 0x7, 0x246, 
       0x2, 0x2, 0x1440, 0x1442, 0x7, 0xcc, 0x2, 0x2, 0x1441, 0x1440, 0x3, 
       0x2, 0x2, 0x2, 0x1441, 0x1442, 0x3, 0x2, 0x2, 0x2, 0x1442, 0x1444, 
       0x3, 0x2, 0x2, 0x2, 0x1443, 0x1445, 0x7, 0xe6, 0x2, 0x2, 0x1444, 
       0x1443, 0x3, 0x2, 0x2, 0x2, 0x1444, 0x1445, 0x3, 0x2, 0x2, 0x2, 0x1445, 
       0x1446, 0x3, 0x2, 0x2, 0x2, 0x1446, 0x1447, 0x9, 0x9, 0x2, 0x2, 0x1447, 
       0x1449, 0x5, 0x256, 0x12c, 0x2, 0x1448, 0x144a, 0x5, 0x254, 0x12b, 
       0x2, 0x1449, 0x1448, 0x3, 0x2, 0x2, 0x2, 0x1449, 0x144a, 0x3, 0x2, 
       0x2, 0x2, 0x144a, 0x144d, 0x3, 0x2, 0x2, 0x2, 0x144b, 0x144e, 0x5, 
       0x25a, 0x12e, 0x2, 0x144c, 0x144e, 0x5, 0x25c, 0x12f, 0x2, 0x144d, 
       0x144b, 0x3, 0x2, 0x2, 0x2, 0x144d, 0x144c, 0x3, 0x2, 0x2, 0x2, 0x144d, 
       0x144e, 0x3, 0x2, 0x2, 0x2, 0x144e, 0x24f, 0x3, 0x2, 0x2, 0x2, 0x144f, 
       0x1451, 0x7, 0x246, 0x2, 0x2, 0x1450, 0x1452, 0x7, 0xcc, 0x2, 0x2, 
       0x1451, 0x1450, 0x3, 0x2, 0x2, 0x2, 0x1451, 0x1452, 0x3, 0x2, 0x2, 
       0x2, 0x1452, 0x1453, 0x3, 0x2, 0x2, 0x2, 0x1453, 0x1454, 0x9, 0x3e, 
       0x2, 0x2, 0x1454, 0x1456, 0x5, 0x256, 0x12c, 0x2, 0x1455, 0x1457, 
       0x5, 0x254, 0x12b, 0x2, 0x1456, 0x1455, 0x3, 0x2, 0x2, 0x2, 0x1456, 
       0x1457, 0x3, 0x2, 0x2, 0x2, 0x1457, 0x1459, 0x3, 0x2, 0x2, 0x2, 0x1458, 
       0x145a, 0x5, 0x25c, 0x12f, 0x2, 0x1459, 0x1458, 0x3, 0x2, 0x2, 0x2, 
       0x1459, 0x145a, 0x3, 0x2, 0x2, 0x2, 0x145a, 0x251, 0x3, 0x2, 0x2, 
       0x2, 0x145b, 0x145c, 0x7, 0x246, 0x2, 0x2, 0x145c, 0x145d, 0x7, 0x78, 
       0x2, 0x2, 0x145d, 0x145e, 0x7, 0x286, 0x2, 0x2, 0x145e, 0x145f, 0x5, 
       0x35a, 0x1ae, 0x2, 0x145f, 0x253, 0x3, 0x2, 0x2, 0x2, 0x1460, 0x1461, 
       0x9, 0x3f, 0x2, 0x2, 0x1461, 0x1462, 0x5, 0x350, 0x1a9, 0x2, 0x1462, 
       0x255, 0x3, 0x2, 0x2, 0x2, 0x1463, 0x1464, 0x9, 0x3f, 0x2, 0x2, 0x1464, 
       0x1465, 0x5, 0x35a, 0x1ae, 0x2, 0x1465, 0x257, 0x3, 0x2, 0x2, 0x2, 
       0x1466, 0x1467, 0x7, 0x13f, 0x2, 0x2, 0x1467, 0x1468, 0x5, 0x32e, 
       0x198, 0x2, 0x1468, 0x259, 0x3, 0x2, 0x2, 0x2, 0x1469, 0x146a, 0x7, 
       0x13f, 0x2, 0x2, 0x146a, 0x146b, 0x5, 0x32e, 0x198, 0x2, 0x146b, 
       0x25b, 0x3, 0x2, 0x2, 0x2, 0x146c, 0x146d, 0x7, 0x2ce, 0x2, 0x2, 
       0x146d, 0x146e, 0x5, 0x3a6, 0x1d4, 0x2, 0x146e, 0x25d, 0x3, 0x2, 
       0x2, 0x2, 0x146f, 0x1472, 0x5, 0x258, 0x12d, 0x2, 0x1470, 0x1472, 
       0x5, 0x25c, 0x12f, 0x2, 0x1471, 0x146f, 0x3, 0x2, 0x2, 0x2, 0x1471, 
       0x1470, 0x3, 0x2, 0x2, 0x2, 0x1472, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x1473, 
       0x1480, 0x7, 0x25, 0x2, 0x2, 0x1474, 0x1475, 0x7, 0x3f, 0x2, 0x2, 
       0x1475, 0x1480, 0x7, 0x122, 0x2, 0x2, 0x1476, 0x1477, 0x7, 0x74, 
       0x2, 0x2, 0x1477, 0x1480, 0x7, 0x284, 0x2, 0x2, 0x1478, 0x1480, 0x7, 
       0x77, 0x2, 0x2, 0x1479, 0x1480, 0x7, 0x126, 0x2, 0x2, 0x147a, 0x1480, 
       0x7, 0x17d, 0x2, 0x2, 0x147b, 0x147c, 0x7, 0x1c5, 0x2, 0x2, 0x147c, 
       0x1480, 0x7, 0xd1, 0x2, 0x2, 0x147d, 0x1480, 0x7, 0x254, 0x2, 0x2, 
       0x147e, 0x1480, 0x7, 0x283, 0x2, 0x2, 0x147f, 0x1473, 0x3, 0x2, 0x2, 
       0x2, 0x147f, 0x1474, 0x3, 0x2, 0x2, 0x2, 0x147f, 0x1476, 0x3, 0x2, 
       0x2, 0x2, 0x147f, 0x1478, 0x3, 0x2, 0x2, 0x2, 0x147f, 0x1479, 0x3, 
       0x2, 0x2, 0x2, 0x147f, 0x147a, 0x3, 0x2, 0x2, 0x2, 0x147f, 0x147b, 
       0x3, 0x2, 0x2, 0x2, 0x147f, 0x147d, 0x3, 0x2, 0x2, 0x2, 0x147f, 0x147e, 
       0x3, 0x2, 0x2, 0x2, 0x1480, 0x261, 0x3, 0x2, 0x2, 0x2, 0x1481, 0x1482, 
       0x7, 0x244, 0x2, 0x2, 0x1482, 0x1487, 0x5, 0x264, 0x133, 0x2, 0x1483, 
       0x1484, 0x7, 0x301, 0x2, 0x2, 0x1484, 0x1486, 0x5, 0x264, 0x133, 
       0x2, 0x1485, 0x1483, 0x3, 0x2, 0x2, 0x2, 0x1486, 0x1489, 0x3, 0x2, 
       0x2, 0x2, 0x1487, 0x1485, 0x3, 0x2, 0x2, 0x2, 0x1487, 0x1488, 0x3, 
       0x2, 0x2, 0x2, 0x1488, 0x263, 0x3, 0x2, 0x2, 0x2, 0x1489, 0x1487, 
       0x3, 0x2, 0x2, 0x2, 0x148a, 0x148b, 0x5, 0x344, 0x1a3, 0x2, 0x148b, 
       0x148c, 0x7, 0x2f4, 0x2, 0x2, 0x148c, 0x148d, 0x5, 0x34e, 0x1a8, 
       0x2, 0x148d, 0x265, 0x3, 0x2, 0x2, 0x2, 0x148e, 0x148f, 0x7, 0x246, 
       0x2, 0x2, 0x148f, 0x1490, 0x9, 0x40, 0x2, 0x2, 0x1490, 0x1491, 0x7, 
       0x14d, 0x2, 0x2, 0x1491, 0x267, 0x3, 0x2, 0x2, 0x2, 0x1492, 0x1493, 
       0x7, 0x246, 0x2, 0x2, 0x1493, 0x1494, 0x7, 0x3c, 0x2, 0x2, 0x1494, 
       0x1497, 0x7, 0xc0, 0x2, 0x2, 0x1495, 0x1496, 0x7, 0x10a, 0x2, 0x2, 
       0x1496, 0x1498, 0x7, 0x94, 0x2, 0x2, 0x1497, 0x1495, 0x3, 0x2, 0x2, 
       0x2, 0x1497, 0x1498, 0x3, 0x2, 0x2, 0x2, 0x1498, 0x149b, 0x3, 0x2, 
       0x2, 0x2, 0x1499, 0x149a, 0x7, 0xe5, 0x2, 0x2, 0x149a, 0x149c, 0x7, 
       0x313, 0x2, 0x2, 0x149b, 0x1499, 0x3, 0x2, 0x2, 0x2, 0x149b, 0x149c, 
       0x3, 0x2, 0x2, 0x2, 0x149c, 0x14a3, 0x3, 0x2, 0x2, 0x2, 0x149d, 0x14a0, 
       0x7, 0x140, 0x2, 0x2, 0x149e, 0x149f, 0x7, 0x313, 0x2, 0x2, 0x149f, 
       0x14a1, 0x7, 0x301, 0x2, 0x2, 0x14a0, 0x149e, 0x3, 0x2, 0x2, 0x2, 
       0x14a0, 0x14a1, 0x3, 0x2, 0x2, 0x2, 0x14a1, 0x14a2, 0x3, 0x2, 0x2, 
       0x2, 0x14a2, 0x14a4, 0x7, 0x313, 0x2, 0x2, 0x14a3, 0x149d, 0x3, 0x2, 
       0x2, 0x2, 0x14a3, 0x14a4, 0x3, 0x2, 0x2, 0x2, 0x14a4, 0x269, 0x3, 
       0x2, 0x2, 0x2, 0x14a5, 0x14a6, 0x7, 0x246, 0x2, 0x2, 0x14a6, 0x14a7, 
       0x7, 0x52, 0x2, 0x2, 0x14a7, 0x14a9, 0x7, 0x244, 0x2, 0x2, 0x14a8, 
       0x14aa, 0x5, 0x25e, 0x130, 0x2, 0x14a9, 0x14a8, 0x3, 0x2, 0x2, 0x2, 
       0x14a9, 0x14aa, 0x3, 0x2, 0x2, 0x2, 0x14aa, 0x26b, 0x3, 0x2, 0x2, 
       0x2, 0x14ab, 0x14ac, 0x7, 0x246, 0x2, 0x2, 0x14ac, 0x14ae, 0x7, 0x5e, 
       0x2, 0x2, 0x14ad, 0x14af, 0x5, 0x25e, 0x130, 0x2, 0x14ae, 0x14ad, 
       0x3, 0x2, 0x2, 0x2, 0x14ae, 0x14af, 0x3, 0x2, 0x2, 0x2, 0x14af, 0x26d, 
       0x3, 0x2, 0x2, 0x2, 0x14b0, 0x14b1, 0x7, 0x246, 0x2, 0x2, 0x14b1, 
       0x14b2, 0x7, 0x78, 0x2, 0x2, 0x14b2, 0x14b4, 0x9, 0x19, 0x2, 0x2, 
       0x14b3, 0x14b5, 0x5, 0x44a, 0x226, 0x2, 0x14b4, 0x14b3, 0x3, 0x2, 
       0x2, 0x2, 0x14b4, 0x14b5, 0x3, 0x2, 0x2, 0x2, 0x14b5, 0x14b6, 0x3, 
       0x2, 0x2, 0x2, 0x14b6, 0x14b7, 0x5, 0x350, 0x1a9, 0x2, 0x14b7, 0x26f, 
       0x3, 0x2, 0x2, 0x2, 0x14b8, 0x14b9, 0x7, 0x246, 0x2, 0x2, 0x14b9, 
       0x14ba, 0x7, 0x78, 0x2, 0x2, 0x14ba, 0x14bb, 0x7, 0xbf, 0x2, 0x2, 
       0x14bb, 0x14bc, 0x5, 0x364, 0x1b3, 0x2, 0x14bc, 0x271, 0x3, 0x2, 
       0x2, 0x2, 0x14bd, 0x14be, 0x7, 0x246, 0x2, 0x2, 0x14be, 0x14bf, 0x7, 
       0x78, 0x2, 0x2, 0x14bf, 0x14c0, 0x7, 0xe8, 0x2, 0x2, 0x14c0, 0x14c1, 
       0x5, 0x36a, 0x1b6, 0x2, 0x14c1, 0x273, 0x3, 0x2, 0x2, 0x2, 0x14c2, 
       0x14c3, 0x7, 0x246, 0x2, 0x2, 0x14c3, 0x14c4, 0x7, 0x78, 0x2, 0x2, 
       0x14c4, 0x14c5, 0x7, 0x1e1, 0x2, 0x2, 0x14c5, 0x14c6, 0x5, 0x36a, 
       0x1b6, 0x2, 0x14c6, 0x275, 0x3, 0x2, 0x2, 0x2, 0x14c7, 0x14c8, 0x7, 
       0x246, 0x2, 0x2, 0x14c8, 0x14c9, 0x7, 0x78, 0x2, 0x2, 0x14c9, 0x14ca, 
       0x7, 0x29e, 0x2, 0x2, 0x14ca, 0x14cb, 0x5, 0x394, 0x1cb, 0x2, 0x14cb, 
       0x277, 0x3, 0x2, 0x2, 0x2, 0x14cc, 0x14cd, 0x7, 0x246, 0x2, 0x2, 
       0x14cd, 0x14ce, 0x7, 0x78, 0x2, 0x2, 0x14ce, 0x14cf, 0x7, 0x2b6, 
       0x2, 0x2, 0x14cf, 0x14d0, 0x5, 0x362, 0x1b2, 0x2, 0x14d0, 0x279, 
       0x3, 0x2, 0x2, 0x2, 0x14d1, 0x14d2, 0x7, 0x246, 0x2, 0x2, 0x14d2, 
       0x14d3, 0x7, 0x78, 0x2, 0x2, 0x14d3, 0x14d4, 0x7, 0x2c6, 0x2, 0x2, 
       0x14d4, 0x14d5, 0x5, 0x36c, 0x1b7, 0x2, 0x14d5, 0x27b, 0x3, 0x2, 
       0x2, 0x2, 0x14d6, 0x14d7, 0x7, 0x246, 0x2, 0x2, 0x14d7, 0x14d8, 0x7, 
       0xb7, 0x2, 0x2, 0x14d8, 0x14d9, 0x5, 0x392, 0x1ca, 0x2, 0x14d9, 0x14da, 
       0x9, 0x41, 0x2, 0x2, 0x14da, 0x27d, 0x3, 0x2, 0x2, 0x2, 0x14db, 0x14dd, 
       0x7, 0x246, 0x2, 0x2, 0x14dc, 0x14de, 0x7, 0x278, 0x2, 0x2, 0x14dd, 
       0x14dc, 0x3, 0x2, 0x2, 0x2, 0x14dd, 0x14de, 0x3, 0x2, 0x2, 0x2, 0x14de, 
       0x14df, 0x3, 0x2, 0x2, 0x2, 0x14df, 0x14e0, 0x7, 0xb8, 0x2, 0x2, 
       0x14e0, 0x27f, 0x3, 0x2, 0x2, 0x2, 0x14e1, 0x14e6, 0x7, 0x246, 0x2, 
       0x2, 0x14e2, 0x14e3, 0x7, 0x7, 0x2, 0x2, 0x14e3, 0x14e4, 0x7, 0x2fb, 
       0x2, 0x2, 0x14e4, 0x14e5, 0x7, 0x2ed, 0x2, 0x2, 0x14e5, 0x14e7, 0x7, 
       0x2fc, 0x2, 0x2, 0x14e6, 0x14e2, 0x3, 0x2, 0x2, 0x2, 0x14e6, 0x14e7, 
       0x3, 0x2, 0x2, 0x2, 0x14e7, 0x14e8, 0x3, 0x2, 0x2, 0x2, 0x14e8, 0x14ef, 
       0x7, 0xbc, 0x2, 0x2, 0x14e9, 0x14ec, 0x7, 0x140, 0x2, 0x2, 0x14ea, 
       0x14eb, 0x7, 0x313, 0x2, 0x2, 0x14eb, 0x14ed, 0x7, 0x301, 0x2, 0x2, 
       0x14ec, 0x14ea, 0x3, 0x2, 0x2, 0x2, 0x14ec, 0x14ed, 0x3, 0x2, 0x2, 
       0x2, 0x14ed, 0x14ee, 0x3, 0x2, 0x2, 0x2, 0x14ee, 0x14f0, 0x7, 0x313, 
       0x2, 0x2, 0x14ef, 0x14e9, 0x3, 0x2, 0x2, 0x2, 0x14ef, 0x14f0, 0x3, 
       0x2, 0x2, 0x2, 0x14f0, 0x281, 0x3, 0x2, 0x2, 0x2, 0x14f1, 0x14f2, 
       0x7, 0x246, 0x2, 0x2, 0x14f2, 0x14f4, 0x7, 0xc0, 0x2, 0x2, 0x14f3, 
       0x14f5, 0x5, 0x254, 0x12b, 0x2, 0x14f4, 0x14f3, 0x3, 0x2, 0x2, 0x2, 
       0x14f4, 0x14f5, 0x3, 0x2, 0x2, 0x2, 0x14f5, 0x14f7, 0x3, 0x2, 0x2, 
       0x2, 0x14f6, 0x14f8, 0x5, 0x25e, 0x130, 0x2, 0x14f7, 0x14f6, 0x3, 
       0x2, 0x2, 0x2, 0x14f7, 0x14f8, 0x3, 0x2, 0x2, 0x2, 0x14f8, 0x283, 
       0x3, 0x2, 0x2, 0x2, 0x14f9, 0x14fa, 0x7, 0x246, 0x2, 0x2, 0x14fa, 
       0x14fb, 0x7, 0xe8, 0x2, 0x2, 0x14fb, 0x14fc, 0x7, 0x5c, 0x2, 0x2, 
       0x14fc, 0x14fd, 0x5, 0x36a, 0x1b6, 0x2, 0x14fd, 0x285, 0x3, 0x2, 
       0x2, 0x2, 0x14fe, 0x14ff, 0x7, 0x246, 0x2, 0x2, 0x14ff, 0x1500, 0x7, 
       0xe8, 0x2, 0x2, 0x1500, 0x1502, 0x7, 0x276, 0x2, 0x2, 0x1501, 0x1503, 
       0x5, 0x25e, 0x130, 0x2, 0x1502, 0x1501, 0x3, 0x2, 0x2, 0x2, 0x1502, 
       0x1503, 0x3, 0x2, 0x2, 0x2, 0x1503, 0x287, 0x3, 0x2, 0x2, 0x2, 0x1504, 
       0x1505, 0x7, 0x246, 0x2, 0x2, 0x1505, 0x1512, 0x7, 0xf3, 0x2, 0x2, 
       0x1506, 0x1507, 0x7, 0xe0, 0x2, 0x2, 0x1507, 0x1510, 0x5, 0x39a, 
       0x1ce, 0x2, 0x1508, 0x1509, 0x7, 0x2b9, 0x2, 0x2, 0x1509, 0x150c, 
       0x5, 0x362, 0x1b2, 0x2, 0x150a, 0x150b, 0x7, 0x301, 0x2, 0x2, 0x150b, 
       0x150d, 0x5, 0x362, 0x1b2, 0x2, 0x150c, 0x150a, 0x3, 0x2, 0x2, 0x2, 
       0x150d, 0x150e, 0x3, 0x2, 0x2, 0x2, 0x150e, 0x150c, 0x3, 0x2, 0x2, 
       0x2, 0x150e, 0x150f, 0x3, 0x2, 0x2, 0x2, 0x150f, 0x1511, 0x3, 0x2, 
       0x2, 0x2, 0x1510, 0x1508, 0x3, 0x2, 0x2, 0x2, 0x1510, 0x1511, 0x3, 
       0x2, 0x2, 0x2, 0x1511, 0x1513, 0x3, 0x2, 0x2, 0x2, 0x1512, 0x1506, 
       0x3, 0x2, 0x2, 0x2, 0x1512, 0x1513, 0x3, 0x2, 0x2, 0x2, 0x1513, 0x289, 
       0x3, 0x2, 0x2, 0x2, 0x1514, 0x1515, 0x7, 0x246, 0x2, 0x2, 0x1515, 
       0x1516, 0x7, 0x154, 0x2, 0x2, 0x1516, 0x1517, 0x7, 0x276, 0x2, 0x2, 
       0x1517, 0x28b, 0x3, 0x2, 0x2, 0x2, 0x1518, 0x1519, 0x7, 0x246, 0x2, 
       0x2, 0x1519, 0x151a, 0x7, 0x1b3, 0x2, 0x2, 0x151a, 0x151c, 0x7, 0x287, 
       0x2, 0x2, 0x151b, 0x151d, 0x5, 0x254, 0x12b, 0x2, 0x151c, 0x151b, 
       0x3, 0x2, 0x2, 0x2, 0x151c, 0x151d, 0x3, 0x2, 0x2, 0x2, 0x151d, 0x151f, 
       0x3, 0x2, 0x2, 0x2, 0x151e, 0x1520, 0x5, 0x25e, 0x130, 0x2, 0x151f, 
       0x151e, 0x3, 0x2, 0x2, 0x2, 0x151f, 0x1520, 0x3, 0x2, 0x2, 0x2, 0x1520, 
       0x28d, 0x3, 0x2, 0x2, 0x2, 0x1521, 0x1522, 0x7, 0x246, 0x2, 0x2, 
       0x1522, 0x1523, 0x7, 0x1d3, 0x2, 0x2, 0x1523, 0x28f, 0x3, 0x2, 0x2, 
       0x2, 0x1524, 0x1525, 0x7, 0x246, 0x2, 0x2, 0x1525, 0x1526, 0x7, 0x1df, 
       0x2, 0x2, 0x1526, 0x291, 0x3, 0x2, 0x2, 0x2, 0x1527, 0x1528, 0x7, 
       0x246, 0x2, 0x2, 0x1528, 0x1529, 0x7, 0x1e1, 0x2, 0x2, 0x1529, 0x152a, 
       0x7, 0x5c, 0x2, 0x2, 0x152a, 0x152b, 0x5, 0x36a, 0x1b6, 0x2, 0x152b, 
       0x293, 0x3, 0x2, 0x2, 0x2, 0x152c, 0x152d, 0x7, 0x246, 0x2, 0x2, 
       0x152d, 0x152e, 0x7, 0x1e1, 0x2, 0x2, 0x152e, 0x152f, 0x7, 0x276, 
       0x2, 0x2, 0x152f, 0x1530, 0x5, 0x25e, 0x130, 0x2, 0x1530, 0x295, 
       0x3, 0x2, 0x2, 0x2, 0x1531, 0x1533, 0x7, 0x246, 0x2, 0x2, 0x1532, 
       0x1534, 0x7, 0xe6, 0x2, 0x2, 0x1533, 0x1532, 0x3, 0x2, 0x2, 0x2, 
       0x1533, 0x1534, 0x3, 0x2, 0x2, 0x2, 0x1534, 0x1535, 0x3, 0x2, 0x2, 
       0x2, 0x1535, 0x1536, 0x7, 0x1e3, 0x2, 0x2, 0x1536, 0x297, 0x3, 0x2, 
       0x2, 0x2, 0x1537, 0x1538, 0x7, 0x246, 0x2, 0x2, 0x1538, 0x1541, 0x7, 
       0x1e4, 0x2, 0x2, 0x1539, 0x153e, 0x5, 0x260, 0x131, 0x2, 0x153a, 
       0x153b, 0x7, 0x301, 0x2, 0x2, 0x153b, 0x153d, 0x5, 0x260, 0x131, 
       0x2, 0x153c, 0x153a, 0x3, 0x2, 0x2, 0x2, 0x153d, 0x1540, 0x3, 0x2, 
       0x2, 0x2, 0x153e, 0x153c, 0x3, 0x2, 0x2, 0x2, 0x153e, 0x153f, 0x3, 
       0x2, 0x2, 0x2, 0x153f, 0x1542, 0x3, 0x2, 0x2, 0x2, 0x1540, 0x153e, 
       0x3, 0x2, 0x2, 0x2, 0x1541, 0x1539, 0x3, 0x2, 0x2, 0x2, 0x1541, 0x1542, 
       0x3, 0x2, 0x2, 0x2, 0x1542, 0x1546, 0x3, 0x2, 0x2, 0x2, 0x1543, 0x1544, 
       0x7, 0xe0, 0x2, 0x2, 0x1544, 0x1545, 0x7, 0x1e9, 0x2, 0x2, 0x1545, 
       0x1547, 0x7, 0x313, 0x2, 0x2, 0x1546, 0x1543, 0x3, 0x2, 0x2, 0x2, 
       0x1546, 0x1547, 0x3, 0x2, 0x2, 0x2, 0x1547, 0x154e, 0x3, 0x2, 0x2, 
       0x2, 0x1548, 0x1549, 0x7, 0x140, 0x2, 0x2, 0x1549, 0x154c, 0x7, 0x313, 
       0x2, 0x2, 0x154a, 0x154b, 0x7, 0x1ad, 0x2, 0x2, 0x154b, 0x154d, 0x7, 
       0x313, 0x2, 0x2, 0x154c, 0x154a, 0x3, 0x2, 0x2, 0x2, 0x154c, 0x154d, 
       0x3, 0x2, 0x2, 0x2, 0x154d, 0x154f, 0x3, 0x2, 0x2, 0x2, 0x154e, 0x1548, 
       0x3, 0x2, 0x2, 0x2, 0x154e, 0x154f, 0x3, 0x2, 0x2, 0x2, 0x154f, 0x299, 
       0x3, 0x2, 0x2, 0x2, 0x1550, 0x1551, 0x7, 0x246, 0x2, 0x2, 0x1551, 
       0x1552, 0x7, 0x1e5, 0x2, 0x2, 0x1552, 0x29b, 0x3, 0x2, 0x2, 0x2, 
       0x1553, 0x1554, 0x7, 0x246, 0x2, 0x2, 0x1554, 0x1555, 0x7, 0x1fc, 
       0x2, 0x2, 0x1555, 0x1558, 0x7, 0xc0, 0x2, 0x2, 0x1556, 0x1557, 0x7, 
       0x10a, 0x2, 0x2, 0x1557, 0x1559, 0x5, 0x38e, 0x1c8, 0x2, 0x1558, 
       0x1556, 0x3, 0x2, 0x2, 0x2, 0x1558, 0x1559, 0x3, 0x2, 0x2, 0x2, 0x1559, 
       0x155c, 0x3, 0x2, 0x2, 0x2, 0x155a, 0x155b, 0x7, 0xe5, 0x2, 0x2, 
       0x155b, 0x155d, 0x7, 0x313, 0x2, 0x2, 0x155c, 0x155a, 0x3, 0x2, 0x2, 
       0x2, 0x155c, 0x155d, 0x3, 0x2, 0x2, 0x2, 0x155d, 0x1564, 0x3, 0x2, 
       0x2, 0x2, 0x155e, 0x1561, 0x7, 0x140, 0x2, 0x2, 0x155f, 0x1560, 0x7, 
       0x313, 0x2, 0x2, 0x1560, 0x1562, 0x7, 0x301, 0x2, 0x2, 0x1561, 0x155f, 
       0x3, 0x2, 0x2, 0x2, 0x1561, 0x1562, 0x3, 0x2, 0x2, 0x2, 0x1562, 0x1563, 
       0x3, 0x2, 0x2, 0x2, 0x1563, 0x1565, 0x7, 0x313, 0x2, 0x2, 0x1564, 
       0x155e, 0x3, 0x2, 0x2, 0x2, 0x1564, 0x1565, 0x3, 0x2, 0x2, 0x2, 0x1565, 
       0x1566, 0x3, 0x2, 0x2, 0x2, 0x1566, 0x1567, 0x7, 0xe0, 0x2, 0x2, 
       0x1567, 0x1568, 0x7, 0x50, 0x2, 0x2, 0x1568, 0x1569, 0x5, 0x38c, 
       0x1c7, 0x2, 0x1569, 0x29d, 0x3, 0x2, 0x2, 0x2, 0x156a, 0x156b, 0x7, 
       0x246, 0x2, 0x2, 0x156b, 0x156c, 0x7, 0x24c, 0x2, 0x2, 0x156c, 0x156d, 
       0x7, 0xff, 0x2, 0x2, 0x156d, 0x29f, 0x3, 0x2, 0x2, 0x2, 0x156e, 0x156f, 
       0x7, 0x246, 0x2, 0x2, 0x156f, 0x1570, 0x7, 0x24c, 0x2, 0x2, 0x1570, 
       0x1574, 0x7, 0x276, 0x2, 0x2, 0x1571, 0x1572, 0x7, 0xe0, 0x2, 0x2, 
       0x1572, 0x1573, 0x7, 0x50, 0x2, 0x2, 0x1573, 0x1575, 0x5, 0x38c, 
       0x1c7, 0x2, 0x1574, 0x1571, 0x3, 0x2, 0x2, 0x2, 0x1574, 0x1575, 0x3, 
       0x2, 0x2, 0x2, 0x1575, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x1576, 0x1578, 
       0x7, 0x246, 0x2, 0x2, 0x1577, 0x1579, 0x9, 0x42, 0x2, 0x2, 0x1578, 
       0x1577, 0x3, 0x2, 0x2, 0x2, 0x1578, 0x1579, 0x3, 0x2, 0x2, 0x2, 0x1579, 
       0x157a, 0x3, 0x2, 0x2, 0x2, 0x157a, 0x157c, 0x7, 0x276, 0x2, 0x2, 
       0x157b, 0x157d, 0x5, 0x25e, 0x130, 0x2, 0x157c, 0x157b, 0x3, 0x2, 
       0x2, 0x2, 0x157c, 0x157d, 0x3, 0x2, 0x2, 0x2, 0x157d, 0x2a3, 0x3, 
       0x2, 0x2, 0x2, 0x157e, 0x157f, 0x7, 0x246, 0x2, 0x2, 0x157f, 0x1581, 
       0x7, 0x29e, 0x2, 0x2, 0x1580, 0x1582, 0x5, 0x254, 0x12b, 0x2, 0x1581, 
       0x1580, 0x3, 0x2, 0x2, 0x2, 0x1581, 0x1582, 0x3, 0x2, 0x2, 0x2, 0x1582, 
       0x1584, 0x3, 0x2, 0x2, 0x2, 0x1583, 0x1585, 0x5, 0x25e, 0x130, 0x2, 
       0x1584, 0x1583, 0x3, 0x2, 0x2, 0x2, 0x1584, 0x1585, 0x3, 0x2, 0x2, 
       0x2, 0x1585, 0x2a5, 0x3, 0x2, 0x2, 0x2, 0x1586, 0x1588, 0x7, 0x246, 
       0x2, 0x2, 0x1587, 0x1589, 0x9, 0x42, 0x2, 0x2, 0x1588, 0x1587, 0x3, 
       0x2, 0x2, 0x2, 0x1588, 0x1589, 0x3, 0x2, 0x2, 0x2, 0x1589, 0x158a, 
       0x3, 0x2, 0x2, 0x2, 0x158a, 0x158c, 0x7, 0x2c3, 0x2, 0x2, 0x158b, 
       0x158d, 0x5, 0x25e, 0x130, 0x2, 0x158c, 0x158b, 0x3, 0x2, 0x2, 0x2, 
       0x158c, 0x158d, 0x3, 0x2, 0x2, 0x2, 0x158d, 0x2a7, 0x3, 0x2, 0x2, 
       0x2, 0x158e, 0x1593, 0x7, 0x246, 0x2, 0x2, 0x158f, 0x1590, 0x7, 0x7, 
       0x2, 0x2, 0x1590, 0x1591, 0x7, 0x2fb, 0x2, 0x2, 0x1591, 0x1592, 0x7, 
       0x2ed, 0x2, 0x2, 0x1592, 0x1594, 0x7, 0x2fc, 0x2, 0x2, 0x1593, 0x158f, 
       0x3, 0x2, 0x2, 0x2, 0x1593, 0x1594, 0x3, 0x2, 0x2, 0x2, 0x1594, 0x1595, 
       0x3, 0x2, 0x2, 0x2, 0x1595, 0x159c, 0x7, 0x2ca, 0x2, 0x2, 0x1596, 
       0x1599, 0x7, 0x140, 0x2, 0x2, 0x1597, 0x1598, 0x7, 0x313, 0x2, 0x2, 
       0x1598, 0x159a, 0x7, 0x301, 0x2, 0x2, 0x1599, 0x1597, 0x3, 0x2, 0x2, 
       0x2, 0x1599, 0x159a, 0x3, 0x2, 0x2, 0x2, 0x159a, 0x159b, 0x3, 0x2, 
       0x2, 0x2, 0x159b, 0x159d, 0x7, 0x313, 0x2, 0x2, 0x159c, 0x1596, 0x3, 
       0x2, 0x2, 0x2, 0x159c, 0x159d, 0x3, 0x2, 0x2, 0x2, 0x159d, 0x2a9, 
       0x3, 0x2, 0x2, 0x2, 0x159e, 0x15a2, 0x7, 0x244, 0x2, 0x2, 0x159f, 
       0x15a0, 0x7, 0x52, 0x2, 0x2, 0x15a0, 0x15a3, 0x7, 0x244, 0x2, 0x2, 
       0x15a1, 0x15a3, 0x7, 0x53, 0x2, 0x2, 0x15a2, 0x159f, 0x3, 0x2, 0x2, 
       0x2, 0x15a2, 0x15a1, 0x3, 0x2, 0x2, 0x2, 0x15a3, 0x15a6, 0x3, 0x2, 
       0x2, 0x2, 0x15a4, 0x15a7, 0x5, 0x354, 0x1ab, 0x2, 0x15a5, 0x15a7, 
       0x7, 0x92, 0x2, 0x2, 0x15a6, 0x15a4, 0x3, 0x2, 0x2, 0x2, 0x15a6, 
       0x15a5, 0x3, 0x2, 0x2, 0x2, 0x15a7, 0x2ab, 0x3, 0x2, 0x2, 0x2, 0x15a8, 
       0x15a9, 0x7, 0x244, 0x2, 0x2, 0x15a9, 0x15b1, 0x7, 0x192, 0x2, 0x2, 
       0x15aa, 0x15ab, 0x7, 0x2f4, 0x2, 0x2, 0x15ab, 0x15b2, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x15ac, 0x15ae, 0x5, 0x354, 0x1ab, 0x2, 0x15ad, 0x15af, 
       0x5, 0x446, 0x224, 0x2, 0x15ae, 0x15ad, 0x3, 0x2, 0x2, 0x2, 0x15ae, 
       0x15af, 0x3, 0x2, 0x2, 0x2, 0x15af, 0x15b2, 0x3, 0x2, 0x2, 0x2, 0x15b0, 
       0x15b2, 0x7, 0x92, 0x2, 0x2, 0x15b1, 0x15aa, 0x3, 0x2, 0x2, 0x2, 
       0x15b1, 0x15ac, 0x3, 0x2, 0x2, 0x2, 0x15b1, 0x15b0, 0x3, 0x2, 0x2, 
       0x2, 0x15b2, 0x2ad, 0x3, 0x2, 0x2, 0x2, 0x15b3, 0x15b4, 0x7, 0x59, 
       0x2, 0x2, 0x15b4, 0x15b5, 0x5, 0x2b0, 0x159, 0x2, 0x15b5, 0x2af, 
       0x3, 0x2, 0x2, 0x2, 0x15b6, 0x15b7, 0x7, 0x146, 0x2, 0x2, 0x15b7, 
       0x15b8, 0x7, 0x83, 0x2, 0x2, 0x15b8, 0x15ba, 0x7, 0x9f, 0x2, 0x2, 
       0x15b9, 0x15bb, 0x7, 0x2f4, 0x2, 0x2, 0x15ba, 0x15b9, 0x3, 0x2, 0x2, 
       0x2, 0x15ba, 0x15bb, 0x3, 0x2, 0x2, 0x2, 0x15bb, 0x15bc, 0x3, 0x2, 
       0x2, 0x2, 0x15bc, 0x15d3, 0x5, 0x38a, 0x1c6, 0x2, 0x15bd, 0x15be, 
       0x7, 0x116, 0x2, 0x2, 0x15be, 0x15bf, 0x7, 0xe5, 0x2, 0x2, 0x15bf, 
       0x15c0, 0x5, 0x388, 0x1c5, 0x2, 0x15c0, 0x15c1, 0x7, 0x105, 0x2, 
       0x2, 0x15c1, 0x15c2, 0x7, 0x45, 0x2, 0x2, 0x15c2, 0x15c9, 0x5, 0x32c, 
       0x197, 0x2, 0x15c3, 0x15c4, 0x7, 0x83, 0x2, 0x2, 0x15c4, 0x15c6, 
       0x7, 0x9f, 0x2, 0x2, 0x15c5, 0x15c7, 0x7, 0x2f4, 0x2, 0x2, 0x15c6, 
       0x15c5, 0x3, 0x2, 0x2, 0x2, 0x15c6, 0x15c7, 0x3, 0x2, 0x2, 0x2, 0x15c7, 
       0x15c8, 0x3, 0x2, 0x2, 0x2, 0x15c8, 0x15ca, 0x5, 0x38a, 0x1c6, 0x2, 
       0x15c9, 0x15c3, 0x3, 0x2, 0x2, 0x2, 0x15c9, 0x15ca, 0x3, 0x2, 0x2, 
       0x2, 0x15ca, 0x15d0, 0x3, 0x2, 0x2, 0x2, 0x15cb, 0x15cd, 0x7, 0x211, 
       0x2, 0x2, 0x15cc, 0x15ce, 0x7, 0x19d, 0x2, 0x2, 0x15cd, 0x15cc, 0x3, 
       0x2, 0x2, 0x2, 0x15cd, 0x15ce, 0x3, 0x2, 0x2, 0x2, 0x15ce, 0x15cf, 
       0x3, 0x2, 0x2, 0x2, 0x15cf, 0x15d1, 0x7, 0x26e, 0x2, 0x2, 0x15d0, 
       0x15cb, 0x3, 0x2, 0x2, 0x2, 0x15d0, 0x15d1, 0x3, 0x2, 0x2, 0x2, 0x15d1, 
       0x15d3, 0x3, 0x2, 0x2, 0x2, 0x15d2, 0x15b6, 0x3, 0x2, 0x2, 0x2, 0x15d2, 
       0x15bd, 0x3, 0x2, 0x2, 0x2, 0x15d3, 0x2b1, 0x3, 0x2, 0x2, 0x2, 0x15d4, 
       0x15d6, 0x7, 0x78, 0x2, 0x2, 0x15d5, 0x15d7, 0x7, 0x23, 0x2, 0x2, 
       0x15d6, 0x15d5, 0x3, 0x2, 0x2, 0x2, 0x15d6, 0x15d7, 0x3, 0x2, 0x2, 
       0x2, 0x15d7, 0x15d8, 0x3, 0x2, 0x2, 0x2, 0x15d8, 0x15d9, 0x7, 0xe8, 
       0x2, 0x2, 0x15d9, 0x15da, 0x5, 0x36a, 0x1b6, 0x2, 0x15da, 0x15db, 
       0x7, 0x21f, 0x2, 0x2, 0x15db, 0x15dc, 0x9, 0x43, 0x2, 0x2, 0x15dc, 
       0x15dd, 0x7, 0x252, 0x2, 0x2, 0x15dd, 0x15de, 0x5, 0x37e, 0x1c0, 
       0x2, 0x15de, 0x2b3, 0x3, 0x2, 0x2, 0x2, 0x15df, 0x15e2, 0x5, 0x2b8, 
       0x15d, 0x2, 0x15e0, 0x15e2, 0x5, 0x2ba, 0x15e, 0x2, 0x15e1, 0x15df, 
       0x3, 0x2, 0x2, 0x2, 0x15e1, 0x15e0, 0x3, 0x2, 0x2, 0x2, 0x15e2, 0x2b5, 
       0x3, 0x2, 0x2, 0x2, 0x15e3, 0x15e6, 0x5, 0x2bc, 0x15f, 0x2, 0x15e4, 
       0x15e6, 0x5, 0x2be, 0x160, 0x2, 0x15e5, 0x15e3, 0x3, 0x2, 0x2, 0x2, 
       0x15e5, 0x15e4, 0x3, 0x2, 0x2, 0x2, 0x15e6, 0x2b7, 0x3, 0x2, 0x2, 
       0x2, 0x15e7, 0x15e8, 0x7, 0x115, 0x2, 0x2, 0x15e8, 0x15e9, 0x7, 0x68, 
       0x2, 0x2, 0x15e9, 0x15ee, 0x5, 0x380, 0x1c1, 0x2, 0x15ea, 0x15eb, 
       0x7, 0x301, 0x2, 0x2, 0x15eb, 0x15ed, 0x5, 0x380, 0x1c1, 0x2, 0x15ec, 
       0x15ea, 0x3, 0x2, 0x2, 0x2, 0x15ed, 0x15f0, 0x3, 0x2, 0x2, 0x2, 0x15ee, 
       0x15ec, 0x3, 0x2, 0x2, 0x2, 0x15ee, 0x15ef, 0x3, 0x2, 0x2, 0x2, 0x15ef, 
       0x2b9, 0x3, 0x2, 0x2, 0x2, 0x15f0, 0x15ee, 0x3, 0x2, 0x2, 0x2, 0x15f1, 
       0x15f2, 0x7, 0x115, 0x2, 0x2, 0x15f2, 0x15f3, 0x7, 0x1d2, 0x2, 0x2, 
       0x15f3, 0x15f4, 0x5, 0x382, 0x1c2, 0x2, 0x15f4, 0x15f5, 0x7, 0x252, 
       0x2, 0x2, 0x15f5, 0x15f6, 0x5, 0x37e, 0x1c0, 0x2, 0x15f6, 0x2bb, 
       0x3, 0x2, 0x2, 0x2, 0x15f7, 0x15f8, 0x7, 0x2ab, 0x2, 0x2, 0x15f8, 
       0x15f9, 0x7, 0x68, 0x2, 0x2, 0x15f9, 0x15fe, 0x5, 0x380, 0x1c1, 0x2, 
       0x15fa, 0x15fb, 0x7, 0x301, 0x2, 0x2, 0x15fb, 0x15fd, 0x5, 0x380, 
       0x1c1, 0x2, 0x15fc, 0x15fa, 0x3, 0x2, 0x2, 0x2, 0x15fd, 0x1600, 0x3, 
       0x2, 0x2, 0x2, 0x15fe, 0x15fc, 0x3, 0x2, 0x2, 0x2, 0x15fe, 0x15ff, 
       0x3, 0x2, 0x2, 0x2, 0x15ff, 0x2bd, 0x3, 0x2, 0x2, 0x2, 0x1600, 0x15fe, 
       0x3, 0x2, 0x2, 0x2, 0x1601, 0x1602, 0x7, 0x2ab, 0x2, 0x2, 0x1602, 
       0x1603, 0x7, 0x1d2, 0x2, 0x2, 0x1603, 0x1604, 0x5, 0x382, 0x1c2, 
       0x2, 0x1604, 0x2bf, 0x3, 0x2, 0x2, 0x2, 0x1605, 0x1607, 0x7, 0x28, 
       0x2, 0x2, 0x1606, 0x1608, 0x9, 0x44, 0x2, 0x2, 0x1607, 0x1606, 0x3, 
       0x2, 0x2, 0x2, 0x1607, 0x1608, 0x3, 0x2, 0x2, 0x2, 0x1608, 0x1609, 
       0x3, 0x2, 0x2, 0x2, 0x1609, 0x160a, 0x5, 0x398, 0x1cd, 0x2, 0x160a, 
       0x160c, 0x5, 0x374, 0x1bb, 0x2, 0x160b, 0x160d, 0x5, 0x2c2, 0x162, 
       0x2, 0x160c, 0x160b, 0x3, 0x2, 0x2, 0x2, 0x160c, 0x160d, 0x3, 0x2, 
       0x2, 0x2, 0x160d, 0x2c1, 0x3, 0x2, 0x2, 0x2, 0x160e, 0x160f, 0x7, 
       0x2b2, 0x2, 0x2, 0x160f, 0x1610, 0x7, 0xfd, 0x2, 0x2, 0x1610, 0x1611, 
       0x7, 0x1b0, 0x2, 0x2, 0x1611, 0x1615, 0x5, 0x378, 0x1bd, 0x2, 0x1612, 
       0x1613, 0x7, 0x2d1, 0x2, 0x2, 0x1613, 0x1614, 0x7, 0x313, 0x2, 0x2, 
       0x1614, 0x1616, 0x7, 0x44, 0x2, 0x2, 0x1615, 0x1612, 0x3, 0x2, 0x2, 
       0x2, 0x1615, 0x1616, 0x3, 0x2, 0x2, 0x2, 0x1616, 0x161c, 0x3, 0x2, 
       0x2, 0x2, 0x1617, 0x1618, 0x7, 0xa8, 0x2, 0x2, 0x1618, 0x1619, 0x7, 
       0xfd, 0x2, 0x2, 0x1619, 0x161a, 0x7, 0x1b0, 0x2, 0x2, 0x161a, 0x161c, 
       0x5, 0x378, 0x1bd, 0x2, 0x161b, 0x160e, 0x3, 0x2, 0x2, 0x2, 0x161b, 
       0x1617, 0x3, 0x2, 0x2, 0x2, 0x161c, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0x161d, 
       0x161e, 0x7, 0x54, 0x2, 0x2, 0x161e, 0x161f, 0x5, 0x398, 0x1cd, 0x2, 
       0x161f, 0x1621, 0x5, 0x374, 0x1bb, 0x2, 0x1620, 0x1622, 0x5, 0x2c6, 
       0x164, 0x2, 0x1621, 0x1620, 0x3, 0x2, 0x2, 0x2, 0x1621, 0x1622, 0x3, 
       0x2, 0x2, 0x2, 0x1622, 0x2c5, 0x3, 0x2, 0x2, 0x2, 0x1623, 0x1624, 
       0x7, 0xe0, 0x2, 0x2, 0x1624, 0x162b, 0x7, 0x2b3, 0x2, 0x2, 0x1625, 
       0x162b, 0x7, 0x1ea, 0x2, 0x2, 0x1626, 0x162b, 0x7, 0xd0, 0x2, 0x2, 
       0x1627, 0x162b, 0x7, 0x178, 0x2, 0x2, 0x1628, 0x162b, 0x7, 0xcc, 
       0x2, 0x2, 0x1629, 0x162b, 0x7, 0x4e, 0x2, 0x2, 0x162a, 0x1623, 0x3, 
       0x2, 0x2, 0x2, 0x162a, 0x1625, 0x3, 0x2, 0x2, 0x2, 0x162a, 0x1626, 
       0x3, 0x2, 0x2, 0x2, 0x162a, 0x1627, 0x3, 0x2, 0x2, 0x2, 0x162a, 0x1628, 
       0x3, 0x2, 0x2, 0x2, 0x162a, 0x1629, 0x3, 0x2, 0x2, 0x2, 0x162b, 0x2c7, 
       0x3, 0x2, 0x2, 0x2, 0x162c, 0x162d, 0x7, 0x55, 0x2, 0x2, 0x162d, 
       0x162e, 0x5, 0x398, 0x1cd, 0x2, 0x162e, 0x1630, 0x5, 0x374, 0x1bb, 
       0x2, 0x162f, 0x1631, 0x9, 0x45, 0x2, 0x2, 0x1630, 0x162f, 0x3, 0x2, 
       0x2, 0x2, 0x1630, 0x1631, 0x3, 0x2, 0x2, 0x2, 0x1631, 0x2c9, 0x3, 
       0x2, 0x2, 0x2, 0x1632, 0x1634, 0x7, 0x1b4, 0x2, 0x2, 0x1633, 0x1635, 
       0x9, 0x44, 0x2, 0x2, 0x1634, 0x1633, 0x3, 0x2, 0x2, 0x2, 0x1634, 
       0x1635, 0x3, 0x2, 0x2, 0x2, 0x1635, 0x1636, 0x3, 0x2, 0x2, 0x2, 0x1636, 
       0x1637, 0x5, 0x398, 0x1cd, 0x2, 0x1637, 0x1638, 0x5, 0x374, 0x1bb, 
       0x2, 0x1638, 0x2cb, 0x3, 0x2, 0x2, 0x2, 0x1639, 0x163b, 0x7, 0x205, 
       0x2, 0x2, 0x163a, 0x163c, 0x9, 0x44, 0x2, 0x2, 0x163b, 0x163a, 0x3, 
       0x2, 0x2, 0x2, 0x163b, 0x163c, 0x3, 0x2, 0x2, 0x2, 0x163c, 0x163d, 
       0x3, 0x2, 0x2, 0x2, 0x163d, 0x163e, 0x5, 0x398, 0x1cd, 0x2, 0x163e, 
       0x1640, 0x5, 0x374, 0x1bb, 0x2, 0x163f, 0x1641, 0x7, 0x1ea, 0x2, 
       0x2, 0x1640, 0x163f, 0x3, 0x2, 0x2, 0x2, 0x1640, 0x1641, 0x3, 0x2, 
       0x2, 0x2, 0x1641, 0x1643, 0x3, 0x2, 0x2, 0x2, 0x1642, 0x1644, 0x7, 
       0xcc, 0x2, 0x2, 0x1643, 0x1642, 0x3, 0x2, 0x2, 0x2, 0x1643, 0x1644, 
       0x3, 0x2, 0x2, 0x2, 0x1644, 0x1646, 0x3, 0x2, 0x2, 0x2, 0x1645, 0x1647, 
       0x7, 0x2b8, 0x2, 0x2, 0x1646, 0x1645, 0x3, 0x2, 0x2, 0x2, 0x1646, 
       0x1647, 0x3, 0x2, 0x2, 0x2, 0x1647, 0x2cd, 0x3, 0x2, 0x2, 0x2, 0x1648, 
       0x1649, 0x7, 0x26, 0x2, 0x2, 0x1649, 0x164a, 0x7, 0x215, 0x2, 0x2, 
       0x164a, 0x164b, 0x7, 0xf4, 0x2, 0x2, 0x164b, 0x1658, 0x5, 0x37a, 
       0x1be, 0x2, 0x164c, 0x164e, 0x7, 0x2c5, 0x2, 0x2, 0x164d, 0x164f, 
       0x7, 0x2f4, 0x2, 0x2, 0x164e, 0x164d, 0x3, 0x2, 0x2, 0x2, 0x164e, 
       0x164f, 0x3, 0x2, 0x2, 0x2, 0x164f, 0x1650, 0x3, 0x2, 0x2, 0x2, 0x1650, 
       0x1655, 0x5, 0x2d0, 0x169, 0x2, 0x1651, 0x1652, 0x7, 0x301, 0x2, 
       0x2, 0x1652, 0x1654, 0x5, 0x2d0, 0x169, 0x2, 0x1653, 0x1651, 0x3, 
       0x2, 0x2, 0x2, 0x1654, 0x1657, 0x3, 0x2, 0x2, 0x2, 0x1655, 0x1653, 
       0x3, 0x2, 0x2, 0x2, 0x1655, 0x1656, 0x3, 0x2, 0x2, 0x2, 0x1656, 0x1659, 
       0x3, 0x2, 0x2, 0x2, 0x1657, 0x1655, 0x3, 0x2, 0x2, 0x2, 0x1658, 0x164c, 
       0x3, 0x2, 0x2, 0x2, 0x1658, 0x1659, 0x3, 0x2, 0x2, 0x2, 0x1659, 0x165f, 
       0x3, 0x2, 0x2, 0x2, 0x165a, 0x165c, 0x7, 0x291, 0x2, 0x2, 0x165b, 
       0x165d, 0x7, 0x2f4, 0x2, 0x2, 0x165c, 0x165b, 0x3, 0x2, 0x2, 0x2, 
       0x165c, 0x165d, 0x3, 0x2, 0x2, 0x2, 0x165d, 0x165e, 0x3, 0x2, 0x2, 
       0x2, 0x165e, 0x1660, 0x7, 0x313, 0x2, 0x2, 0x165f, 0x165a, 0x3, 0x2, 
       0x2, 0x2, 0x165f, 0x1660, 0x3, 0x2, 0x2, 0x2, 0x1660, 0x1666, 0x3, 
       0x2, 0x2, 0x2, 0x1661, 0x1667, 0x7, 0xb1, 0x2, 0x2, 0x1662, 0x1664, 
       0x7, 0xa0, 0x2, 0x2, 0x1663, 0x1665, 0x7, 0xe1, 0x2, 0x2, 0x1664, 
       0x1663, 0x3, 0x2, 0x2, 0x2, 0x1664, 0x1665, 0x3, 0x2, 0x2, 0x2, 0x1665, 
       0x1667, 0x3, 0x2, 0x2, 0x2, 0x1666, 0x1661, 0x3, 0x2, 0x2, 0x2, 0x1666, 
       0x1662, 0x3, 0x2, 0x2, 0x2, 0x1666, 0x1667, 0x3, 0x2, 0x2, 0x2, 0x1667, 
       0x2cf, 0x3, 0x2, 0x2, 0x2, 0x1668, 0x166d, 0x7, 0x313, 0x2, 0x2, 
       0x1669, 0x166a, 0x7, 0x313, 0x2, 0x2, 0x166a, 0x166b, 0x7, 0x2ec, 
       0x2, 0x2, 0x166b, 0x166d, 0x7, 0x313, 0x2, 0x2, 0x166c, 0x1668, 0x3, 
       0x2, 0x2, 0x2, 0x166c, 0x1669, 0x3, 0x2, 0x2, 0x2, 0x166d, 0x2d1, 
       0x3, 0x2, 0x2, 0x2, 0x166e, 0x166f, 0x7, 0x78, 0x2, 0x2, 0x166f, 
       0x1670, 0x7, 0x215, 0x2, 0x2, 0x1670, 0x1671, 0x7, 0xf4, 0x2, 0x2, 
       0x1671, 0x1672, 0x5, 0x37a, 0x1be, 0x2, 0x1672, 0x1673, 0x7, 0x2a2, 
       0x2, 0x2, 0x1673, 0x1674, 0x7, 0x2f4, 0x2, 0x2, 0x1674, 0x1681, 0x9, 
       0x46, 0x2, 0x2, 0x1675, 0x1677, 0x7, 0x2c5, 0x2, 0x2, 0x1676, 0x1678, 
       0x7, 0x2f4, 0x2, 0x2, 0x1677, 0x1676, 0x3, 0x2, 0x2, 0x2, 0x1677, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x1678, 0x1679, 0x3, 0x2, 0x2, 0x2, 0x1679, 
       0x167e, 0x5, 0x2d0, 0x169, 0x2, 0x167a, 0x167b, 0x7, 0x301, 0x2, 
       0x2, 0x167b, 0x167d, 0x5, 0x2d0, 0x169, 0x2, 0x167c, 0x167a, 0x3, 
       0x2, 0x2, 0x2, 0x167d, 0x1680, 0x3, 0x2, 0x2, 0x2, 0x167e, 0x167c, 
       0x3, 0x2, 0x2, 0x2, 0x167e, 0x167f, 0x3, 0x2, 0x2, 0x2, 0x167f, 0x1682, 
       0x3, 0x2, 0x2, 0x2, 0x1680, 0x167e, 0x3, 0x2, 0x2, 0x2, 0x1681, 0x1675, 
       0x3, 0x2, 0x2, 0x2, 0x1681, 0x1682, 0x3, 0x2, 0x2, 0x2, 0x1682, 0x1688, 
       0x3, 0x2, 0x2, 0x2, 0x1683, 0x1685, 0x7, 0x291, 0x2, 0x2, 0x1684, 
       0x1686, 0x7, 0x2f4, 0x2, 0x2, 0x1685, 0x1684, 0x3, 0x2, 0x2, 0x2, 
       0x1685, 0x1686, 0x3, 0x2, 0x2, 0x2, 0x1686, 0x1687, 0x3, 0x2, 0x2, 
       0x2, 0x1687, 0x1689, 0x7, 0x313, 0x2, 0x2, 0x1688, 0x1683, 0x3, 0x2, 
       0x2, 0x2, 0x1688, 0x1689, 0x3, 0x2, 0x2, 0x2, 0x1689, 0x168b, 0x3, 
       0x2, 0x2, 0x2, 0x168a, 0x168c, 0x9, 0x1b, 0x2, 0x2, 0x168b, 0x168a, 
       0x3, 0x2, 0x2, 0x2, 0x168b, 0x168c, 0x3, 0x2, 0x2, 0x2, 0x168c, 0x2d3, 
       0x3, 0x2, 0x2, 0x2, 0x168d, 0x168e, 0x7, 0xa8, 0x2, 0x2, 0x168e, 
       0x168f, 0x7, 0x215, 0x2, 0x2, 0x168f, 0x1690, 0x7, 0xf4, 0x2, 0x2, 
       0x1690, 0x1692, 0x5, 0x37a, 0x1be, 0x2, 0x1691, 0x1693, 0x7, 0xe1, 
       0x2, 0x2, 0x1692, 0x1691, 0x3, 0x2, 0x2, 0x2, 0x1692, 0x1693, 0x3, 
       0x2, 0x2, 0x2, 0x1693, 0x2d5, 0x3, 0x2, 0x2, 0x2, 0x1694, 0x1695, 
       0x7, 0x244, 0x2, 0x2, 0x1695, 0x1696, 0x7, 0x215, 0x2, 0x2, 0x1696, 
       0x1697, 0x7, 0xf4, 0x2, 0x2, 0x1697, 0x16a1, 0x5, 0x37a, 0x1be, 0x2, 
       0x1698, 0x1699, 0x7, 0xe0, 0x2, 0x2, 0x1699, 0x169e, 0x7, 0x313, 
       0x2, 0x2, 0x169a, 0x169b, 0x7, 0x301, 0x2, 0x2, 0x169b, 0x169d, 0x7, 
       0x313, 0x2, 0x2, 0x169c, 0x169a, 0x3, 0x2, 0x2, 0x2, 0x169d, 0x16a0, 
       0x3, 0x2, 0x2, 0x2, 0x169e, 0x169c, 0x3, 0x2, 0x2, 0x2, 0x169e, 0x169f, 
       0x3, 0x2, 0x2, 0x2, 0x169f, 0x16a2, 0x3, 0x2, 0x2, 0x2, 0x16a0, 0x169e, 
       0x3, 0x2, 0x2, 0x2, 0x16a1, 0x1698, 0x3, 0x2, 0x2, 0x2, 0x16a1, 0x16a2, 
       0x3, 0x2, 0x2, 0x2, 0x16a2, 0x2d7, 0x3, 0x2, 0x2, 0x2, 0x16a3, 0x16a4, 
       0x7, 0x3c, 0x2, 0x2, 0x16a4, 0x16a5, 0x5, 0x32e, 0x198, 0x2, 0x16a5, 
       0x2d9, 0x3, 0x2, 0x2, 0x2, 0x16a6, 0x16a7, 0x7, 0x47, 0x2, 0x2, 0x16a7, 
       0x16b6, 0x7, 0x10c, 0x2, 0x2, 0x16a8, 0x16ad, 0x5, 0x2dc, 0x16f, 
       0x2, 0x16a9, 0x16aa, 0x7, 0x301, 0x2, 0x2, 0x16aa, 0x16ac, 0x5, 0x2dc, 
       0x16f, 0x2, 0x16ab, 0x16a9, 0x3, 0x2, 0x2, 0x2, 0x16ac, 0x16af, 0x3, 
       0x2, 0x2, 0x2, 0x16ad, 0x16ab, 0x3, 0x2, 0x2, 0x2, 0x16ad, 0x16ae, 
       0x3, 0x2, 0x2, 0x2, 0x16ae, 0x16b7, 0x3, 0x2, 0x2, 0x2, 0x16af, 0x16ad, 
       0x3, 0x2, 0x2, 0x2, 0x16b0, 0x16b1, 0x5, 0x35a, 0x1ae, 0x2, 0x16b1, 
       0x16b2, 0x7, 0x1c8, 0x2, 0x2, 0x16b2, 0x16b3, 0x7, 0x2fb, 0x2, 0x2, 
       0x16b3, 0x16b4, 0x5, 0x2de, 0x170, 0x2, 0x16b4, 0x16b5, 0x7, 0x2fc, 
       0x2, 0x2, 0x16b5, 0x16b7, 0x3, 0x2, 0x2, 0x2, 0x16b6, 0x16a8, 0x3, 
       0x2, 0x2, 0x2, 0x16b6, 0x16b0, 0x3, 0x2, 0x2, 0x2, 0x16b7, 0x16b8, 
       0x3, 0x2, 0x2, 0x2, 0x16b8, 0x16bb, 0x7, 0x10a, 0x2, 0x2, 0x16b9, 
       0x16bc, 0x5, 0x33e, 0x1a0, 0x2, 0x16ba, 0x16bc, 0x7, 0x92, 0x2, 0x2, 
       0x16bb, 0x16b9, 0x3, 0x2, 0x2, 0x2, 0x16bb, 0x16ba, 0x3, 0x2, 0x2, 
       0x2, 0x16bc, 0x2db, 0x3, 0x2, 0x2, 0x2, 0x16bd, 0x16c3, 0x5, 0x35a, 
       0x1ae, 0x2, 0x16be, 0x16bf, 0x7, 0x1c8, 0x2, 0x2, 0x16bf, 0x16c0, 
       0x7, 0x2fb, 0x2, 0x2, 0x16c0, 0x16c1, 0x5, 0x2de, 0x170, 0x2, 0x16c1, 
       0x16c2, 0x7, 0x2fc, 0x2, 0x2, 0x16c2, 0x16c4, 0x3, 0x2, 0x2, 0x2, 
       0x16c3, 0x16be, 0x3, 0x2, 0x2, 0x2, 0x16c3, 0x16c4, 0x3, 0x2, 0x2, 
       0x2, 0x16c4, 0x16d1, 0x3, 0x2, 0x2, 0x2, 0x16c5, 0x16c6, 0x9, 0xe, 
       0x2, 0x2, 0x16c6, 0x16c7, 0x7, 0x2fb, 0x2, 0x2, 0x16c7, 0x16cc, 0x5, 
       0x35e, 0x1b0, 0x2, 0x16c8, 0x16c9, 0x7, 0x301, 0x2, 0x2, 0x16c9, 
       0x16cb, 0x5, 0x35e, 0x1b0, 0x2, 0x16ca, 0x16c8, 0x3, 0x2, 0x2, 0x2, 
       0x16cb, 0x16ce, 0x3, 0x2, 0x2, 0x2, 0x16cc, 0x16ca, 0x3, 0x2, 0x2, 
       0x2, 0x16cc, 0x16cd, 0x3, 0x2, 0x2, 0x2, 0x16cd, 0x16cf, 0x3, 0x2, 
       0x2, 0x2, 0x16ce, 0x16cc, 0x3, 0x2, 0x2, 0x2, 0x16cf, 0x16d0, 0x7, 
       0x2fc, 0x2, 0x2, 0x16d0, 0x16d2, 0x3, 0x2, 0x2, 0x2, 0x16d1, 0x16c5, 
       0x3, 0x2, 0x2, 0x2, 0x16d1, 0x16d2, 0x3, 0x2, 0x2, 0x2, 0x16d2, 0x16d5, 
       0x3, 0x2, 0x2, 0x2, 0x16d3, 0x16d4, 0x7, 0x107, 0x2, 0x2, 0x16d4, 
       0x16d6, 0x7, 0x13b, 0x2, 0x2, 0x16d5, 0x16d3, 0x3, 0x2, 0x2, 0x2, 
       0x16d5, 0x16d6, 0x3, 0x2, 0x2, 0x2, 0x16d6, 0x2dd, 0x3, 0x2, 0x2, 
       0x2, 0x16d7, 0x16dc, 0x5, 0x39c, 0x1cf, 0x2, 0x16d8, 0x16d9, 0x7, 
       0x301, 0x2, 0x2, 0x16d9, 0x16db, 0x5, 0x39c, 0x1cf, 0x2, 0x16da, 
       0x16d8, 0x3, 0x2, 0x2, 0x2, 0x16db, 0x16de, 0x3, 0x2, 0x2, 0x2, 0x16dc, 
       0x16da, 0x3, 0x2, 0x2, 0x2, 0x16dc, 0x16dd, 0x3, 0x2, 0x2, 0x2, 0x16dd, 
       0x16e1, 0x3, 0x2, 0x2, 0x2, 0x16de, 0x16dc, 0x3, 0x2, 0x2, 0x2, 0x16df, 
       0x16e1, 0x7, 0x25, 0x2, 0x2, 0x16e0, 0x16d7, 0x3, 0x2, 0x2, 0x2, 
       0x16e0, 0x16df, 0x3, 0x2, 0x2, 0x2, 0x16e1, 0x2df, 0x3, 0x2, 0x2, 
       0x2, 0x16e2, 0x16e4, 0x7, 0xdd, 0x2, 0x2, 0x16e3, 0x16e5, 0x9, 0x44, 
       0x2, 0x2, 0x16e4, 0x16e3, 0x3, 0x2, 0x2, 0x2, 0x16e4, 0x16e5, 0x3, 
       0x2, 0x2, 0x2, 0x16e5, 0x16ef, 0x3, 0x2, 0x2, 0x2, 0x16e6, 0x16eb, 
       0x5, 0x2e2, 0x172, 0x2, 0x16e7, 0x16e8, 0x7, 0x301, 0x2, 0x2, 0x16e8, 
       0x16ea, 0x5, 0x2e2, 0x172, 0x2, 0x16e9, 0x16e7, 0x3, 0x2, 0x2, 0x2, 
       0x16ea, 0x16ed, 0x3, 0x2, 0x2, 0x2, 0x16eb, 0x16e9, 0x3, 0x2, 0x2, 
       0x2, 0x16eb, 0x16ec, 0x3, 0x2, 0x2, 0x2, 0x16ec, 0x16f0, 0x3, 0x2, 
       0x2, 0x2, 0x16ed, 0x16eb, 0x3, 0x2, 0x2, 0x2, 0x16ee, 0x16f0, 0x5, 
       0x2e4, 0x173, 0x2, 0x16ef, 0x16e6, 0x3, 0x2, 0x2, 0x2, 0x16ef, 0x16ee, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x2e1, 0x3, 0x2, 0x2, 0x2, 0x16f1, 0x16f2, 
       0x7, 0x3b, 0x2, 0x2, 0x16f2, 0x1709, 0x7, 0x14d, 0x2, 0x2, 0x16f3, 
       0x16f4, 0x7, 0xb7, 0x2, 0x2, 0x16f4, 0x1709, 0x7, 0x14d, 0x2, 0x2, 
       0x16f5, 0x16f6, 0x7, 0xbb, 0x2, 0x2, 0x16f6, 0x1709, 0x7, 0x14d, 
       0x2, 0x2, 0x16f7, 0x16f8, 0x7, 0xe9, 0x2, 0x2, 0x16f8, 0x1709, 0x7, 
       0x14d, 0x2, 0x2, 0x16f9, 0x1709, 0x7, 0x100, 0x2, 0x2, 0x16fa, 0x1709, 
       0x7, 0x14d, 0x2, 0x2, 0x16fb, 0x1709, 0x7, 0x1df, 0x2, 0x2, 0x16fc, 
       0x1709, 0x7, 0x1b5, 0x2, 0x2, 0x16fd, 0x16fe, 0x7, 0x1fb, 0x2, 0x2, 
       0x16fe, 0x1702, 0x7, 0x14d, 0x2, 0x2, 0x16ff, 0x1700, 0x7, 0xe0, 
       0x2, 0x2, 0x1700, 0x1701, 0x7, 0x50, 0x2, 0x2, 0x1701, 0x1703, 0x5, 
       0x38c, 0x1c7, 0x2, 0x1702, 0x16ff, 0x3, 0x2, 0x2, 0x2, 0x1702, 0x1703, 
       0x3, 0x2, 0x2, 0x2, 0x1703, 0x1709, 0x3, 0x2, 0x2, 0x2, 0x1704, 0x1705, 
       0x7, 0x24d, 0x2, 0x2, 0x1705, 0x1709, 0x7, 0x14d, 0x2, 0x2, 0x1706, 
       0x1709, 0x7, 0x276, 0x2, 0x2, 0x1707, 0x1709, 0x7, 0x2b7, 0x2, 0x2, 
       0x1708, 0x16f1, 0x3, 0x2, 0x2, 0x2, 0x1708, 0x16f3, 0x3, 0x2, 0x2, 
       0x2, 0x1708, 0x16f5, 0x3, 0x2, 0x2, 0x2, 0x1708, 0x16f7, 0x3, 0x2, 
       0x2, 0x2, 0x1708, 0x16f9, 0x3, 0x2, 0x2, 0x2, 0x1708, 0x16fa, 0x3, 
       0x2, 0x2, 0x2, 0x1708, 0x16fb, 0x3, 0x2, 0x2, 0x2, 0x1708, 0x16fc, 
       0x3, 0x2, 0x2, 0x2, 0x1708, 0x16fd, 0x3, 0x2, 0x2, 0x2, 0x1708, 0x1704, 
       0x3, 0x2, 0x2, 0x2, 0x1708, 0x1706, 0x3, 0x2, 0x2, 0x2, 0x1708, 0x1707, 
       0x3, 0x2, 0x2, 0x2, 0x1709, 0x2e3, 0x3, 0x2, 0x2, 0x2, 0x170a, 0x1732, 
       0x7, 0x287, 0x2, 0x2, 0x170b, 0x170c, 0x7, 0x287, 0x2, 0x2, 0x170c, 
       0x1711, 0x5, 0x35a, 0x1ae, 0x2, 0x170d, 0x170e, 0x7, 0x301, 0x2, 
       0x2, 0x170e, 0x1710, 0x5, 0x35a, 0x1ae, 0x2, 0x170f, 0x170d, 0x3, 
       0x2, 0x2, 0x2, 0x1710, 0x1713, 0x3, 0x2, 0x2, 0x2, 0x1711, 0x170f, 
       0x3, 0x2, 0x2, 0x2, 0x1711, 0x1712, 0x3, 0x2, 0x2, 0x2, 0x1712, 0x1732, 
       0x3, 0x2, 0x2, 0x2, 0x1713, 0x1711, 0x3, 0x2, 0x2, 0x2, 0x1714, 0x1715, 
       0x7, 0x287, 0x2, 0x2, 0x1715, 0x1716, 0x7, 0x2d1, 0x2, 0x2, 0x1716, 
       0x1717, 0x7, 0x1ee, 0x2, 0x2, 0x1717, 0x1732, 0x7, 0x149, 0x2, 0x2, 
       0x1718, 0x1719, 0x7, 0x287, 0x2, 0x2, 0x1719, 0x171e, 0x5, 0x35a, 
       0x1ae, 0x2, 0x171a, 0x171b, 0x7, 0x301, 0x2, 0x2, 0x171b, 0x171d, 
       0x5, 0x35a, 0x1ae, 0x2, 0x171c, 0x171a, 0x3, 0x2, 0x2, 0x2, 0x171d, 
       0x1720, 0x3, 0x2, 0x2, 0x2, 0x171e, 0x171c, 0x3, 0x2, 0x2, 0x2, 0x171e, 
       0x171f, 0x3, 0x2, 0x2, 0x2, 0x171f, 0x1721, 0x3, 0x2, 0x2, 0x2, 0x1720, 
       0x171e, 0x3, 0x2, 0x2, 0x2, 0x1721, 0x1722, 0x7, 0x2d1, 0x2, 0x2, 
       0x1722, 0x1723, 0x7, 0x1ee, 0x2, 0x2, 0x1723, 0x1724, 0x7, 0x149, 
       0x2, 0x2, 0x1724, 0x1732, 0x3, 0x2, 0x2, 0x2, 0x1725, 0x1726, 0x7, 
       0x287, 0x2, 0x2, 0x1726, 0x172b, 0x5, 0x35a, 0x1ae, 0x2, 0x1727, 
       0x1728, 0x7, 0x301, 0x2, 0x2, 0x1728, 0x172a, 0x5, 0x35a, 0x1ae, 
       0x2, 0x1729, 0x1727, 0x3, 0x2, 0x2, 0x2, 0x172a, 0x172d, 0x3, 0x2, 
       0x2, 0x2, 0x172b, 0x1729, 0x3, 0x2, 0x2, 0x2, 0x172b, 0x172c, 0x3, 
       0x2, 0x2, 0x2, 0x172c, 0x172e, 0x3, 0x2, 0x2, 0x2, 0x172d, 0x172b, 
       0x3, 0x2, 0x2, 0x2, 0x172e, 0x172f, 0x7, 0xe0, 0x2, 0x2, 0x172f, 
       0x1730, 0x7, 0xcb, 0x2, 0x2, 0x1730, 0x1732, 0x3, 0x2, 0x2, 0x2, 
       0x1731, 0x170a, 0x3, 0x2, 0x2, 0x2, 0x1731, 0x170b, 0x3, 0x2, 0x2, 
       0x2, 0x1731, 0x1714, 0x3, 0x2, 0x2, 0x2, 0x1731, 0x1718, 0x3, 0x2, 
       0x2, 0x2, 0x1731, 0x1725, 0x3, 0x2, 0x2, 0x2, 0x1732, 0x2e5, 0x3, 
       0x2, 0x2, 0x2, 0x1733, 0x1735, 0x7, 0x132, 0x2, 0x2, 0x1734, 0x1736, 
       0x9, 0x47, 0x2, 0x2, 0x1735, 0x1734, 0x3, 0x2, 0x2, 0x2, 0x1735, 
       0x1736, 0x3, 0x2, 0x2, 0x2, 0x1736, 0x1738, 0x3, 0x2, 0x2, 0x2, 0x1737, 
       0x1739, 0x7, 0x313, 0x2, 0x2, 0x1738, 0x1737, 0x3, 0x2, 0x2, 0x2, 
       0x1739, 0x173a, 0x3, 0x2, 0x2, 0x2, 0x173a, 0x1738, 0x3, 0x2, 0x2, 
       0x2, 0x173a, 0x173b, 0x3, 0x2, 0x2, 0x2, 0x173b, 0x2e7, 0x3, 0x2, 
       0x2, 0x2, 0x173c, 0x173d, 0x7, 0x145, 0x2, 0x2, 0x173d, 0x173e, 0x7, 
       0x10c, 0x2, 0x2, 0x173e, 0x173f, 0x7, 0x11f, 0x2, 0x2, 0x173f, 0x1740, 
       0x7, 0x47, 0x2, 0x2, 0x1740, 0x1745, 0x5, 0x2dc, 0x16f, 0x2, 0x1741, 
       0x1742, 0x7, 0x301, 0x2, 0x2, 0x1742, 0x1744, 0x5, 0x2dc, 0x16f, 
       0x2, 0x1743, 0x1741, 0x3, 0x2, 0x2, 0x2, 0x1744, 0x1747, 0x3, 0x2, 
       0x2, 0x2, 0x1745, 0x1743, 0x3, 0x2, 0x2, 0x2, 0x1745, 0x1746, 0x3, 
       0x2, 0x2, 0x2, 0x1746, 0x2e9, 0x3, 0x2, 0x2, 0x2, 0x1747, 0x1745, 
       0x3, 0x2, 0x2, 0x2, 0x1748, 0x1749, 0x7, 0x213, 0x2, 0x2, 0x1749, 
       0x174e, 0x5, 0x2ec, 0x177, 0x2, 0x174a, 0x174b, 0x7, 0x301, 0x2, 
       0x2, 0x174b, 0x174d, 0x5, 0x2ec, 0x177, 0x2, 0x174c, 0x174a, 0x3, 
       0x2, 0x2, 0x2, 0x174d, 0x1750, 0x3, 0x2, 0x2, 0x2, 0x174e, 0x174c, 
       0x3, 0x2, 0x2, 0x2, 0x174e, 0x174f, 0x3, 0x2, 0x2, 0x2, 0x174f, 0x1753, 
       0x3, 0x2, 0x2, 0x2, 0x1750, 0x174e, 0x3, 0x2, 0x2, 0x2, 0x1751, 0x1753, 
       0x5, 0x2ee, 0x178, 0x2, 0x1752, 0x1748, 0x3, 0x2, 0x2, 0x2, 0x1752, 
       0x1751, 0x3, 0x2, 0x2, 0x2, 0x1753, 0x2eb, 0x3, 0x2, 0x2, 0x2, 0x1754, 
       0x1757, 0x7, 0x154, 0x2, 0x2, 0x1755, 0x1756, 0x7, 0x29b, 0x2, 0x2, 
       0x1756, 0x1758, 0x5, 0x40a, 0x206, 0x2, 0x1757, 0x1755, 0x3, 0x2, 
       0x2, 0x2, 0x1757, 0x1758, 0x3, 0x2, 0x2, 0x2, 0x1758, 0x1761, 0x3, 
       0x2, 0x2, 0x2, 0x1759, 0x175b, 0x7, 0x24c, 0x2, 0x2, 0x175a, 0x175c, 
       0x7, 0x25, 0x2, 0x2, 0x175b, 0x175a, 0x3, 0x2, 0x2, 0x2, 0x175b, 
       0x175c, 0x3, 0x2, 0x2, 0x2, 0x175c, 0x175e, 0x3, 0x2, 0x2, 0x2, 0x175d, 
       0x175f, 0x5, 0x45a, 0x22e, 0x2, 0x175e, 0x175d, 0x3, 0x2, 0x2, 0x2, 
       0x175e, 0x175f, 0x3, 0x2, 0x2, 0x2, 0x175f, 0x1761, 0x3, 0x2, 0x2, 
       0x2, 0x1760, 0x1754, 0x3, 0x2, 0x2, 0x2, 0x1760, 0x1759, 0x3, 0x2, 
       0x2, 0x2, 0x1761, 0x2ed, 0x3, 0x2, 0x2, 0x2, 0x1762, 0x1763, 0x7, 
       0x213, 0x2, 0x2, 0x1763, 0x1768, 0x7, 0x1cf, 0x2, 0x2, 0x1764, 0x1766, 
       0x5, 0x44c, 0x227, 0x2, 0x1765, 0x1764, 0x3, 0x2, 0x2, 0x2, 0x1765, 
       0x1766, 0x3, 0x2, 0x2, 0x2, 0x1766, 0x1767, 0x3, 0x2, 0x2, 0x2, 0x1767, 
       0x1769, 0x5, 0x33e, 0x1a0, 0x2, 0x1768, 0x1765, 0x3, 0x2, 0x2, 0x2, 
       0x1768, 0x1769, 0x3, 0x2, 0x2, 0x2, 0x1769, 0x2ef, 0x3, 0x2, 0x2, 
       0x2, 0x176a, 0x176b, 0x7, 0x217, 0x2, 0x2, 0x176b, 0x2f1, 0x3, 0x2, 
       0x2, 0x2, 0x176c, 0x176d, 0x7, 0x247, 0x2, 0x2, 0x176d, 0x2f3, 0x3, 
       0x2, 0x2, 0x2, 0x176e, 0x176f, 0x7, 0xe3, 0x2, 0x2, 0x176f, 0x1770, 
       0x7, 0x2f4, 0x2, 0x2, 0x1770, 0x1771, 0x5, 0x2f8, 0x17d, 0x2, 0x1771, 
       0x2f5, 0x3, 0x2, 0x2, 0x2, 0x1772, 0x1778, 0x5, 0x36, 0x1c, 0x2, 
       0x1773, 0x1778, 0x5, 0x2e, 0x18, 0x2, 0x1774, 0x1778, 0x5, 0x4, 0x3, 
       0x2, 0x1775, 0x1778, 0x5, 0x18, 0xd, 0x2, 0x1776, 0x1778, 0x5, 0x20, 
       0x11, 0x2, 0x1777, 0x1772, 0x3, 0x2, 0x2, 0x2, 0x1777, 0x1773, 0x3, 
       0x2, 0x2, 0x2, 0x1777, 0x1774, 0x3, 0x2, 0x2, 0x2, 0x1777, 0x1775, 
       0x3, 0x2, 0x2, 0x2, 0x1777, 0x1776, 0x3, 0x2, 0x2, 0x2, 0x1778, 0x2f7, 
       0x3, 0x2, 0x2, 0x2, 0x1779, 0x177a, 0x9, 0x48, 0x2, 0x2, 0x177a, 
       0x2f9, 0x3, 0x2, 0x2, 0x2, 0x177b, 0x17a4, 0x5, 0x248, 0x125, 0x2, 
       0x177c, 0x17a4, 0x5, 0x24a, 0x126, 0x2, 0x177d, 0x17a4, 0x5, 0x24c, 
       0x127, 0x2, 0x177e, 0x17a4, 0x5, 0x266, 0x134, 0x2, 0x177f, 0x17a4, 
       0x5, 0x24e, 0x128, 0x2, 0x1780, 0x17a4, 0x5, 0x250, 0x129, 0x2, 0x1781, 
       0x17a4, 0x5, 0x26e, 0x138, 0x2, 0x1782, 0x17a4, 0x5, 0x252, 0x12a, 
       0x2, 0x1783, 0x17a4, 0x5, 0x268, 0x135, 0x2, 0x1784, 0x17a4, 0x5, 
       0x26a, 0x136, 0x2, 0x1785, 0x17a4, 0x5, 0x26c, 0x137, 0x2, 0x1786, 
       0x17a4, 0x5, 0x270, 0x139, 0x2, 0x1787, 0x17a4, 0x5, 0x272, 0x13a, 
       0x2, 0x1788, 0x17a4, 0x5, 0x274, 0x13b, 0x2, 0x1789, 0x17a4, 0x5, 
       0x276, 0x13c, 0x2, 0x178a, 0x17a4, 0x5, 0x278, 0x13d, 0x2, 0x178b, 
       0x17a4, 0x5, 0x27a, 0x13e, 0x2, 0x178c, 0x17a4, 0x5, 0x27c, 0x13f, 
       0x2, 0x178d, 0x17a4, 0x5, 0x27e, 0x140, 0x2, 0x178e, 0x17a4, 0x5, 
       0x280, 0x141, 0x2, 0x178f, 0x17a4, 0x5, 0x282, 0x142, 0x2, 0x1790, 
       0x17a4, 0x5, 0x284, 0x143, 0x2, 0x1791, 0x17a4, 0x5, 0x286, 0x144, 
       0x2, 0x1792, 0x17a4, 0x5, 0x288, 0x145, 0x2, 0x1793, 0x17a4, 0x5, 
       0x28a, 0x146, 0x2, 0x1794, 0x17a4, 0x5, 0x28e, 0x148, 0x2, 0x1795, 
       0x17a4, 0x5, 0x28c, 0x147, 0x2, 0x1796, 0x17a4, 0x5, 0x290, 0x149, 
       0x2, 0x1797, 0x17a4, 0x5, 0x292, 0x14a, 0x2, 0x1798, 0x17a4, 0x5, 
       0x296, 0x14c, 0x2, 0x1799, 0x17a4, 0x5, 0x298, 0x14d, 0x2, 0x179a, 
       0x17a4, 0x5, 0x294, 0x14b, 0x2, 0x179b, 0x17a4, 0x5, 0x29a, 0x14e, 
       0x2, 0x179c, 0x17a4, 0x5, 0x29e, 0x150, 0x2, 0x179d, 0x17a4, 0x5, 
       0x2a0, 0x151, 0x2, 0x179e, 0x17a4, 0x5, 0x29c, 0x14f, 0x2, 0x179f, 
       0x17a4, 0x5, 0x2a2, 0x152, 0x2, 0x17a0, 0x17a4, 0x5, 0x2a4, 0x153, 
       0x2, 0x17a1, 0x17a4, 0x5, 0x2a8, 0x155, 0x2, 0x17a2, 0x17a4, 0x5, 
       0x2a6, 0x154, 0x2, 0x17a3, 0x177b, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x177c, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x177d, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x177e, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x177f, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1780, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1781, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1782, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1783, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1784, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1785, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1786, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1787, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1788, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1789, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x178a, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x178b, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x178c, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x178d, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x178e, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x178f, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1790, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1791, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1792, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1793, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1794, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1795, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1796, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1797, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1798, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x1799, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x179a, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x179b, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x179c, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x179d, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x179e, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x179f, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x17a0, 
       0x3, 0x2, 0x2, 0x2, 0x17a3, 0x17a1, 0x3, 0x2, 0x2, 0x2, 0x17a3, 0x17a2, 
       0x3, 0x2, 0x2, 0x2, 0x17a4, 0x2fb, 0x3, 0x2, 0x2, 0x2, 0x17a5, 0x17a8, 
       0x5, 0x2fe, 0x180, 0x2, 0x17a6, 0x17a8, 0x5, 0x300, 0x181, 0x2, 0x17a7, 
       0x17a5, 0x3, 0x2, 0x2, 0x2, 0x17a7, 0x17a6, 0x3, 0x2, 0x2, 0x2, 0x17a8, 
       0x2fd, 0x3, 0x2, 0x2, 0x2, 0x17a9, 0x17aa, 0x7, 0x4e, 0x2, 0x2, 0x17aa, 
       0x17ab, 0x7, 0x154, 0x2, 0x2, 0x17ab, 0x17ac, 0x7, 0x29b, 0x2, 0x2, 
       0x17ac, 0x17ae, 0x5, 0x316, 0x18c, 0x2, 0x17ad, 0x17af, 0x5, 0x45a, 
       0x22e, 0x2, 0x17ae, 0x17ad, 0x3, 0x2, 0x2, 0x2, 0x17ae, 0x17af, 0x3, 
       0x2, 0x2, 0x2, 0x17af, 0x2ff, 0x3, 0x2, 0x2, 0x2, 0x17b0, 0x17b1, 
       0x7, 0x4e, 0x2, 0x2, 0x17b1, 0x17b2, 0x7, 0x210, 0x2, 0x2, 0x17b2, 
       0x17b3, 0x7, 0xd6, 0x2, 0x2, 0x17b3, 0x17b5, 0x5, 0x31e, 0x190, 0x2, 
       0x17b4, 0x17b6, 0x5, 0x45a, 0x22e, 0x2, 0x17b5, 0x17b4, 0x3, 0x2, 
       0x2, 0x2, 0x17b5, 0x17b6, 0x3, 0x2, 0x2, 0x2, 0x17b6, 0x301, 0x3, 
       0x2, 0x2, 0x2, 0x17b7, 0x17b8, 0x7, 0x270, 0x2, 0x2, 0x17b8, 0x17ba, 
       0x7, 0x24c, 0x2, 0x2, 0x17b9, 0x17bb, 0x5, 0x30e, 0x188, 0x2, 0x17ba, 
       0x17b9, 0x3, 0x2, 0x2, 0x2, 0x17ba, 0x17bb, 0x3, 0x2, 0x2, 0x2, 0x17bb, 
       0x17bd, 0x3, 0x2, 0x2, 0x2, 0x17bc, 0x17be, 0x5, 0x312, 0x18a, 0x2, 
       0x17bd, 0x17bc, 0x3, 0x2, 0x2, 0x2, 0x17bd, 0x17be, 0x3, 0x2, 0x2, 
       0x2, 0x17be, 0x17bf, 0x3, 0x2, 0x2, 0x2, 0x17bf, 0x17c1, 0x5, 0x314, 
       0x18b, 0x2, 0x17c0, 0x17c2, 0x5, 0x45a, 0x22e, 0x2, 0x17c1, 0x17c0, 
       0x3, 0x2, 0x2, 0x2, 0x17c1, 0x17c2, 0x3, 0x2, 0x2, 0x2, 0x17c2, 0x303, 
       0x3, 0x2, 0x2, 0x2, 0x17c3, 0x17c4, 0x7, 0x277, 0x2, 0x2, 0x17c4, 
       0x17c5, 0x7, 0x24c, 0x2, 0x2, 0x17c5, 0x17c9, 0x5, 0x30e, 0x188, 
       0x2, 0x17c6, 0x17c8, 0x5, 0x45a, 0x22e, 0x2, 0x17c7, 0x17c6, 0x3, 
       0x2, 0x2, 0x2, 0x17c8, 0x17cb, 0x3, 0x2, 0x2, 0x2, 0x17c9, 0x17c7, 
       0x3, 0x2, 0x2, 0x2, 0x17c9, 0x17ca, 0x3, 0x2, 0x2, 0x2, 0x17ca, 0x305, 
       0x3, 0x2, 0x2, 0x2, 0x17cb, 0x17c9, 0x3, 0x2, 0x2, 0x2, 0x17cc, 0x17cf, 
       0x5, 0x308, 0x185, 0x2, 0x17cd, 0x17cf, 0x5, 0x30a, 0x186, 0x2, 0x17ce, 
       0x17cc, 0x3, 0x2, 0x2, 0x2, 0x17ce, 0x17cd, 0x3, 0x2, 0x2, 0x2, 0x17cf, 
       0x307, 0x3, 0x2, 0x2, 0x2, 0x17d0, 0x17d1, 0x7, 0x270, 0x2, 0x2, 
       0x17d1, 0x17d2, 0x7, 0xf7, 0x2, 0x2, 0x17d2, 0x309, 0x3, 0x2, 0x2, 
       0x2, 0x17d3, 0x17d4, 0x7, 0x277, 0x2, 0x2, 0x17d4, 0x17d5, 0x7, 0xf7, 
       0x2, 0x2, 0x17d5, 0x30b, 0x3, 0x2, 0x2, 0x2, 0x17d6, 0x17d7, 0x7, 
       0x1e7, 0x2, 0x2, 0x17d7, 0x17d8, 0x9, 0x40, 0x2, 0x2, 0x17d8, 0x17dd, 
       0x7, 0x14d, 0x2, 0x2, 0x17d9, 0x17da, 0x7, 0x29b, 0x2, 0x2, 0x17da, 
       0x17de, 0x5, 0x38e, 0x1c8, 0x2, 0x17db, 0x17dc, 0x7, 0x37, 0x2, 0x2, 
       0x17dc, 0x17de, 0x5, 0x408, 0x205, 0x2, 0x17dd, 0x17d9, 0x3, 0x2, 
       0x2, 0x2, 0x17dd, 0x17db, 0x3, 0x2, 0x2, 0x2, 0x17de, 0x30d, 0x3, 
       0x2, 0x2, 0x2, 0x17df, 0x17e1, 0x5, 0x310, 0x189, 0x2, 0x17e0, 0x17df, 
       0x3, 0x2, 0x2, 0x2, 0x17e1, 0x17e2, 0x3, 0x2, 0x2, 0x2, 0x17e2, 0x17e0, 
       0x3, 0x2, 0x2, 0x2, 0x17e2, 0x17e3, 0x3, 0x2, 0x2, 0x2, 0x17e3, 0x30f, 
       0x3, 0x2, 0x2, 0x2, 0x17e4, 0x17e5, 0x9, 0x49, 0x2, 0x2, 0x17e5, 
       0x311, 0x3, 0x2, 0x2, 0x2, 0x17e6, 0x17fb, 0x7, 0x2b1, 0x2, 0x2, 
       0x17e7, 0x17e8, 0x9, 0x4a, 0x2, 0x2, 0x17e8, 0x17e9, 0x7, 0x2f4, 
       0x2, 0x2, 0x17e9, 0x17fc, 0x5, 0x33e, 0x1a0, 0x2, 0x17ea, 0x17eb, 
       0x7, 0x15c, 0x2, 0x2, 0x17eb, 0x17ec, 0x7, 0x2f4, 0x2, 0x2, 0x17ec, 
       0x17ed, 0x5, 0x32c, 0x197, 0x2, 0x17ed, 0x17ee, 0x7, 0x301, 0x2, 
       0x2, 0x17ee, 0x17ef, 0x7, 0x15d, 0x2, 0x2, 0x17ef, 0x17f0, 0x7, 0x2f4, 
       0x2, 0x2, 0x17f0, 0x17f1, 0x7, 0x313, 0x2, 0x2, 0x17f1, 0x17fc, 0x3, 
       0x2, 0x2, 0x2, 0x17f2, 0x17f3, 0x7, 0x1fd, 0x2, 0x2, 0x17f3, 0x17f4, 
       0x7, 0x2f4, 0x2, 0x2, 0x17f4, 0x17f5, 0x5, 0x32c, 0x197, 0x2, 0x17f5, 
       0x17f6, 0x7, 0x301, 0x2, 0x2, 0x17f6, 0x17f7, 0x7, 0x1fe, 0x2, 0x2, 
       0x17f7, 0x17f8, 0x7, 0x2f4, 0x2, 0x2, 0x17f8, 0x17f9, 0x7, 0x313, 
       0x2, 0x2, 0x17f9, 0x17fc, 0x3, 0x2, 0x2, 0x2, 0x17fa, 0x17fc, 0x7, 
       0x25d, 0x2, 0x2, 0x17fb, 0x17e7, 0x3, 0x2, 0x2, 0x2, 0x17fb, 0x17ea, 
       0x3, 0x2, 0x2, 0x2, 0x17fb, 0x17f2, 0x3, 0x2, 0x2, 0x2, 0x17fb, 0x17fa, 
       0x3, 0x2, 0x2, 0x2, 0x17fc, 0x313, 0x3, 0x2, 0x2, 0x2, 0x17fd, 0x17fe, 
       0x7, 0x2b6, 0x2, 0x2, 0x17fe, 0x17ff, 0x7, 0x2f4, 0x2, 0x2, 0x17ff, 
       0x1801, 0x5, 0x32c, 0x197, 0x2, 0x1800, 0x17fd, 0x3, 0x2, 0x2, 0x2, 
       0x1800, 0x1801, 0x3, 0x2, 0x2, 0x2, 0x1801, 0x1805, 0x3, 0x2, 0x2, 
       0x2, 0x1802, 0x1803, 0x7, 0x1cb, 0x2, 0x2, 0x1803, 0x1804, 0x7, 0x2f4, 
       0x2, 0x2, 0x1804, 0x1806, 0x5, 0x32c, 0x197, 0x2, 0x1805, 0x1802, 
       0x3, 0x2, 0x2, 0x2, 0x1805, 0x1806, 0x3, 0x2, 0x2, 0x2, 0x1806, 0x180a, 
       0x3, 0x2, 0x2, 0x2, 0x1807, 0x1808, 0x7, 0x93, 0x2, 0x2, 0x1808, 
       0x1809, 0x7, 0x2f4, 0x2, 0x2, 0x1809, 0x180b, 0x5, 0x32c, 0x197, 
       0x2, 0x180a, 0x1807, 0x3, 0x2, 0x2, 0x2, 0x180a, 0x180b, 0x3, 0x2, 
       0x2, 0x2, 0x180b, 0x180f, 0x3, 0x2, 0x2, 0x2, 0x180c, 0x180d, 0x7, 
       0x1d4, 0x2, 0x2, 0x180d, 0x180e, 0x7, 0x2f4, 0x2, 0x2, 0x180e, 0x1810, 
       0x5, 0x32c, 0x197, 0x2, 0x180f, 0x180c, 0x3, 0x2, 0x2, 0x2, 0x180f, 
       0x1810, 0x3, 0x2, 0x2, 0x2, 0x1810, 0x315, 0x3, 0x2, 0x2, 0x2, 0x1811, 
       0x1816, 0x5, 0x318, 0x18d, 0x2, 0x1812, 0x1813, 0x7, 0x301, 0x2, 
       0x2, 0x1813, 0x1815, 0x5, 0x318, 0x18d, 0x2, 0x1814, 0x1812, 0x3, 
       0x2, 0x2, 0x2, 0x1815, 0x1818, 0x3, 0x2, 0x2, 0x2, 0x1816, 0x1814, 
       0x3, 0x2, 0x2, 0x2, 0x1816, 0x1817, 0x3, 0x2, 0x2, 0x2, 0x1817, 0x317, 
       0x3, 0x2, 0x2, 0x2, 0x1818, 0x1816, 0x3, 0x2, 0x2, 0x2, 0x1819, 0x181a, 
       0x7, 0x156, 0x2, 0x2, 0x181a, 0x181b, 0x7, 0x2f4, 0x2, 0x2, 0x181b, 
       0x187d, 0x5, 0x32c, 0x197, 0x2, 0x181c, 0x181d, 0x7, 0x15b, 0x2, 
       0x2, 0x181d, 0x181e, 0x7, 0x2f4, 0x2, 0x2, 0x181e, 0x187d, 0x5, 0x32c, 
       0x197, 0x2, 0x181f, 0x1820, 0x7, 0x16e, 0x2, 0x2, 0x1820, 0x1821, 
       0x7, 0x2f4, 0x2, 0x2, 0x1821, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x1822, 
       0x1823, 0x7, 0x15e, 0x2, 0x2, 0x1823, 0x1824, 0x7, 0x2f4, 0x2, 0x2, 
       0x1824, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x1825, 0x1826, 0x7, 0x15f, 
       0x2, 0x2, 0x1826, 0x1827, 0x7, 0x2f4, 0x2, 0x2, 0x1827, 0x187d, 0x7, 
       0x313, 0x2, 0x2, 0x1828, 0x1829, 0x7, 0x1e0, 0x2, 0x2, 0x1829, 0x182a, 
       0x7, 0x2f4, 0x2, 0x2, 0x182a, 0x187d, 0x9, 0x4b, 0x2, 0x2, 0x182b, 
       0x182c, 0x7, 0x212, 0x2, 0x2, 0x182c, 0x182d, 0x7, 0x2f4, 0x2, 0x2, 
       0x182d, 0x187d, 0x7, 0x313, 0x2, 0x2, 0x182e, 0x182f, 0x7, 0x158, 
       0x2, 0x2, 0x182f, 0x1830, 0x7, 0x2f4, 0x2, 0x2, 0x1830, 0x187d, 0x7, 
       0x313, 0x2, 0x2, 0x1831, 0x1832, 0x7, 0x161, 0x2, 0x2, 0x1832, 0x1833, 
       0x7, 0x2f4, 0x2, 0x2, 0x1833, 0x187d, 0x7, 0x313, 0x2, 0x2, 0x1834, 
       0x1835, 0x7, 0x159, 0x2, 0x2, 0x1835, 0x1836, 0x7, 0x2f4, 0x2, 0x2, 
       0x1836, 0x187d, 0x7, 0x313, 0x2, 0x2, 0x1837, 0x1838, 0x7, 0x15a, 
       0x2, 0x2, 0x1838, 0x1839, 0x7, 0x2f4, 0x2, 0x2, 0x1839, 0x187d, 0x7, 
       0x313, 0x2, 0x2, 0x183a, 0x183b, 0x7, 0x15c, 0x2, 0x2, 0x183b, 0x183c, 
       0x7, 0x2f4, 0x2, 0x2, 0x183c, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x183d, 
       0x183e, 0x7, 0x15d, 0x2, 0x2, 0x183e, 0x183f, 0x7, 0x2f4, 0x2, 0x2, 
       0x183f, 0x187d, 0x7, 0x313, 0x2, 0x2, 0x1840, 0x1841, 0x7, 0x155, 
       0x2, 0x2, 0x1841, 0x1842, 0x7, 0x2f4, 0x2, 0x2, 0x1842, 0x187d, 0x7, 
       0x313, 0x2, 0x2, 0x1843, 0x1844, 0x7, 0x1fd, 0x2, 0x2, 0x1844, 0x1845, 
       0x7, 0x2f4, 0x2, 0x2, 0x1845, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x1846, 
       0x1847, 0x7, 0x1fe, 0x2, 0x2, 0x1847, 0x1848, 0x7, 0x2f4, 0x2, 0x2, 
       0x1848, 0x187d, 0x7, 0x313, 0x2, 0x2, 0x1849, 0x184a, 0x7, 0x157, 
       0x2, 0x2, 0x184a, 0x184b, 0x7, 0x2f4, 0x2, 0x2, 0x184b, 0x187d, 0x5, 
       0x32c, 0x197, 0x2, 0x184c, 0x184d, 0x7, 0x16f, 0x2, 0x2, 0x184d, 
       0x184e, 0x7, 0x2f4, 0x2, 0x2, 0x184e, 0x187d, 0x7, 0x313, 0x2, 0x2, 
       0x184f, 0x1850, 0x7, 0x163, 0x2, 0x2, 0x1850, 0x1851, 0x7, 0x2f4, 
       0x2, 0x2, 0x1851, 0x187d, 0x7, 0x313, 0x2, 0x2, 0x1852, 0x1853, 0x7, 
       0x164, 0x2, 0x2, 0x1853, 0x1854, 0x7, 0x2f4, 0x2, 0x2, 0x1854, 0x187d, 
       0x5, 0x32c, 0x197, 0x2, 0x1855, 0x1856, 0x7, 0x165, 0x2, 0x2, 0x1856, 
       0x1857, 0x7, 0x2f4, 0x2, 0x2, 0x1857, 0x187d, 0x5, 0x32c, 0x197, 
       0x2, 0x1858, 0x1859, 0x7, 0x166, 0x2, 0x2, 0x1859, 0x185a, 0x7, 0x2f4, 
       0x2, 0x2, 0x185a, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x185b, 0x185c, 
       0x7, 0x168, 0x2, 0x2, 0x185c, 0x185d, 0x7, 0x2f4, 0x2, 0x2, 0x185d, 
       0x187d, 0x5, 0x32c, 0x197, 0x2, 0x185e, 0x185f, 0x7, 0x169, 0x2, 
       0x2, 0x185f, 0x1860, 0x7, 0x2f4, 0x2, 0x2, 0x1860, 0x187d, 0x5, 0x32c, 
       0x197, 0x2, 0x1861, 0x1862, 0x7, 0x16a, 0x2, 0x2, 0x1862, 0x1863, 
       0x7, 0x2f4, 0x2, 0x2, 0x1863, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x1864, 
       0x1865, 0x7, 0x167, 0x2, 0x2, 0x1865, 0x1866, 0x7, 0x2f4, 0x2, 0x2, 
       0x1866, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x1867, 0x1868, 0x7, 0x16b, 
       0x2, 0x2, 0x1868, 0x1869, 0x7, 0x2f4, 0x2, 0x2, 0x1869, 0x187d, 0x7, 
       0x313, 0x2, 0x2, 0x186a, 0x186b, 0x7, 0x16d, 0x2, 0x2, 0x186b, 0x186c, 
       0x7, 0x2f4, 0x2, 0x2, 0x186c, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x186d, 
       0x186e, 0x7, 0x16c, 0x2, 0x2, 0x186e, 0x186f, 0x7, 0x2f4, 0x2, 0x2, 
       0x186f, 0x187d, 0x5, 0x32c, 0x197, 0x2, 0x1870, 0x1871, 0x7, 0x160, 
       0x2, 0x2, 0x1871, 0x1872, 0x7, 0x2f4, 0x2, 0x2, 0x1872, 0x187d, 0x5, 
       0x32c, 0x197, 0x2, 0x1873, 0x1874, 0x7, 0xf0, 0x2, 0x2, 0x1874, 0x1875, 
       0x7, 0x2f4, 0x2, 0x2, 0x1875, 0x187d, 0x7, 0x313, 0x2, 0x2, 0x1876, 
       0x1877, 0x7, 0x108, 0x2, 0x2, 0x1877, 0x1878, 0x7, 0x2f4, 0x2, 0x2, 
       0x1878, 0x1879, 0x7, 0x2fb, 0x2, 0x2, 0x1879, 0x187a, 0x5, 0x31a, 
       0x18e, 0x2, 0x187a, 0x187b, 0x7, 0x2fc, 0x2, 0x2, 0x187b, 0x187d, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1819, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x181c, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x181f, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1822, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1825, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1828, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x182b, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x182e, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1831, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1834, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1837, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x183a, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x183d, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1840, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1843, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1846, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1849, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x184c, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x184f, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1852, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1855, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1858, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x185b, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x185e, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1861, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1864, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1867, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x186a, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x186d, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1870, 
       0x3, 0x2, 0x2, 0x2, 0x187c, 0x1873, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x1876, 
       0x3, 0x2, 0x2, 0x2, 0x187d, 0x319, 0x3, 0x2, 0x2, 0x2, 0x187e, 0x187f, 
       0x5, 0x31c, 0x18f, 0x2, 0x187f, 0x1880, 0x7, 0x301, 0x2, 0x2, 0x1880, 
       0x1881, 0x5, 0x31c, 0x18f, 0x2, 0x1881, 0x31b, 0x3, 0x2, 0x2, 0x2, 
       0x1882, 0x1883, 0x7, 0x313, 0x2, 0x2, 0x1883, 0x31d, 0x3, 0x2, 0x2, 
       0x2, 0x1884, 0x1889, 0x5, 0x320, 0x191, 0x2, 0x1885, 0x1886, 0x7, 
       0x301, 0x2, 0x2, 0x1886, 0x1888, 0x5, 0x320, 0x191, 0x2, 0x1887, 
       0x1885, 0x3, 0x2, 0x2, 0x2, 0x1888, 0x188b, 0x3, 0x2, 0x2, 0x2, 0x1889, 
       0x1887, 0x3, 0x2, 0x2, 0x2, 0x1889, 0x188a, 0x3, 0x2, 0x2, 0x2, 0x188a, 
       0x31f, 0x3, 0x2, 0x2, 0x2, 0x188b, 0x1889, 0x3, 0x2, 0x2, 0x2, 0x188c, 
       0x188d, 0x7, 0x209, 0x2, 0x2, 0x188d, 0x188e, 0x7, 0x2f4, 0x2, 0x2, 
       0x188e, 0x1890, 0x7, 0x2fb, 0x2, 0x2, 0x188f, 0x1891, 0x5, 0x352, 
       0x1aa, 0x2, 0x1890, 0x188f, 0x3, 0x2, 0x2, 0x2, 0x1890, 0x1891, 0x3, 
       0x2, 0x2, 0x2, 0x1891, 0x1892, 0x3, 0x2, 0x2, 0x2, 0x1892, 0x18be, 
       0x7, 0x2fc, 0x2, 0x2, 0x1893, 0x1894, 0x7, 0x20b, 0x2, 0x2, 0x1894, 
       0x1895, 0x7, 0x2f4, 0x2, 0x2, 0x1895, 0x1897, 0x7, 0x2fb, 0x2, 0x2, 
       0x1896, 0x1898, 0x5, 0x352, 0x1aa, 0x2, 0x1897, 0x1896, 0x3, 0x2, 
       0x2, 0x2, 0x1897, 0x1898, 0x3, 0x2, 0x2, 0x2, 0x1898, 0x1899, 0x3, 
       0x2, 0x2, 0x2, 0x1899, 0x18be, 0x7, 0x2fc, 0x2, 0x2, 0x189a, 0x189b, 
       0x7, 0x20a, 0x2, 0x2, 0x189b, 0x189c, 0x7, 0x2f4, 0x2, 0x2, 0x189c, 
       0x189e, 0x7, 0x2fb, 0x2, 0x2, 0x189d, 0x189f, 0x5, 0x374, 0x1bb, 
       0x2, 0x189e, 0x189d, 0x3, 0x2, 0x2, 0x2, 0x189e, 0x189f, 0x3, 0x2, 
       0x2, 0x2, 0x189f, 0x18a0, 0x3, 0x2, 0x2, 0x2, 0x18a0, 0x18be, 0x7, 
       0x2fc, 0x2, 0x2, 0x18a1, 0x18a2, 0x7, 0x20c, 0x2, 0x2, 0x18a2, 0x18a3, 
       0x7, 0x2f4, 0x2, 0x2, 0x18a3, 0x18a5, 0x7, 0x2fb, 0x2, 0x2, 0x18a4, 
       0x18a6, 0x5, 0x374, 0x1bb, 0x2, 0x18a5, 0x18a4, 0x3, 0x2, 0x2, 0x2, 
       0x18a5, 0x18a6, 0x3, 0x2, 0x2, 0x2, 0x18a6, 0x18a7, 0x3, 0x2, 0x2, 
       0x2, 0x18a7, 0x18be, 0x7, 0x2fc, 0x2, 0x2, 0x18a8, 0x18a9, 0x7, 0x20e, 
       0x2, 0x2, 0x18a9, 0x18aa, 0x7, 0x2f4, 0x2, 0x2, 0x18aa, 0x18ac, 0x7, 
       0x2fb, 0x2, 0x2, 0x18ab, 0x18ad, 0x5, 0x322, 0x192, 0x2, 0x18ac, 
       0x18ab, 0x3, 0x2, 0x2, 0x2, 0x18ac, 0x18ad, 0x3, 0x2, 0x2, 0x2, 0x18ad, 
       0x18ae, 0x3, 0x2, 0x2, 0x2, 0x18ae, 0x18be, 0x7, 0x2fc, 0x2, 0x2, 
       0x18af, 0x18b0, 0x7, 0x20f, 0x2, 0x2, 0x18b0, 0x18b1, 0x7, 0x2f4, 
       0x2, 0x2, 0x18b1, 0x18b3, 0x7, 0x2fb, 0x2, 0x2, 0x18b2, 0x18b4, 0x5, 
       0x322, 0x192, 0x2, 0x18b3, 0x18b2, 0x3, 0x2, 0x2, 0x2, 0x18b3, 0x18b4, 
       0x3, 0x2, 0x2, 0x2, 0x18b4, 0x18b5, 0x3, 0x2, 0x2, 0x2, 0x18b5, 0x18be, 
       0x7, 0x2fc, 0x2, 0x2, 0x18b6, 0x18b7, 0x7, 0x20d, 0x2, 0x2, 0x18b7, 
       0x18b8, 0x7, 0x2f4, 0x2, 0x2, 0x18b8, 0x18ba, 0x7, 0x2fb, 0x2, 0x2, 
       0x18b9, 0x18bb, 0x5, 0x356, 0x1ac, 0x2, 0x18ba, 0x18b9, 0x3, 0x2, 
       0x2, 0x2, 0x18ba, 0x18bb, 0x3, 0x2, 0x2, 0x2, 0x18bb, 0x18bc, 0x3, 
       0x2, 0x2, 0x2, 0x18bc, 0x18be, 0x7, 0x2fc, 0x2, 0x2, 0x18bd, 0x188c, 
       0x3, 0x2, 0x2, 0x2, 0x18bd, 0x1893, 0x3, 0x2, 0x2, 0x2, 0x18bd, 0x189a, 
       0x3, 0x2, 0x2, 0x2, 0x18bd, 0x18a1, 0x3, 0x2, 0x2, 0x2, 0x18bd, 0x18a8, 
       0x3, 0x2, 0x2, 0x2, 0x18bd, 0x18af, 0x3, 0x2, 0x2, 0x2, 0x18bd, 0x18b6, 
       0x3, 0x2, 0x2, 0x2, 0x18be, 0x321, 0x3, 0x2, 0x2, 0x2, 0x18bf, 0x18c4, 
       0x5, 0x324, 0x193, 0x2, 0x18c0, 0x18c1, 0x7, 0x301, 0x2, 0x2, 0x18c1, 
       0x18c3, 0x5, 0x324, 0x193, 0x2, 0x18c2, 0x18c0, 0x3, 0x2, 0x2, 0x2, 
       0x18c3, 0x18c6, 0x3, 0x2, 0x2, 0x2, 0x18c4, 0x18c2, 0x3, 0x2, 0x2, 
       0x2, 0x18c4, 0x18c5, 0x3, 0x2, 0x2, 0x2, 0x18c5, 0x323, 0x3, 0x2, 
       0x2, 0x2, 0x18c6, 0x18c4, 0x3, 0x2, 0x2, 0x2, 0x18c7, 0x18c8, 0x5, 
       0x32c, 0x197, 0x2, 0x18c8, 0x325, 0x3, 0x2, 0x2, 0x2, 0x18c9, 0x18ca, 
       0x7, 0x305, 0x2, 0x2, 0x18ca, 0x327, 0x3, 0x2, 0x2, 0x2, 0x18cb, 
       0x18cc, 0x9, 0x4c, 0x2, 0x2, 0x18cc, 0x329, 0x3, 0x2, 0x2, 0x2, 0x18cd, 
       0x18d5, 0x5, 0x32e, 0x198, 0x2, 0x18ce, 0x18d5, 0x5, 0x330, 0x199, 
       0x2, 0x18cf, 0x18d5, 0x5, 0x332, 0x19a, 0x2, 0x18d0, 0x18d5, 0x5, 
       0x334, 0x19b, 0x2, 0x18d1, 0x18d5, 0x5, 0x336, 0x19c, 0x2, 0x18d2, 
       0x18d5, 0x5, 0x338, 0x19d, 0x2, 0x18d3, 0x18d5, 0x5, 0x33a, 0x19e, 
       0x2, 0x18d4, 0x18cd, 0x3, 0x2, 0x2, 0x2, 0x18d4, 0x18ce, 0x3, 0x2, 
       0x2, 0x2, 0x18d4, 0x18cf, 0x3, 0x2, 0x2, 0x2, 0x18d4, 0x18d0, 0x3, 
       0x2, 0x2, 0x2, 0x18d4, 0x18d1, 0x3, 0x2, 0x2, 0x2, 0x18d4, 0x18d2, 
       0x3, 0x2, 0x2, 0x2, 0x18d4, 0x18d3, 0x3, 0x2, 0x2, 0x2, 0x18d5, 0x32b, 
       0x3, 0x2, 0x2, 0x2, 0x18d6, 0x18d7, 0x9, 0x4d, 0x2, 0x2, 0x18d7, 
       0x32d, 0x3, 0x2, 0x2, 0x2, 0x18d8, 0x18da, 0x7, 0x312, 0x2, 0x2, 
       0x18d9, 0x18d8, 0x3, 0x2, 0x2, 0x2, 0x18d9, 0x18da, 0x3, 0x2, 0x2, 
       0x2, 0x18da, 0x18db, 0x3, 0x2, 0x2, 0x2, 0x18db, 0x18de, 0x5, 0x32c, 
       0x197, 0x2, 0x18dc, 0x18de, 0x7, 0x311, 0x2, 0x2, 0x18dd, 0x18d9, 
       0x3, 0x2, 0x2, 0x2, 0x18dd, 0x18dc, 0x3, 0x2, 0x2, 0x2, 0x18de, 0x32f, 
       0x3, 0x2, 0x2, 0x2, 0x18df, 0x18e0, 0x7, 0x313, 0x2, 0x2, 0x18e0, 
       0x331, 0x3, 0x2, 0x2, 0x2, 0x18e1, 0x18e2, 0x9, 0x4e, 0x2, 0x2, 0x18e2, 
       0x18e3, 0x7, 0x30f, 0x2, 0x2, 0x18e3, 0x333, 0x3, 0x2, 0x2, 0x2, 
       0x18e4, 0x18e6, 0x7, 0x312, 0x2, 0x2, 0x18e5, 0x18e4, 0x3, 0x2, 0x2, 
       0x2, 0x18e5, 0x18e6, 0x3, 0x2, 0x2, 0x2, 0x18e6, 0x18e7, 0x3, 0x2, 
       0x2, 0x2, 0x18e7, 0x18e9, 0x7, 0x317, 0x2, 0x2, 0x18e8, 0x18ea, 0x5, 
       0x446, 0x224, 0x2, 0x18e9, 0x18e8, 0x3, 0x2, 0x2, 0x2, 0x18e9, 0x18ea, 
       0x3, 0x2, 0x2, 0x2, 0x18ea, 0x335, 0x3, 0x2, 0x2, 0x2, 0x18eb, 0x18ed, 
       0x7, 0x312, 0x2, 0x2, 0x18ec, 0x18eb, 0x3, 0x2, 0x2, 0x2, 0x18ec, 
       0x18ed, 0x3, 0x2, 0x2, 0x2, 0x18ed, 0x18ee, 0x3, 0x2, 0x2, 0x2, 0x18ee, 
       0x18f0, 0x7, 0x318, 0x2, 0x2, 0x18ef, 0x18f1, 0x5, 0x446, 0x224, 
       0x2, 0x18f0, 0x18ef, 0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18f1, 0x3, 0x2, 
       0x2, 0x2, 0x18f1, 0x337, 0x3, 0x2, 0x2, 0x2, 0x18f2, 0x18f3, 0x9, 
       0x4f, 0x2, 0x2, 0x18f3, 0x339, 0x3, 0x2, 0x2, 0x2, 0x18f4, 0x18f5, 
       0x7, 0x1a6, 0x2, 0x2, 0x18f5, 0x33b, 0x3, 0x2, 0x2, 0x2, 0x18f6, 
       0x18f9, 0x5, 0x342, 0x1a2, 0x2, 0x18f7, 0x18f9, 0x7, 0x3b, 0x2, 0x2, 
       0x18f8, 0x18f6, 0x3, 0x2, 0x2, 0x2, 0x18f8, 0x18f7, 0x3, 0x2, 0x2, 
       0x2, 0x18f9, 0x33d, 0x3, 0x2, 0x2, 0x2, 0x18fa, 0x18ff, 0x7, 0x30e, 
       0x2, 0x2, 0x18fb, 0x18ff, 0x5, 0x340, 0x1a1, 0x2, 0x18fc, 0x18ff, 
       0x5, 0x328, 0x195, 0x2, 0x18fd, 0x18ff, 0x7, 0x310, 0x2, 0x2, 0x18fe, 
       0x18fa, 0x3, 0x2, 0x2, 0x2, 0x18fe, 0x18fb, 0x3, 0x2, 0x2, 0x2, 0x18fe, 
       0x18fc, 0x3, 0x2, 0x2, 0x2, 0x18fe, 0x18fd, 0x3, 0x2, 0x2, 0x2, 0x18ff, 
       0x33f, 0x3, 0x2, 0x2, 0x2, 0x1900, 0x1901, 0x9, 0x50, 0x2, 0x2, 0x1901, 
       0x341, 0x3, 0x2, 0x2, 0x2, 0x1902, 0x1905, 0x5, 0x33e, 0x1a0, 0x2, 
       0x1903, 0x1905, 0x5, 0x32c, 0x197, 0x2, 0x1904, 0x1902, 0x3, 0x2, 
       0x2, 0x2, 0x1904, 0x1903, 0x3, 0x2, 0x2, 0x2, 0x1905, 0x343, 0x3, 
       0x2, 0x2, 0x2, 0x1906, 0x1908, 0x7, 0x306, 0x2, 0x2, 0x1907, 0x1906, 
       0x3, 0x2, 0x2, 0x2, 0x1907, 0x1908, 0x3, 0x2, 0x2, 0x2, 0x1908, 0x1909, 
       0x3, 0x2, 0x2, 0x2, 0x1909, 0x190b, 0x7, 0x306, 0x2, 0x2, 0x190a, 
       0x1907, 0x3, 0x2, 0x2, 0x2, 0x190a, 0x190b, 0x3, 0x2, 0x2, 0x2, 0x190b, 
       0x190d, 0x3, 0x2, 0x2, 0x2, 0x190c, 0x190e, 0x5, 0x34a, 0x1a6, 0x2, 
       0x190d, 0x190c, 0x3, 0x2, 0x2, 0x2, 0x190d, 0x190e, 0x3, 0x2, 0x2, 
       0x2, 0x190e, 0x1910, 0x3, 0x2, 0x2, 0x2, 0x190f, 0x1911, 0x7, 0x2f0, 
       0x2, 0x2, 0x1910, 0x190f, 0x3, 0x2, 0x2, 0x2, 0x1910, 0x1911, 0x3, 
       0x2, 0x2, 0x2, 0x1911, 0x1912, 0x3, 0x2, 0x2, 0x2, 0x1912, 0x1913, 
       0x5, 0x34c, 0x1a7, 0x2, 0x1913, 0x345, 0x3, 0x2, 0x2, 0x2, 0x1914, 
       0x1915, 0x7, 0x306, 0x2, 0x2, 0x1915, 0x1916, 0x5, 0x342, 0x1a2, 
       0x2, 0x1916, 0x347, 0x3, 0x2, 0x2, 0x2, 0x1917, 0x1918, 0x7, 0x306, 
       0x2, 0x2, 0x1918, 0x191a, 0x7, 0x306, 0x2, 0x2, 0x1919, 0x191b, 0x5, 
       0x34a, 0x1a6, 0x2, 0x191a, 0x1919, 0x3, 0x2, 0x2, 0x2, 0x191a, 0x191b, 
       0x3, 0x2, 0x2, 0x2, 0x191b, 0x191c, 0x3, 0x2, 0x2, 0x2, 0x191c, 0x191f, 
       0x5, 0x342, 0x1a2, 0x2, 0x191d, 0x191e, 0x7, 0x2f0, 0x2, 0x2, 0x191e, 
       0x1920, 0x5, 0x33e, 0x1a0, 0x2, 0x191f, 0x191d, 0x3, 0x2, 0x2, 0x2, 
       0x191f, 0x1920, 0x3, 0x2, 0x2, 0x2, 0x1920, 0x349, 0x3, 0x2, 0x2, 
       0x2, 0x1921, 0x1922, 0x9, 0x51, 0x2, 0x2, 0x1922, 0x34b, 0x3, 0x2, 
       0x2, 0x2, 0x1923, 0x192c, 0x5, 0x33e, 0x1a0, 0x2, 0x1924, 0x1925, 
       0x7, 0x92, 0x2, 0x2, 0x1925, 0x1926, 0x7, 0x2f0, 0x2, 0x2, 0x1926, 
       0x192c, 0x5, 0x33e, 0x1a0, 0x2, 0x1927, 0x1928, 0x5, 0x33e, 0x1a0, 
       0x2, 0x1928, 0x1929, 0x7, 0x2f0, 0x2, 0x2, 0x1929, 0x192a, 0x5, 0x33e, 
       0x1a0, 0x2, 0x192a, 0x192c, 0x3, 0x2, 0x2, 0x2, 0x192b, 0x1923, 0x3, 
       0x2, 0x2, 0x2, 0x192b, 0x1924, 0x3, 0x2, 0x2, 0x2, 0x192b, 0x1927, 
       0x3, 0x2, 0x2, 0x2, 0x192c, 0x34d, 0x3, 0x2, 0x2, 0x2, 0x192d, 0x1935, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x192e, 0x1935, 0x7, 0x92, 0x2, 0x2, 0x192f, 
       0x1935, 0x7, 0x25, 0x2, 0x2, 0x1930, 0x1935, 0x7, 0x1b0, 0x2, 0x2, 
       0x1931, 0x1935, 0x7, 0x3b, 0x2, 0x2, 0x1932, 0x1935, 0x7, 0x22a, 
       0x2, 0x2, 0x1933, 0x1935, 0x7, 0x285, 0x2, 0x2, 0x1934, 0x192d, 0x3, 
       0x2, 0x2, 0x2, 0x1934, 0x192e, 0x3, 0x2, 0x2, 0x2, 0x1934, 0x192f, 
       0x3, 0x2, 0x2, 0x2, 0x1934, 0x1930, 0x3, 0x2, 0x2, 0x2, 0x1934, 0x1931, 
       0x3, 0x2, 0x2, 0x2, 0x1934, 0x1932, 0x3, 0x2, 0x2, 0x2, 0x1934, 0x1933, 
       0x3, 0x2, 0x2, 0x2, 0x1935, 0x34f, 0x3, 0x2, 0x2, 0x2, 0x1936, 0x1937, 
       0x5, 0x33e, 0x1a0, 0x2, 0x1937, 0x351, 0x3, 0x2, 0x2, 0x2, 0x1938, 
       0x193d, 0x5, 0x350, 0x1a9, 0x2, 0x1939, 0x193a, 0x7, 0x301, 0x2, 
       0x2, 0x193a, 0x193c, 0x5, 0x350, 0x1a9, 0x2, 0x193b, 0x1939, 0x3, 
       0x2, 0x2, 0x2, 0x193c, 0x193f, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x193b, 
       0x3, 0x2, 0x2, 0x2, 0x193d, 0x193e, 0x3, 0x2, 0x2, 0x2, 0x193e, 0x353, 
       0x3, 0x2, 0x2, 0x2, 0x193f, 0x193d, 0x3, 0x2, 0x2, 0x2, 0x1940, 0x1943, 
       0x5, 0x342, 0x1a2, 0x2, 0x1941, 0x1943, 0x7, 0x3b, 0x2, 0x2, 0x1942, 
       0x1940, 0x3, 0x2, 0x2, 0x2, 0x1942, 0x1941, 0x3, 0x2, 0x2, 0x2, 0x1943, 
       0x355, 0x3, 0x2, 0x2, 0x2, 0x1944, 0x1949, 0x5, 0x358, 0x1ad, 0x2, 
       0x1945, 0x1946, 0x7, 0x301, 0x2, 0x2, 0x1946, 0x1948, 0x5, 0x358, 
       0x1ad, 0x2, 0x1947, 0x1945, 0x3, 0x2, 0x2, 0x2, 0x1948, 0x194b, 0x3, 
       0x2, 0x2, 0x2, 0x1949, 0x1947, 0x3, 0x2, 0x2, 0x2, 0x1949, 0x194a, 
       0x3, 0x2, 0x2, 0x2, 0x194a, 0x357, 0x3, 0x2, 0x2, 0x2, 0x194b, 0x1949, 
       0x3, 0x2, 0x2, 0x2, 0x194c, 0x194d, 0x7, 0x2fb, 0x2, 0x2, 0x194d, 
       0x194e, 0x5, 0x350, 0x1a9, 0x2, 0x194e, 0x194f, 0x7, 0x301, 0x2, 
       0x2, 0x194f, 0x1950, 0x5, 0x350, 0x1a9, 0x2, 0x1950, 0x1951, 0x7, 
       0x2fc, 0x2, 0x2, 0x1951, 0x359, 0x3, 0x2, 0x2, 0x2, 0x1952, 0x1953, 
       0x5, 0x36e, 0x1b8, 0x2, 0x1953, 0x1954, 0x7, 0x2f0, 0x2, 0x2, 0x1954, 
       0x1956, 0x3, 0x2, 0x2, 0x2, 0x1955, 0x1952, 0x3, 0x2, 0x2, 0x2, 0x1955, 
       0x1956, 0x3, 0x2, 0x2, 0x2, 0x1956, 0x1957, 0x3, 0x2, 0x2, 0x2, 0x1957, 
       0x1958, 0x5, 0x372, 0x1ba, 0x2, 0x1958, 0x35b, 0x3, 0x2, 0x2, 0x2, 
       0x1959, 0x195a, 0x5, 0x33e, 0x1a0, 0x2, 0x195a, 0x35d, 0x3, 0x2, 
       0x2, 0x2, 0x195b, 0x195c, 0x5, 0x33e, 0x1a0, 0x2, 0x195c, 0x35f, 
       0x3, 0x2, 0x2, 0x2, 0x195d, 0x1960, 0x5, 0x342, 0x1a2, 0x2, 0x195e, 
       0x195f, 0x7, 0x306, 0x2, 0x2, 0x195f, 0x1961, 0x5, 0x342, 0x1a2, 
       0x2, 0x1960, 0x195e, 0x3, 0x2, 0x2, 0x2, 0x1960, 0x1961, 0x3, 0x2, 
       0x2, 0x2, 0x1961, 0x361, 0x3, 0x2, 0x2, 0x2, 0x1962, 0x1969, 0x5, 
       0x360, 0x1b1, 0x2, 0x1963, 0x1966, 0x7, 0x80, 0x2, 0x2, 0x1964, 0x1965, 
       0x7, 0x2fb, 0x2, 0x2, 0x1965, 0x1967, 0x7, 0x2fc, 0x2, 0x2, 0x1966, 
       0x1964, 0x3, 0x2, 0x2, 0x2, 0x1966, 0x1967, 0x3, 0x2, 0x2, 0x2, 0x1967, 
       0x1969, 0x3, 0x2, 0x2, 0x2, 0x1968, 0x1962, 0x3, 0x2, 0x2, 0x2, 0x1968, 
       0x1963, 0x3, 0x2, 0x2, 0x2, 0x1969, 0x363, 0x3, 0x2, 0x2, 0x2, 0x196a, 
       0x196d, 0x5, 0x33e, 0x1a0, 0x2, 0x196b, 0x196c, 0x7, 0x2f0, 0x2, 
       0x2, 0x196c, 0x196e, 0x5, 0x33e, 0x1a0, 0x2, 0x196d, 0x196b, 0x3, 
       0x2, 0x2, 0x2, 0x196d, 0x196e, 0x3, 0x2, 0x2, 0x2, 0x196e, 0x365, 
       0x3, 0x2, 0x2, 0x2, 0x196f, 0x1970, 0x5, 0x342, 0x1a2, 0x2, 0x1970, 
       0x367, 0x3, 0x2, 0x2, 0x2, 0x1971, 0x1972, 0x5, 0x342, 0x1a2, 0x2, 
       0x1972, 0x369, 0x3, 0x2, 0x2, 0x2, 0x1973, 0x197b, 0x5, 0x33e, 0x1a0, 
       0x2, 0x1974, 0x1975, 0x5, 0x36e, 0x1b8, 0x2, 0x1975, 0x1976, 0x7, 
       0x2f0, 0x2, 0x2, 0x1976, 0x1978, 0x3, 0x2, 0x2, 0x2, 0x1977, 0x1974, 
       0x3, 0x2, 0x2, 0x2, 0x1977, 0x1978, 0x3, 0x2, 0x2, 0x2, 0x1978, 0x1979, 
       0x3, 0x2, 0x2, 0x2, 0x1979, 0x197b, 0x5, 0x33e, 0x1a0, 0x2, 0x197a, 
       0x1973, 0x3, 0x2, 0x2, 0x2, 0x197a, 0x1977, 0x3, 0x2, 0x2, 0x2, 0x197b, 
       0x36b, 0x3, 0x2, 0x2, 0x2, 0x197c, 0x1984, 0x5, 0x33e, 0x1a0, 0x2, 
       0x197d, 0x197e, 0x5, 0x36e, 0x1b8, 0x2, 0x197e, 0x197f, 0x7, 0x2f0, 
       0x2, 0x2, 0x197f, 0x1981, 0x3, 0x2, 0x2, 0x2, 0x1980, 0x197d, 0x3, 
       0x2, 0x2, 0x2, 0x1980, 0x1981, 0x3, 0x2, 0x2, 0x2, 0x1981, 0x1982, 
       0x3, 0x2, 0x2, 0x2, 0x1982, 0x1984, 0x5, 0x33e, 0x1a0, 0x2, 0x1983, 
       0x197c, 0x3, 0x2, 0x2, 0x2, 0x1983, 0x1980, 0x3, 0x2, 0x2, 0x2, 0x1984, 
       0x36d, 0x3, 0x2, 0x2, 0x2, 0x1985, 0x1986, 0x5, 0x33e, 0x1a0, 0x2, 
       0x1986, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x1987, 0x1988, 0x5, 0x342, 0x1a2, 
       0x2, 0x1988, 0x371, 0x3, 0x2, 0x2, 0x2, 0x1989, 0x198a, 0x5, 0x33e, 
       0x1a0, 0x2, 0x198a, 0x373, 0x3, 0x2, 0x2, 0x2, 0x198b, 0x1990, 0x5, 
       0x35a, 0x1ae, 0x2, 0x198c, 0x198d, 0x7, 0x301, 0x2, 0x2, 0x198d, 
       0x198f, 0x5, 0x35a, 0x1ae, 0x2, 0x198e, 0x198c, 0x3, 0x2, 0x2, 0x2, 
       0x198f, 0x1992, 0x3, 0x2, 0x2, 0x2, 0x1990, 0x198e, 0x3, 0x2, 0x2, 
       0x2, 0x1990, 0x1991, 0x3, 0x2, 0x2, 0x2, 0x1991, 0x375, 0x3, 0x2, 
       0x2, 0x2, 0x1992, 0x1990, 0x3, 0x2, 0x2, 0x2, 0x1993, 0x1998, 0x5, 
       0x36c, 0x1b7, 0x2, 0x1994, 0x1995, 0x7, 0x301, 0x2, 0x2, 0x1995, 
       0x1997, 0x5, 0x36c, 0x1b7, 0x2, 0x1996, 0x1994, 0x3, 0x2, 0x2, 0x2, 
       0x1997, 0x199a, 0x3, 0x2, 0x2, 0x2, 0x1998, 0x1996, 0x3, 0x2, 0x2, 
       0x2, 0x1998, 0x1999, 0x3, 0x2, 0x2, 0x2, 0x1999, 0x377, 0x3, 0x2, 
       0x2, 0x2, 0x199a, 0x1998, 0x3, 0x2, 0x2, 0x2, 0x199b, 0x19a0, 0x5, 
       0x35c, 0x1af, 0x2, 0x199c, 0x199d, 0x7, 0x301, 0x2, 0x2, 0x199d, 
       0x199f, 0x5, 0x35c, 0x1af, 0x2, 0x199e, 0x199c, 0x3, 0x2, 0x2, 0x2, 
       0x199f, 0x19a2, 0x3, 0x2, 0x2, 0x2, 0x19a0, 0x199e, 0x3, 0x2, 0x2, 
       0x2, 0x19a0, 0x19a1, 0x3, 0x2, 0x2, 0x2, 0x19a1, 0x379, 0x3, 0x2, 
       0x2, 0x2, 0x19a2, 0x19a0, 0x3, 0x2, 0x2, 0x2, 0x19a3, 0x19a4, 0x5, 
       0x33e, 0x1a0, 0x2, 0x19a4, 0x37b, 0x3, 0x2, 0x2, 0x2, 0x19a5, 0x19a6, 
       0x5, 0x33e, 0x1a0, 0x2, 0x19a6, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x19a7, 
       0x19a8, 0x5, 0x32e, 0x198, 0x2, 0x19a8, 0x37f, 0x3, 0x2, 0x2, 0x2, 
       0x19a9, 0x19aa, 0x5, 0x32c, 0x197, 0x2, 0x19aa, 0x381, 0x3, 0x2, 
       0x2, 0x2, 0x19ab, 0x19ac, 0x5, 0x33e, 0x1a0, 0x2, 0x19ac, 0x383, 
       0x3, 0x2, 0x2, 0x2, 0x19ad, 0x19ae, 0x5, 0x32c, 0x197, 0x2, 0x19ae, 
       0x385, 0x3, 0x2, 0x2, 0x2, 0x19af, 0x19b0, 0x7, 0x313, 0x2, 0x2, 
       0x19b0, 0x387, 0x3, 0x2, 0x2, 0x2, 0x19b1, 0x19b2, 0x5, 0x362, 0x1b2, 
       0x2, 0x19b2, 0x19b3, 0x7, 0x306, 0x2, 0x2, 0x19b3, 0x19b4, 0x5, 0x384, 
       0x1c3, 0x2, 0x19b4, 0x19b5, 0x7, 0x2ea, 0x2, 0x2, 0x19b5, 0x19b6, 
       0x5, 0x386, 0x1c4, 0x2, 0x19b6, 0x389, 0x3, 0x2, 0x2, 0x2, 0x19b7, 
       0x19b8, 0x5, 0x32c, 0x197, 0x2, 0x19b8, 0x38b, 0x3, 0x2, 0x2, 0x2, 
       0x19b9, 0x19bc, 0x5, 0x33e, 0x1a0, 0x2, 0x19ba, 0x19bb, 0x7, 0x2f0, 
       0x2, 0x2, 0x19bb, 0x19bd, 0x5, 0x33e, 0x1a0, 0x2, 0x19bc, 0x19ba, 
       0x3, 0x2, 0x2, 0x2, 0x19bc, 0x19bd, 0x3, 0x2, 0x2, 0x2, 0x19bd, 0x38d, 
       0x3, 0x2, 0x2, 0x2, 0x19be, 0x19bf, 0x5, 0x32e, 0x198, 0x2, 0x19bf, 
       0x38f, 0x3, 0x2, 0x2, 0x2, 0x19c0, 0x19c3, 0x5, 0x32c, 0x197, 0x2, 
       0x19c1, 0x19c3, 0x7, 0x30e, 0x2, 0x2, 0x19c2, 0x19c0, 0x3, 0x2, 0x2, 
       0x2, 0x19c2, 0x19c1, 0x3, 0x2, 0x2, 0x2, 0x19c3, 0x19c4, 0x3, 0x2, 
       0x2, 0x2, 0x19c4, 0x19c7, 0x7, 0x306, 0x2, 0x2, 0x19c5, 0x19c8, 0x5, 
       0x32c, 0x197, 0x2, 0x19c6, 0x19c8, 0x7, 0x30e, 0x2, 0x2, 0x19c7, 
       0x19c5, 0x3, 0x2, 0x2, 0x2, 0x19c7, 0x19c6, 0x3, 0x2, 0x2, 0x2, 0x19c8, 
       0x19cb, 0x3, 0x2, 0x2, 0x2, 0x19c9, 0x19cb, 0x7, 0x30e, 0x2, 0x2, 
       0x19ca, 0x19c2, 0x3, 0x2, 0x2, 0x2, 0x19ca, 0x19c9, 0x3, 0x2, 0x2, 
       0x2, 0x19cb, 0x391, 0x3, 0x2, 0x2, 0x2, 0x19cc, 0x19cd, 0x5, 0x342, 
       0x1a2, 0x2, 0x19cd, 0x393, 0x3, 0x2, 0x2, 0x2, 0x19ce, 0x19d1, 0x5, 
       0x33e, 0x1a0, 0x2, 0x19cf, 0x19d0, 0x7, 0x2f0, 0x2, 0x2, 0x19d0, 
       0x19d2, 0x5, 0x33e, 0x1a0, 0x2, 0x19d1, 0x19cf, 0x3, 0x2, 0x2, 0x2, 
       0x19d1, 0x19d2, 0x3, 0x2, 0x2, 0x2, 0x19d2, 0x395, 0x3, 0x2, 0x2, 
       0x2, 0x19d3, 0x19d4, 0x9, 0x52, 0x2, 0x2, 0x19d4, 0x397, 0x3, 0x2, 
       0x2, 0x2, 0x19d5, 0x19d6, 0x9, 0x32, 0x2, 0x2, 0x19d6, 0x399, 0x3, 
       0x2, 0x2, 0x2, 0x19d7, 0x19da, 0x5, 0x362, 0x1b2, 0x2, 0x19d8, 0x19da, 
       0x5, 0x390, 0x1c9, 0x2, 0x19d9, 0x19d7, 0x3, 0x2, 0x2, 0x2, 0x19d9, 
       0x19d8, 0x3, 0x2, 0x2, 0x2, 0x19da, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x19db, 
       0x19dc, 0x5, 0x33e, 0x1a0, 0x2, 0x19dc, 0x39d, 0x3, 0x2, 0x2, 0x2, 
       0x19dd, 0x19e2, 0x5, 0x33e, 0x1a0, 0x2, 0x19de, 0x19df, 0x7, 0x301, 
       0x2, 0x2, 0x19df, 0x19e1, 0x5, 0x33e, 0x1a0, 0x2, 0x19e0, 0x19de, 
       0x3, 0x2, 0x2, 0x2, 0x19e1, 0x19e4, 0x3, 0x2, 0x2, 0x2, 0x19e2, 0x19e0, 
       0x3, 0x2, 0x2, 0x2, 0x19e2, 0x19e3, 0x3, 0x2, 0x2, 0x2, 0x19e3, 0x39f, 
       0x3, 0x2, 0x2, 0x2, 0x19e4, 0x19e2, 0x3, 0x2, 0x2, 0x2, 0x19e5, 0x19e8, 
       0x7, 0x25, 0x2, 0x2, 0x19e6, 0x19e8, 0x5, 0x39e, 0x1d0, 0x2, 0x19e7, 
       0x19e5, 0x3, 0x2, 0x2, 0x2, 0x19e7, 0x19e6, 0x3, 0x2, 0x2, 0x2, 0x19e8, 
       0x3a1, 0x3, 0x2, 0x2, 0x2, 0x19e9, 0x19ea, 0x9, 0x53, 0x2, 0x2, 0x19ea, 
       0x3a3, 0x3, 0x2, 0x2, 0x2, 0x19eb, 0x19ec, 0x9, 0x54, 0x2, 0x2, 0x19ec, 
       0x19ed, 0x5, 0x394, 0x1cb, 0x2, 0x19ed, 0x3a5, 0x3, 0x2, 0x2, 0x2, 
       0x19ee, 0x19ef, 0x8, 0x1d4, 0x1, 0x2, 0x19ef, 0x19f4, 0x5, 0x3ac, 
       0x1d7, 0x2, 0x19f0, 0x19f1, 0x5, 0x3aa, 0x1d6, 0x2, 0x19f1, 0x19f2, 
       0x5, 0x3a6, 0x1d4, 0x3, 0x19f2, 0x19f4, 0x3, 0x2, 0x2, 0x2, 0x19f3, 
       0x19ee, 0x3, 0x2, 0x2, 0x2, 0x19f3, 0x19f0, 0x3, 0x2, 0x2, 0x2, 0x19f4, 
       0x19fe, 0x3, 0x2, 0x2, 0x2, 0x19f5, 0x19f6, 0xc, 0x5, 0x2, 0x2, 0x19f6, 
       0x19f7, 0x5, 0x3a8, 0x1d5, 0x2, 0x19f7, 0x19f8, 0x5, 0x3a6, 0x1d4, 
       0x6, 0x19f8, 0x19fd, 0x3, 0x2, 0x2, 0x2, 0x19f9, 0x19fa, 0xc, 0x4, 
       0x2, 0x2, 0x19fa, 0x19fb, 0x7, 0x2da, 0x2, 0x2, 0x19fb, 0x19fd, 0x5, 
       0x3a6, 0x1d4, 0x5, 0x19fc, 0x19f5, 0x3, 0x2, 0x2, 0x2, 0x19fc, 0x19f9, 
       0x3, 0x2, 0x2, 0x2, 0x19fd, 0x1a00, 0x3, 0x2, 0x2, 0x2, 0x19fe, 0x19fc, 
       0x3, 0x2, 0x2, 0x2, 0x19fe, 0x19ff, 0x3, 0x2, 0x2, 0x2, 0x19ff, 0x3a7, 
       0x3, 0x2, 0x2, 0x2, 0x1a00, 0x19fe, 0x3, 0x2, 0x2, 0x2, 0x1a01, 0x1a02, 
       0x9, 0x55, 0x2, 0x2, 0x1a02, 0x3a9, 0x3, 0x2, 0x2, 0x2, 0x1a03, 0x1a04, 
       0x9, 0x56, 0x2, 0x2, 0x1a04, 0x3ab, 0x3, 0x2, 0x2, 0x2, 0x1a05, 0x1a06, 
       0x8, 0x1d7, 0x1, 0x2, 0x1a06, 0x1a07, 0x5, 0x3b0, 0x1d9, 0x2, 0x1a07, 
       0x1a1c, 0x3, 0x2, 0x2, 0x2, 0x1a08, 0x1a09, 0xc, 0x7, 0x2, 0x2, 0x1a09, 
       0x1a0b, 0x7, 0x127, 0x2, 0x2, 0x1a0a, 0x1a0c, 0x7, 0x1a0, 0x2, 0x2, 
       0x1a0b, 0x1a0a, 0x3, 0x2, 0x2, 0x2, 0x1a0b, 0x1a0c, 0x3, 0x2, 0x2, 
       0x2, 0x1a0c, 0x1a0d, 0x3, 0x2, 0x2, 0x2, 0x1a0d, 0x1a1b, 0x9, 0x57, 
       0x2, 0x2, 0x1a0e, 0x1a0f, 0xc, 0x6, 0x2, 0x2, 0x1a0f, 0x1a10, 0x7, 
       0x2f2, 0x2, 0x2, 0x1a10, 0x1a1b, 0x5, 0x3b0, 0x1d9, 0x2, 0x1a11, 
       0x1a12, 0xc, 0x5, 0x2, 0x2, 0x1a12, 0x1a13, 0x5, 0x3ae, 0x1d8, 0x2, 
       0x1a13, 0x1a14, 0x5, 0x3b0, 0x1d9, 0x2, 0x1a14, 0x1a1b, 0x3, 0x2, 
       0x2, 0x2, 0x1a15, 0x1a16, 0xc, 0x4, 0x2, 0x2, 0x1a16, 0x1a17, 0x5, 
       0x3ae, 0x1d8, 0x2, 0x1a17, 0x1a18, 0x9, 0x58, 0x2, 0x2, 0x1a18, 0x1a19, 
       0x5, 0x9a, 0x4e, 0x2, 0x1a19, 0x1a1b, 0x3, 0x2, 0x2, 0x2, 0x1a1a, 
       0x1a08, 0x3, 0x2, 0x2, 0x2, 0x1a1a, 0x1a0e, 0x3, 0x2, 0x2, 0x2, 0x1a1a, 
       0x1a11, 0x3, 0x2, 0x2, 0x2, 0x1a1a, 0x1a15, 0x3, 0x2, 0x2, 0x2, 0x1a1b, 
       0x1a1e, 0x3, 0x2, 0x2, 0x2, 0x1a1c, 0x1a1a, 0x3, 0x2, 0x2, 0x2, 0x1a1c, 
       0x1a1d, 0x3, 0x2, 0x2, 0x2, 0x1a1d, 0x3ad, 0x3, 0x2, 0x2, 0x2, 0x1a1e, 
       0x1a1c, 0x3, 0x2, 0x2, 0x2, 0x1a1f, 0x1a20, 0x9, 0x59, 0x2, 0x2, 
       0x1a20, 0x3af, 0x3, 0x2, 0x2, 0x2, 0x1a21, 0x1a23, 0x5, 0x3b2, 0x1da, 
       0x2, 0x1a22, 0x1a24, 0x7, 0x1a0, 0x2, 0x2, 0x1a23, 0x1a22, 0x3, 0x2, 
       0x2, 0x2, 0x1a23, 0x1a24, 0x3, 0x2, 0x2, 0x2, 0x1a24, 0x1a25, 0x3, 
       0x2, 0x2, 0x2, 0x1a25, 0x1a26, 0x7, 0x10a, 0x2, 0x2, 0x1a26, 0x1a27, 
       0x5, 0x9a, 0x4e, 0x2, 0x1a27, 0x1a59, 0x3, 0x2, 0x2, 0x2, 0x1a28, 
       0x1a2a, 0x5, 0x3b2, 0x1da, 0x2, 0x1a29, 0x1a2b, 0x7, 0x1a0, 0x2, 
       0x2, 0x1a2a, 0x1a29, 0x3, 0x2, 0x2, 0x2, 0x1a2a, 0x1a2b, 0x3, 0x2, 
       0x2, 0x2, 0x1a2b, 0x1a2c, 0x3, 0x2, 0x2, 0x2, 0x1a2c, 0x1a2d, 0x7, 
       0x10a, 0x2, 0x2, 0x1a2d, 0x1a2e, 0x7, 0x2fb, 0x2, 0x2, 0x1a2e, 0x1a33, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x1a2f, 0x1a30, 0x7, 0x301, 0x2, 0x2, 0x1a30, 
       0x1a32, 0x5, 0x3a6, 0x1d4, 0x2, 0x1a31, 0x1a2f, 0x3, 0x2, 0x2, 0x2, 
       0x1a32, 0x1a35, 0x3, 0x2, 0x2, 0x2, 0x1a33, 0x1a31, 0x3, 0x2, 0x2, 
       0x2, 0x1a33, 0x1a34, 0x3, 0x2, 0x2, 0x2, 0x1a34, 0x1a36, 0x3, 0x2, 
       0x2, 0x2, 0x1a35, 0x1a33, 0x3, 0x2, 0x2, 0x2, 0x1a36, 0x1a37, 0x7, 
       0x2fc, 0x2, 0x2, 0x1a37, 0x1a59, 0x3, 0x2, 0x2, 0x2, 0x1a38, 0x1a3a, 
       0x5, 0x3b2, 0x1da, 0x2, 0x1a39, 0x1a3b, 0x7, 0x1a0, 0x2, 0x2, 0x1a3a, 
       0x1a39, 0x3, 0x2, 0x2, 0x2, 0x1a3a, 0x1a3b, 0x3, 0x2, 0x2, 0x2, 0x1a3b, 
       0x1a3c, 0x3, 0x2, 0x2, 0x2, 0x1a3c, 0x1a3d, 0x7, 0x39, 0x2, 0x2, 
       0x1a3d, 0x1a3e, 0x5, 0x3b2, 0x1da, 0x2, 0x1a3e, 0x1a3f, 0x7, 0x29, 
       0x2, 0x2, 0x1a3f, 0x1a40, 0x5, 0x3b0, 0x1d9, 0x2, 0x1a40, 0x1a59, 
       0x3, 0x2, 0x2, 0x2, 0x1a41, 0x1a42, 0x5, 0x3b2, 0x1da, 0x2, 0x1a42, 
       0x1a43, 0x7, 0x253, 0x2, 0x2, 0x1a43, 0x1a44, 0x7, 0x13f, 0x2, 0x2, 
       0x1a44, 0x1a45, 0x5, 0x3b2, 0x1da, 0x2, 0x1a45, 0x1a59, 0x3, 0x2, 
       0x2, 0x2, 0x1a46, 0x1a48, 0x5, 0x3b2, 0x1da, 0x2, 0x1a47, 0x1a49, 
       0x7, 0x1a0, 0x2, 0x2, 0x1a48, 0x1a47, 0x3, 0x2, 0x2, 0x2, 0x1a48, 
       0x1a49, 0x3, 0x2, 0x2, 0x2, 0x1a49, 0x1a4a, 0x3, 0x2, 0x2, 0x2, 0x1a4a, 
       0x1a4b, 0x7, 0x13f, 0x2, 0x2, 0x1a4b, 0x1a4e, 0x5, 0x3b4, 0x1db, 
       0x2, 0x1a4c, 0x1a4d, 0x7, 0xbd, 0x2, 0x2, 0x1a4d, 0x1a4f, 0x5, 0x3b4, 
       0x1db, 0x2, 0x1a4e, 0x1a4c, 0x3, 0x2, 0x2, 0x2, 0x1a4e, 0x1a4f, 0x3, 
       0x2, 0x2, 0x2, 0x1a4f, 0x1a59, 0x3, 0x2, 0x2, 0x2, 0x1a50, 0x1a52, 
       0x5, 0x3b2, 0x1da, 0x2, 0x1a51, 0x1a53, 0x7, 0x1a0, 0x2, 0x2, 0x1a52, 
       0x1a51, 0x3, 0x2, 0x2, 0x2, 0x1a52, 0x1a53, 0x3, 0x2, 0x2, 0x2, 0x1a53, 
       0x1a54, 0x3, 0x2, 0x2, 0x2, 0x1a54, 0x1a55, 0x7, 0x1fa, 0x2, 0x2, 
       0x1a55, 0x1a56, 0x5, 0x3b2, 0x1da, 0x2, 0x1a56, 0x1a59, 0x3, 0x2, 
       0x2, 0x2, 0x1a57, 0x1a59, 0x5, 0x3b2, 0x1da, 0x2, 0x1a58, 0x1a21, 
       0x3, 0x2, 0x2, 0x2, 0x1a58, 0x1a28, 0x3, 0x2, 0x2, 0x2, 0x1a58, 0x1a38, 
       0x3, 0x2, 0x2, 0x2, 0x1a58, 0x1a41, 0x3, 0x2, 0x2, 0x2, 0x1a58, 0x1a46, 
       0x3, 0x2, 0x2, 0x2, 0x1a58, 0x1a50, 0x3, 0x2, 0x2, 0x2, 0x1a58, 0x1a57, 
       0x3, 0x2, 0x2, 0x2, 0x1a59, 0x3b1, 0x3, 0x2, 0x2, 0x2, 0x1a5a, 0x1a5b, 
       0x8, 0x1da, 0x1, 0x2, 0x1a5b, 0x1a5c, 0x5, 0x3b4, 0x1db, 0x2, 0x1a5c, 
       0x1a89, 0x3, 0x2, 0x2, 0x2, 0x1a5d, 0x1a5e, 0xc, 0x11, 0x2, 0x2, 
       0x1a5e, 0x1a5f, 0x7, 0x2e4, 0x2, 0x2, 0x1a5f, 0x1a88, 0x5, 0x3b2, 
       0x1da, 0x12, 0x1a60, 0x1a61, 0xc, 0x10, 0x2, 0x2, 0x1a61, 0x1a62, 
       0x7, 0x2e5, 0x2, 0x2, 0x1a62, 0x1a88, 0x5, 0x3b2, 0x1da, 0x11, 0x1a63, 
       0x1a64, 0xc, 0xf, 0x2, 0x2, 0x1a64, 0x1a65, 0x7, 0x2e6, 0x2, 0x2, 
       0x1a65, 0x1a88, 0x5, 0x3b2, 0x1da, 0x10, 0x1a66, 0x1a67, 0xc, 0xe, 
       0x2, 0x2, 0x1a67, 0x1a68, 0x7, 0x2e7, 0x2, 0x2, 0x1a68, 0x1a88, 0x5, 
       0x3b2, 0x1da, 0xf, 0x1a69, 0x1a6a, 0xc, 0xd, 0x2, 0x2, 0x1a6a, 0x1a6b, 
       0x7, 0x2eb, 0x2, 0x2, 0x1a6b, 0x1a88, 0x5, 0x3b2, 0x1da, 0xe, 0x1a6c, 
       0x1a6d, 0xc, 0xc, 0x2, 0x2, 0x1a6d, 0x1a6e, 0x7, 0x2ec, 0x2, 0x2, 
       0x1a6e, 0x1a88, 0x5, 0x3b2, 0x1da, 0xd, 0x1a6f, 0x1a70, 0xc, 0xb, 
       0x2, 0x2, 0x1a70, 0x1a71, 0x7, 0x2ed, 0x2, 0x2, 0x1a71, 0x1a88, 0x5, 
       0x3b2, 0x1da, 0xc, 0x1a72, 0x1a73, 0xc, 0xa, 0x2, 0x2, 0x1a73, 0x1a74, 
       0x7, 0x2ee, 0x2, 0x2, 0x1a74, 0x1a88, 0x5, 0x3b2, 0x1da, 0xb, 0x1a75, 
       0x1a76, 0xc, 0x9, 0x2, 0x2, 0x1a76, 0x1a77, 0x7, 0xa5, 0x2, 0x2, 
       0x1a77, 0x1a88, 0x5, 0x3b2, 0x1da, 0xa, 0x1a78, 0x1a79, 0xc, 0x8, 
       0x2, 0x2, 0x1a79, 0x1a7a, 0x7, 0x187, 0x2, 0x2, 0x1a7a, 0x1a88, 0x5, 
       0x3b2, 0x1da, 0x9, 0x1a7b, 0x1a7c, 0xc, 0x7, 0x2, 0x2, 0x1a7c, 0x1a7d, 
       0x7, 0x2e9, 0x2, 0x2, 0x1a7d, 0x1a88, 0x5, 0x3b2, 0x1da, 0x8, 0x1a7e, 
       0x1a7f, 0xc, 0x6, 0x2, 0x2, 0x1a7f, 0x1a80, 0x7, 0x2e8, 0x2, 0x2, 
       0x1a80, 0x1a88, 0x5, 0x3b2, 0x1da, 0x7, 0x1a81, 0x1a82, 0xc, 0x5, 
       0x2, 0x2, 0x1a82, 0x1a83, 0x7, 0x2eb, 0x2, 0x2, 0x1a83, 0x1a88, 0x5, 
       0x410, 0x209, 0x2, 0x1a84, 0x1a85, 0xc, 0x4, 0x2, 0x2, 0x1a85, 0x1a86, 
       0x7, 0x2ec, 0x2, 0x2, 0x1a86, 0x1a88, 0x5, 0x410, 0x209, 0x2, 0x1a87, 
       0x1a5d, 0x3, 0x2, 0x2, 0x2, 0x1a87, 0x1a60, 0x3, 0x2, 0x2, 0x2, 0x1a87, 
       0x1a63, 0x3, 0x2, 0x2, 0x2, 0x1a87, 0x1a66, 0x3, 0x2, 0x2, 0x2, 0x1a87, 
       0x1a69, 0x3, 0x2, 0x2, 0x2, 0x1a87, 0x1a6c, 0x3, 0x2, 0x2, 0x2, 0x1a87, 
       0x1a6f, 0x3, 0x2, 0x2, 0x2, 0x1a87, 0x1a72, 0x3, 0x2, 0x2, 0x2, 0x1a87, 
       0x1a75, 0x3, 0x2, 0x2, 0x2, 0x1a87, 0x1a78, 0x3, 0x2, 0x2, 0x2, 0x1a87, 
       0x1a7b, 0x3, 0x2, 0x2, 0x2, 0x1a87, 0x1a7e, 0x3, 0x2, 0x2, 0x2, 0x1a87, 
       0x1a81, 0x3, 0x2, 0x2, 0x2, 0x1a87, 0x1a84, 0x3, 0x2, 0x2, 0x2, 0x1a88, 
       0x1a8b, 0x3, 0x2, 0x2, 0x2, 0x1a89, 0x1a87, 0x3, 0x2, 0x2, 0x2, 0x1a89, 
       0x1a8a, 0x3, 0x2, 0x2, 0x2, 0x1a8a, 0x3b3, 0x3, 0x2, 0x2, 0x2, 0x1a8b, 
       0x1a89, 0x3, 0x2, 0x2, 0x2, 0x1a8c, 0x1a8d, 0x8, 0x1db, 0x1, 0x2, 
       0x1a8d, 0x1ab9, 0x5, 0x3ba, 0x1de, 0x2, 0x1a8e, 0x1ab9, 0x5, 0x326, 
       0x194, 0x2, 0x1a8f, 0x1ab9, 0x5, 0x32a, 0x196, 0x2, 0x1a90, 0x1ab9, 
       0x5, 0x3b6, 0x1dc, 0x2, 0x1a91, 0x1ab9, 0x5, 0x344, 0x1a3, 0x2, 0x1a92, 
       0x1a98, 0x7, 0x2eb, 0x2, 0x2, 0x1a93, 0x1a98, 0x7, 0x2ec, 0x2, 0x2, 
       0x1a94, 0x1a98, 0x7, 0x2e3, 0x2, 0x2, 0x1a95, 0x1a98, 0x5, 0x3aa, 
       0x1d6, 0x2, 0x1a96, 0x1a98, 0x7, 0x3b, 0x2, 0x2, 0x1a97, 0x1a92, 
       0x3, 0x2, 0x2, 0x2, 0x1a97, 0x1a93, 0x3, 0x2, 0x2, 0x2, 0x1a97, 0x1a94, 
       0x3, 0x2, 0x2, 0x2, 0x1a97, 0x1a95, 0x3, 0x2, 0x2, 0x2, 0x1a97, 0x1a96, 
       0x3, 0x2, 0x2, 0x2, 0x1a98, 0x1a99, 0x3, 0x2, 0x2, 0x2, 0x1a99, 0x1ab9, 
       0x5, 0x3b4, 0x1db, 0xa, 0x1a9a, 0x1a9c, 0x7, 0x22a, 0x2, 0x2, 0x1a9b, 
       0x1a9a, 0x3, 0x2, 0x2, 0x2, 0x1a9b, 0x1a9c, 0x3, 0x2, 0x2, 0x2, 0x1a9c, 
       0x1a9d, 0x3, 0x2, 0x2, 0x2, 0x1a9d, 0x1a9e, 0x7, 0x2fb, 0x2, 0x2, 
       0x1a9e, 0x1aa3, 0x5, 0x3a6, 0x1d4, 0x2, 0x1a9f, 0x1aa0, 0x7, 0x301, 
       0x2, 0x2, 0x1aa0, 0x1aa2, 0x5, 0x3a6, 0x1d4, 0x2, 0x1aa1, 0x1a9f, 
       0x3, 0x2, 0x2, 0x2, 0x1aa2, 0x1aa5, 0x3, 0x2, 0x2, 0x2, 0x1aa3, 0x1aa1, 
       0x3, 0x2, 0x2, 0x2, 0x1aa3, 0x1aa4, 0x3, 0x2, 0x2, 0x2, 0x1aa4, 0x1aa6, 
       0x3, 0x2, 0x2, 0x2, 0x1aa5, 0x1aa3, 0x3, 0x2, 0x2, 0x2, 0x1aa6, 0x1aa7, 
       0x7, 0x2fc, 0x2, 0x2, 0x1aa7, 0x1ab9, 0x3, 0x2, 0x2, 0x2, 0x1aa8, 
       0x1aaa, 0x7, 0xc6, 0x2, 0x2, 0x1aa9, 0x1aa8, 0x3, 0x2, 0x2, 0x2, 
       0x1aa9, 0x1aaa, 0x3, 0x2, 0x2, 0x2, 0x1aaa, 0x1aab, 0x3, 0x2, 0x2, 
       0x2, 0x1aab, 0x1ab9, 0x5, 0x9a, 0x4e, 0x2, 0x1aac, 0x1aad, 0x7, 0x2fd, 
       0x2, 0x2, 0x1aad, 0x1aae, 0x5, 0x33e, 0x1a0, 0x2, 0x1aae, 0x1aaf, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x1aaf, 0x1ab0, 0x7, 0x2fe, 0x2, 0x2, 0x1ab0, 
       0x1ab9, 0x3, 0x2, 0x2, 0x2, 0x1ab1, 0x1ab2, 0x5, 0x33e, 0x1a0, 0x2, 
       0x1ab2, 0x1ab3, 0x9, 0x5a, 0x2, 0x2, 0x1ab3, 0x1ab4, 0x5, 0x32c, 
       0x197, 0x2, 0x1ab4, 0x1ab9, 0x3, 0x2, 0x2, 0x2, 0x1ab5, 0x1ab9, 0x5, 
       0x402, 0x202, 0x2, 0x1ab6, 0x1ab9, 0x5, 0x406, 0x204, 0x2, 0x1ab7, 
       0x1ab9, 0x5, 0x410, 0x209, 0x2, 0x1ab8, 0x1a8c, 0x3, 0x2, 0x2, 0x2, 
       0x1ab8, 0x1a8e, 0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1a8f, 0x3, 0x2, 0x2, 
       0x2, 0x1ab8, 0x1a90, 0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1a91, 0x3, 0x2, 
       0x2, 0x2, 0x1ab8, 0x1a97, 0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1a9b, 0x3, 
       0x2, 0x2, 0x2, 0x1ab8, 0x1aa9, 0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1aac, 
       0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1ab1, 0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1ab5, 
       0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1ab6, 0x3, 0x2, 0x2, 0x2, 0x1ab8, 0x1ab7, 
       0x3, 0x2, 0x2, 0x2, 0x1ab9, 0x1ac2, 0x3, 0x2, 0x2, 0x2, 0x1aba, 0x1abb, 
       0xc, 0xb, 0x2, 0x2, 0x1abb, 0x1abc, 0x7, 0x2e1, 0x2, 0x2, 0x1abc, 
       0x1ac1, 0x5, 0x3b4, 0x1db, 0xc, 0x1abd, 0x1abe, 0xc, 0xd, 0x2, 0x2, 
       0x1abe, 0x1abf, 0x7, 0x5d, 0x2, 0x2, 0x1abf, 0x1ac1, 0x5, 0x342, 
       0x1a2, 0x2, 0x1ac0, 0x1aba, 0x3, 0x2, 0x2, 0x2, 0x1ac0, 0x1abd, 0x3, 
       0x2, 0x2, 0x2, 0x1ac1, 0x1ac4, 0x3, 0x2, 0x2, 0x2, 0x1ac2, 0x1ac0, 
       0x3, 0x2, 0x2, 0x2, 0x1ac2, 0x1ac3, 0x3, 0x2, 0x2, 0x2, 0x1ac3, 0x3b5, 
       0x3, 0x2, 0x2, 0x2, 0x1ac4, 0x1ac2, 0x3, 0x2, 0x2, 0x2, 0x1ac5, 0x1ac8, 
       0x5, 0x33e, 0x1a0, 0x2, 0x1ac6, 0x1ac7, 0x7, 0x2f0, 0x2, 0x2, 0x1ac7, 
       0x1ac9, 0x5, 0x33e, 0x1a0, 0x2, 0x1ac8, 0x1ac6, 0x3, 0x2, 0x2, 0x2, 
       0x1ac8, 0x1ac9, 0x3, 0x2, 0x2, 0x2, 0x1ac9, 0x1acc, 0x3, 0x2, 0x2, 
       0x2, 0x1aca, 0x1acb, 0x7, 0x2f0, 0x2, 0x2, 0x1acb, 0x1acd, 0x5, 0x33e, 
       0x1a0, 0x2, 0x1acc, 0x1aca, 0x3, 0x2, 0x2, 0x2, 0x1acc, 0x1acd, 0x3, 
       0x2, 0x2, 0x2, 0x1acd, 0x3b7, 0x3, 0x2, 0x2, 0x2, 0x1ace, 0x1ad3, 
       0x5, 0x3b6, 0x1dc, 0x2, 0x1acf, 0x1ad0, 0x7, 0x301, 0x2, 0x2, 0x1ad0, 
       0x1ad2, 0x5, 0x3b6, 0x1dc, 0x2, 0x1ad1, 0x1acf, 0x3, 0x2, 0x2, 0x2, 
       0x1ad2, 0x1ad5, 0x3, 0x2, 0x2, 0x2, 0x1ad3, 0x1ad1, 0x3, 0x2, 0x2, 
       0x2, 0x1ad3, 0x1ad4, 0x3, 0x2, 0x2, 0x2, 0x1ad4, 0x3b9, 0x3, 0x2, 
       0x2, 0x2, 0x1ad5, 0x1ad3, 0x3, 0x2, 0x2, 0x2, 0x1ad6, 0x1ada, 0x5, 
       0x3bc, 0x1df, 0x2, 0x1ad7, 0x1ada, 0x5, 0x3ce, 0x1e8, 0x2, 0x1ad8, 
       0x1ada, 0x5, 0x3fa, 0x1fe, 0x2, 0x1ad9, 0x1ad6, 0x3, 0x2, 0x2, 0x2, 
       0x1ad9, 0x1ad7, 0x3, 0x2, 0x2, 0x2, 0x1ad9, 0x1ad8, 0x3, 0x2, 0x2, 
       0x2, 0x1ada, 0x3bb, 0x3, 0x2, 0x2, 0x2, 0x1adb, 0x1adc, 0x5, 0x3be, 
       0x1e0, 0x2, 0x1adc, 0x1ade, 0x7, 0x2fb, 0x2, 0x2, 0x1add, 0x1adf, 
       0x5, 0x3c0, 0x1e1, 0x2, 0x1ade, 0x1add, 0x3, 0x2, 0x2, 0x2, 0x1ade, 
       0x1adf, 0x3, 0x2, 0x2, 0x2, 0x1adf, 0x1ae9, 0x3, 0x2, 0x2, 0x2, 0x1ae0, 
       0x1ae5, 0x5, 0x3a6, 0x1d4, 0x2, 0x1ae1, 0x1ae2, 0x7, 0x301, 0x2, 
       0x2, 0x1ae2, 0x1ae4, 0x5, 0x3a6, 0x1d4, 0x2, 0x1ae3, 0x1ae1, 0x3, 
       0x2, 0x2, 0x2, 0x1ae4, 0x1ae7, 0x3, 0x2, 0x2, 0x2, 0x1ae5, 0x1ae3, 
       0x3, 0x2, 0x2, 0x2, 0x1ae5, 0x1ae6, 0x3, 0x2, 0x2, 0x2, 0x1ae6, 0x1aea, 
       0x3, 0x2, 0x2, 0x2, 0x1ae7, 0x1ae5, 0x3, 0x2, 0x2, 0x2, 0x1ae8, 0x1aea, 
       0x7, 0x2ed, 0x2, 0x2, 0x1ae9, 0x1ae0, 0x3, 0x2, 0x2, 0x2, 0x1ae9, 
       0x1ae8, 0x3, 0x2, 0x2, 0x2, 0x1ae9, 0x1aea, 0x3, 0x2, 0x2, 0x2, 0x1aea, 
       0x1aeb, 0x3, 0x2, 0x2, 0x2, 0x1aeb, 0x1aed, 0x7, 0x2fc, 0x2, 0x2, 
       0x1aec, 0x1aee, 0x5, 0x3c2, 0x1e2, 0x2, 0x1aed, 0x1aec, 0x3, 0x2, 
       0x2, 0x2, 0x1aed, 0x1aee, 0x3, 0x2, 0x2, 0x2, 0x1aee, 0x3bd, 0x3, 
       0x2, 0x2, 0x2, 0x1aef, 0x1af0, 0x9, 0x5b, 0x2, 0x2, 0x1af0, 0x3bf, 
       0x3, 0x2, 0x2, 0x2, 0x1af1, 0x1af2, 0x7, 0xa3, 0x2, 0x2, 0x1af2, 
       0x3c1, 0x3, 0x2, 0x2, 0x2, 0x1af3, 0x1af9, 0x7, 0x1c2, 0x2, 0x2, 
       0x1af4, 0x1af5, 0x7, 0x2fb, 0x2, 0x2, 0x1af5, 0x1af6, 0x5, 0x3c4, 
       0x1e3, 0x2, 0x1af6, 0x1af7, 0x7, 0x2fc, 0x2, 0x2, 0x1af7, 0x1afa, 
       0x3, 0x2, 0x2, 0x2, 0x1af8, 0x1afa, 0x5, 0x33e, 0x1a0, 0x2, 0x1af9, 
       0x1af4, 0x3, 0x2, 0x2, 0x2, 0x1af9, 0x1af8, 0x3, 0x2, 0x2, 0x2, 0x1afa, 
       0x3c3, 0x3, 0x2, 0x2, 0x2, 0x1afb, 0x1afd, 0x7, 0x2fb, 0x2, 0x2, 
       0x1afc, 0x1afe, 0x5, 0x33e, 0x1a0, 0x2, 0x1afd, 0x1afc, 0x3, 0x2, 
       0x2, 0x2, 0x1afd, 0x1afe, 0x3, 0x2, 0x2, 0x2, 0x1afe, 0x1b09, 0x3, 
       0x2, 0x2, 0x2, 0x1aff, 0x1b00, 0x7, 0x1c8, 0x2, 0x2, 0x1b00, 0x1b01, 
       0x7, 0x45, 0x2, 0x2, 0x1b01, 0x1b06, 0x5, 0x3a6, 0x1d4, 0x2, 0x1b02, 
       0x1b03, 0x7, 0x301, 0x2, 0x2, 0x1b03, 0x1b05, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1b04, 0x1b02, 0x3, 0x2, 0x2, 0x2, 0x1b05, 0x1b08, 0x3, 0x2, 
       0x2, 0x2, 0x1b06, 0x1b04, 0x3, 0x2, 0x2, 0x2, 0x1b06, 0x1b07, 0x3, 
       0x2, 0x2, 0x2, 0x1b07, 0x1b0a, 0x3, 0x2, 0x2, 0x2, 0x1b08, 0x1b06, 
       0x3, 0x2, 0x2, 0x2, 0x1b09, 0x1aff, 0x3, 0x2, 0x2, 0x2, 0x1b09, 0x1b0a, 
       0x3, 0x2, 0x2, 0x2, 0x1b0a, 0x1b0c, 0x3, 0x2, 0x2, 0x2, 0x1b0b, 0x1b0d, 
       0x5, 0x416, 0x20c, 0x2, 0x1b0c, 0x1b0b, 0x3, 0x2, 0x2, 0x2, 0x1b0c, 
       0x1b0d, 0x3, 0x2, 0x2, 0x2, 0x1b0d, 0x1b0f, 0x3, 0x2, 0x2, 0x2, 0x1b0e, 
       0x1b10, 0x5, 0x3c6, 0x1e4, 0x2, 0x1b0f, 0x1b0e, 0x3, 0x2, 0x2, 0x2, 
       0x1b0f, 0x1b10, 0x3, 0x2, 0x2, 0x2, 0x1b10, 0x1b11, 0x3, 0x2, 0x2, 
       0x2, 0x1b11, 0x1b12, 0x7, 0x2fc, 0x2, 0x2, 0x1b12, 0x3c5, 0x3, 0x2, 
       0x2, 0x2, 0x1b13, 0x1b16, 0x9, 0x5c, 0x2, 0x2, 0x1b14, 0x1b17, 0x5, 
       0x3c8, 0x1e5, 0x2, 0x1b15, 0x1b17, 0x5, 0x3cc, 0x1e7, 0x2, 0x1b16, 
       0x1b14, 0x3, 0x2, 0x2, 0x2, 0x1b16, 0x1b15, 0x3, 0x2, 0x2, 0x2, 0x1b17, 
       0x3c7, 0x3, 0x2, 0x2, 0x2, 0x1b18, 0x1b19, 0x7, 0x7c, 0x2, 0x2, 0x1b19, 
       0x1b25, 0x7, 0x22a, 0x2, 0x2, 0x1b1a, 0x1b1b, 0x7, 0x2a4, 0x2, 0x2, 
       0x1b1b, 0x1b25, 0x7, 0x1d9, 0x2, 0x2, 0x1b1c, 0x1b1d, 0x7, 0x2a4, 
       0x2, 0x2, 0x1b1d, 0x1b25, 0x7, 0xde, 0x2, 0x2, 0x1b1e, 0x1b1f, 0x5, 
       0x3a6, 0x1d4, 0x2, 0x1b1f, 0x1b20, 0x7, 0x1d9, 0x2, 0x2, 0x1b20, 
       0x1b25, 0x3, 0x2, 0x2, 0x2, 0x1b21, 0x1b22, 0x5, 0x3a6, 0x1d4, 0x2, 
       0x1b22, 0x1b23, 0x7, 0xde, 0x2, 0x2, 0x1b23, 0x1b25, 0x3, 0x2, 0x2, 
       0x2, 0x1b24, 0x1b18, 0x3, 0x2, 0x2, 0x2, 0x1b24, 0x1b1a, 0x3, 0x2, 
       0x2, 0x2, 0x1b24, 0x1b1c, 0x3, 0x2, 0x2, 0x2, 0x1b24, 0x1b1e, 0x3, 
       0x2, 0x2, 0x2, 0x1b24, 0x1b21, 0x3, 0x2, 0x2, 0x2, 0x1b25, 0x3c9, 
       0x3, 0x2, 0x2, 0x2, 0x1b26, 0x1b27, 0x5, 0x3c8, 0x1e5, 0x2, 0x1b27, 
       0x3cb, 0x3, 0x2, 0x2, 0x2, 0x1b28, 0x1b29, 0x7, 0x39, 0x2, 0x2, 0x1b29, 
       0x1b2a, 0x5, 0x3c8, 0x1e5, 0x2, 0x1b2a, 0x1b2b, 0x7, 0x29, 0x2, 0x2, 
       0x1b2b, 0x1b2c, 0x5, 0x3ca, 0x1e6, 0x2, 0x1b2c, 0x3cd, 0x3, 0x2, 
       0x2, 0x2, 0x1b2d, 0x1b3a, 0x5, 0x3d2, 0x1ea, 0x2, 0x1b2e, 0x1b3a, 
       0x5, 0x3d4, 0x1eb, 0x2, 0x1b2f, 0x1b3a, 0x5, 0x3e0, 0x1f1, 0x2, 0x1b30, 
       0x1b3a, 0x5, 0x3e2, 0x1f2, 0x2, 0x1b31, 0x1b3a, 0x5, 0x3e8, 0x1f5, 
       0x2, 0x1b32, 0x1b3a, 0x5, 0x3ea, 0x1f6, 0x2, 0x1b33, 0x1b3a, 0x5, 
       0x3ec, 0x1f7, 0x2, 0x1b34, 0x1b3a, 0x5, 0x3ee, 0x1f8, 0x2, 0x1b35, 
       0x1b3a, 0x5, 0x3f0, 0x1f9, 0x2, 0x1b36, 0x1b3a, 0x5, 0x3f4, 0x1fb, 
       0x2, 0x1b37, 0x1b3a, 0x5, 0x3f2, 0x1fa, 0x2, 0x1b38, 0x1b3a, 0x5, 
       0x3d0, 0x1e9, 0x2, 0x1b39, 0x1b2d, 0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b2e, 
       0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b2f, 0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b30, 
       0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b31, 0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b32, 
       0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b33, 0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b34, 
       0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b35, 0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b36, 
       0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b37, 0x3, 0x2, 0x2, 0x2, 0x1b39, 0x1b38, 
       0x3, 0x2, 0x2, 0x2, 0x1b3a, 0x3cf, 0x3, 0x2, 0x2, 0x2, 0x1b3b, 0x1b3e, 
       0x7, 0x80, 0x2, 0x2, 0x1b3c, 0x1b3d, 0x7, 0x2fb, 0x2, 0x2, 0x1b3d, 
       0x1b3f, 0x7, 0x2fc, 0x2, 0x2, 0x1b3e, 0x1b3c, 0x3, 0x2, 0x2, 0x2, 
       0x1b3e, 0x1b3f, 0x3, 0x2, 0x2, 0x2, 0x1b3f, 0x3d1, 0x3, 0x2, 0x2, 
       0x2, 0x1b40, 0x1b41, 0x7, 0x8, 0x2, 0x2, 0x1b41, 0x1b43, 0x7, 0x2fb, 
       0x2, 0x2, 0x1b42, 0x1b44, 0x5, 0x3c0, 0x1e1, 0x2, 0x1b43, 0x1b42, 
       0x3, 0x2, 0x2, 0x2, 0x1b43, 0x1b44, 0x3, 0x2, 0x2, 0x2, 0x1b44, 0x1b4e, 
       0x3, 0x2, 0x2, 0x2, 0x1b45, 0x1b4a, 0x5, 0x3a6, 0x1d4, 0x2, 0x1b46, 
       0x1b47, 0x7, 0x301, 0x2, 0x2, 0x1b47, 0x1b49, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1b48, 0x1b46, 0x3, 0x2, 0x2, 0x2, 0x1b49, 0x1b4c, 0x3, 0x2, 
       0x2, 0x2, 0x1b4a, 0x1b48, 0x3, 0x2, 0x2, 0x2, 0x1b4a, 0x1b4b, 0x3, 
       0x2, 0x2, 0x2, 0x1b4b, 0x1b4f, 0x3, 0x2, 0x2, 0x2, 0x1b4c, 0x1b4a, 
       0x3, 0x2, 0x2, 0x2, 0x1b4d, 0x1b4f, 0x7, 0x2ed, 0x2, 0x2, 0x1b4e, 
       0x1b45, 0x3, 0x2, 0x2, 0x2, 0x1b4e, 0x1b4d, 0x3, 0x2, 0x2, 0x2, 0x1b4e, 
       0x1b4f, 0x3, 0x2, 0x2, 0x2, 0x1b4f, 0x1b51, 0x3, 0x2, 0x2, 0x2, 0x1b50, 
       0x1b52, 0x5, 0x416, 0x20c, 0x2, 0x1b51, 0x1b50, 0x3, 0x2, 0x2, 0x2, 
       0x1b51, 0x1b52, 0x3, 0x2, 0x2, 0x2, 0x1b52, 0x1b55, 0x3, 0x2, 0x2, 
       0x2, 0x1b53, 0x1b54, 0x7, 0x23f, 0x2, 0x2, 0x1b54, 0x1b56, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1b55, 0x1b53, 0x3, 0x2, 0x2, 0x2, 0x1b55, 0x1b56, 0x3, 
       0x2, 0x2, 0x2, 0x1b56, 0x1b57, 0x3, 0x2, 0x2, 0x2, 0x1b57, 0x1b58, 
       0x7, 0x2fc, 0x2, 0x2, 0x1b58, 0x3d3, 0x3, 0x2, 0x2, 0x2, 0x1b59, 
       0x1b5a, 0x9, 0x5d, 0x2, 0x2, 0x1b5a, 0x1b5b, 0x7, 0x2fb, 0x2, 0x2, 
       0x1b5b, 0x1b5c, 0x7, 0x2fc, 0x2, 0x2, 0x1b5c, 0x1b86, 0x5, 0x3d6, 
       0x1ec, 0x2, 0x1b5d, 0x1b5e, 0x7, 0x1a5, 0x2, 0x2, 0x1b5e, 0x1b5f, 
       0x5, 0x3b4, 0x1db, 0x2, 0x1b5f, 0x1b60, 0x5, 0x3d6, 0x1ec, 0x2, 0x1b60, 
       0x1b86, 0x3, 0x2, 0x2, 0x2, 0x1b61, 0x1b62, 0x9, 0x5e, 0x2, 0x2, 
       0x1b62, 0x1b63, 0x7, 0x2fb, 0x2, 0x2, 0x1b63, 0x1b65, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1b64, 0x1b66, 0x5, 0x3d8, 0x1ed, 0x2, 0x1b65, 0x1b64, 
       0x3, 0x2, 0x2, 0x2, 0x1b65, 0x1b66, 0x3, 0x2, 0x2, 0x2, 0x1b66, 0x1b67, 
       0x3, 0x2, 0x2, 0x2, 0x1b67, 0x1b69, 0x7, 0x2fc, 0x2, 0x2, 0x1b68, 
       0x1b6a, 0x5, 0x3da, 0x1ee, 0x2, 0x1b69, 0x1b68, 0x3, 0x2, 0x2, 0x2, 
       0x1b69, 0x1b6a, 0x3, 0x2, 0x2, 0x2, 0x1b6a, 0x1b6b, 0x3, 0x2, 0x2, 
       0x2, 0x1b6b, 0x1b6c, 0x5, 0x3d6, 0x1ec, 0x2, 0x1b6c, 0x1b86, 0x3, 
       0x2, 0x2, 0x2, 0x1b6d, 0x1b6e, 0x9, 0x5f, 0x2, 0x2, 0x1b6e, 0x1b6f, 
       0x7, 0x2fb, 0x2, 0x2, 0x1b6f, 0x1b70, 0x5, 0x3a6, 0x1d4, 0x2, 0x1b70, 
       0x1b72, 0x7, 0x2fc, 0x2, 0x2, 0x1b71, 0x1b73, 0x5, 0x3da, 0x1ee, 
       0x2, 0x1b72, 0x1b71, 0x3, 0x2, 0x2, 0x2, 0x1b72, 0x1b73, 0x3, 0x2, 
       0x2, 
  };
  static uint16_t serializedATNSegment3[] = {
    0x2, 0x1b73, 0x1b74, 0x3, 0x2, 0x2, 0x2, 0x1b74, 0x1b75, 0x5, 0x3d6, 
       0x1ec, 0x2, 0x1b75, 0x1b86, 0x3, 0x2, 0x2, 0x2, 0x1b76, 0x1b77, 0x7, 
       0x1a4, 0x2, 0x2, 0x1b77, 0x1b78, 0x7, 0x2fb, 0x2, 0x2, 0x1b78, 0x1b79, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x1b79, 0x1b7a, 0x7, 0x301, 0x2, 0x2, 0x1b7a, 
       0x1b7b, 0x5, 0x3b4, 0x1db, 0x2, 0x1b7b, 0x1b7e, 0x7, 0x2fc, 0x2, 
       0x2, 0x1b7c, 0x1b7d, 0x7, 0xe5, 0x2, 0x2, 0x1b7d, 0x1b7f, 0x9, 0x60, 
       0x2, 0x2, 0x1b7e, 0x1b7c, 0x3, 0x2, 0x2, 0x2, 0x1b7e, 0x1b7f, 0x3, 
       0x2, 0x2, 0x2, 0x1b7f, 0x1b81, 0x3, 0x2, 0x2, 0x2, 0x1b80, 0x1b82, 
       0x5, 0x3da, 0x1ee, 0x2, 0x1b81, 0x1b80, 0x3, 0x2, 0x2, 0x2, 0x1b81, 
       0x1b82, 0x3, 0x2, 0x2, 0x2, 0x1b82, 0x1b83, 0x3, 0x2, 0x2, 0x2, 0x1b83, 
       0x1b84, 0x5, 0x3d6, 0x1ec, 0x2, 0x1b84, 0x1b86, 0x3, 0x2, 0x2, 0x2, 
       0x1b85, 0x1b59, 0x3, 0x2, 0x2, 0x2, 0x1b85, 0x1b5d, 0x3, 0x2, 0x2, 
       0x2, 0x1b85, 0x1b61, 0x3, 0x2, 0x2, 0x2, 0x1b85, 0x1b6d, 0x3, 0x2, 
       0x2, 0x2, 0x1b85, 0x1b76, 0x3, 0x2, 0x2, 0x2, 0x1b86, 0x3d5, 0x3, 
       0x2, 0x2, 0x2, 0x1b87, 0x1b8a, 0x7, 0x1c2, 0x2, 0x2, 0x1b88, 0x1b8b, 
       0x5, 0x33e, 0x1a0, 0x2, 0x1b89, 0x1b8b, 0x5, 0x3c4, 0x1e3, 0x2, 0x1b8a, 
       0x1b88, 0x3, 0x2, 0x2, 0x2, 0x1b8a, 0x1b89, 0x3, 0x2, 0x2, 0x2, 0x1b8b, 
       0x3d7, 0x3, 0x2, 0x2, 0x2, 0x1b8c, 0x1b8d, 0x7, 0x301, 0x2, 0x2, 
       0x1b8d, 0x1b90, 0x9, 0x61, 0x2, 0x2, 0x1b8e, 0x1b8f, 0x7, 0x301, 
       0x2, 0x2, 0x1b8f, 0x1b91, 0x5, 0x3a6, 0x1d4, 0x2, 0x1b90, 0x1b8e, 
       0x3, 0x2, 0x2, 0x2, 0x1b90, 0x1b91, 0x3, 0x2, 0x2, 0x2, 0x1b91, 0x3d9, 
       0x3, 0x2, 0x2, 0x2, 0x1b92, 0x1b93, 0x9, 0x62, 0x2, 0x2, 0x1b93, 
       0x1b94, 0x7, 0x1a7, 0x2, 0x2, 0x1b94, 0x3db, 0x3, 0x2, 0x2, 0x2, 
       0x1b95, 0x1b96, 0x7, 0xe0, 0x2, 0x2, 0x1b96, 0x1b9d, 0x7, 0x2b3, 
       0x2, 0x2, 0x1b97, 0x1b9d, 0x7, 0x1ea, 0x2, 0x2, 0x1b98, 0x1b9d, 0x7, 
       0xd0, 0x2, 0x2, 0x1b99, 0x1b9d, 0x7, 0x178, 0x2, 0x2, 0x1b9a, 0x1b9d, 
       0x7, 0xcc, 0x2, 0x2, 0x1b9b, 0x1b9d, 0x7, 0x4f, 0x2, 0x2, 0x1b9c, 
       0x1b95, 0x3, 0x2, 0x2, 0x2, 0x1b9c, 0x1b97, 0x3, 0x2, 0x2, 0x2, 0x1b9c, 
       0x1b98, 0x3, 0x2, 0x2, 0x2, 0x1b9c, 0x1b99, 0x3, 0x2, 0x2, 0x2, 0x1b9c, 
       0x1b9a, 0x3, 0x2, 0x2, 0x2, 0x1b9c, 0x1b9b, 0x3, 0x2, 0x2, 0x2, 0x1b9d, 
       0x3dd, 0x3, 0x2, 0x2, 0x2, 0x1b9e, 0x1b9f, 0x9, 0x63, 0x2, 0x2, 0x1b9f, 
       0x3df, 0x3, 0x2, 0x2, 0x2, 0x1ba0, 0x1ba1, 0x7, 0x9, 0x2, 0x2, 0x1ba1, 
       0x1ba2, 0x7, 0x2fb, 0x2, 0x2, 0x1ba2, 0x1ba3, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1ba3, 0x1ba4, 0x7, 0x2c, 0x2, 0x2, 0x1ba4, 0x1ba5, 0x5, 0x41a, 
       0x20e, 0x2, 0x1ba5, 0x1ba6, 0x7, 0x2fc, 0x2, 0x2, 0x1ba6, 0x3e1, 
       0x3, 0x2, 0x2, 0x2, 0x1ba7, 0x1ba8, 0x7, 0x76, 0x2, 0x2, 0x1ba8, 
       0x1ba9, 0x7, 0x2fb, 0x2, 0x2, 0x1ba9, 0x1baa, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1baa, 0x1bab, 0x7, 0x301, 0x2, 0x2, 0x1bab, 0x1bac, 0x5, 0x3e4, 
       0x1f3, 0x2, 0x1bac, 0x1bad, 0x7, 0x2fc, 0x2, 0x2, 0x1bad, 0x1bb6, 
       0x3, 0x2, 0x2, 0x2, 0x1bae, 0x1baf, 0x7, 0x76, 0x2, 0x2, 0x1baf, 
       0x1bb0, 0x7, 0x2fb, 0x2, 0x2, 0x1bb0, 0x1bb1, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1bb1, 0x1bb2, 0x7, 0x2b9, 0x2, 0x2, 0x1bb2, 0x1bb3, 0x5, 0x354, 
       0x1ab, 0x2, 0x1bb3, 0x1bb4, 0x7, 0x2fc, 0x2, 0x2, 0x1bb4, 0x1bb6, 
       0x3, 0x2, 0x2, 0x2, 0x1bb5, 0x1ba7, 0x3, 0x2, 0x2, 0x2, 0x1bb5, 0x1bae, 
       0x3, 0x2, 0x2, 0x2, 0x1bb6, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x1bb7, 0x1bb9, 
       0x7, 0x3b, 0x2, 0x2, 0x1bb8, 0x1bba, 0x5, 0x442, 0x222, 0x2, 0x1bb9, 
       0x1bb8, 0x3, 0x2, 0x2, 0x2, 0x1bb9, 0x1bba, 0x3, 0x2, 0x2, 0x2, 0x1bba, 
       0x1be5, 0x3, 0x2, 0x2, 0x2, 0x1bbb, 0x1bbd, 0x7, 0x51, 0x2, 0x2, 
       0x1bbc, 0x1bbe, 0x5, 0x442, 0x222, 0x2, 0x1bbd, 0x1bbc, 0x3, 0x2, 
       0x2, 0x2, 0x1bbd, 0x1bbe, 0x3, 0x2, 0x2, 0x2, 0x1bbe, 0x1bc0, 0x3, 
       0x2, 0x2, 0x2, 0x1bbf, 0x1bc1, 0x5, 0x428, 0x215, 0x2, 0x1bc0, 0x1bbf, 
       0x3, 0x2, 0x2, 0x2, 0x1bc0, 0x1bc1, 0x3, 0x2, 0x2, 0x2, 0x1bc1, 0x1be5, 
       0x3, 0x2, 0x2, 0x2, 0x1bc2, 0x1bc4, 0x5, 0x3e6, 0x1f4, 0x2, 0x1bc3, 
       0x1bc5, 0x5, 0x442, 0x222, 0x2, 0x1bc4, 0x1bc3, 0x3, 0x2, 0x2, 0x2, 
       0x1bc4, 0x1bc5, 0x3, 0x2, 0x2, 0x2, 0x1bc5, 0x1be5, 0x3, 0x2, 0x2, 
       0x2, 0x1bc6, 0x1bc8, 0x7, 0x249, 0x2, 0x2, 0x1bc7, 0x1bc9, 0x7, 0x117, 
       0x2, 0x2, 0x1bc8, 0x1bc7, 0x3, 0x2, 0x2, 0x2, 0x1bc8, 0x1bc9, 0x3, 
       0x2, 0x2, 0x2, 0x1bc9, 0x1be5, 0x3, 0x2, 0x2, 0x2, 0x1bca, 0x1bcc, 
       0x7, 0x2b0, 0x2, 0x2, 0x1bcb, 0x1bcd, 0x7, 0x117, 0x2, 0x2, 0x1bcc, 
       0x1bcb, 0x3, 0x2, 0x2, 0x2, 0x1bcc, 0x1bcd, 0x3, 0x2, 0x2, 0x2, 0x1bcd, 
       0x1be5, 0x3, 0x2, 0x2, 0x2, 0x1bce, 0x1be5, 0x7, 0x87, 0x2, 0x2, 
       0x1bcf, 0x1bd1, 0x7, 0x293, 0x2, 0x2, 0x1bd0, 0x1bd2, 0x5, 0x426, 
       0x214, 0x2, 0x1bd1, 0x1bd0, 0x3, 0x2, 0x2, 0x2, 0x1bd1, 0x1bd2, 0x3, 
       0x2, 0x2, 0x2, 0x1bd2, 0x1be5, 0x3, 0x2, 0x2, 0x2, 0x1bd3, 0x1bd5, 
       0x7, 0x88, 0x2, 0x2, 0x1bd4, 0x1bd6, 0x5, 0x426, 0x214, 0x2, 0x1bd5, 
       0x1bd4, 0x3, 0x2, 0x2, 0x2, 0x1bd5, 0x1bd6, 0x3, 0x2, 0x2, 0x2, 0x1bd6, 
       0x1be5, 0x3, 0x2, 0x2, 0x2, 0x1bd7, 0x1bda, 0x7, 0x90, 0x2, 0x2, 
       0x1bd8, 0x1bdb, 0x5, 0x442, 0x222, 0x2, 0x1bd9, 0x1bdb, 0x5, 0x424, 
       0x213, 0x2, 0x1bda, 0x1bd8, 0x3, 0x2, 0x2, 0x2, 0x1bda, 0x1bd9, 0x3, 
       0x2, 0x2, 0x2, 0x1bda, 0x1bdb, 0x3, 0x2, 0x2, 0x2, 0x1bdb, 0x1be5, 
       0x3, 0x2, 0x2, 0x2, 0x1bdc, 0x1be5, 0x7, 0x12c, 0x2, 0x2, 0x1bdd, 
       0x1be5, 0x7, 0x1f2, 0x2, 0x2, 0x1bde, 0x1bdf, 0x7, 0xa7, 0x2, 0x2, 
       0x1bdf, 0x1be5, 0x7, 0x1da, 0x2, 0x2, 0x1be0, 0x1be2, 0x7, 0xda, 
       0x2, 0x2, 0x1be1, 0x1be3, 0x5, 0x424, 0x213, 0x2, 0x1be2, 0x1be1, 
       0x3, 0x2, 0x2, 0x2, 0x1be2, 0x1be3, 0x3, 0x2, 0x2, 0x2, 0x1be3, 0x1be5, 
       0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bb7, 0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bbb, 
       0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bc2, 0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bc6, 
       0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bca, 0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bce, 
       0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bcf, 0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bd3, 
       0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bd7, 0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bdc, 
       0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bdd, 0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1bde, 
       0x3, 0x2, 0x2, 0x2, 0x1be4, 0x1be0, 0x3, 0x2, 0x2, 0x2, 0x1be5, 0x3e5, 
       0x3, 0x2, 0x2, 0x2, 0x1be6, 0x1bea, 0x7, 0x195, 0x2, 0x2, 0x1be7, 
       0x1be8, 0x7, 0x193, 0x2, 0x2, 0x1be8, 0x1bea, 0x7, 0x51, 0x2, 0x2, 
       0x1be9, 0x1be6, 0x3, 0x2, 0x2, 0x2, 0x1be9, 0x1be7, 0x3, 0x2, 0x2, 
       0x2, 0x1bea, 0x3e7, 0x3, 0x2, 0x2, 0x2, 0x1beb, 0x1bec, 0x7, 0xa, 
       0x2, 0x2, 0x1bec, 0x1bed, 0x7, 0x2fb, 0x2, 0x2, 0x1bed, 0x1bee, 0x5, 
       0x3a6, 0x1d4, 0x2, 0x1bee, 0x1bef, 0x7, 0x10a, 0x2, 0x2, 0x1bef, 
       0x1bf0, 0x5, 0x3a6, 0x1d4, 0x2, 0x1bf0, 0x1bf1, 0x7, 0x2fc, 0x2, 
       0x2, 0x1bf1, 0x3e9, 0x3, 0x2, 0x2, 0x2, 0x1bf2, 0x1bf3, 0x9, 0x64, 
       0x2, 0x2, 0x1bf3, 0x1bf4, 0x7, 0x2fb, 0x2, 0x2, 0x1bf4, 0x1bf5, 0x5, 
       0x3a6, 0x1d4, 0x2, 0x1bf5, 0x1bf6, 0x7, 0xe5, 0x2, 0x2, 0x1bf6, 0x1bf9, 
       0x7, 0x313, 0x2, 0x2, 0x1bf7, 0x1bf8, 0x7, 0xe0, 0x2, 0x2, 0x1bf8, 
       0x1bfa, 0x7, 0x313, 0x2, 0x2, 0x1bf9, 0x1bf7, 0x3, 0x2, 0x2, 0x2, 
       0x1bf9, 0x1bfa, 0x3, 0x2, 0x2, 0x2, 0x1bfa, 0x1bfb, 0x3, 0x2, 0x2, 
       0x2, 0x1bfb, 0x1bfc, 0x7, 0x2fc, 0x2, 0x2, 0x1bfc, 0x1c09, 0x3, 0x2, 
       0x2, 0x2, 0x1bfd, 0x1bfe, 0x9, 0x64, 0x2, 0x2, 0x1bfe, 0x1bff, 0x7, 
       0x2fb, 0x2, 0x2, 0x1bff, 0x1c00, 0x5, 0x3a6, 0x1d4, 0x2, 0x1c00, 
       0x1c01, 0x7, 0x301, 0x2, 0x2, 0x1c01, 0x1c04, 0x7, 0x313, 0x2, 0x2, 
       0x1c02, 0x1c03, 0x7, 0x301, 0x2, 0x2, 0x1c03, 0x1c05, 0x7, 0x313, 
       0x2, 0x2, 0x1c04, 0x1c02, 0x3, 0x2, 0x2, 0x2, 0x1c04, 0x1c05, 0x3, 
       0x2, 0x2, 0x2, 0x1c05, 0x1c06, 0x3, 0x2, 0x2, 0x2, 0x1c06, 0x1c07, 
       0x7, 0x2fc, 0x2, 0x2, 0x1c07, 0x1c09, 0x3, 0x2, 0x2, 0x2, 0x1c08, 
       0x1bf2, 0x3, 0x2, 0x2, 0x2, 0x1c08, 0x1bfd, 0x3, 0x2, 0x2, 0x2, 0x1c09, 
       0x3eb, 0x3, 0x2, 0x2, 0x2, 0x1c0a, 0x1c0b, 0x7, 0xd, 0x2, 0x2, 0x1c0b, 
       0x1c0c, 0x7, 0x2fb, 0x2, 0x2, 0x1c0c, 0x1c0d, 0x5, 0x33e, 0x1a0, 
       0x2, 0x1c0d, 0x1c0e, 0x7, 0xe5, 0x2, 0x2, 0x1c0e, 0x1c0f, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1c0f, 0x1c10, 0x7, 0x2fc, 0x2, 0x2, 0x1c10, 0x3ed, 
       0x3, 0x2, 0x2, 0x2, 0x1c11, 0x1c12, 0x7, 0x51, 0x2, 0x2, 0x1c12, 
       0x1c13, 0x7, 0x2fb, 0x2, 0x2, 0x1c13, 0x1c18, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1c14, 0x1c15, 0x7, 0x301, 0x2, 0x2, 0x1c15, 0x1c17, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1c16, 0x1c14, 0x3, 0x2, 0x2, 0x2, 0x1c17, 0x1c1a, 0x3, 
       0x2, 0x2, 0x2, 0x1c18, 0x1c16, 0x3, 0x2, 0x2, 0x2, 0x1c18, 0x1c19, 
       0x3, 0x2, 0x2, 0x2, 0x1c19, 0x1c1d, 0x3, 0x2, 0x2, 0x2, 0x1c1a, 0x1c18, 
       0x3, 0x2, 0x2, 0x2, 0x1c1b, 0x1c1c, 0x7, 0x2b9, 0x2, 0x2, 0x1c1c, 
       0x1c1e, 0x5, 0x354, 0x1ab, 0x2, 0x1c1d, 0x1c1b, 0x3, 0x2, 0x2, 0x2, 
       0x1c1d, 0x1c1e, 0x3, 0x2, 0x2, 0x2, 0x1c1e, 0x1c1f, 0x3, 0x2, 0x2, 
       0x2, 0x1c1f, 0x1c20, 0x7, 0x2fc, 0x2, 0x2, 0x1c20, 0x3ef, 0x3, 0x2, 
       0x2, 0x2, 0x1c21, 0x1c22, 0x7, 0xe, 0x2, 0x2, 0x1c22, 0x1c23, 0x7, 
       0x2fb, 0x2, 0x2, 0x1c23, 0x1c24, 0x9, 0x65, 0x2, 0x2, 0x1c24, 0x1c25, 
       0x5, 0x32c, 0x197, 0x2, 0x1c25, 0x1c26, 0x7, 0xe5, 0x2, 0x2, 0x1c26, 
       0x1c27, 0x5, 0x32c, 0x197, 0x2, 0x1c27, 0x1c28, 0x7, 0x2fc, 0x2, 
       0x2, 0x1c28, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x1c29, 0x1c2a, 0x7, 0x2bf, 
       0x2, 0x2, 0x1c2a, 0x1c2b, 0x7, 0x2fb, 0x2, 0x2, 0x1c2b, 0x1c2c, 0x5, 
       0x3b8, 0x1dd, 0x2, 0x1c2c, 0x1c2d, 0x7, 0x2fc, 0x2, 0x2, 0x1c2d, 
       0x3f3, 0x3, 0x2, 0x2, 0x2, 0x1c2e, 0x1c2f, 0x7, 0x2cc, 0x2, 0x2, 
       0x1c2f, 0x1c30, 0x7, 0x2fb, 0x2, 0x2, 0x1c30, 0x1c33, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1c31, 0x1c32, 0x7, 0x2c, 0x2, 0x2, 0x1c32, 0x1c34, 
       0x5, 0x41a, 0x20e, 0x2, 0x1c33, 0x1c31, 0x3, 0x2, 0x2, 0x2, 0x1c33, 
       0x1c34, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c36, 0x3, 0x2, 0x2, 0x2, 0x1c35, 
       0x1c37, 0x5, 0x3f6, 0x1fc, 0x2, 0x1c36, 0x1c35, 0x3, 0x2, 0x2, 0x2, 
       0x1c36, 0x1c37, 0x3, 0x2, 0x2, 0x2, 0x1c37, 0x1c38, 0x3, 0x2, 0x2, 
       0x2, 0x1c38, 0x1c39, 0x7, 0x2fc, 0x2, 0x2, 0x1c39, 0x3f5, 0x3, 0x2, 
       0x2, 0x2, 0x1c3a, 0x1c46, 0x7, 0x13e, 0x2, 0x2, 0x1c3b, 0x1c40, 0x5, 
       0x3f8, 0x1fd, 0x2, 0x1c3c, 0x1c3d, 0x7, 0x301, 0x2, 0x2, 0x1c3d, 
       0x1c3f, 0x5, 0x3f8, 0x1fd, 0x2, 0x1c3e, 0x1c3c, 0x3, 0x2, 0x2, 0x2, 
       0x1c3f, 0x1c42, 0x3, 0x2, 0x2, 0x2, 0x1c40, 0x1c3e, 0x3, 0x2, 0x2, 
       0x2, 0x1c40, 0x1c41, 0x3, 0x2, 0x2, 0x2, 0x1c41, 0x1c47, 0x3, 0x2, 
       0x2, 0x2, 0x1c42, 0x1c40, 0x3, 0x2, 0x2, 0x2, 0x1c43, 0x1c44, 0x7, 
       0x313, 0x2, 0x2, 0x1c44, 0x1c45, 0x7, 0x2ec, 0x2, 0x2, 0x1c45, 0x1c47, 
       0x7, 0x313, 0x2, 0x2, 0x1c46, 0x1c3b, 0x3, 0x2, 0x2, 0x2, 0x1c46, 
       0x1c43, 0x3, 0x2, 0x2, 0x2, 0x1c47, 0x3f7, 0x3, 0x2, 0x2, 0x2, 0x1c48, 
       0x1c4a, 0x7, 0x313, 0x2, 0x2, 0x1c49, 0x1c4b, 0x5, 0x43e, 0x220, 
       0x2, 0x1c4a, 0x1c49, 0x3, 0x2, 0x2, 0x2, 0x1c4a, 0x1c4b, 0x3, 0x2, 
       0x2, 0x2, 0x1c4b, 0x1c4d, 0x3, 0x2, 0x2, 0x2, 0x1c4c, 0x1c4e, 0x7, 
       0x221, 0x2, 0x2, 0x1c4d, 0x1c4c, 0x3, 0x2, 0x2, 0x2, 0x1c4d, 0x1c4e, 
       0x3, 0x2, 0x2, 0x2, 0x1c4e, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x1c4f, 0x1c52, 
       0x5, 0x3fe, 0x200, 0x2, 0x1c50, 0x1c52, 0x5, 0x3fc, 0x1ff, 0x2, 0x1c51, 
       0x1c4f, 0x3, 0x2, 0x2, 0x2, 0x1c51, 0x1c50, 0x3, 0x2, 0x2, 0x2, 0x1c52, 
       0x3fb, 0x3, 0x2, 0x2, 0x2, 0x1c53, 0x1c61, 0x7, 0x7d, 0x2, 0x2, 0x1c54, 
       0x1c5a, 0x7, 0x7e, 0x2, 0x2, 0x1c55, 0x1c57, 0x7, 0x2fb, 0x2, 0x2, 
       0x1c56, 0x1c58, 0x7, 0x313, 0x2, 0x2, 0x1c57, 0x1c56, 0x3, 0x2, 0x2, 
       0x2, 0x1c57, 0x1c58, 0x3, 0x2, 0x2, 0x2, 0x1c58, 0x1c59, 0x3, 0x2, 
       0x2, 0x2, 0x1c59, 0x1c5b, 0x7, 0x2fc, 0x2, 0x2, 0x1c5a, 0x1c55, 0x3, 
       0x2, 0x2, 0x2, 0x1c5a, 0x1c5b, 0x3, 0x2, 0x2, 0x2, 0x1c5b, 0x1c61, 
       0x3, 0x2, 0x2, 0x2, 0x1c5c, 0x1c61, 0x7, 0x7f, 0x2, 0x2, 0x1c5d, 
       0x1c61, 0x7, 0xf, 0x2, 0x2, 0x1c5e, 0x1c61, 0x7, 0x147, 0x2, 0x2, 
       0x1c5f, 0x1c61, 0x7, 0x148, 0x2, 0x2, 0x1c60, 0x1c53, 0x3, 0x2, 0x2, 
       0x2, 0x1c60, 0x1c54, 0x3, 0x2, 0x2, 0x2, 0x1c60, 0x1c5c, 0x3, 0x2, 
       0x2, 0x2, 0x1c60, 0x1c5d, 0x3, 0x2, 0x2, 0x2, 0x1c60, 0x1c5e, 0x3, 
       0x2, 0x2, 0x2, 0x1c60, 0x1c5f, 0x3, 0x2, 0x2, 0x2, 0x1c61, 0x3fd, 
       0x3, 0x2, 0x2, 0x2, 0x1c62, 0x1c63, 0x5, 0x400, 0x201, 0x2, 0x1c63, 
       0x1c6d, 0x7, 0x2fb, 0x2, 0x2, 0x1c64, 0x1c69, 0x5, 0x3a6, 0x1d4, 
       0x2, 0x1c65, 0x1c66, 0x7, 0x301, 0x2, 0x2, 0x1c66, 0x1c68, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1c67, 0x1c65, 0x3, 0x2, 0x2, 0x2, 0x1c68, 0x1c6b, 0x3, 
       0x2, 0x2, 0x2, 0x1c69, 0x1c67, 0x3, 0x2, 0x2, 0x2, 0x1c69, 0x1c6a, 
       0x3, 0x2, 0x2, 0x2, 0x1c6a, 0x1c6e, 0x3, 0x2, 0x2, 0x2, 0x1c6b, 0x1c69, 
       0x3, 0x2, 0x2, 0x2, 0x1c6c, 0x1c6e, 0x7, 0x2ed, 0x2, 0x2, 0x1c6d, 
       0x1c64, 0x3, 0x2, 0x2, 0x2, 0x1c6d, 0x1c6c, 0x3, 0x2, 0x2, 0x2, 0x1c6d, 
       0x1c6e, 0x3, 0x2, 0x2, 0x2, 0x1c6e, 0x1c6f, 0x3, 0x2, 0x2, 0x2, 0x1c6f, 
       0x1c70, 0x7, 0x2fc, 0x2, 0x2, 0x1c70, 0x3ff, 0x3, 0x2, 0x2, 0x2, 
       0x1c71, 0x1c8c, 0x7, 0x106, 0x2, 0x2, 0x1c72, 0x1c8c, 0x7, 0x147, 
       0x2, 0x2, 0x1c73, 0x1c8c, 0x7, 0x148, 0x2, 0x2, 0x1c74, 0x1c8c, 0x7, 
       0x208, 0x2, 0x2, 0x1c75, 0x1c8c, 0x7, 0x11e, 0x2, 0x2, 0x1c76, 0x1c8c, 
       0x7, 0x187, 0x2, 0x2, 0x1c77, 0x1c8c, 0x7, 0x84, 0x2, 0x2, 0x1c78, 
       0x1c8c, 0x7, 0x13c, 0x2, 0x2, 0x1c79, 0x1c8c, 0x7, 0x223, 0x2, 0x2, 
       0x1c7a, 0x1c8c, 0x7, 0x87, 0x2, 0x2, 0x1c7b, 0x1c8c, 0x7, 0x89, 0x2, 
       0x2, 0x1c7c, 0x1c8c, 0x7, 0xeb, 0x2, 0x2, 0x1c7d, 0x1c8c, 0x7, 0xed, 
       0x2, 0x2, 0x1c7e, 0x1c8c, 0x7, 0x143, 0x2, 0x2, 0x1c7f, 0x1c8c, 0x7, 
       0x18c, 0x2, 0x2, 0x1c80, 0x1c8c, 0x7, 0x18d, 0x2, 0x2, 0x1c81, 0x1c8c, 
       0x7, 0x18e, 0x2, 0x2, 0x1c82, 0x1c8c, 0x7, 0x1d5, 0x2, 0x2, 0x1c83, 
       0x1c8c, 0x7, 0x1d6, 0x2, 0x2, 0x1c84, 0x1c8c, 0x7, 0x293, 0x2, 0x2, 
       0x1c85, 0x1c8c, 0x7, 0x294, 0x2, 0x2, 0x1c86, 0x1c8c, 0x7, 0x295, 
       0x2, 0x2, 0x1c87, 0x1c8c, 0x7, 0x296, 0x2, 0x2, 0x1c88, 0x1c8c, 0x7, 
       0x87, 0x2, 0x2, 0x1c89, 0x1c8c, 0x7, 0x7f, 0x2, 0x2, 0x1c8a, 0x1c8c, 
       0x5, 0x33e, 0x1a0, 0x2, 0x1c8b, 0x1c71, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c72, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c73, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c74, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c75, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c76, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c77, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c78, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c79, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c7a, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c7b, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c7c, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c7d, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c7e, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c7f, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c80, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c81, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c82, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c83, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c84, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c85, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c86, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c87, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c88, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 0x1c89, 0x3, 0x2, 0x2, 0x2, 0x1c8b, 
       0x1c8a, 0x3, 0x2, 0x2, 0x2, 0x1c8c, 0x401, 0x3, 0x2, 0x2, 0x2, 0x1c8d, 
       0x1c93, 0x7, 0x170, 0x2, 0x2, 0x1c8e, 0x1c94, 0x5, 0x3b8, 0x1dd, 
       0x2, 0x1c8f, 0x1c90, 0x7, 0x2fb, 0x2, 0x2, 0x1c90, 0x1c91, 0x5, 0x3b8, 
       0x1dd, 0x2, 0x1c91, 0x1c92, 0x7, 0x2fc, 0x2, 0x2, 0x1c92, 0x1c94, 
       0x3, 0x2, 0x2, 0x2, 0x1c93, 0x1c8e, 0x3, 0x2, 0x2, 0x2, 0x1c93, 0x1c8f, 
       0x3, 0x2, 0x2, 0x2, 0x1c94, 0x1c95, 0x3, 0x2, 0x2, 0x2, 0x1c95, 0x1c96, 
       0x7, 0x22, 0x2, 0x2, 0x1c96, 0x1c97, 0x7, 0x2fb, 0x2, 0x2, 0x1c97, 
       0x1c99, 0x5, 0x3a6, 0x1d4, 0x2, 0x1c98, 0x1c9a, 0x5, 0x404, 0x203, 
       0x2, 0x1c99, 0x1c98, 0x3, 0x2, 0x2, 0x2, 0x1c99, 0x1c9a, 0x3, 0x2, 
       0x2, 0x2, 0x1c9a, 0x1c9b, 0x3, 0x2, 0x2, 0x2, 0x1c9b, 0x1c9c, 0x7, 
       0x2fc, 0x2, 0x2, 0x1c9c, 0x403, 0x3, 0x2, 0x2, 0x2, 0x1c9d, 0x1c9e, 
       0x7, 0x10a, 0x2, 0x2, 0x1c9e, 0x1c9f, 0x7, 0x194, 0x2, 0x2, 0x1c9f, 
       0x1ca0, 0x7, 0x134, 0x2, 0x2, 0x1ca0, 0x1caf, 0x7, 0x188, 0x2, 0x2, 
       0x1ca1, 0x1ca2, 0x7, 0x10a, 0x2, 0x2, 0x1ca2, 0x1ca3, 0x7, 0x194, 
       0x2, 0x2, 0x1ca3, 0x1ca4, 0x7, 0x134, 0x2, 0x2, 0x1ca4, 0x1ca5, 0x7, 
       0x188, 0x2, 0x2, 0x1ca5, 0x1ca6, 0x7, 0x2d1, 0x2, 0x2, 0x1ca6, 0x1ca7, 
       0x7, 0x1e9, 0x2, 0x2, 0x1ca7, 0x1caf, 0x7, 0xc8, 0x2, 0x2, 0x1ca8, 
       0x1ca9, 0x7, 0x10a, 0x2, 0x2, 0x1ca9, 0x1caa, 0x7, 0x41, 0x2, 0x2, 
       0x1caa, 0x1caf, 0x7, 0x188, 0x2, 0x2, 0x1cab, 0x1cac, 0x7, 0x2d1, 
       0x2, 0x2, 0x1cac, 0x1cad, 0x7, 0x1e9, 0x2, 0x2, 0x1cad, 0x1caf, 0x7, 
       0xc8, 0x2, 0x2, 0x1cae, 0x1c9d, 0x3, 0x2, 0x2, 0x2, 0x1cae, 0x1ca1, 
       0x3, 0x2, 0x2, 0x2, 0x1cae, 0x1ca8, 0x3, 0x2, 0x2, 0x2, 0x1cae, 0x1cab, 
       0x3, 0x2, 0x2, 0x2, 0x1caf, 0x405, 0x3, 0x2, 0x2, 0x2, 0x1cb0, 0x1cb2, 
       0x7, 0x4b, 0x2, 0x2, 0x1cb1, 0x1cb3, 0x5, 0x3b4, 0x1db, 0x2, 0x1cb2, 
       0x1cb1, 0x3, 0x2, 0x2, 0x2, 0x1cb2, 0x1cb3, 0x3, 0x2, 0x2, 0x2, 0x1cb3, 
       0x1cb5, 0x3, 0x2, 0x2, 0x2, 0x1cb4, 0x1cb6, 0x5, 0x40c, 0x207, 0x2, 
       0x1cb5, 0x1cb4, 0x3, 0x2, 0x2, 0x2, 0x1cb6, 0x1cb7, 0x3, 0x2, 0x2, 
       0x2, 0x1cb7, 0x1cb5, 0x3, 0x2, 0x2, 0x2, 0x1cb7, 0x1cb8, 0x3, 0x2, 
       0x2, 0x2, 0x1cb8, 0x1cba, 0x3, 0x2, 0x2, 0x2, 0x1cb9, 0x1cbb, 0x5, 
       0x40e, 0x208, 0x2, 0x1cba, 0x1cb9, 0x3, 0x2, 0x2, 0x2, 0x1cba, 0x1cbb, 
       0x3, 0x2, 0x2, 0x2, 0x1cbb, 0x1cbc, 0x3, 0x2, 0x2, 0x2, 0x1cbc, 0x1cbd, 
       0x7, 0xb4, 0x2, 0x2, 0x1cbd, 0x407, 0x3, 0x2, 0x2, 0x2, 0x1cbe, 0x1cbf, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x1cbf, 0x409, 0x3, 0x2, 0x2, 0x2, 0x1cc0, 
       0x1cc1, 0x7, 0x313, 0x2, 0x2, 0x1cc1, 0x40b, 0x3, 0x2, 0x2, 0x2, 
       0x1cc2, 0x1cc3, 0x7, 0x2cd, 0x2, 0x2, 0x1cc3, 0x1cc4, 0x5, 0x3a6, 
       0x1d4, 0x2, 0x1cc4, 0x1cc5, 0x7, 0x290, 0x2, 0x2, 0x1cc5, 0x1cc6, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x1cc6, 0x40d, 0x3, 0x2, 0x2, 0x2, 0x1cc7, 
       0x1cc8, 0x7, 0xae, 0x2, 0x2, 0x1cc8, 0x1cc9, 0x5, 0x3a6, 0x1d4, 0x2, 
       0x1cc9, 0x40f, 0x3, 0x2, 0x2, 0x2, 0x1cca, 0x1ccb, 0x7, 0x11e, 0x2, 
       0x2, 0x1ccb, 0x1ccc, 0x5, 0x412, 0x20a, 0x2, 0x1ccc, 0x411, 0x3, 
       0x2, 0x2, 0x2, 0x1ccd, 0x1cce, 0x5, 0x3a6, 0x1d4, 0x2, 0x1cce, 0x1ccf, 
       0x5, 0x414, 0x20b, 0x2, 0x1ccf, 0x413, 0x3, 0x2, 0x2, 0x2, 0x1cd0, 
       0x1cd1, 0x9, 0x66, 0x2, 0x2, 0x1cd1, 0x415, 0x3, 0x2, 0x2, 0x2, 0x1cd2, 
       0x1cd3, 0x7, 0x1bb, 0x2, 0x2, 0x1cd3, 0x1cd4, 0x7, 0x45, 0x2, 0x2, 
       0x1cd4, 0x1cd9, 0x5, 0x418, 0x20d, 0x2, 0x1cd5, 0x1cd6, 0x7, 0x301, 
       0x2, 0x2, 0x1cd6, 0x1cd8, 0x5, 0x418, 0x20d, 0x2, 0x1cd7, 0x1cd5, 
       0x3, 0x2, 0x2, 0x2, 0x1cd8, 0x1cdb, 0x3, 0x2, 0x2, 0x2, 0x1cd9, 0x1cd7, 
       0x3, 0x2, 0x2, 0x2, 0x1cd9, 0x1cda, 0x3, 0x2, 0x2, 0x2, 0x1cda, 0x417, 
       0x3, 0x2, 0x2, 0x2, 0x1cdb, 0x1cd9, 0x3, 0x2, 0x2, 0x2, 0x1cdc, 0x1cdf, 
       0x5, 0x330, 0x199, 0x2, 0x1cdd, 0x1cdf, 0x5, 0x3a6, 0x1d4, 0x2, 0x1cde, 
       0x1cdc, 0x3, 0x2, 0x2, 0x2, 0x1cde, 0x1cdd, 0x3, 0x2, 0x2, 0x2, 0x1cdf, 
       0x1ce1, 0x3, 0x2, 0x2, 0x2, 0x1ce0, 0x1ce2, 0x5, 0x43e, 0x220, 0x2, 
       0x1ce1, 0x1ce0, 0x3, 0x2, 0x2, 0x2, 0x1ce1, 0x1ce2, 0x3, 0x2, 0x2, 
       0x2, 0x1ce2, 0x419, 0x3, 0x2, 0x2, 0x2, 0x1ce3, 0x1ce5, 0x9, 0x67, 
       0x2, 0x2, 0x1ce4, 0x1ce6, 0x5, 0x442, 0x222, 0x2, 0x1ce5, 0x1ce4, 
       0x3, 0x2, 0x2, 0x2, 0x1ce5, 0x1ce6, 0x3, 0x2, 0x2, 0x2, 0x1ce6, 0x1ce8, 
       0x3, 0x2, 0x2, 0x2, 0x1ce7, 0x1ce9, 0x5, 0x422, 0x212, 0x2, 0x1ce8, 
       0x1ce7, 0x3, 0x2, 0x2, 0x2, 0x1ce8, 0x1ce9, 0x3, 0x2, 0x2, 0x2, 0x1ce9, 
       0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1cea, 0x1cf0, 0x7, 0x1f2, 0x2, 0x2, 
       0x1ceb, 0x1ced, 0x7, 0xa7, 0x2, 0x2, 0x1cec, 0x1cee, 0x7, 0x1da, 
       0x2, 0x2, 0x1ced, 0x1cec, 0x3, 0x2, 0x2, 0x2, 0x1ced, 0x1cee, 0x3, 
       0x2, 0x2, 0x2, 0x1cee, 0x1cf0, 0x3, 0x2, 0x2, 0x2, 0x1cef, 0x1cea, 
       0x3, 0x2, 0x2, 0x2, 0x1cef, 0x1ceb, 0x3, 0x2, 0x2, 0x2, 0x1cf0, 0x1cf2, 
       0x3, 0x2, 0x2, 0x2, 0x1cf1, 0x1cf3, 0x5, 0x424, 0x213, 0x2, 0x1cf2, 
       0x1cf1, 0x3, 0x2, 0x2, 0x2, 0x1cf2, 0x1cf3, 0x3, 0x2, 0x2, 0x2, 0x1cf3, 
       0x1cf5, 0x3, 0x2, 0x2, 0x2, 0x1cf4, 0x1cf6, 0x5, 0x422, 0x212, 0x2, 
       0x1cf5, 0x1cf4, 0x3, 0x2, 0x2, 0x2, 0x1cf5, 0x1cf6, 0x3, 0x2, 0x2, 
       0x2, 0x1cf6, 0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1cf7, 0x1cfa, 0x9, 0x68, 
       0x2, 0x2, 0x1cf8, 0x1cfb, 0x5, 0x442, 0x222, 0x2, 0x1cf9, 0x1cfb, 
       0x5, 0x424, 0x213, 0x2, 0x1cfa, 0x1cf8, 0x3, 0x2, 0x2, 0x2, 0x1cfa, 
       0x1cf9, 0x3, 0x2, 0x2, 0x2, 0x1cfa, 0x1cfb, 0x3, 0x2, 0x2, 0x2, 0x1cfb, 
       0x1cfd, 0x3, 0x2, 0x2, 0x2, 0x1cfc, 0x1cfe, 0x5, 0x422, 0x212, 0x2, 
       0x1cfd, 0x1cfc, 0x3, 0x2, 0x2, 0x2, 0x1cfd, 0x1cfe, 0x3, 0x2, 0x2, 
       0x2, 0x1cfe, 0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1cff, 0x1d01, 0x7, 0x3d, 
       0x2, 0x2, 0x1d00, 0x1d02, 0x5, 0x442, 0x222, 0x2, 0x1d01, 0x1d00, 
       0x3, 0x2, 0x2, 0x2, 0x1d01, 0x1d02, 0x3, 0x2, 0x2, 0x2, 0x1d02, 0x1d7b, 
       0x3, 0x2, 0x2, 0x2, 0x1d03, 0x1d7b, 0x9, 0x69, 0x2, 0x2, 0x1d04, 
       0x1d06, 0x7, 0x51, 0x2, 0x2, 0x1d05, 0x1d07, 0x5, 0x442, 0x222, 0x2, 
       0x1d06, 0x1d05, 0x3, 0x2, 0x2, 0x2, 0x1d06, 0x1d07, 0x3, 0x2, 0x2, 
       0x2, 0x1d07, 0x1d09, 0x3, 0x2, 0x2, 0x2, 0x1d08, 0x1d0a, 0x5, 0x428, 
       0x215, 0x2, 0x1d09, 0x1d08, 0x3, 0x2, 0x2, 0x2, 0x1d09, 0x1d0a, 0x3, 
       0x2, 0x2, 0x2, 0x1d0a, 0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1d0b, 0x1d0f, 
       0x7, 0x195, 0x2, 0x2, 0x1d0c, 0x1d0d, 0x7, 0x193, 0x2, 0x2, 0x1d0d, 
       0x1d0f, 0x7, 0x51, 0x2, 0x2, 0x1d0e, 0x1d0b, 0x3, 0x2, 0x2, 0x2, 
       0x1d0e, 0x1d0c, 0x3, 0x2, 0x2, 0x2, 0x1d0f, 0x1d11, 0x3, 0x2, 0x2, 
       0x2, 0x1d10, 0x1d12, 0x5, 0x442, 0x222, 0x2, 0x1d11, 0x1d10, 0x3, 
       0x2, 0x2, 0x2, 0x1d11, 0x1d12, 0x3, 0x2, 0x2, 0x2, 0x1d12, 0x1d14, 
       0x3, 0x2, 0x2, 0x2, 0x1d13, 0x1d15, 0x7, 0x3b, 0x2, 0x2, 0x1d14, 
       0x1d13, 0x3, 0x2, 0x2, 0x2, 0x1d14, 0x1d15, 0x3, 0x2, 0x2, 0x2, 0x1d15, 
       0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1d16, 0x1d18, 0x7, 0x3b, 0x2, 0x2, 
       0x1d17, 0x1d19, 0x5, 0x442, 0x222, 0x2, 0x1d18, 0x1d17, 0x3, 0x2, 
       0x2, 0x2, 0x1d18, 0x1d19, 0x3, 0x2, 0x2, 0x2, 0x1d19, 0x1d7b, 0x3, 
       0x2, 0x2, 0x2, 0x1d1a, 0x1d1b, 0x7, 0x51, 0x2, 0x2, 0x1d1b, 0x1d1e, 
       0x7, 0x2c4, 0x2, 0x2, 0x1d1c, 0x1d1e, 0x7, 0x2c1, 0x2, 0x2, 0x1d1d, 
       0x1d1a, 0x3, 0x2, 0x2, 0x2, 0x1d1d, 0x1d1c, 0x3, 0x2, 0x2, 0x2, 0x1d1e, 
       0x1d1f, 0x3, 0x2, 0x2, 0x2, 0x1d1f, 0x1d21, 0x5, 0x442, 0x222, 0x2, 
       0x1d20, 0x1d22, 0x5, 0x428, 0x215, 0x2, 0x1d21, 0x1d20, 0x3, 0x2, 
       0x2, 0x2, 0x1d21, 0x1d22, 0x3, 0x2, 0x2, 0x2, 0x1d22, 0x1d7b, 0x3, 
       0x2, 0x2, 0x2, 0x1d23, 0x1d24, 0x7, 0x193, 0x2, 0x2, 0x1d24, 0x1d2e, 
       0x7, 0x2c1, 0x2, 0x2, 0x1d25, 0x1d2e, 0x7, 0x1aa, 0x2, 0x2, 0x1d26, 
       0x1d27, 0x7, 0x195, 0x2, 0x2, 0x1d27, 0x1d2e, 0x7, 0x2c1, 0x2, 0x2, 
       0x1d28, 0x1d29, 0x7, 0x193, 0x2, 0x2, 0x1d29, 0x1d2a, 0x7, 0x51, 
       0x2, 0x2, 0x1d2a, 0x1d2e, 0x7, 0x2c4, 0x2, 0x2, 0x1d2b, 0x1d2c, 0x7, 
       0x195, 0x2, 0x2, 0x1d2c, 0x1d2e, 0x7, 0x2c4, 0x2, 0x2, 0x1d2d, 0x1d23, 
       0x3, 0x2, 0x2, 0x2, 0x1d2d, 0x1d25, 0x3, 0x2, 0x2, 0x2, 0x1d2d, 0x1d26, 
       0x3, 0x2, 0x2, 0x2, 0x1d2d, 0x1d28, 0x3, 0x2, 0x2, 0x2, 0x1d2d, 0x1d2b, 
       0x3, 0x2, 0x2, 0x2, 0x1d2e, 0x1d2f, 0x3, 0x2, 0x2, 0x2, 0x1d2f, 0x1d31, 
       0x5, 0x442, 0x222, 0x2, 0x1d30, 0x1d32, 0x7, 0x3b, 0x2, 0x2, 0x1d31, 
       0x1d30, 0x3, 0x2, 0x2, 0x2, 0x1d31, 0x1d32, 0x3, 0x2, 0x2, 0x2, 0x1d32, 
       0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1d33, 0x1d35, 0x7, 0x2c0, 0x2, 0x2, 
       0x1d34, 0x1d36, 0x5, 0x442, 0x222, 0x2, 0x1d35, 0x1d34, 0x3, 0x2, 
       0x2, 0x2, 0x1d35, 0x1d36, 0x3, 0x2, 0x2, 0x2, 0x1d36, 0x1d7b, 0x3, 
       0x2, 0x2, 0x2, 0x1d37, 0x1d39, 0x7, 0x2db, 0x2, 0x2, 0x1d38, 0x1d3a, 
       0x5, 0x442, 0x222, 0x2, 0x1d39, 0x1d38, 0x3, 0x2, 0x2, 0x2, 0x1d39, 
       0x1d3a, 0x3, 0x2, 0x2, 0x2, 0x1d3a, 0x1d3c, 0x3, 0x2, 0x2, 0x2, 0x1d3b, 
       0x1d3d, 0x5, 0x422, 0x212, 0x2, 0x1d3c, 0x1d3b, 0x3, 0x2, 0x2, 0x2, 
       0x1d3c, 0x1d3d, 0x3, 0x2, 0x2, 0x2, 0x1d3d, 0x1d7b, 0x3, 0x2, 0x2, 
       0x2, 0x1d3e, 0x1d7b, 0x7, 0x87, 0x2, 0x2, 0x1d3f, 0x1d41, 0x7, 0x293, 
       0x2, 0x2, 0x1d40, 0x1d42, 0x5, 0x426, 0x214, 0x2, 0x1d41, 0x1d40, 
       0x3, 0x2, 0x2, 0x2, 0x1d41, 0x1d42, 0x3, 0x2, 0x2, 0x2, 0x1d42, 0x1d7b, 
       0x3, 0x2, 0x2, 0x2, 0x1d43, 0x1d45, 0x7, 0x294, 0x2, 0x2, 0x1d44, 
       0x1d46, 0x5, 0x426, 0x214, 0x2, 0x1d45, 0x1d44, 0x3, 0x2, 0x2, 0x2, 
       0x1d45, 0x1d46, 0x3, 0x2, 0x2, 0x2, 0x1d46, 0x1d7b, 0x3, 0x2, 0x2, 
       0x2, 0x1d47, 0x1d49, 0x7, 0x88, 0x2, 0x2, 0x1d48, 0x1d4a, 0x5, 0x426, 
       0x214, 0x2, 0x1d49, 0x1d48, 0x3, 0x2, 0x2, 0x2, 0x1d49, 0x1d4a, 0x3, 
       0x2, 0x2, 0x2, 0x1d4a, 0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1d4b, 0x1d7b, 
       0x7, 0x297, 0x2, 0x2, 0x1d4c, 0x1d4e, 0x7, 0x3e, 0x2, 0x2, 0x1d4d, 
       0x1d4f, 0x5, 0x442, 0x222, 0x2, 0x1d4e, 0x1d4d, 0x3, 0x2, 0x2, 0x2, 
       0x1d4e, 0x1d4f, 0x3, 0x2, 0x2, 0x2, 0x1d4f, 0x1d7b, 0x3, 0x2, 0x2, 
       0x2, 0x1d50, 0x1d7b, 0x9, 0x6a, 0x2, 0x2, 0x1d51, 0x1d52, 0x7, 0x14e, 
       0x2, 0x2, 0x1d52, 0x1d7b, 0x7, 0x2c0, 0x2, 0x2, 0x1d53, 0x1d57, 0x7, 
       0x14e, 0x2, 0x2, 0x1d54, 0x1d55, 0x7, 0x51, 0x2, 0x2, 0x1d55, 0x1d58, 
       0x7, 0x2c4, 0x2, 0x2, 0x1d56, 0x1d58, 0x7, 0x2c1, 0x2, 0x2, 0x1d57, 
       0x1d54, 0x3, 0x2, 0x2, 0x2, 0x1d57, 0x1d56, 0x3, 0x2, 0x2, 0x2, 0x1d57, 
       0x1d58, 0x3, 0x2, 0x2, 0x2, 0x1d58, 0x1d5a, 0x3, 0x2, 0x2, 0x2, 0x1d59, 
       0x1d5b, 0x5, 0x428, 0x215, 0x2, 0x1d5a, 0x1d59, 0x3, 0x2, 0x2, 0x2, 
       0x1d5a, 0x1d5b, 0x3, 0x2, 0x2, 0x2, 0x1d5b, 0x1d7b, 0x3, 0x2, 0x2, 
       0x2, 0x1d5c, 0x1d5e, 0x7, 0x299, 0x2, 0x2, 0x1d5d, 0x1d5f, 0x5, 0x428, 
       0x215, 0x2, 0x1d5e, 0x1d5d, 0x3, 0x2, 0x2, 0x2, 0x1d5e, 0x1d5f, 0x3, 
       0x2, 0x2, 0x2, 0x1d5f, 0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1d60, 0x1d62, 
       0x7, 0x28e, 0x2, 0x2, 0x1d61, 0x1d63, 0x5, 0x442, 0x222, 0x2, 0x1d62, 
       0x1d61, 0x3, 0x2, 0x2, 0x2, 0x1d62, 0x1d63, 0x3, 0x2, 0x2, 0x2, 0x1d63, 
       0x1d65, 0x3, 0x2, 0x2, 0x2, 0x1d64, 0x1d66, 0x5, 0x428, 0x215, 0x2, 
       0x1d65, 0x1d64, 0x3, 0x2, 0x2, 0x2, 0x1d65, 0x1d66, 0x3, 0x2, 0x2, 
       0x2, 0x1d66, 0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1d67, 0x1d69, 0x7, 0x17b, 
       0x2, 0x2, 0x1d68, 0x1d6a, 0x5, 0x428, 0x215, 0x2, 0x1d69, 0x1d68, 
       0x3, 0x2, 0x2, 0x2, 0x1d69, 0x1d6a, 0x3, 0x2, 0x2, 0x2, 0x1d6a, 0x1d7b, 
       0x3, 0x2, 0x2, 0x2, 0x1d6b, 0x1d6d, 0x7, 0x150, 0x2, 0x2, 0x1d6c, 
       0x1d6e, 0x5, 0x428, 0x215, 0x2, 0x1d6d, 0x1d6c, 0x3, 0x2, 0x2, 0x2, 
       0x1d6d, 0x1d6e, 0x3, 0x2, 0x2, 0x2, 0x1d6e, 0x1d7b, 0x3, 0x2, 0x2, 
       0x2, 0x1d6f, 0x1d70, 0x7, 0xba, 0x2, 0x2, 0x1d70, 0x1d72, 0x5, 0x41c, 
       0x20f, 0x2, 0x1d71, 0x1d73, 0x5, 0x428, 0x215, 0x2, 0x1d72, 0x1d71, 
       0x3, 0x2, 0x2, 0x2, 0x1d72, 0x1d73, 0x3, 0x2, 0x2, 0x2, 0x1d73, 0x1d7b, 
       0x3, 0x2, 0x2, 0x2, 0x1d74, 0x1d75, 0x7, 0x244, 0x2, 0x2, 0x1d75, 
       0x1d77, 0x5, 0x41c, 0x20f, 0x2, 0x1d76, 0x1d78, 0x5, 0x428, 0x215, 
       0x2, 0x1d77, 0x1d76, 0x3, 0x2, 0x2, 0x2, 0x1d77, 0x1d78, 0x3, 0x2, 
       0x2, 0x2, 0x1d78, 0x1d7b, 0x3, 0x2, 0x2, 0x2, 0x1d79, 0x1d7b, 0x9, 
       0x6b, 0x2, 0x2, 0x1d7a, 0x1ce3, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1cef, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1cf7, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1cff, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d03, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d04, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d0e, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d16, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d1d, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d2d, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d33, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d37, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d3e, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d3f, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d43, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d47, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d4b, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d4c, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d50, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d51, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d53, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d5c, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d60, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d67, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d6b, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d6f, 
       0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d74, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d79, 
       0x3, 0x2, 0x2, 0x2, 0x1d7b, 0x41b, 0x3, 0x2, 0x2, 0x2, 0x1d7c, 0x1d7d, 
       0x7, 0x2fb, 0x2, 0x2, 0x1d7d, 0x1d82, 0x5, 0x41e, 0x210, 0x2, 0x1d7e, 
       0x1d7f, 0x7, 0x301, 0x2, 0x2, 0x1d7f, 0x1d81, 0x5, 0x41e, 0x210, 
       0x2, 0x1d80, 0x1d7e, 0x3, 0x2, 0x2, 0x2, 0x1d81, 0x1d84, 0x3, 0x2, 
       0x2, 0x2, 0x1d82, 0x1d80, 0x3, 0x2, 0x2, 0x2, 0x1d82, 0x1d83, 0x3, 
       0x2, 0x2, 0x2, 0x1d83, 0x1d85, 0x3, 0x2, 0x2, 0x2, 0x1d84, 0x1d82, 
       0x3, 0x2, 0x2, 0x2, 0x1d85, 0x1d86, 0x7, 0x2fc, 0x2, 0x2, 0x1d86, 
       0x41d, 0x3, 0x2, 0x2, 0x2, 0x1d87, 0x1d8b, 0x5, 0x32c, 0x197, 0x2, 
       0x1d88, 0x1d8b, 0x7, 0x317, 0x2, 0x2, 0x1d89, 0x1d8b, 0x7, 0x318, 
       0x2, 0x2, 0x1d8a, 0x1d87, 0x3, 0x2, 0x2, 0x2, 0x1d8a, 0x1d88, 0x3, 
       0x2, 0x2, 0x2, 0x1d8a, 0x1d89, 0x3, 0x2, 0x2, 0x2, 0x1d8b, 0x41f, 
       0x3, 0x2, 0x2, 0x2, 0x1d8c, 0x1d8f, 0x5, 0x32c, 0x197, 0x2, 0x1d8d, 
       0x1d8f, 0x7, 0x317, 0x2, 0x2, 0x1d8e, 0x1d8c, 0x3, 0x2, 0x2, 0x2, 
       0x1d8e, 0x1d8d, 0x3, 0x2, 0x2, 0x2, 0x1d8f, 0x421, 0x3, 0x2, 0x2, 
       0x2, 0x1d90, 0x1d92, 0x9, 0x6c, 0x2, 0x2, 0x1d91, 0x1d90, 0x3, 0x2, 
       0x2, 0x2, 0x1d92, 0x1d93, 0x3, 0x2, 0x2, 0x2, 0x1d93, 0x1d91, 0x3, 
       0x2, 0x2, 0x2, 0x1d93, 0x1d94, 0x3, 0x2, 0x2, 0x2, 0x1d94, 0x423, 
       0x3, 0x2, 0x2, 0x2, 0x1d95, 0x1d96, 0x7, 0x2fb, 0x2, 0x2, 0x1d96, 
       0x1d97, 0x7, 0x313, 0x2, 0x2, 0x1d97, 0x1d98, 0x7, 0x301, 0x2, 0x2, 
       0x1d98, 0x1d99, 0x7, 0x313, 0x2, 0x2, 0x1d99, 0x1d9a, 0x7, 0x2fc, 
       0x2, 0x2, 0x1d9a, 0x425, 0x3, 0x2, 0x2, 0x2, 0x1d9b, 0x1d9c, 0x7, 
       0x2fb, 0x2, 0x2, 0x1d9c, 0x1d9d, 0x7, 0x313, 0x2, 0x2, 0x1d9d, 0x1d9e, 
       0x7, 0x2fc, 0x2, 0x2, 0x1d9e, 0x427, 0x3, 0x2, 0x2, 0x2, 0x1d9f, 
       0x1dae, 0x5, 0x42a, 0x216, 0x2, 0x1da0, 0x1dae, 0x5, 0x42c, 0x217, 
       0x2, 0x1da1, 0x1dae, 0x7, 0x46, 0x2, 0x2, 0x1da2, 0x1da3, 0x5, 0x42e, 
       0x218, 0x2, 0x1da3, 0x1da5, 0x5, 0x354, 0x1ab, 0x2, 0x1da4, 0x1da6, 
       0x7, 0x3b, 0x2, 0x2, 0x1da5, 0x1da4, 0x3, 0x2, 0x2, 0x2, 0x1da5, 
       0x1da6, 0x3, 0x2, 0x2, 0x2, 0x1da6, 0x1dae, 0x3, 0x2, 0x2, 0x2, 0x1da7, 
       0x1dab, 0x7, 0x3b, 0x2, 0x2, 0x1da8, 0x1da9, 0x5, 0x42e, 0x218, 0x2, 
       0x1da9, 0x1daa, 0x5, 0x354, 0x1ab, 0x2, 0x1daa, 0x1dac, 0x3, 0x2, 
       0x2, 0x2, 0x1dab, 0x1da8, 0x3, 0x2, 0x2, 0x2, 0x1dab, 0x1dac, 0x3, 
       0x2, 0x2, 0x2, 0x1dac, 0x1dae, 0x3, 0x2, 0x2, 0x2, 0x1dad, 0x1d9f, 
       0x3, 0x2, 0x2, 0x2, 0x1dad, 0x1da0, 0x3, 0x2, 0x2, 0x2, 0x1dad, 0x1da1, 
       0x3, 0x2, 0x2, 0x2, 0x1dad, 0x1da2, 0x3, 0x2, 0x2, 0x2, 0x1dad, 0x1da7, 
       0x3, 0x2, 0x2, 0x2, 0x1dae, 0x429, 0x3, 0x2, 0x2, 0x2, 0x1daf, 0x1db1, 
       0x7, 0x2e, 0x2, 0x2, 0x1db0, 0x1db2, 0x7, 0x3b, 0x2, 0x2, 0x1db1, 
       0x1db0, 0x3, 0x2, 0x2, 0x2, 0x1db1, 0x1db2, 0x3, 0x2, 0x2, 0x2, 0x1db2, 
       0x1db6, 0x3, 0x2, 0x2, 0x2, 0x1db3, 0x1db4, 0x7, 0x3b, 0x2, 0x2, 
       0x1db4, 0x1db6, 0x7, 0x2e, 0x2, 0x2, 0x1db5, 0x1daf, 0x3, 0x2, 0x2, 
       0x2, 0x1db5, 0x1db3, 0x3, 0x2, 0x2, 0x2, 0x1db6, 0x42b, 0x3, 0x2, 
       0x2, 0x2, 0x1db7, 0x1db9, 0x7, 0x2aa, 0x2, 0x2, 0x1db8, 0x1dba, 0x7, 
       0x3b, 0x2, 0x2, 0x1db9, 0x1db8, 0x3, 0x2, 0x2, 0x2, 0x1db9, 0x1dba, 
       0x3, 0x2, 0x2, 0x2, 0x1dba, 0x1dbe, 0x3, 0x2, 0x2, 0x2, 0x1dbb, 0x1dbc, 
       0x7, 0x3b, 0x2, 0x2, 0x1dbc, 0x1dbe, 0x7, 0x2aa, 0x2, 0x2, 0x1dbd, 
       0x1db7, 0x3, 0x2, 0x2, 0x2, 0x1dbd, 0x1dbb, 0x3, 0x2, 0x2, 0x2, 0x1dbe, 
       0x42d, 0x3, 0x2, 0x2, 0x2, 0x1dbf, 0x1dc0, 0x9, 0x6d, 0x2, 0x2, 0x1dc0, 
       0x1dc3, 0x7, 0x244, 0x2, 0x2, 0x1dc1, 0x1dc3, 0x7, 0x53, 0x2, 0x2, 
       0x1dc2, 0x1dbf, 0x3, 0x2, 0x2, 0x2, 0x1dc2, 0x1dc1, 0x3, 0x2, 0x2, 
       0x2, 0x1dc3, 0x42f, 0x3, 0x2, 0x2, 0x2, 0x1dc4, 0x1dc6, 0x7, 0x92, 
       0x2, 0x2, 0x1dc5, 0x1dc4, 0x3, 0x2, 0x2, 0x2, 0x1dc5, 0x1dc6, 0x3, 
       0x2, 0x2, 0x2, 0x1dc6, 0x1dc7, 0x3, 0x2, 0x2, 0x2, 0x1dc7, 0x1dc9, 
       0x7, 0x5d, 0x2, 0x2, 0x1dc8, 0x1dca, 0x7, 0x2f4, 0x2, 0x2, 0x1dc9, 
       0x1dc8, 0x3, 0x2, 0x2, 0x2, 0x1dc9, 0x1dca, 0x3, 0x2, 0x2, 0x2, 0x1dca, 
       0x1dcb, 0x3, 0x2, 0x2, 0x2, 0x1dcb, 0x1dcc, 0x5, 0x33c, 0x19f, 0x2, 
       0x1dcc, 0x431, 0x3, 0x2, 0x2, 0x2, 0x1dcd, 0x1dcf, 0x7, 0x92, 0x2, 
       0x2, 0x1dce, 0x1dcd, 0x3, 0x2, 0x2, 0x2, 0x1dce, 0x1dcf, 0x3, 0x2, 
       0x2, 0x2, 0x1dcf, 0x1dd0, 0x3, 0x2, 0x2, 0x2, 0x1dd0, 0x1dd2, 0x7, 
       0xb3, 0x2, 0x2, 0x1dd1, 0x1dd3, 0x7, 0x2f4, 0x2, 0x2, 0x1dd2, 0x1dd1, 
       0x3, 0x2, 0x2, 0x2, 0x1dd2, 0x1dd3, 0x3, 0x2, 0x2, 0x2, 0x1dd3, 0x1dd4, 
       0x3, 0x2, 0x2, 0x2, 0x1dd4, 0x1dd5, 0x5, 0x32c, 0x197, 0x2, 0x1dd5, 
       0x433, 0x3, 0x2, 0x2, 0x2, 0x1dd6, 0x1dd8, 0x7, 0x92, 0x2, 0x2, 0x1dd7, 
       0x1dd6, 0x3, 0x2, 0x2, 0x2, 0x1dd7, 0x1dd8, 0x3, 0x2, 0x2, 0x2, 0x1dd8, 
       0x1dd9, 0x3, 0x2, 0x2, 0x2, 0x1dd9, 0x1ddb, 0x5, 0x42e, 0x218, 0x2, 
       0x1dda, 0x1ddc, 0x7, 0x2f4, 0x2, 0x2, 0x1ddb, 0x1dda, 0x3, 0x2, 0x2, 
       0x2, 0x1ddb, 0x1ddc, 0x3, 0x2, 0x2, 0x2, 0x1ddc, 0x1ddd, 0x3, 0x2, 
       0x2, 0x2, 0x1ddd, 0x1dde, 0x5, 0x354, 0x1ab, 0x2, 0x1dde, 0x435, 
       0x3, 0x2, 0x2, 0x2, 0x1ddf, 0x1de3, 0x5, 0x32a, 0x196, 0x2, 0x1de0, 
       0x1de1, 0x9, 0x6e, 0x2, 0x2, 0x1de1, 0x1de3, 0x5, 0x330, 0x199, 0x2, 
       0x1de2, 0x1ddf, 0x3, 0x2, 0x2, 0x2, 0x1de2, 0x1de0, 0x3, 0x2, 0x2, 
       0x2, 0x1de3, 0x437, 0x3, 0x2, 0x2, 0x2, 0x1de4, 0x1dea, 0x9, 0x6f, 
       0x2, 0x2, 0x1de5, 0x1de7, 0x7, 0x2fb, 0x2, 0x2, 0x1de6, 0x1de8, 0x7, 
       0x313, 0x2, 0x2, 0x1de7, 0x1de6, 0x3, 0x2, 0x2, 0x2, 0x1de7, 0x1de8, 
       0x3, 0x2, 0x2, 0x2, 0x1de8, 0x1de9, 0x3, 0x2, 0x2, 0x2, 0x1de9, 0x1deb, 
       0x7, 0x2fc, 0x2, 0x2, 0x1dea, 0x1de5, 0x3, 0x2, 0x2, 0x2, 0x1dea, 
       0x1deb, 0x3, 0x2, 0x2, 0x2, 0x1deb, 0x439, 0x3, 0x2, 0x2, 0x2, 0x1dec, 
       0x1ded, 0x9, 0x70, 0x2, 0x2, 0x1ded, 0x43b, 0x3, 0x2, 0x2, 0x2, 0x1dee, 
       0x1def, 0x9, 0x71, 0x2, 0x2, 0x1def, 0x43d, 0x3, 0x2, 0x2, 0x2, 0x1df0, 
       0x1df1, 0x9, 0x72, 0x2, 0x2, 0x1df1, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x1df2, 
       0x1df3, 0x9, 0xe, 0x2, 0x2, 0x1df3, 0x441, 0x3, 0x2, 0x2, 0x2, 0x1df4, 
       0x1df5, 0x7, 0x2fb, 0x2, 0x2, 0x1df5, 0x1df6, 0x7, 0x313, 0x2, 0x2, 
       0x1df6, 0x1df7, 0x7, 0x2fc, 0x2, 0x2, 0x1df7, 0x443, 0x3, 0x2, 0x2, 
       0x2, 0x1df8, 0x1df9, 0x5, 0x42e, 0x218, 0x2, 0x1df9, 0x1dfa, 0x5, 
       0x354, 0x1ab, 0x2, 0x1dfa, 0x445, 0x3, 0x2, 0x2, 0x2, 0x1dfb, 0x1dfc, 
       0x7, 0x5d, 0x2, 0x2, 0x1dfc, 0x1dfd, 0x5, 0x33c, 0x19f, 0x2, 0x1dfd, 
       0x447, 0x3, 0x2, 0x2, 0x2, 0x1dfe, 0x1e07, 0x7, 0x2fb, 0x2, 0x2, 
       0x1dff, 0x1e04, 0x5, 0x33e, 0x1a0, 0x2, 0x1e00, 0x1e01, 0x7, 0x301, 
       0x2, 0x2, 0x1e01, 0x1e03, 0x5, 0x33e, 0x1a0, 0x2, 0x1e02, 0x1e00, 
       0x3, 0x2, 0x2, 0x2, 0x1e03, 0x1e06, 0x3, 0x2, 0x2, 0x2, 0x1e04, 0x1e02, 
       0x3, 0x2, 0x2, 0x2, 0x1e04, 0x1e05, 0x3, 0x2, 0x2, 0x2, 0x1e05, 0x1e08, 
       0x3, 0x2, 0x2, 0x2, 0x1e06, 0x1e04, 0x3, 0x2, 0x2, 0x2, 0x1e07, 0x1dff, 
       0x3, 0x2, 0x2, 0x2, 0x1e07, 0x1e08, 0x3, 0x2, 0x2, 0x2, 0x1e08, 0x1e09, 
       0x3, 0x2, 0x2, 0x2, 0x1e09, 0x1e0a, 0x7, 0x2fc, 0x2, 0x2, 0x1e0a, 
       0x449, 0x3, 0x2, 0x2, 0x2, 0x1e0b, 0x1e0c, 0x7, 0x106, 0x2, 0x2, 
       0x1e0c, 0x1e0d, 0x7, 0x1a0, 0x2, 0x2, 0x1e0d, 0x1e0e, 0x7, 0xc6, 
       0x2, 0x2, 0x1e0e, 0x44b, 0x3, 0x2, 0x2, 0x2, 0x1e0f, 0x1e10, 0x7, 
       0x106, 0x2, 0x2, 0x1e10, 0x1e11, 0x7, 0xc6, 0x2, 0x2, 0x1e11, 0x44d, 
       0x3, 0x2, 0x2, 0x2, 0x1e12, 0x1e13, 0x7, 0x313, 0x2, 0x2, 0x1e13, 
       0x44f, 0x3, 0x2, 0x2, 0x2, 0x1e14, 0x1e15, 0x5, 0x33e, 0x1a0, 0x2, 
       0x1e15, 0x451, 0x3, 0x2, 0x2, 0x2, 0x1e16, 0x1e17, 0x5, 0x33e, 0x1a0, 
       0x2, 0x1e17, 0x453, 0x3, 0x2, 0x2, 0x2, 0x1e18, 0x1e19, 0x5, 0x33e, 
       0x1a0, 0x2, 0x1e19, 0x455, 0x3, 0x2, 0x2, 0x2, 0x1e1a, 0x1e1b, 0x9, 
       0x73, 0x2, 0x2, 0x1e1b, 0x457, 0x3, 0x2, 0x2, 0x2, 0x1e1c, 0x1e1d, 
       0x9, 0x44, 0x2, 0x2, 0x1e1d, 0x459, 0x3, 0x2, 0x2, 0x2, 0x1e1e, 0x1e1f, 
       0x7, 0xe0, 0x2, 0x2, 0x1e1f, 0x1e20, 0x7, 0x50, 0x2, 0x2, 0x1e20, 
       0x1e21, 0x5, 0x32c, 0x197, 0x2, 0x1e21, 0x45b, 0x3, 0x2, 0x2, 0x2, 
       0x1e22, 0x1e23, 0x7, 0x1db, 0x2, 0x2, 0x1e23, 0x1e24, 0x5, 0x33e, 
       0x1a0, 0x2, 0x1e24, 0x1e27, 0x7, 0xe5, 0x2, 0x2, 0x1e25, 0x1e28, 
       0x5, 0x32e, 0x198, 0x2, 0x1e26, 0x1e28, 0x5, 0x346, 0x1a4, 0x2, 0x1e27, 
       0x1e25, 0x3, 0x2, 0x2, 0x2, 0x1e27, 0x1e26, 0x3, 0x2, 0x2, 0x2, 0x1e28, 
       0x1e2e, 0x3, 0x2, 0x2, 0x2, 0x1e29, 0x1e2e, 0x5, 0x45e, 0x230, 0x2, 
       0x1e2a, 0x1e2b, 0x9, 0x74, 0x2, 0x2, 0x1e2b, 0x1e2c, 0x7, 0x1db, 
       0x2, 0x2, 0x1e2c, 0x1e2e, 0x5, 0x33e, 0x1a0, 0x2, 0x1e2d, 0x1e22, 
       0x3, 0x2, 0x2, 0x2, 0x1e2d, 0x1e29, 0x3, 0x2, 0x2, 0x2, 0x1e2d, 0x1e2a, 
       0x3, 0x2, 0x2, 0x2, 0x1e2e, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x1e2f, 0x1e30, 
       0x7, 0xc5, 0x2, 0x2, 0x1e30, 0x1e33, 0x5, 0x33e, 0x1a0, 0x2, 0x1e31, 
       0x1e32, 0x7, 0x2b9, 0x2, 0x2, 0x1e32, 0x1e34, 0x5, 0x460, 0x231, 
       0x2, 0x1e33, 0x1e31, 0x3, 0x2, 0x2, 0x2, 0x1e33, 0x1e34, 0x3, 0x2, 
       0x2, 0x2, 0x1e34, 0x45f, 0x3, 0x2, 0x2, 0x2, 0x1e35, 0x1e3a, 0x5, 
       0x346, 0x1a4, 0x2, 0x1e36, 0x1e37, 0x7, 0x301, 0x2, 0x2, 0x1e37, 
       0x1e39, 0x5, 0x346, 0x1a4, 0x2, 0x1e38, 0x1e36, 0x3, 0x2, 0x2, 0x2, 
       0x1e39, 0x1e3c, 0x3, 0x2, 0x2, 0x2, 0x1e3a, 0x1e38, 0x3, 0x2, 0x2, 
       0x2, 0x1e3a, 0x1e3b, 0x3, 0x2, 0x2, 0x2, 0x1e3b, 0x461, 0x3, 0x2, 
       0x2, 0x2, 0x1e3c, 0x1e3a, 0x3, 0x2, 0x2, 0x2, 0x3fa, 0x4c3, 0x4c7, 
       0x4ca, 0x4cf, 0x4d3, 0x4d8, 0x4db, 0x4de, 0x4e1, 0x4e5, 0x4e8, 0x4f0, 
       0x4f4, 0x4f7, 0x4fe, 0x503, 0x50a, 0x50f, 0x513, 0x516, 0x523, 0x529, 
       0x531, 0x538, 0x53b, 0x53f, 0x544, 0x54a, 0x54d, 0x555, 0x559, 0x55c, 
       0x55f, 0x563, 0x566, 0x56b, 0x572, 0x575, 0x578, 0x57b, 0x57e, 0x585, 
       0x58d, 0x596, 0x59d, 0x5a2, 0x5ab, 0x5ae, 0x5b1, 0x5b4, 0x5b7, 0x5ba, 
       0x5bd, 0x5c2, 0x5c5, 0x5c8, 0x5d3, 0x5d7, 0x5db, 0x5e4, 0x5ea, 0x5ed, 
       0x5f1, 0x5f4, 0x5f7, 0x5fe, 0x602, 0x604, 0x609, 0x60d, 0x611, 0x618, 
       0x61a, 0x621, 0x627, 0x62c, 0x62f, 0x632, 0x635, 0x638, 0x63b, 0x645, 
       0x648, 0x64b, 0x653, 0x65a, 0x660, 0x663, 0x66f, 0x672, 0x675, 0x67c, 
       0x67f, 0x68b, 0x68f, 0x694, 0x697, 0x69c, 0x6a2, 0x6a7, 0x6ad, 0x6af, 
       0x6b5, 0x6b7, 0x6bd, 0x6c0, 0x6c3, 0x6c8, 0x6cb, 0x6d0, 0x6d8, 0x6e1, 
       0x6e7, 0x6ea, 0x6ed, 0x6fc, 0x701, 0x708, 0x710, 0x71d, 0x723, 0x729, 
       0x72e, 0x731, 0x734, 0x73e, 0x745, 0x74c, 0x755, 0x75a, 0x75f, 0x762, 
       0x765, 0x768, 0x76c, 0x773, 0x779, 0x782, 0x78c, 0x797, 0x799, 0x7a1, 
       0x7a9, 0x7b2, 0x7b5, 0x7b9, 0x7bd, 0x7c3, 0x7c9, 0x7cc, 0x7d5, 0x7e1, 
       0x7e6, 0x7ef, 0x7f6, 0x7fa, 0x7fe, 0x806, 0x817, 0x81d, 0x825, 0x82d, 
       0x839, 0x83f, 0x841, 0x847, 0x849, 0x84b, 0x850, 0x853, 0x859, 0x85e, 
       0x865, 0x86c, 0x873, 0x881, 0x885, 0x889, 0x88d, 0x890, 0x893, 0x896, 
       0x899, 0x8a0, 0x8a3, 0x8a6, 0x8a9, 0x8ad, 0x8b1, 0x8b5, 0x8c6, 0x8c8, 
       0x8cd, 0x8d6, 0x8dc, 0x8e0, 0x8e7, 0x8ea, 0x8ed, 0x8f1, 0x8f7, 0x8fe, 
       0x903, 0x909, 0x90c, 0x911, 0x917, 0x91a, 0x91e, 0x924, 0x928, 0x92e, 
       0x932, 0x936, 0x93c, 0x942, 0x947, 0x94b, 0x950, 0x954, 0x958, 0x966, 
       0x96e, 0x978, 0x97c, 0x995, 0x9a3, 0x9a9, 0x9ad, 0x9b2, 0x9b6, 0x9bb, 
       0x9c1, 0x9c6, 0x9c9, 0x9cf, 0x9d4, 0x9d7, 0x9dd, 0x9e1, 0x9e7, 0x9e9, 
       0x9ec, 0x9f2, 0x9f6, 0x9fb, 0xa01, 0xa05, 0xa07, 0xa0e, 0xa14, 0xa1f, 
       0xa24, 0xa29, 0xa31, 0xa37, 0xa3b, 0xa40, 0xa49, 0xa4f, 0xa55, 0xa5b, 
       0xa64, 0xa6a, 0xa73, 0xa7f, 0xa83, 0xa8a, 0xa8f, 0xa97, 0xa9b, 0xa9f, 
       0xaa3, 0xaaa, 0xaae, 0xab0, 0xab5, 0xabb, 0xac1, 0xac7, 0xacc, 0xad2, 
       0xad6, 0xad8, 0xade, 0xae4, 0xaea, 0xaef, 0xaf5, 0xafb, 0xafe, 0xb03, 
       0xb1b, 0xb21, 0xb23, 0xb29, 0xb2d, 0xb36, 0xb39, 0xb40, 0xb44, 0xb4b, 
       0xb52, 0xb57, 0xb5a, 0xb5f, 0xb66, 0xb6a, 0xb6e, 0xb73, 0xb79, 0xb81, 
       0xb89, 0xb92, 0xb9d, 0xba3, 0xba9, 0xbaf, 0xbb5, 0xbbc, 0xbc7, 0xbcd, 
       0xbdf, 0xbee, 0xbf6, 0xbfd, 0xc02, 0xc05, 0xc0a, 0xc12, 0xc18, 0xc1c, 
       0xc22, 0xc25, 0xc2a, 0xc32, 0xc38, 0xc3c, 0xc41, 0xc45, 0xc49, 0xc53, 
       0xc58, 0xc5c, 0xc5f, 0xc63, 0xc70, 0xc73, 0xc77, 0xc7a, 0xc7e, 0xc81, 
       0xc85, 0xc88, 0xc8c, 0xc8f, 0xc92, 0xc96, 0xc99, 0xc9d, 0xca0, 0xca4, 
       0xcae, 0xcb1, 0xcb6, 0xcba, 0xcbd, 0xcc1, 0xcc7, 0xccb, 0xcd2, 0xcd6, 
       0xcd9, 0xcdd, 0xce3, 0xce6, 0xcf1, 0xcf4, 0xcf8, 0xcfb, 0xcff, 0xd02, 
       0xd06, 0xd09, 0xd0c, 0xd10, 0xd13, 0xd17, 0xd1a, 0xd25, 0xd28, 0xd2b, 
       0xd2f, 0xd32, 0xd3a, 0xd3d, 0xd41, 0xd4d, 0xd54, 0xd59, 0xd68, 0xd72, 
       0xd78, 0xd7c, 0xd7f, 0xd86, 0xd8b, 0xd8e, 0xd91, 0xd9d, 0xda7, 0xdac, 
       0xdb8, 0xdbc, 0xdc4, 0xdd4, 0xdd7, 0xddf, 0xde7, 0xde9, 0xdf3, 0xdf7, 
       0xe04, 0xe0b, 0xe0e, 0xe15, 0xe17, 0xe1f, 0xe26, 0xe2a, 0xe30, 0xe35, 
       0xe3a, 0xe40, 0xe45, 0xe4a, 0xe4f, 0xe54, 0xe58, 0xe5d, 0xe62, 0xe67, 
       0xe6c, 0xe71, 0xe76, 0xe7b, 0xe80, 0xe85, 0xe8a, 0xe8f, 0xe94, 0xe99, 
       0xea3, 0xea9, 0xeaf, 0xeb4, 0xebb, 0xec0, 0xec5, 0xecb, 0xed7, 0xedf, 
       0xee5, 0xee8, 0xeef, 0xeff, 0xf04, 0xf0c, 0xf1c, 0xf1e, 0xf23, 0xf2c, 
       0xf31, 0xf36, 0xf3b, 0xf42, 0xf46, 0xf4a, 0xf4f, 0xf55, 0xf5b, 0xf60, 
       0xf65, 0xf6a, 0xf6d, 0xf74, 0xf7d, 0xf7f, 0xf87, 0xf92, 0xf95, 0xf9d, 
       0xfa0, 0xfa2, 0xfa8, 0xfac, 0xfbc, 0xfc3, 0xfd0, 0xfd5, 0xfd8, 0xfdf, 
       0xff5, 0xff8, 0xffd, 0x1003, 0x1008, 0x100b, 0x1013, 0x101b, 0x1026, 
       0x102a, 0x1032, 0x1036, 0x103c, 0x103e, 0x1049, 0x1051, 0x1055, 0x105c, 
       0x105e, 0x106c, 0x1072, 0x1077, 0x107c, 0x1082, 0x1089, 0x1091, 0x1099, 
       0x109e, 0x10a4, 0x10b1, 0x10b4, 0x10bd, 0x10c8, 0x10d9, 0x10e0, 0x10e8, 
       0x10f2, 0x10f5, 0x1101, 0x110c, 0x1114, 0x1118, 0x1120, 0x1123, 0x112d, 
       0x1130, 0x1138, 0x1140, 0x1145, 0x1148, 0x114b, 0x114e, 0x115e, 0x1161, 
       0x1163, 0x1167, 0x116a, 0x116d, 0x1171, 0x1175, 0x1179, 0x117c, 0x117f, 
       0x1181, 0x1188, 0x1194, 0x1197, 0x11aa, 0x11ac, 0x11b4, 0x11bb, 0x11bd, 
       0x11c6, 0x11cf, 0x11d6, 0x11db, 0x11e1, 0x11e4, 0x11ea, 0x11ed, 0x11f0, 
       0x11f7, 0x11fb, 0x1201, 0x1208, 0x1210, 0x1218, 0x121b, 0x1221, 0x1225, 
       0x1232, 0x123a, 0x123e, 0x1242, 0x1270, 0x1273, 0x1284, 0x128b, 0x128f, 
       0x1292, 0x1295, 0x1298, 0x12a1, 0x12a8, 0x12ad, 0x12b0, 0x12b7, 0x12bd, 
       0x12c8, 0x12d3, 0x12d9, 0x12df, 0x12e5, 0x12e9, 0x12ec, 0x12ef, 0x12f5, 
       0x12ff, 0x130b, 0x130e, 0x1310, 0x1314, 0x131b, 0x1322, 0x1329, 0x1331, 
       0x1338, 0x133f, 0x1346, 0x1355, 0x1362, 0x1365, 0x136d, 0x1379, 0x137f, 
       0x1384, 0x1389, 0x1395, 0x13a0, 0x13a8, 0x13b6, 0x13bd, 0x13c4, 0x13c8, 
       0x13cd, 0x13d9, 0x13dd, 0x13e2, 0x13ec, 0x13ee, 0x13f8, 0x1402, 0x1408, 
       0x1414, 0x1417, 0x141d, 0x1421, 0x1426, 0x142a, 0x142d, 0x1431, 0x1434, 
       0x143a, 0x143d, 0x1441, 0x1444, 0x1449, 0x144d, 0x1451, 0x1456, 0x1459, 
       0x1471, 0x147f, 0x1487, 0x1497, 0x149b, 0x14a0, 0x14a3, 0x14a9, 0x14ae, 
       0x14b4, 0x14dd, 0x14e6, 0x14ec, 0x14ef, 0x14f4, 0x14f7, 0x1502, 0x150e, 
       0x1510, 0x1512, 0x151c, 0x151f, 0x1533, 0x153e, 0x1541, 0x1546, 0x154c, 
       0x154e, 0x1558, 0x155c, 0x1561, 0x1564, 0x1574, 0x1578, 0x157c, 0x1581, 
       0x1584, 0x1588, 0x158c, 0x1593, 0x1599, 0x159c, 0x15a2, 0x15a6, 0x15ae, 
       0x15b1, 0x15ba, 0x15c6, 0x15c9, 0x15cd, 0x15d0, 0x15d2, 0x15d6, 0x15e1, 
       0x15e5, 0x15ee, 0x15fe, 0x1607, 0x160c, 0x1615, 0x161b, 0x1621, 0x162a, 
       0x1630, 0x1634, 0x163b, 0x1640, 0x1643, 0x1646, 0x164e, 0x1655, 0x1658, 
       0x165c, 0x165f, 0x1664, 0x1666, 0x166c, 0x1677, 0x167e, 0x1681, 0x1685, 
       0x1688, 0x168b, 0x1692, 0x169e, 0x16a1, 0x16ad, 0x16b6, 0x16bb, 0x16c3, 
       0x16cc, 0x16d1, 0x16d5, 0x16dc, 0x16e0, 0x16e4, 0x16eb, 0x16ef, 0x1702, 
       0x1708, 0x1711, 0x171e, 0x172b, 0x1731, 0x1735, 0x173a, 0x1745, 0x174e, 
       0x1752, 0x1757, 0x175b, 0x175e, 0x1760, 0x1765, 0x1768, 0x1777, 0x17a3, 
       0x17a7, 0x17ae, 0x17b5, 0x17ba, 0x17bd, 0x17c1, 0x17c9, 0x17ce, 0x17dd, 
       0x17e2, 0x17fb, 0x1800, 0x1805, 0x180a, 0x180f, 0x1816, 0x187c, 0x1889, 
       0x1890, 0x1897, 0x189e, 0x18a5, 0x18ac, 0x18b3, 0x18ba, 0x18bd, 0x18c4, 
       0x18d4, 0x18d9, 0x18dd, 0x18e5, 0x18e9, 0x18ec, 0x18f0, 0x18f8, 0x18fe, 
       0x1904, 0x1907, 0x190a, 0x190d, 0x1910, 0x191a, 0x191f, 0x192b, 0x1934, 
       0x193d, 0x1942, 0x1949, 0x1955, 0x1960, 0x1966, 0x1968, 0x196d, 0x1977, 
       0x197a, 0x1980, 0x1983, 0x1990, 0x1998, 0x19a0, 0x19bc, 0x19c2, 0x19c7, 
       0x19ca, 0x19d1, 0x19d9, 0x19e2, 0x19e7, 0x19f3, 0x19fc, 0x19fe, 0x1a0b, 
       0x1a1a, 0x1a1c, 0x1a23, 0x1a2a, 0x1a33, 0x1a3a, 0x1a48, 0x1a4e, 0x1a52, 
       0x1a58, 0x1a87, 0x1a89, 0x1a97, 0x1a9b, 0x1aa3, 0x1aa9, 0x1ab8, 0x1ac0, 
       0x1ac2, 0x1ac8, 0x1acc, 0x1ad3, 0x1ad9, 0x1ade, 0x1ae5, 0x1ae9, 0x1aed, 
       0x1af9, 0x1afd, 0x1b06, 0x1b09, 0x1b0c, 0x1b0f, 0x1b16, 0x1b24, 0x1b39, 
       0x1b3e, 0x1b43, 0x1b4a, 0x1b4e, 0x1b51, 0x1b55, 0x1b65, 0x1b69, 0x1b72, 
       0x1b7e, 0x1b81, 0x1b85, 0x1b8a, 0x1b90, 0x1b9c, 0x1bb5, 0x1bb9, 0x1bbd, 
       0x1bc0, 0x1bc4, 0x1bc8, 0x1bcc, 0x1bd1, 0x1bd5, 0x1bda, 0x1be2, 0x1be4, 
       0x1be9, 0x1bf9, 0x1c04, 0x1c08, 0x1c18, 0x1c1d, 0x1c33, 0x1c36, 0x1c40, 
       0x1c46, 0x1c4a, 0x1c4d, 0x1c51, 0x1c57, 0x1c5a, 0x1c60, 0x1c69, 0x1c6d, 
       0x1c8b, 0x1c93, 0x1c99, 0x1cae, 0x1cb2, 0x1cb7, 0x1cba, 0x1cd9, 0x1cde, 
       0x1ce1, 0x1ce5, 0x1ce8, 0x1ced, 0x1cef, 0x1cf2, 0x1cf5, 0x1cfa, 0x1cfd, 
       0x1d01, 0x1d06, 0x1d09, 0x1d0e, 0x1d11, 0x1d14, 0x1d18, 0x1d1d, 0x1d21, 
       0x1d2d, 0x1d31, 0x1d35, 0x1d39, 0x1d3c, 0x1d41, 0x1d45, 0x1d49, 0x1d4e, 
       0x1d57, 0x1d5a, 0x1d5e, 0x1d62, 0x1d65, 0x1d69, 0x1d6d, 0x1d72, 0x1d77, 
       0x1d7a, 0x1d82, 0x1d8a, 0x1d8e, 0x1d93, 0x1da5, 0x1dab, 0x1dad, 0x1db1, 
       0x1db5, 0x1db9, 0x1dbd, 0x1dc2, 0x1dc5, 0x1dc9, 0x1dce, 0x1dd2, 0x1dd7, 
       0x1ddb, 0x1de2, 0x1de7, 0x1dea, 0x1e04, 0x1e07, 0x1e27, 0x1e2d, 0x1e33, 
       0x1e3a, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment2,
    serializedATNSegment2 + sizeof(serializedATNSegment2) / sizeof(serializedATNSegment2[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment3,
    serializedATNSegment3 + sizeof(serializedATNSegment3) / sizeof(serializedATNSegment3[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

MySQLStatementParser::Initializer MySQLStatementParser::_init;
