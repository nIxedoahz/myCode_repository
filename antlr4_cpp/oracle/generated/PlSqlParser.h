
// Generated from /home/jona/myGit/myCode_repository/antlr4_cpp/oracle/PlSqlParser.g4 by ANTLR 4.7.1

#pragma once


#include "antlr4-runtime.h"


#include <PlSqlBaseParser.h>


namespace oracle {


class  PlSqlParser : public PlSqlBaseParser {
public:
  enum {
    ABORT = 1, ABS = 2, ACCESS = 3, ACCESSED = 4, ACCOUNT = 5, ACL = 6, 
    ACOS = 7, ACTION = 8, ACTIONS = 9, ACTIVATE = 10, ACTIVE = 11, ACTIVE_COMPONENT = 12, 
    ACTIVE_DATA = 13, ACTIVE_FUNCTION = 14, ACTIVE_TAG = 15, ACTIVITY = 16, 
    ADAPTIVE_PLAN = 17, ADD = 18, ADD_COLUMN = 19, ADD_GROUP = 20, ADD_MONTHS = 21, 
    ADJ_DATE = 22, ADMIN = 23, ADMINISTER = 24, ADMINISTRATOR = 25, ADVANCED = 26, 
    ADVISE = 27, ADVISOR = 28, AFD_DISKSTRING = 29, AFTER = 30, AGENT = 31, 
    AGGREGATE = 32, A_LETTER = 33, ALIAS = 34, ALL = 35, ALLOCATE = 36, 
    ALLOW = 37, ALL_ROWS = 38, ALTER = 39, ALWAYS = 40, ANALYZE = 41, ANCILLARY = 42, 
    AND = 43, AND_EQUAL = 44, ANOMALY = 45, ANSI_REARCH = 46, ANTIJOIN = 47, 
    ANY = 48, ANYSCHEMA = 49, APPEND = 50, APPENDCHILDXML = 51, APPEND_VALUES = 52, 
    APPLICATION = 53, APPLY = 54, APPROX_COUNT_DISTINCT = 55, ARCHIVAL = 56, 
    ARCHIVE = 57, ARCHIVED = 58, ARCHIVELOG = 59, ARRAY = 60, AS = 61, ASC = 62, 
    ASCII = 63, ASCIISTR = 64, ASIN = 65, ASIS = 66, ASSEMBLY = 67, ASSIGN = 68, 
    ASSOCIATE = 69, ASYNC = 70, ASYNCHRONOUS = 71, ATAN2 = 72, ATAN = 73, 
    AT = 74, ATTRIBUTE = 75, ATTRIBUTES = 76, AUDIT = 77, AUTHENTICATED = 78, 
    AUTHENTICATION = 79, AUTHID = 80, AUTHORIZATION = 81, AUTOALLOCATE = 82, 
    AUTO = 83, AUTOBACKUP = 84, AUTOEXTEND = 85, AUTO_LOGIN = 86, AUTOMATIC = 87, 
    AUTONOMOUS_TRANSACTION = 88, AUTO_REOPTIMIZE = 89, AVAILABILITY = 90, 
    AVRO = 91, BACKGROUND = 92, BACKUP = 93, BACKUPSET = 94, BASIC = 95, 
    BASICFILE = 96, BATCH = 97, BATCHSIZE = 98, BATCH_TABLE_ACCESS_BY_ROWID = 99, 
    BECOME = 100, BEFORE = 101, BEGIN = 102, BEGINNING = 103, BEGIN_OUTLINE_DATA = 104, 
    BEHALF = 105, BEQUEATH = 106, BETWEEN = 107, BFILE = 108, BFILENAME = 109, 
    BIGFILE = 110, BINARY = 111, BINARY_DOUBLE = 112, BINARY_DOUBLE_INFINITY = 113, 
    BINARY_DOUBLE_NAN = 114, BINARY_FLOAT = 115, BINARY_FLOAT_INFINITY = 116, 
    BINARY_FLOAT_NAN = 117, BINARY_INTEGER = 118, BIND_AWARE = 119, BINDING = 120, 
    BIN_TO_NUM = 121, BITAND = 122, BITMAP_AND = 123, BITMAP = 124, BITMAPS = 125, 
    BITMAP_TREE = 126, BITS = 127, BLOB = 128, BLOCK = 129, BLOCK_RANGE = 130, 
    BLOCKS = 131, BLOCKSIZE = 132, BODY = 133, BOOLEAN = 134, BOTH = 135, 
    BOUND = 136, BRANCH = 137, BREADTH = 138, BROADCAST = 139, BSON = 140, 
    BUFFER = 141, BUFFER_CACHE = 142, BUFFER_POOL = 143, BUILD = 144, BULK = 145, 
    BY = 146, BYPASS_RECURSIVE_CHECK = 147, BYPASS_UJVC = 148, BYTE = 149, 
    CACHE = 150, CACHE_CB = 151, CACHE_INSTANCES = 152, CACHE_TEMP_TABLE = 153, 
    CACHING = 154, CALCULATED = 155, CALLBACK = 156, CALL = 157, CANCEL = 158, 
    CANONICAL = 159, CAPACITY = 160, CARDINALITY = 161, CASCADE = 162, CASE = 163, 
    CAST = 164, CATEGORY = 165, CDBDEFAULT = 166, CEIL = 167, CELL_FLASH_CACHE = 168, 
    CERTIFICATE = 169, CFILE = 170, CHAINED = 171, CHANGE = 172, CHANGETRACKING = 173, 
    CHANGE_DUPKEY_ERROR_INDEX = 174, CHARACTER = 175, CHAR = 176, CHAR_CS = 177, 
    CHARTOROWID = 178, CHECK_ACL_REWRITE = 179, CHECK = 180, CHECKPOINT = 181, 
    CHILD = 182, CHOOSE = 183, CHR = 184, CHUNK = 185, CLASS = 186, CLASSIFIER = 187, 
    CLEANUP = 188, CLEAR = 189, C_LETTER = 190, CLIENT = 191, CLOB = 192, 
    CLONE = 193, CLOSE_CACHED_OPEN_CURSORS = 194, CLOSE = 195, CLUSTER_BY_ROWID = 196, 
    CLUSTER = 197, CLUSTER_DETAILS = 198, CLUSTER_DISTANCE = 199, CLUSTER_ID = 200, 
    CLUSTERING = 201, CLUSTERING_FACTOR = 202, CLUSTER_PROBABILITY = 203, 
    CLUSTER_SET = 204, COALESCE = 205, COALESCE_SQ = 206, COARSE = 207, 
    CO_AUTH_IND = 208, COLD = 209, COLLECT = 210, COLUMNAR = 211, COLUMN_AUTH_INDICATOR = 212, 
    COLUMN = 213, COLUMNS = 214, COLUMN_STATS = 215, COLUMN_VALUE = 216, 
    COMMENT = 217, COMMIT = 218, COMMITTED = 219, COMMON_DATA = 220, COMPACT = 221, 
    COMPATIBILITY = 222, COMPILE = 223, COMPLETE = 224, COMPLIANCE = 225, 
    COMPONENT = 226, COMPONENTS = 227, COMPOSE = 228, COMPOSITE = 229, COMPOSITE_LIMIT = 230, 
    COMPOUND = 231, COMPRESS = 232, COMPUTE = 233, CONCAT = 234, CON_DBID_TO_ID = 235, 
    CONDITIONAL = 236, CONDITION = 237, CONFIRM = 238, CONFORMING = 239, 
    CON_GUID_TO_ID = 240, CON_ID = 241, CON_NAME_TO_ID = 242, CONNECT_BY_CB_WHR_ONLY = 243, 
    CONNECT_BY_COMBINE_SW = 244, CONNECT_BY_COST_BASED = 245, CONNECT_BY_ELIM_DUPS = 246, 
    CONNECT_BY_FILTERING = 247, CONNECT_BY_ISCYCLE = 248, CONNECT_BY_ISLEAF = 249, 
    CONNECT_BY_ROOT = 250, CONNECT = 251, CONNECT_TIME = 252, CONSIDER = 253, 
    CONSISTENT = 254, CONSTANT = 255, CONST = 256, CONSTRAINT = 257, CONSTRAINTS = 258, 
    CONSTRUCTOR = 259, CONTAINER = 260, CONTAINER_DATA = 261, CONTAINERS = 262, 
    CONTENT = 263, CONTENTS = 264, CONTEXT = 265, CONTINUE = 266, CONTROLFILE = 267, 
    CON_UID_TO_ID = 268, CONVERT = 269, COOKIE = 270, COPY = 271, CORR_K = 272, 
    CORR_S = 273, CORRUPTION = 274, CORRUPT_XID_ALL = 275, CORRUPT_XID = 276, 
    COS = 277, COSH = 278, COST = 279, COST_XML_QUERY_REWRITE = 280, COUNT = 281, 
    COVAR_POP = 282, COVAR_SAMP = 283, CPU_COSTING = 284, CPU_PER_CALL = 285, 
    CPU_PER_SESSION = 286, CRASH = 287, CREATE = 288, CREATE_FILE_DEST = 289, 
    CREATE_STORED_OUTLINES = 290, CREATION = 291, CREDENTIAL = 292, CRITICAL = 293, 
    CROSS = 294, CROSSEDITION = 295, CSCONVERT = 296, CUBE_AJ = 297, CUBE = 298, 
    CUBE_GB = 299, CUBE_SJ = 300, CUME_DISTM = 301, CURRENT = 302, CURRENT_DATE = 303, 
    CURRENT_SCHEMA = 304, CURRENT_TIME = 305, CURRENT_TIMESTAMP = 306, CURRENT_USER = 307, 
    CURRENTV = 308, CURSOR = 309, CURSOR_SHARING_EXACT = 310, CURSOR_SPECIFIC_SEGMENT = 311, 
    CUSTOMDATUM = 312, CV = 313, CYCLE = 314, DANGLING = 315, DATABASE = 316, 
    DATA = 317, DATAFILE = 318, DATAFILES = 319, DATAGUARDCONFIG = 320, 
    DATAMOVEMENT = 321, DATAOBJNO = 322, DATAOBJ_TO_MAT_PARTITION = 323, 
    DATAOBJ_TO_PARTITION = 324, DATAPUMP = 325, DATA_SECURITY_REWRITE_LIMIT = 326, 
    DATE = 327, DATE_MODE = 328, DAY = 329, DAYS = 330, DBA = 331, DBA_RECYCLEBIN = 332, 
    DBMS_STATS = 333, DB_ROLE_CHANGE = 334, DBTIMEZONE = 335, DB_UNIQUE_NAME = 336, 
    DB_VERSION = 337, DDL = 338, DEALLOCATE = 339, DEBUG = 340, DEBUGGER = 341, 
    DEC = 342, DECIMAL = 343, DECLARE = 344, DECOMPOSE = 345, DECORRELATE = 346, 
    DECR = 347, DECREMENT = 348, DECRYPT = 349, DEDUPLICATE = 350, DEFAULT = 351, 
    DEFAULTS = 352, DEFERRABLE = 353, DEFERRED = 354, DEFINED = 355, DEFINE = 356, 
    DEFINER = 357, DEGREE = 358, DELAY = 359, DELEGATE = 360, DELETE_ALL = 361, 
    DELETE = 362, DELETEXML = 363, DEMAND = 364, DENSE_RANKM = 365, DEPENDENT = 366, 
    DEPTH = 367, DEQUEUE = 368, DEREF = 369, DEREF_NO_REWRITE = 370, DESC = 371, 
    DESTROY = 372, DETACHED = 373, DETERMINES = 374, DETERMINISTIC = 375, 
    DICTIONARY = 376, DIMENSION = 377, DIMENSIONS = 378, DIRECT_LOAD = 379, 
    DIRECTORY = 380, DIRECT_PATH = 381, DISABLE_ALL = 382, DISABLE = 383, 
    DISABLE_PARALLEL_DML = 384, DISABLE_PRESET = 385, DISABLE_RPKE = 386, 
    DISALLOW = 387, DISASSOCIATE = 388, DISCARD = 389, DISCONNECT = 390, 
    DISK = 391, DISKGROUP = 392, DISKGROUP_PLUS = 393, DISKS = 394, DISMOUNT = 395, 
    DISTINCT = 396, DISTINGUISHED = 397, DISTRIBUTED = 398, DISTRIBUTE = 399, 
    DML = 400, DML_UPDATE = 401, DOCFIDELITY = 402, DOCUMENT = 403, DOMAIN_INDEX_FILTER = 404, 
    DOMAIN_INDEX_NO_SORT = 405, DOMAIN_INDEX_SORT = 406, DOUBLE = 407, DOWNGRADE = 408, 
    DRIVING_SITE = 409, DROP_COLUMN = 410, DROP = 411, DROP_GROUP = 412, 
    DSINTERVAL_UNCONSTRAINED = 413, DST_UPGRADE_INSERT_CONV = 414, DUMP = 415, 
    DUMPSET = 416, DUPLICATE = 417, DV = 418, DYNAMIC = 419, DYNAMIC_SAMPLING = 420, 
    DYNAMIC_SAMPLING_EST_CDN = 421, EACH = 422, EDITIONABLE = 423, EDITION = 424, 
    EDITIONING = 425, EDITIONS = 426, ELEMENT = 427, ELIM_GROUPBY = 428, 
    ELIMINATE_JOIN = 429, ELIMINATE_OBY = 430, ELIMINATE_OUTER_JOIN = 431, 
    ELSE = 432, ELSIF = 433, EM = 434, EMPTY_BLOB = 435, EMPTY_CLOB = 436, 
    EMPTY = 437, ENABLE_ALL = 438, ENABLE = 439, ENABLE_PARALLEL_DML = 440, 
    ENABLE_PRESET = 441, ENCODING = 442, ENCRYPT = 443, ENCRYPTION = 444, 
    END = 445, END_OUTLINE_DATA = 446, ENFORCED = 447, ENFORCE = 448, ENQUEUE = 449, 
    ENTERPRISE = 450, ENTITYESCAPING = 451, ENTRY = 452, EQUIPART = 453, 
    ERR = 454, ERROR_ARGUMENT = 455, ERROR = 456, ERROR_ON_OVERLAP_TIME = 457, 
    ERRORS = 458, ESCAPE = 459, ESTIMATE = 460, EVAL = 461, EVALNAME = 462, 
    EVALUATE = 463, EVALUATION = 464, EVENTS = 465, EVERY = 466, EXCEPT = 467, 
    EXCEPTION = 468, EXCEPTION_INIT = 469, EXCEPTIONS = 470, EXCHANGE = 471, 
    EXCLUDE = 472, EXCLUDING = 473, EXCLUSIVE = 474, EXECUTE = 475, EXEMPT = 476, 
    EXISTING = 477, EXISTS = 478, EXISTSNODE = 479, EXIT = 480, EXPAND_GSET_TO_UNION = 481, 
    EXPAND_TABLE = 482, EXP = 483, EXPIRE = 484, EXPLAIN = 485, EXPLOSION = 486, 
    EXPORT = 487, EXPR_CORR_CHECK = 488, EXPRESS = 489, EXTENDS = 490, EXTENT = 491, 
    EXTENTS = 492, EXTERNAL = 493, EXTERNALLY = 494, EXTRACTCLOBXML = 495, 
    EXTRACT = 496, EXTRACTVALUE = 497, EXTRA = 498, FACILITY = 499, FACT = 500, 
    FACTOR = 501, FACTORIZE_JOIN = 502, FAILED = 503, FAILED_LOGIN_ATTEMPTS = 504, 
    FAILGROUP = 505, FAILOVER = 506, FAILURE = 507, FALSE = 508, FAMILY = 509, 
    FAR = 510, FAST = 511, FASTSTART = 512, FBTSCAN = 513, FEATURE_DETAILS = 514, 
    FEATURE_ID = 515, FEATURE_SET = 516, FEATURE_VALUE = 517, FETCH = 518, 
    FILE = 519, FILE_NAME_CONVERT = 520, FILESYSTEM_LIKE_LOGGING = 521, 
    FILTER = 522, FINAL = 523, FINE = 524, FINISH = 525, FIRST = 526, FIRSTM = 527, 
    FIRST_ROWS = 528, FIRST_VALUE = 529, FIXED_VIEW_DATA = 530, FLAGGER = 531, 
    FLASHBACK = 532, FLASH_CACHE = 533, FLOAT = 534, FLOB = 535, FLOOR = 536, 
    FLUSH = 537, FOLDER = 538, FOLLOWING = 539, FOLLOWS = 540, FORALL = 541, 
    FORCE = 542, FORCE_XML_QUERY_REWRITE = 543, FOREIGN = 544, FOREVER = 545, 
    FOR = 546, FORMAT = 547, FORWARD = 548, FRAGMENT_NUMBER = 549, FREELIST = 550, 
    FREELISTS = 551, FREEPOOLS = 552, FRESH = 553, FROM = 554, FROM_TZ = 555, 
    FULL = 556, FULL_OUTER_JOIN_TO_OUTER = 557, FUNCTION = 558, FUNCTIONS = 559, 
    GATHER_OPTIMIZER_STATISTICS = 560, GATHER_PLAN_STATISTICS = 561, GBY_CONC_ROLLUP = 562, 
    GBY_PUSHDOWN = 563, GENERATED = 564, GET = 565, GLOBAL = 566, GLOBALLY = 567, 
    GLOBAL_NAME = 568, GLOBAL_TOPIC_ENABLED = 569, GOTO = 570, GRANT = 571, 
    GROUP_BY = 572, GROUP = 573, GROUP_ID = 574, GROUPING = 575, GROUPING_ID = 576, 
    GROUPS = 577, GUARANTEED = 578, GUARANTEE = 579, GUARD = 580, HASH_AJ = 581, 
    HASH = 582, HASHKEYS = 583, HASH_SJ = 584, HAVING = 585, HEADER = 586, 
    HEAP = 587, HELP = 588, HEXTORAW = 589, HEXTOREF = 590, HIDDEN_KEYWORD = 591, 
    HIDE = 592, HIERARCHY = 593, HIGH = 594, HINTSET_BEGIN = 595, HINTSET_END = 596, 
    HOT = 597, HOUR = 598, HWM_BROKERED = 599, HYBRID = 600, IDENTIFIED = 601, 
    IDENTIFIER = 602, IDENTITY = 603, IDGENERATORS = 604, ID = 605, IDLE_TIME = 606, 
    IF = 607, IGNORE = 608, IGNORE_OPTIM_EMBEDDED_HINTS = 609, IGNORE_ROW_ON_DUPKEY_INDEX = 610, 
    IGNORE_WHERE_CLAUSE = 611, ILM = 612, IMMEDIATE = 613, IMPACT = 614, 
    IMPORT = 615, INACTIVE = 616, INCLUDE = 617, INCLUDE_VERSION = 618, 
    INCLUDING = 619, INCREMENTAL = 620, INCREMENT = 621, INCR = 622, INDENT = 623, 
    INDEX_ASC = 624, INDEX_COMBINE = 625, INDEX_DESC = 626, INDEXED = 627, 
    INDEXES = 628, INDEX_FFS = 629, INDEX_FILTER = 630, INDEX = 631, INDEXING = 632, 
    INDEX_JOIN = 633, INDEX_ROWS = 634, INDEX_RRS = 635, INDEX_RS_ASC = 636, 
    INDEX_RS_DESC = 637, INDEX_RS = 638, INDEX_SCAN = 639, INDEX_SKIP_SCAN = 640, 
    INDEX_SS_ASC = 641, INDEX_SS_DESC = 642, INDEX_SS = 643, INDEX_STATS = 644, 
    INDEXTYPE = 645, INDEXTYPES = 646, INDICATOR = 647, INDICES = 648, INFINITE = 649, 
    INFORMATIONAL = 650, INHERIT = 651, IN = 652, INITCAP = 653, INITIAL = 654, 
    INITIALIZED = 655, INITIALLY = 656, INITRANS = 657, INLINE = 658, INLINE_XMLTYPE_NT = 659, 
    INMEMORY = 660, IN_MEMORY_METADATA = 661, INMEMORY_PRUNING = 662, INNER = 663, 
    INOUT = 664, INPLACE = 665, INSERTCHILDXMLAFTER = 666, INSERTCHILDXMLBEFORE = 667, 
    INSERTCHILDXML = 668, INSERT = 669, INSERTXMLAFTER = 670, INSERTXMLBEFORE = 671, 
    INSTANCE = 672, INSTANCES = 673, INSTANTIABLE = 674, INSTANTLY = 675, 
    INSTEAD = 676, INSTR2 = 677, INSTR4 = 678, INSTRB = 679, INSTRC = 680, 
    INSTR = 681, INTEGER = 682, INTERLEAVED = 683, INTERMEDIATE = 684, INTERNAL_CONVERT = 685, 
    INTERNAL_USE = 686, INTERPRETED = 687, INTERSECT = 688, INTERVAL = 689, 
    INT = 690, INTO = 691, INVALIDATE = 692, INVISIBLE = 693, IN_XQUERY = 694, 
    IS = 695, ISOLATION = 696, ISOLATION_LEVEL = 697, ITERATE = 698, ITERATION_NUMBER = 699, 
    JAVA = 700, JOB = 701, JOIN = 702, JSON_ARRAYAGG = 703, JSON_ARRAY = 704, 
    JSON_EQUAL = 705, JSON_EXISTS2 = 706, JSON_EXISTS = 707, JSONGET = 708, 
    JSON = 709, JSON_OBJECTAGG = 710, JSON_OBJECT = 711, JSONPARSE = 712, 
    JSON_QUERY = 713, JSON_SERIALIZE = 714, JSON_TABLE = 715, JSON_TEXTCONTAINS2 = 716, 
    JSON_TEXTCONTAINS = 717, JSON_VALUE = 718, KEEP_DUPLICATES = 719, KEEP = 720, 
    KERBEROS = 721, KEY = 722, KEY_LENGTH = 723, KEYSIZE = 724, KEYS = 725, 
    KEYSTORE = 726, KILL = 727, LABEL = 728, LANGUAGE = 729, LAST_DAY = 730, 
    LAST = 731, LAST_VALUE = 732, LATERAL = 733, LAX = 734, LAYER = 735, 
    LDAP_REGISTRATION_ENABLED = 736, LDAP_REGISTRATION = 737, LDAP_REG_SYNC_INTERVAL = 738, 
    LEADING = 739, LEFT = 740, LENGTH2 = 741, LENGTH4 = 742, LENGTHB = 743, 
    LENGTHC = 744, LENGTH = 745, LESS = 746, LEVEL = 747, LEVELS = 748, 
    LIBRARY = 749, LIFECYCLE = 750, LIFE = 751, LIFETIME = 752, LIKE2 = 753, 
    LIKE4 = 754, LIKEC = 755, LIKE_EXPAND = 756, LIKE = 757, LIMIT = 758, 
    LINEAR = 759, LINK = 760, LIST = 761, LN = 762, LNNVL = 763, LOAD = 764, 
    LOB = 765, LOBNVL = 766, LOBS = 767, LOCAL_INDEXES = 768, LOCAL = 769, 
    LOCALTIME = 770, LOCALTIMESTAMP = 771, LOCATION = 772, LOCATOR = 773, 
    LOCKED = 774, LOCKING = 775, LOCK = 776, LOGFILE = 777, LOGFILES = 778, 
    LOGGING = 779, LOGICAL = 780, LOGICAL_READS_PER_CALL = 781, LOGICAL_READS_PER_SESSION = 782, 
    LOG = 783, LOGMINING = 784, LOGOFF = 785, LOGON = 786, LOG_READ_ONLY_VIOLATIONS = 787, 
    LONG = 788, LOOP = 789, LOWER = 790, LOW = 791, LPAD = 792, LTRIM = 793, 
    MAIN = 794, MAKE_REF = 795, MANAGED = 796, MANAGE = 797, MANAGEMENT = 798, 
    MANAGER = 799, MANUAL = 800, MAP = 801, MAPPING = 802, MASTER = 803, 
    MATCHED = 804, MATCHES = 805, MATCH = 806, MATCH_NUMBER = 807, MATCH_RECOGNIZE = 808, 
    MATERIALIZED = 809, MATERIALIZE = 810, MAXARCHLOGS = 811, MAXDATAFILES = 812, 
    MAXEXTENTS = 813, MAXIMIZE = 814, MAXINSTANCES = 815, MAXLOGFILES = 816, 
    MAXLOGHISTORY = 817, MAXLOGMEMBERS = 818, MAX_SHARED_TEMP_SIZE = 819, 
    MAXSIZE = 820, MAXTRANS = 821, MAXVALUE = 822, MEASURE = 823, MEASURES = 824, 
    MEDIUM = 825, MEMBER = 826, MEMCOMPRESS = 827, MEMORY = 828, MERGEACTIONS = 829, 
    MERGE_AJ = 830, MERGE_CONST_ON = 831, MERGE = 832, MERGE_SJ = 833, METADATA = 834, 
    METHOD = 835, MIGRATE = 836, MIGRATION = 837, MINEXTENTS = 838, MINIMIZE = 839, 
    MINIMUM = 840, MINING = 841, MINUS = 842, MINUS_NULL = 843, MINUTE = 844, 
    MINVALUE = 845, MIRRORCOLD = 846, MIRRORHOT = 847, MIRROR = 848, MLSLABEL = 849, 
    MODEL_COMPILE_SUBQUERY = 850, MODEL_DONTVERIFY_UNIQUENESS = 851, MODEL_DYNAMIC_SUBQUERY = 852, 
    MODEL_MIN_ANALYSIS = 853, MODEL = 854, MODEL_NB = 855, MODEL_NO_ANALYSIS = 856, 
    MODEL_PBY = 857, MODEL_PUSH_REF = 858, MODEL_SV = 859, MODE = 860, MODIFICATION = 861, 
    MODIFY_COLUMN_TYPE = 862, MODIFY = 863, MOD = 864, MODULE = 865, MONITORING = 866, 
    MONITOR = 867, MONTH = 868, MONTHS_BETWEEN = 869, MONTHS = 870, MOUNT = 871, 
    MOUNTPATH = 872, MOVEMENT = 873, MOVE = 874, MULTIDIMENSIONAL = 875, 
    MULTISET = 876, MV_MERGE = 877, NAMED = 878, NAME = 879, NAMESPACE = 880, 
    NAN = 881, NANVL = 882, NATIONAL = 883, NATIVE_FULL_OUTER_JOIN = 884, 
    NATIVE = 885, NATURAL = 886, NATURALN = 887, NAV = 888, NCHAR_CS = 889, 
    NCHAR = 890, NCHR = 891, NCLOB = 892, NEEDED = 893, NEG = 894, NESTED = 895, 
    NESTED_TABLE_FAST_INSERT = 896, NESTED_TABLE_GET_REFS = 897, NESTED_TABLE_ID = 898, 
    NESTED_TABLE_SET_REFS = 899, NESTED_TABLE_SET_SETID = 900, NETWORK = 901, 
    NEVER = 902, NEW = 903, NEW_TIME = 904, NEXT_DAY = 905, NEXT = 906, 
    NL_AJ = 907, NLJ_BATCHING = 908, NLJ_INDEX_FILTER = 909, NLJ_INDEX_SCAN = 910, 
    NLJ_PREFETCH = 911, NLS_CALENDAR = 912, NLS_CHARACTERSET = 913, NLS_CHARSET_DECL_LEN = 914, 
    NLS_CHARSET_ID = 915, NLS_CHARSET_NAME = 916, NLS_COMP = 917, NLS_CURRENCY = 918, 
    NLS_DATE_FORMAT = 919, NLS_DATE_LANGUAGE = 920, NLS_INITCAP = 921, NLS_ISO_CURRENCY = 922, 
    NL_SJ = 923, NLS_LANG = 924, NLS_LANGUAGE = 925, NLS_LENGTH_SEMANTICS = 926, 
    NLS_LOWER = 927, NLS_NCHAR_CONV_EXCP = 928, NLS_NUMERIC_CHARACTERS = 929, 
    NLS_SORT = 930, NLSSORT = 931, NLS_SPECIAL_CHARS = 932, NLS_TERRITORY = 933, 
    NLS_UPPER = 934, NO_ACCESS = 935, NO_ADAPTIVE_PLAN = 936, NO_ANSI_REARCH = 937, 
    NOAPPEND = 938, NOARCHIVELOG = 939, NOAUDIT = 940, NO_AUTO_REOPTIMIZE = 941, 
    NO_BASETABLE_MULTIMV_REWRITE = 942, NO_BATCH_TABLE_ACCESS_BY_ROWID = 943, 
    NO_BIND_AWARE = 944, NO_BUFFER = 945, NOCACHE = 946, NO_CARTESIAN = 947, 
    NO_CHECK_ACL_REWRITE = 948, NO_CLUSTER_BY_ROWID = 949, NO_CLUSTERING = 950, 
    NO_COALESCE_SQ = 951, NO_COMMON_DATA = 952, NOCOMPRESS = 953, NO_CONNECT_BY_CB_WHR_ONLY = 954, 
    NO_CONNECT_BY_COMBINE_SW = 955, NO_CONNECT_BY_COST_BASED = 956, NO_CONNECT_BY_ELIM_DUPS = 957, 
    NO_CONNECT_BY_FILTERING = 958, NOCOPY = 959, NO_COST_XML_QUERY_REWRITE = 960, 
    NO_CPU_COSTING = 961, NOCPU_COSTING = 962, NOCYCLE = 963, NO_DATA_SECURITY_REWRITE = 964, 
    NO_DECORRELATE = 965, NODELAY = 966, NO_DOMAIN_INDEX_FILTER = 967, NO_DST_UPGRADE_INSERT_CONV = 968, 
    NO_ELIM_GROUPBY = 969, NO_ELIMINATE_JOIN = 970, NO_ELIMINATE_OBY = 971, 
    NO_ELIMINATE_OUTER_JOIN = 972, NOENTITYESCAPING = 973, NO_EXPAND_GSET_TO_UNION = 974, 
    NO_EXPAND = 975, NO_EXPAND_TABLE = 976, NO_FACT = 977, NO_FACTORIZE_JOIN = 978, 
    NO_FILTERING = 979, NOFORCE = 980, NO_FULL_OUTER_JOIN_TO_OUTER = 981, 
    NO_GATHER_OPTIMIZER_STATISTICS = 982, NO_GBY_PUSHDOWN = 983, NOGUARANTEE = 984, 
    NO_INDEX_FFS = 985, NO_INDEX = 986, NO_INDEX_SS = 987, NO_INMEMORY = 988, 
    NO_INMEMORY_PRUNING = 989, NOKEEP = 990, NO_LOAD = 991, NOLOCAL = 992, 
    NOLOGGING = 993, NOMAPPING = 994, NOMAXVALUE = 995, NO_MERGE = 996, 
    NOMINIMIZE = 997, NOMINVALUE = 998, NO_MODEL_PUSH_REF = 999, NO_MONITORING = 1000, 
    NOMONITORING = 1001, NO_MONITOR = 1002, NO_MULTIMV_REWRITE = 1003, NO_NATIVE_FULL_OUTER_JOIN = 1004, 
    NONBLOCKING = 1005, NONEDITIONABLE = 1006, NONE = 1007, NO_NLJ_BATCHING = 1008, 
    NO_NLJ_PREFETCH = 1009, NO = 1010, NONSCHEMA = 1011, NO_OBJECT_LINK = 1012, 
    NOORDER = 1013, NO_ORDER_ROLLUPS = 1014, NO_OUTER_JOIN_TO_ANTI = 1015, 
    NO_OUTER_JOIN_TO_INNER = 1016, NOOVERRIDE = 1017, NO_PARALLEL_INDEX = 1018, 
    NOPARALLEL_INDEX = 1019, NO_PARALLEL = 1020, NOPARALLEL = 1021, NO_PARTIAL_COMMIT = 1022, 
    NO_PARTIAL_JOIN = 1023, NO_PARTIAL_ROLLUP_PUSHDOWN = 1024, NOPARTITION = 1025, 
    NO_PLACE_DISTINCT = 1026, NO_PLACE_GROUP_BY = 1027, NO_PQ_CONCURRENT_UNION = 1028, 
    NO_PQ_MAP = 1029, NO_PQ_REPLICATE = 1030, NO_PQ_SKEW = 1031, NO_PRUNE_GSETS = 1032, 
    NO_PULL_PRED = 1033, NO_PUSH_PRED = 1034, NO_PUSH_SUBQ = 1035, NO_PX_FAULT_TOLERANCE = 1036, 
    NO_PX_JOIN_FILTER = 1037, NO_QKN_BUFF = 1038, NO_QUERY_TRANSFORMATION = 1039, 
    NO_REF_CASCADE = 1040, NORELOCATE = 1041, NORELY = 1042, NOREPAIR = 1043, 
    NOREPLAY = 1044, NORESETLOGS = 1045, NO_RESULT_CACHE = 1046, NOREVERSE = 1047, 
    NO_REWRITE = 1048, NOREWRITE = 1049, NORMAL = 1050, NO_ROOT_SW_FOR_LOCAL = 1051, 
    NOROWDEPENDENCIES = 1052, NOSCHEMACHECK = 1053, NOSEGMENT = 1054, NO_SEMIJOIN = 1055, 
    NO_SEMI_TO_INNER = 1056, NO_SET_TO_JOIN = 1057, NOSORT = 1058, NO_SQL_TRANSLATION = 1059, 
    NO_SQL_TUNE = 1060, NO_STAR_TRANSFORMATION = 1061, NO_STATEMENT_QUEUING = 1062, 
    NO_STATS_GSETS = 1063, NOSTRICT = 1064, NO_SUBQUERY_PRUNING = 1065, 
    NO_SUBSTRB_PAD = 1066, NO_SWAP_JOIN_INPUTS = 1067, NOSWITCH = 1068, 
    NO_TABLE_LOOKUP_BY_NL = 1069, NO_TEMP_TABLE = 1070, NOTHING = 1071, 
    NOTIFICATION = 1072, NOT = 1073, NO_TRANSFORM_DISTINCT_AGG = 1074, NO_UNNEST = 1075, 
    NO_USE_CUBE = 1076, NO_USE_HASH_AGGREGATION = 1077, NO_USE_HASH_GBY_FOR_PUSHDOWN = 1078, 
    NO_USE_HASH = 1079, NO_USE_INVISIBLE_INDEXES = 1080, NO_USE_MERGE = 1081, 
    NO_USE_NL = 1082, NO_USE_VECTOR_AGGREGATION = 1083, NOVALIDATE = 1084, 
    NO_VECTOR_TRANSFORM_DIMS = 1085, NO_VECTOR_TRANSFORM_FACT = 1086, NO_VECTOR_TRANSFORM = 1087, 
    NOWAIT = 1088, NO_XDB_FASTPATH_INSERT = 1089, NO_XML_DML_REWRITE = 1090, 
    NO_XMLINDEX_REWRITE_IN_SELECT = 1091, NO_XMLINDEX_REWRITE = 1092, NO_XML_QUERY_REWRITE = 1093, 
    NO_ZONEMAP = 1094, NTH_VALUE = 1095, NULLIF = 1096, NULL_ = 1097, NULLS = 1098, 
    NUMBER = 1099, NUMERIC = 1100, NUM_INDEX_KEYS = 1101, NUMTODSINTERVAL = 1102, 
    NUMTOYMINTERVAL = 1103, NVARCHAR2 = 1104, NVL2 = 1105, OBJECT2XML = 1106, 
    OBJECT = 1107, OBJ_ID = 1108, OBJNO = 1109, OBJNO_REUSE = 1110, OCCURENCES = 1111, 
    OFFLINE = 1112, OFF = 1113, OFFSET = 1114, OF = 1115, OIDINDEX = 1116, 
    OID = 1117, OLAP = 1118, OLD = 1119, OLD_PUSH_PRED = 1120, OLS = 1121, 
    OLTP = 1122, OMIT = 1123, ONE = 1124, ONLINE = 1125, ONLINELOG = 1126, 
    ONLY = 1127, ON = 1128, OPAQUE = 1129, OPAQUE_TRANSFORM = 1130, OPAQUE_XCANONICAL = 1131, 
    OPCODE = 1132, OPEN = 1133, OPERATIONS = 1134, OPERATOR = 1135, OPT_ESTIMATE = 1136, 
    OPTIMAL = 1137, OPTIMIZE = 1138, OPTIMIZER_FEATURES_ENABLE = 1139, OPTIMIZER_GOAL = 1140, 
    OPTION = 1141, OPT_PARAM = 1142, ORA_BRANCH = 1143, ORA_CHECK_ACL = 1144, 
    ORA_CHECK_PRIVILEGE = 1145, ORA_CLUSTERING = 1146, ORADATA = 1147, ORADEBUG = 1148, 
    ORA_DST_AFFECTED = 1149, ORA_DST_CONVERT = 1150, ORA_DST_ERROR = 1151, 
    ORA_GET_ACLIDS = 1152, ORA_GET_PRIVILEGES = 1153, ORA_HASH = 1154, ORA_INVOKING_USERID = 1155, 
    ORA_INVOKING_USER = 1156, ORA_INVOKING_XS_USER_GUID = 1157, ORA_INVOKING_XS_USER = 1158, 
    ORA_RAWCOMPARE = 1159, ORA_RAWCONCAT = 1160, ORA_ROWSCN = 1161, ORA_ROWSCN_RAW = 1162, 
    ORA_ROWVERSION = 1163, ORA_TABVERSION = 1164, ORA_WRITE_TIME = 1165, 
    ORDERED = 1166, ORDERED_PREDICATES = 1167, ORDER = 1168, ORDINALITY = 1169, 
    OR_EXPAND = 1170, ORGANIZATION = 1171, OR = 1172, OR_PREDICATES = 1173, 
    OSERROR = 1174, OTHER = 1175, OUTER_JOIN_TO_ANTI = 1176, OUTER_JOIN_TO_INNER = 1177, 
    OUTER = 1178, OUTLINE_LEAF = 1179, OUTLINE = 1180, OUT_OF_LINE = 1181, 
    OUT = 1182, OVERFLOW_NOMOVE = 1183, OVERFLOW = 1184, OVERLAPS = 1185, 
    OVER = 1186, OVERRIDING = 1187, OWNER = 1188, OWNERSHIP = 1189, OWN = 1190, 
    PACKAGE = 1191, PACKAGES = 1192, PARALLEL_ENABLE = 1193, PARALLEL_INDEX = 1194, 
    PARALLEL = 1195, PARAMETERFILE = 1196, PARAMETERS = 1197, PARAM = 1198, 
    PARENT = 1199, PARITY = 1200, PARTIAL_JOIN = 1201, PARTIALLY = 1202, 
    PARTIAL = 1203, PARTIAL_ROLLUP_PUSHDOWN = 1204, PARTITION_HASH = 1205, 
    PARTITION_LIST = 1206, PARTITION = 1207, PARTITION_RANGE = 1208, PARTITIONS = 1209, 
    PARTNUMINST = 1210, PASSING = 1211, PASSWORD_GRACE_TIME = 1212, PASSWORD_LIFE_TIME = 1213, 
    PASSWORD_LOCK_TIME = 1214, PASSWORD = 1215, PASSWORD_REUSE_MAX = 1216, 
    PASSWORD_REUSE_TIME = 1217, PASSWORD_VERIFY_FUNCTION = 1218, PAST = 1219, 
    PATCH = 1220, PATH = 1221, PATH_PREFIX = 1222, PATHS = 1223, PATTERN = 1224, 
    PBL_HS_BEGIN = 1225, PBL_HS_END = 1226, PCTFREE = 1227, PCTINCREASE = 1228, 
    PCTTHRESHOLD = 1229, PCTUSED = 1230, PCTVERSION = 1231, PENDING = 1232, 
    PERCENT_FOUND = 1233, PERCENT_ISOPEN = 1234, PERCENT_NOTFOUND = 1235, 
    PERCENT_KEYWORD = 1236, PERCENT_RANKM = 1237, PERCENT_ROWCOUNT = 1238, 
    PERCENT_ROWTYPE = 1239, PERCENT_TYPE = 1240, PERFORMANCE = 1241, PERIOD_KEYWORD = 1242, 
    PERMANENT = 1243, PERMISSION = 1244, PERMUTE = 1245, PER = 1246, PFILE = 1247, 
    PHYSICAL = 1248, PIKEY = 1249, PIPELINED = 1250, PIPE = 1251, PIV_GB = 1252, 
    PIVOT = 1253, PIV_SSF = 1254, PLACE_DISTINCT = 1255, PLACE_GROUP_BY = 1256, 
    PLAN = 1257, PLSCOPE_SETTINGS = 1258, PLS_INTEGER = 1259, PLSQL_CCFLAGS = 1260, 
    PLSQL_CODE_TYPE = 1261, PLSQL_DEBUG = 1262, PLSQL_OPTIMIZE_LEVEL = 1263, 
    PLSQL_WARNINGS = 1264, PLUGGABLE = 1265, POINT = 1266, POLICY = 1267, 
    POOL_16K = 1268, POOL_2K = 1269, POOL_32K = 1270, POOL_4K = 1271, POOL_8K = 1272, 
    POSITIVEN = 1273, POSITIVE = 1274, POST_TRANSACTION = 1275, POWERMULTISET_BY_CARDINALITY = 1276, 
    POWERMULTISET = 1277, POWER = 1278, PQ_CONCURRENT_UNION = 1279, PQ_DISTRIBUTE = 1280, 
    PQ_DISTRIBUTE_WINDOW = 1281, PQ_FILTER = 1282, PQ_MAP = 1283, PQ_NOMAP = 1284, 
    PQ_REPLICATE = 1285, PQ_SKEW = 1286, PRAGMA = 1287, PREBUILT = 1288, 
    PRECEDES = 1289, PRECEDING = 1290, PRECISION = 1291, PRECOMPUTE_SUBQUERY = 1292, 
    PREDICATE_REORDERS = 1293, PRELOAD = 1294, PREPARE = 1295, PRESENTNNV = 1296, 
    PRESENT = 1297, PRESENTV = 1298, PRESERVE_OID = 1299, PRESERVE = 1300, 
    PRETTY = 1301, PREVIOUS = 1302, PREV = 1303, PRIMARY = 1304, PRINTBLOBTOCLOB = 1305, 
    PRIORITY = 1306, PRIOR = 1307, PRIVATE = 1308, PRIVATE_SGA = 1309, PRIVILEGED = 1310, 
    PRIVILEGE = 1311, PRIVILEGES = 1312, PROCEDURAL = 1313, PROCEDURE = 1314, 
    PROCESS = 1315, PROFILE = 1316, PROGRAM = 1317, PROJECT = 1318, PROPAGATE = 1319, 
    PROTECTED = 1320, PROTECTION = 1321, PROXY = 1322, PRUNING = 1323, PUBLIC = 1324, 
    PULL_PRED = 1325, PURGE = 1326, PUSH_PRED = 1327, PUSH_SUBQ = 1328, 
    PX_FAULT_TOLERANCE = 1329, PX_GRANULE = 1330, PX_JOIN_FILTER = 1331, 
    QB_NAME = 1332, QUERY_BLOCK = 1333, QUERY = 1334, QUEUE_CURR = 1335, 
    QUEUE = 1336, QUEUE_ROWP = 1337, QUIESCE = 1338, QUORUM = 1339, QUOTA = 1340, 
    RAISE = 1341, RANDOM_LOCAL = 1342, RANDOM = 1343, RANGE = 1344, RANKM = 1345, 
    RAPIDLY = 1346, RAW = 1347, RAWTOHEX = 1348, RAWTONHEX = 1349, RBA = 1350, 
    RBO_OUTLINE = 1351, RDBA = 1352, READ = 1353, READS = 1354, REALM = 1355, 
    REAL = 1356, REBALANCE = 1357, REBUILD = 1358, RECORD = 1359, RECORDS_PER_BLOCK = 1360, 
    RECOVERABLE = 1361, RECOVER = 1362, RECOVERY = 1363, RECYCLEBIN = 1364, 
    RECYCLE = 1365, REDACTION = 1366, REDEFINE = 1367, REDO = 1368, REDUCED = 1369, 
    REDUNDANCY = 1370, REF_CASCADE_CURSOR = 1371, REFERENCED = 1372, REFERENCE = 1373, 
    REFERENCES = 1374, REFERENCING = 1375, REF = 1376, REFRESH = 1377, REFTOHEX = 1378, 
    REGEXP_COUNT = 1379, REGEXP_INSTR = 1380, REGEXP_LIKE = 1381, REGEXP_REPLACE = 1382, 
    REGEXP_SUBSTR = 1383, REGISTER = 1384, REGR_AVGX = 1385, REGR_AVGY = 1386, 
    REGR_COUNT = 1387, REGR_INTERCEPT = 1388, REGR_R2 = 1389, REGR_SLOPE = 1390, 
    REGR_SXX = 1391, REGR_SXY = 1392, REGR_SYY = 1393, REGULAR = 1394, REJECT = 1395, 
    REKEY = 1396, RELATIONAL = 1397, RELIES_ON = 1398, RELOCATE = 1399, 
    RELY = 1400, REMAINDER = 1401, REMOTE_MAPPED = 1402, REMOVE = 1403, 
    RENAME = 1404, REPAIR = 1405, REPEAT = 1406, REPLACE = 1407, REPLICATION = 1408, 
    REQUIRED = 1409, RESETLOGS = 1410, RESET = 1411, RESIZE = 1412, RESOLVE = 1413, 
    RESOLVER = 1414, RESOURCE = 1415, RESPECT = 1416, RESTART = 1417, RESTORE_AS_INTERVALS = 1418, 
    RESTORE = 1419, RESTRICT_ALL_REF_CONS = 1420, RESTRICTED = 1421, RESTRICT_REFERENCES = 1422, 
    RESTRICT = 1423, RESULT_CACHE = 1424, RESULT = 1425, RESUMABLE = 1426, 
    RESUME = 1427, RETENTION = 1428, RETRY_ON_ROW_CHANGE = 1429, RETURNING = 1430, 
    RETURN = 1431, REUSE = 1432, REVERSE = 1433, REVOKE = 1434, REWRITE_OR_ERROR = 1435, 
    REWRITE = 1436, RIGHT = 1437, ROLE = 1438, ROLESET = 1439, ROLES = 1440, 
    ROLLBACK = 1441, ROLLING = 1442, ROLLUP = 1443, ROWDEPENDENCIES = 1444, 
    ROWID_MAPPING_TABLE = 1445, ROWID = 1446, ROWIDTOCHAR = 1447, ROWIDTONCHAR = 1448, 
    ROW_LENGTH = 1449, ROWNUM = 1450, ROW = 1451, ROWS = 1452, RPAD = 1453, 
    RTRIM = 1454, RULE = 1455, RULES = 1456, RUNNING = 1457, SALT = 1458, 
    SAMPLE = 1459, SAVE_AS_INTERVALS = 1460, SAVEPOINT = 1461, SAVE = 1462, 
    SB4 = 1463, SCALE_ROWS = 1464, SCALE = 1465, SCAN_INSTANCES = 1466, 
    SCAN = 1467, SCHEDULER = 1468, SCHEMACHECK = 1469, SCHEMA = 1470, SCN_ASCENDING = 1471, 
    SCN = 1472, SCOPE = 1473, SCRUB = 1474, SD_ALL = 1475, SD_INHIBIT = 1476, 
    SDO_GEOM_MBR = 1477, SD_SHOW = 1478, SEARCH = 1479, SECOND = 1480, SECRET = 1481, 
    SECUREFILE_DBA = 1482, SECUREFILE = 1483, SECURITY = 1484, SEED = 1485, 
    SEG_BLOCK = 1486, SEG_FILE = 1487, SEGMENT = 1488, SELECTIVITY = 1489, 
    SELECT = 1490, SELF = 1491, SEMIJOIN_DRIVER = 1492, SEMIJOIN = 1493, 
    SEMI_TO_INNER = 1494, SEQUENCED = 1495, SEQUENCE = 1496, SEQUENTIAL = 1497, 
    SEQ = 1498, SERIALIZABLE = 1499, SERIALLY_REUSABLE = 1500, SERIAL = 1501, 
    SERVERERROR = 1502, SERVICE_NAME_CONVERT = 1503, SERVICES = 1504, SESSION_CACHED_CURSORS = 1505, 
    SESSION = 1506, SESSIONS_PER_USER = 1507, SESSIONTIMEZONE = 1508, SESSIONTZNAME = 1509, 
    SET = 1510, SETS = 1511, SETTINGS = 1512, SET_TO_JOIN = 1513, SEVERE = 1514, 
    SHARED_POOL = 1515, SHARED = 1516, SHARE = 1517, SHARING = 1518, SHELFLIFE = 1519, 
    SHOW = 1520, SHRINK = 1521, SHUTDOWN = 1522, SIBLINGS = 1523, SID = 1524, 
    SIGNAL_COMPONENT = 1525, SIGNAL_FUNCTION = 1526, SIGN = 1527, SIGNTYPE = 1528, 
    SIMPLE_INTEGER = 1529, SIMPLE = 1530, SINGLE = 1531, SINGLETASK = 1532, 
    SINH = 1533, SIN = 1534, SIZE = 1535, SKIP_EXT_OPTIMIZER = 1536, SKIP_ = 1537, 
    SKIP_UNQ_UNUSABLE_IDX = 1538, SKIP_UNUSABLE_INDEXES = 1539, SMALLFILE = 1540, 
    SMALLINT = 1541, SNAPSHOT = 1542, SOME = 1543, SORT = 1544, SOUNDEX = 1545, 
    SOURCE_FILE_DIRECTORY = 1546, SOURCE_FILE_NAME_CONVERT = 1547, SOURCE = 1548, 
    SPACE_KEYWORD = 1549, SPECIFICATION = 1550, SPFILE = 1551, SPLIT = 1552, 
    SPREADSHEET = 1553, SQLDATA = 1554, SQLERROR = 1555, SQLLDR = 1556, 
    SQL = 1557, SQL_TRACE = 1558, SQL_TRANSLATION_PROFILE = 1559, SQRT = 1560, 
    STALE = 1561, STANDALONE = 1562, STANDARD_HASH = 1563, STANDBY_MAX_DATA_DELAY = 1564, 
    STANDBYS = 1565, STANDBY = 1566, STAR = 1567, STAR_TRANSFORMATION = 1568, 
    START = 1569, STARTUP = 1570, STATEMENT_ID = 1571, STATEMENT_QUEUING = 1572, 
    STATEMENTS = 1573, STATEMENT = 1574, STATE = 1575, STATIC = 1576, STATISTICS = 1577, 
    STATS_BINOMIAL_TEST = 1578, STATS_CROSSTAB = 1579, STATS_F_TEST = 1580, 
    STATS_KS_TEST = 1581, STATS_MODE = 1582, STATS_MW_TEST = 1583, STATS_ONE_WAY_ANOVA = 1584, 
    STATS_T_TEST_INDEP = 1585, STATS_T_TEST_INDEPU = 1586, STATS_T_TEST_ONE = 1587, 
    STATS_T_TEST_PAIRED = 1588, STATS_WSR_TEST = 1589, STDDEV_POP = 1590, 
    STDDEV_SAMP = 1591, STOP = 1592, STORAGE = 1593, STORE = 1594, STREAMS = 1595, 
    STREAM = 1596, STRICT = 1597, STRING = 1598, STRIPE_COLUMNS = 1599, 
    STRIPE_WIDTH = 1600, STRIP = 1601, STRUCTURE = 1602, SUBMULTISET = 1603, 
    SUBPARTITION_REL = 1604, SUBPARTITIONS = 1605, SUBPARTITION = 1606, 
    SUBQUERIES = 1607, SUBQUERY_PRUNING = 1608, SUBSCRIBE = 1609, SUBSET = 1610, 
    SUBSTITUTABLE = 1611, SUBSTR2 = 1612, SUBSTR4 = 1613, SUBSTRB = 1614, 
    SUBSTRC = 1615, SUBTYPE = 1616, SUCCESSFUL = 1617, SUCCESS = 1618, SUMMARY = 1619, 
    SUPPLEMENTAL = 1620, SUSPEND = 1621, SWAP_JOIN_INPUTS = 1622, SWITCHOVER = 1623, 
    SWITCH = 1624, SYNCHRONOUS = 1625, SYNC = 1626, SYNONYM = 1627, SYSASM = 1628, 
    SYS_AUDIT = 1629, SYSAUX = 1630, SYSBACKUP = 1631, SYS_CHECKACL = 1632, 
    SYS_CHECK_PRIVILEGE = 1633, SYS_CONNECT_BY_PATH = 1634, SYS_CONTEXT = 1635, 
    SYSDATE = 1636, SYSDBA = 1637, SYS_DBURIGEN = 1638, SYSDG = 1639, SYS_DL_CURSOR = 1640, 
    SYS_DM_RXFORM_CHR = 1641, SYS_DM_RXFORM_NUM = 1642, SYS_DOM_COMPARE = 1643, 
    SYS_DST_PRIM2SEC = 1644, SYS_DST_SEC2PRIM = 1645, SYS_ET_BFILE_TO_RAW = 1646, 
    SYS_ET_BLOB_TO_IMAGE = 1647, SYS_ET_IMAGE_TO_BLOB = 1648, SYS_ET_RAW_TO_BFILE = 1649, 
    SYS_EXTPDTXT = 1650, SYS_EXTRACT_UTC = 1651, SYS_FBT_INSDEL = 1652, 
    SYS_FILTER_ACLS = 1653, SYS_FNMATCHES = 1654, SYS_FNREPLACE = 1655, 
    SYS_GET_ACLIDS = 1656, SYS_GET_COL_ACLIDS = 1657, SYS_GET_PRIVILEGES = 1658, 
    SYS_GETTOKENID = 1659, SYS_GETXTIVAL = 1660, SYS_GUID = 1661, SYSGUID = 1662, 
    SYSKM = 1663, SYS_MAKE_XMLNODEID = 1664, SYS_MAKEXML = 1665, SYS_MKXMLATTR = 1666, 
    SYS_MKXTI = 1667, SYSOBJ = 1668, SYS_OP_ADT2BIN = 1669, SYS_OP_ADTCONS = 1670, 
    SYS_OP_ALSCRVAL = 1671, SYS_OP_ATG = 1672, SYS_OP_BIN2ADT = 1673, SYS_OP_BITVEC = 1674, 
    SYS_OP_BL2R = 1675, SYS_OP_BLOOM_FILTER_LIST = 1676, SYS_OP_BLOOM_FILTER = 1677, 
    SYS_OP_C2C = 1678, SYS_OP_CAST = 1679, SYS_OP_CEG = 1680, SYS_OP_CL2C = 1681, 
    SYS_OP_COMBINED_HASH = 1682, SYS_OP_COMP = 1683, SYS_OP_CONVERT = 1684, 
    SYS_OP_COUNTCHG = 1685, SYS_OP_CSCONV = 1686, SYS_OP_CSCONVTEST = 1687, 
    SYS_OP_CSR = 1688, SYS_OP_CSX_PATCH = 1689, SYS_OP_CYCLED_SEQ = 1690, 
    SYS_OP_DECOMP = 1691, SYS_OP_DESCEND = 1692, SYS_OP_DISTINCT = 1693, 
    SYS_OP_DRA = 1694, SYS_OP_DUMP = 1695, SYS_OP_DV_CHECK = 1696, SYS_OP_ENFORCE_NOT_NULL = 1697, 
    SYSOPER = 1698, SYS_OP_EXTRACT = 1699, SYS_OP_GROUPING = 1700, SYS_OP_GUID = 1701, 
    SYS_OP_HASH = 1702, SYS_OP_IIX = 1703, SYS_OP_ITR = 1704, SYS_OP_KEY_VECTOR_CREATE = 1705, 
    SYS_OP_KEY_VECTOR_FILTER_LIST = 1706, SYS_OP_KEY_VECTOR_FILTER = 1707, 
    SYS_OP_KEY_VECTOR_SUCCEEDED = 1708, SYS_OP_KEY_VECTOR_USE = 1709, SYS_OP_LBID = 1710, 
    SYS_OP_LOBLOC2BLOB = 1711, SYS_OP_LOBLOC2CLOB = 1712, SYS_OP_LOBLOC2ID = 1713, 
    SYS_OP_LOBLOC2NCLOB = 1714, SYS_OP_LOBLOC2TYP = 1715, SYS_OP_LSVI = 1716, 
    SYS_OP_LVL = 1717, SYS_OP_MAKEOID = 1718, SYS_OP_MAP_NONNULL = 1719, 
    SYS_OP_MSR = 1720, SYS_OP_NICOMBINE = 1721, SYS_OP_NIEXTRACT = 1722, 
    SYS_OP_NII = 1723, SYS_OP_NIX = 1724, SYS_OP_NOEXPAND = 1725, SYS_OP_NTCIMG = 1726, 
    SYS_OP_NUMTORAW = 1727, SYS_OP_OIDVALUE = 1728, SYS_OP_OPNSIZE = 1729, 
    SYS_OP_PAR_1 = 1730, SYS_OP_PARGID_1 = 1731, SYS_OP_PARGID = 1732, SYS_OP_PAR = 1733, 
    SYS_OP_PART_ID = 1734, SYS_OP_PIVOT = 1735, SYS_OP_R2O = 1736, SYS_OP_RAWTONUM = 1737, 
    SYS_OP_RDTM = 1738, SYS_OP_REF = 1739, SYS_OP_RMTD = 1740, SYS_OP_ROWIDTOOBJ = 1741, 
    SYS_OP_RPB = 1742, SYS_OPTLOBPRBSC = 1743, SYS_OP_TOSETID = 1744, SYS_OP_TPR = 1745, 
    SYS_OP_TRTB = 1746, SYS_OPTXICMP = 1747, SYS_OPTXQCASTASNQ = 1748, SYS_OP_UNDESCEND = 1749, 
    SYS_OP_VECAND = 1750, SYS_OP_VECBIT = 1751, SYS_OP_VECOR = 1752, SYS_OP_VECXOR = 1753, 
    SYS_OP_VERSION = 1754, SYS_OP_VREF = 1755, SYS_OP_VVD = 1756, SYS_OP_XMLCONS_FOR_CSX = 1757, 
    SYS_OP_XPTHATG = 1758, SYS_OP_XPTHIDX = 1759, SYS_OP_XPTHOP = 1760, 
    SYS_OP_XTXT2SQLT = 1761, SYS_OP_ZONE_ID = 1762, SYS_ORDERKEY_DEPTH = 1763, 
    SYS_ORDERKEY_MAXCHILD = 1764, SYS_ORDERKEY_PARENT = 1765, SYS_PARALLEL_TXN = 1766, 
    SYS_PATHID_IS_ATTR = 1767, SYS_PATHID_IS_NMSPC = 1768, SYS_PATHID_LASTNAME = 1769, 
    SYS_PATHID_LASTNMSPC = 1770, SYS_PATH_REVERSE = 1771, SYS_PXQEXTRACT = 1772, 
    SYS_RAW_TO_XSID = 1773, SYS_RID_ORDER = 1774, SYS_ROW_DELTA = 1775, 
    SYS_SC_2_XMLT = 1776, SYS_SYNRCIREDO = 1777, SYSTEM_DEFINED = 1778, 
    SYSTEM = 1779, SYSTIMESTAMP = 1780, SYS_TYPEID = 1781, SYS_UMAKEXML = 1782, 
    SYS_XMLANALYZE = 1783, SYS_XMLCONTAINS = 1784, SYS_XMLCONV = 1785, SYS_XMLEXNSURI = 1786, 
    SYS_XMLGEN = 1787, SYS_XMLI_LOC_ISNODE = 1788, SYS_XMLI_LOC_ISTEXT = 1789, 
    SYS_XMLINSTR = 1790, SYS_XMLLOCATOR_GETSVAL = 1791, SYS_XMLNODEID_GETCID = 1792, 
    SYS_XMLNODEID_GETLOCATOR = 1793, SYS_XMLNODEID_GETOKEY = 1794, SYS_XMLNODEID_GETPATHID = 1795, 
    SYS_XMLNODEID_GETPTRID = 1796, SYS_XMLNODEID_GETRID = 1797, SYS_XMLNODEID_GETSVAL = 1798, 
    SYS_XMLNODEID_GETTID = 1799, SYS_XMLNODEID = 1800, SYS_XMLT_2_SC = 1801, 
    SYS_XMLTRANSLATE = 1802, SYS_XMLTYPE2SQL = 1803, SYS_XQ_ASQLCNV = 1804, 
    SYS_XQ_ATOMCNVCHK = 1805, SYS_XQBASEURI = 1806, SYS_XQCASTABLEERRH = 1807, 
    SYS_XQCODEP2STR = 1808, SYS_XQCODEPEQ = 1809, SYS_XQCON2SEQ = 1810, 
    SYS_XQCONCAT = 1811, SYS_XQDELETE = 1812, SYS_XQDFLTCOLATION = 1813, 
    SYS_XQDOC = 1814, SYS_XQDOCURI = 1815, SYS_XQDURDIV = 1816, SYS_XQED4URI = 1817, 
    SYS_XQENDSWITH = 1818, SYS_XQERRH = 1819, SYS_XQERR = 1820, SYS_XQESHTMLURI = 1821, 
    SYS_XQEXLOBVAL = 1822, SYS_XQEXSTWRP = 1823, SYS_XQEXTRACT = 1824, SYS_XQEXTRREF = 1825, 
    SYS_XQEXVAL = 1826, SYS_XQFB2STR = 1827, SYS_XQFNBOOL = 1828, SYS_XQFNCMP = 1829, 
    SYS_XQFNDATIM = 1830, SYS_XQFNLNAME = 1831, SYS_XQFNNM = 1832, SYS_XQFNNSURI = 1833, 
    SYS_XQFNPREDTRUTH = 1834, SYS_XQFNQNM = 1835, SYS_XQFNROOT = 1836, SYS_XQFORMATNUM = 1837, 
    SYS_XQFTCONTAIN = 1838, SYS_XQFUNCR = 1839, SYS_XQGETCONTENT = 1840, 
    SYS_XQINDXOF = 1841, SYS_XQINSERT = 1842, SYS_XQINSPFX = 1843, SYS_XQIRI2URI = 1844, 
    SYS_XQLANG = 1845, SYS_XQLLNMFRMQNM = 1846, SYS_XQMKNODEREF = 1847, 
    SYS_XQNILLED = 1848, SYS_XQNODENAME = 1849, SYS_XQNORMSPACE = 1850, 
    SYS_XQNORMUCODE = 1851, SYS_XQ_NRNG = 1852, SYS_XQNSP4PFX = 1853, SYS_XQNSPFRMQNM = 1854, 
    SYS_XQPFXFRMQNM = 1855, SYS_XQ_PKSQL2XML = 1856, SYS_XQPOLYABS = 1857, 
    SYS_XQPOLYADD = 1858, SYS_XQPOLYCEL = 1859, SYS_XQPOLYCSTBL = 1860, 
    SYS_XQPOLYCST = 1861, SYS_XQPOLYDIV = 1862, SYS_XQPOLYFLR = 1863, SYS_XQPOLYMOD = 1864, 
    SYS_XQPOLYMUL = 1865, SYS_XQPOLYRND = 1866, SYS_XQPOLYSQRT = 1867, SYS_XQPOLYSUB = 1868, 
    SYS_XQPOLYUMUS = 1869, SYS_XQPOLYUPLS = 1870, SYS_XQPOLYVEQ = 1871, 
    SYS_XQPOLYVGE = 1872, SYS_XQPOLYVGT = 1873, SYS_XQPOLYVLE = 1874, SYS_XQPOLYVLT = 1875, 
    SYS_XQPOLYVNE = 1876, SYS_XQREF2VAL = 1877, SYS_XQRENAME = 1878, SYS_XQREPLACE = 1879, 
    SYS_XQRESVURI = 1880, SYS_XQRNDHALF2EVN = 1881, SYS_XQRSLVQNM = 1882, 
    SYS_XQRYENVPGET = 1883, SYS_XQRYVARGET = 1884, SYS_XQRYWRP = 1885, SYS_XQSEQ2CON4XC = 1886, 
    SYS_XQSEQ2CON = 1887, SYS_XQSEQDEEPEQ = 1888, SYS_XQSEQINSB = 1889, 
    SYS_XQSEQRM = 1890, SYS_XQSEQRVS = 1891, SYS_XQSEQSUB = 1892, SYS_XQSEQTYPMATCH = 1893, 
    SYS_XQSTARTSWITH = 1894, SYS_XQSTATBURI = 1895, SYS_XQSTR2CODEP = 1896, 
    SYS_XQSTRJOIN = 1897, SYS_XQSUBSTRAFT = 1898, SYS_XQSUBSTRBEF = 1899, 
    SYS_XQTOKENIZE = 1900, SYS_XQTREATAS = 1901, SYS_XQ_UPKXML2SQL = 1902, 
    SYS_XQXFORM = 1903, SYS_XSID_TO_RAW = 1904, SYS_ZMAP_FILTER = 1905, 
    SYS_ZMAP_REFRESH = 1906, TABLE_LOOKUP_BY_NL = 1907, TABLESPACE_NO = 1908, 
    TABLESPACE = 1909, TABLES = 1910, TABLE_STATS = 1911, TABLE = 1912, 
    TABNO = 1913, TAG = 1914, TANH = 1915, TAN = 1916, TBLORIDXPARTNUM = 1917, 
    TEMPFILE = 1918, TEMPLATE = 1919, TEMPORARY = 1920, TEMP_TABLE = 1921, 
    TEST = 1922, TEXT = 1923, THAN = 1924, THEN = 1925, THE = 1926, THREAD = 1927, 
    THROUGH = 1928, TIER = 1929, TIES = 1930, TIMEOUT = 1931, TIMESTAMP_LTZ_UNCONSTRAINED = 1932, 
    TIMESTAMP = 1933, TIMESTAMP_TZ_UNCONSTRAINED = 1934, TIMESTAMP_UNCONSTRAINED = 1935, 
    TIMES = 1936, TIME = 1937, TIMEZONE = 1938, TIMEZONE_ABBR = 1939, TIMEZONE_HOUR = 1940, 
    TIMEZONE_MINUTE = 1941, TIMEZONE_OFFSET = 1942, TIMEZONE_REGION = 1943, 
    TIME_ZONE = 1944, TIV_GB = 1945, TIV_SSF = 1946, TO_ACLID = 1947, TO_BINARY_DOUBLE = 1948, 
    TO_BINARY_FLOAT = 1949, TO_BLOB = 1950, TO_CLOB = 1951, TO_DSINTERVAL = 1952, 
    TO_LOB = 1953, TO_MULTI_BYTE = 1954, TO_NCHAR = 1955, TO_NCLOB = 1956, 
    TO_NUMBER = 1957, TOPLEVEL = 1958, TO_SINGLE_BYTE = 1959, TO_TIMESTAMP = 1960, 
    TO_TIMESTAMP_TZ = 1961, TO_TIME = 1962, TO_TIME_TZ = 1963, TO = 1964, 
    TO_YMINTERVAL = 1965, TRACE = 1966, TRACING = 1967, TRACKING = 1968, 
    TRAILING = 1969, TRANSACTION = 1970, TRANSFORM_DISTINCT_AGG = 1971, 
    TRANSITIONAL = 1972, TRANSITION = 1973, TRANSLATE = 1974, TRANSLATION = 1975, 
    TREAT = 1976, TRIGGERS = 1977, TRIGGER = 1978, TRUE = 1979, TRUNCATE = 1980, 
    TRUNC = 1981, TRUSTED = 1982, TRUST = 1983, TUNING = 1984, TX = 1985, 
    TYPES = 1986, TYPE = 1987, TZ_OFFSET = 1988, UB2 = 1989, UBA = 1990, 
    UCS2 = 1991, UID = 1992, UNARCHIVED = 1993, UNBOUNDED = 1994, UNBOUND = 1995, 
    UNCONDITIONAL = 1996, UNDER = 1997, UNDO = 1998, UNDROP = 1999, UNIFORM = 2000, 
    UNION = 2001, UNIQUE = 2002, UNISTR = 2003, UNLIMITED = 2004, UNLOAD = 2005, 
    UNLOCK = 2006, UNMATCHED = 2007, UNNEST_INNERJ_DISTINCT_VIEW = 2008, 
    UNNEST_NOSEMIJ_NODISTINCTVIEW = 2009, UNNEST_SEMIJ_VIEW = 2010, UNNEST = 2011, 
    UNPACKED = 2012, UNPIVOT = 2013, UNPLUG = 2014, UNPROTECTED = 2015, 
    UNQUIESCE = 2016, UNRECOVERABLE = 2017, UNRESTRICTED = 2018, UNSUBSCRIBE = 2019, 
    UNTIL = 2020, UNUSABLE = 2021, UNUSED = 2022, UPDATABLE = 2023, UPDATED = 2024, 
    UPDATE = 2025, UPDATEXML = 2026, UPD_INDEXES = 2027, UPD_JOININDEX = 2028, 
    UPGRADE = 2029, UPPER = 2030, UPSERT = 2031, UROWID = 2032, USABLE = 2033, 
    USAGE = 2034, USE_ANTI = 2035, USE_CONCAT = 2036, USE_CUBE = 2037, USE_HASH_AGGREGATION = 2038, 
    USE_HASH_GBY_FOR_PUSHDOWN = 2039, USE_HASH = 2040, USE_HIDDEN_PARTITIONS = 2041, 
    USE_INVISIBLE_INDEXES = 2042, USE_MERGE_CARTESIAN = 2043, USE_MERGE = 2044, 
    USE_NL = 2045, USE_NL_WITH_INDEX = 2046, USE_PRIVATE_OUTLINES = 2047, 
    USER_DATA = 2048, USER_DEFINED = 2049, USERENV = 2050, USERGROUP = 2051, 
    USER_RECYCLEBIN = 2052, USERS = 2053, USER_TABLESPACES = 2054, USER = 2055, 
    USE_SEMI = 2056, USE_STORED_OUTLINES = 2057, USE_TTT_FOR_GSETS = 2058, 
    USE = 2059, USE_VECTOR_AGGREGATION = 2060, USE_WEAK_NAME_RESL = 2061, 
    USING_NO_EXPAND = 2062, USING = 2063, UTF16BE = 2064, UTF16LE = 2065, 
    UTF32 = 2066, UTF8 = 2067, V1 = 2068, V2 = 2069, VALIDATE = 2070, VALIDATION = 2071, 
    VALID_TIME_END = 2072, VALUES = 2073, VALUE = 2074, VARCHAR2 = 2075, 
    VARCHAR = 2076, VARIABLE = 2077, VAR_POP = 2078, VARRAYS = 2079, VARRAY = 2080, 
    VAR_SAMP = 2081, VARYING = 2082, VECTOR_READ_TRACE = 2083, VECTOR_READ = 2084, 
    VECTOR_TRANSFORM_DIMS = 2085, VECTOR_TRANSFORM_FACT = 2086, VECTOR_TRANSFORM = 2087, 
    VERIFIER = 2088, VERIFY = 2089, VERSIONING = 2090, VERSIONS_ENDSCN = 2091, 
    VERSIONS_ENDTIME = 2092, VERSIONS_OPERATION = 2093, VERSIONS_STARTSCN = 2094, 
    VERSIONS_STARTTIME = 2095, VERSIONS = 2096, VERSIONS_XID = 2097, VERSION = 2098, 
    VIEW = 2099, VIOLATION = 2100, VIRTUAL = 2101, VISIBILITY = 2102, VISIBLE = 2103, 
    VOLUME = 2104, VSIZE = 2105, WAIT = 2106, WALLET = 2107, WARNING = 2108, 
    WEEKS = 2109, WEEK = 2110, WELLFORMED = 2111, WHENEVER = 2112, WHEN = 2113, 
    WHERE = 2114, WHILE = 2115, WHITESPACE = 2116, WIDTH_BUCKET = 2117, 
    WITHIN = 2118, WITHOUT = 2119, WITH_PLSQL = 2120, WITH = 2121, WORK = 2122, 
    WRAPPED = 2123, WRAPPER = 2124, WRITE = 2125, XDB_FASTPATH_INSERT = 2126, 
    XDB = 2127, X_DYN_PRUNE = 2128, XID = 2129, XML2OBJECT = 2130, XMLAGG = 2131, 
    XMLATTRIBUTES = 2132, XMLCAST = 2133, XMLCDATA = 2134, XMLCOLATTVAL = 2135, 
    XMLCOMMENT = 2136, XMLCONCAT = 2137, XMLDIFF = 2138, XML_DML_RWT_STMT = 2139, 
    XMLELEMENT = 2140, XMLEXISTS2 = 2141, XMLEXISTS = 2142, XMLFOREST = 2143, 
    XMLINDEX = 2144, XMLINDEX_REWRITE_IN_SELECT = 2145, XMLINDEX_REWRITE = 2146, 
    XMLINDEX_SEL_IDX_TBL = 2147, XMLISNODE = 2148, XMLISVALID = 2149, XMLNAMESPACES = 2150, 
    XMLPARSE = 2151, XMLPATCH = 2152, XMLPI = 2153, XMLQUERYVAL = 2154, 
    XMLQUERY = 2155, XMLROOT = 2156, XMLSCHEMA = 2157, XMLSERIALIZE = 2158, 
    XMLTABLE = 2159, XMLTRANSFORMBLOB = 2160, XMLTRANSFORM = 2161, XMLTYPE = 2162, 
    XML = 2163, XPATHTABLE = 2164, XS_SYS_CONTEXT = 2165, XS = 2166, XTRANSPORT = 2167, 
    YEARS = 2168, YEAR = 2169, YES = 2170, YMINTERVAL_UNCONSTRAINED = 2171, 
    ZONEMAP = 2172, ZONE = 2173, PREDICTION = 2174, PREDICTION_BOUNDS = 2175, 
    PREDICTION_COST = 2176, PREDICTION_DETAILS = 2177, PREDICTION_PROBABILITY = 2178, 
    PREDICTION_SET = 2179, CUME_DIST = 2180, DENSE_RANK = 2181, LISTAGG = 2182, 
    PERCENT_RANK = 2183, PERCENTILE_CONT = 2184, PERCENTILE_DISC = 2185, 
    RANK = 2186, AVG = 2187, CORR = 2188, COVAR_ = 2189, DECODE = 2190, 
    LAG = 2191, LEAD = 2192, MAX = 2193, MEDIAN = 2194, MIN = 2195, NTILE = 2196, 
    NVL = 2197, RATIO_TO_REPORT = 2198, REGR_ = 2199, ROUND = 2200, ROW_NUMBER = 2201, 
    SUBSTR = 2202, TO_CHAR = 2203, TRIM = 2204, SUM = 2205, STDDEV = 2206, 
    VAR_ = 2207, VARIANCE = 2208, LEAST = 2209, GREATEST = 2210, TO_DATE = 2211, 
    NATIONAL_CHAR_STRING_LIT = 2212, BIT_STRING_LIT = 2213, HEX_STRING_LIT = 2214, 
    DOUBLE_PERIOD = 2215, PERIOD = 2216, UNSIGNED_INTEGER = 2217, APPROXIMATE_NUM_LIT = 2218, 
    CHAR_STRING = 2219, DELIMITED_ID = 2220, PERCENT = 2221, AMPERSAND = 2222, 
    LEFT_PAREN = 2223, RIGHT_PAREN = 2224, DOUBLE_ASTERISK = 2225, ASTERISK = 2226, 
    PLUS_SIGN = 2227, MINUS_SIGN = 2228, COMMA = 2229, SOLIDUS = 2230, AT_SIGN = 2231, 
    ASSIGN_OP = 2232, BINDVAR = 2233, NOT_EQUAL_OP = 2234, CARRET_OPERATOR_PART = 2235, 
    TILDE_OPERATOR_PART = 2236, EXCLAMATION_OPERATOR_PART = 2237, GREATER_THAN_OP = 2238, 
    LESS_THAN_OP = 2239, COLON = 2240, SEMICOLON = 2241, BAR = 2242, EQUALS_OP = 2243, 
    LEFT_BRACKET = 2244, RIGHT_BRACKET = 2245, INTRODUCER = 2246, SINGLE_LINE_COMMENT = 2247, 
    MULTI_LINE_COMMENT = 2248, REMARK_COMMENT = 2249, PROMPT_MESSAGE = 2250, 
    START_CMD = 2251, REGULAR_ID = 2252, SPACES = 2253
  };

  enum {
    RuleSql_script = 0, RuleUnit_statement = 1, RuleSelect_expr_statement = 2, 
    RuleDrop_function = 3, RuleAlter_function = 4, RuleCreate_function_body = 5, 
    RuleParallel_enable_clause = 6, RulePartition_by_clause = 7, RuleResult_cache_clause = 8, 
    RuleRelies_on_part = 9, RuleStreaming_clause = 10, RuleDrop_package = 11, 
    RuleAlter_package = 12, RuleCreate_package = 13, RuleCreate_package_body = 14, 
    RulePackage_obj_spec = 15, RuleProcedure_spec = 16, RuleFunction_spec = 17, 
    RulePackage_obj_body = 18, RuleDrop_procedure = 19, RuleAlter_procedure = 20, 
    RuleFunction_body = 21, RuleProcedure_body = 22, RuleCreate_procedure_body = 23, 
    RuleDrop_trigger = 24, RuleAlter_trigger = 25, RuleCreate_trigger = 26, 
    RuleTrigger_follows_clause = 27, RuleTrigger_when_clause = 28, RuleSimple_dml_trigger = 29, 
    RuleFor_each_row = 30, RuleCompound_dml_trigger = 31, RuleNon_dml_trigger = 32, 
    RuleTrigger_body = 33, RuleRoutine_clause = 34, RuleCompound_trigger_block = 35, 
    RuleTiming_point_section = 36, RuleNon_dml_event = 37, RuleDml_event_clause = 38, 
    RuleDml_event_element = 39, RuleDml_event_nested_clause = 40, RuleReferencing_clause = 41, 
    RuleReferencing_element = 42, RuleDrop_type = 43, RuleAlter_type = 44, 
    RuleCompile_type_clause = 45, RuleReplace_type_clause = 46, RuleAlter_method_spec = 47, 
    RuleAlter_method_element = 48, RuleAlter_attribute_definition = 49, 
    RuleAttribute_definition = 50, RuleAlter_collection_clauses = 51, RuleDependent_handling_clause = 52, 
    RuleDependent_exceptions_part = 53, RuleCreate_type = 54, RuleType_definition = 55, 
    RuleObject_type_def = 56, RuleObject_as_part = 57, RuleObject_under_part = 58, 
    RuleNested_table_type_def = 59, RuleSqlj_object_type = 60, RuleType_body = 61, 
    RuleType_body_elements = 62, RuleMap_order_func_declaration = 63, RuleSubprog_decl_in_type = 64, 
    RuleProc_decl_in_type = 65, RuleFunc_decl_in_type = 66, RuleConstructor_declaration = 67, 
    RuleModifier_clause = 68, RuleObject_member_spec = 69, RuleSqlj_object_type_attr = 70, 
    RuleElement_spec = 71, RuleElement_spec_options = 72, RuleSubprogram_spec = 73, 
    RuleOverriding_subprogram_spec = 74, RuleOverriding_function_spec = 75, 
    RuleType_procedure_spec = 76, RuleType_function_spec = 77, RuleConstructor_spec = 78, 
    RuleMap_order_function_spec = 79, RulePragma_clause = 80, RulePragma_elements = 81, 
    RuleType_elements_parameter = 82, RuleDrop_sequence = 83, RuleAlter_sequence = 84, 
    RuleAlter_session = 85, RuleAlter_session_set_clause = 86, RuleCreate_sequence = 87, 
    RuleSequence_spec = 88, RuleSequence_start_clause = 89, RuleCreate_index = 90, 
    RuleCluster_index_clause = 91, RuleCluster_name = 92, RuleTable_index_clause = 93, 
    RuleBitmap_join_index_clause = 94, RuleIndex_expr = 95, RuleIndex_properties = 96, 
    RuleDomain_index_clause = 97, RuleLocal_domain_index_clause = 98, RuleXmlindex_clause = 99, 
    RuleLocal_xmlindex_clause = 100, RuleGlobal_partitioned_index = 101, 
    RuleIndex_partitioning_clause = 102, RuleLocal_partitioned_index = 103, 
    RuleOn_range_partitioned_table = 104, RuleOn_list_partitioned_table = 105, 
    RuleOn_hash_partitioned_table = 106, RuleOn_comp_partitioned_table = 107, 
    RuleIndex_subpartition_clause = 108, RuleOdci_parameters = 109, RuleIndextype = 110, 
    RuleAlter_index = 111, RuleAlter_index_ops_set1 = 112, RuleAlter_index_ops_set2 = 113, 
    RuleVisible_or_invisible = 114, RuleMonitoring_nomonitoring = 115, RuleRebuild_clause = 116, 
    RuleAlter_index_partitioning = 117, RuleModify_index_default_attrs = 118, 
    RuleAdd_hash_index_partition = 119, RuleCoalesce_index_partition = 120, 
    RuleModify_index_partition = 121, RuleModify_index_partitions_ops = 122, 
    RuleRename_index_partition = 123, RuleDrop_index_partition = 124, RuleSplit_index_partition = 125, 
    RuleIndex_partition_description = 126, RuleModify_index_subpartition = 127, 
    RulePartition_name_old = 128, RuleNew_partition_name = 129, RuleNew_index_name = 130, 
    RuleCreate_user = 131, RuleAlter_user = 132, RuleAlter_identified_by = 133, 
    RuleIdentified_by = 134, RuleIdentified_other_clause = 135, RuleUser_tablespace_clause = 136, 
    RuleQuota_clause = 137, RuleProfile_clause = 138, RuleRole_clause = 139, 
    RuleUser_default_role_clause = 140, RulePassword_expire_clause = 141, 
    RuleUser_lock_clause = 142, RuleUser_editions_clause = 143, RuleAlter_user_editions_clause = 144, 
    RuleProxy_clause = 145, RuleContainer_names = 146, RuleSet_container_data = 147, 
    RuleAdd_rem_container_data = 148, RuleContainer_data_clause = 149, RuleAnalyze = 150, 
    RulePartition_extention_clause = 151, RuleValidation_clauses = 152, 
    RuleOnline_or_offline = 153, RuleInto_clause1 = 154, RulePartition_key_value = 155, 
    RuleSubpartition_key_value = 156, RuleAssociate_statistics = 157, RuleColumn_association = 158, 
    RuleFunction_association = 159, RuleIndextype_name = 160, RuleUsing_statistics_type = 161, 
    RuleStatistics_type_name = 162, RuleDefault_cost_clause = 163, RuleCpu_cost = 164, 
    RuleIo_cost = 165, RuleNetwork_cost = 166, RuleDefault_selectivity_clause = 167, 
    RuleDefault_selectivity = 168, RuleStorage_table_clause = 169, RuleUnified_auditing = 170, 
    RulePolicy_name = 171, RuleAudit_traditional = 172, RuleAudit_direct_path = 173, 
    RuleAudit_container_clause = 174, RuleAudit_operation_clause = 175, 
    RuleAuditing_by_clause = 176, RuleAudit_user = 177, RuleAudit_schema_object_clause = 178, 
    RuleSql_operation = 179, RuleAuditing_on_clause = 180, RuleModel_name = 181, 
    RuleObject_name = 182, RuleProfile_name = 183, RuleSql_statement_shortcut = 184, 
    RuleDrop_index = 185, RuleGrant_statement = 186, RuleContainer_clause = 187, 
    RuleCreate_directory = 188, RuleDirectory_name = 189, RuleDirectory_path = 190, 
    RuleAlter_library = 191, RuleLibrary_editionable = 192, RuleLibrary_debug = 193, 
    RuleCompiler_parameters_clause = 194, RuleParameter_value = 195, RuleLibrary_name = 196, 
    RuleAlter_view = 197, RuleAlter_view_editionable = 198, RuleCreate_view = 199, 
    RuleView_options = 200, RuleView_alias_constraint = 201, RuleObject_view_clause = 202, 
    RuleInline_constraint = 203, RuleInline_ref_constraint = 204, RuleOut_of_line_ref_constraint = 205, 
    RuleOut_of_line_constraint = 206, RuleConstraint_state = 207, RuleAlter_tablespace = 208, 
    RuleDatafile_tempfile_clauses = 209, RuleTablespace_logging_clauses = 210, 
    RuleTablespace_group_clause = 211, RuleTablespace_group_name = 212, 
    RuleTablespace_state_clauses = 213, RuleFlashback_mode_clause = 214, 
    RuleNew_tablespace_name = 215, RuleCreate_tablespace = 216, RulePermanent_tablespace_clause = 217, 
    RuleTablespace_encryption_spec = 218, RuleLogging_clause = 219, RuleExtent_management_clause = 220, 
    RuleSegment_management_clause = 221, RuleTemporary_tablespace_clause = 222, 
    RuleUndo_tablespace_clause = 223, RuleTablespace_retention_clause = 224, 
    RuleDatafile_specification = 225, RuleTempfile_specification = 226, 
    RuleDatafile_tempfile_spec = 227, RuleRedo_log_file_spec = 228, RuleAutoextend_clause = 229, 
    RuleMaxsize_clause = 230, RuleBuild_clause = 231, RuleParallel_clause = 232, 
    RuleAlter_materialized_view = 233, RuleAlter_mv_option1 = 234, RuleAlter_mv_refresh = 235, 
    RuleRollback_segment = 236, RuleModify_mv_column_clause = 237, RuleAlter_materialized_view_log = 238, 
    RuleAdd_mv_log_column_clause = 239, RuleMove_mv_log_clause = 240, RuleMv_log_augmentation = 241, 
    RuleDatetime_expr = 242, RuleInterval_expr = 243, RuleSynchronous_or_asynchronous = 244, 
    RuleIncluding_or_excluding = 245, RuleCreate_materialized_view_log = 246, 
    RuleNew_values_clause = 247, RuleMv_log_purge_clause = 248, RuleCreate_materialized_view = 249, 
    RuleCreate_mv_refresh = 250, RuleCreate_context = 251, RuleOracle_namespace = 252, 
    RuleCreate_cluster = 253, RuleCreate_table = 254, RuleXmltype_table = 255, 
    RuleXmltype_virtual_columns = 256, RuleXmltype_column_properties = 257, 
    RuleXmltype_storage = 258, RuleXmlschema_spec = 259, RuleObject_table = 260, 
    RuleOid_index_clause = 261, RuleOid_clause = 262, RuleObject_properties = 263, 
    RuleObject_table_substitution = 264, RuleRelational_table = 265, RuleRelational_properties = 266, 
    RuleTable_partitioning_clauses = 267, RuleRange_partitions = 268, RuleList_partitions = 269, 
    RuleHash_partitions = 270, RuleIndividual_hash_partitions = 271, RuleHash_partitions_by_quantity = 272, 
    RuleHash_partition_quantity = 273, RuleComposite_range_partitions = 274, 
    RuleComposite_list_partitions = 275, RuleComposite_hash_partitions = 276, 
    RuleReference_partitioning = 277, RuleReference_partition_desc = 278, 
    RuleSystem_partitioning = 279, RuleRange_partition_desc = 280, RuleList_partition_desc = 281, 
    RuleSubpartition_template = 282, RuleHash_subpartition_quantity = 283, 
    RuleSubpartition_by_range = 284, RuleSubpartition_by_list = 285, RuleSubpartition_by_hash = 286, 
    RuleSubpartition_name = 287, RuleRange_subpartition_desc = 288, RuleList_subpartition_desc = 289, 
    RuleIndividual_hash_subparts = 290, RuleHash_subparts_by_quantity = 291, 
    RuleRange_values_clause = 292, RuleList_values_clause = 293, RuleTable_partition_description = 294, 
    RulePartitioning_storage_clause = 295, RuleLob_partitioning_storage = 296, 
    RuleDatatype_null_enable = 297, RuleSize_clause = 298, RuleTable_compression = 299, 
    RulePhysical_attributes_clause = 300, RuleStorage_clause = 301, RuleDeferred_segment_creation = 302, 
    RuleSegment_attributes_clause = 303, RulePhysical_properties = 304, 
    RuleRow_movement_clause = 305, RuleFlashback_archive_clause = 306, RuleLog_grp = 307, 
    RuleSupplemental_table_logging = 308, RuleSupplemental_log_grp_clause = 309, 
    RuleSupplemental_id_key_clause = 310, RuleAllocate_extent_clause = 311, 
    RuleDeallocate_unused_clause = 312, RuleShrink_clause = 313, RuleRecords_per_block_clause = 314, 
    RuleUpgrade_table_clause = 315, RuleDrop_table = 316, RuleComment_on_column = 317, 
    RuleEnable_or_disable = 318, RuleAllow_or_disallow = 319, RuleCreate_synonym = 320, 
    RuleComment_on_table = 321, RuleAlter_cluster = 322, RuleCache_or_nocache = 323, 
    RuleDatabase_name = 324, RuleAlter_database = 325, RuleStartup_clauses = 326, 
    RuleResetlogs_or_noresetlogs = 327, RuleUpgrade_or_downgrade = 328, 
    RuleRecovery_clauses = 329, RuleBegin_or_end = 330, RuleGeneral_recovery = 331, 
    RuleFull_database_recovery = 332, RulePartial_database_recovery = 333, 
    RulePartial_database_recovery_10g = 334, RuleManaged_standby_recovery = 335, 
    RuleDb_name = 336, RuleDatabase_file_clauses = 337, RuleCreate_datafile_clause = 338, 
    RuleAlter_datafile_clause = 339, RuleAlter_tempfile_clause = 340, RuleLogfile_clauses = 341, 
    RuleAdd_logfile_clauses = 342, RuleLog_file_group = 343, RuleDrop_logfile_clauses = 344, 
    RuleSwitch_logfile_clause = 345, RuleSupplemental_db_logging = 346, 
    RuleAdd_or_drop = 347, RuleSupplemental_plsql_clause = 348, RuleLogfile_descriptor = 349, 
    RuleControlfile_clauses = 350, RuleTrace_file_clause = 351, RuleStandby_database_clauses = 352, 
    RuleActivate_standby_db_clause = 353, RuleMaximize_standby_db_clause = 354, 
    RuleRegister_logfile_clause = 355, RuleCommit_switchover_clause = 356, 
    RuleStart_standby_clause = 357, RuleStop_standby_clause = 358, RuleConvert_database_clause = 359, 
    RuleDefault_settings_clause = 360, RuleSet_time_zone_clause = 361, RuleInstance_clauses = 362, 
    RuleSecurity_clause = 363, RuleDomain = 364, RuleDatabase = 365, RuleEdition_name = 366, 
    RuleFilenumber = 367, RuleFilename = 368, RuleAlter_table = 369, RuleAlter_table_properties = 370, 
    RuleAlter_table_properties_1 = 371, RuleAlter_iot_clauses = 372, RuleAlter_mapping_table_clause = 373, 
    RuleAlter_overflow_clause = 374, RuleAdd_overflow_clause = 375, RuleEnable_disable_clause = 376, 
    RuleUsing_index_clause = 377, RuleIndex_attributes = 378, RuleSort_or_nosort = 379, 
    RuleExceptions_clause = 380, RuleMove_table_clause = 381, RuleIndex_org_table_clause = 382, 
    RuleMapping_table_clause = 383, RuleKey_compression = 384, RuleIndex_org_overflow_clause = 385, 
    RuleColumn_clauses = 386, RuleModify_collection_retrieval = 387, RuleCollection_item = 388, 
    RuleRename_column_clause = 389, RuleOld_column_name = 390, RuleNew_column_name = 391, 
    RuleAdd_modify_drop_column_clauses = 392, RuleDrop_column_clause = 393, 
    RuleModify_column_clauses = 394, RuleModify_col_properties = 395, RuleModify_col_substitutable = 396, 
    RuleAdd_column_clause = 397, RuleAlter_varray_col_properties = 398, 
    RuleVarray_col_properties = 399, RuleVarray_storage_clause = 400, RuleLob_segname = 401, 
    RuleLob_item = 402, RuleLob_storage_parameters = 403, RuleLob_storage_clause = 404, 
    RuleModify_lob_storage_clause = 405, RuleModify_lob_parameters = 406, 
    RuleLob_parameters = 407, RuleLob_deduplicate_clause = 408, RuleLob_compression_clause = 409, 
    RuleLob_retention_clause = 410, RuleEncryption_spec = 411, RuleTablespace = 412, 
    RuleVarray_item = 413, RuleColumn_properties = 414, RulePeriod_definition = 415, 
    RuleStart_time_column = 416, RuleEnd_time_column = 417, RuleColumn_definition = 418, 
    RuleVirtual_column_definition = 419, RuleOut_of_line_part_storage = 420, 
    RuleNested_table_col_properties = 421, RuleNested_item = 422, RuleSubstitutable_column_clause = 423, 
    RulePartition_name = 424, RuleSupplemental_logging_props = 425, RuleColumn_or_attribute = 426, 
    RuleObject_type_col_properties = 427, RuleConstraint_clauses = 428, 
    RuleOld_constraint_name = 429, RuleNew_constraint_name = 430, RuleDrop_constraint_clause = 431, 
    RuleDrop_primary_key_or_unique_or_generic_clause = 432, RuleAdd_constraint = 433, 
    RuleCheck_constraint = 434, RuleDrop_constraint = 435, RuleEnable_constraint = 436, 
    RuleDisable_constraint = 437, RuleForeign_key_clause = 438, RuleReferences_clause = 439, 
    RuleOn_delete_clause = 440, RuleUnique_key_clause = 441, RulePrimary_key_clause = 442, 
    RuleAnonymous_block = 443, RuleInvoker_rights_clause = 444, RuleCall_spec = 445, 
    RuleJava_spec = 446, RuleC_spec = 447, RuleC_agent_in_clause = 448, 
    RuleC_parameters_clause = 449, RuleParameter = 450, RuleDefault_value_part = 451, 
    RuleSeq_of_declare_specs = 452, RuleDeclare_spec = 453, RuleVariable_declaration = 454, 
    RuleSubtype_declaration = 455, RuleCursor_declaration = 456, RuleParameter_spec = 457, 
    RuleException_declaration = 458, RulePragma_declaration = 459, RuleRecord_type_def = 460, 
    RuleField_spec = 461, RuleRef_cursor_type_def = 462, RuleType_declaration = 463, 
    RuleTable_type_def = 464, RuleTable_indexed_by_part = 465, RuleVarray_type_def = 466, 
    RuleSeq_of_statements = 467, RuleLabel_declaration = 468, RuleStatement = 469, 
    RuleSwallow_to_semi = 470, RuleAssignment_statement = 471, RuleContinue_statement = 472, 
    RuleExit_statement = 473, RuleGoto_statement = 474, RuleIf_statement = 475, 
    RuleElsif_part = 476, RuleElse_part = 477, RuleLoop_statement = 478, 
    RuleCursor_loop_param = 479, RuleForall_statement = 480, RuleBounds_clause = 481, 
    RuleBetween_bound = 482, RuleLower_bound = 483, RuleUpper_bound = 484, 
    RuleNull_statement = 485, RuleRaise_statement = 486, RuleReturn_statement = 487, 
    RuleFunction_call = 488, RuleProcedure_call = 489, RulePipe_row_statement = 490, 
    RuleBody = 491, RuleException_handler = 492, RuleTrigger_block = 493, 
    RuleBlock = 494, RuleSql_statement = 495, RuleExecute_immediate = 496, 
    RuleDynamic_returning_clause = 497, RuleData_manipulation_language_statements = 498, 
    RuleCursor_manipulation_statements = 499, RuleClose_statement = 500, 
    RuleOpen_statement = 501, RuleFetch_statement = 502, RuleOpen_for_statement = 503, 
    RuleTransaction_control_statements = 504, RuleSet_transaction_command = 505, 
    RuleSet_constraint_command = 506, RuleCommit_statement = 507, RuleWrite_clause = 508, 
    RuleRollback_statement = 509, RuleSavepoint_statement = 510, RuleExplain_statement = 511, 
    RuleSelect_statement = 512, RuleSubquery_factoring_clause = 513, RuleFactoring_element = 514, 
    RuleSearch_clause = 515, RuleCycle_clause = 516, RuleSubquery = 517, 
    RuleSubquery_basic_elements = 518, RuleSubquery_operation_part = 519, 
    RuleQuery_block = 520, RuleSelected_list = 521, RuleSelected_list_element = 522, 
    RuleFrom_clause = 523, RuleSelect_list_elements = 524, RuleTable_ref_list = 525, 
    RuleTable_ref = 526, RuleTable_ref_aux = 527, RuleTable_ref_aux_internal = 528, 
    RuleJoin_clause = 529, RuleJoin_on_part = 530, RuleJoin_using_part = 531, 
    RuleOuter_join_type = 532, RuleQuery_partition_clause = 533, RuleFlashback_query_clause = 534, 
    RulePivot_clause = 535, RulePivot_element = 536, RulePivot_for_clause = 537, 
    RulePivot_in_clause = 538, RulePivot_in_clause_element = 539, RulePivot_in_clause_elements = 540, 
    RuleUnpivot_clause = 541, RuleUnpivot_in_clause = 542, RuleUnpivot_in_elements = 543, 
    RuleHierarchical_query_clause = 544, RuleStart_part = 545, RuleGroup_by_clause = 546, 
    RuleGroup_by_elements = 547, RuleRollup_cube_clause = 548, RuleGrouping_sets_clause = 549, 
    RuleGrouping_sets_elements = 550, RuleHaving_clause = 551, RuleModel_clause = 552, 
    RuleCell_reference_options = 553, RuleReturn_rows_clause = 554, RuleReference_model = 555, 
    RuleMain_model = 556, RuleModel_column_clauses = 557, RuleModel_column_partition_part = 558, 
    RuleModel_column_list = 559, RuleModel_column = 560, RuleModel_rules_clause = 561, 
    RuleModel_rules_part = 562, RuleModel_rules_element = 563, RuleCell_assignment = 564, 
    RuleModel_iterate_clause = 565, RuleUntil_part = 566, RuleOrder_by_clause = 567, 
    RuleOrder_by_elements = 568, RuleOffset_clause = 569, RuleFetch_clause = 570, 
    RuleFor_update_clause = 571, RuleFor_update_of_part = 572, RuleFor_update_options = 573, 
    RuleUpdate_statement = 574, RuleUpdate_set_clause = 575, RuleColumn_based_update_set_clause = 576, 
    RuleDelete_statement = 577, RuleInsert_statement = 578, RuleSingle_table_insert = 579, 
    RuleMulti_table_insert = 580, RuleMulti_table_element = 581, RuleConditional_insert_clause = 582, 
    RuleConditional_insert_when_part = 583, RuleConditional_insert_else_part = 584, 
    RuleInsert_into_clause = 585, RuleValues_clause = 586, RuleMerge_statement = 587, 
    RuleMerge_update_clause = 588, RuleMerge_element = 589, RuleMerge_update_delete_part = 590, 
    RuleMerge_insert_clause = 591, RuleSelected_tableview = 592, RuleLock_table_statement = 593, 
    RuleWait_nowait_part = 594, RuleLock_table_element = 595, RuleLock_mode = 596, 
    RuleGeneral_table_ref = 597, RuleStatic_returning_clause = 598, RuleError_logging_clause = 599, 
    RuleError_logging_into_part = 600, RuleError_logging_reject_part = 601, 
    RuleDml_table_expression_clause = 602, RuleTable_collection_expression = 603, 
    RuleSubquery_restriction_clause = 604, RuleSample_clause = 605, RuleSeed_part = 606, 
    RuleCondition = 607, RuleExpressions = 608, RuleExpression = 609, RuleCursor_expression = 610, 
    RuleLogical_expression = 611, RuleMultiset_expression = 612, RuleRelational_expression = 613, 
    RuleCompound_expression = 614, RuleRelational_operator = 615, RuleIn_elements = 616, 
    RuleBetween_elements = 617, RuleConcatenation = 618, RuleInterval_expression = 619, 
    RuleModel_expression = 620, RuleModel_expression_element = 621, RuleSingle_column_for_loop = 622, 
    RuleMulti_column_for_loop = 623, RuleUnary_expression = 624, RuleCase_statement = 625, 
    RuleSimple_case_statement = 626, RuleSimple_case_when_part = 627, RuleSearched_case_statement = 628, 
    RuleSearched_case_when_part = 629, RuleCase_else_part = 630, RuleAtom = 631, 
    RuleQuantified_expression = 632, RuleString_function = 633, RuleStandard_function = 634, 
    RuleLiteral = 635, RuleNumeric_function_wrapper = 636, RuleNumeric_function = 637, 
    RuleOther_function = 638, RuleOver_clause_keyword = 639, RuleWithin_or_over_clause_keyword = 640, 
    RuleStandard_prediction_function_keyword = 641, RuleOver_clause = 642, 
    RuleWindowing_clause = 643, RuleWindowing_type = 644, RuleWindowing_elements = 645, 
    RuleUsing_clause = 646, RuleUsing_element = 647, RuleCollect_order_by_part = 648, 
    RuleWithin_or_over_part = 649, RuleCost_matrix_clause = 650, RuleXml_passing_clause = 651, 
    RuleXml_attributes_clause = 652, RuleXml_namespaces_clause = 653, RuleXml_table_column = 654, 
    RuleXml_general_default_part = 655, RuleXml_multiuse_expression_element = 656, 
    RuleXmlroot_param_version_part = 657, RuleXmlroot_param_standalone_part = 658, 
    RuleXmlserialize_param_enconding_part = 659, RuleXmlserialize_param_version_part = 660, 
    RuleXmlserialize_param_ident_part = 661, RuleSql_plus_command = 662, 
    RuleWhenever_command = 663, RuleSet_command = 664, RulePartition_extension_clause = 665, 
    RuleColumn_alias = 666, RuleTable_alias = 667, RuleWhere_clause = 668, 
    RuleInto_clause = 669, RuleXml_column_name = 670, RuleCost_class_name = 671, 
    RuleAttribute_name = 672, RuleSavepoint_name = 673, RuleRollback_segment_name = 674, 
    RuleTable_var_name = 675, RuleSchema_name = 676, RuleRoutine_name = 677, 
    RulePackage_name = 678, RuleImplementation_type_name = 679, RuleParameter_name = 680, 
    RuleReference_model_name = 681, RuleMain_model_name = 682, RuleContainer_tableview_name = 683, 
    RuleAggregate_function_name = 684, RuleQuery_name = 685, RuleGrantee_name = 686, 
    RuleRole_name = 687, RuleConstraint_name = 688, RuleLabel_name = 689, 
    RuleType_name = 690, RuleSequence_name = 691, RuleException_name = 692, 
    RuleFunction_name = 693, RuleProcedure_name = 694, RuleTrigger_name = 695, 
    RuleVariable_name = 696, RuleIndex_name = 697, RuleCursor_name = 698, 
    RuleRecord_name = 699, RuleCollection_name = 700, RuleLink_name = 701, 
    RuleColumn_name = 702, RuleTableview_name = 703, RuleChar_set_name = 704, 
    RuleSynonym_name = 705, RuleSchema_object_name = 706, RuleDir_object_name = 707, 
    RuleUser_object_name = 708, RuleGrant_object_name = 709, RuleColumn_list = 710, 
    RuleParen_column_list = 711, RuleKeep_clause = 712, RuleFunction_argument = 713, 
    RuleFunction_argument_analytic = 714, RuleFunction_argument_modeling = 715, 
    RuleRespect_or_ignore_nulls = 716, RuleArgument = 717, RuleType_spec = 718, 
    RuleDatatype = 719, RulePrecision_part = 720, RuleNative_datatype_element = 721, 
    RuleBind_variable = 722, RuleGeneral_element = 723, RuleGeneral_element_part = 724, 
    RuleTable_element = 725, RuleObject_privilege = 726, RuleSystem_privilege = 727, 
    RuleConstant = 728, RuleNumeric = 729, RuleNumeric_negative = 730, RuleQuoted_string = 731, 
    RuleIdentifier = 732, RuleId_expression = 733, RuleOuter_join_sign = 734, 
    RuleRegular_id = 735, RuleNon_reserved_keywords_in_12c = 736, RuleNon_reserved_keywords_pre12c = 737, 
    RuleString_function_name = 738, RuleNumeric_function_name = 739
  };

  PlSqlParser(antlr4::TokenStream *input);
  ~PlSqlParser();

  virtual std::string getGrammarFileName() const override;
  virtual const antlr4::atn::ATN& getATN() const override { return _atn; };
  virtual const std::vector<std::string>& getTokenNames() const override { return _tokenNames; }; // deprecated: use vocabulary instead.
  virtual const std::vector<std::string>& getRuleNames() const override;
  virtual antlr4::dfa::Vocabulary& getVocabulary() const override;


  class Sql_scriptContext;
  class Unit_statementContext;
  class Select_expr_statementContext;
  class Drop_functionContext;
  class Alter_functionContext;
  class Create_function_bodyContext;
  class Parallel_enable_clauseContext;
  class Partition_by_clauseContext;
  class Result_cache_clauseContext;
  class Relies_on_partContext;
  class Streaming_clauseContext;
  class Drop_packageContext;
  class Alter_packageContext;
  class Create_packageContext;
  class Create_package_bodyContext;
  class Package_obj_specContext;
  class Procedure_specContext;
  class Function_specContext;
  class Package_obj_bodyContext;
  class Drop_procedureContext;
  class Alter_procedureContext;
  class Function_bodyContext;
  class Procedure_bodyContext;
  class Create_procedure_bodyContext;
  class Drop_triggerContext;
  class Alter_triggerContext;
  class Create_triggerContext;
  class Trigger_follows_clauseContext;
  class Trigger_when_clauseContext;
  class Simple_dml_triggerContext;
  class For_each_rowContext;
  class Compound_dml_triggerContext;
  class Non_dml_triggerContext;
  class Trigger_bodyContext;
  class Routine_clauseContext;
  class Compound_trigger_blockContext;
  class Timing_point_sectionContext;
  class Non_dml_eventContext;
  class Dml_event_clauseContext;
  class Dml_event_elementContext;
  class Dml_event_nested_clauseContext;
  class Referencing_clauseContext;
  class Referencing_elementContext;
  class Drop_typeContext;
  class Alter_typeContext;
  class Compile_type_clauseContext;
  class Replace_type_clauseContext;
  class Alter_method_specContext;
  class Alter_method_elementContext;
  class Alter_attribute_definitionContext;
  class Attribute_definitionContext;
  class Alter_collection_clausesContext;
  class Dependent_handling_clauseContext;
  class Dependent_exceptions_partContext;
  class Create_typeContext;
  class Type_definitionContext;
  class Object_type_defContext;
  class Object_as_partContext;
  class Object_under_partContext;
  class Nested_table_type_defContext;
  class Sqlj_object_typeContext;
  class Type_bodyContext;
  class Type_body_elementsContext;
  class Map_order_func_declarationContext;
  class Subprog_decl_in_typeContext;
  class Proc_decl_in_typeContext;
  class Func_decl_in_typeContext;
  class Constructor_declarationContext;
  class Modifier_clauseContext;
  class Object_member_specContext;
  class Sqlj_object_type_attrContext;
  class Element_specContext;
  class Element_spec_optionsContext;
  class Subprogram_specContext;
  class Overriding_subprogram_specContext;
  class Overriding_function_specContext;
  class Type_procedure_specContext;
  class Type_function_specContext;
  class Constructor_specContext;
  class Map_order_function_specContext;
  class Pragma_clauseContext;
  class Pragma_elementsContext;
  class Type_elements_parameterContext;
  class Drop_sequenceContext;
  class Alter_sequenceContext;
  class Alter_sessionContext;
  class Alter_session_set_clauseContext;
  class Create_sequenceContext;
  class Sequence_specContext;
  class Sequence_start_clauseContext;
  class Create_indexContext;
  class Cluster_index_clauseContext;
  class Cluster_nameContext;
  class Table_index_clauseContext;
  class Bitmap_join_index_clauseContext;
  class Index_exprContext;
  class Index_propertiesContext;
  class Domain_index_clauseContext;
  class Local_domain_index_clauseContext;
  class Xmlindex_clauseContext;
  class Local_xmlindex_clauseContext;
  class Global_partitioned_indexContext;
  class Index_partitioning_clauseContext;
  class Local_partitioned_indexContext;
  class On_range_partitioned_tableContext;
  class On_list_partitioned_tableContext;
  class On_hash_partitioned_tableContext;
  class On_comp_partitioned_tableContext;
  class Index_subpartition_clauseContext;
  class Odci_parametersContext;
  class IndextypeContext;
  class Alter_indexContext;
  class Alter_index_ops_set1Context;
  class Alter_index_ops_set2Context;
  class Visible_or_invisibleContext;
  class Monitoring_nomonitoringContext;
  class Rebuild_clauseContext;
  class Alter_index_partitioningContext;
  class Modify_index_default_attrsContext;
  class Add_hash_index_partitionContext;
  class Coalesce_index_partitionContext;
  class Modify_index_partitionContext;
  class Modify_index_partitions_opsContext;
  class Rename_index_partitionContext;
  class Drop_index_partitionContext;
  class Split_index_partitionContext;
  class Index_partition_descriptionContext;
  class Modify_index_subpartitionContext;
  class Partition_name_oldContext;
  class New_partition_nameContext;
  class New_index_nameContext;
  class Create_userContext;
  class Alter_userContext;
  class Alter_identified_byContext;
  class Identified_byContext;
  class Identified_other_clauseContext;
  class User_tablespace_clauseContext;
  class Quota_clauseContext;
  class Profile_clauseContext;
  class Role_clauseContext;
  class User_default_role_clauseContext;
  class Password_expire_clauseContext;
  class User_lock_clauseContext;
  class User_editions_clauseContext;
  class Alter_user_editions_clauseContext;
  class Proxy_clauseContext;
  class Container_namesContext;
  class Set_container_dataContext;
  class Add_rem_container_dataContext;
  class Container_data_clauseContext;
  class AnalyzeContext;
  class Partition_extention_clauseContext;
  class Validation_clausesContext;
  class Online_or_offlineContext;
  class Into_clause1Context;
  class Partition_key_valueContext;
  class Subpartition_key_valueContext;
  class Associate_statisticsContext;
  class Column_associationContext;
  class Function_associationContext;
  class Indextype_nameContext;
  class Using_statistics_typeContext;
  class Statistics_type_nameContext;
  class Default_cost_clauseContext;
  class Cpu_costContext;
  class Io_costContext;
  class Network_costContext;
  class Default_selectivity_clauseContext;
  class Default_selectivityContext;
  class Storage_table_clauseContext;
  class Unified_auditingContext;
  class Policy_nameContext;
  class Audit_traditionalContext;
  class Audit_direct_pathContext;
  class Audit_container_clauseContext;
  class Audit_operation_clauseContext;
  class Auditing_by_clauseContext;
  class Audit_userContext;
  class Audit_schema_object_clauseContext;
  class Sql_operationContext;
  class Auditing_on_clauseContext;
  class Model_nameContext;
  class Object_nameContext;
  class Profile_nameContext;
  class Sql_statement_shortcutContext;
  class Drop_indexContext;
  class Grant_statementContext;
  class Container_clauseContext;
  class Create_directoryContext;
  class Directory_nameContext;
  class Directory_pathContext;
  class Alter_libraryContext;
  class Library_editionableContext;
  class Library_debugContext;
  class Compiler_parameters_clauseContext;
  class Parameter_valueContext;
  class Library_nameContext;
  class Alter_viewContext;
  class Alter_view_editionableContext;
  class Create_viewContext;
  class View_optionsContext;
  class View_alias_constraintContext;
  class Object_view_clauseContext;
  class Inline_constraintContext;
  class Inline_ref_constraintContext;
  class Out_of_line_ref_constraintContext;
  class Out_of_line_constraintContext;
  class Constraint_stateContext;
  class Alter_tablespaceContext;
  class Datafile_tempfile_clausesContext;
  class Tablespace_logging_clausesContext;
  class Tablespace_group_clauseContext;
  class Tablespace_group_nameContext;
  class Tablespace_state_clausesContext;
  class Flashback_mode_clauseContext;
  class New_tablespace_nameContext;
  class Create_tablespaceContext;
  class Permanent_tablespace_clauseContext;
  class Tablespace_encryption_specContext;
  class Logging_clauseContext;
  class Extent_management_clauseContext;
  class Segment_management_clauseContext;
  class Temporary_tablespace_clauseContext;
  class Undo_tablespace_clauseContext;
  class Tablespace_retention_clauseContext;
  class Datafile_specificationContext;
  class Tempfile_specificationContext;
  class Datafile_tempfile_specContext;
  class Redo_log_file_specContext;
  class Autoextend_clauseContext;
  class Maxsize_clauseContext;
  class Build_clauseContext;
  class Parallel_clauseContext;
  class Alter_materialized_viewContext;
  class Alter_mv_option1Context;
  class Alter_mv_refreshContext;
  class Rollback_segmentContext;
  class Modify_mv_column_clauseContext;
  class Alter_materialized_view_logContext;
  class Add_mv_log_column_clauseContext;
  class Move_mv_log_clauseContext;
  class Mv_log_augmentationContext;
  class Datetime_exprContext;
  class Interval_exprContext;
  class Synchronous_or_asynchronousContext;
  class Including_or_excludingContext;
  class Create_materialized_view_logContext;
  class New_values_clauseContext;
  class Mv_log_purge_clauseContext;
  class Create_materialized_viewContext;
  class Create_mv_refreshContext;
  class Create_contextContext;
  class Oracle_namespaceContext;
  class Create_clusterContext;
  class Create_tableContext;
  class Xmltype_tableContext;
  class Xmltype_virtual_columnsContext;
  class Xmltype_column_propertiesContext;
  class Xmltype_storageContext;
  class Xmlschema_specContext;
  class Object_tableContext;
  class Oid_index_clauseContext;
  class Oid_clauseContext;
  class Object_propertiesContext;
  class Object_table_substitutionContext;
  class Relational_tableContext;
  class Relational_propertiesContext;
  class Table_partitioning_clausesContext;
  class Range_partitionsContext;
  class List_partitionsContext;
  class Hash_partitionsContext;
  class Individual_hash_partitionsContext;
  class Hash_partitions_by_quantityContext;
  class Hash_partition_quantityContext;
  class Composite_range_partitionsContext;
  class Composite_list_partitionsContext;
  class Composite_hash_partitionsContext;
  class Reference_partitioningContext;
  class Reference_partition_descContext;
  class System_partitioningContext;
  class Range_partition_descContext;
  class List_partition_descContext;
  class Subpartition_templateContext;
  class Hash_subpartition_quantityContext;
  class Subpartition_by_rangeContext;
  class Subpartition_by_listContext;
  class Subpartition_by_hashContext;
  class Subpartition_nameContext;
  class Range_subpartition_descContext;
  class List_subpartition_descContext;
  class Individual_hash_subpartsContext;
  class Hash_subparts_by_quantityContext;
  class Range_values_clauseContext;
  class List_values_clauseContext;
  class Table_partition_descriptionContext;
  class Partitioning_storage_clauseContext;
  class Lob_partitioning_storageContext;
  class Datatype_null_enableContext;
  class Size_clauseContext;
  class Table_compressionContext;
  class Physical_attributes_clauseContext;
  class Storage_clauseContext;
  class Deferred_segment_creationContext;
  class Segment_attributes_clauseContext;
  class Physical_propertiesContext;
  class Row_movement_clauseContext;
  class Flashback_archive_clauseContext;
  class Log_grpContext;
  class Supplemental_table_loggingContext;
  class Supplemental_log_grp_clauseContext;
  class Supplemental_id_key_clauseContext;
  class Allocate_extent_clauseContext;
  class Deallocate_unused_clauseContext;
  class Shrink_clauseContext;
  class Records_per_block_clauseContext;
  class Upgrade_table_clauseContext;
  class Drop_tableContext;
  class Comment_on_columnContext;
  class Enable_or_disableContext;
  class Allow_or_disallowContext;
  class Create_synonymContext;
  class Comment_on_tableContext;
  class Alter_clusterContext;
  class Cache_or_nocacheContext;
  class Database_nameContext;
  class Alter_databaseContext;
  class Startup_clausesContext;
  class Resetlogs_or_noresetlogsContext;
  class Upgrade_or_downgradeContext;
  class Recovery_clausesContext;
  class Begin_or_endContext;
  class General_recoveryContext;
  class Full_database_recoveryContext;
  class Partial_database_recoveryContext;
  class Partial_database_recovery_10gContext;
  class Managed_standby_recoveryContext;
  class Db_nameContext;
  class Database_file_clausesContext;
  class Create_datafile_clauseContext;
  class Alter_datafile_clauseContext;
  class Alter_tempfile_clauseContext;
  class Logfile_clausesContext;
  class Add_logfile_clausesContext;
  class Log_file_groupContext;
  class Drop_logfile_clausesContext;
  class Switch_logfile_clauseContext;
  class Supplemental_db_loggingContext;
  class Add_or_dropContext;
  class Supplemental_plsql_clauseContext;
  class Logfile_descriptorContext;
  class Controlfile_clausesContext;
  class Trace_file_clauseContext;
  class Standby_database_clausesContext;
  class Activate_standby_db_clauseContext;
  class Maximize_standby_db_clauseContext;
  class Register_logfile_clauseContext;
  class Commit_switchover_clauseContext;
  class Start_standby_clauseContext;
  class Stop_standby_clauseContext;
  class Convert_database_clauseContext;
  class Default_settings_clauseContext;
  class Set_time_zone_clauseContext;
  class Instance_clausesContext;
  class Security_clauseContext;
  class DomainContext;
  class DatabaseContext;
  class Edition_nameContext;
  class FilenumberContext;
  class FilenameContext;
  class Alter_tableContext;
  class Alter_table_propertiesContext;
  class Alter_table_properties_1Context;
  class Alter_iot_clausesContext;
  class Alter_mapping_table_clauseContext;
  class Alter_overflow_clauseContext;
  class Add_overflow_clauseContext;
  class Enable_disable_clauseContext;
  class Using_index_clauseContext;
  class Index_attributesContext;
  class Sort_or_nosortContext;
  class Exceptions_clauseContext;
  class Move_table_clauseContext;
  class Index_org_table_clauseContext;
  class Mapping_table_clauseContext;
  class Key_compressionContext;
  class Index_org_overflow_clauseContext;
  class Column_clausesContext;
  class Modify_collection_retrievalContext;
  class Collection_itemContext;
  class Rename_column_clauseContext;
  class Old_column_nameContext;
  class New_column_nameContext;
  class Add_modify_drop_column_clausesContext;
  class Drop_column_clauseContext;
  class Modify_column_clausesContext;
  class Modify_col_propertiesContext;
  class Modify_col_substitutableContext;
  class Add_column_clauseContext;
  class Alter_varray_col_propertiesContext;
  class Varray_col_propertiesContext;
  class Varray_storage_clauseContext;
  class Lob_segnameContext;
  class Lob_itemContext;
  class Lob_storage_parametersContext;
  class Lob_storage_clauseContext;
  class Modify_lob_storage_clauseContext;
  class Modify_lob_parametersContext;
  class Lob_parametersContext;
  class Lob_deduplicate_clauseContext;
  class Lob_compression_clauseContext;
  class Lob_retention_clauseContext;
  class Encryption_specContext;
  class TablespaceContext;
  class Varray_itemContext;
  class Column_propertiesContext;
  class Period_definitionContext;
  class Start_time_columnContext;
  class End_time_columnContext;
  class Column_definitionContext;
  class Virtual_column_definitionContext;
  class Out_of_line_part_storageContext;
  class Nested_table_col_propertiesContext;
  class Nested_itemContext;
  class Substitutable_column_clauseContext;
  class Partition_nameContext;
  class Supplemental_logging_propsContext;
  class Column_or_attributeContext;
  class Object_type_col_propertiesContext;
  class Constraint_clausesContext;
  class Old_constraint_nameContext;
  class New_constraint_nameContext;
  class Drop_constraint_clauseContext;
  class Drop_primary_key_or_unique_or_generic_clauseContext;
  class Add_constraintContext;
  class Check_constraintContext;
  class Drop_constraintContext;
  class Enable_constraintContext;
  class Disable_constraintContext;
  class Foreign_key_clauseContext;
  class References_clauseContext;
  class On_delete_clauseContext;
  class Unique_key_clauseContext;
  class Primary_key_clauseContext;
  class Anonymous_blockContext;
  class Invoker_rights_clauseContext;
  class Call_specContext;
  class Java_specContext;
  class C_specContext;
  class C_agent_in_clauseContext;
  class C_parameters_clauseContext;
  class ParameterContext;
  class Default_value_partContext;
  class Seq_of_declare_specsContext;
  class Declare_specContext;
  class Variable_declarationContext;
  class Subtype_declarationContext;
  class Cursor_declarationContext;
  class Parameter_specContext;
  class Exception_declarationContext;
  class Pragma_declarationContext;
  class Record_type_defContext;
  class Field_specContext;
  class Ref_cursor_type_defContext;
  class Type_declarationContext;
  class Table_type_defContext;
  class Table_indexed_by_partContext;
  class Varray_type_defContext;
  class Seq_of_statementsContext;
  class Label_declarationContext;
  class StatementContext;
  class Swallow_to_semiContext;
  class Assignment_statementContext;
  class Continue_statementContext;
  class Exit_statementContext;
  class Goto_statementContext;
  class If_statementContext;
  class Elsif_partContext;
  class Else_partContext;
  class Loop_statementContext;
  class Cursor_loop_paramContext;
  class Forall_statementContext;
  class Bounds_clauseContext;
  class Between_boundContext;
  class Lower_boundContext;
  class Upper_boundContext;
  class Null_statementContext;
  class Raise_statementContext;
  class Return_statementContext;
  class Function_callContext;
  class Procedure_callContext;
  class Pipe_row_statementContext;
  class BodyContext;
  class Exception_handlerContext;
  class Trigger_blockContext;
  class BlockContext;
  class Sql_statementContext;
  class Execute_immediateContext;
  class Dynamic_returning_clauseContext;
  class Data_manipulation_language_statementsContext;
  class Cursor_manipulation_statementsContext;
  class Close_statementContext;
  class Open_statementContext;
  class Fetch_statementContext;
  class Open_for_statementContext;
  class Transaction_control_statementsContext;
  class Set_transaction_commandContext;
  class Set_constraint_commandContext;
  class Commit_statementContext;
  class Write_clauseContext;
  class Rollback_statementContext;
  class Savepoint_statementContext;
  class Explain_statementContext;
  class Select_statementContext;
  class Subquery_factoring_clauseContext;
  class Factoring_elementContext;
  class Search_clauseContext;
  class Cycle_clauseContext;
  class SubqueryContext;
  class Subquery_basic_elementsContext;
  class Subquery_operation_partContext;
  class Query_blockContext;
  class Selected_listContext;
  class Selected_list_elementContext;
  class From_clauseContext;
  class Select_list_elementsContext;
  class Table_ref_listContext;
  class Table_refContext;
  class Table_ref_auxContext;
  class Table_ref_aux_internalContext;
  class Join_clauseContext;
  class Join_on_partContext;
  class Join_using_partContext;
  class Outer_join_typeContext;
  class Query_partition_clauseContext;
  class Flashback_query_clauseContext;
  class Pivot_clauseContext;
  class Pivot_elementContext;
  class Pivot_for_clauseContext;
  class Pivot_in_clauseContext;
  class Pivot_in_clause_elementContext;
  class Pivot_in_clause_elementsContext;
  class Unpivot_clauseContext;
  class Unpivot_in_clauseContext;
  class Unpivot_in_elementsContext;
  class Hierarchical_query_clauseContext;
  class Start_partContext;
  class Group_by_clauseContext;
  class Group_by_elementsContext;
  class Rollup_cube_clauseContext;
  class Grouping_sets_clauseContext;
  class Grouping_sets_elementsContext;
  class Having_clauseContext;
  class Model_clauseContext;
  class Cell_reference_optionsContext;
  class Return_rows_clauseContext;
  class Reference_modelContext;
  class Main_modelContext;
  class Model_column_clausesContext;
  class Model_column_partition_partContext;
  class Model_column_listContext;
  class Model_columnContext;
  class Model_rules_clauseContext;
  class Model_rules_partContext;
  class Model_rules_elementContext;
  class Cell_assignmentContext;
  class Model_iterate_clauseContext;
  class Until_partContext;
  class Order_by_clauseContext;
  class Order_by_elementsContext;
  class Offset_clauseContext;
  class Fetch_clauseContext;
  class For_update_clauseContext;
  class For_update_of_partContext;
  class For_update_optionsContext;
  class Update_statementContext;
  class Update_set_clauseContext;
  class Column_based_update_set_clauseContext;
  class Delete_statementContext;
  class Insert_statementContext;
  class Single_table_insertContext;
  class Multi_table_insertContext;
  class Multi_table_elementContext;
  class Conditional_insert_clauseContext;
  class Conditional_insert_when_partContext;
  class Conditional_insert_else_partContext;
  class Insert_into_clauseContext;
  class Values_clauseContext;
  class Merge_statementContext;
  class Merge_update_clauseContext;
  class Merge_elementContext;
  class Merge_update_delete_partContext;
  class Merge_insert_clauseContext;
  class Selected_tableviewContext;
  class Lock_table_statementContext;
  class Wait_nowait_partContext;
  class Lock_table_elementContext;
  class Lock_modeContext;
  class General_table_refContext;
  class Static_returning_clauseContext;
  class Error_logging_clauseContext;
  class Error_logging_into_partContext;
  class Error_logging_reject_partContext;
  class Dml_table_expression_clauseContext;
  class Table_collection_expressionContext;
  class Subquery_restriction_clauseContext;
  class Sample_clauseContext;
  class Seed_partContext;
  class ConditionContext;
  class ExpressionsContext;
  class ExpressionContext;
  class Cursor_expressionContext;
  class Logical_expressionContext;
  class Multiset_expressionContext;
  class Relational_expressionContext;
  class Compound_expressionContext;
  class Relational_operatorContext;
  class In_elementsContext;
  class Between_elementsContext;
  class ConcatenationContext;
  class Interval_expressionContext;
  class Model_expressionContext;
  class Model_expression_elementContext;
  class Single_column_for_loopContext;
  class Multi_column_for_loopContext;
  class Unary_expressionContext;
  class Case_statementContext;
  class Simple_case_statementContext;
  class Simple_case_when_partContext;
  class Searched_case_statementContext;
  class Searched_case_when_partContext;
  class Case_else_partContext;
  class AtomContext;
  class Quantified_expressionContext;
  class String_functionContext;
  class Standard_functionContext;
  class LiteralContext;
  class Numeric_function_wrapperContext;
  class Numeric_functionContext;
  class Other_functionContext;
  class Over_clause_keywordContext;
  class Within_or_over_clause_keywordContext;
  class Standard_prediction_function_keywordContext;
  class Over_clauseContext;
  class Windowing_clauseContext;
  class Windowing_typeContext;
  class Windowing_elementsContext;
  class Using_clauseContext;
  class Using_elementContext;
  class Collect_order_by_partContext;
  class Within_or_over_partContext;
  class Cost_matrix_clauseContext;
  class Xml_passing_clauseContext;
  class Xml_attributes_clauseContext;
  class Xml_namespaces_clauseContext;
  class Xml_table_columnContext;
  class Xml_general_default_partContext;
  class Xml_multiuse_expression_elementContext;
  class Xmlroot_param_version_partContext;
  class Xmlroot_param_standalone_partContext;
  class Xmlserialize_param_enconding_partContext;
  class Xmlserialize_param_version_partContext;
  class Xmlserialize_param_ident_partContext;
  class Sql_plus_commandContext;
  class Whenever_commandContext;
  class Set_commandContext;
  class Partition_extension_clauseContext;
  class Column_aliasContext;
  class Table_aliasContext;
  class Where_clauseContext;
  class Into_clauseContext;
  class Xml_column_nameContext;
  class Cost_class_nameContext;
  class Attribute_nameContext;
  class Savepoint_nameContext;
  class Rollback_segment_nameContext;
  class Table_var_nameContext;
  class Schema_nameContext;
  class Routine_nameContext;
  class Package_nameContext;
  class Implementation_type_nameContext;
  class Parameter_nameContext;
  class Reference_model_nameContext;
  class Main_model_nameContext;
  class Container_tableview_nameContext;
  class Aggregate_function_nameContext;
  class Query_nameContext;
  class Grantee_nameContext;
  class Role_nameContext;
  class Constraint_nameContext;
  class Label_nameContext;
  class Type_nameContext;
  class Sequence_nameContext;
  class Exception_nameContext;
  class Function_nameContext;
  class Procedure_nameContext;
  class Trigger_nameContext;
  class Variable_nameContext;
  class Index_nameContext;
  class Cursor_nameContext;
  class Record_nameContext;
  class Collection_nameContext;
  class Link_nameContext;
  class Column_nameContext;
  class Tableview_nameContext;
  class Char_set_nameContext;
  class Synonym_nameContext;
  class Schema_object_nameContext;
  class Dir_object_nameContext;
  class User_object_nameContext;
  class Grant_object_nameContext;
  class Column_listContext;
  class Paren_column_listContext;
  class Keep_clauseContext;
  class Function_argumentContext;
  class Function_argument_analyticContext;
  class Function_argument_modelingContext;
  class Respect_or_ignore_nullsContext;
  class ArgumentContext;
  class Type_specContext;
  class DatatypeContext;
  class Precision_partContext;
  class Native_datatype_elementContext;
  class Bind_variableContext;
  class General_elementContext;
  class General_element_partContext;
  class Table_elementContext;
  class Object_privilegeContext;
  class System_privilegeContext;
  class ConstantContext;
  class NumericContext;
  class Numeric_negativeContext;
  class Quoted_stringContext;
  class IdentifierContext;
  class Id_expressionContext;
  class Outer_join_signContext;
  class Regular_idContext;
  class Non_reserved_keywords_in_12cContext;
  class Non_reserved_keywords_pre12cContext;
  class String_function_nameContext;
  class Numeric_function_nameContext; 

  class  Sql_scriptContext : public antlr4::ParserRuleContext {
  public:
    Sql_scriptContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EOF();
    std::vector<Unit_statementContext *> unit_statement();
    Unit_statementContext* unit_statement(size_t i);
    std::vector<Sql_plus_commandContext *> sql_plus_command();
    Sql_plus_commandContext* sql_plus_command(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEMICOLON();
    antlr4::tree::TerminalNode* SEMICOLON(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_scriptContext* sql_script();

  class  Unit_statementContext : public antlr4::ParserRuleContext {
  public:
    Unit_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Transaction_control_statementsContext *transaction_control_statements();
    Alter_clusterContext *alter_cluster();
    Alter_databaseContext *alter_database();
    Alter_functionContext *alter_function();
    Alter_packageContext *alter_package();
    Alter_procedureContext *alter_procedure();
    Alter_sequenceContext *alter_sequence();
    Alter_sessionContext *alter_session();
    Alter_triggerContext *alter_trigger();
    Alter_typeContext *alter_type();
    Alter_tableContext *alter_table();
    Alter_tablespaceContext *alter_tablespace();
    Alter_indexContext *alter_index();
    Alter_libraryContext *alter_library();
    Alter_materialized_viewContext *alter_materialized_view();
    Alter_materialized_view_logContext *alter_materialized_view_log();
    Alter_userContext *alter_user();
    Alter_viewContext *alter_view();
    AnalyzeContext *analyze();
    Associate_statisticsContext *associate_statistics();
    Audit_traditionalContext *audit_traditional();
    Unified_auditingContext *unified_auditing();
    Create_function_bodyContext *create_function_body();
    Create_procedure_bodyContext *create_procedure_body();
    Create_packageContext *create_package();
    Create_package_bodyContext *create_package_body();
    Create_indexContext *create_index();
    Create_tableContext *create_table();
    Create_tablespaceContext *create_tablespace();
    Create_clusterContext *create_cluster();
    Create_contextContext *create_context();
    Create_viewContext *create_view();
    Create_directoryContext *create_directory();
    Create_materialized_viewContext *create_materialized_view();
    Create_materialized_view_logContext *create_materialized_view_log();
    Create_userContext *create_user();
    Create_sequenceContext *create_sequence();
    Create_triggerContext *create_trigger();
    Create_typeContext *create_type();
    Create_synonymContext *create_synonym();
    Drop_functionContext *drop_function();
    Drop_packageContext *drop_package();
    Drop_procedureContext *drop_procedure();
    Drop_sequenceContext *drop_sequence();
    Drop_triggerContext *drop_trigger();
    Drop_typeContext *drop_type();
    Data_manipulation_language_statementsContext *data_manipulation_language_statements();
    Drop_tableContext *drop_table();
    Drop_indexContext *drop_index();
    Comment_on_columnContext *comment_on_column();
    Comment_on_tableContext *comment_on_table();
    Anonymous_blockContext *anonymous_block();
    Grant_statementContext *grant_statement();
    Procedure_callContext *procedure_call();
    Select_expr_statementContext *select_expr_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unit_statementContext* unit_statement();

  class  Select_expr_statementContext : public antlr4::ParserRuleContext {
  public:
    Select_expr_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SELECT();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Select_expr_statementContext* select_expr_statement();

  class  Drop_functionContext : public antlr4::ParserRuleContext {
  public:
    Drop_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *SEMICOLON();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_functionContext* drop_function();

  class  Alter_functionContext : public antlr4::ParserRuleContext {
  public:
    Alter_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_functionContext* alter_function();

  class  Create_function_bodyContext : public antlr4::ParserRuleContext {
  public:
    Create_function_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *USING();
    Implementation_type_nameContext *implementation_type_name();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Invoker_rights_clauseContext *> invoker_rights_clause();
    Invoker_rights_clauseContext* invoker_rights_clause(size_t i);
    std::vector<Parallel_enable_clauseContext *> parallel_enable_clause();
    Parallel_enable_clauseContext* parallel_enable_clause(size_t i);
    std::vector<Result_cache_clauseContext *> result_cache_clause();
    Result_cache_clauseContext* result_cache_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    BodyContext *body();
    Call_specContext *call_spec();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_function_bodyContext* create_function_body();

  class  Parallel_enable_clauseContext : public antlr4::ParserRuleContext {
  public:
    Parallel_enable_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARALLEL_ENABLE();
    Partition_by_clauseContext *partition_by_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parallel_enable_clauseContext* parallel_enable_clause();

  class  Partition_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partition_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *PARTITION();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ANY();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *LIST();
    Streaming_clauseContext *streaming_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_by_clauseContext* partition_by_clause();

  class  Result_cache_clauseContext : public antlr4::ParserRuleContext {
  public:
    Result_cache_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RESULT_CACHE();
    Relies_on_partContext *relies_on_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Result_cache_clauseContext* result_cache_clause();

  class  Relies_on_partContext : public antlr4::ParserRuleContext {
  public:
    Relies_on_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RELIES_ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relies_on_partContext* relies_on_part();

  class  Streaming_clauseContext : public antlr4::ParserRuleContext {
  public:
    Streaming_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *BY();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *CLUSTER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Streaming_clauseContext* streaming_clause();

  class  Drop_packageContext : public antlr4::ParserRuleContext {
  public:
    Drop_packageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PACKAGE();
    Package_nameContext *package_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *BODY();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_packageContext* drop_package();

  class  Alter_packageContext : public antlr4::ParserRuleContext {
  public:
    Alter_packageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    std::vector<antlr4::tree::TerminalNode *> PACKAGE();
    antlr4::tree::TerminalNode* PACKAGE(size_t i);
    Package_nameContext *package_name();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();
    antlr4::tree::TerminalNode *BODY();
    antlr4::tree::TerminalNode *SPECIFICATION();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_packageContext* alter_package();

  class  Create_packageContext : public antlr4::ParserRuleContext {
  public:
    Create_packageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PACKAGE();
    std::vector<Package_nameContext *> package_name();
    Package_nameContext* package_name(size_t i);
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();
    Invoker_rights_clauseContext *invoker_rights_clause();
    std::vector<Package_obj_specContext *> package_obj_spec();
    Package_obj_specContext* package_obj_spec(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_packageContext* create_package();

  class  Create_package_bodyContext : public antlr4::ParserRuleContext {
  public:
    Create_package_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PACKAGE();
    antlr4::tree::TerminalNode *BODY();
    std::vector<Package_nameContext *> package_name();
    Package_nameContext* package_name(size_t i);
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();
    std::vector<Package_obj_bodyContext *> package_obj_body();
    Package_obj_bodyContext* package_obj_body(size_t i);
    antlr4::tree::TerminalNode *BEGIN();
    Seq_of_statementsContext *seq_of_statements();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_package_bodyContext* create_package_body();

  class  Package_obj_specContext : public antlr4::ParserRuleContext {
  public:
    Package_obj_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pragma_declarationContext *pragma_declaration();
    Variable_declarationContext *variable_declaration();
    Subtype_declarationContext *subtype_declaration();
    Cursor_declarationContext *cursor_declaration();
    Exception_declarationContext *exception_declaration();
    Type_declarationContext *type_declaration();
    Procedure_specContext *procedure_spec();
    Function_specContext *function_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Package_obj_specContext* package_obj_spec();

  class  Procedure_specContext : public antlr4::ParserRuleContext {
  public:
    Procedure_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Procedure_specContext* procedure_spec();

  class  Function_specContext : public antlr4::ParserRuleContext {
  public:
    Function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DETERMINISTIC();
    antlr4::tree::TerminalNode *RESULT_CACHE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_specContext* function_spec();

  class  Package_obj_bodyContext : public antlr4::ParserRuleContext {
  public:
    Package_obj_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Variable_declarationContext *variable_declaration();
    Subtype_declarationContext *subtype_declaration();
    Cursor_declarationContext *cursor_declaration();
    Exception_declarationContext *exception_declaration();
    Type_declarationContext *type_declaration();
    Procedure_bodyContext *procedure_body();
    Function_bodyContext *function_body();
    Procedure_specContext *procedure_spec();
    Function_specContext *function_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Package_obj_bodyContext* package_obj_body();

  class  Drop_procedureContext : public antlr4::ParserRuleContext {
  public:
    Drop_procedureContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *SEMICOLON();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_procedureContext* drop_procedure();

  class  Alter_procedureContext : public antlr4::ParserRuleContext {
  public:
    Alter_procedureContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_procedureContext* alter_procedure();

  class  Function_bodyContext : public antlr4::ParserRuleContext {
  public:
    Function_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *USING();
    Implementation_type_nameContext *implementation_type_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Invoker_rights_clauseContext *> invoker_rights_clause();
    Invoker_rights_clauseContext* invoker_rights_clause(size_t i);
    std::vector<Parallel_enable_clauseContext *> parallel_enable_clause();
    Parallel_enable_clauseContext* parallel_enable_clause(size_t i);
    std::vector<Result_cache_clauseContext *> result_cache_clause();
    Result_cache_clauseContext* result_cache_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    BodyContext *body();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_bodyContext* function_body();

  class  Procedure_bodyContext : public antlr4::ParserRuleContext {
  public:
    Procedure_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    BodyContext *body();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Procedure_bodyContext* procedure_body();

  class  Create_procedure_bodyContext : public antlr4::ParserRuleContext {
  public:
    Create_procedure_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    BodyContext *body();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Invoker_rights_clauseContext *invoker_rights_clause();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_procedure_bodyContext* create_procedure_body();

  class  Drop_triggerContext : public antlr4::ParserRuleContext {
  public:
    Drop_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *TRIGGER();
    Trigger_nameContext *trigger_name();
    antlr4::tree::TerminalNode *SEMICOLON();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_triggerContext* drop_trigger();

  class  Alter_triggerContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Trigger_nameContext *alter_trigger_name = nullptr;;
    PlSqlParser::Trigger_nameContext *rename_trigger_name = nullptr;;
    Alter_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Trigger_nameContext *> trigger_name();
    Trigger_nameContext* trigger_name(size_t i);
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_triggerContext* alter_trigger();

  class  Create_triggerContext : public antlr4::ParserRuleContext {
  public:
    Create_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *TRIGGER();
    Trigger_nameContext *trigger_name();
    Trigger_bodyContext *trigger_body();
    antlr4::tree::TerminalNode *SEMICOLON();
    Simple_dml_triggerContext *simple_dml_trigger();
    Compound_dml_triggerContext *compound_dml_trigger();
    Non_dml_triggerContext *non_dml_trigger();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Trigger_follows_clauseContext *trigger_follows_clause();
    Trigger_when_clauseContext *trigger_when_clause();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_triggerContext* create_trigger();

  class  Trigger_follows_clauseContext : public antlr4::ParserRuleContext {
  public:
    Trigger_follows_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOLLOWS();
    std::vector<Trigger_nameContext *> trigger_name();
    Trigger_nameContext* trigger_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_follows_clauseContext* trigger_follows_clause();

  class  Trigger_when_clauseContext : public antlr4::ParserRuleContext {
  public:
    Trigger_when_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_when_clauseContext* trigger_when_clause();

  class  Simple_dml_triggerContext : public antlr4::ParserRuleContext {
  public:
    Simple_dml_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Dml_event_clauseContext *dml_event_clause();
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *INSTEAD();
    antlr4::tree::TerminalNode *OF();
    Referencing_clauseContext *referencing_clause();
    For_each_rowContext *for_each_row();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_dml_triggerContext* simple_dml_trigger();

  class  For_each_rowContext : public antlr4::ParserRuleContext {
  public:
    For_each_rowContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *EACH();
    antlr4::tree::TerminalNode *ROW();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_each_rowContext* for_each_row();

  class  Compound_dml_triggerContext : public antlr4::ParserRuleContext {
  public:
    Compound_dml_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Dml_event_clauseContext *dml_event_clause();
    Referencing_clauseContext *referencing_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compound_dml_triggerContext* compound_dml_trigger();

  class  Non_dml_triggerContext : public antlr4::ParserRuleContext {
  public:
    Non_dml_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Non_dml_eventContext *> non_dml_event();
    Non_dml_eventContext* non_dml_event(size_t i);
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *SCHEMA();
    std::vector<antlr4::tree::TerminalNode *> OR();
    antlr4::tree::TerminalNode* OR(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_dml_triggerContext* non_dml_trigger();

  class  Trigger_bodyContext : public antlr4::ParserRuleContext {
  public:
    Trigger_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPOUND();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *CALL();
    IdentifierContext *identifier();
    Trigger_blockContext *trigger_block();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_bodyContext* trigger_body();

  class  Routine_clauseContext : public antlr4::ParserRuleContext {
  public:
    Routine_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Routine_nameContext *routine_name();
    Function_argumentContext *function_argument();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Routine_clauseContext* routine_clause();

  class  Compound_trigger_blockContext : public antlr4::ParserRuleContext {
  public:
    Compound_trigger_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPOUND();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *END();
    Trigger_nameContext *trigger_name();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<Timing_point_sectionContext *> timing_point_section();
    Timing_point_sectionContext* timing_point_section(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compound_trigger_blockContext* compound_trigger_block();

  class  Timing_point_sectionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *bk = nullptr;;
    antlr4::Token *ak = nullptr;;
    Timing_point_sectionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> STATEMENT();
    antlr4::tree::TerminalNode* STATEMENT(size_t i);
    antlr4::tree::TerminalNode *IS();
    Trigger_blockContext *trigger_block();
    std::vector<antlr4::tree::TerminalNode *> BEFORE();
    antlr4::tree::TerminalNode* BEFORE(size_t i);
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<antlr4::tree::TerminalNode *> EACH();
    antlr4::tree::TerminalNode* EACH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROW();
    antlr4::tree::TerminalNode* ROW(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AFTER();
    antlr4::tree::TerminalNode* AFTER(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Timing_point_sectionContext* timing_point_section();

  class  Non_dml_eventContext : public antlr4::ParserRuleContext {
  public:
    Non_dml_eventContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *ASSOCIATE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DISASSOCIATE();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *NOAUDIT();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *REVOKE();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *DDL();
    antlr4::tree::TerminalNode *STARTUP();
    antlr4::tree::TerminalNode *SHUTDOWN();
    antlr4::tree::TerminalNode *DB_ROLE_CHANGE();
    antlr4::tree::TerminalNode *LOGON();
    antlr4::tree::TerminalNode *LOGOFF();
    antlr4::tree::TerminalNode *SERVERERROR();
    antlr4::tree::TerminalNode *SUSPEND();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *FOLLOWS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_dml_eventContext* non_dml_event();

  class  Dml_event_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dml_event_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Dml_event_elementContext *> dml_event_element();
    Dml_event_elementContext* dml_event_element(size_t i);
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    std::vector<antlr4::tree::TerminalNode *> OR();
    antlr4::tree::TerminalNode* OR(size_t i);
    Dml_event_nested_clauseContext *dml_event_nested_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_event_clauseContext* dml_event_clause();

  class  Dml_event_elementContext : public antlr4::ParserRuleContext {
  public:
    Dml_event_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *OF();
    Column_listContext *column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_event_elementContext* dml_event_element();

  class  Dml_event_nested_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dml_event_nested_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *OF();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_event_nested_clauseContext* dml_event_nested_clause();

  class  Referencing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Referencing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFERENCING();
    std::vector<Referencing_elementContext *> referencing_element();
    Referencing_elementContext* referencing_element(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Referencing_clauseContext* referencing_clause();

  class  Referencing_elementContext : public antlr4::ParserRuleContext {
  public:
    Referencing_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *OLD();
    antlr4::tree::TerminalNode *PARENT();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Referencing_elementContext* referencing_element();

  class  Drop_typeContext : public antlr4::ParserRuleContext {
  public:
    Drop_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *TYPE();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *BODY();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *VALIDATE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_typeContext* drop_type();

  class  Alter_typeContext : public antlr4::ParserRuleContext {
  public:
    Alter_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *TYPE();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    Compile_type_clauseContext *compile_type_clause();
    Replace_type_clauseContext *replace_type_clause();
    Alter_method_specContext *alter_method_spec();
    Alter_collection_clausesContext *alter_collection_clauses();
    Modifier_clauseContext *modifier_clause();
    Overriding_subprogram_specContext *overriding_subprogram_spec();
    Dependent_handling_clauseContext *dependent_handling_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_typeContext* alter_type();

  class  Compile_type_clauseContext : public antlr4::ParserRuleContext {
  public:
    Compile_type_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();
    antlr4::tree::TerminalNode *SPECIFICATION();
    antlr4::tree::TerminalNode *BODY();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compile_type_clauseContext* compile_type_clause();

  class  Replace_type_clauseContext : public antlr4::ParserRuleContext {
  public:
    Replace_type_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Object_member_specContext *> object_member_spec();
    Object_member_specContext* object_member_spec(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Invoker_rights_clauseContext *invoker_rights_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Replace_type_clauseContext* replace_type_clause();

  class  Alter_method_specContext : public antlr4::ParserRuleContext {
  public:
    Alter_method_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Alter_method_elementContext *> alter_method_element();
    Alter_method_elementContext* alter_method_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_method_specContext* alter_method_spec();

  class  Alter_method_elementContext : public antlr4::ParserRuleContext {
  public:
    Alter_method_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *DROP();
    Map_order_function_specContext *map_order_function_spec();
    Subprogram_specContext *subprogram_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_method_elementContext* alter_method_element();

  class  Alter_attribute_definitionContext : public antlr4::ParserRuleContext {
  public:
    Alter_attribute_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ATTRIBUTE();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *DROP();
    std::vector<Attribute_definitionContext *> attribute_definition();
    Attribute_definitionContext* attribute_definition(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_attribute_definitionContext* alter_attribute_definition();

  class  Attribute_definitionContext : public antlr4::ParserRuleContext {
  public:
    Attribute_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Attribute_nameContext *attribute_name();
    Type_specContext *type_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Attribute_definitionContext* attribute_definition();

  class  Alter_collection_clausesContext : public antlr4::ParserRuleContext {
  public:
    Alter_collection_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LIMIT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *TYPE();
    Type_specContext *type_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_collection_clausesContext* alter_collection_clauses();

  class  Dependent_handling_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dependent_handling_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INVALIDATE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *DATA();
    Dependent_exceptions_partContext *dependent_exceptions_part();
    antlr4::tree::TerminalNode *NOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dependent_handling_clauseContext* dependent_handling_clause();

  class  Dependent_exceptions_partContext : public antlr4::ParserRuleContext {
  public:
    Dependent_exceptions_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *FORCE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dependent_exceptions_partContext* dependent_exceptions_part();

  class  Create_typeContext : public antlr4::ParserRuleContext {
  public:
    Create_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *SEMICOLON();
    Type_definitionContext *type_definition();
    Type_bodyContext *type_body();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_typeContext* create_type();

  class  Type_definitionContext : public antlr4::ParserRuleContext {
  public:
    Type_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *OID();
    antlr4::tree::TerminalNode *CHAR_STRING();
    Object_type_defContext *object_type_def();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_definitionContext* type_definition();

  class  Object_type_defContext : public antlr4::ParserRuleContext {
  public:
    Object_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Object_as_partContext *object_as_part();
    Object_under_partContext *object_under_part();
    Invoker_rights_clauseContext *invoker_rights_clause();
    Sqlj_object_typeContext *sqlj_object_type();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Object_member_specContext *> object_member_spec();
    Object_member_specContext* object_member_spec(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Modifier_clauseContext *> modifier_clause();
    Modifier_clauseContext* modifier_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_type_defContext* object_type_def();

  class  Object_as_partContext : public antlr4::ParserRuleContext {
  public:
    Object_as_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OBJECT();
    Varray_type_defContext *varray_type_def();
    Nested_table_type_defContext *nested_table_type_def();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_as_partContext* object_as_part();

  class  Object_under_partContext : public antlr4::ParserRuleContext {
  public:
    Object_under_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNDER();
    Type_specContext *type_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_under_partContext* object_under_part();

  class  Nested_table_type_defContext : public antlr4::ParserRuleContext {
  public:
    Nested_table_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *OF();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Nested_table_type_defContext* nested_table_type_def();

  class  Sqlj_object_typeContext : public antlr4::ParserRuleContext {
  public:
    Sqlj_object_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *NAME();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *LANGUAGE();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *SQLDATA();
    antlr4::tree::TerminalNode *CUSTOMDATUM();
    antlr4::tree::TerminalNode *ORADATA();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sqlj_object_typeContext* sqlj_object_type();

  class  Type_bodyContext : public antlr4::ParserRuleContext {
  public:
    Type_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BODY();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    std::vector<Type_body_elementsContext *> type_body_elements();
    Type_body_elementsContext* type_body_elements(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_bodyContext* type_body();

  class  Type_body_elementsContext : public antlr4::ParserRuleContext {
  public:
    Type_body_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Map_order_func_declarationContext *map_order_func_declaration();
    Subprog_decl_in_typeContext *subprog_decl_in_type();
    Overriding_subprogram_specContext *overriding_subprogram_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_body_elementsContext* type_body_elements();

  class  Map_order_func_declarationContext : public antlr4::ParserRuleContext {
  public:
    Map_order_func_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER();
    Func_decl_in_typeContext *func_decl_in_type();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *ORDER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Map_order_func_declarationContext* map_order_func_declaration();

  class  Subprog_decl_in_typeContext : public antlr4::ParserRuleContext {
  public:
    Subprog_decl_in_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *STATIC();
    Proc_decl_in_typeContext *proc_decl_in_type();
    Func_decl_in_typeContext *func_decl_in_type();
    Constructor_declarationContext *constructor_declaration();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subprog_decl_in_typeContext* subprog_decl_in_type();

  class  Proc_decl_in_typeContext : public antlr4::ParserRuleContext {
  public:
    Proc_decl_in_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    Call_specContext *call_spec();
    BodyContext *body();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Proc_decl_in_typeContext* proc_decl_in_type();

  class  Func_decl_in_typeContext : public antlr4::ParserRuleContext {
  public:
    Func_decl_in_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    Call_specContext *call_spec();
    BodyContext *body();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Func_decl_in_typeContext* func_decl_in_type();

  class  Constructor_declarationContext : public antlr4::ParserRuleContext {
  public:
    Constructor_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONSTRUCTOR();
    antlr4::tree::TerminalNode *FUNCTION();
    std::vector<Type_specContext *> type_spec();
    Type_specContext* type_spec(size_t i);
    antlr4::tree::TerminalNode *RETURN();
    std::vector<antlr4::tree::TerminalNode *> SELF();
    antlr4::tree::TerminalNode* SELF(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *IS();
    Call_specContext *call_spec();
    BodyContext *body();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *OUT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constructor_declarationContext* constructor_declaration();

  class  Modifier_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modifier_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *OVERRIDING();
    antlr4::tree::TerminalNode *NOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modifier_clauseContext* modifier_clause();

  class  Object_member_specContext : public antlr4::ParserRuleContext {
  public:
    Object_member_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Type_specContext *type_spec();
    Sqlj_object_type_attrContext *sqlj_object_type_attr();
    Element_specContext *element_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_member_specContext* object_member_spec();

  class  Sqlj_object_type_attrContext : public antlr4::ParserRuleContext {
  public:
    Sqlj_object_type_attrContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *NAME();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sqlj_object_type_attrContext* sqlj_object_type_attr();

  class  Element_specContext : public antlr4::ParserRuleContext {
  public:
    Element_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Modifier_clauseContext *modifier_clause();
    std::vector<Element_spec_optionsContext *> element_spec_options();
    Element_spec_optionsContext* element_spec_options(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    Pragma_clauseContext *pragma_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Element_specContext* element_spec();

  class  Element_spec_optionsContext : public antlr4::ParserRuleContext {
  public:
    Element_spec_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subprogram_specContext *subprogram_spec();
    Constructor_specContext *constructor_spec();
    Map_order_function_specContext *map_order_function_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Element_spec_optionsContext* element_spec_options();

  class  Subprogram_specContext : public antlr4::ParserRuleContext {
  public:
    Subprogram_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *STATIC();
    Type_procedure_specContext *type_procedure_spec();
    Type_function_specContext *type_function_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subprogram_specContext* subprogram_spec();

  class  Overriding_subprogram_specContext : public antlr4::ParserRuleContext {
  public:
    Overriding_subprogram_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OVERRIDING();
    antlr4::tree::TerminalNode *MEMBER();
    Overriding_function_specContext *overriding_function_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Overriding_subprogram_specContext* overriding_subprogram_spec();

  class  Overriding_function_specContext : public antlr4::ParserRuleContext {
  public:
    Overriding_function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SELF();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *IS();
    BodyContext *body();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Overriding_function_specContext* overriding_function_spec();

  class  Type_procedure_specContext : public antlr4::ParserRuleContext {
  public:
    Type_procedure_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_procedure_specContext* type_procedure_spec();

  class  Type_function_specContext : public antlr4::ParserRuleContext {
  public:
    Type_function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SELF();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *NAME();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *IS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *VARIABLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_function_specContext* type_function_spec();

  class  Constructor_specContext : public antlr4::ParserRuleContext {
  public:
    Constructor_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONSTRUCTOR();
    antlr4::tree::TerminalNode *FUNCTION();
    std::vector<Type_specContext *> type_spec();
    Type_specContext* type_spec(size_t i);
    antlr4::tree::TerminalNode *RETURN();
    std::vector<antlr4::tree::TerminalNode *> SELF();
    antlr4::tree::TerminalNode* SELF(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *OUT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constructor_specContext* constructor_spec();

  class  Map_order_function_specContext : public antlr4::ParserRuleContext {
  public:
    Map_order_function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER();
    Type_function_specContext *type_function_spec();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *ORDER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Map_order_function_specContext* map_order_function_spec();

  class  Pragma_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pragma_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRAGMA();
    antlr4::tree::TerminalNode *RESTRICT_REFERENCES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Pragma_elementsContext *> pragma_elements();
    Pragma_elementsContext* pragma_elements(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pragma_clauseContext* pragma_clause();

  class  Pragma_elementsContext : public antlr4::ParserRuleContext {
  public:
    Pragma_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *DEFAULT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pragma_elementsContext* pragma_elements();

  class  Type_elements_parameterContext : public antlr4::ParserRuleContext {
  public:
    Type_elements_parameterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    Type_specContext *type_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_elements_parameterContext* type_elements_parameter();

  class  Drop_sequenceContext : public antlr4::ParserRuleContext {
  public:
    Drop_sequenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *SEQUENCE();
    Sequence_nameContext *sequence_name();
    antlr4::tree::TerminalNode *SEMICOLON();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_sequenceContext* drop_sequence();

  class  Alter_sequenceContext : public antlr4::ParserRuleContext {
  public:
    Alter_sequenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *SEQUENCE();
    Sequence_nameContext *sequence_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Sequence_specContext *> sequence_spec();
    Sequence_specContext* sequence_spec(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_sequenceContext* alter_sequence();

  class  Alter_sessionContext : public antlr4::ParserRuleContext {
  public:
    Alter_sessionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *ADVISE();
    antlr4::tree::TerminalNode *CLOSE();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    Parameter_nameContext *parameter_name();
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *GUARD();
    std::vector<antlr4::tree::TerminalNode *> PARALLEL();
    antlr4::tree::TerminalNode* PARALLEL(size_t i);
    antlr4::tree::TerminalNode *SET();
    Alter_session_set_clauseContext *alter_session_set_clause();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *NOTHING();
    antlr4::tree::TerminalNode *DML();
    antlr4::tree::TerminalNode *DDL();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *FORCE();
    LiteralContext *literal();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_sessionContext* alter_session();

  class  Alter_session_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_session_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Parameter_valueContext *parameter_value();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_session_set_clauseContext* alter_session_set_clause();

  class  Create_sequenceContext : public antlr4::ParserRuleContext {
  public:
    Create_sequenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *SEQUENCE();
    Sequence_nameContext *sequence_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Sequence_start_clauseContext *> sequence_start_clause();
    Sequence_start_clauseContext* sequence_start_clause(size_t i);
    std::vector<Sequence_specContext *> sequence_spec();
    Sequence_specContext* sequence_spec(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_sequenceContext* create_sequence();

  class  Sequence_specContext : public antlr4::ParserRuleContext {
  public:
    Sequence_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *NOMAXVALUE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *NOMINVALUE();
    antlr4::tree::TerminalNode *CYCLE();
    antlr4::tree::TerminalNode *NOCYCLE();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *NOORDER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sequence_specContext* sequence_spec();

  class  Sequence_start_clauseContext : public antlr4::ParserRuleContext {
  public:
    Sequence_start_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sequence_start_clauseContext* sequence_start_clause();

  class  Create_indexContext : public antlr4::ParserRuleContext {
  public:
    Create_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *SEMICOLON();
    Cluster_index_clauseContext *cluster_index_clause();
    Table_index_clauseContext *table_index_clause();
    Bitmap_join_index_clauseContext *bitmap_join_index_clause();
    antlr4::tree::TerminalNode *UNUSABLE();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *BITMAP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_indexContext* create_index();

  class  Cluster_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cluster_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    Index_attributesContext *index_attributes();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cluster_index_clauseContext* cluster_index_clause();

  class  Cluster_nameContext : public antlr4::ParserRuleContext {
  public:
    Cluster_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cluster_nameContext* cluster_name();

  class  Table_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Table_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();
    std::vector<Index_exprContext *> index_expr();
    Index_exprContext* index_expr(size_t i);
    Index_propertiesContext *index_properties();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ASC();
    antlr4::tree::TerminalNode* ASC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DESC();
    antlr4::tree::TerminalNode* DESC(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_index_clauseContext* table_index_clause();

  class  Bitmap_join_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Bitmap_join_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FROM();
    Where_clauseContext *where_clause();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<Table_aliasContext *> table_alias();
    Table_aliasContext* table_alias(size_t i);
    Local_partitioned_indexContext *local_partitioned_index();
    Index_attributesContext *index_attributes();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ASC();
    antlr4::tree::TerminalNode* ASC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DESC();
    antlr4::tree::TerminalNode* DESC(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Bitmap_join_index_clauseContext* bitmap_join_index_clause();

  class  Index_exprContext : public antlr4::ParserRuleContext {
  public:
    Index_exprContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_exprContext* index_expr();

  class  Index_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Index_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Global_partitioned_indexContext *> global_partitioned_index();
    Global_partitioned_indexContext* global_partitioned_index(size_t i);
    std::vector<Local_partitioned_indexContext *> local_partitioned_index();
    Local_partitioned_indexContext* local_partitioned_index(size_t i);
    std::vector<Index_attributesContext *> index_attributes();
    Index_attributesContext* index_attributes(size_t i);
    antlr4::tree::TerminalNode *INDEXTYPE();
    antlr4::tree::TerminalNode *IS();
    Domain_index_clauseContext *domain_index_clause();
    Xmlindex_clauseContext *xmlindex_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_propertiesContext* index_properties();

  class  Domain_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Domain_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IndextypeContext *indextype();
    Local_domain_index_clauseContext *local_domain_index_clause();
    Parallel_clauseContext *parallel_clause();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Domain_index_clauseContext* domain_index_clause();

  class  Local_domain_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Local_domain_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARAMETERS();
    antlr4::tree::TerminalNode* PARAMETERS(size_t i);
    std::vector<Odci_parametersContext *> odci_parameters();
    Odci_parametersContext* odci_parameters(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Local_domain_index_clauseContext* local_domain_index_clause();

  class  Xmlindex_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xmlindex_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLINDEX();
    antlr4::tree::TerminalNode *XDB();
    antlr4::tree::TerminalNode *PERIOD();
    Local_xmlindex_clauseContext *local_xmlindex_clause();
    Parallel_clauseContext *parallel_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlindex_clauseContext* xmlindex_clause();

  class  Local_xmlindex_clauseContext : public antlr4::ParserRuleContext {
  public:
    Local_xmlindex_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Local_xmlindex_clauseContext* local_xmlindex_clause();

  class  Global_partitioned_indexContext : public antlr4::ParserRuleContext {
  public:
    Global_partitioned_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Index_partitioning_clauseContext *index_partitioning_clause();
    antlr4::tree::TerminalNode *HASH();
    Individual_hash_partitionsContext *individual_hash_partitions();
    Hash_partitions_by_quantityContext *hash_partitions_by_quantity();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Global_partitioned_indexContext* global_partitioned_index();

  class  Index_partitioning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_partitioning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LESS();
    antlr4::tree::TerminalNode *THAN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Partition_nameContext *partition_name();
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    Segment_attributes_clauseContext *segment_attributes_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_partitioning_clauseContext* index_partitioning_clause();

  class  Local_partitioned_indexContext : public antlr4::ParserRuleContext {
  public:
    Local_partitioned_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    On_range_partitioned_tableContext *on_range_partitioned_table();
    On_list_partitioned_tableContext *on_list_partitioned_table();
    On_hash_partitioned_tableContext *on_hash_partitioned_table();
    On_comp_partitioned_tableContext *on_comp_partitioned_table();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Local_partitioned_indexContext* local_partitioned_index();

  class  On_range_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_range_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNUSABLE();
    antlr4::tree::TerminalNode* UNUSABLE(size_t i);
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_range_partitioned_tableContext* on_range_partitioned_table();

  class  On_list_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_list_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNUSABLE();
    antlr4::tree::TerminalNode* UNUSABLE(size_t i);
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_list_partitioned_tableContext* on_list_partitioned_table();

  class  On_hash_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_hash_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNUSABLE();
    antlr4::tree::TerminalNode* UNUSABLE(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_hash_partitioned_tableContext* on_hash_partitioned_table();

  class  On_comp_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_comp_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNUSABLE();
    antlr4::tree::TerminalNode* UNUSABLE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<Index_subpartition_clauseContext *> index_subpartition_clause();
    Index_subpartition_clauseContext* index_subpartition_clause(size_t i);
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_comp_partitioned_tableContext* on_comp_partitioned_table();

  class  Index_subpartition_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_subpartition_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SUBPARTITION();
    antlr4::tree::TerminalNode* SUBPARTITION(size_t i);
    std::vector<Subpartition_nameContext *> subpartition_name();
    Subpartition_nameContext* subpartition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNUSABLE();
    antlr4::tree::TerminalNode* UNUSABLE(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_subpartition_clauseContext* index_subpartition_clause();

  class  Odci_parametersContext : public antlr4::ParserRuleContext {
  public:
    Odci_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Odci_parametersContext* odci_parameters();

  class  IndextypeContext : public antlr4::ParserRuleContext {
  public:
    IndextypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  IndextypeContext* indextype();

  class  Alter_indexContext : public antlr4::ParserRuleContext {
  public:
    Alter_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    Alter_index_ops_set1Context *alter_index_ops_set1();
    Alter_index_ops_set2Context *alter_index_ops_set2();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_indexContext* alter_index();

  class  Alter_index_ops_set1Context : public antlr4::ParserRuleContext {
  public:
    Alter_index_ops_set1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Shrink_clauseContext *> shrink_clause();
    Shrink_clauseContext* shrink_clause(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_index_ops_set1Context* alter_index_ops_set1();

  class  Alter_index_ops_set2Context : public antlr4::ParserRuleContext {
  public:
    Alter_index_ops_set2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Rebuild_clauseContext *rebuild_clause();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COMPILE();
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *UNUSABLE();
    Visible_or_invisibleContext *visible_or_invisible();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    New_index_nameContext *new_index_name();
    antlr4::tree::TerminalNode *COALESCE();
    Monitoring_nomonitoringContext *monitoring_nomonitoring();
    antlr4::tree::TerminalNode *USAGE();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *REFERENCES();
    Alter_index_partitioningContext *alter_index_partitioning();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_index_ops_set2Context* alter_index_ops_set2();

  class  Visible_or_invisibleContext : public antlr4::ParserRuleContext {
  public:
    Visible_or_invisibleContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *INVISIBLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Visible_or_invisibleContext* visible_or_invisible();

  class  Monitoring_nomonitoringContext : public antlr4::ParserRuleContext {
  public:
    Monitoring_nomonitoringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MONITORING();
    antlr4::tree::TerminalNode *NOMONITORING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Monitoring_nomonitoringContext* monitoring_nomonitoring();

  class  Rebuild_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rebuild_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REBUILD();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    antlr4::tree::TerminalNode *REVERSE();
    antlr4::tree::TerminalNode *NOREVERSE();
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARAMETERS();
    antlr4::tree::TerminalNode* PARAMETERS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Odci_parametersContext *> odci_parameters();
    Odci_parametersContext* odci_parameters(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLINE();
    antlr4::tree::TerminalNode* ONLINE(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rebuild_clauseContext* rebuild_clause();

  class  Alter_index_partitioningContext : public antlr4::ParserRuleContext {
  public:
    Alter_index_partitioningContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Modify_index_default_attrsContext *modify_index_default_attrs();
    Add_hash_index_partitionContext *add_hash_index_partition();
    Modify_index_partitionContext *modify_index_partition();
    Rename_index_partitionContext *rename_index_partition();
    Drop_index_partitionContext *drop_index_partition();
    Split_index_partitionContext *split_index_partition();
    Coalesce_index_partitionContext *coalesce_index_partition();
    Modify_index_subpartitionContext *modify_index_subpartition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_index_partitioningContext* alter_index_partitioning();

  class  Modify_index_default_attrsContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_default_attrsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    antlr4::tree::TerminalNode *ATTRIBUTES();
    Physical_attributes_clauseContext *physical_attributes_clause();
    antlr4::tree::TerminalNode *TABLESPACE();
    Logging_clauseContext *logging_clause();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    TablespaceContext *tablespace();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_default_attrsContext* modify_index_default_attrs();

  class  Add_hash_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Add_hash_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    Key_compressionContext *key_compression();
    Parallel_clauseContext *parallel_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_hash_index_partitionContext* add_hash_index_partition();

  class  Coalesce_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Coalesce_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *PARTITION();
    Parallel_clauseContext *parallel_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Coalesce_index_partitionContext* coalesce_index_partition();

  class  Modify_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *UNUSABLE();
    std::vector<Modify_index_partitions_opsContext *> modify_index_partitions_ops();
    Modify_index_partitions_opsContext* modify_index_partitions_ops(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_partitionContext* modify_index_partition();

  class  Modify_index_partitions_opsContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_partitions_opsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Deallocate_unused_clauseContext *deallocate_unused_clause();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Physical_attributes_clauseContext *physical_attributes_clause();
    Logging_clauseContext *logging_clause();
    Key_compressionContext *key_compression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_partitions_opsContext* modify_index_partitions_ops();

  class  Rename_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Rename_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    New_partition_nameContext *new_partition_name();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rename_index_partitionContext* rename_index_partition();

  class  Drop_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Drop_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_index_partitionContext* drop_index_partition();

  class  Split_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Split_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SPLIT();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_name_oldContext *partition_name_old();
    antlr4::tree::TerminalNode *AT();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    antlr4::tree::TerminalNode *INTO();
    std::vector<Index_partition_descriptionContext *> index_partition_description();
    Index_partition_descriptionContext* index_partition_description(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Parallel_clauseContext *parallel_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Split_index_partitionContext* split_index_partition();

  class  Index_partition_descriptionContext : public antlr4::ParserRuleContext {
  public:
    Index_partition_descriptionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *UNUSABLE();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_partition_descriptionContext* index_partition_description();

  class  Modify_index_subpartitionContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_subpartitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    antlr4::tree::TerminalNode *UNUSABLE();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Deallocate_unused_clauseContext *deallocate_unused_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_subpartitionContext* modify_index_subpartition();

  class  Partition_name_oldContext : public antlr4::ParserRuleContext {
  public:
    Partition_name_oldContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Partition_nameContext *partition_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_name_oldContext* partition_name_old();

  class  New_partition_nameContext : public antlr4::ParserRuleContext {
  public:
    New_partition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Partition_nameContext *partition_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_partition_nameContext* new_partition_name();

  class  New_index_nameContext : public antlr4::ParserRuleContext {
  public:
    New_index_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_nameContext *index_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_index_nameContext* new_index_name();

  class  Create_userContext : public antlr4::ParserRuleContext {
  public:
    Create_userContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *USER();
    User_object_nameContext *user_object_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Identified_byContext *> identified_by();
    Identified_byContext* identified_by(size_t i);
    std::vector<Identified_other_clauseContext *> identified_other_clause();
    Identified_other_clauseContext* identified_other_clause(size_t i);
    std::vector<User_tablespace_clauseContext *> user_tablespace_clause();
    User_tablespace_clauseContext* user_tablespace_clause(size_t i);
    std::vector<Quota_clauseContext *> quota_clause();
    Quota_clauseContext* quota_clause(size_t i);
    std::vector<Profile_clauseContext *> profile_clause();
    Profile_clauseContext* profile_clause(size_t i);
    std::vector<Password_expire_clauseContext *> password_expire_clause();
    Password_expire_clauseContext* password_expire_clause(size_t i);
    std::vector<User_lock_clauseContext *> user_lock_clause();
    User_lock_clauseContext* user_lock_clause(size_t i);
    std::vector<User_editions_clauseContext *> user_editions_clause();
    User_editions_clauseContext* user_editions_clause(size_t i);
    std::vector<Container_clauseContext *> container_clause();
    Container_clauseContext* container_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_userContext* create_user();

  class  Alter_userContext : public antlr4::ParserRuleContext {
  public:
    Alter_userContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *USER();
    std::vector<User_object_nameContext *> user_object_name();
    User_object_nameContext* user_object_name(size_t i);
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Alter_identified_byContext *> alter_identified_by();
    Alter_identified_byContext* alter_identified_by(size_t i);
    std::vector<Identified_other_clauseContext *> identified_other_clause();
    Identified_other_clauseContext* identified_other_clause(size_t i);
    std::vector<User_tablespace_clauseContext *> user_tablespace_clause();
    User_tablespace_clauseContext* user_tablespace_clause(size_t i);
    std::vector<Quota_clauseContext *> quota_clause();
    Quota_clauseContext* quota_clause(size_t i);
    std::vector<Profile_clauseContext *> profile_clause();
    Profile_clauseContext* profile_clause(size_t i);
    std::vector<User_default_role_clauseContext *> user_default_role_clause();
    User_default_role_clauseContext* user_default_role_clause(size_t i);
    std::vector<Password_expire_clauseContext *> password_expire_clause();
    Password_expire_clauseContext* password_expire_clause(size_t i);
    std::vector<User_lock_clauseContext *> user_lock_clause();
    User_lock_clauseContext* user_lock_clause(size_t i);
    std::vector<Alter_user_editions_clauseContext *> alter_user_editions_clause();
    Alter_user_editions_clauseContext* alter_user_editions_clause(size_t i);
    std::vector<Container_clauseContext *> container_clause();
    Container_clauseContext* container_clause(size_t i);
    std::vector<Container_data_clauseContext *> container_data_clause();
    Container_data_clauseContext* container_data_clause(size_t i);
    Proxy_clauseContext *proxy_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_userContext* alter_user();

  class  Alter_identified_byContext : public antlr4::ParserRuleContext {
  public:
    Alter_identified_byContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Identified_byContext *identified_by();
    antlr4::tree::TerminalNode *REPLACE();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_identified_byContext* alter_identified_by();

  class  Identified_byContext : public antlr4::ParserRuleContext {
  public:
    Identified_byContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identified_byContext* identified_by();

  class  Identified_other_clauseContext : public antlr4::ParserRuleContext {
  public:
    Identified_other_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *EXTERNALLY();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *AS();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identified_other_clauseContext* identified_other_clause();

  class  User_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *TEMPORARY();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_tablespace_clauseContext* user_tablespace_clause();

  class  Quota_clauseContext : public antlr4::ParserRuleContext {
  public:
    Quota_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *QUOTA();
    antlr4::tree::TerminalNode *ON();
    Id_expressionContext *id_expression();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *UNLIMITED();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quota_clauseContext* quota_clause();

  class  Profile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Profile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROFILE();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Profile_clauseContext* profile_clause();

  class  Role_clauseContext : public antlr4::ParserRuleContext {
  public:
    Role_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Role_nameContext *> role_name();
    Role_nameContext* role_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> EXCEPT();
    antlr4::tree::TerminalNode* EXCEPT(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Role_clauseContext* role_clause();

  class  User_default_role_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_default_role_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *NONE();
    Role_clauseContext *role_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_default_role_clauseContext* user_default_role_clause();

  class  Password_expire_clauseContext : public antlr4::ParserRuleContext {
  public:
    Password_expire_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *EXPIRE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Password_expire_clauseContext* password_expire_clause();

  class  User_lock_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_lock_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACCOUNT();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *UNLOCK();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_lock_clauseContext* user_lock_clause();

  class  User_editions_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_editions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *EDITIONS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_editions_clauseContext* user_editions_clause();

  class  Alter_user_editions_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_user_editions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    User_editions_clauseContext *user_editions_clause();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *FORCE();
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_user_editions_clauseContext* alter_user_editions_clause();

  class  Proxy_clauseContext : public antlr4::ParserRuleContext {
  public:
    Proxy_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REVOKE();
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *THROUGH();
    antlr4::tree::TerminalNode *ENTERPRISE();
    antlr4::tree::TerminalNode *USERS();
    User_object_nameContext *user_object_name();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *AUTHENTICATION();
    antlr4::tree::TerminalNode *REQUIRED();
    antlr4::tree::TerminalNode *AUTHENTICATED();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *ROLES();
    antlr4::tree::TerminalNode *ROLE();
    Role_clauseContext *role_clause();
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *CERTIFICATE();
    antlr4::tree::TerminalNode *DISTINGUISHED();
    antlr4::tree::TerminalNode *NAME();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Proxy_clauseContext* proxy_clause();

  class  Container_namesContext : public antlr4::ParserRuleContext {
  public:
    Container_namesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_namesContext* container_names();

  class  Set_container_dataContext : public antlr4::ParserRuleContext {
  public:
    Set_container_dataContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *CONTAINER_DATA();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *DEFAULT();
    Container_namesContext *container_names();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_container_dataContext* set_container_data();

  class  Add_rem_container_dataContext : public antlr4::ParserRuleContext {
  public:
    Add_rem_container_dataContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTAINER_DATA();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Container_namesContext *container_names();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *REMOVE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_rem_container_dataContext* add_rem_container_data();

  class  Container_data_clauseContext : public antlr4::ParserRuleContext {
  public:
    Container_data_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Set_container_dataContext *set_container_data();
    Add_rem_container_dataContext *add_rem_container_data();
    antlr4::tree::TerminalNode *FOR();
    Container_tableview_nameContext *container_tableview_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_data_clauseContext* container_data_clause();

  class  AnalyzeContext : public antlr4::ParserRuleContext {
  public:
    AnalyzeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    Validation_clausesContext *validation_clauses();
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *CHAINED();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    Partition_extention_clauseContext *partition_extention_clause();
    Into_clause1Context *into_clause1();
    antlr4::tree::TerminalNode *SYSTEM();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  AnalyzeContext* analyze();

  class  Partition_extention_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partition_extention_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FOR();
    std::vector<Partition_key_valueContext *> partition_key_value();
    Partition_key_valueContext* partition_key_value(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    std::vector<Subpartition_key_valueContext *> subpartition_key_value();
    Subpartition_key_valueContext* subpartition_key_value(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_extention_clauseContext* partition_extention_clause();

  class  Validation_clausesContext : public antlr4::ParserRuleContext {
  public:
    Validation_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALIDATE();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *DANGLING();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *STRUCTURE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *FAST();
    std::vector<Online_or_offlineContext *> online_or_offline();
    Online_or_offlineContext* online_or_offline(size_t i);
    std::vector<Into_clauseContext *> into_clause();
    Into_clauseContext* into_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Validation_clausesContext* validation_clauses();

  class  Online_or_offlineContext : public antlr4::ParserRuleContext {
  public:
    Online_or_offlineContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *ONLINE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Online_or_offlineContext* online_or_offline();

  class  Into_clause1Context : public antlr4::ParserRuleContext {
  public:
    Into_clause1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Into_clause1Context* into_clause1();

  class  Partition_key_valueContext : public antlr4::ParserRuleContext {
  public:
    Partition_key_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LiteralContext *literal();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_key_valueContext* partition_key_value();

  class  Subpartition_key_valueContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_key_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LiteralContext *literal();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_key_valueContext* subpartition_key_value();

  class  Associate_statisticsContext : public antlr4::ParserRuleContext {
  public:
    Associate_statisticsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASSOCIATE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *SEMICOLON();
    Column_associationContext *column_association();
    Function_associationContext *function_association();
    Storage_table_clauseContext *storage_table_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Associate_statisticsContext* associate_statistics();

  class  Column_associationContext : public antlr4::ParserRuleContext {
  public:
    Column_associationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COLUMNS();
    Using_statistics_typeContext *using_statistics_type();
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_associationContext* column_association();

  class  Function_associationContext : public antlr4::ParserRuleContext {
  public:
    Function_associationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTIONS();
    antlr4::tree::TerminalNode *PACKAGES();
    antlr4::tree::TerminalNode *TYPES();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *INDEXTYPES();
    Using_statistics_typeContext *using_statistics_type();
    Default_cost_clauseContext *default_cost_clause();
    Default_selectivity_clauseContext *default_selectivity_clause();
    std::vector<Function_nameContext *> function_name();
    Function_nameContext* function_name(size_t i);
    std::vector<Package_nameContext *> package_name();
    Package_nameContext* package_name(size_t i);
    std::vector<Type_nameContext *> type_name();
    Type_nameContext* type_name(size_t i);
    std::vector<Index_nameContext *> index_name();
    Index_nameContext* index_name(size_t i);
    std::vector<Indextype_nameContext *> indextype_name();
    Indextype_nameContext* indextype_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_associationContext* function_association();

  class  Indextype_nameContext : public antlr4::ParserRuleContext {
  public:
    Indextype_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Indextype_nameContext* indextype_name();

  class  Using_statistics_typeContext : public antlr4::ParserRuleContext {
  public:
    Using_statistics_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Statistics_type_nameContext *statistics_type_name();
    antlr4::tree::TerminalNode *NULL_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_statistics_typeContext* using_statistics_type();

  class  Statistics_type_nameContext : public antlr4::ParserRuleContext {
  public:
    Statistics_type_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Statistics_type_nameContext* statistics_type_name();

  class  Default_cost_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_cost_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Cpu_costContext *cpu_cost();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Io_costContext *io_cost();
    Network_costContext *network_cost();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_cost_clauseContext* default_cost_clause();

  class  Cpu_costContext : public antlr4::ParserRuleContext {
  public:
    Cpu_costContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cpu_costContext* cpu_cost();

  class  Io_costContext : public antlr4::ParserRuleContext {
  public:
    Io_costContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Io_costContext* io_cost();

  class  Network_costContext : public antlr4::ParserRuleContext {
  public:
    Network_costContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Network_costContext* network_cost();

  class  Default_selectivity_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_selectivity_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *SELECTIVITY();
    Default_selectivityContext *default_selectivity();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_selectivity_clauseContext* default_selectivity_clause();

  class  Default_selectivityContext : public antlr4::ParserRuleContext {
  public:
    Default_selectivityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_selectivityContext* default_selectivity();

  class  Storage_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Storage_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *MANAGED();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *TABLES();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *USER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Storage_table_clauseContext* storage_table_clause();

  class  Unified_auditingContext : public antlr4::ParserRuleContext {
  public:
    Unified_auditingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *POLICY();
    Policy_nameContext *policy_name();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *NAMESPACE();
    Oracle_namespaceContext *oracle_namespace();
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    std::vector<Attribute_nameContext *> attribute_name();
    Attribute_nameContext* attribute_name(size_t i);
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *EXCEPT();
    std::vector<Audit_userContext *> audit_user();
    Audit_userContext* audit_user(size_t i);
    antlr4::tree::TerminalNode *NOT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unified_auditingContext* unified_auditing();

  class  Policy_nameContext : public antlr4::ParserRuleContext {
  public:
    Policy_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Policy_nameContext* policy_name();

  class  Audit_traditionalContext : public antlr4::ParserRuleContext {
  public:
    Audit_traditionalContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *SEMICOLON();
    Audit_operation_clauseContext *audit_operation_clause();
    Audit_schema_object_clauseContext *audit_schema_object_clause();
    antlr4::tree::TerminalNode *NETWORK();
    Audit_direct_pathContext *audit_direct_path();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    Audit_container_clauseContext *audit_container_clause();
    std::vector<antlr4::tree::TerminalNode *> SESSION();
    antlr4::tree::TerminalNode* SESSION(size_t i);
    antlr4::tree::TerminalNode *ACCESS();
    Auditing_by_clauseContext *auditing_by_clause();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *NOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_traditionalContext* audit_traditional();

  class  Audit_direct_pathContext : public antlr4::ParserRuleContext {
  public:
    Audit_direct_pathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DIRECT_PATH();
    Auditing_by_clauseContext *auditing_by_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_direct_pathContext* audit_direct_path();

  class  Audit_container_clauseContext : public antlr4::ParserRuleContext {
  public:
    Audit_container_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_container_clauseContext* audit_container_clause();

  class  Audit_operation_clauseContext : public antlr4::ParserRuleContext {
  public:
    Audit_operation_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Sql_statement_shortcutContext *> sql_statement_shortcut();
    Sql_statement_shortcutContext* sql_statement_shortcut(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    std::vector<System_privilegeContext *> system_privilege();
    System_privilegeContext* system_privilege(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIVILEGES();
    antlr4::tree::TerminalNode* PRIVILEGES(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> STATEMENTS();
    antlr4::tree::TerminalNode* STATEMENTS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_operation_clauseContext* audit_operation_clause();

  class  Auditing_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Auditing_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BY();
    std::vector<Audit_userContext *> audit_user();
    Audit_userContext* audit_user(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Auditing_by_clauseContext* auditing_by_clause();

  class  Audit_userContext : public antlr4::ParserRuleContext {
  public:
    Audit_userContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_userContext* audit_user();

  class  Audit_schema_object_clauseContext : public antlr4::ParserRuleContext {
  public:
    Audit_schema_object_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Auditing_on_clauseContext *auditing_on_clause();
    antlr4::tree::TerminalNode *ALL();
    std::vector<Sql_operationContext *> sql_operation();
    Sql_operationContext* sql_operation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_schema_object_clauseContext* audit_schema_object_clause();

  class  Sql_operationContext : public antlr4::ParserRuleContext {
  public:
    Sql_operationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *UPDATE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_operationContext* sql_operation();

  class  Auditing_on_clauseContext : public antlr4::ParserRuleContext {
  public:
    Auditing_on_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    Object_nameContext *object_name();
    antlr4::tree::TerminalNode *DIRECTORY();
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    Model_nameContext *model_name();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *PROFILE();
    Profile_nameContext *profile_name();
    antlr4::tree::TerminalNode *DEFAULT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Auditing_on_clauseContext* auditing_on_clause();

  class  Model_nameContext : public antlr4::ParserRuleContext {
  public:
    Model_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_nameContext* model_name();

  class  Object_nameContext : public antlr4::ParserRuleContext {
  public:
    Object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_nameContext* object_name();

  class  Profile_nameContext : public antlr4::ParserRuleContext {
  public:
    Profile_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Profile_nameContext* profile_name();

  class  Sql_statement_shortcutContext : public antlr4::ParserRuleContext {
  public:
    Sql_statement_shortcutContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *SYNONYM();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *UPDATE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_statement_shortcutContext* sql_statement_shortcut();

  class  Drop_indexContext : public antlr4::ParserRuleContext {
  public:
    Drop_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *SEMICOLON();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_indexContext* drop_index();

  class  Grant_statementContext : public antlr4::ParserRuleContext {
  public:
    Grant_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> GRANT();
    antlr4::tree::TerminalNode* GRANT(size_t i);
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *ON();
    Grant_object_nameContext *grant_object_name();
    std::vector<Grantee_nameContext *> grantee_name();
    Grantee_nameContext* grantee_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PUBLIC();
    antlr4::tree::TerminalNode* PUBLIC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OPTION();
    antlr4::tree::TerminalNode* OPTION(size_t i);
    antlr4::tree::TerminalNode *HIERARCHY();
    Container_clauseContext *container_clause();
    antlr4::tree::TerminalNode *ADMIN();
    antlr4::tree::TerminalNode *DELEGATE();
    std::vector<Role_nameContext *> role_name();
    Role_nameContext* role_name(size_t i);
    std::vector<System_privilegeContext *> system_privilege();
    System_privilegeContext* system_privilege(size_t i);
    std::vector<Object_privilegeContext *> object_privilege();
    Object_privilegeContext* object_privilege(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Paren_column_listContext *> paren_column_list();
    Paren_column_listContext* paren_column_list(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grant_statementContext* grant_statement();

  class  Container_clauseContext : public antlr4::ParserRuleContext {
  public:
    Container_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_clauseContext* container_clause();

  class  Create_directoryContext : public antlr4::ParserRuleContext {
  public:
    Create_directoryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DIRECTORY();
    Directory_nameContext *directory_name();
    antlr4::tree::TerminalNode *AS();
    Directory_pathContext *directory_path();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_directoryContext* create_directory();

  class  Directory_nameContext : public antlr4::ParserRuleContext {
  public:
    Directory_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Directory_nameContext* directory_name();

  class  Directory_pathContext : public antlr4::ParserRuleContext {
  public:
    Directory_pathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Directory_pathContext* directory_path();

  class  Alter_libraryContext : public antlr4::ParserRuleContext {
  public:
    Alter_libraryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *LIBRARY();
    Library_nameContext *library_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *COMPILE();
    Library_editionableContext *library_editionable();
    Library_debugContext *library_debug();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_libraryContext* alter_library();

  class  Library_editionableContext : public antlr4::ParserRuleContext {
  public:
    Library_editionableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Library_editionableContext* library_editionable();

  class  Library_debugContext : public antlr4::ParserRuleContext {
  public:
    Library_debugContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEBUG();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Library_debugContext* library_debug();

  class  Compiler_parameters_clauseContext : public antlr4::ParserRuleContext {
  public:
    Compiler_parameters_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Parameter_valueContext *parameter_value();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compiler_parameters_clauseContext* compiler_parameters_clause();

  class  Parameter_valueContext : public antlr4::ParserRuleContext {
  public:
    Parameter_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parameter_valueContext* parameter_value();

  class  Library_nameContext : public antlr4::ParserRuleContext {
  public:
    Library_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    antlr4::tree::TerminalNode *PERIOD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Library_nameContext* library_name();

  class  Alter_viewContext : public antlr4::ParserRuleContext {
  public:
    Alter_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *ADD();
    Out_of_line_constraintContext *out_of_line_constraint();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *RELY();
    antlr4::tree::TerminalNode *NORELY();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Alter_view_editionableContext *alter_view_editionable();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_viewContext* alter_view();

  class  Alter_view_editionableContext : public antlr4::ParserRuleContext {
  public:
    Alter_view_editionableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_view_editionableContext* alter_view_editionable();

  class  Create_viewContext : public antlr4::ParserRuleContext {
  public:
    Create_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *AS();
    SubqueryContext *subquery();
    std::vector<antlr4::tree::TerminalNode *> OR();
    antlr4::tree::TerminalNode* OR(size_t i);
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *EDITIONING();
    View_optionsContext *view_options();
    Subquery_restriction_clauseContext *subquery_restriction_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_viewContext* create_view();

  class  View_optionsContext : public antlr4::ParserRuleContext {
  public:
    View_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    View_alias_constraintContext *view_alias_constraint();
    Object_view_clauseContext *object_view_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  View_optionsContext* view_options();

  class  View_alias_constraintContext : public antlr4::ParserRuleContext {
  public:
    View_alias_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Table_aliasContext *> table_alias();
    Table_aliasContext* table_alias(size_t i);
    std::vector<Out_of_line_constraintContext *> out_of_line_constraint();
    Out_of_line_constraintContext* out_of_line_constraint(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  View_alias_constraintContext* view_alias_constraint();

  class  Object_view_clauseContext : public antlr4::ParserRuleContext {
  public:
    Object_view_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *UNDER();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *ID();
    antlr4::tree::TerminalNode *OID();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *DEFAULT();
    std::vector<antlr4::tree::TerminalNode *> REGULAR_ID();
    antlr4::tree::TerminalNode* REGULAR_ID(size_t i);
    std::vector<Out_of_line_constraintContext *> out_of_line_constraint();
    Out_of_line_constraintContext* out_of_line_constraint(size_t i);
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_view_clauseContext* object_view_clause();

  class  Inline_constraintContext : public antlr4::ParserRuleContext {
  public:
    Inline_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    References_clauseContext *references_clause();
    Check_constraintContext *check_constraint();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Constraint_stateContext *constraint_state();
    antlr4::tree::TerminalNode *NOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inline_constraintContext* inline_constraint();

  class  Inline_ref_constraintContext : public antlr4::ParserRuleContext {
  public:
    Inline_ref_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *IS();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *ROWID();
    References_clauseContext *references_clause();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Constraint_stateContext *constraint_state();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inline_ref_constraintContext* inline_ref_constraint();

  class  Out_of_line_ref_constraintContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Regular_idContext *ref_col_or_attr = nullptr;;
    Out_of_line_ref_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *IS();
    Tableview_nameContext *tableview_name();
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *FOREIGN();
    antlr4::tree::TerminalNode *KEY();
    References_clauseContext *references_clause();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Constraint_stateContext *constraint_state();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Out_of_line_ref_constraintContext* out_of_line_ref_constraint();

  class  Out_of_line_constraintContext : public antlr4::ParserRuleContext {
  public:
    Out_of_line_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Constraint_stateContext *constraint_state();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    Foreign_key_clauseContext *foreign_key_clause();
    antlr4::tree::TerminalNode *CHECK();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Out_of_line_constraintContext* out_of_line_constraint();

  class  Constraint_stateContext : public antlr4::ParserRuleContext {
  public:
    Constraint_stateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> DEFERRABLE();
    antlr4::tree::TerminalNode* DEFERRABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INITIALLY();
    antlr4::tree::TerminalNode* INITIALLY(size_t i);
    std::vector<Using_index_clauseContext *> using_index_clause();
    Using_index_clauseContext* using_index_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IMMEDIATE();
    antlr4::tree::TerminalNode* IMMEDIATE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFERRED();
    antlr4::tree::TerminalNode* DEFERRED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RELY();
    antlr4::tree::TerminalNode* RELY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NORELY();
    antlr4::tree::TerminalNode* NORELY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENABLE();
    antlr4::tree::TerminalNode* ENABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DISABLE();
    antlr4::tree::TerminalNode* DISABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> VALIDATE();
    antlr4::tree::TerminalNode* VALIDATE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOVALIDATE();
    antlr4::tree::TerminalNode* NOVALIDATE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOT();
    antlr4::tree::TerminalNode* NOT(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constraint_stateContext* constraint_state();

  class  Alter_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    Alter_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *MINIMUM();
    antlr4::tree::TerminalNode *EXTENT();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    New_tablespace_nameContext *new_tablespace_name();
    Begin_or_endContext *begin_or_end();
    antlr4::tree::TerminalNode *BACKUP();
    Datafile_tempfile_clausesContext *datafile_tempfile_clauses();
    Tablespace_logging_clausesContext *tablespace_logging_clauses();
    Tablespace_group_clauseContext *tablespace_group_clause();
    Tablespace_state_clausesContext *tablespace_state_clauses();
    Autoextend_clauseContext *autoextend_clause();
    Flashback_mode_clauseContext *flashback_mode_clause();
    Tablespace_retention_clauseContext *tablespace_retention_clause();
    Table_compressionContext *table_compression();
    Storage_clauseContext *storage_clause();
    antlr4::tree::TerminalNode *KEEP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tablespaceContext* alter_tablespace();

  class  Datafile_tempfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Datafile_tempfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    Datafile_specificationContext *datafile_specification();
    Tempfile_specificationContext *tempfile_specification();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *TEMPFILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *KEEP();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Online_or_offlineContext *online_or_offline();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datafile_tempfile_clausesContext* datafile_tempfile_clauses();

  class  Tablespace_logging_clausesContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_logging_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Logging_clauseContext *logging_clause();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *NO();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_logging_clausesContext* tablespace_logging_clauses();

  class  Tablespace_group_clauseContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_group_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *GROUP();
    Tablespace_group_nameContext *tablespace_group_name();
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_group_clauseContext* tablespace_group_clause();

  class  Tablespace_group_nameContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_group_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_group_nameContext* tablespace_group_name();

  class  Tablespace_state_clausesContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_state_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *NORMAL();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *PERMANENT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_state_clausesContext* tablespace_state_clauses();

  class  Flashback_mode_clauseContext : public antlr4::ParserRuleContext {
  public:
    Flashback_mode_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OFF();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_mode_clauseContext* flashback_mode_clause();

  class  New_tablespace_nameContext : public antlr4::ParserRuleContext {
  public:
    New_tablespace_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TablespaceContext *tablespace();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_tablespace_nameContext* new_tablespace_name();

  class  Create_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    Create_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *SEMICOLON();
    Permanent_tablespace_clauseContext *permanent_tablespace_clause();
    Temporary_tablespace_clauseContext *temporary_tablespace_clause();
    Undo_tablespace_clauseContext *undo_tablespace_clause();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *SMALLFILE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_tablespaceContext* create_tablespace();

  class  Permanent_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    Permanent_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    Datafile_specificationContext *datafile_specification();
    std::vector<antlr4::tree::TerminalNode *> MINIMUM();
    antlr4::tree::TerminalNode* MINIMUM(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EXTENT();
    antlr4::tree::TerminalNode* EXTENT(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BLOCKSIZE();
    antlr4::tree::TerminalNode* BLOCKSIZE(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOGGING();
    antlr4::tree::TerminalNode* LOGGING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPTION();
    antlr4::tree::TerminalNode* ENCRYPTION(size_t i);
    std::vector<Tablespace_encryption_specContext *> tablespace_encryption_spec();
    Tablespace_encryption_specContext* tablespace_encryption_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<Extent_management_clauseContext *> extent_management_clause();
    Extent_management_clauseContext* extent_management_clause(size_t i);
    std::vector<Segment_management_clauseContext *> segment_management_clause();
    Segment_management_clauseContext* segment_management_clause(size_t i);
    std::vector<Flashback_mode_clauseContext *> flashback_mode_clause();
    Flashback_mode_clauseContext* flashback_mode_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLINE();
    antlr4::tree::TerminalNode* ONLINE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OFFLINE();
    antlr4::tree::TerminalNode* OFFLINE(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Permanent_tablespace_clauseContext* permanent_tablespace_clause();

  class  Tablespace_encryption_specContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *encrypt_algorithm = nullptr;;
    Tablespace_encryption_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_encryption_specContext* tablespace_encryption_spec();

  class  Logging_clauseContext : public antlr4::ParserRuleContext {
  public:
    Logging_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *NOLOGGING();
    antlr4::tree::TerminalNode *FILESYSTEM_LIKE_LOGGING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logging_clauseContext* logging_clause();

  class  Extent_management_clauseContext : public antlr4::ParserRuleContext {
  public:
    Extent_management_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *AUTOALLOCATE();
    antlr4::tree::TerminalNode *UNIFORM();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Extent_management_clauseContext* extent_management_clause();

  class  Segment_management_clauseContext : public antlr4::ParserRuleContext {
  public:
    Segment_management_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *MANUAL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Segment_management_clauseContext* segment_management_clause();

  class  Temporary_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;;
    Temporary_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    Tempfile_specificationContext *tempfile_specification();
    Tablespace_group_clauseContext *tablespace_group_clause();
    Extent_management_clauseContext *extent_management_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Temporary_tablespace_clauseContext* temporary_tablespace_clause();

  class  Undo_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;;
    Undo_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNDO();
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    Datafile_specificationContext *datafile_specification();
    Extent_management_clauseContext *extent_management_clause();
    Tablespace_retention_clauseContext *tablespace_retention_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Undo_tablespace_clauseContext* undo_tablespace_clause();

  class  Tablespace_retention_clauseContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_retention_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *GUARANTEE();
    antlr4::tree::TerminalNode *NOGUARANTEE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_retention_clauseContext* tablespace_retention_clause();

  class  Datafile_specificationContext : public antlr4::ParserRuleContext {
  public:
    Datafile_specificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATAFILE();
    Datafile_tempfile_specContext *datafile_tempfile_spec();
    antlr4::tree::TerminalNode *COMMA();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datafile_specificationContext* datafile_specification();

  class  Tempfile_specificationContext : public antlr4::ParserRuleContext {
  public:
    Tempfile_specificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TEMPFILE();
    Datafile_tempfile_specContext *datafile_tempfile_spec();
    antlr4::tree::TerminalNode *COMMA();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tempfile_specificationContext* tempfile_specification();

  class  Datafile_tempfile_specContext : public antlr4::ParserRuleContext {
  public:
    Datafile_tempfile_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *REUSE();
    Autoextend_clauseContext *autoextend_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datafile_tempfile_specContext* datafile_tempfile_spec();

  class  Redo_log_file_specContext : public antlr4::ParserRuleContext {
  public:
    Redo_log_file_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SIZE();
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    antlr4::tree::TerminalNode *BLOCKSIZE();
    antlr4::tree::TerminalNode *REUSE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Redo_log_file_specContext* redo_log_file_spec();

  class  Autoextend_clauseContext : public antlr4::ParserRuleContext {
  public:
    Autoextend_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUTOEXTEND();
    antlr4::tree::TerminalNode *OFF();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *NEXT();
    Size_clauseContext *size_clause();
    Maxsize_clauseContext *maxsize_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Autoextend_clauseContext* autoextend_clause();

  class  Maxsize_clauseContext : public antlr4::ParserRuleContext {
  public:
    Maxsize_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MAXSIZE();
    antlr4::tree::TerminalNode *UNLIMITED();
    Size_clauseContext *size_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Maxsize_clauseContext* maxsize_clause();

  class  Build_clauseContext : public antlr4::ParserRuleContext {
  public:
    Build_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BUILD();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *DEFERRED();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Build_clauseContext* build_clause();

  class  Parallel_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *parallel_count = nullptr;;
    Parallel_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOPARALLEL();
    antlr4::tree::TerminalNode *PARALLEL();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parallel_clauseContext* parallel_clause();

  class  Alter_materialized_viewContext : public antlr4::ParserRuleContext {
  public:
    Alter_materialized_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    Modify_mv_column_clauseContext *modify_mv_column_clause();
    Table_compressionContext *table_compression();
    Parallel_clauseContext *parallel_clause();
    Logging_clauseContext *logging_clause();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Deallocate_unused_clauseContext *deallocate_unused_clause();
    Shrink_clauseContext *shrink_clause();
    Alter_iot_clausesContext *alter_iot_clauses();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *INDEX();
    Alter_mv_option1Context *alter_mv_option1();
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *CONSIDER();
    antlr4::tree::TerminalNode *FRESH();
    Cache_or_nocacheContext *cache_or_nocache();
    std::vector<Lob_storage_clauseContext *> lob_storage_clause();
    Lob_storage_clauseContext* lob_storage_clause(size_t i);
    std::vector<Modify_lob_storage_clauseContext *> modify_lob_storage_clause();
    Modify_lob_storage_clauseContext* modify_lob_storage_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_materialized_viewContext* alter_materialized_view();

  class  Alter_mv_option1Context : public antlr4::ParserRuleContext {
  public:
    Alter_mv_option1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Alter_mv_refreshContext *alter_mv_refresh();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_mv_option1Context* alter_mv_option1();

  class  Alter_mv_refreshContext : public antlr4::ParserRuleContext {
  public:
    Alter_mv_refreshContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFRESH();
    std::vector<antlr4::tree::TerminalNode *> FAST();
    antlr4::tree::TerminalNode* FAST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMPLETE();
    antlr4::tree::TerminalNode* COMPLETE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> START();
    antlr4::tree::TerminalNode* START(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NEXT();
    antlr4::tree::TerminalNode* NEXT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MASTER();
    antlr4::tree::TerminalNode* MASTER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROLLBACK();
    antlr4::tree::TerminalNode* ROLLBACK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEGMENT();
    antlr4::tree::TerminalNode* SEGMENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSTRAINTS();
    antlr4::tree::TerminalNode* CONSTRAINTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEMAND();
    antlr4::tree::TerminalNode* DEMAND(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMIT();
    antlr4::tree::TerminalNode* COMMIT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENFORCED();
    antlr4::tree::TerminalNode* ENFORCED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TRUSTED();
    antlr4::tree::TerminalNode* TRUSTED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<Rollback_segmentContext *> rollback_segment();
    Rollback_segmentContext* rollback_segment(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_mv_refreshContext* alter_mv_refresh();

  class  Rollback_segmentContext : public antlr4::ParserRuleContext {
  public:
    Rollback_segmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollback_segmentContext* rollback_segment();

  class  Modify_mv_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modify_mv_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ENCRYPT();
    Encryption_specContext *encryption_spec();
    antlr4::tree::TerminalNode *DECRYPT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_mv_column_clauseContext* modify_mv_column_clause();

  class  Alter_materialized_view_logContext : public antlr4::ParserRuleContext {
  public:
    Alter_materialized_view_logContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *FORCE();
    Physical_attributes_clauseContext *physical_attributes_clause();
    Add_mv_log_column_clauseContext *add_mv_log_column_clause();
    Parallel_clauseContext *parallel_clause();
    Logging_clauseContext *logging_clause();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Shrink_clauseContext *shrink_clause();
    Move_mv_log_clauseContext *move_mv_log_clause();
    Cache_or_nocacheContext *cache_or_nocache();
    Mv_log_augmentationContext *mv_log_augmentation();
    Mv_log_purge_clauseContext *mv_log_purge_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_materialized_view_logContext* alter_materialized_view_log();

  class  Add_mv_log_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_mv_log_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_mv_log_column_clauseContext* add_mv_log_column_clause();

  class  Move_mv_log_clauseContext : public antlr4::ParserRuleContext {
  public:
    Move_mv_log_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    Segment_attributes_clauseContext *segment_attributes_clause();
    Parallel_clauseContext *parallel_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_mv_log_clauseContext* move_mv_log_clause();

  class  Mv_log_augmentationContext : public antlr4::ParserRuleContext {
  public:
    Mv_log_augmentationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    New_values_clauseContext *new_values_clause();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *ID();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *SEQUENCE();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Mv_log_augmentationContext* mv_log_augmentation();

  class  Datetime_exprContext : public antlr4::ParserRuleContext {
  public:
    Datetime_exprContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datetime_exprContext* datetime_expr();

  class  Interval_exprContext : public antlr4::ParserRuleContext {
  public:
    Interval_exprContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Interval_exprContext* interval_expr();

  class  Synchronous_or_asynchronousContext : public antlr4::ParserRuleContext {
  public:
    Synchronous_or_asynchronousContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SYNCHRONOUS();
    antlr4::tree::TerminalNode *ASYNCHRONOUS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Synchronous_or_asynchronousContext* synchronous_or_asynchronous();

  class  Including_or_excludingContext : public antlr4::ParserRuleContext {
  public:
    Including_or_excludingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *EXCLUDING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Including_or_excludingContext* including_or_excluding();

  class  Create_materialized_view_logContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;;
    Create_materialized_view_logContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    Parallel_clauseContext *parallel_clause();
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Mv_log_purge_clauseContext *> mv_log_purge_clause();
    Mv_log_purge_clauseContext* mv_log_purge_clause(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OBJECT();
    antlr4::tree::TerminalNode* OBJECT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ID();
    antlr4::tree::TerminalNode* ID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROWID();
    antlr4::tree::TerminalNode* ROWID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEQUENCE();
    antlr4::tree::TerminalNode* SEQUENCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMIT();
    antlr4::tree::TerminalNode* COMMIT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SCN();
    antlr4::tree::TerminalNode* SCN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    std::vector<New_values_clauseContext *> new_values_clause();
    New_values_clauseContext* new_values_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_materialized_view_logContext* create_materialized_view_log();

  class  New_values_clauseContext : public antlr4::ParserRuleContext {
  public:
    New_values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *EXCLUDING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_values_clauseContext* new_values_clause();

  class  Mv_log_purge_clauseContext : public antlr4::ParserRuleContext {
  public:
    Mv_log_purge_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *SYNCHRONOUS();
    antlr4::tree::TerminalNode *ASYNCHRONOUS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Mv_log_purge_clauseContext* mv_log_purge_clause();

  class  Create_materialized_viewContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *mv_tablespace = nullptr;;
    Create_materialized_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *AS();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *PREBUILT();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *OF();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *NO();
    Create_mv_refreshContext *create_mv_refresh();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *REDUCED();
    antlr4::tree::TerminalNode *PRECISION();
    Physical_propertiesContext *physical_properties();
    Parallel_clauseContext *parallel_clause();
    Build_clauseContext *build_clause();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_materialized_viewContext* create_materialized_view();

  class  Create_mv_refreshContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *rb_segment = nullptr;;
    Create_mv_refreshContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NEVER();
    antlr4::tree::TerminalNode *REFRESH();
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSTRAINTS();
    antlr4::tree::TerminalNode* CONSTRAINTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FAST();
    antlr4::tree::TerminalNode* FAST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMPLETE();
    antlr4::tree::TerminalNode* COMPLETE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEMAND();
    antlr4::tree::TerminalNode* DEMAND(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMIT();
    antlr4::tree::TerminalNode* COMMIT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENFORCED();
    antlr4::tree::TerminalNode* ENFORCED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TRUSTED();
    antlr4::tree::TerminalNode* TRUSTED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> START();
    antlr4::tree::TerminalNode* START(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NEXT();
    antlr4::tree::TerminalNode* NEXT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROWID();
    antlr4::tree::TerminalNode* ROWID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROLLBACK();
    antlr4::tree::TerminalNode* ROLLBACK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEGMENT();
    antlr4::tree::TerminalNode* SEGMENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REGULAR_ID();
    antlr4::tree::TerminalNode* REGULAR_ID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MASTER();
    antlr4::tree::TerminalNode* MASTER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOCAL();
    antlr4::tree::TerminalNode* LOCAL(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_mv_refreshContext* create_mv_refresh();

  class  Create_contextContext : public antlr4::ParserRuleContext {
  public:
    Create_contextContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *CONTEXT();
    Oracle_namespaceContext *oracle_namespace();
    antlr4::tree::TerminalNode *USING();
    Package_nameContext *package_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *INITIALIZED();
    antlr4::tree::TerminalNode *ACCESSED();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *EXTERNALLY();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_contextContext* create_context();

  class  Oracle_namespaceContext : public antlr4::ParserRuleContext {
  public:
    Oracle_namespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Oracle_namespaceContext* oracle_namespace();

  class  Create_clusterContext : public antlr4::ParserRuleContext {
  public:
    Create_clusterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<DatatypeContext *> datatype();
    DatatypeContext* datatype(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INDEX();
    antlr4::tree::TerminalNode* INDEX(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HASHKEYS();
    antlr4::tree::TerminalNode* HASHKEYS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    Parallel_clauseContext *parallel_clause();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SORT();
    antlr4::tree::TerminalNode* SORT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SINGLE();
    antlr4::tree::TerminalNode* SINGLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLE();
    antlr4::tree::TerminalNode* TABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HASH();
    antlr4::tree::TerminalNode* HASH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IS();
    antlr4::tree::TerminalNode* IS(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_clusterContext* create_cluster();

  class  Create_tableContext : public antlr4::ParserRuleContext {
  public:
    Create_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    Relational_tableContext *relational_table();
    Object_tableContext *object_table();
    Xmltype_tableContext *xmltype_table();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *AS();
    Select_statementContext *select_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_tableContext* create_table();

  class  Xmltype_tableContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    std::vector<antlr4::tree::TerminalNode *> XMLTYPE();
    antlr4::tree::TerminalNode* XMLTYPE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Object_propertiesContext *object_properties();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Xmltype_storageContext *xmltype_storage();
    Xmlschema_specContext *xmlschema_spec();
    Xmltype_virtual_columnsContext *xmltype_virtual_columns();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *ROWS();
    Oid_clauseContext *oid_clause();
    Oid_index_clauseContext *oid_index_clause();
    Physical_propertiesContext *physical_properties();
    Column_propertiesContext *column_properties();
    Table_partitioning_clausesContext *table_partitioning_clauses();
    antlr4::tree::TerminalNode *RESULT_CACHE();
    antlr4::tree::TerminalNode *MODE();
    Parallel_clauseContext *parallel_clause();
    Row_movement_clauseContext *row_movement_clause();
    Flashback_archive_clauseContext *flashback_archive_clause();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    std::vector<Enable_disable_clauseContext *> enable_disable_clause();
    Enable_disable_clauseContext* enable_disable_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_tableContext* xmltype_table();

  class  Xmltype_virtual_columnsContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_virtual_columnsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VIRTUAL();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_virtual_columnsContext* xmltype_virtual_columns();

  class  Xmltype_column_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_column_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLTYPE();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *COLUMN();
    Xmltype_storageContext *xmltype_storage();
    Xmlschema_specContext *xmlschema_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_column_propertiesContext* xmltype_column_properties();

  class  Xmltype_storageContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_storageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *RELATIONAL();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BINARY();
    antlr4::tree::TerminalNode *XML();
    Lob_segnameContext *lob_segname();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Lob_parametersContext *lob_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SECUREFILE();
    antlr4::tree::TerminalNode *BASICFILE();
    antlr4::tree::TerminalNode *VARRAYS();
    antlr4::tree::TerminalNode *LOBS();
    antlr4::tree::TerminalNode *TABLES();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_storageContext* xmltype_storage();

  class  Xmlschema_specContext : public antlr4::ParserRuleContext {
  public:
    Xmlschema_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELEMENT();
    std::vector<antlr4::tree::TerminalNode *> DELIMITED_ID();
    antlr4::tree::TerminalNode* DELIMITED_ID(size_t i);
    antlr4::tree::TerminalNode *XMLSCHEMA();
    std::vector<Allow_or_disallowContext *> allow_or_disallow();
    Allow_or_disallowContext* allow_or_disallow(size_t i);
    antlr4::tree::TerminalNode *NONSCHEMA();
    antlr4::tree::TerminalNode *ANYSCHEMA();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlschema_specContext* xmlschema_spec();

  class  Object_tableContext : public antlr4::ParserRuleContext {
  public:
    Object_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    Type_nameContext *type_name();
    Object_table_substitutionContext *object_table_substitution();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *ROWS();
    Oid_clauseContext *oid_clause();
    Oid_index_clauseContext *oid_index_clause();
    Physical_propertiesContext *physical_properties();
    Column_propertiesContext *column_properties();
    Table_partitioning_clausesContext *table_partitioning_clauses();
    antlr4::tree::TerminalNode *RESULT_CACHE();
    antlr4::tree::TerminalNode *MODE();
    Parallel_clauseContext *parallel_clause();
    Row_movement_clauseContext *row_movement_clause();
    Flashback_archive_clauseContext *flashback_archive_clause();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    std::vector<Object_propertiesContext *> object_properties();
    Object_propertiesContext* object_properties(size_t i);
    std::vector<Enable_disable_clauseContext *> enable_disable_clause();
    Enable_disable_clauseContext* enable_disable_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_tableContext* object_table();

  class  Oid_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Oid_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OIDINDEX();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Index_nameContext *index_name();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Oid_index_clauseContext* oid_index_clause();

  class  Oid_clauseContext : public antlr4::ParserRuleContext {
  public:
    Oid_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Oid_clauseContext* oid_clause();

  class  Object_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Object_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Attribute_nameContext *attribute_name();
    antlr4::tree::TerminalNode *DEFAULT();
    ExpressionContext *expression();
    Inline_ref_constraintContext *inline_ref_constraint();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Out_of_line_constraintContext *out_of_line_constraint();
    Out_of_line_ref_constraintContext *out_of_line_ref_constraint();
    Supplemental_logging_propsContext *supplemental_logging_props();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_propertiesContext* object_properties();

  class  Object_table_substitutionContext : public antlr4::ParserRuleContext {
  public:
    Object_table_substitutionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *NOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_table_substitutionContext* object_table_substitution();

  class  Relational_tableContext : public antlr4::ParserRuleContext {
  public:
    Relational_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Relational_propertiesContext *relational_properties();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *ROWS();
    Physical_propertiesContext *physical_properties();
    Column_propertiesContext *column_properties();
    Table_partitioning_clausesContext *table_partitioning_clauses();
    antlr4::tree::TerminalNode *RESULT_CACHE();
    antlr4::tree::TerminalNode *MODE();
    Parallel_clauseContext *parallel_clause();
    Row_movement_clauseContext *row_movement_clause();
    Flashback_archive_clauseContext *flashback_archive_clause();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    std::vector<Enable_disable_clauseContext *> enable_disable_clause();
    Enable_disable_clauseContext* enable_disable_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_tableContext* relational_table();

  class  Relational_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Relational_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Column_definitionContext *> column_definition();
    Column_definitionContext* column_definition(size_t i);
    std::vector<Virtual_column_definitionContext *> virtual_column_definition();
    Virtual_column_definitionContext* virtual_column_definition(size_t i);
    std::vector<Out_of_line_constraintContext *> out_of_line_constraint();
    Out_of_line_constraintContext* out_of_line_constraint(size_t i);
    std::vector<Out_of_line_ref_constraintContext *> out_of_line_ref_constraint();
    Out_of_line_ref_constraintContext* out_of_line_ref_constraint(size_t i);
    std::vector<Supplemental_logging_propsContext *> supplemental_logging_props();
    Supplemental_logging_propsContext* supplemental_logging_props(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_propertiesContext* relational_properties();

  class  Table_partitioning_clausesContext : public antlr4::ParserRuleContext {
  public:
    Table_partitioning_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Range_partitionsContext *range_partitions();
    List_partitionsContext *list_partitions();
    Hash_partitionsContext *hash_partitions();
    Composite_range_partitionsContext *composite_range_partitions();
    Composite_list_partitionsContext *composite_list_partitions();
    Composite_hash_partitionsContext *composite_hash_partitions();
    Reference_partitioningContext *reference_partitioning();
    System_partitioningContext *system_partitioning();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_partitioning_clausesContext* table_partitioning_clauses();

  class  Range_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Range_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *INTERVAL();
    ExpressionContext *expression();
    std::vector<Range_values_clauseContext *> range_values_clause();
    Range_values_clauseContext* range_values_clause(size_t i);
    std::vector<Table_partition_descriptionContext *> table_partition_description();
    Table_partition_descriptionContext* table_partition_description(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_partitionsContext* range_partitions();

  class  List_partitionsContext : public antlr4::ParserRuleContext {
  public:
    List_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LIST();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Column_nameContext *column_name();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<List_values_clauseContext *> list_values_clause();
    List_values_clauseContext* list_values_clause(size_t i);
    std::vector<Table_partition_descriptionContext *> table_partition_description();
    Table_partition_descriptionContext* table_partition_description(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_partitionsContext* list_partitions();

  class  Hash_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Hash_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Individual_hash_partitionsContext *individual_hash_partitions();
    Hash_partitions_by_quantityContext *hash_partitions_by_quantity();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_partitionsContext* hash_partitions();

  class  Individual_hash_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Individual_hash_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<Partitioning_storage_clauseContext *> partitioning_storage_clause();
    Partitioning_storage_clauseContext* partitioning_storage_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Individual_hash_partitionsContext* individual_hash_partitions();

  class  Hash_partitions_by_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_partitions_by_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITIONS();
    Hash_partition_quantityContext *hash_partition_quantity();
    std::vector<antlr4::tree::TerminalNode *> STORE();
    antlr4::tree::TerminalNode* STORE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IN();
    antlr4::tree::TerminalNode* IN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Table_compressionContext *table_compression();
    Key_compressionContext *key_compression();
    antlr4::tree::TerminalNode *OVERFLOW();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_partitions_by_quantityContext* hash_partitions_by_quantity();

  class  Hash_partition_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_partition_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_partition_quantityContext* hash_partition_quantity();

  class  Composite_range_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Composite_range_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Subpartition_by_rangeContext *subpartition_by_range();
    Subpartition_by_listContext *subpartition_by_list();
    Subpartition_by_hashContext *subpartition_by_hash();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *INTERVAL();
    ExpressionContext *expression();
    std::vector<Range_partition_descContext *> range_partition_desc();
    Range_partition_descContext* range_partition_desc(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Composite_range_partitionsContext* composite_range_partitions();

  class  Composite_list_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Composite_list_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LIST();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Column_nameContext *column_name();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Subpartition_by_rangeContext *subpartition_by_range();
    Subpartition_by_listContext *subpartition_by_list();
    Subpartition_by_hashContext *subpartition_by_hash();
    std::vector<List_partition_descContext *> list_partition_desc();
    List_partition_descContext* list_partition_desc(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Composite_list_partitionsContext* composite_list_partitions();

  class  Composite_hash_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Composite_hash_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Subpartition_by_rangeContext *subpartition_by_range();
    Subpartition_by_listContext *subpartition_by_list();
    Subpartition_by_hashContext *subpartition_by_hash();
    Individual_hash_partitionsContext *individual_hash_partitions();
    Hash_partitions_by_quantityContext *hash_partitions_by_quantity();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Composite_hash_partitionsContext* composite_hash_partitions();

  class  Reference_partitioningContext : public antlr4::ParserRuleContext {
  public:
    Reference_partitioningContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *REFERENCE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Regular_idContext *regular_id();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Reference_partition_descContext *> reference_partition_desc();
    Reference_partition_descContext* reference_partition_desc(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_partitioningContext* reference_partitioning();

  class  Reference_partition_descContext : public antlr4::ParserRuleContext {
  public:
    Reference_partition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Table_partition_descriptionContext *table_partition_description();
    Partition_nameContext *partition_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_partition_descContext* reference_partition_desc();

  class  System_partitioningContext : public antlr4::ParserRuleContext {
  public:
    System_partitioningContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *PARTITIONS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    std::vector<Reference_partition_descContext *> reference_partition_desc();
    Reference_partition_descContext* reference_partition_desc(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  System_partitioningContext* system_partitioning();

  class  Range_partition_descContext : public antlr4::ParserRuleContext {
  public:
    Range_partition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Range_values_clauseContext *range_values_clause();
    Table_partition_descriptionContext *table_partition_description();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Hash_subparts_by_quantityContext *hash_subparts_by_quantity();
    std::vector<Range_subpartition_descContext *> range_subpartition_desc();
    Range_subpartition_descContext* range_subpartition_desc(size_t i);
    std::vector<List_subpartition_descContext *> list_subpartition_desc();
    List_subpartition_descContext* list_subpartition_desc(size_t i);
    std::vector<Individual_hash_subpartsContext *> individual_hash_subparts();
    Individual_hash_subpartsContext* individual_hash_subparts(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_partition_descContext* range_partition_desc();

  class  List_partition_descContext : public antlr4::ParserRuleContext {
  public:
    List_partition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    List_values_clauseContext *list_values_clause();
    Table_partition_descriptionContext *table_partition_description();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Hash_subparts_by_quantityContext *hash_subparts_by_quantity();
    std::vector<Range_subpartition_descContext *> range_subpartition_desc();
    Range_subpartition_descContext* range_subpartition_desc(size_t i);
    std::vector<List_subpartition_descContext *> list_subpartition_desc();
    List_subpartition_descContext* list_subpartition_desc(size_t i);
    std::vector<Individual_hash_subpartsContext *> individual_hash_subparts();
    Individual_hash_subpartsContext* individual_hash_subparts(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_partition_descContext* list_partition_desc();

  class  Subpartition_templateContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_templateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *TEMPLATE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Hash_subpartition_quantityContext *hash_subpartition_quantity();
    std::vector<Range_subpartition_descContext *> range_subpartition_desc();
    Range_subpartition_descContext* range_subpartition_desc(size_t i);
    std::vector<List_subpartition_descContext *> list_subpartition_desc();
    List_subpartition_descContext* list_subpartition_desc(size_t i);
    std::vector<Individual_hash_subpartsContext *> individual_hash_subparts();
    Individual_hash_subpartsContext* individual_hash_subparts(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_templateContext* subpartition_template();

  class  Hash_subpartition_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_subpartition_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_subpartition_quantityContext* hash_subpartition_quantity();

  class  Subpartition_by_rangeContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_by_rangeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    Subpartition_templateContext *subpartition_template();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_by_rangeContext* subpartition_by_range();

  class  Subpartition_by_listContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_by_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Subpartition_templateContext *subpartition_template();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_by_listContext* subpartition_by_list();

  class  Subpartition_by_hashContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_by_hashContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *HASH();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Subpartition_templateContext *subpartition_template();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_by_hashContext* subpartition_by_hash();

  class  Subpartition_nameContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Partition_nameContext *partition_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_nameContext* subpartition_name();

  class  Range_subpartition_descContext : public antlr4::ParserRuleContext {
  public:
    Range_subpartition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    Range_values_clauseContext *range_values_clause();
    Subpartition_nameContext *subpartition_name();
    Partitioning_storage_clauseContext *partitioning_storage_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_subpartition_descContext* range_subpartition_desc();

  class  List_subpartition_descContext : public antlr4::ParserRuleContext {
  public:
    List_subpartition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    List_values_clauseContext *list_values_clause();
    Subpartition_nameContext *subpartition_name();
    Partitioning_storage_clauseContext *partitioning_storage_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_subpartition_descContext* list_subpartition_desc();

  class  Individual_hash_subpartsContext : public antlr4::ParserRuleContext {
  public:
    Individual_hash_subpartsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    Partitioning_storage_clauseContext *partitioning_storage_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Individual_hash_subpartsContext* individual_hash_subparts();

  class  Hash_subparts_by_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_subparts_by_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_subparts_by_quantityContext* hash_subparts_by_quantity();

  class  Range_values_clauseContext : public antlr4::ParserRuleContext {
  public:
    Range_values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LESS();
    antlr4::tree::TerminalNode *THAN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_values_clauseContext* range_values_clause();

  class  List_values_clauseContext : public antlr4::ParserRuleContext {
  public:
    List_values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DEFAULT();
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_values_clauseContext* list_values_clause();

  class  Table_partition_descriptionContext : public antlr4::ParserRuleContext {
  public:
    Table_partition_descriptionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Deferred_segment_creationContext *deferred_segment_creation();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    Table_compressionContext *table_compression();
    Key_compressionContext *key_compression();
    antlr4::tree::TerminalNode *OVERFLOW();
    Lob_storage_clauseContext *lob_storage_clause();
    Varray_col_propertiesContext *varray_col_properties();
    Nested_table_col_propertiesContext *nested_table_col_properties();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_partition_descriptionContext* table_partition_description();

  class  Partitioning_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partitioning_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OVERFLOW();
    antlr4::tree::TerminalNode* OVERFLOW(size_t i);
    std::vector<Table_compressionContext *> table_compression();
    Table_compressionContext* table_compression(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<Lob_partitioning_storageContext *> lob_partitioning_storage();
    Lob_partitioning_storageContext* lob_partitioning_storage(size_t i);
    std::vector<antlr4::tree::TerminalNode *> VARRAY();
    antlr4::tree::TerminalNode* VARRAY(size_t i);
    std::vector<Varray_itemContext *> varray_item();
    Varray_itemContext* varray_item(size_t i);
    std::vector<antlr4::tree::TerminalNode *> STORE();
    antlr4::tree::TerminalNode* STORE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOB();
    antlr4::tree::TerminalNode* LOB(size_t i);
    std::vector<Lob_segnameContext *> lob_segname();
    Lob_segnameContext* lob_segname(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BASICFILE();
    antlr4::tree::TerminalNode* BASICFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECUREFILE();
    antlr4::tree::TerminalNode* SECUREFILE(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partitioning_storage_clauseContext* partitioning_storage_clause();

  class  Lob_partitioning_storageContext : public antlr4::ParserRuleContext {
  public:
    Lob_partitioning_storageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOB();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Lob_itemContext *lob_item();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    Lob_segnameContext *lob_segname();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *BASICFILE();
    antlr4::tree::TerminalNode *SECUREFILE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_partitioning_storageContext* lob_partitioning_storage();

  class  Datatype_null_enableContext : public antlr4::ParserRuleContext {
  public:
    Datatype_null_enableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    DatatypeContext *datatype();
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *DEFAULT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ENCRYPT();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *USING();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *SALT();
    antlr4::tree::TerminalNode *NO();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datatype_null_enableContext* datatype_null_enable();

  class  Size_clauseContext : public antlr4::ParserRuleContext {
  public:
    Size_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *REGULAR_ID();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Size_clauseContext* size_clause();

  class  Table_compressionContext : public antlr4::ParserRuleContext {
  public:
    Table_compressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *BASIC();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *OLTP();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *NOCOMPRESS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_compressionContext* table_compression();

  class  Physical_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *pctfree = nullptr;;
    antlr4::Token *pctused = nullptr;;
    antlr4::Token *inittrans = nullptr;;
    Physical_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> PCTFREE();
    antlr4::tree::TerminalNode* PCTFREE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTUSED();
    antlr4::tree::TerminalNode* PCTUSED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INITRANS();
    antlr4::tree::TerminalNode* INITRANS(size_t i);
    std::vector<Storage_clauseContext *> storage_clause();
    Storage_clauseContext* storage_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Physical_attributes_clauseContext* physical_attributes_clause();

  class  Storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Size_clauseContext *initial_size = nullptr;;
    PlSqlParser::Size_clauseContext *next_size = nullptr;;
    antlr4::Token *minextents = nullptr;;
    antlr4::Token *pctincrease = nullptr;;
    antlr4::Token *freelists = nullptr;;
    antlr4::Token *freelist_groups = nullptr;;
    Storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> INITIAL();
    antlr4::tree::TerminalNode* INITIAL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NEXT();
    antlr4::tree::TerminalNode* NEXT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MINEXTENTS();
    antlr4::tree::TerminalNode* MINEXTENTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MAXEXTENTS();
    antlr4::tree::TerminalNode* MAXEXTENTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTINCREASE();
    antlr4::tree::TerminalNode* PCTINCREASE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREELISTS();
    antlr4::tree::TerminalNode* FREELISTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREELIST();
    antlr4::tree::TerminalNode* FREELIST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> GROUPS();
    antlr4::tree::TerminalNode* GROUPS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OPTIMAL();
    antlr4::tree::TerminalNode* OPTIMAL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BUFFER_POOL();
    antlr4::tree::TerminalNode* BUFFER_POOL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FLASH_CACHE();
    antlr4::tree::TerminalNode* FLASH_CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPT();
    antlr4::tree::TerminalNode* ENCRYPT(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEEP();
    antlr4::tree::TerminalNode* KEEP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RECYCLE();
    antlr4::tree::TerminalNode* RECYCLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NONE();
    antlr4::tree::TerminalNode* NONE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNLIMITED();
    antlr4::tree::TerminalNode* UNLIMITED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Storage_clauseContext* storage_clause();

  class  Deferred_segment_creationContext : public antlr4::ParserRuleContext {
  public:
    Deferred_segment_creationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *CREATION();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *DEFERRED();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Deferred_segment_creationContext* deferred_segment_creation();

  class  Segment_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;;
    Segment_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Segment_attributes_clauseContext* segment_attributes_clause();

  class  Physical_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Physical_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Segment_attributes_clauseContext *segment_attributes_clause();
    Deferred_segment_creationContext *deferred_segment_creation();
    Table_compressionContext *table_compression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Physical_propertiesContext* physical_properties();

  class  Row_movement_clauseContext : public antlr4::ParserRuleContext {
  public:
    Row_movement_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *MOVEMENT();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Row_movement_clauseContext* row_movement_clause();

  class  Flashback_archive_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *flashback_archive = nullptr;;
    Flashback_archive_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *NO();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_archive_clauseContext* flashback_archive_clause();

  class  Log_grpContext : public antlr4::ParserRuleContext {
  public:
    Log_grpContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Log_grpContext* log_grp();

  class  Supplemental_table_loggingContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_table_loggingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    std::vector<antlr4::tree::TerminalNode *> SUPPLEMENTAL();
    antlr4::tree::TerminalNode* SUPPLEMENTAL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOG();
    antlr4::tree::TerminalNode* LOG(size_t i);
    std::vector<Supplemental_log_grp_clauseContext *> supplemental_log_grp_clause();
    Supplemental_log_grp_clauseContext* supplemental_log_grp_clause(size_t i);
    std::vector<Supplemental_id_key_clauseContext *> supplemental_id_key_clause();
    Supplemental_id_key_clauseContext* supplemental_id_key_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();
    std::vector<antlr4::tree::TerminalNode *> GROUP();
    antlr4::tree::TerminalNode* GROUP(size_t i);
    std::vector<Log_grpContext *> log_grp();
    Log_grpContext* log_grp(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_table_loggingContext* supplemental_table_logging();

  class  Supplemental_log_grp_clauseContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_log_grp_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    Log_grpContext *log_grp();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    antlr4::tree::TerminalNode *ALWAYS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NO();
    antlr4::tree::TerminalNode* NO(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOG();
    antlr4::tree::TerminalNode* LOG(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_log_grp_clauseContext* supplemental_log_grp_clause();

  class  Supplemental_id_key_clauseContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_id_key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNIQUE();
    antlr4::tree::TerminalNode* UNIQUE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FOREIGN();
    antlr4::tree::TerminalNode* FOREIGN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_id_key_clauseContext* supplemental_id_key_clause();

  class  Allocate_extent_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *datafile = nullptr;;
    antlr4::Token *inst_num = nullptr;;
    Allocate_extent_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALLOCATE();
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DATAFILE();
    antlr4::tree::TerminalNode* DATAFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INSTANCE();
    antlr4::tree::TerminalNode* INSTANCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Allocate_extent_clauseContext* allocate_extent_clause();

  class  Deallocate_unused_clauseContext : public antlr4::ParserRuleContext {
  public:
    Deallocate_unused_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEALLOCATE();
    antlr4::tree::TerminalNode *UNUSED();
    antlr4::tree::TerminalNode *KEEP();
    Size_clauseContext *size_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Deallocate_unused_clauseContext* deallocate_unused_clause();

  class  Shrink_clauseContext : public antlr4::ParserRuleContext {
  public:
    Shrink_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *COMPACT();
    antlr4::tree::TerminalNode *CASCADE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Shrink_clauseContext* shrink_clause();

  class  Records_per_block_clauseContext : public antlr4::ParserRuleContext {
  public:
    Records_per_block_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECORDS_PER_BLOCK();
    antlr4::tree::TerminalNode *MINIMIZE();
    antlr4::tree::TerminalNode *NOMINIMIZE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Records_per_block_clauseContext* records_per_block_clause();

  class  Upgrade_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Upgrade_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPGRADE();
    Column_propertiesContext *column_properties();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *NOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Upgrade_table_clauseContext* upgrade_table_clause();

  class  Drop_tableContext : public antlr4::ParserRuleContext {
  public:
    Drop_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *PURGE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_tableContext* drop_table();

  class  Comment_on_columnContext : public antlr4::ParserRuleContext {
  public:
    Comment_on_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COLUMN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *IS();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Comment_on_columnContext* comment_on_column();

  class  Enable_or_disableContext : public antlr4::ParserRuleContext {
  public:
    Enable_or_disableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Enable_or_disableContext* enable_or_disable();

  class  Allow_or_disallowContext : public antlr4::ParserRuleContext {
  public:
    Allow_or_disallowContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALLOW();
    antlr4::tree::TerminalNode *DISALLOW();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Allow_or_disallowContext* allow_or_disallow();

  class  Create_synonymContext : public antlr4::ParserRuleContext {
  public:
    Create_synonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *SYNONYM();
    Synonym_nameContext *synonym_name();
    antlr4::tree::TerminalNode *FOR();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    std::vector<Schema_nameContext *> schema_name();
    Schema_nameContext* schema_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_synonymContext* create_synonym();

  class  Comment_on_tableContext : public antlr4::ParserRuleContext {
  public:
    Comment_on_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *IS();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Comment_on_tableContext* comment_on_table();

  class  Alter_clusterContext : public antlr4::ParserRuleContext {
  public:
    Alter_clusterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<Cache_or_nocacheContext *> cache_or_nocache();
    Cache_or_nocacheContext* cache_or_nocache(size_t i);
    Parallel_clauseContext *parallel_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_clusterContext* alter_cluster();

  class  Cache_or_nocacheContext : public antlr4::ParserRuleContext {
  public:
    Cache_or_nocacheContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cache_or_nocacheContext* cache_or_nocache();

  class  Database_nameContext : public antlr4::ParserRuleContext {
  public:
    Database_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Database_nameContext* database_name();

  class  Alter_databaseContext : public antlr4::ParserRuleContext {
  public:
    Alter_databaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *SEMICOLON();
    Startup_clausesContext *startup_clauses();
    Recovery_clausesContext *recovery_clauses();
    Database_file_clausesContext *database_file_clauses();
    Logfile_clausesContext *logfile_clauses();
    Controlfile_clausesContext *controlfile_clauses();
    Standby_database_clausesContext *standby_database_clauses();
    Default_settings_clauseContext *default_settings_clause();
    Instance_clausesContext *instance_clauses();
    Security_clauseContext *security_clause();
    Database_nameContext *database_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_databaseContext* alter_database();

  class  Startup_clausesContext : public antlr4::ParserRuleContext {
  public:
    Startup_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOUNT();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *CLONE();
    antlr4::tree::TerminalNode *OPEN();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *WRITE();
    Resetlogs_or_noresetlogsContext *resetlogs_or_noresetlogs();
    Upgrade_or_downgradeContext *upgrade_or_downgrade();
    antlr4::tree::TerminalNode *ONLY();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Startup_clausesContext* startup_clauses();

  class  Resetlogs_or_noresetlogsContext : public antlr4::ParserRuleContext {
  public:
    Resetlogs_or_noresetlogsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *NORESETLOGS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Resetlogs_or_noresetlogsContext* resetlogs_or_noresetlogs();

  class  Upgrade_or_downgradeContext : public antlr4::ParserRuleContext {
  public:
    Upgrade_or_downgradeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPGRADE();
    antlr4::tree::TerminalNode *DOWNGRADE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Upgrade_or_downgradeContext* upgrade_or_downgrade();

  class  Recovery_clausesContext : public antlr4::ParserRuleContext {
  public:
    Recovery_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    General_recoveryContext *general_recovery();
    Managed_standby_recoveryContext *managed_standby_recovery();
    Begin_or_endContext *begin_or_end();
    antlr4::tree::TerminalNode *BACKUP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Recovery_clausesContext* recovery_clauses();

  class  Begin_or_endContext : public antlr4::ParserRuleContext {
  public:
    Begin_or_endContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BEGIN();
    antlr4::tree::TerminalNode *END();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Begin_or_endContext* begin_or_end();

  class  General_recoveryContext : public antlr4::ParserRuleContext {
  public:
    General_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECOVER();
    antlr4::tree::TerminalNode *CONTINUE();
    antlr4::tree::TerminalNode *CANCEL();
    antlr4::tree::TerminalNode *AUTOMATIC();
    antlr4::tree::TerminalNode *FROM();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    Full_database_recoveryContext *full_database_recovery();
    Partial_database_recoveryContext *partial_database_recovery();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *DEFAULT();
    std::vector<antlr4::tree::TerminalNode *> TEST();
    antlr4::tree::TerminalNode* TEST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ALLOW();
    antlr4::tree::TerminalNode* ALLOW(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CORRUPTION();
    antlr4::tree::TerminalNode* CORRUPTION(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_recoveryContext* general_recovery();

  class  Full_database_recoveryContext : public antlr4::ParserRuleContext {
  public:
    Full_database_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *STANDBY();
    std::vector<antlr4::tree::TerminalNode *> UNTIL();
    antlr4::tree::TerminalNode* UNTIL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BACKUP();
    antlr4::tree::TerminalNode* BACKUP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONTROLFILE();
    antlr4::tree::TerminalNode* CONTROLFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CANCEL();
    antlr4::tree::TerminalNode* CANCEL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TIME();
    antlr4::tree::TerminalNode* TIME(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHANGE();
    antlr4::tree::TerminalNode* CHANGE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSISTENT();
    antlr4::tree::TerminalNode* CONSISTENT(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Full_database_recoveryContext* full_database_recovery();

  class  Partial_database_recoveryContext : public antlr4::ParserRuleContext {
  public:
    Partial_database_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    Partial_database_recovery_10gContext *partial_database_recovery_10g();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partial_database_recoveryContext* partial_database_recovery();

  class  Partial_database_recovery_10gContext : public antlr4::ParserRuleContext {
  public:
    Partial_database_recovery_10gContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *CONSISTENT();
    antlr4::tree::TerminalNode *WITH();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partial_database_recovery_10gContext* partial_database_recovery_10g();

  class  Managed_standby_recoveryContext : public antlr4::ParserRuleContext {
  public:
    Managed_standby_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECOVER();
    antlr4::tree::TerminalNode *MANAGED();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *LOGICAL();
    Db_nameContext *db_name();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *IDENTITY();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *CANCEL();
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CURRENT();
    antlr4::tree::TerminalNode* CURRENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOGFILE();
    antlr4::tree::TerminalNode* LOGFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DISCONNECT();
    antlr4::tree::TerminalNode* DISCONNECT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NODELAY();
    antlr4::tree::TerminalNode* NODELAY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNTIL();
    antlr4::tree::TerminalNode* UNTIL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHANGE();
    antlr4::tree::TerminalNode* CHANGE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSISTENT();
    antlr4::tree::TerminalNode* CONSISTENT(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FROM();
    antlr4::tree::TerminalNode* FROM(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SESSION();
    antlr4::tree::TerminalNode* SESSION(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Managed_standby_recoveryContext* managed_standby_recovery();

  class  Db_nameContext : public antlr4::ParserRuleContext {
  public:
    Db_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Db_nameContext* db_name();

  class  Database_file_clausesContext : public antlr4::ParserRuleContext {
  public:
    Database_file_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *FILE();
    antlr4::tree::TerminalNode *TO();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Create_datafile_clauseContext *create_datafile_clause();
    Alter_datafile_clauseContext *alter_datafile_clause();
    Alter_tempfile_clauseContext *alter_tempfile_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Database_file_clausesContext* database_file_clauses();

  class  Create_datafile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Create_datafile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *AS();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    antlr4::tree::TerminalNode *NEW();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_datafile_clauseContext* create_datafile_clause();

  class  Alter_datafile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_datafile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *RESIZE();
    Size_clauseContext *size_clause();
    Autoextend_clauseContext *autoextend_clause();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *BACKUP();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *DROP();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_datafile_clauseContext* alter_datafile_clause();

  class  Alter_tempfile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_tempfile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TEMPFILE();
    antlr4::tree::TerminalNode *RESIZE();
    Size_clauseContext *size_clause();
    Autoextend_clauseContext *autoextend_clause();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *DATAFILES();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tempfile_clauseContext* alter_tempfile_clause();

  class  Logfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Logfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ARCHIVELOG();
    antlr4::tree::TerminalNode *NOARCHIVELOG();
    antlr4::tree::TerminalNode *MANUAL();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *FILE();
    antlr4::tree::TerminalNode *TO();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *CLEAR();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *UNARCHIVED();
    std::vector<Logfile_descriptorContext *> logfile_descriptor();
    Logfile_descriptorContext* logfile_descriptor(size_t i);
    antlr4::tree::TerminalNode *UNRECOVERABLE();
    antlr4::tree::TerminalNode *DATAFILE();
    Add_logfile_clausesContext *add_logfile_clauses();
    Drop_logfile_clausesContext *drop_logfile_clauses();
    Switch_logfile_clauseContext *switch_logfile_clause();
    Supplemental_db_loggingContext *supplemental_db_logging();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logfile_clausesContext* logfile_clauses();

  class  Add_logfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Add_logfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *STANDBY();
    std::vector<Log_file_groupContext *> log_file_group();
    Log_file_groupContext* log_file_group(size_t i);
    std::vector<Redo_log_file_specContext *> redo_log_file_spec();
    Redo_log_file_specContext* redo_log_file_spec(size_t i);
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<Logfile_descriptorContext *> logfile_descriptor();
    Logfile_descriptorContext* logfile_descriptor(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REUSE();
    antlr4::tree::TerminalNode* REUSE(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_logfile_clausesContext* add_logfile_clauses();

  class  Log_file_groupContext : public antlr4::ParserRuleContext {
  public:
    Log_file_groupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *THREAD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Log_file_groupContext* log_file_group();

  class  Drop_logfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Drop_logfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *STANDBY();
    std::vector<Logfile_descriptorContext *> logfile_descriptor();
    Logfile_descriptorContext* logfile_descriptor(size_t i);
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_logfile_clausesContext* drop_logfile_clauses();

  class  Switch_logfile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Switch_logfile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SWITCH();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LOGFILES();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *BLOCKSIZE();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Switch_logfile_clauseContext* switch_logfile_clause();

  class  Supplemental_db_loggingContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_db_loggingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_or_dropContext *add_or_drop();
    antlr4::tree::TerminalNode *SUPPLEMENTAL();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *DATA();
    Supplemental_id_key_clauseContext *supplemental_id_key_clause();
    Supplemental_plsql_clauseContext *supplemental_plsql_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_db_loggingContext* supplemental_db_logging();

  class  Add_or_dropContext : public antlr4::ParserRuleContext {
  public:
    Add_or_dropContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *DROP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_or_dropContext* add_or_drop();

  class  Supplemental_plsql_clauseContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_plsql_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *PROCEDURAL();
    antlr4::tree::TerminalNode *REPLICATION();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_plsql_clauseContext* supplemental_plsql_clause();

  class  Logfile_descriptorContext : public antlr4::ParserRuleContext {
  public:
    Logfile_descriptorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logfile_descriptorContext* logfile_descriptor();

  class  Controlfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Controlfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *AS();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *TO();
    Trace_file_clauseContext *trace_file_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Controlfile_clausesContext* controlfile_clauses();

  class  Trace_file_clauseContext : public antlr4::ParserRuleContext {
  public:
    Trace_file_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRACE();
    antlr4::tree::TerminalNode *AS();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *NORESETLOGS();
    antlr4::tree::TerminalNode *REUSE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trace_file_clauseContext* trace_file_clause();

  class  Standby_database_clausesContext : public antlr4::ParserRuleContext {
  public:
    Standby_database_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Activate_standby_db_clauseContext *activate_standby_db_clause();
    Maximize_standby_db_clauseContext *maximize_standby_db_clause();
    Register_logfile_clauseContext *register_logfile_clause();
    Commit_switchover_clauseContext *commit_switchover_clause();
    Start_standby_clauseContext *start_standby_clause();
    Stop_standby_clauseContext *stop_standby_clause();
    Convert_database_clauseContext *convert_database_clause();
    Parallel_clauseContext *parallel_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standby_database_clausesContext* standby_database_clauses();

  class  Activate_standby_db_clauseContext : public antlr4::ParserRuleContext {
  public:
    Activate_standby_db_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACTIVATE();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *LOGICAL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Activate_standby_db_clauseContext* activate_standby_db_clause();

  class  Maximize_standby_db_clauseContext : public antlr4::ParserRuleContext {
  public:
    Maximize_standby_db_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *MAXIMIZE();
    antlr4::tree::TerminalNode *PROTECTION();
    antlr4::tree::TerminalNode *AVAILABILITY();
    antlr4::tree::TerminalNode *PERFORMANCE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Maximize_standby_db_clauseContext* maximize_standby_db_clause();

  class  Register_logfile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Register_logfile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REGISTER();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Register_logfile_clauseContext* register_logfile_clause();

  class  Commit_switchover_clauseContext : public antlr4::ParserRuleContext {
  public:
    Commit_switchover_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> TO();
    antlr4::tree::TerminalNode* TO(size_t i);
    antlr4::tree::TerminalNode *SWITCHOVER();
    antlr4::tree::TerminalNode *PREPARE();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *CANCEL();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *SHUTDOWN();
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *NOWAIT();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *WITHOUT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Commit_switchover_clauseContext* commit_switchover_clause();

  class  Start_standby_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *scn_value = nullptr;;
    Start_standby_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *NODELAY();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *PRIMARY();
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *INITIAL();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *FAILED();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_standby_clauseContext* start_standby_clause();

  class  Stop_standby_clauseContext : public antlr4::ParserRuleContext {
  public:
    Stop_standby_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *STOP();
    antlr4::tree::TerminalNode *ABORT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Stop_standby_clauseContext* stop_standby_clause();

  class  Convert_database_clauseContext : public antlr4::ParserRuleContext {
  public:
    Convert_database_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *SNAPSHOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Convert_database_clauseContext* convert_database_clause();

  class  Default_settings_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_settings_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *EDITION();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Edition_nameContext *edition_name();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *SMALLFILE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *TEMPORARY();
    Tablespace_group_nameContext *tablespace_group_name();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *GLOBAL_NAME();
    antlr4::tree::TerminalNode *TO();
    DatabaseContext *database();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<DomainContext *> domain();
    DomainContext* domain(size_t i);
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *TRACKING();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *FILE();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *DISABLE();
    Flashback_mode_clauseContext *flashback_mode_clause();
    Set_time_zone_clauseContext *set_time_zone_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_settings_clauseContext* default_settings_clause();

  class  Set_time_zone_clauseContext : public antlr4::ParserRuleContext {
  public:
    Set_time_zone_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *TIMEZONE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_time_zone_clauseContext* set_time_zone_clause();

  class  Instance_clausesContext : public antlr4::ParserRuleContext {
  public:
    Instance_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *INSTANCE();
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Instance_clausesContext* instance_clauses();

  class  Security_clauseContext : public antlr4::ParserRuleContext {
  public:
    Security_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GUARD();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *NONE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Security_clauseContext* security_clause();

  class  DomainContext : public antlr4::ParserRuleContext {
  public:
    DomainContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  DomainContext* domain();

  class  DatabaseContext : public antlr4::ParserRuleContext {
  public:
    DatabaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  DatabaseContext* database();

  class  Edition_nameContext : public antlr4::ParserRuleContext {
  public:
    Edition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Edition_nameContext* edition_name();

  class  FilenumberContext : public antlr4::ParserRuleContext {
  public:
    FilenumberContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  FilenumberContext* filenumber();

  class  FilenameContext : public antlr4::ParserRuleContext {
  public:
    FilenameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  FilenameContext* filename();

  class  Alter_tableContext : public antlr4::ParserRuleContext {
  public:
    Alter_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    std::vector<antlr4::tree::TerminalNode *> TABLE();
    antlr4::tree::TerminalNode* TABLE(size_t i);
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *SEMICOLON();
    Alter_table_propertiesContext *alter_table_properties();
    Constraint_clausesContext *constraint_clauses();
    Column_clausesContext *column_clauses();
    Move_table_clauseContext *move_table_clause();
    std::vector<Enable_disable_clauseContext *> enable_disable_clause();
    Enable_disable_clauseContext* enable_disable_clause(size_t i);
    std::vector<Enable_or_disableContext *> enable_or_disable();
    Enable_or_disableContext* enable_or_disable(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOCK();
    antlr4::tree::TerminalNode* LOCK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TRIGGERS();
    antlr4::tree::TerminalNode* TRIGGERS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tableContext* alter_table();

  class  Alter_table_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Alter_table_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Alter_table_properties_1Context *alter_table_properties_1();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    Tableview_nameContext *tableview_name();
    Shrink_clauseContext *shrink_clause();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *REKEY();
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_table_propertiesContext* alter_table_properties();

  class  Alter_table_properties_1Context : public antlr4::ParserRuleContext {
  public:
    Alter_table_properties_1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<Table_compressionContext *> table_compression();
    Table_compressionContext* table_compression(size_t i);
    std::vector<Supplemental_table_loggingContext *> supplemental_table_logging();
    Supplemental_table_loggingContext* supplemental_table_logging(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RESULT_CACHE();
    antlr4::tree::TerminalNode* RESULT_CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MODE();
    antlr4::tree::TerminalNode* MODE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Upgrade_table_clauseContext *> upgrade_table_clause();
    Upgrade_table_clauseContext* upgrade_table_clause(size_t i);
    std::vector<Records_per_block_clauseContext *> records_per_block_clause();
    Records_per_block_clauseContext* records_per_block_clause(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<Row_movement_clauseContext *> row_movement_clause();
    Row_movement_clauseContext* row_movement_clause(size_t i);
    std::vector<Flashback_archive_clauseContext *> flashback_archive_clause();
    Flashback_archive_clauseContext* flashback_archive_clause(size_t i);
    Alter_iot_clausesContext *alter_iot_clauses();
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_table_properties_1Context* alter_table_properties_1();

  class  Alter_iot_clausesContext : public antlr4::ParserRuleContext {
  public:
    Alter_iot_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_org_table_clauseContext *index_org_table_clause();
    Alter_overflow_clauseContext *alter_overflow_clause();
    Alter_mapping_table_clauseContext *alter_mapping_table_clause();
    antlr4::tree::TerminalNode *COALESCE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_iot_clausesContext* alter_iot_clauses();

  class  Alter_mapping_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_mapping_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *TABLE();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Deallocate_unused_clauseContext *deallocate_unused_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_mapping_table_clauseContext* alter_mapping_table_clause();

  class  Alter_overflow_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_overflow_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_overflow_clauseContext *add_overflow_clause();
    antlr4::tree::TerminalNode *OVERFLOW();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Shrink_clauseContext *> shrink_clause();
    Shrink_clauseContext* shrink_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_overflow_clauseContext* alter_overflow_clause();

  class  Add_overflow_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_overflow_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *OVERFLOW();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_overflow_clauseContext* add_overflow_clause();

  class  Enable_disable_clauseContext : public antlr4::ParserRuleContext {
  public:
    Enable_disable_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Using_index_clauseContext *using_index_clause();
    Exceptions_clauseContext *exceptions_clause();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *VALIDATE();
    antlr4::tree::TerminalNode *NOVALIDATE();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *DROP();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Enable_disable_clauseContext* enable_disable_clause();

  class  Using_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Using_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Create_indexContext *create_index();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Index_attributesContext *index_attributes();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_index_clauseContext* using_index_clause();

  class  Index_attributesContext : public antlr4::ParserRuleContext {
  public:
    Index_attributesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<Sort_or_nosortContext *> sort_or_nosort();
    Sort_or_nosortContext* sort_or_nosort(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REVERSE();
    antlr4::tree::TerminalNode* REVERSE(size_t i);
    std::vector<Visible_or_invisibleContext *> visible_or_invisible();
    Visible_or_invisibleContext* visible_or_invisible(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_attributesContext* index_attributes();

  class  Sort_or_nosortContext : public antlr4::ParserRuleContext {
  public:
    Sort_or_nosortContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *NOSORT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sort_or_nosortContext* sort_or_nosort();

  class  Exceptions_clauseContext : public antlr4::ParserRuleContext {
  public:
    Exceptions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exceptions_clauseContext* exceptions_clause();

  class  Move_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Move_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *ONLINE();
    Segment_attributes_clauseContext *segment_attributes_clause();
    Table_compressionContext *table_compression();
    Index_org_table_clauseContext *index_org_table_clause();
    Parallel_clauseContext *parallel_clause();
    std::vector<Lob_storage_clauseContext *> lob_storage_clause();
    Lob_storage_clauseContext* lob_storage_clause(size_t i);
    std::vector<Varray_col_propertiesContext *> varray_col_properties();
    Varray_col_propertiesContext* varray_col_properties(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_table_clauseContext* move_table_clause();

  class  Index_org_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_org_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Mapping_table_clauseContext *mapping_table_clause();
    antlr4::tree::TerminalNode *PCTTHRESHOLD();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Key_compressionContext *key_compression();
    Index_org_overflow_clauseContext *index_org_overflow_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_org_table_clauseContext* index_org_table_clause();

  class  Mapping_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Mapping_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *NOMAPPING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Mapping_table_clauseContext* mapping_table_clause();

  class  Key_compressionContext : public antlr4::ParserRuleContext {
  public:
    Key_compressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOCOMPRESS();
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Key_compressionContext* key_compression();

  class  Index_org_overflow_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_org_overflow_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OVERFLOW();
    antlr4::tree::TerminalNode *INCLUDING();
    Column_nameContext *column_name();
    Segment_attributes_clauseContext *segment_attributes_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_org_overflow_clauseContext* index_org_overflow_clause();

  class  Column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_modify_drop_column_clausesContext *add_modify_drop_column_clauses();
    Rename_column_clauseContext *rename_column_clause();
    Modify_collection_retrievalContext *modify_collection_retrieval();
    Modify_lob_storage_clauseContext *modify_lob_storage_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_clausesContext* column_clauses();

  class  Modify_collection_retrievalContext : public antlr4::ParserRuleContext {
  public:
    Modify_collection_retrievalContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *TABLE();
    Collection_itemContext *collection_item();
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LOCATOR();
    antlr4::tree::TerminalNode *VALUE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_collection_retrievalContext* modify_collection_retrieval();

  class  Collection_itemContext : public antlr4::ParserRuleContext {
  public:
    Collection_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collection_itemContext* collection_item();

  class  Rename_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rename_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *COLUMN();
    Old_column_nameContext *old_column_name();
    antlr4::tree::TerminalNode *TO();
    New_column_nameContext *new_column_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rename_column_clauseContext* rename_column_clause();

  class  Old_column_nameContext : public antlr4::ParserRuleContext {
  public:
    Old_column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Old_column_nameContext* old_column_name();

  class  New_column_nameContext : public antlr4::ParserRuleContext {
  public:
    New_column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_column_nameContext* new_column_name();

  class  Add_modify_drop_column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Add_modify_drop_column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Add_column_clauseContext *> add_column_clause();
    Add_column_clauseContext* add_column_clause(size_t i);
    std::vector<Modify_column_clausesContext *> modify_column_clauses();
    Modify_column_clausesContext* modify_column_clauses(size_t i);
    std::vector<Drop_column_clauseContext *> drop_column_clause();
    Drop_column_clauseContext* drop_column_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_modify_drop_column_clausesContext* add_modify_drop_column_clauses();

  class  Drop_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *UNUSED();
    antlr4::tree::TerminalNode *COLUMN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CASCADE();
    antlr4::tree::TerminalNode* CASCADE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSTRAINTS();
    antlr4::tree::TerminalNode* CONSTRAINTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INVALIDATE();
    antlr4::tree::TerminalNode* INVALIDATE(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *CHECKPOINT();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *COLUMNS();
    antlr4::tree::TerminalNode *CONTINUE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_column_clauseContext* drop_column_clause();

  class  Modify_column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Modify_column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Modify_col_propertiesContext *> modify_col_properties();
    Modify_col_propertiesContext* modify_col_properties(size_t i);
    Modify_col_substitutableContext *modify_col_substitutable();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_column_clausesContext* modify_column_clauses();

  class  Modify_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Modify_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    DatatypeContext *datatype();
    antlr4::tree::TerminalNode *DEFAULT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ENCRYPT();
    Encryption_specContext *encryption_spec();
    antlr4::tree::TerminalNode *DECRYPT();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);
    Lob_storage_clauseContext *lob_storage_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_col_propertiesContext* modify_col_properties();

  class  Modify_col_substitutableContext : public antlr4::ParserRuleContext {
  public:
    Modify_col_substitutableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COLUMN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *FORCE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_col_substitutableContext* modify_col_substitutable();

  class  Add_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_propertiesContext *column_properties();
    std::vector<Column_definitionContext *> column_definition();
    Column_definitionContext* column_definition(size_t i);
    std::vector<Virtual_column_definitionContext *> virtual_column_definition();
    Virtual_column_definitionContext* virtual_column_definition(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_column_clauseContext* add_column_clause();

  class  Alter_varray_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Alter_varray_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *VARRAY();
    Varray_itemContext *varray_item();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Modify_lob_parametersContext *modify_lob_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_varray_col_propertiesContext* alter_varray_col_properties();

  class  Varray_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Varray_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VARRAY();
    Varray_itemContext *varray_item();
    Varray_storage_clauseContext *varray_storage_clause();
    Substitutable_column_clauseContext *substitutable_column_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_col_propertiesContext* varray_col_properties();

  class  Varray_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Varray_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LOB();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Lob_storage_parametersContext *lob_storage_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Lob_segnameContext *lob_segname();
    antlr4::tree::TerminalNode *SECUREFILE();
    antlr4::tree::TerminalNode *BASICFILE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_storage_clauseContext* varray_storage_clause();

  class  Lob_segnameContext : public antlr4::ParserRuleContext {
  public:
    Lob_segnameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_segnameContext* lob_segname();

  class  Lob_itemContext : public antlr4::ParserRuleContext {
  public:
    Lob_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_itemContext* lob_item();

  class  Lob_storage_parametersContext : public antlr4::ParserRuleContext {
  public:
    Lob_storage_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    Lob_parametersContext *lob_parameters();
    Storage_clauseContext *storage_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_storage_parametersContext* lob_storage_parameters();

  class  Lob_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOB();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    std::vector<Lob_itemContext *> lob_item();
    Lob_itemContext* lob_item(size_t i);
    std::vector<Lob_storage_parametersContext *> lob_storage_parameters();
    Lob_storage_parametersContext* lob_storage_parameters(size_t i);
    std::vector<Lob_segnameContext *> lob_segname();
    Lob_segnameContext* lob_segname(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECUREFILE();
    antlr4::tree::TerminalNode* SECUREFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BASICFILE();
    antlr4::tree::TerminalNode* BASICFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_storage_clauseContext* lob_storage_clause();

  class  Modify_lob_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modify_lob_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LOB();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Lob_itemContext *lob_item();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Modify_lob_parametersContext *modify_lob_parameters();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_lob_storage_clauseContext* modify_lob_storage_clause();

  class  Modify_lob_parametersContext : public antlr4::ParserRuleContext {
  public:
    Modify_lob_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Storage_clauseContext *> storage_clause();
    Storage_clauseContext* storage_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REBUILD();
    antlr4::tree::TerminalNode* REBUILD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREEPOOLS();
    antlr4::tree::TerminalNode* FREEPOOLS(size_t i);
    std::vector<Lob_retention_clauseContext *> lob_retention_clause();
    Lob_retention_clauseContext* lob_retention_clause(size_t i);
    std::vector<Lob_deduplicate_clauseContext *> lob_deduplicate_clause();
    Lob_deduplicate_clauseContext* lob_deduplicate_clause(size_t i);
    std::vector<Lob_compression_clauseContext *> lob_compression_clause();
    Lob_compression_clauseContext* lob_compression_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPT();
    antlr4::tree::TerminalNode* ENCRYPT(size_t i);
    std::vector<Encryption_specContext *> encryption_spec();
    Encryption_specContext* encryption_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DECRYPT();
    antlr4::tree::TerminalNode* DECRYPT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Shrink_clauseContext *> shrink_clause();
    Shrink_clauseContext* shrink_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTVERSION();
    antlr4::tree::TerminalNode* PCTVERSION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> READS();
    antlr4::tree::TerminalNode* READS(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_lob_parametersContext* modify_lob_parameters();

  class  Lob_parametersContext : public antlr4::ParserRuleContext {
  public:
    Lob_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> STORAGE();
    antlr4::tree::TerminalNode* STORAGE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IN();
    antlr4::tree::TerminalNode* IN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROW();
    antlr4::tree::TerminalNode* ROW(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHUNK();
    antlr4::tree::TerminalNode* CHUNK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTVERSION();
    antlr4::tree::TerminalNode* PCTVERSION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREEPOOLS();
    antlr4::tree::TerminalNode* FREEPOOLS(size_t i);
    std::vector<Lob_retention_clauseContext *> lob_retention_clause();
    Lob_retention_clauseContext* lob_retention_clause(size_t i);
    std::vector<Lob_deduplicate_clauseContext *> lob_deduplicate_clause();
    Lob_deduplicate_clauseContext* lob_deduplicate_clause(size_t i);
    std::vector<Lob_compression_clauseContext *> lob_compression_clause();
    Lob_compression_clauseContext* lob_compression_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPT();
    antlr4::tree::TerminalNode* ENCRYPT(size_t i);
    std::vector<Encryption_specContext *> encryption_spec();
    Encryption_specContext* encryption_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DECRYPT();
    antlr4::tree::TerminalNode* DECRYPT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENABLE();
    antlr4::tree::TerminalNode* ENABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DISABLE();
    antlr4::tree::TerminalNode* DISABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> READS();
    antlr4::tree::TerminalNode* READS(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_parametersContext* lob_parameters();

  class  Lob_deduplicate_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_deduplicate_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEDUPLICATE();
    antlr4::tree::TerminalNode *KEEP_DUPLICATES();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_deduplicate_clauseContext* lob_deduplicate_clause();

  class  Lob_compression_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_compression_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOCOMPRESS();
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *MEDIUM();
    antlr4::tree::TerminalNode *LOW();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_compression_clauseContext* lob_compression_clause();

  class  Lob_retention_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_retention_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *NONE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_retention_clauseContext* lob_retention_clause();

  class  Encryption_specContext : public antlr4::ParserRuleContext {
  public:
    Encryption_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *SALT();
    antlr4::tree::TerminalNode *NO();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Encryption_specContext* encryption_spec();

  class  TablespaceContext : public antlr4::ParserRuleContext {
  public:
    TablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  TablespaceContext* tablespace();

  class  Varray_itemContext : public antlr4::ParserRuleContext {
  public:
    Varray_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_itemContext* varray_item();

  class  Column_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Column_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Object_type_col_propertiesContext *object_type_col_properties();
    Nested_table_col_propertiesContext *nested_table_col_properties();
    Varray_col_propertiesContext *varray_col_properties();
    Lob_storage_clauseContext *lob_storage_clause();
    Xmltype_column_propertiesContext *xmltype_column_properties();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_propertiesContext* column_properties();

  class  Period_definitionContext : public antlr4::ParserRuleContext {
  public:
    Period_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Start_time_columnContext *start_time_column();
    antlr4::tree::TerminalNode *COMMA();
    End_time_columnContext *end_time_column();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Period_definitionContext* period_definition();

  class  Start_time_columnContext : public antlr4::ParserRuleContext {
  public:
    Start_time_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_time_columnContext* start_time_column();

  class  End_time_columnContext : public antlr4::ParserRuleContext {
  public:
    End_time_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  End_time_columnContext* end_time_column();

  class  Column_definitionContext : public antlr4::ParserRuleContext {
  public:
    Column_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    DatatypeContext *datatype();
    Type_nameContext *type_name();
    Inline_ref_constraintContext *inline_ref_constraint();
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *DEFAULT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ENCRYPT();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);
    antlr4::tree::TerminalNode *USING();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *SALT();
    antlr4::tree::TerminalNode *NO();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_definitionContext* column_definition();

  class  Virtual_column_definitionContext : public antlr4::ParserRuleContext {
  public:
    Virtual_column_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    DatatypeContext *datatype();
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *ALWAYS();
    antlr4::tree::TerminalNode *VIRTUAL();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Virtual_column_definitionContext* virtual_column_definition();

  class  Out_of_line_part_storageContext : public antlr4::ParserRuleContext {
  public:
    Out_of_line_part_storageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Out_of_line_part_storageContext* out_of_line_part_storage();

  class  Nested_table_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Nested_table_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *STORE();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    Tableview_nameContext *tableview_name();
    Nested_itemContext *nested_item();
    antlr4::tree::TerminalNode *COLUMN_VALUE();
    Substitutable_column_clauseContext *substitutable_column_clause();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *LOCATOR();
    antlr4::tree::TerminalNode *VALUE();
    std::vector<Object_propertiesContext *> object_properties();
    Object_propertiesContext* object_properties(size_t i);
    std::vector<Physical_propertiesContext *> physical_properties();
    Physical_propertiesContext* physical_properties(size_t i);
    std::vector<Column_propertiesContext *> column_properties();
    Column_propertiesContext* column_properties(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Nested_table_col_propertiesContext* nested_table_col_properties();

  class  Nested_itemContext : public antlr4::ParserRuleContext {
  public:
    Nested_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Nested_itemContext* nested_item();

  class  Substitutable_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Substitutable_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *NOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Substitutable_column_clauseContext* substitutable_column_clause();

  class  Partition_nameContext : public antlr4::ParserRuleContext {
  public:
    Partition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_nameContext* partition_name();

  class  Supplemental_logging_propsContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_logging_propsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUPPLEMENTAL();
    antlr4::tree::TerminalNode *LOG();
    Supplemental_log_grp_clauseContext *supplemental_log_grp_clause();
    Supplemental_id_key_clauseContext *supplemental_id_key_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_logging_propsContext* supplemental_logging_props();

  class  Column_or_attributeContext : public antlr4::ParserRuleContext {
  public:
    Column_or_attributeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_or_attributeContext* column_or_attribute();

  class  Object_type_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Regular_idContext *column = nullptr;;
    Object_type_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COLUMN();
    Substitutable_column_clauseContext *substitutable_column_clause();
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_type_col_propertiesContext* object_type_col_properties();

  class  Constraint_clausesContext : public antlr4::ParserRuleContext {
  public:
    Constraint_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Out_of_line_ref_constraintContext *out_of_line_ref_constraint();
    std::vector<Out_of_line_constraintContext *> out_of_line_constraint();
    Out_of_line_constraintContext* out_of_line_constraint(size_t i);
    antlr4::tree::TerminalNode *MODIFY();
    Constraint_stateContext *constraint_state();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *CASCADE();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RENAME();
    Old_constraint_nameContext *old_constraint_name();
    antlr4::tree::TerminalNode *TO();
    New_constraint_nameContext *new_constraint_name();
    std::vector<Drop_constraint_clauseContext *> drop_constraint_clause();
    Drop_constraint_clauseContext* drop_constraint_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constraint_clausesContext* constraint_clauses();

  class  Old_constraint_nameContext : public antlr4::ParserRuleContext {
  public:
    Old_constraint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Old_constraint_nameContext* old_constraint_name();

  class  New_constraint_nameContext : public antlr4::ParserRuleContext {
  public:
    New_constraint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_constraint_nameContext* new_constraint_name();

  class  Drop_constraint_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_constraint_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    Drop_primary_key_or_unique_or_generic_clauseContext *drop_primary_key_or_unique_or_generic_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_constraint_clauseContext* drop_constraint_clause();

  class  Drop_primary_key_or_unique_or_generic_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_primary_key_or_unique_or_generic_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *DROP();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_primary_key_or_unique_or_generic_clauseContext* drop_primary_key_or_unique_or_generic_clause();

  class  Add_constraintContext : public antlr4::ParserRuleContext {
  public:
    Add_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    std::vector<Primary_key_clauseContext *> primary_key_clause();
    Primary_key_clauseContext* primary_key_clause(size_t i);
    std::vector<Foreign_key_clauseContext *> foreign_key_clause();
    Foreign_key_clauseContext* foreign_key_clause(size_t i);
    std::vector<Unique_key_clauseContext *> unique_key_clause();
    Unique_key_clauseContext* unique_key_clause(size_t i);
    std::vector<Check_constraintContext *> check_constraint();
    Check_constraintContext* check_constraint(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSTRAINT();
    antlr4::tree::TerminalNode* CONSTRAINT(size_t i);
    std::vector<Constraint_nameContext *> constraint_name();
    Constraint_nameContext* constraint_name(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_constraintContext* add_constraint();

  class  Check_constraintContext : public antlr4::ParserRuleContext {
  public:
    Check_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHECK();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DISABLE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Check_constraintContext* check_constraint();

  class  Drop_constraintContext : public antlr4::ParserRuleContext {
  public:
    Drop_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_constraintContext* drop_constraint();

  class  Enable_constraintContext : public antlr4::ParserRuleContext {
  public:
    Enable_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Enable_constraintContext* enable_constraint();

  class  Disable_constraintContext : public antlr4::ParserRuleContext {
  public:
    Disable_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Disable_constraintContext* disable_constraint();

  class  Foreign_key_clauseContext : public antlr4::ParserRuleContext {
  public:
    Foreign_key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOREIGN();
    antlr4::tree::TerminalNode *KEY();
    Paren_column_listContext *paren_column_list();
    References_clauseContext *references_clause();
    On_delete_clauseContext *on_delete_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Foreign_key_clauseContext* foreign_key_clause();

  class  References_clauseContext : public antlr4::ParserRuleContext {
  public:
    References_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFERENCES();
    Tableview_nameContext *tableview_name();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  References_clauseContext* references_clause();

  class  On_delete_clauseContext : public antlr4::ParserRuleContext {
  public:
    On_delete_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *NULL_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_delete_clauseContext* on_delete_clause();

  class  Unique_key_clauseContext : public antlr4::ParserRuleContext {
  public:
    Unique_key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNIQUE();
    Paren_column_listContext *paren_column_list();
    Using_index_clauseContext *using_index_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unique_key_clauseContext* unique_key_clause();

  class  Primary_key_clauseContext : public antlr4::ParserRuleContext {
  public:
    Primary_key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    Paren_column_listContext *paren_column_list();
    Using_index_clauseContext *using_index_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Primary_key_clauseContext* primary_key_clause();

  class  Anonymous_blockContext : public antlr4::ParserRuleContext {
  public:
    Anonymous_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BEGIN();
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    antlr4::tree::TerminalNode *EXCEPTION();
    std::vector<Exception_handlerContext *> exception_handler();
    Exception_handlerContext* exception_handler(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Anonymous_blockContext* anonymous_block();

  class  Invoker_rights_clauseContext : public antlr4::ParserRuleContext {
  public:
    Invoker_rights_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUTHID();
    antlr4::tree::TerminalNode *CURRENT_USER();
    antlr4::tree::TerminalNode *DEFINER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Invoker_rights_clauseContext* invoker_rights_clause();

  class  Call_specContext : public antlr4::ParserRuleContext {
  public:
    Call_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LANGUAGE();
    Java_specContext *java_spec();
    C_specContext *c_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Call_specContext* call_spec();

  class  Java_specContext : public antlr4::ParserRuleContext {
  public:
    Java_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *CHAR_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Java_specContext* java_spec();

  class  C_specContext : public antlr4::ParserRuleContext {
  public:
    C_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *C_LETTER();
    antlr4::tree::TerminalNode *LIBRARY();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *CHAR_STRING();
    C_agent_in_clauseContext *c_agent_in_clause();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *CONTEXT();
    C_parameters_clauseContext *c_parameters_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_specContext* c_spec();

  class  C_agent_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    C_agent_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AGENT();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_agent_in_clauseContext* c_agent_in_clause();

  class  C_parameters_clauseContext : public antlr4::ParserRuleContext {
  public:
    C_parameters_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_parameters_clauseContext* c_parameters_clause();

  class  ParameterContext : public antlr4::ParserRuleContext {
  public:
    ParameterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    Type_specContext *type_spec();
    Default_value_partContext *default_value_part();
    std::vector<antlr4::tree::TerminalNode *> IN();
    antlr4::tree::TerminalNode* IN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OUT();
    antlr4::tree::TerminalNode* OUT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INOUT();
    antlr4::tree::TerminalNode* INOUT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCOPY();
    antlr4::tree::TerminalNode* NOCOPY(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ParameterContext* parameter();

  class  Default_value_partContext : public antlr4::ParserRuleContext {
  public:
    Default_value_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ASSIGN_OP();
    antlr4::tree::TerminalNode *DEFAULT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_value_partContext* default_value_part();

  class  Seq_of_declare_specsContext : public antlr4::ParserRuleContext {
  public:
    Seq_of_declare_specsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Declare_specContext *> declare_spec();
    Declare_specContext* declare_spec(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Seq_of_declare_specsContext* seq_of_declare_specs();

  class  Declare_specContext : public antlr4::ParserRuleContext {
  public:
    Declare_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pragma_declarationContext *pragma_declaration();
    Variable_declarationContext *variable_declaration();
    Subtype_declarationContext *subtype_declaration();
    Cursor_declarationContext *cursor_declaration();
    Exception_declarationContext *exception_declaration();
    Type_declarationContext *type_declaration();
    Procedure_specContext *procedure_spec();
    Function_specContext *function_spec();
    Procedure_bodyContext *procedure_body();
    Function_bodyContext *function_body();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Declare_specContext* declare_spec();

  class  Variable_declarationContext : public antlr4::ParserRuleContext {
  public:
    Variable_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *CONSTANT();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    Default_value_partContext *default_value_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Variable_declarationContext* variable_declaration();

  class  Subtype_declarationContext : public antlr4::ParserRuleContext {
  public:
    Subtype_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBTYPE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *IS();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *DOUBLE_PERIOD();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subtype_declarationContext* subtype_declaration();

  class  Cursor_declarationContext : public antlr4::ParserRuleContext {
  public:
    Cursor_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURSOR();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *IS();
    Select_statementContext *select_statement();
    std::vector<Parameter_specContext *> parameter_spec();
    Parameter_specContext* parameter_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_declarationContext* cursor_declaration();

  class  Parameter_specContext : public antlr4::ParserRuleContext {
  public:
    Parameter_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    Type_specContext *type_spec();
    Default_value_partContext *default_value_part();
    antlr4::tree::TerminalNode *IN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parameter_specContext* parameter_spec();

  class  Exception_declarationContext : public antlr4::ParserRuleContext {
  public:
    Exception_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *EXCEPTION();
    antlr4::tree::TerminalNode *SEMICOLON();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exception_declarationContext* exception_declaration();

  class  Pragma_declarationContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::IdentifierContext *id1 = nullptr;;
    Pragma_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRAGMA();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *SERIALLY_REUSABLE();
    antlr4::tree::TerminalNode *AUTONOMOUS_TRANSACTION();
    antlr4::tree::TerminalNode *EXCEPTION_INIT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Exception_nameContext *exception_name();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Numeric_negativeContext *numeric_negative();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *INLINE();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RESTRICT_REFERENCES();
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    antlr4::tree::TerminalNode *DEFAULT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pragma_declarationContext* pragma_declaration();

  class  Record_type_defContext : public antlr4::ParserRuleContext {
  public:
    Record_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECORD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Field_specContext *> field_spec();
    Field_specContext* field_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Record_type_defContext* record_type_def();

  class  Field_specContext : public antlr4::ParserRuleContext {
  public:
    Field_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    Default_value_partContext *default_value_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Field_specContext* field_spec();

  class  Ref_cursor_type_defContext : public antlr4::ParserRuleContext {
  public:
    Ref_cursor_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ref_cursor_type_defContext* ref_cursor_type_def();

  class  Type_declarationContext : public antlr4::ParserRuleContext {
  public:
    Type_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TYPE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *SEMICOLON();
    Table_type_defContext *table_type_def();
    Varray_type_defContext *varray_type_def();
    Record_type_defContext *record_type_def();
    Ref_cursor_type_defContext *ref_cursor_type_def();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_declarationContext* type_declaration();

  class  Table_type_defContext : public antlr4::ParserRuleContext {
  public:
    Table_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *OF();
    Type_specContext *type_spec();
    Table_indexed_by_partContext *table_indexed_by_part();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_type_defContext* table_type_def();

  class  Table_indexed_by_partContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *idx1 = nullptr;;
    antlr4::Token *idx2 = nullptr;;
    Table_indexed_by_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BY();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *INDEXED();
    antlr4::tree::TerminalNode *INDEX();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_indexed_by_partContext* table_indexed_by_part();

  class  Varray_type_defContext : public antlr4::ParserRuleContext {
  public:
    Varray_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *OF();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *VARRAY();
    antlr4::tree::TerminalNode *VARYING();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_type_defContext* varray_type_def();

  class  Seq_of_statementsContext : public antlr4::ParserRuleContext {
  public:
    Seq_of_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<StatementContext *> statement();
    StatementContext* statement(size_t i);
    std::vector<Label_declarationContext *> label_declaration();
    Label_declarationContext* label_declaration(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEMICOLON();
    antlr4::tree::TerminalNode* SEMICOLON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EOF();
    antlr4::tree::TerminalNode* EOF(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Seq_of_statementsContext* seq_of_statements();

  class  Label_declarationContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ltp1 = nullptr;;
    Label_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LESS_THAN_OP();
    antlr4::tree::TerminalNode* LESS_THAN_OP(size_t i);
    Label_nameContext *label_name();
    std::vector<antlr4::tree::TerminalNode *> GREATER_THAN_OP();
    antlr4::tree::TerminalNode* GREATER_THAN_OP(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Label_declarationContext* label_declaration();

  class  StatementContext : public antlr4::ParserRuleContext {
  public:
    StatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BodyContext *body();
    BlockContext *block();
    Assignment_statementContext *assignment_statement();
    Continue_statementContext *continue_statement();
    Exit_statementContext *exit_statement();
    Goto_statementContext *goto_statement();
    If_statementContext *if_statement();
    Loop_statementContext *loop_statement();
    Forall_statementContext *forall_statement();
    Null_statementContext *null_statement();
    Raise_statementContext *raise_statement();
    Return_statementContext *return_statement();
    Case_statementContext *case_statement();
    Sql_statementContext *sql_statement();
    Function_callContext *function_call();
    Pipe_row_statementContext *pipe_row_statement();
    Procedure_callContext *procedure_call();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  StatementContext* statement();

  class  Swallow_to_semiContext : public antlr4::ParserRuleContext {
  public:
    Swallow_to_semiContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> SEMICOLON();
    antlr4::tree::TerminalNode* SEMICOLON(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Swallow_to_semiContext* swallow_to_semi();

  class  Assignment_statementContext : public antlr4::ParserRuleContext {
  public:
    Assignment_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASSIGN_OP();
    ExpressionContext *expression();
    General_elementContext *general_element();
    Bind_variableContext *bind_variable();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Assignment_statementContext* assignment_statement();

  class  Continue_statementContext : public antlr4::ParserRuleContext {
  public:
    Continue_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTINUE();
    Label_nameContext *label_name();
    antlr4::tree::TerminalNode *WHEN();
    ConditionContext *condition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Continue_statementContext* continue_statement();

  class  Exit_statementContext : public antlr4::ParserRuleContext {
  public:
    Exit_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXIT();
    Label_nameContext *label_name();
    antlr4::tree::TerminalNode *WHEN();
    ConditionContext *condition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exit_statementContext* exit_statement();

  class  Goto_statementContext : public antlr4::ParserRuleContext {
  public:
    Goto_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GOTO();
    Label_nameContext *label_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Goto_statementContext* goto_statement();

  class  If_statementContext : public antlr4::ParserRuleContext {
  public:
    If_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> IF();
    antlr4::tree::TerminalNode* IF(size_t i);
    ConditionContext *condition();
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    std::vector<Elsif_partContext *> elsif_part();
    Elsif_partContext* elsif_part(size_t i);
    Else_partContext *else_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  If_statementContext* if_statement();

  class  Elsif_partContext : public antlr4::ParserRuleContext {
  public:
    Elsif_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSIF();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Elsif_partContext* elsif_part();

  class  Else_partContext : public antlr4::ParserRuleContext {
  public:
    Else_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    Seq_of_statementsContext *seq_of_statements();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Else_partContext* else_part();

  class  Loop_statementContext : public antlr4::ParserRuleContext {
  public:
    Loop_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LOOP();
    antlr4::tree::TerminalNode* LOOP(size_t i);
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    Label_declarationContext *label_declaration();
    antlr4::tree::TerminalNode *WHILE();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *FOR();
    Cursor_loop_paramContext *cursor_loop_param();
    Label_nameContext *label_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Loop_statementContext* loop_statement();

  class  Cursor_loop_paramContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *range_separator = nullptr;;
    Cursor_loop_paramContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *IN();
    Lower_boundContext *lower_bound();
    Upper_boundContext *upper_bound();
    antlr4::tree::TerminalNode *DOUBLE_PERIOD();
    antlr4::tree::TerminalNode *REVERSE();
    Record_nameContext *record_name();
    Cursor_nameContext *cursor_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_loop_paramContext* cursor_loop_param();

  class  Forall_statementContext : public antlr4::ParserRuleContext {
  public:
    Forall_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FORALL();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *IN();
    Bounds_clauseContext *bounds_clause();
    Sql_statementContext *sql_statement();
    antlr4::tree::TerminalNode *SAVE();
    antlr4::tree::TerminalNode *EXCEPTIONS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Forall_statementContext* forall_statement();

  class  Bounds_clauseContext : public antlr4::ParserRuleContext {
  public:
    Bounds_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Lower_boundContext *lower_bound();
    antlr4::tree::TerminalNode *DOUBLE_PERIOD();
    Upper_boundContext *upper_bound();
    antlr4::tree::TerminalNode *INDICES();
    antlr4::tree::TerminalNode *OF();
    Collection_nameContext *collection_name();
    Between_boundContext *between_bound();
    antlr4::tree::TerminalNode *VALUES();
    Index_nameContext *index_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Bounds_clauseContext* bounds_clause();

  class  Between_boundContext : public antlr4::ParserRuleContext {
  public:
    Between_boundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BETWEEN();
    Lower_boundContext *lower_bound();
    antlr4::tree::TerminalNode *AND();
    Upper_boundContext *upper_bound();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Between_boundContext* between_bound();

  class  Lower_boundContext : public antlr4::ParserRuleContext {
  public:
    Lower_boundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lower_boundContext* lower_bound();

  class  Upper_boundContext : public antlr4::ParserRuleContext {
  public:
    Upper_boundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Upper_boundContext* upper_bound();

  class  Null_statementContext : public antlr4::ParserRuleContext {
  public:
    Null_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Null_statementContext* null_statement();

  class  Raise_statementContext : public antlr4::ParserRuleContext {
  public:
    Raise_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RAISE();
    Exception_nameContext *exception_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Raise_statementContext* raise_statement();

  class  Return_statementContext : public antlr4::ParserRuleContext {
  public:
    Return_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURN();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Return_statementContext* return_statement();

  class  Function_callContext : public antlr4::ParserRuleContext {
  public:
    Function_callContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Routine_nameContext *routine_name();
    antlr4::tree::TerminalNode *CALL();
    Function_argumentContext *function_argument();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_callContext* function_call();

  class  Procedure_callContext : public antlr4::ParserRuleContext {
  public:
    Procedure_callContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Routine_nameContext *routine_name();
    Function_argumentContext *function_argument();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Procedure_callContext* procedure_call();

  class  Pipe_row_statementContext : public antlr4::ParserRuleContext {
  public:
    Pipe_row_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PIPE();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pipe_row_statementContext* pipe_row_statement();

  class  BodyContext : public antlr4::ParserRuleContext {
  public:
    BodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BEGIN();
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *EXCEPTION();
    Label_nameContext *label_name();
    std::vector<Exception_handlerContext *> exception_handler();
    Exception_handlerContext* exception_handler(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  BodyContext* body();

  class  Exception_handlerContext : public antlr4::ParserRuleContext {
  public:
    Exception_handlerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    std::vector<Exception_nameContext *> exception_name();
    Exception_nameContext* exception_name(size_t i);
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();
    std::vector<antlr4::tree::TerminalNode *> OR();
    antlr4::tree::TerminalNode* OR(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exception_handlerContext* exception_handler();

  class  Trigger_blockContext : public antlr4::ParserRuleContext {
  public:
    Trigger_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BodyContext *body();
    antlr4::tree::TerminalNode *DECLARE();
    std::vector<Declare_specContext *> declare_spec();
    Declare_specContext* declare_spec(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_blockContext* trigger_block();

  class  BlockContext : public antlr4::ParserRuleContext {
  public:
    BlockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BodyContext *body();
    antlr4::tree::TerminalNode *DECLARE();
    std::vector<Declare_specContext *> declare_spec();
    Declare_specContext* declare_spec(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  BlockContext* block();

  class  Sql_statementContext : public antlr4::ParserRuleContext {
  public:
    Sql_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Execute_immediateContext *execute_immediate();
    Data_manipulation_language_statementsContext *data_manipulation_language_statements();
    Cursor_manipulation_statementsContext *cursor_manipulation_statements();
    Transaction_control_statementsContext *transaction_control_statements();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_statementContext* sql_statement();

  class  Execute_immediateContext : public antlr4::ParserRuleContext {
  public:
    Execute_immediateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *IMMEDIATE();
    ExpressionContext *expression();
    Into_clauseContext *into_clause();
    Using_clauseContext *using_clause();
    Dynamic_returning_clauseContext *dynamic_returning_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Execute_immediateContext* execute_immediate();

  class  Dynamic_returning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dynamic_returning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Into_clauseContext *into_clause();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *RETURN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dynamic_returning_clauseContext* dynamic_returning_clause();

  class  Data_manipulation_language_statementsContext : public antlr4::ParserRuleContext {
  public:
    Data_manipulation_language_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Merge_statementContext *merge_statement();
    Lock_table_statementContext *lock_table_statement();
    Select_statementContext *select_statement();
    Update_statementContext *update_statement();
    Delete_statementContext *delete_statement();
    Insert_statementContext *insert_statement();
    Explain_statementContext *explain_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Data_manipulation_language_statementsContext* data_manipulation_language_statements();

  class  Cursor_manipulation_statementsContext : public antlr4::ParserRuleContext {
  public:
    Cursor_manipulation_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Close_statementContext *close_statement();
    Open_statementContext *open_statement();
    Fetch_statementContext *fetch_statement();
    Open_for_statementContext *open_for_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_manipulation_statementsContext* cursor_manipulation_statements();

  class  Close_statementContext : public antlr4::ParserRuleContext {
  public:
    Close_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLOSE();
    Cursor_nameContext *cursor_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Close_statementContext* close_statement();

  class  Open_statementContext : public antlr4::ParserRuleContext {
  public:
    Open_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OPEN();
    Cursor_nameContext *cursor_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Open_statementContext* open_statement();

  class  Fetch_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *it1 = nullptr;;
    Fetch_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FETCH();
    Cursor_nameContext *cursor_name();
    antlr4::tree::TerminalNode *BULK();
    antlr4::tree::TerminalNode *COLLECT();
    antlr4::tree::TerminalNode *INTO();
    std::vector<Variable_nameContext *> variable_name();
    Variable_nameContext* variable_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Fetch_statementContext* fetch_statement();

  class  Open_for_statementContext : public antlr4::ParserRuleContext {
  public:
    Open_for_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OPEN();
    Variable_nameContext *variable_name();
    antlr4::tree::TerminalNode *FOR();
    Select_statementContext *select_statement();
    ExpressionContext *expression();
    Using_clauseContext *using_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Open_for_statementContext* open_for_statement();

  class  Transaction_control_statementsContext : public antlr4::ParserRuleContext {
  public:
    Transaction_control_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Set_transaction_commandContext *set_transaction_command();
    Set_constraint_commandContext *set_constraint_command();
    Commit_statementContext *commit_statement();
    Rollback_statementContext *rollback_statement();
    Savepoint_statementContext *savepoint_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Transaction_control_statementsContext* transaction_control_statements();

  class  Set_transaction_commandContext : public antlr4::ParserRuleContext {
  public:
    Set_transaction_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ISOLATION();
    antlr4::tree::TerminalNode *LEVEL();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    Rollback_segment_nameContext *rollback_segment_name();
    antlr4::tree::TerminalNode *NAME();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *SERIALIZABLE();
    antlr4::tree::TerminalNode *COMMITTED();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_transaction_commandContext* set_transaction_command();

  class  Set_constraint_commandContext : public antlr4::ParserRuleContext {
  public:
    Set_constraint_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *CONSTRAINT();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *DEFERRED();
    antlr4::tree::TerminalNode *ALL();
    std::vector<Constraint_nameContext *> constraint_name();
    Constraint_nameContext* constraint_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_constraint_commandContext* set_constraint_command();

  class  Commit_statementContext : public antlr4::ParserRuleContext {
  public:
    Commit_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *WORK();
    antlr4::tree::TerminalNode *COMMENT();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *FORCE();
    Write_clauseContext *write_clause();
    antlr4::tree::TerminalNode *CORRUPT_XID();
    antlr4::tree::TerminalNode *CORRUPT_XID_ALL();
    antlr4::tree::TerminalNode *COMMA();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Commit_statementContext* commit_statement();

  class  Write_clauseContext : public antlr4::ParserRuleContext {
  public:
    Write_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *NOWAIT();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *BATCH();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Write_clauseContext* write_clause();

  class  Rollback_statementContext : public antlr4::ParserRuleContext {
  public:
    Rollback_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *WORK();
    antlr4::tree::TerminalNode *TO();
    Savepoint_nameContext *savepoint_name();
    antlr4::tree::TerminalNode *FORCE();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *SAVEPOINT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollback_statementContext* rollback_statement();

  class  Savepoint_statementContext : public antlr4::ParserRuleContext {
  public:
    Savepoint_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SAVEPOINT();
    Savepoint_nameContext *savepoint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Savepoint_statementContext* savepoint_statement();

  class  Explain_statementContext : public antlr4::ParserRuleContext {
  public:
    Explain_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXPLAIN();
    antlr4::tree::TerminalNode *PLAN();
    antlr4::tree::TerminalNode *FOR();
    Select_statementContext *select_statement();
    Update_statementContext *update_statement();
    Delete_statementContext *delete_statement();
    Insert_statementContext *insert_statement();
    Merge_statementContext *merge_statement();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *STATEMENT_ID();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Explain_statementContext* explain_statement();

  class  Select_statementContext : public antlr4::ParserRuleContext {
  public:
    Select_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SubqueryContext *subquery();
    Subquery_factoring_clauseContext *subquery_factoring_clause();
    std::vector<For_update_clauseContext *> for_update_clause();
    For_update_clauseContext* for_update_clause(size_t i);
    std::vector<Order_by_clauseContext *> order_by_clause();
    Order_by_clauseContext* order_by_clause(size_t i);
    std::vector<Offset_clauseContext *> offset_clause();
    Offset_clauseContext* offset_clause(size_t i);
    std::vector<Fetch_clauseContext *> fetch_clause();
    Fetch_clauseContext* fetch_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Select_statementContext* select_statement();

  class  Subquery_factoring_clauseContext : public antlr4::ParserRuleContext {
  public:
    Subquery_factoring_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    std::vector<Factoring_elementContext *> factoring_element();
    Factoring_elementContext* factoring_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_factoring_clauseContext* subquery_factoring_clause();

  class  Factoring_elementContext : public antlr4::ParserRuleContext {
  public:
    Factoring_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Query_nameContext *query_name();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Paren_column_listContext *paren_column_list();
    Order_by_clauseContext *order_by_clause();
    Search_clauseContext *search_clause();
    Cycle_clauseContext *cycle_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Factoring_elementContext* factoring_element();

  class  Search_clauseContext : public antlr4::ParserRuleContext {
  public:
    Search_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEARCH();
    std::vector<antlr4::tree::TerminalNode *> FIRST();
    antlr4::tree::TerminalNode* FIRST(size_t i);
    antlr4::tree::TerminalNode *BY();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *DEPTH();
    antlr4::tree::TerminalNode *BREADTH();
    std::vector<antlr4::tree::TerminalNode *> ASC();
    antlr4::tree::TerminalNode* ASC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DESC();
    antlr4::tree::TerminalNode* DESC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULLS();
    antlr4::tree::TerminalNode* NULLS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LAST();
    antlr4::tree::TerminalNode* LAST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Search_clauseContext* search_clause();

  class  Cycle_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cycle_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CYCLE();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *SET();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *TO();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *DEFAULT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cycle_clauseContext* cycle_clause();

  class  SubqueryContext : public antlr4::ParserRuleContext {
  public:
    SubqueryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subquery_basic_elementsContext *subquery_basic_elements();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  SubqueryContext* subquery();

  class  Subquery_basic_elementsContext : public antlr4::ParserRuleContext {
  public:
    Subquery_basic_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Query_blockContext *query_block();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_basic_elementsContext* subquery_basic_elements();

  class  Subquery_operation_partContext : public antlr4::ParserRuleContext {
  public:
    Subquery_operation_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subquery_basic_elementsContext *subquery_basic_elements();
    antlr4::tree::TerminalNode *UNION();
    antlr4::tree::TerminalNode *INTERSECT();
    antlr4::tree::TerminalNode *MINUS();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_operation_partContext* subquery_operation_part();

  class  Query_blockContext : public antlr4::ParserRuleContext {
  public:
    Query_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SELECT();
    Selected_listContext *selected_list();
    From_clauseContext *from_clause();
    Into_clauseContext *into_clause();
    Where_clauseContext *where_clause();
    Hierarchical_query_clauseContext *hierarchical_query_clause();
    Group_by_clauseContext *group_by_clause();
    Model_clauseContext *model_clause();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_blockContext* query_block();

  class  Selected_listContext : public antlr4::ParserRuleContext {
  public:
    Selected_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<Selected_list_elementContext *> selected_list_element();
    Selected_list_elementContext* selected_list_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_listContext* selected_list();

  class  Selected_list_elementContext : public antlr4::ParserRuleContext {
  public:
    Selected_list_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *ASTERISK();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *AS();
    Column_aliasContext *column_alias();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_list_elementContext* selected_list_element();

  class  From_clauseContext : public antlr4::ParserRuleContext {
  public:
    From_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FROM();
    Table_ref_listContext *table_ref_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  From_clauseContext* from_clause();

  class  Select_list_elementsContext : public antlr4::ParserRuleContext {
  public:
    Select_list_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *ASTERISK();
    ExpressionContext *expression();
    Regular_idContext *regular_id();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Select_list_elementsContext* select_list_elements();

  class  Table_ref_listContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Table_refContext *> table_ref();
    Table_refContext* table_ref(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_ref_listContext* table_ref_list();

  class  Table_refContext : public antlr4::ParserRuleContext {
  public:
    Table_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_ref_auxContext *table_ref_aux();
    std::vector<Join_clauseContext *> join_clause();
    Join_clauseContext* join_clause(size_t i);
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_refContext* table_ref();

  class  Table_ref_auxContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_auxContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_ref_aux_internalContext *table_ref_aux_internal();
    std::vector<Flashback_query_clauseContext *> flashback_query_clause();
    Flashback_query_clauseContext* flashback_query_clause(size_t i);
    Table_aliasContext *table_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_ref_auxContext* table_ref_aux();

  class  Table_ref_aux_internalContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_aux_internalContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    Table_ref_aux_internalContext() : antlr4::ParserRuleContext() { }
    void copyFrom(Table_ref_aux_internalContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  Table_ref_aux_internal_threeContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_threeContext(Table_ref_aux_internalContext *ctx);

    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Dml_table_expression_clauseContext *dml_table_expression_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  class  Table_ref_aux_internal_oneContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_oneContext(Table_ref_aux_internalContext *ctx);

    Dml_table_expression_clauseContext *dml_table_expression_clause();
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();
    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  class  Table_ref_aux_internal_twoContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_twoContext(Table_ref_aux_internalContext *ctx);

    antlr4::tree::TerminalNode *LEFT_PAREN();
    Table_refContext *table_ref();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();
    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  Table_ref_aux_internalContext* table_ref_aux_internal();

  class  Join_clauseContext : public antlr4::ParserRuleContext {
  public:
    Join_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JOIN();
    Table_ref_auxContext *table_ref_aux();
    std::vector<Query_partition_clauseContext *> query_partition_clause();
    Query_partition_clauseContext* query_partition_clause(size_t i);
    antlr4::tree::TerminalNode *INNER();
    Outer_join_typeContext *outer_join_type();
    std::vector<Join_on_partContext *> join_on_part();
    Join_on_partContext* join_on_part(size_t i);
    std::vector<Join_using_partContext *> join_using_part();
    Join_using_partContext* join_using_part(size_t i);
    antlr4::tree::TerminalNode *CROSS();
    antlr4::tree::TerminalNode *NATURAL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_clauseContext* join_clause();

  class  Join_on_partContext : public antlr4::ParserRuleContext {
  public:
    Join_on_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    ConditionContext *condition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_on_partContext* join_on_part();

  class  Join_using_partContext : public antlr4::ParserRuleContext {
  public:
    Join_using_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_using_partContext* join_using_part();

  class  Outer_join_typeContext : public antlr4::ParserRuleContext {
  public:
    Outer_join_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FULL();
    antlr4::tree::TerminalNode *LEFT();
    antlr4::tree::TerminalNode *RIGHT();
    antlr4::tree::TerminalNode *OUTER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Outer_join_typeContext* outer_join_type();

  class  Query_partition_clauseContext : public antlr4::ParserRuleContext {
  public:
    Query_partition_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SubqueryContext *subquery();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_partition_clauseContext* query_partition_clause();

  class  Flashback_query_clauseContext : public antlr4::ParserRuleContext {
  public:
    Flashback_query_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSIONS();
    antlr4::tree::TerminalNode *BETWEEN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *SCN();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *SNAPSHOT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_query_clauseContext* flashback_query_clause();

  class  Pivot_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PIVOT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Pivot_for_clauseContext *pivot_for_clause();
    Pivot_in_clauseContext *pivot_in_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *XML();
    std::vector<Pivot_elementContext *> pivot_element();
    Pivot_elementContext* pivot_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_clauseContext* pivot_clause();

  class  Pivot_elementContext : public antlr4::ParserRuleContext {
  public:
    Pivot_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Aggregate_function_nameContext *aggregate_function_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_elementContext* pivot_element();

  class  Pivot_for_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_for_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_for_clauseContext* pivot_for_clause();

  class  Pivot_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SubqueryContext *subquery();
    std::vector<antlr4::tree::TerminalNode *> ANY();
    antlr4::tree::TerminalNode* ANY(size_t i);
    std::vector<Pivot_in_clause_elementContext *> pivot_in_clause_element();
    Pivot_in_clause_elementContext* pivot_in_clause_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clauseContext* pivot_in_clause();

  class  Pivot_in_clause_elementContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clause_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pivot_in_clause_elementsContext *pivot_in_clause_elements();
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clause_elementContext* pivot_in_clause_element();

  class  Pivot_in_clause_elementsContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clause_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clause_elementsContext* pivot_in_clause_elements();

  class  Unpivot_clauseContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNPIVOT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Pivot_for_clauseContext *pivot_for_clause();
    Unpivot_in_clauseContext *unpivot_in_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *INCLUDE();
    antlr4::tree::TerminalNode *EXCLUDE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_clauseContext* unpivot_clause();

  class  Unpivot_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Unpivot_in_elementsContext *> unpivot_in_elements();
    Unpivot_in_elementsContext* unpivot_in_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_in_clauseContext* unpivot_in_clause();

  class  Unpivot_in_elementsContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_in_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *AS();
    std::vector<ConstantContext *> constant();
    ConstantContext* constant(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_in_elementsContext* unpivot_in_elements();

  class  Hierarchical_query_clauseContext : public antlr4::ParserRuleContext {
  public:
    Hierarchical_query_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *BY();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *NOCYCLE();
    Start_partContext *start_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hierarchical_query_clauseContext* hierarchical_query_clause();

  class  Start_partContext : public antlr4::ParserRuleContext {
  public:
    Start_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *WITH();
    ConditionContext *condition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_partContext* start_part();

  class  Group_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Group_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *BY();
    std::vector<Group_by_elementsContext *> group_by_elements();
    Group_by_elementsContext* group_by_elements(size_t i);
    Having_clauseContext *having_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Group_by_clauseContext* group_by_clause();

  class  Group_by_elementsContext : public antlr4::ParserRuleContext {
  public:
    Group_by_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Grouping_sets_clauseContext *grouping_sets_clause();
    Rollup_cube_clauseContext *rollup_cube_clause();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Group_by_elementsContext* group_by_elements();

  class  Rollup_cube_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rollup_cube_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ROLLUP();
    antlr4::tree::TerminalNode *CUBE();
    std::vector<Grouping_sets_elementsContext *> grouping_sets_elements();
    Grouping_sets_elementsContext* grouping_sets_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollup_cube_clauseContext* rollup_cube_clause();

  class  Grouping_sets_clauseContext : public antlr4::ParserRuleContext {
  public:
    Grouping_sets_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUPING();
    antlr4::tree::TerminalNode *SETS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Grouping_sets_elementsContext *> grouping_sets_elements();
    Grouping_sets_elementsContext* grouping_sets_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grouping_sets_clauseContext* grouping_sets_clause();

  class  Grouping_sets_elementsContext : public antlr4::ParserRuleContext {
  public:
    Grouping_sets_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Rollup_cube_clauseContext *rollup_cube_clause();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grouping_sets_elementsContext* grouping_sets_elements();

  class  Having_clauseContext : public antlr4::ParserRuleContext {
  public:
    Having_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HAVING();
    ConditionContext *condition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Having_clauseContext* having_clause();

  class  Model_clauseContext : public antlr4::ParserRuleContext {
  public:
    Model_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODEL();
    Main_modelContext *main_model();
    std::vector<Cell_reference_optionsContext *> cell_reference_options();
    Cell_reference_optionsContext* cell_reference_options(size_t i);
    Return_rows_clauseContext *return_rows_clause();
    std::vector<Reference_modelContext *> reference_model();
    Reference_modelContext* reference_model(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_clauseContext* model_clause();

  class  Cell_reference_optionsContext : public antlr4::ParserRuleContext {
  public:
    Cell_reference_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NAV();
    antlr4::tree::TerminalNode *IGNORE();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *SINGLE();
    antlr4::tree::TerminalNode *REFERENCE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cell_reference_optionsContext* cell_reference_options();

  class  Return_rows_clauseContext : public antlr4::ParserRuleContext {
  public:
    Return_rows_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *UPDATED();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Return_rows_clauseContext* return_rows_clause();

  class  Reference_modelContext : public antlr4::ParserRuleContext {
  public:
    Reference_modelContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFERENCE();
    Reference_model_nameContext *reference_model_name();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Model_column_clausesContext *model_column_clauses();
    std::vector<Cell_reference_optionsContext *> cell_reference_options();
    Cell_reference_optionsContext* cell_reference_options(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_modelContext* reference_model();

  class  Main_modelContext : public antlr4::ParserRuleContext {
  public:
    Main_modelContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_column_clausesContext *model_column_clauses();
    Model_rules_clauseContext *model_rules_clause();
    antlr4::tree::TerminalNode *MAIN();
    Main_model_nameContext *main_model_name();
    std::vector<Cell_reference_optionsContext *> cell_reference_options();
    Cell_reference_optionsContext* cell_reference_options(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Main_modelContext* main_model();

  class  Model_column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Model_column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *BY();
    std::vector<Model_column_listContext *> model_column_list();
    Model_column_listContext* model_column_list(size_t i);
    antlr4::tree::TerminalNode *MEASURES();
    Model_column_partition_partContext *model_column_partition_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_column_clausesContext* model_column_clauses();

  class  Model_column_partition_partContext : public antlr4::ParserRuleContext {
  public:
    Model_column_partition_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    Model_column_listContext *model_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_column_partition_partContext* model_column_partition_part();

  class  Model_column_listContext : public antlr4::ParserRuleContext {
  public:
    Model_column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Model_columnContext *> model_column();
    Model_columnContext* model_column(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_column_listContext* model_column_list();

  class  Model_columnContext : public antlr4::ParserRuleContext {
  public:
    Model_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    Query_blockContext *query_block();
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_columnContext* model_column();

  class  Model_rules_clauseContext : public antlr4::ParserRuleContext {
  public:
    Model_rules_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Model_rules_partContext *model_rules_part();
    std::vector<Model_rules_elementContext *> model_rules_element();
    Model_rules_elementContext* model_rules_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_rules_clauseContext* model_rules_clause();

  class  Model_rules_partContext : public antlr4::ParserRuleContext {
  public:
    Model_rules_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RULES();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *UPSERT();
    antlr4::tree::TerminalNode *ORDER();
    Model_iterate_clauseContext *model_iterate_clause();
    antlr4::tree::TerminalNode *AUTOMATIC();
    antlr4::tree::TerminalNode *SEQUENTIAL();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_rules_partContext* model_rules_part();

  class  Model_rules_elementContext : public antlr4::ParserRuleContext {
  public:
    Model_rules_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Cell_assignmentContext *cell_assignment();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *UPSERT();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_rules_elementContext* model_rules_element();

  class  Cell_assignmentContext : public antlr4::ParserRuleContext {
  public:
    Cell_assignmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_expressionContext *model_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cell_assignmentContext* cell_assignment();

  class  Model_iterate_clauseContext : public antlr4::ParserRuleContext {
  public:
    Model_iterate_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ITERATE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Until_partContext *until_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_iterate_clauseContext* model_iterate_clause();

  class  Until_partContext : public antlr4::ParserRuleContext {
  public:
    Until_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Until_partContext* until_part();

  class  Order_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Order_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *SIBLINGS();
    std::vector<Order_by_elementsContext *> order_by_elements();
    Order_by_elementsContext* order_by_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Order_by_clauseContext* order_by_clause();

  class  Order_by_elementsContext : public antlr4::ParserRuleContext {
  public:
    Order_by_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *ASC();
    antlr4::tree::TerminalNode *DESC();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Order_by_elementsContext* order_by_elements();

  class  Offset_clauseContext : public antlr4::ParserRuleContext {
  public:
    Offset_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OFFSET();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROWS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Offset_clauseContext* offset_clause();

  class  Fetch_clauseContext : public antlr4::ParserRuleContext {
  public:
    Fetch_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FETCH();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *NEXT();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIES();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *PERCENT_KEYWORD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Fetch_clauseContext* fetch_clause();

  class  For_update_clauseContext : public antlr4::ParserRuleContext {
  public:
    For_update_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *UPDATE();
    For_update_of_partContext *for_update_of_part();
    For_update_optionsContext *for_update_options();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_clauseContext* for_update_clause();

  class  For_update_of_partContext : public antlr4::ParserRuleContext {
  public:
    For_update_of_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    Column_listContext *column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_of_partContext* for_update_of_part();

  class  For_update_optionsContext : public antlr4::ParserRuleContext {
  public:
    For_update_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *LOCKED();
    antlr4::tree::TerminalNode *NOWAIT();
    antlr4::tree::TerminalNode *WAIT();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_optionsContext* for_update_options();

  class  Update_statementContext : public antlr4::ParserRuleContext {
  public:
    Update_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPDATE();
    General_table_refContext *general_table_ref();
    Update_set_clauseContext *update_set_clause();
    Where_clauseContext *where_clause();
    Static_returning_clauseContext *static_returning_clause();
    Error_logging_clauseContext *error_logging_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_statementContext* update_statement();

  class  Update_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    Update_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    std::vector<Column_based_update_set_clauseContext *> column_based_update_set_clause();
    Column_based_update_set_clauseContext* column_based_update_set_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_set_clauseContext* update_set_clause();

  class  Column_based_update_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    Column_based_update_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    Paren_column_listContext *paren_column_list();
    SubqueryContext *subquery();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_based_update_set_clauseContext* column_based_update_set_clause();

  class  Delete_statementContext : public antlr4::ParserRuleContext {
  public:
    Delete_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    General_table_refContext *general_table_ref();
    antlr4::tree::TerminalNode *FROM();
    Where_clauseContext *where_clause();
    Static_returning_clauseContext *static_returning_clause();
    Error_logging_clauseContext *error_logging_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Delete_statementContext* delete_statement();

  class  Insert_statementContext : public antlr4::ParserRuleContext {
  public:
    Insert_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INSERT();
    Single_table_insertContext *single_table_insert();
    Multi_table_insertContext *multi_table_insert();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Insert_statementContext* insert_statement();

  class  Single_table_insertContext : public antlr4::ParserRuleContext {
  public:
    Single_table_insertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Insert_into_clauseContext *insert_into_clause();
    Values_clauseContext *values_clause();
    Select_statementContext *select_statement();
    Error_logging_clauseContext *error_logging_clause();
    Static_returning_clauseContext *static_returning_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Single_table_insertContext* single_table_insert();

  class  Multi_table_insertContext : public antlr4::ParserRuleContext {
  public:
    Multi_table_insertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *ALL();
    Conditional_insert_clauseContext *conditional_insert_clause();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_table_insertContext* multi_table_insert();

  class  Multi_table_elementContext : public antlr4::ParserRuleContext {
  public:
    Multi_table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Insert_into_clauseContext *insert_into_clause();
    Values_clauseContext *values_clause();
    Error_logging_clauseContext *error_logging_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_table_elementContext* multi_table_element();

  class  Conditional_insert_clauseContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Conditional_insert_when_partContext *> conditional_insert_when_part();
    Conditional_insert_when_partContext* conditional_insert_when_part(size_t i);
    Conditional_insert_else_partContext *conditional_insert_else_part();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *FIRST();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_clauseContext* conditional_insert_clause();

  class  Conditional_insert_when_partContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_when_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *THEN();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_when_partContext* conditional_insert_when_part();

  class  Conditional_insert_else_partContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_else_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_else_partContext* conditional_insert_else_part();

  class  Insert_into_clauseContext : public antlr4::ParserRuleContext {
  public:
    Insert_into_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    General_table_refContext *general_table_ref();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Insert_into_clauseContext* insert_into_clause();

  class  Values_clauseContext : public antlr4::ParserRuleContext {
  public:
    Values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Values_clauseContext* values_clause();

  class  Merge_statementContext : public antlr4::ParserRuleContext {
  public:
    Merge_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *USING();
    Selected_tableviewContext *selected_tableview();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();
    Merge_update_clauseContext *merge_update_clause();
    Merge_insert_clauseContext *merge_insert_clause();
    Error_logging_clauseContext *error_logging_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_statementContext* merge_statement();

  class  Merge_update_clauseContext : public antlr4::ParserRuleContext {
  public:
    Merge_update_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *SET();
    std::vector<Merge_elementContext *> merge_element();
    Merge_elementContext* merge_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Where_clauseContext *where_clause();
    Merge_update_delete_partContext *merge_update_delete_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_update_clauseContext* merge_update_clause();

  class  Merge_elementContext : public antlr4::ParserRuleContext {
  public:
    Merge_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_elementContext* merge_element();

  class  Merge_update_delete_partContext : public antlr4::ParserRuleContext {
  public:
    Merge_update_delete_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    Where_clauseContext *where_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_update_delete_partContext* merge_update_delete_part();

  class  Merge_insert_clauseContext : public antlr4::ParserRuleContext {
  public:
    Merge_insert_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Paren_column_listContext *paren_column_list();
    ExpressionsContext *expressions();
    Where_clauseContext *where_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_insert_clauseContext* merge_insert_clause();

  class  Selected_tableviewContext : public antlr4::ParserRuleContext {
  public:
    Selected_tableviewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_tableviewContext* selected_tableview();

  class  Lock_table_statementContext : public antlr4::ParserRuleContext {
  public:
    Lock_table_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *TABLE();
    std::vector<Lock_table_elementContext *> lock_table_element();
    Lock_table_elementContext* lock_table_element(size_t i);
    antlr4::tree::TerminalNode *IN();
    Lock_modeContext *lock_mode();
    antlr4::tree::TerminalNode *MODE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Wait_nowait_partContext *wait_nowait_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lock_table_statementContext* lock_table_statement();

  class  Wait_nowait_partContext : public antlr4::ParserRuleContext {
  public:
    Wait_nowait_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WAIT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *NOWAIT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Wait_nowait_partContext* wait_nowait_part();

  class  Lock_table_elementContext : public antlr4::ParserRuleContext {
  public:
    Lock_table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    Partition_extension_clauseContext *partition_extension_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lock_table_elementContext* lock_table_element();

  class  Lock_modeContext : public antlr4::ParserRuleContext {
  public:
    Lock_modeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *SHARE();
    antlr4::tree::TerminalNode *EXCLUSIVE();
    antlr4::tree::TerminalNode *UPDATE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lock_modeContext* lock_mode();

  class  General_table_refContext : public antlr4::ParserRuleContext {
  public:
    General_table_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Dml_table_expression_clauseContext *dml_table_expression_clause();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_table_refContext* general_table_ref();

  class  Static_returning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Static_returning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionsContext *expressions();
    Into_clauseContext *into_clause();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *RETURN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Static_returning_clauseContext* static_returning_clause();

  class  Error_logging_clauseContext : public antlr4::ParserRuleContext {
  public:
    Error_logging_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ERRORS();
    Error_logging_into_partContext *error_logging_into_part();
    ExpressionContext *expression();
    Error_logging_reject_partContext *error_logging_reject_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Error_logging_clauseContext* error_logging_clause();

  class  Error_logging_into_partContext : public antlr4::ParserRuleContext {
  public:
    Error_logging_into_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Error_logging_into_partContext* error_logging_into_part();

  class  Error_logging_reject_partContext : public antlr4::ParserRuleContext {
  public:
    Error_logging_reject_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *UNLIMITED();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Error_logging_reject_partContext* error_logging_reject_part();

  class  Dml_table_expression_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dml_table_expression_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_collection_expressionContext *table_collection_expression();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Subquery_restriction_clauseContext *subquery_restriction_clause();
    Tableview_nameContext *tableview_name();
    Sample_clauseContext *sample_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_table_expression_clauseContext* dml_table_expression_clause();

  class  Table_collection_expressionContext : public antlr4::ParserRuleContext {
  public:
    Table_collection_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *THE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    SubqueryContext *subquery();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *PLUS_SIGN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_collection_expressionContext* table_collection_expression();

  class  Subquery_restriction_clauseContext : public antlr4::ParserRuleContext {
  public:
    Subquery_restriction_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *CHECK();
    antlr4::tree::TerminalNode *OPTION();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_restriction_clauseContext* subquery_restriction_clause();

  class  Sample_clauseContext : public antlr4::ParserRuleContext {
  public:
    Sample_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SAMPLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *COMMA();
    Seed_partContext *seed_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sample_clauseContext* sample_clause();

  class  Seed_partContext : public antlr4::ParserRuleContext {
  public:
    Seed_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEED();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Seed_partContext* seed_part();

  class  ConditionContext : public antlr4::ParserRuleContext {
  public:
    ConditionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConditionContext* condition();

  class  ExpressionsContext : public antlr4::ParserRuleContext {
  public:
    ExpressionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ExpressionsContext* expressions();

  class  ExpressionContext : public antlr4::ParserRuleContext {
  public:
    ExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Cursor_expressionContext *cursor_expression();
    Logical_expressionContext *logical_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ExpressionContext* expression();

  class  Cursor_expressionContext : public antlr4::ParserRuleContext {
  public:
    Cursor_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_expressionContext* cursor_expression();

  class  Logical_expressionContext : public antlr4::ParserRuleContext {
  public:
    Logical_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Multiset_expressionContext *multiset_expression();
    std::vector<antlr4::tree::TerminalNode *> IS();
    antlr4::tree::TerminalNode* IS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NAN();
    antlr4::tree::TerminalNode* NAN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRESENT();
    antlr4::tree::TerminalNode* PRESENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INFINITE();
    antlr4::tree::TerminalNode* INFINITE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> A_LETTER();
    antlr4::tree::TerminalNode* A_LETTER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SET();
    antlr4::tree::TerminalNode* SET(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EMPTY();
    antlr4::tree::TerminalNode* EMPTY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OF();
    antlr4::tree::TerminalNode* OF(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Type_specContext *> type_spec();
    Type_specContext* type_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOT();
    antlr4::tree::TerminalNode* NOT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TYPE();
    antlr4::tree::TerminalNode* TYPE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLY();
    antlr4::tree::TerminalNode* ONLY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Logical_expressionContext *> logical_expression();
    Logical_expressionContext* logical_expression(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *OR();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logical_expressionContext* logical_expression();
  Logical_expressionContext* logical_expression(int precedence);
  class  Multiset_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *multiset_type = nullptr;;
    Multiset_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Relational_expressionContext *relational_expression();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *SUBMULTISET();
    antlr4::tree::TerminalNode *OF();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multiset_expressionContext* multiset_expression();

  class  Relational_expressionContext : public antlr4::ParserRuleContext {
  public:
    Relational_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Compound_expressionContext *compound_expression();
    std::vector<Relational_expressionContext *> relational_expression();
    Relational_expressionContext* relational_expression(size_t i);
    Relational_operatorContext *relational_operator();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_expressionContext* relational_expression();
  Relational_expressionContext* relational_expression(int precedence);
  class  Compound_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *like_type = nullptr;;
    Compound_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *IN();
    In_elementsContext *in_elements();
    antlr4::tree::TerminalNode *BETWEEN();
    Between_elementsContext *between_elements();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *LIKE();
    antlr4::tree::TerminalNode *LIKEC();
    antlr4::tree::TerminalNode *LIKE2();
    antlr4::tree::TerminalNode *LIKE4();
    antlr4::tree::TerminalNode *ESCAPE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compound_expressionContext* compound_expression();

  class  Relational_operatorContext : public antlr4::ParserRuleContext {
  public:
    Relational_operatorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *NOT_EQUAL_OP();
    antlr4::tree::TerminalNode *LESS_THAN_OP();
    antlr4::tree::TerminalNode *GREATER_THAN_OP();
    antlr4::tree::TerminalNode *EXCLAMATION_OPERATOR_PART();
    antlr4::tree::TerminalNode *CARRET_OPERATOR_PART();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_operatorContext* relational_operator();

  class  In_elementsContext : public antlr4::ParserRuleContext {
  public:
    In_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    ConstantContext *constant();
    Bind_variableContext *bind_variable();
    General_elementContext *general_element();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  In_elementsContext* in_elements();

  class  Between_elementsContext : public antlr4::ParserRuleContext {
  public:
    Between_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *AND();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Between_elementsContext* between_elements();

  class  ConcatenationContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *op = nullptr;;
    ConcatenationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_expressionContext *model_expression();
    antlr4::tree::TerminalNode *AT();
    Interval_expressionContext *interval_expression();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *SOLIDUS();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *MINUS_SIGN();
    std::vector<antlr4::tree::TerminalNode *> BAR();
    antlr4::tree::TerminalNode* BAR(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConcatenationContext* concatenation();
  ConcatenationContext* concatenation(int precedence);
  class  Interval_expressionContext : public antlr4::ParserRuleContext {
  public:
    Interval_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *SECOND();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Interval_expressionContext* interval_expression();

  class  Model_expressionContext : public antlr4::ParserRuleContext {
  public:
    Model_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Unary_expressionContext *unary_expression();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    Model_expression_elementContext *model_expression_element();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_expressionContext* model_expression();

  class  Model_expression_elementContext : public antlr4::ParserRuleContext {
  public:
    Model_expression_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> ANY();
    antlr4::tree::TerminalNode* ANY(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Single_column_for_loopContext *> single_column_for_loop();
    Single_column_for_loopContext* single_column_for_loop(size_t i);
    Multi_column_for_loopContext *multi_column_for_loop();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_expression_elementContext* model_expression_element();

  class  Single_column_for_loopContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::ExpressionContext *fromExpr = nullptr;;
    PlSqlParser::ExpressionContext *toExpr = nullptr;;
    antlr4::Token *action_type = nullptr;;
    PlSqlParser::ExpressionContext *action_expr = nullptr;;
    Single_column_for_loopContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *TO();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *DECREMENT();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *LIKE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Single_column_for_loopContext* single_column_for_loop();

  class  Multi_column_for_loopContext : public antlr4::ParserRuleContext {
  public:
    Multi_column_for_loopContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *IN();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    SubqueryContext *subquery();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_column_for_loopContext* multi_column_for_loop();

  class  Unary_expressionContext : public antlr4::ParserRuleContext {
  public:
    Unary_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Unary_expressionContext *unary_expression();
    antlr4::tree::TerminalNode *MINUS_SIGN();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *PRIOR();
    antlr4::tree::TerminalNode *CONNECT_BY_ROOT();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();
    Case_statementContext *case_statement();
    Quantified_expressionContext *quantified_expression();
    Standard_functionContext *standard_function();
    AtomContext *atom();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unary_expressionContext* unary_expression();

  class  Case_statementContext : public antlr4::ParserRuleContext {
  public:
    Case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Searched_case_statementContext *searched_case_statement();
    Simple_case_statementContext *simple_case_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_statementContext* case_statement();

  class  Simple_case_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;;
    Simple_case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    std::vector<Label_nameContext *> label_name();
    Label_nameContext* label_name(size_t i);
    std::vector<Simple_case_when_partContext *> simple_case_when_part();
    Simple_case_when_partContext* simple_case_when_part(size_t i);
    Case_else_partContext *case_else_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_case_statementContext* simple_case_statement();

  class  Simple_case_when_partContext : public antlr4::ParserRuleContext {
  public:
    Simple_case_when_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_case_when_partContext* simple_case_when_part();

  class  Searched_case_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;;
    Searched_case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    std::vector<Label_nameContext *> label_name();
    Label_nameContext* label_name(size_t i);
    std::vector<Searched_case_when_partContext *> searched_case_when_part();
    Searched_case_when_partContext* searched_case_when_part(size_t i);
    Case_else_partContext *case_else_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Searched_case_statementContext* searched_case_statement();

  class  Searched_case_when_partContext : public antlr4::ParserRuleContext {
  public:
    Searched_case_when_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Searched_case_when_partContext* searched_case_when_part();

  class  Case_else_partContext : public antlr4::ParserRuleContext {
  public:
    Case_else_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    Seq_of_statementsContext *seq_of_statements();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_else_partContext* case_else_part();

  class  AtomContext : public antlr4::ParserRuleContext {
  public:
    AtomContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_elementContext *table_element();
    Outer_join_signContext *outer_join_sign();
    Bind_variableContext *bind_variable();
    ConstantContext *constant();
    General_elementContext *general_element();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  AtomContext* atom();

  class  Quantified_expressionContext : public antlr4::ParserRuleContext {
  public:
    Quantified_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SOME();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quantified_expressionContext* quantified_expression();

  class  String_functionContext : public antlr4::ParserRuleContext {
  public:
    String_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBSTR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *TO_CHAR();
    Table_elementContext *table_element();
    Standard_functionContext *standard_function();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *DECODE();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *CHR();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *NVL();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *TO_DATE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  String_functionContext* string_function();

  class  Standard_functionContext : public antlr4::ParserRuleContext {
  public:
    Standard_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    String_functionContext *string_function();
    Numeric_function_wrapperContext *numeric_function_wrapper();
    Other_functionContext *other_function();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standard_functionContext* standard_function();

  class  LiteralContext : public antlr4::ParserRuleContext {
  public:
    LiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    String_functionContext *string_function();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *MAXVALUE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  LiteralContext* literal();

  class  Numeric_function_wrapperContext : public antlr4::ParserRuleContext {
  public:
    Numeric_function_wrapperContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Numeric_functionContext *numeric_function();
    Single_column_for_loopContext *single_column_for_loop();
    Multi_column_for_loopContext *multi_column_for_loop();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_function_wrapperContext* numeric_function_wrapper();

  class  Numeric_functionContext : public antlr4::ParserRuleContext {
  public:
    Numeric_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *ASTERISK();
    Over_clauseContext *over_clause();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ROUND();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *LEAST();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *GREATEST();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_functionContext* numeric_function();

  class  Other_functionContext : public antlr4::ParserRuleContext {
  public:
    Other_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Over_clause_keywordContext *over_clause_keyword();
    Function_argument_analyticContext *function_argument_analytic();
    Over_clauseContext *over_clause();
    Regular_idContext *regular_id();
    Function_argument_modelingContext *function_argument_modeling();
    Using_clauseContext *using_clause();
    antlr4::tree::TerminalNode *COUNT();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *CAST();
    antlr4::tree::TerminalNode *XMLCAST();
    antlr4::tree::TerminalNode *MULTISET();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *COALESCE();
    Table_elementContext *table_element();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    NumericContext *numeric();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *COLLECT();
    Collect_order_by_partContext *collect_order_by_part();
    Within_or_over_clause_keywordContext *within_or_over_clause_keyword();
    Function_argumentContext *function_argument();
    std::vector<Within_or_over_partContext *> within_or_over_part();
    Within_or_over_partContext* within_or_over_part(size_t i);
    Cursor_nameContext *cursor_name();
    antlr4::tree::TerminalNode *PERCENT_ISOPEN();
    antlr4::tree::TerminalNode *PERCENT_FOUND();
    antlr4::tree::TerminalNode *PERCENT_NOTFOUND();
    antlr4::tree::TerminalNode *PERCENT_ROWCOUNT();
    antlr4::tree::TerminalNode *DECOMPOSE();
    antlr4::tree::TerminalNode *CANONICAL();
    antlr4::tree::TerminalNode *COMPATIBILITY();
    antlr4::tree::TerminalNode *EXTRACT();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *FIRST_VALUE();
    antlr4::tree::TerminalNode *LAST_VALUE();
    Respect_or_ignore_nullsContext *respect_or_ignore_nulls();
    Standard_prediction_function_keywordContext *standard_prediction_function_keyword();
    ExpressionsContext *expressions();
    Cost_matrix_clauseContext *cost_matrix_clause();
    antlr4::tree::TerminalNode *TRANSLATE();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CHAR_CS();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *TREAT();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *XMLAGG();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *PERIOD();
    General_element_partContext *general_element_part();
    antlr4::tree::TerminalNode *XMLCOLATTVAL();
    antlr4::tree::TerminalNode *XMLFOREST();
    std::vector<Xml_multiuse_expression_elementContext *> xml_multiuse_expression_element();
    Xml_multiuse_expression_elementContext* xml_multiuse_expression_element(size_t i);
    antlr4::tree::TerminalNode *XMLELEMENT();
    Xml_attributes_clauseContext *xml_attributes_clause();
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *EVALNAME();
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    antlr4::tree::TerminalNode *XMLEXISTS();
    Xml_passing_clauseContext *xml_passing_clause();
    antlr4::tree::TerminalNode *XMLPARSE();
    antlr4::tree::TerminalNode *DOCUMENT();
    antlr4::tree::TerminalNode *CONTENT();
    antlr4::tree::TerminalNode *WELLFORMED();
    antlr4::tree::TerminalNode *XMLPI();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *XMLQUERY();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *EMPTY();
    antlr4::tree::TerminalNode *XMLROOT();
    Xmlroot_param_version_partContext *xmlroot_param_version_part();
    Xmlroot_param_standalone_partContext *xmlroot_param_standalone_part();
    antlr4::tree::TerminalNode *XMLSERIALIZE();
    Xmlserialize_param_enconding_partContext *xmlserialize_param_enconding_part();
    Xmlserialize_param_version_partContext *xmlserialize_param_version_part();
    Xmlserialize_param_ident_partContext *xmlserialize_param_ident_part();
    antlr4::tree::TerminalNode *DEFAULTS();
    antlr4::tree::TerminalNode *HIDE();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *XMLTABLE();
    Xml_namespaces_clauseContext *xml_namespaces_clause();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<Xml_table_columnContext *> xml_table_column();
    Xml_table_columnContext* xml_table_column(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Other_functionContext* other_function();

  class  Over_clause_keywordContext : public antlr4::ParserRuleContext {
  public:
    Over_clause_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *CORR();
    antlr4::tree::TerminalNode *LAG();
    antlr4::tree::TerminalNode *LEAD();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MEDIAN();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *NTILE();
    antlr4::tree::TerminalNode *RATIO_TO_REPORT();
    antlr4::tree::TerminalNode *ROW_NUMBER();
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *VARIANCE();
    antlr4::tree::TerminalNode *REGR_();
    antlr4::tree::TerminalNode *STDDEV();
    antlr4::tree::TerminalNode *VAR_();
    antlr4::tree::TerminalNode *COVAR_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Over_clause_keywordContext* over_clause_keyword();

  class  Within_or_over_clause_keywordContext : public antlr4::ParserRuleContext {
  public:
    Within_or_over_clause_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CUME_DIST();
    antlr4::tree::TerminalNode *DENSE_RANK();
    antlr4::tree::TerminalNode *LISTAGG();
    antlr4::tree::TerminalNode *PERCENT_RANK();
    antlr4::tree::TerminalNode *PERCENTILE_CONT();
    antlr4::tree::TerminalNode *PERCENTILE_DISC();
    antlr4::tree::TerminalNode *RANK();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Within_or_over_clause_keywordContext* within_or_over_clause_keyword();

  class  Standard_prediction_function_keywordContext : public antlr4::ParserRuleContext {
  public:
    Standard_prediction_function_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PREDICTION();
    antlr4::tree::TerminalNode *PREDICTION_BOUNDS();
    antlr4::tree::TerminalNode *PREDICTION_COST();
    antlr4::tree::TerminalNode *PREDICTION_DETAILS();
    antlr4::tree::TerminalNode *PREDICTION_PROBABILITY();
    antlr4::tree::TerminalNode *PREDICTION_SET();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standard_prediction_function_keywordContext* standard_prediction_function_keyword();

  class  Over_clauseContext : public antlr4::ParserRuleContext {
  public:
    Over_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OVER();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Query_partition_clauseContext *query_partition_clause();
    Order_by_clauseContext *order_by_clause();
    Windowing_clauseContext *windowing_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Over_clauseContext* over_clause();

  class  Windowing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Windowing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Windowing_typeContext *windowing_type();
    antlr4::tree::TerminalNode *BETWEEN();
    std::vector<Windowing_elementsContext *> windowing_elements();
    Windowing_elementsContext* windowing_elements(size_t i);
    antlr4::tree::TerminalNode *AND();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_clauseContext* windowing_clause();

  class  Windowing_typeContext : public antlr4::ParserRuleContext {
  public:
    Windowing_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *RANGE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_typeContext* windowing_type();

  class  Windowing_elementsContext : public antlr4::ParserRuleContext {
  public:
    Windowing_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNBOUNDED();
    antlr4::tree::TerminalNode *PRECEDING();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *ROW();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *FOLLOWING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_elementsContext* windowing_elements();

  class  Using_clauseContext : public antlr4::ParserRuleContext {
  public:
    Using_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<Using_elementContext *> using_element();
    Using_elementContext* using_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_clauseContext* using_clause();

  class  Using_elementContext : public antlr4::ParserRuleContext {
  public:
    Using_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Select_list_elementsContext *select_list_elements();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *OUT();
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_elementContext* using_element();

  class  Collect_order_by_partContext : public antlr4::ParserRuleContext {
  public:
    Collect_order_by_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collect_order_by_partContext* collect_order_by_part();

  class  Within_or_over_partContext : public antlr4::ParserRuleContext {
  public:
    Within_or_over_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITHIN();
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Over_clauseContext *over_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Within_or_over_partContext* within_or_over_part();

  class  Cost_matrix_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cost_matrix_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *MODEL();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *AUTO();
    std::vector<Cost_class_nameContext *> cost_class_name();
    Cost_class_nameContext* cost_class_name(size_t i);
    ExpressionsContext *expressions();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cost_matrix_clauseContext* cost_matrix_clause();

  class  Xml_passing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_passing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PASSING();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *VALUE();
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_passing_clauseContext* xml_passing_clause();

  class  Xml_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLATTRIBUTES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Xml_multiuse_expression_elementContext *> xml_multiuse_expression_element();
    Xml_multiuse_expression_elementContext* xml_multiuse_expression_element(size_t i);
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *SCHEMACHECK();
    antlr4::tree::TerminalNode *NOSCHEMACHECK();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_attributes_clauseContext* xml_attributes_clause();

  class  Xml_namespaces_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_namespaces_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLNAMESPACES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Xml_general_default_partContext *xml_general_default_part();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_namespaces_clauseContext* xml_namespaces_clause();

  class  Xml_table_columnContext : public antlr4::ParserRuleContext {
  public:
    Xml_table_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Xml_column_nameContext *xml_column_name();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *ORDINALITY();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *PATH();
    ConcatenationContext *concatenation();
    Xml_general_default_partContext *xml_general_default_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_table_columnContext* xml_table_column();

  class  Xml_general_default_partContext : public antlr4::ParserRuleContext {
  public:
    Xml_general_default_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_general_default_partContext* xml_general_default_part();

  class  Xml_multiuse_expression_elementContext : public antlr4::ParserRuleContext {
  public:
    Xml_multiuse_expression_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *AS();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *EVALNAME();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_multiuse_expression_elementContext* xml_multiuse_expression_element();

  class  Xmlroot_param_version_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlroot_param_version_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *VALUE();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlroot_param_version_partContext* xmlroot_param_version_part();

  class  Xmlroot_param_standalone_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlroot_param_standalone_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STANDALONE();
    antlr4::tree::TerminalNode *YES();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *VALUE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlroot_param_standalone_partContext* xmlroot_param_standalone_part();

  class  Xmlserialize_param_enconding_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_enconding_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENCODING();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_enconding_partContext* xmlserialize_param_enconding_part();

  class  Xmlserialize_param_version_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_version_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSION();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_version_partContext* xmlserialize_param_version_part();

  class  Xmlserialize_param_ident_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_ident_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *INDENT();
    antlr4::tree::TerminalNode *SIZE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_ident_partContext* xmlserialize_param_ident_part();

  class  Sql_plus_commandContext : public antlr4::ParserRuleContext {
  public:
    Sql_plus_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SOLIDUS();
    antlr4::tree::TerminalNode *EXIT();
    antlr4::tree::TerminalNode *PROMPT_MESSAGE();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *ERR();
    antlr4::tree::TerminalNode *ERRORS();
    antlr4::tree::TerminalNode *START_CMD();
    Whenever_commandContext *whenever_command();
    Set_commandContext *set_command();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_plus_commandContext* sql_plus_command();

  class  Whenever_commandContext : public antlr4::ParserRuleContext {
  public:
    Whenever_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *SQLERROR();
    antlr4::tree::TerminalNode *OSERROR();
    antlr4::tree::TerminalNode *EXIT();
    antlr4::tree::TerminalNode *CONTINUE();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *SUCCESS();
    antlr4::tree::TerminalNode *FAILURE();
    antlr4::tree::TerminalNode *WARNING();
    Variable_nameContext *variable_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Whenever_commandContext* whenever_command();

  class  Set_commandContext : public antlr4::ParserRuleContext {
  public:
    Set_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OFF();
    NumericContext *numeric();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_commandContext* set_command();

  class  Partition_extension_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partition_extension_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *FOR();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_extension_clauseContext* partition_extension_clause();

  class  Column_aliasContext : public antlr4::ParserRuleContext {
  public:
    Column_aliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_aliasContext* column_alias();

  class  Table_aliasContext : public antlr4::ParserRuleContext {
  public:
    Table_aliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_aliasContext* table_alias();

  class  Where_clauseContext : public antlr4::ParserRuleContext {
  public:
    Where_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHERE();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *OF();
    Cursor_nameContext *cursor_name();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Where_clauseContext* where_clause();

  class  Into_clauseContext : public antlr4::ParserRuleContext {
  public:
    Into_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    antlr4::tree::TerminalNode *BULK();
    antlr4::tree::TerminalNode *COLLECT();
    std::vector<Variable_nameContext *> variable_name();
    Variable_nameContext* variable_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Into_clauseContext* into_clause();

  class  Xml_column_nameContext : public antlr4::ParserRuleContext {
  public:
    Xml_column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_column_nameContext* xml_column_name();

  class  Cost_class_nameContext : public antlr4::ParserRuleContext {
  public:
    Cost_class_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cost_class_nameContext* cost_class_name();

  class  Attribute_nameContext : public antlr4::ParserRuleContext {
  public:
    Attribute_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Attribute_nameContext* attribute_name();

  class  Savepoint_nameContext : public antlr4::ParserRuleContext {
  public:
    Savepoint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Savepoint_nameContext* savepoint_name();

  class  Rollback_segment_nameContext : public antlr4::ParserRuleContext {
  public:
    Rollback_segment_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollback_segment_nameContext* rollback_segment_name();

  class  Table_var_nameContext : public antlr4::ParserRuleContext {
  public:
    Table_var_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_var_nameContext* table_var_name();

  class  Schema_nameContext : public antlr4::ParserRuleContext {
  public:
    Schema_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Schema_nameContext* schema_name();

  class  Routine_nameContext : public antlr4::ParserRuleContext {
  public:
    Routine_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Routine_nameContext* routine_name();

  class  Package_nameContext : public antlr4::ParserRuleContext {
  public:
    Package_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Package_nameContext* package_name();

  class  Implementation_type_nameContext : public antlr4::ParserRuleContext {
  public:
    Implementation_type_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Implementation_type_nameContext* implementation_type_name();

  class  Parameter_nameContext : public antlr4::ParserRuleContext {
  public:
    Parameter_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parameter_nameContext* parameter_name();

  class  Reference_model_nameContext : public antlr4::ParserRuleContext {
  public:
    Reference_model_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_model_nameContext* reference_model_name();

  class  Main_model_nameContext : public antlr4::ParserRuleContext {
  public:
    Main_model_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Main_model_nameContext* main_model_name();

  class  Container_tableview_nameContext : public antlr4::ParserRuleContext {
  public:
    Container_tableview_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_tableview_nameContext* container_tableview_name();

  class  Aggregate_function_nameContext : public antlr4::ParserRuleContext {
  public:
    Aggregate_function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Aggregate_function_nameContext* aggregate_function_name();

  class  Query_nameContext : public antlr4::ParserRuleContext {
  public:
    Query_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_nameContext* query_name();

  class  Grantee_nameContext : public antlr4::ParserRuleContext {
  public:
    Grantee_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    Identified_byContext *identified_by();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grantee_nameContext* grantee_name();

  class  Role_nameContext : public antlr4::ParserRuleContext {
  public:
    Role_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *CONNECT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Role_nameContext* role_name();

  class  Constraint_nameContext : public antlr4::ParserRuleContext {
  public:
    Constraint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constraint_nameContext* constraint_name();

  class  Label_nameContext : public antlr4::ParserRuleContext {
  public:
    Label_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Label_nameContext* label_name();

  class  Type_nameContext : public antlr4::ParserRuleContext {
  public:
    Type_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_nameContext* type_name();

  class  Sequence_nameContext : public antlr4::ParserRuleContext {
  public:
    Sequence_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sequence_nameContext* sequence_name();

  class  Exception_nameContext : public antlr4::ParserRuleContext {
  public:
    Exception_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exception_nameContext* exception_name();

  class  Function_nameContext : public antlr4::ParserRuleContext {
  public:
    Function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_nameContext* function_name();

  class  Procedure_nameContext : public antlr4::ParserRuleContext {
  public:
    Procedure_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Procedure_nameContext* procedure_name();

  class  Trigger_nameContext : public antlr4::ParserRuleContext {
  public:
    Trigger_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_nameContext* trigger_name();

  class  Variable_nameContext : public antlr4::ParserRuleContext {
  public:
    Variable_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    antlr4::tree::TerminalNode *PERIOD();
    Bind_variableContext *bind_variable();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Variable_nameContext* variable_name();

  class  Index_nameContext : public antlr4::ParserRuleContext {
  public:
    Index_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_nameContext* index_name();

  class  Cursor_nameContext : public antlr4::ParserRuleContext {
  public:
    Cursor_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    General_elementContext *general_element();
    Bind_variableContext *bind_variable();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_nameContext* cursor_name();

  class  Record_nameContext : public antlr4::ParserRuleContext {
  public:
    Record_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Bind_variableContext *bind_variable();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Record_nameContext* record_name();

  class  Collection_nameContext : public antlr4::ParserRuleContext {
  public:
    Collection_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collection_nameContext* collection_name();

  class  Link_nameContext : public antlr4::ParserRuleContext {
  public:
    Link_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Link_nameContext* link_name();

  class  Column_nameContext : public antlr4::ParserRuleContext {
  public:
    Column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_nameContext* column_name();

  class  Tableview_nameContext : public antlr4::ParserRuleContext {
  public:
    Tableview_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();
    Partition_extension_clauseContext *partition_extension_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tableview_nameContext* tableview_name();

  class  Char_set_nameContext : public antlr4::ParserRuleContext {
  public:
    Char_set_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Char_set_nameContext* char_set_name();

  class  Synonym_nameContext : public antlr4::ParserRuleContext {
  public:
    Synonym_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Synonym_nameContext* synonym_name();

  class  Schema_object_nameContext : public antlr4::ParserRuleContext {
  public:
    Schema_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Schema_object_nameContext* schema_object_name();

  class  Dir_object_nameContext : public antlr4::ParserRuleContext {
  public:
    Dir_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dir_object_nameContext* dir_object_name();

  class  User_object_nameContext : public antlr4::ParserRuleContext {
  public:
    User_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_object_nameContext* user_object_name();

  class  Grant_object_nameContext : public antlr4::ParserRuleContext {
  public:
    Grant_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *USER();
    std::vector<User_object_nameContext *> user_object_name();
    User_object_nameContext* user_object_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DIRECTORY();
    Dir_object_nameContext *dir_object_name();
    antlr4::tree::TerminalNode *EDITION();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *RESOURCE();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *PROFILE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grant_object_nameContext* grant_object_name();

  class  Column_listContext : public antlr4::ParserRuleContext {
  public:
    Column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_listContext* column_list();

  class  Paren_column_listContext : public antlr4::ParserRuleContext {
  public:
    Paren_column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Paren_column_listContext* paren_column_list();

  class  Keep_clauseContext : public antlr4::ParserRuleContext {
  public:
    Keep_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *DENSE_RANK();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();
    Over_clauseContext *over_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Keep_clauseContext* keep_clause();

  class  Function_argumentContext : public antlr4::ParserRuleContext {
  public:
    Function_argumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ArgumentContext *> argument();
    ArgumentContext* argument(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argumentContext* function_argument();

  class  Function_argument_analyticContext : public antlr4::ParserRuleContext {
  public:
    Function_argument_analyticContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ArgumentContext *> argument();
    ArgumentContext* argument(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Respect_or_ignore_nullsContext *> respect_or_ignore_nulls();
    Respect_or_ignore_nullsContext* respect_or_ignore_nulls(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argument_analyticContext* function_argument_analytic();

  class  Function_argument_modelingContext : public antlr4::ParserRuleContext {
  public:
    Function_argument_modelingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argument_modelingContext* function_argument_modeling();

  class  Respect_or_ignore_nullsContext : public antlr4::ParserRuleContext {
  public:
    Respect_or_ignore_nullsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *RESPECT();
    antlr4::tree::TerminalNode *IGNORE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Respect_or_ignore_nullsContext* respect_or_ignore_nulls();

  class  ArgumentContext : public antlr4::ParserRuleContext {
  public:
    ArgumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *GREATER_THAN_OP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ArgumentContext* argument();

  class  Type_specContext : public antlr4::ParserRuleContext {
  public:
    Type_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatatypeContext *datatype();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *PERCENT_ROWTYPE();
    antlr4::tree::TerminalNode *PERCENT_TYPE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_specContext* type_spec();

  class  DatatypeContext : public antlr4::ParserRuleContext {
  public:
    DatatypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Native_datatype_elementContext *native_datatype_element();
    Precision_partContext *precision_part();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *SET();
    Char_set_nameContext *char_set_name();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *SECOND();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  DatatypeContext* datatype();

  class  Precision_partContext : public antlr4::ParserRuleContext {
  public:
    Precision_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *BYTE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Precision_partContext* precision_part();

  class  Native_datatype_elementContext : public antlr4::ParserRuleContext {
  public:
    Native_datatype_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BINARY_INTEGER();
    antlr4::tree::TerminalNode *PLS_INTEGER();
    antlr4::tree::TerminalNode *NATURAL();
    antlr4::tree::TerminalNode *BINARY_FLOAT();
    antlr4::tree::TerminalNode *BINARY_DOUBLE();
    antlr4::tree::TerminalNode *NATURALN();
    antlr4::tree::TerminalNode *POSITIVE();
    antlr4::tree::TerminalNode *POSITIVEN();
    antlr4::tree::TerminalNode *SIGNTYPE();
    antlr4::tree::TerminalNode *SIMPLE_INTEGER();
    antlr4::tree::TerminalNode *NVARCHAR2();
    antlr4::tree::TerminalNode *DEC();
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *INT();
    antlr4::tree::TerminalNode *NUMERIC();
    antlr4::tree::TerminalNode *SMALLINT();
    antlr4::tree::TerminalNode *NUMBER();
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *PRECISION();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *REAL();
    antlr4::tree::TerminalNode *NCHAR();
    antlr4::tree::TerminalNode *LONG();
    antlr4::tree::TerminalNode *RAW();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *VARCHAR();
    antlr4::tree::TerminalNode *STRING();
    antlr4::tree::TerminalNode *BOOLEAN();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *UROWID();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *HOUR();
    antlr4::tree::TerminalNode *MINUTE();
    antlr4::tree::TerminalNode *SECOND();
    antlr4::tree::TerminalNode *TIMEZONE_HOUR();
    antlr4::tree::TerminalNode *TIMEZONE_MINUTE();
    antlr4::tree::TerminalNode *TIMEZONE_REGION();
    antlr4::tree::TerminalNode *TIMEZONE_ABBR();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *TIMESTAMP_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_TZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_LTZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *YMINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *DSINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *BFILE();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *NCLOB();
    antlr4::tree::TerminalNode *MLSLABEL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Native_datatype_elementContext* native_datatype_element();

  class  Bind_variableContext : public antlr4::ParserRuleContext {
  public:
    Bind_variableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> BINDVAR();
    antlr4::tree::TerminalNode* BINDVAR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COLON();
    antlr4::tree::TerminalNode* COLON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);
    antlr4::tree::TerminalNode *INDICATOR();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Bind_variableContext* bind_variable();

  class  General_elementContext : public antlr4::ParserRuleContext {
  public:
    General_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_elementContext* general_element();

  class  General_element_partContext : public antlr4::ParserRuleContext {
  public:
    General_element_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();
    Function_argumentContext *function_argument();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_element_partContext* general_element_part();

  class  Table_elementContext : public antlr4::ParserRuleContext {
  public:
    Table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_elementContext* table_element();

  class  Object_privilegeContext : public antlr4::ParserRuleContext {
  public:
    Object_privilegeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *PRIVILEGES();
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *INHERIT();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *UNDER();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *WRITE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_privilegeContext* object_privilege();

  class  System_privilegeContext : public antlr4::ParserRuleContext {
  public:
    System_privilegeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *PRIVILEGES();
    antlr4::tree::TerminalNode *ADVISOR();
    antlr4::tree::TerminalNode *ADMINISTER();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *TUNING();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *EXEMPT();
    antlr4::tree::TerminalNode *REDACTION();
    antlr4::tree::TerminalNode *POLICY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *DICTIONARY();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *EDITION();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *INDEXTYPE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *JOB();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *CLASS();
    antlr4::tree::TerminalNode *PROGRAM();
    antlr4::tree::TerminalNode *MANAGE();
    antlr4::tree::TerminalNode *SCHEDULER();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *LIBRARY();
    antlr4::tree::TerminalNode *LOGMINING();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *CUBE();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *FOLDER();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *BUILD();
    antlr4::tree::TerminalNode *PROCESS();
    antlr4::tree::TerminalNode *OPERATOR();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *RESTRICTED();
    antlr4::tree::TerminalNode *RESOURCE();
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *SYNONYM();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *UNLIMITED();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *UNDER();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *BECOME();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *NOTIFICATION();
    antlr4::tree::TerminalNode *ACCESS();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *PRIVILEGE();
    antlr4::tree::TerminalNode *INHERIT();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *SYSGUID();
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *DBA_RECYCLEBIN();
    antlr4::tree::TerminalNode *RESUMABLE();
    antlr4::tree::TerminalNode *SYSBACKUP();
    antlr4::tree::TerminalNode *SYSDBA();
    antlr4::tree::TerminalNode *SYSDG();
    antlr4::tree::TerminalNode *SYSKM();
    antlr4::tree::TerminalNode *SYSOPER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  System_privilegeContext* system_privilege();

  class  ConstantContext : public antlr4::ParserRuleContext {
  public:
    ConstantContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TIMESTAMP();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    std::vector<Bind_variableContext *> bind_variable();
    Bind_variableContext* bind_variable(size_t i);
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();
    std::vector<antlr4::tree::TerminalNode *> DAY();
    antlr4::tree::TerminalNode* DAY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HOUR();
    antlr4::tree::TerminalNode* HOUR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MINUTE();
    antlr4::tree::TerminalNode* MINUTE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECOND();
    antlr4::tree::TerminalNode* SECOND(size_t i);
    General_element_partContext *general_element_part();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *TRUE();
    antlr4::tree::TerminalNode *FALSE();
    antlr4::tree::TerminalNode *DBTIMEZONE();
    antlr4::tree::TerminalNode *SESSIONTIMEZONE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *DEFAULT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConstantContext* constant();

  class  NumericContext : public antlr4::ParserRuleContext {
  public:
    NumericContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *APPROXIMATE_NUM_LIT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  NumericContext* numeric();

  class  Numeric_negativeContext : public antlr4::ParserRuleContext {
  public:
    Numeric_negativeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_SIGN();
    NumericContext *numeric();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_negativeContext* numeric_negative();

  class  Quoted_stringContext : public antlr4::ParserRuleContext {
  public:
    Quoted_stringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *NATIONAL_CHAR_STRING_LIT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quoted_stringContext* quoted_string();

  class  IdentifierContext : public antlr4::ParserRuleContext {
  public:
    IdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  IdentifierContext* identifier();

  class  Id_expressionContext : public antlr4::ParserRuleContext {
  public:
    Id_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *DELIMITED_ID();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Id_expressionContext* id_expression();

  class  Outer_join_signContext : public antlr4::ParserRuleContext {
  public:
    Outer_join_signContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Outer_join_signContext* outer_join_sign();

  class  Regular_idContext : public antlr4::ParserRuleContext {
  public:
    Regular_idContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Non_reserved_keywords_pre12cContext *non_reserved_keywords_pre12c();
    Non_reserved_keywords_in_12cContext *non_reserved_keywords_in_12c();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *A_LETTER();
    antlr4::tree::TerminalNode *AGENT();
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *AUTONOMOUS_TRANSACTION();
    antlr4::tree::TerminalNode *BATCH();
    antlr4::tree::TerminalNode *BINARY_INTEGER();
    antlr4::tree::TerminalNode *BOOLEAN();
    antlr4::tree::TerminalNode *C_LETTER();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *CONSTRUCTOR();
    antlr4::tree::TerminalNode *CUSTOMDATUM();
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *DETERMINISTIC();
    antlr4::tree::TerminalNode *DSINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *ERR();
    antlr4::tree::TerminalNode *EXCEPTION();
    antlr4::tree::TerminalNode *EXCEPTION_INIT();
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *EXIT();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *FORALL();
    antlr4::tree::TerminalNode *INDICES();
    antlr4::tree::TerminalNode *INOUT();
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *LANGUAGE();
    antlr4::tree::TerminalNode *LONG();
    antlr4::tree::TerminalNode *LOOP();
    antlr4::tree::TerminalNode *NUMBER();
    antlr4::tree::TerminalNode *ORADATA();
    antlr4::tree::TerminalNode *OSERROR();
    antlr4::tree::TerminalNode *OUT();
    antlr4::tree::TerminalNode *OVERRIDING();
    antlr4::tree::TerminalNode *PARALLEL_ENABLE();
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *PLS_INTEGER();
    antlr4::tree::TerminalNode *POSITIVE();
    antlr4::tree::TerminalNode *POSITIVEN();
    antlr4::tree::TerminalNode *PRAGMA();
    antlr4::tree::TerminalNode *RAISE();
    antlr4::tree::TerminalNode *RAW();
    antlr4::tree::TerminalNode *RECORD();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *RESTRICT_REFERENCES();
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *SELF();
    antlr4::tree::TerminalNode *SERIALLY_REUSABLE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *SIGNTYPE();
    antlr4::tree::TerminalNode *SIMPLE_INTEGER();
    antlr4::tree::TerminalNode *SMALLINT();
    antlr4::tree::TerminalNode *SQLDATA();
    antlr4::tree::TerminalNode *SQLERROR();
    antlr4::tree::TerminalNode *SUBTYPE();
    antlr4::tree::TerminalNode *TIMESTAMP_LTZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_TZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *VARCHAR();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *VARIABLE();
    antlr4::tree::TerminalNode *WARNING();
    antlr4::tree::TerminalNode *WHILE();
    antlr4::tree::TerminalNode *XMLAGG();
    antlr4::tree::TerminalNode *YMINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *REGR_();
    antlr4::tree::TerminalNode *VAR_();
    antlr4::tree::TerminalNode *COVAR_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Regular_idContext* regular_id();

  class  Non_reserved_keywords_in_12cContext : public antlr4::ParserRuleContext {
  public:
    Non_reserved_keywords_in_12cContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACL();
    antlr4::tree::TerminalNode *ACTION();
    antlr4::tree::TerminalNode *ACTIONS();
    antlr4::tree::TerminalNode *ACTIVE();
    antlr4::tree::TerminalNode *ACTIVE_DATA();
    antlr4::tree::TerminalNode *ACTIVITY();
    antlr4::tree::TerminalNode *ADAPTIVE_PLAN();
    antlr4::tree::TerminalNode *ADVANCED();
    antlr4::tree::TerminalNode *AFD_DISKSTRING();
    antlr4::tree::TerminalNode *ANOMALY();
    antlr4::tree::TerminalNode *ANSI_REARCH();
    antlr4::tree::TerminalNode *APPLICATION();
    antlr4::tree::TerminalNode *APPROX_COUNT_DISTINCT();
    antlr4::tree::TerminalNode *ARCHIVAL();
    antlr4::tree::TerminalNode *ARCHIVED();
    antlr4::tree::TerminalNode *ASIS();
    antlr4::tree::TerminalNode *ASSIGN();
    antlr4::tree::TerminalNode *AUTO_LOGIN();
    antlr4::tree::TerminalNode *AUTO_REOPTIMIZE();
    antlr4::tree::TerminalNode *AVRO();
    antlr4::tree::TerminalNode *BACKGROUND();
    antlr4::tree::TerminalNode *BATCHSIZE();
    antlr4::tree::TerminalNode *BATCH_TABLE_ACCESS_BY_ROWID();
    antlr4::tree::TerminalNode *BEGINNING();
    antlr4::tree::TerminalNode *BEQUEATH();
    antlr4::tree::TerminalNode *BITMAP_AND();
    antlr4::tree::TerminalNode *BSON();
    antlr4::tree::TerminalNode *CACHING();
    antlr4::tree::TerminalNode *CALCULATED();
    antlr4::tree::TerminalNode *CALLBACK();
    antlr4::tree::TerminalNode *CAPACITY();
    antlr4::tree::TerminalNode *CDBDEFAULT();
    antlr4::tree::TerminalNode *CLASSIFIER();
    antlr4::tree::TerminalNode *CLEANUP();
    antlr4::tree::TerminalNode *CLIENT();
    antlr4::tree::TerminalNode *CLUSTER_DETAILS();
    antlr4::tree::TerminalNode *CLUSTER_DISTANCE();
    antlr4::tree::TerminalNode *CLUSTERING();
    antlr4::tree::TerminalNode *COMMON_DATA();
    antlr4::tree::TerminalNode *COMPONENT();
    antlr4::tree::TerminalNode *COMPONENTS();
    antlr4::tree::TerminalNode *CON_DBID_TO_ID();
    antlr4::tree::TerminalNode *CONDITION();
    antlr4::tree::TerminalNode *CONDITIONAL();
    antlr4::tree::TerminalNode *CON_GUID_TO_ID();
    antlr4::tree::TerminalNode *CON_ID();
    antlr4::tree::TerminalNode *CON_NAME_TO_ID();
    antlr4::tree::TerminalNode *CONTAINER_DATA();
    antlr4::tree::TerminalNode *CONTAINERS();
    antlr4::tree::TerminalNode *CON_UID_TO_ID();
    antlr4::tree::TerminalNode *COOKIE();
    antlr4::tree::TerminalNode *COPY();
    antlr4::tree::TerminalNode *CREATE_FILE_DEST();
    antlr4::tree::TerminalNode *CREDENTIAL();
    antlr4::tree::TerminalNode *CRITICAL();
    antlr4::tree::TerminalNode *CUBE_AJ();
    antlr4::tree::TerminalNode *CUBE_SJ();
    antlr4::tree::TerminalNode *DATAMOVEMENT();
    antlr4::tree::TerminalNode *DATAOBJ_TO_MAT_PARTITION();
    antlr4::tree::TerminalNode *DATAPUMP();
    antlr4::tree::TerminalNode *DATA_SECURITY_REWRITE_LIMIT();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *DB_UNIQUE_NAME();
    antlr4::tree::TerminalNode *DECORRELATE();
    antlr4::tree::TerminalNode *DEFINE();
    antlr4::tree::TerminalNode *DELEGATE();
    antlr4::tree::TerminalNode *DELETE_ALL();
    antlr4::tree::TerminalNode *DESTROY();
    antlr4::tree::TerminalNode *DIMENSIONS();
    antlr4::tree::TerminalNode *DISABLE_ALL();
    antlr4::tree::TerminalNode *DISABLE_PARALLEL_DML();
    antlr4::tree::TerminalNode *DISCARD();
    antlr4::tree::TerminalNode *DISTRIBUTE();
    antlr4::tree::TerminalNode *DUPLICATE();
    antlr4::tree::TerminalNode *DV();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *ELIM_GROUPBY();
    antlr4::tree::TerminalNode *EM();
    antlr4::tree::TerminalNode *ENABLE_ALL();
    antlr4::tree::TerminalNode *ENABLE_PARALLEL_DML();
    antlr4::tree::TerminalNode *EQUIPART();
    antlr4::tree::TerminalNode *EVAL();
    antlr4::tree::TerminalNode *EVALUATE();
    antlr4::tree::TerminalNode *EXISTING();
    antlr4::tree::TerminalNode *EXPRESS();
    antlr4::tree::TerminalNode *EXTRACTCLOBXML();
    antlr4::tree::TerminalNode *FACTOR();
    antlr4::tree::TerminalNode *FAILOVER();
    antlr4::tree::TerminalNode *FAILURE();
    antlr4::tree::TerminalNode *FAMILY();
    antlr4::tree::TerminalNode *FAR();
    antlr4::tree::TerminalNode *FASTSTART();
    antlr4::tree::TerminalNode *FEATURE_DETAILS();
    antlr4::tree::TerminalNode *FETCH();
    antlr4::tree::TerminalNode *FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *FIXED_VIEW_DATA();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *GATHER_OPTIMIZER_STATISTICS();
    antlr4::tree::TerminalNode *GET();
    antlr4::tree::TerminalNode *ILM();
    antlr4::tree::TerminalNode *INACTIVE();
    antlr4::tree::TerminalNode *INDEXING();
    antlr4::tree::TerminalNode *INHERIT();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *INMEMORY_PRUNING();
    antlr4::tree::TerminalNode *INPLACE();
    antlr4::tree::TerminalNode *INTERLEAVED();
    antlr4::tree::TerminalNode *JSON();
    antlr4::tree::TerminalNode *JSON_ARRAY();
    antlr4::tree::TerminalNode *JSON_ARRAYAGG();
    antlr4::tree::TerminalNode *JSON_EQUAL();
    antlr4::tree::TerminalNode *JSON_EXISTS();
    antlr4::tree::TerminalNode *JSON_EXISTS2();
    antlr4::tree::TerminalNode *JSONGET();
    antlr4::tree::TerminalNode *JSON_OBJECT();
    antlr4::tree::TerminalNode *JSON_OBJECTAGG();
    antlr4::tree::TerminalNode *JSONPARSE();
    antlr4::tree::TerminalNode *JSON_QUERY();
    antlr4::tree::TerminalNode *JSON_SERIALIZE();
    antlr4::tree::TerminalNode *JSON_TABLE();
    antlr4::tree::TerminalNode *JSON_TEXTCONTAINS();
    antlr4::tree::TerminalNode *JSON_TEXTCONTAINS2();
    antlr4::tree::TerminalNode *JSON_VALUE();
    antlr4::tree::TerminalNode *KEYSTORE();
    antlr4::tree::TerminalNode *LABEL();
    antlr4::tree::TerminalNode *LAX();
    antlr4::tree::TerminalNode *LIFECYCLE();
    antlr4::tree::TerminalNode *LINEAR();
    antlr4::tree::TerminalNode *LOCKING();
    antlr4::tree::TerminalNode *LOGMINING();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *MATCH();
    antlr4::tree::TerminalNode *MATCHES();
    antlr4::tree::TerminalNode *MATCH_NUMBER();
    antlr4::tree::TerminalNode *MATCH_RECOGNIZE();
    antlr4::tree::TerminalNode *MAX_SHARED_TEMP_SIZE();
    antlr4::tree::TerminalNode *MEMCOMPRESS();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *MODEL_NB();
    antlr4::tree::TerminalNode *MODEL_SV();
    antlr4::tree::TerminalNode *MODIFICATION();
    antlr4::tree::TerminalNode *MODULE();
    antlr4::tree::TerminalNode *MONTHS();
    antlr4::tree::TerminalNode *MULTIDIMENSIONAL();
    antlr4::tree::TerminalNode *NEG();
    antlr4::tree::TerminalNode *NO_ADAPTIVE_PLAN();
    antlr4::tree::TerminalNode *NO_ANSI_REARCH();
    antlr4::tree::TerminalNode *NO_AUTO_REOPTIMIZE();
    antlr4::tree::TerminalNode *NO_BATCH_TABLE_ACCESS_BY_ROWID();
    antlr4::tree::TerminalNode *NO_CLUSTERING();
    antlr4::tree::TerminalNode *NO_COMMON_DATA();
    antlr4::tree::TerminalNode *NOCOPY();
    antlr4::tree::TerminalNode *NO_DATA_SECURITY_REWRITE();
    antlr4::tree::TerminalNode *NO_DECORRELATE();
    antlr4::tree::TerminalNode *NO_ELIM_GROUPBY();
    antlr4::tree::TerminalNode *NO_GATHER_OPTIMIZER_STATISTICS();
    antlr4::tree::TerminalNode *NO_INMEMORY();
    antlr4::tree::TerminalNode *NO_INMEMORY_PRUNING();
    antlr4::tree::TerminalNode *NOKEEP();
    antlr4::tree::TerminalNode *NONEDITIONABLE();
    antlr4::tree::TerminalNode *NO_OBJECT_LINK();
    antlr4::tree::TerminalNode *NO_PARTIAL_JOIN();
    antlr4::tree::TerminalNode *NO_PARTIAL_ROLLUP_PUSHDOWN();
    antlr4::tree::TerminalNode *NOPARTITION();
    antlr4::tree::TerminalNode *NO_PQ_CONCURRENT_UNION();
    antlr4::tree::TerminalNode *NO_PQ_REPLICATE();
    antlr4::tree::TerminalNode *NO_PQ_SKEW();
    antlr4::tree::TerminalNode *NO_PX_FAULT_TOLERANCE();
    antlr4::tree::TerminalNode *NORELOCATE();
    antlr4::tree::TerminalNode *NOREPLAY();
    antlr4::tree::TerminalNode *NO_ROOT_SW_FOR_LOCAL();
    antlr4::tree::TerminalNode *NO_SQL_TRANSLATION();
    antlr4::tree::TerminalNode *NO_USE_CUBE();
    antlr4::tree::TerminalNode *NO_USE_VECTOR_AGGREGATION();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM_DIMS();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM_FACT();
    antlr4::tree::TerminalNode *NO_ZONEMAP();
    antlr4::tree::TerminalNode *OBJ_ID();
    antlr4::tree::TerminalNode *OFFSET();
    antlr4::tree::TerminalNode *OLS();
    antlr4::tree::TerminalNode *OMIT();
    antlr4::tree::TerminalNode *ONE();
    antlr4::tree::TerminalNode *ORA_CHECK_ACL();
    antlr4::tree::TerminalNode *ORA_CHECK_PRIVILEGE();
    antlr4::tree::TerminalNode *ORA_CLUSTERING();
    antlr4::tree::TerminalNode *ORA_INVOKING_USER();
    antlr4::tree::TerminalNode *ORA_INVOKING_USERID();
    antlr4::tree::TerminalNode *ORA_INVOKING_XS_USER();
    antlr4::tree::TerminalNode *ORA_INVOKING_XS_USER_GUID();
    antlr4::tree::TerminalNode *ORA_RAWCOMPARE();
    antlr4::tree::TerminalNode *ORA_RAWCONCAT();
    antlr4::tree::TerminalNode *ORA_WRITE_TIME();
    antlr4::tree::TerminalNode *PARTIAL();
    antlr4::tree::TerminalNode *PARTIAL_JOIN();
    antlr4::tree::TerminalNode *PARTIAL_ROLLUP_PUSHDOWN();
    antlr4::tree::TerminalNode *PAST();
    antlr4::tree::TerminalNode *PATCH();
    antlr4::tree::TerminalNode *PATH_PREFIX();
    antlr4::tree::TerminalNode *PATTERN();
    antlr4::tree::TerminalNode *PER();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *PERMUTE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *POOL_16K();
    antlr4::tree::TerminalNode *POOL_2K();
    antlr4::tree::TerminalNode *POOL_32K();
    antlr4::tree::TerminalNode *POOL_4K();
    antlr4::tree::TerminalNode *POOL_8K();
    antlr4::tree::TerminalNode *PQ_CONCURRENT_UNION();
    antlr4::tree::TerminalNode *PQ_DISTRIBUTE_WINDOW();
    antlr4::tree::TerminalNode *PQ_FILTER();
    antlr4::tree::TerminalNode *PQ_REPLICATE();
    antlr4::tree::TerminalNode *PQ_SKEW();
    antlr4::tree::TerminalNode *PRELOAD();
    antlr4::tree::TerminalNode *PRETTY();
    antlr4::tree::TerminalNode *PREV();
    antlr4::tree::TerminalNode *PRINTBLOBTOCLOB();
    antlr4::tree::TerminalNode *PRIORITY();
    antlr4::tree::TerminalNode *PRIVILEGED();
    antlr4::tree::TerminalNode *PROXY();
    antlr4::tree::TerminalNode *PRUNING();
    antlr4::tree::TerminalNode *PX_FAULT_TOLERANCE();
    antlr4::tree::TerminalNode *REALM();
    antlr4::tree::TerminalNode *REDEFINE();
    antlr4::tree::TerminalNode *RELOCATE();
    antlr4::tree::TerminalNode *RESTART();
    antlr4::tree::TerminalNode *ROLESET();
    antlr4::tree::TerminalNode *ROWID_MAPPING_TABLE();
    antlr4::tree::TerminalNode *RUNNING();
    antlr4::tree::TerminalNode *SAVE();
    antlr4::tree::TerminalNode *SCRUB();
    antlr4::tree::TerminalNode *SDO_GEOM_MBR();
    antlr4::tree::TerminalNode *SECRET();
    antlr4::tree::TerminalNode *SERIAL();
    antlr4::tree::TerminalNode *SERVICE_NAME_CONVERT();
    antlr4::tree::TerminalNode *SERVICES();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *SHELFLIFE();
    antlr4::tree::TerminalNode *SOURCE_FILE_DIRECTORY();
    antlr4::tree::TerminalNode *SOURCE_FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *SQL_TRANSLATION_PROFILE();
    antlr4::tree::TerminalNode *STANDARD_HASH();
    antlr4::tree::TerminalNode *STANDBYS();
    antlr4::tree::TerminalNode *STATE();
    antlr4::tree::TerminalNode *STATEMENT();
    antlr4::tree::TerminalNode *STREAM();
    antlr4::tree::TerminalNode *SUBSCRIBE();
    antlr4::tree::TerminalNode *SUBSET();
    antlr4::tree::TerminalNode *SUCCESS();
    antlr4::tree::TerminalNode *SYSBACKUP();
    antlr4::tree::TerminalNode *SYS_CHECK_PRIVILEGE();
    antlr4::tree::TerminalNode *SYSDG();
    antlr4::tree::TerminalNode *SYS_GET_COL_ACLIDS();
    antlr4::tree::TerminalNode *SYSGUID();
    antlr4::tree::TerminalNode *SYSKM();
    antlr4::tree::TerminalNode *SYS_MKXTI();
    antlr4::tree::TerminalNode *SYSOBJ();
    antlr4::tree::TerminalNode *SYS_OP_CYCLED_SEQ();
    antlr4::tree::TerminalNode *SYS_OP_HASH();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_CREATE();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_FILTER();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_FILTER_LIST();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_SUCCEEDED();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_USE();
    antlr4::tree::TerminalNode *SYS_OP_PART_ID();
    antlr4::tree::TerminalNode *SYS_OP_ZONE_ID();
    antlr4::tree::TerminalNode *SYS_RAW_TO_XSID();
    antlr4::tree::TerminalNode *SYS_XSID_TO_RAW();
    antlr4::tree::TerminalNode *SYS_ZMAP_FILTER();
    antlr4::tree::TerminalNode *SYS_ZMAP_REFRESH();
    antlr4::tree::TerminalNode *TAG();
    antlr4::tree::TerminalNode *TEXT();
    antlr4::tree::TerminalNode *TIER();
    antlr4::tree::TerminalNode *TIES();
    antlr4::tree::TerminalNode *TO_ACLID();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *TRUST();
    antlr4::tree::TerminalNode *UCS2();
    antlr4::tree::TerminalNode *UNCONDITIONAL();
    antlr4::tree::TerminalNode *UNMATCHED();
    antlr4::tree::TerminalNode *UNPLUG();
    antlr4::tree::TerminalNode *UNSUBSCRIBE();
    antlr4::tree::TerminalNode *USABLE();
    antlr4::tree::TerminalNode *USE_CUBE();
    antlr4::tree::TerminalNode *USE_HIDDEN_PARTITIONS();
    antlr4::tree::TerminalNode *USER_DATA();
    antlr4::tree::TerminalNode *USER_TABLESPACES();
    antlr4::tree::TerminalNode *USE_VECTOR_AGGREGATION();
    antlr4::tree::TerminalNode *USING_NO_EXPAND();
    antlr4::tree::TerminalNode *UTF16BE();
    antlr4::tree::TerminalNode *UTF16LE();
    antlr4::tree::TerminalNode *UTF32();
    antlr4::tree::TerminalNode *UTF8();
    antlr4::tree::TerminalNode *V1();
    antlr4::tree::TerminalNode *V2();
    antlr4::tree::TerminalNode *VALID_TIME_END();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM_DIMS();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM_FACT();
    antlr4::tree::TerminalNode *VERIFIER();
    antlr4::tree::TerminalNode *VIOLATION();
    antlr4::tree::TerminalNode *VISIBILITY();
    antlr4::tree::TerminalNode *WEEK();
    antlr4::tree::TerminalNode *WEEKS();
    antlr4::tree::TerminalNode *WITH_PLSQL();
    antlr4::tree::TerminalNode *WRAPPER();
    antlr4::tree::TerminalNode *XS();
    antlr4::tree::TerminalNode *YEARS();
    antlr4::tree::TerminalNode *ZONEMAP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_reserved_keywords_in_12cContext* non_reserved_keywords_in_12c();

  class  Non_reserved_keywords_pre12cContext : public antlr4::ParserRuleContext {
  public:
    Non_reserved_keywords_pre12cContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ABORT();
    antlr4::tree::TerminalNode *ABS();
    antlr4::tree::TerminalNode *ACCESSED();
    antlr4::tree::TerminalNode *ACCESS();
    antlr4::tree::TerminalNode *ACCOUNT();
    antlr4::tree::TerminalNode *ACOS();
    antlr4::tree::TerminalNode *ACTIVATE();
    antlr4::tree::TerminalNode *ACTIVE_COMPONENT();
    antlr4::tree::TerminalNode *ACTIVE_FUNCTION();
    antlr4::tree::TerminalNode *ACTIVE_TAG();
    antlr4::tree::TerminalNode *ADD_COLUMN();
    antlr4::tree::TerminalNode *ADD_GROUP();
    antlr4::tree::TerminalNode *ADD_MONTHS();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *ADJ_DATE();
    antlr4::tree::TerminalNode *ADMINISTER();
    antlr4::tree::TerminalNode *ADMINISTRATOR();
    antlr4::tree::TerminalNode *ADMIN();
    antlr4::tree::TerminalNode *ADVISE();
    antlr4::tree::TerminalNode *ADVISOR();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *ALIAS();
    antlr4::tree::TerminalNode *ALLOCATE();
    antlr4::tree::TerminalNode *ALLOW();
    antlr4::tree::TerminalNode *ALL_ROWS();
    antlr4::tree::TerminalNode *ALWAYS();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *ANCILLARY();
    antlr4::tree::TerminalNode *AND_EQUAL();
    antlr4::tree::TerminalNode *ANTIJOIN();
    antlr4::tree::TerminalNode *ANYSCHEMA();
    antlr4::tree::TerminalNode *APPENDCHILDXML();
    antlr4::tree::TerminalNode *APPEND();
    antlr4::tree::TerminalNode *APPEND_VALUES();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *ARCHIVELOG();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *ASCII();
    antlr4::tree::TerminalNode *ASCIISTR();
    antlr4::tree::TerminalNode *ASIN();
    antlr4::tree::TerminalNode *ASSEMBLY();
    antlr4::tree::TerminalNode *ASSOCIATE();
    antlr4::tree::TerminalNode *ASYNCHRONOUS();
    antlr4::tree::TerminalNode *ASYNC();
    antlr4::tree::TerminalNode *ATAN2();
    antlr4::tree::TerminalNode *ATAN();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ATTRIBUTE();
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *AUTHENTICATED();
    antlr4::tree::TerminalNode *AUTHENTICATION();
    antlr4::tree::TerminalNode *AUTHID();
    antlr4::tree::TerminalNode *AUTHORIZATION();
    antlr4::tree::TerminalNode *AUTOALLOCATE();
    antlr4::tree::TerminalNode *AUTOEXTEND();
    antlr4::tree::TerminalNode *AUTOMATIC();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *AVAILABILITY();
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *BASICFILE();
    antlr4::tree::TerminalNode *BASIC();
    antlr4::tree::TerminalNode *BATCH();
    antlr4::tree::TerminalNode *BECOME();
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *BEGIN();
    antlr4::tree::TerminalNode *BEGIN_OUTLINE_DATA();
    antlr4::tree::TerminalNode *BEHALF();
    antlr4::tree::TerminalNode *BFILE();
    antlr4::tree::TerminalNode *BFILENAME();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *BINARY_DOUBLE_INFINITY();
    antlr4::tree::TerminalNode *BINARY_DOUBLE();
    antlr4::tree::TerminalNode *BINARY_DOUBLE_NAN();
    antlr4::tree::TerminalNode *BINARY_FLOAT_INFINITY();
    antlr4::tree::TerminalNode *BINARY_FLOAT();
    antlr4::tree::TerminalNode *BINARY_FLOAT_NAN();
    antlr4::tree::TerminalNode *BINARY();
    antlr4::tree::TerminalNode *BIND_AWARE();
    antlr4::tree::TerminalNode *BINDING();
    antlr4::tree::TerminalNode *BIN_TO_NUM();
    antlr4::tree::TerminalNode *BITAND();
    antlr4::tree::TerminalNode *BITMAP();
    antlr4::tree::TerminalNode *BITMAPS();
    antlr4::tree::TerminalNode *BITMAP_TREE();
    antlr4::tree::TerminalNode *BITS();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *BLOCK_RANGE();
    antlr4::tree::TerminalNode *BLOCKSIZE();
    antlr4::tree::TerminalNode *BLOCKS();
    antlr4::tree::TerminalNode *BODY();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *BOUND();
    antlr4::tree::TerminalNode *BRANCH();
    antlr4::tree::TerminalNode *BREADTH();
    antlr4::tree::TerminalNode *BROADCAST();
    antlr4::tree::TerminalNode *BUFFER_CACHE();
    antlr4::tree::TerminalNode *BUFFER();
    antlr4::tree::TerminalNode *BUFFER_POOL();
    antlr4::tree::TerminalNode *BUILD();
    antlr4::tree::TerminalNode *BULK();
    antlr4::tree::TerminalNode *BYPASS_RECURSIVE_CHECK();
    antlr4::tree::TerminalNode *BYPASS_UJVC();
    antlr4::tree::TerminalNode *BYTE();
    antlr4::tree::TerminalNode *CACHE_CB();
    antlr4::tree::TerminalNode *CACHE_INSTANCES();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *CACHE_TEMP_TABLE();
    antlr4::tree::TerminalNode *CALL();
    antlr4::tree::TerminalNode *CANCEL();
    antlr4::tree::TerminalNode *CARDINALITY();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CASE();
    antlr4::tree::TerminalNode *CAST();
    antlr4::tree::TerminalNode *CATEGORY();
    antlr4::tree::TerminalNode *CEIL();
    antlr4::tree::TerminalNode *CELL_FLASH_CACHE();
    antlr4::tree::TerminalNode *CERTIFICATE();
    antlr4::tree::TerminalNode *CFILE();
    antlr4::tree::TerminalNode *CHAINED();
    antlr4::tree::TerminalNode *CHANGE_DUPKEY_ERROR_INDEX();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *CHAR_CS();
    antlr4::tree::TerminalNode *CHARTOROWID();
    antlr4::tree::TerminalNode *CHECK_ACL_REWRITE();
    antlr4::tree::TerminalNode *CHECKPOINT();
    antlr4::tree::TerminalNode *CHILD();
    antlr4::tree::TerminalNode *CHOOSE();
    antlr4::tree::TerminalNode *CHR();
    antlr4::tree::TerminalNode *CHUNK();
    antlr4::tree::TerminalNode *CLASS();
    antlr4::tree::TerminalNode *CLEAR();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *CLONE();
    antlr4::tree::TerminalNode *CLOSE_CACHED_OPEN_CURSORS();
    antlr4::tree::TerminalNode *CLOSE();
    antlr4::tree::TerminalNode *CLUSTER_BY_ROWID();
    antlr4::tree::TerminalNode *CLUSTER_ID();
    antlr4::tree::TerminalNode *CLUSTERING_FACTOR();
    antlr4::tree::TerminalNode *CLUSTER_PROBABILITY();
    antlr4::tree::TerminalNode *CLUSTER_SET();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *COALESCE_SQ();
    antlr4::tree::TerminalNode *COARSE();
    antlr4::tree::TerminalNode *CO_AUTH_IND();
    antlr4::tree::TerminalNode *COLD();
    antlr4::tree::TerminalNode *COLLECT();
    antlr4::tree::TerminalNode *COLUMNAR();
    antlr4::tree::TerminalNode *COLUMN_AUTH_INDICATOR();
    antlr4::tree::TerminalNode *COLUMN();
    antlr4::tree::TerminalNode *COLUMNS();
    antlr4::tree::TerminalNode *COLUMN_STATS();
    antlr4::tree::TerminalNode *COLUMN_VALUE();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *COMMITTED();
    antlr4::tree::TerminalNode *COMPACT();
    antlr4::tree::TerminalNode *COMPATIBILITY();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *COMPLETE();
    antlr4::tree::TerminalNode *COMPLIANCE();
    antlr4::tree::TerminalNode *COMPOSE();
    antlr4::tree::TerminalNode *COMPOSITE_LIMIT();
    antlr4::tree::TerminalNode *COMPOSITE();
    antlr4::tree::TerminalNode *COMPOUND();
    antlr4::tree::TerminalNode *COMPUTE();
    antlr4::tree::TerminalNode *CONCAT();
    antlr4::tree::TerminalNode *CONFIRM();
    antlr4::tree::TerminalNode *CONFORMING();
    antlr4::tree::TerminalNode *CONNECT_BY_CB_WHR_ONLY();
    antlr4::tree::TerminalNode *CONNECT_BY_COMBINE_SW();
    antlr4::tree::TerminalNode *CONNECT_BY_COST_BASED();
    antlr4::tree::TerminalNode *CONNECT_BY_ELIM_DUPS();
    antlr4::tree::TerminalNode *CONNECT_BY_FILTERING();
    antlr4::tree::TerminalNode *CONNECT_BY_ISCYCLE();
    antlr4::tree::TerminalNode *CONNECT_BY_ISLEAF();
    antlr4::tree::TerminalNode *CONNECT_BY_ROOT();
    antlr4::tree::TerminalNode *CONNECT_TIME();
    antlr4::tree::TerminalNode *CONSIDER();
    antlr4::tree::TerminalNode *CONSISTENT();
    antlr4::tree::TerminalNode *CONSTANT();
    antlr4::tree::TerminalNode *CONST();
    antlr4::tree::TerminalNode *CONSTRAINT();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *CONTENT();
    antlr4::tree::TerminalNode *CONTENTS();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *CONTINUE();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *CORR_K();
    antlr4::tree::TerminalNode *CORR();
    antlr4::tree::TerminalNode *CORR_S();
    antlr4::tree::TerminalNode *CORRUPTION();
    antlr4::tree::TerminalNode *CORRUPT_XID_ALL();
    antlr4::tree::TerminalNode *CORRUPT_XID();
    antlr4::tree::TerminalNode *COSH();
    antlr4::tree::TerminalNode *COS();
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *COST_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *COVAR_POP();
    antlr4::tree::TerminalNode *COVAR_SAMP();
    antlr4::tree::TerminalNode *CPU_COSTING();
    antlr4::tree::TerminalNode *CPU_PER_CALL();
    antlr4::tree::TerminalNode *CPU_PER_SESSION();
    antlr4::tree::TerminalNode *CRASH();
    antlr4::tree::TerminalNode *CREATE_STORED_OUTLINES();
    antlr4::tree::TerminalNode *CREATION();
    antlr4::tree::TerminalNode *CROSSEDITION();
    antlr4::tree::TerminalNode *CROSS();
    antlr4::tree::TerminalNode *CSCONVERT();
    antlr4::tree::TerminalNode *CUBE_GB();
    antlr4::tree::TerminalNode *CUBE();
    antlr4::tree::TerminalNode *CUME_DISTM();
    antlr4::tree::TerminalNode *CUME_DIST();
    antlr4::tree::TerminalNode *CURRENT_DATE();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *CURRENT_SCHEMA();
    antlr4::tree::TerminalNode *CURRENT_TIME();
    antlr4::tree::TerminalNode *CURRENT_TIMESTAMP();
    antlr4::tree::TerminalNode *CURRENT_USER();
    antlr4::tree::TerminalNode *CURRENTV();
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *CURSOR_SHARING_EXACT();
    antlr4::tree::TerminalNode *CURSOR_SPECIFIC_SEGMENT();
    antlr4::tree::TerminalNode *CV();
    antlr4::tree::TerminalNode *CYCLE();
    antlr4::tree::TerminalNode *DANGLING();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *DATAFILES();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *DATAOBJNO();
    antlr4::tree::TerminalNode *DATAOBJ_TO_PARTITION();
    antlr4::tree::TerminalNode *DATE_MODE();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *DBA();
    antlr4::tree::TerminalNode *DBA_RECYCLEBIN();
    antlr4::tree::TerminalNode *DBMS_STATS();
    antlr4::tree::TerminalNode *DB_ROLE_CHANGE();
    antlr4::tree::TerminalNode *DBTIMEZONE();
    antlr4::tree::TerminalNode *DB_VERSION();
    antlr4::tree::TerminalNode *DDL();
    antlr4::tree::TerminalNode *DEALLOCATE();
    antlr4::tree::TerminalNode *DEBUGGER();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *DECLARE();
    antlr4::tree::TerminalNode *DEC();
    antlr4::tree::TerminalNode *DECOMPOSE();
    antlr4::tree::TerminalNode *DECREMENT();
    antlr4::tree::TerminalNode *DECR();
    antlr4::tree::TerminalNode *DECRYPT();
    antlr4::tree::TerminalNode *DEDUPLICATE();
    antlr4::tree::TerminalNode *DEFAULTS();
    antlr4::tree::TerminalNode *DEFERRABLE();
    antlr4::tree::TerminalNode *DEFERRED();
    antlr4::tree::TerminalNode *DEFINED();
    antlr4::tree::TerminalNode *DEFINER();
    antlr4::tree::TerminalNode *DEGREE();
    antlr4::tree::TerminalNode *DELAY();
    antlr4::tree::TerminalNode *DELETEXML();
    antlr4::tree::TerminalNode *DEMAND();
    antlr4::tree::TerminalNode *DENSE_RANKM();
    antlr4::tree::TerminalNode *DENSE_RANK();
    antlr4::tree::TerminalNode *DEPENDENT();
    antlr4::tree::TerminalNode *DEPTH();
    antlr4::tree::TerminalNode *DEQUEUE();
    antlr4::tree::TerminalNode *DEREF();
    antlr4::tree::TerminalNode *DEREF_NO_REWRITE();
    antlr4::tree::TerminalNode *DETACHED();
    antlr4::tree::TerminalNode *DETERMINES();
    antlr4::tree::TerminalNode *DICTIONARY();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *DIRECT_LOAD();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *DIRECT_PATH();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *DISABLE_PRESET();
    antlr4::tree::TerminalNode *DISABLE_RPKE();
    antlr4::tree::TerminalNode *DISALLOW();
    antlr4::tree::TerminalNode *DISASSOCIATE();
    antlr4::tree::TerminalNode *DISCONNECT();
    antlr4::tree::TerminalNode *DISKGROUP();
    antlr4::tree::TerminalNode *DISK();
    antlr4::tree::TerminalNode *DISKS();
    antlr4::tree::TerminalNode *DISMOUNT();
    antlr4::tree::TerminalNode *DISTINGUISHED();
    antlr4::tree::TerminalNode *DISTRIBUTED();
    antlr4::tree::TerminalNode *DML();
    antlr4::tree::TerminalNode *DML_UPDATE();
    antlr4::tree::TerminalNode *DOCFIDELITY();
    antlr4::tree::TerminalNode *DOCUMENT();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_FILTER();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_NO_SORT();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_SORT();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *DOWNGRADE();
    antlr4::tree::TerminalNode *DRIVING_SITE();
    antlr4::tree::TerminalNode *DROP_COLUMN();
    antlr4::tree::TerminalNode *DROP_GROUP();
    antlr4::tree::TerminalNode *DST_UPGRADE_INSERT_CONV();
    antlr4::tree::TerminalNode *DUMP();
    antlr4::tree::TerminalNode *DYNAMIC();
    antlr4::tree::TerminalNode *DYNAMIC_SAMPLING_EST_CDN();
    antlr4::tree::TerminalNode *DYNAMIC_SAMPLING();
    antlr4::tree::TerminalNode *EACH();
    antlr4::tree::TerminalNode *EDITIONING();
    antlr4::tree::TerminalNode *EDITION();
    antlr4::tree::TerminalNode *EDITIONS();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *ELIMINATE_JOIN();
    antlr4::tree::TerminalNode *ELIMINATE_OBY();
    antlr4::tree::TerminalNode *ELIMINATE_OUTER_JOIN();
    antlr4::tree::TerminalNode *EMPTY_BLOB();
    antlr4::tree::TerminalNode *EMPTY_CLOB();
    antlr4::tree::TerminalNode *EMPTY();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *ENABLE_PRESET();
    antlr4::tree::TerminalNode *ENCODING();
    antlr4::tree::TerminalNode *ENCRYPTION();
    antlr4::tree::TerminalNode *ENCRYPT();
    antlr4::tree::TerminalNode *END_OUTLINE_DATA();
    antlr4::tree::TerminalNode *ENFORCED();
    antlr4::tree::TerminalNode *ENFORCE();
    antlr4::tree::TerminalNode *ENQUEUE();
    antlr4::tree::TerminalNode *ENTERPRISE();
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *ENTRY();
    antlr4::tree::TerminalNode *ERROR_ARGUMENT();
    antlr4::tree::TerminalNode *ERROR();
    antlr4::tree::TerminalNode *ERROR_ON_OVERLAP_TIME();
    antlr4::tree::TerminalNode *ERRORS();
    antlr4::tree::TerminalNode *ESCAPE();
    antlr4::tree::TerminalNode *ESTIMATE();
    antlr4::tree::TerminalNode *EVALNAME();
    antlr4::tree::TerminalNode *EVALUATION();
    antlr4::tree::TerminalNode *EVENTS();
    antlr4::tree::TerminalNode *EVERY();
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *EXCEPT();
    antlr4::tree::TerminalNode *EXCHANGE();
    antlr4::tree::TerminalNode *EXCLUDE();
    antlr4::tree::TerminalNode *EXCLUDING();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *EXEMPT();
    antlr4::tree::TerminalNode *EXISTSNODE();
    antlr4::tree::TerminalNode *EXPAND_GSET_TO_UNION();
    antlr4::tree::TerminalNode *EXPAND_TABLE();
    antlr4::tree::TerminalNode *EXPIRE();
    antlr4::tree::TerminalNode *EXPLAIN();
    antlr4::tree::TerminalNode *EXPLOSION();
    antlr4::tree::TerminalNode *EXP();
    antlr4::tree::TerminalNode *EXPORT();
    antlr4::tree::TerminalNode *EXPR_CORR_CHECK();
    antlr4::tree::TerminalNode *EXTENDS();
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *EXTENTS();
    antlr4::tree::TerminalNode *EXTERNALLY();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *EXTRACT();
    antlr4::tree::TerminalNode *EXTRACTVALUE();
    antlr4::tree::TerminalNode *EXTRA();
    antlr4::tree::TerminalNode *FACILITY();
    antlr4::tree::TerminalNode *FACT();
    antlr4::tree::TerminalNode *FACTORIZE_JOIN();
    antlr4::tree::TerminalNode *FAILED_LOGIN_ATTEMPTS();
    antlr4::tree::TerminalNode *FAILED();
    antlr4::tree::TerminalNode *FAILGROUP();
    antlr4::tree::TerminalNode *FALSE();
    antlr4::tree::TerminalNode *FAST();
    antlr4::tree::TerminalNode *FBTSCAN();
    antlr4::tree::TerminalNode *FEATURE_ID();
    antlr4::tree::TerminalNode *FEATURE_SET();
    antlr4::tree::TerminalNode *FEATURE_VALUE();
    antlr4::tree::TerminalNode *FILE();
    antlr4::tree::TerminalNode *FILESYSTEM_LIKE_LOGGING();
    antlr4::tree::TerminalNode *FILTER();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *FINE();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *FIRSTM();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *FIRST_ROWS();
    antlr4::tree::TerminalNode *FIRST_VALUE();
    antlr4::tree::TerminalNode *FLAGGER();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *FLASH_CACHE();
    antlr4::tree::TerminalNode *FLOB();
    antlr4::tree::TerminalNode *FLOOR();
    antlr4::tree::TerminalNode *FLUSH();
    antlr4::tree::TerminalNode *FOLDER();
    antlr4::tree::TerminalNode *FOLLOWING();
    antlr4::tree::TerminalNode *FOLLOWS();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *FORCE_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *FOREIGN();
    antlr4::tree::TerminalNode *FOREVER();
    antlr4::tree::TerminalNode *FORWARD();
    antlr4::tree::TerminalNode *FRAGMENT_NUMBER();
    antlr4::tree::TerminalNode *FREELIST();
    antlr4::tree::TerminalNode *FREELISTS();
    antlr4::tree::TerminalNode *FREEPOOLS();
    antlr4::tree::TerminalNode *FRESH();
    antlr4::tree::TerminalNode *FROM_TZ();
    antlr4::tree::TerminalNode *FULL();
    antlr4::tree::TerminalNode *FULL_OUTER_JOIN_TO_OUTER();
    antlr4::tree::TerminalNode *FUNCTION();
    antlr4::tree::TerminalNode *FUNCTIONS();
    antlr4::tree::TerminalNode *GATHER_PLAN_STATISTICS();
    antlr4::tree::TerminalNode *GBY_CONC_ROLLUP();
    antlr4::tree::TerminalNode *GBY_PUSHDOWN();
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *GLOBAL_NAME();
    antlr4::tree::TerminalNode *GLOBAL_TOPIC_ENABLED();
    antlr4::tree::TerminalNode *GREATEST();
    antlr4::tree::TerminalNode *GROUP_BY();
    antlr4::tree::TerminalNode *GROUP_ID();
    antlr4::tree::TerminalNode *GROUPING_ID();
    antlr4::tree::TerminalNode *GROUPING();
    antlr4::tree::TerminalNode *GROUPS();
    antlr4::tree::TerminalNode *GUARANTEED();
    antlr4::tree::TerminalNode *GUARANTEE();
    antlr4::tree::TerminalNode *GUARD();
    antlr4::tree::TerminalNode *HASH_AJ();
    antlr4::tree::TerminalNode *HASHKEYS();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *HASH_SJ();
    antlr4::tree::TerminalNode *HEADER();
    antlr4::tree::TerminalNode *HEAP();
    antlr4::tree::TerminalNode *HELP();
    antlr4::tree::TerminalNode *HEXTORAW();
    antlr4::tree::TerminalNode *HEXTOREF();
    antlr4::tree::TerminalNode *HIDDEN_KEYWORD();
    antlr4::tree::TerminalNode *HIDE();
    antlr4::tree::TerminalNode *HIERARCHY();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *HINTSET_BEGIN();
    antlr4::tree::TerminalNode *HINTSET_END();
    antlr4::tree::TerminalNode *HOT();
    antlr4::tree::TerminalNode *HOUR();
    antlr4::tree::TerminalNode *HWM_BROKERED();
    antlr4::tree::TerminalNode *HYBRID();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *IDENTITY();
    antlr4::tree::TerminalNode *IDGENERATORS();
    antlr4::tree::TerminalNode *IDLE_TIME();
    antlr4::tree::TerminalNode *ID();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *IGNORE();
    antlr4::tree::TerminalNode *IGNORE_OPTIM_EMBEDDED_HINTS();
    antlr4::tree::TerminalNode *IGNORE_ROW_ON_DUPKEY_INDEX();
    antlr4::tree::TerminalNode *IGNORE_WHERE_CLAUSE();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *IMPACT();
    antlr4::tree::TerminalNode *IMPORT();
    antlr4::tree::TerminalNode *INCLUDE();
    antlr4::tree::TerminalNode *INCLUDE_VERSION();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *INCREMENTAL();
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *INCR();
    antlr4::tree::TerminalNode *INDENT();
    antlr4::tree::TerminalNode *INDEX_ASC();
    antlr4::tree::TerminalNode *INDEX_COMBINE();
    antlr4::tree::TerminalNode *INDEX_DESC();
    antlr4::tree::TerminalNode *INDEXED();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *INDEX_FFS();
    antlr4::tree::TerminalNode *INDEX_FILTER();
    antlr4::tree::TerminalNode *INDEX_JOIN();
    antlr4::tree::TerminalNode *INDEX_ROWS();
    antlr4::tree::TerminalNode *INDEX_RRS();
    antlr4::tree::TerminalNode *INDEX_RS_ASC();
    antlr4::tree::TerminalNode *INDEX_RS_DESC();
    antlr4::tree::TerminalNode *INDEX_RS();
    antlr4::tree::TerminalNode *INDEX_SCAN();
    antlr4::tree::TerminalNode *INDEX_SKIP_SCAN();
    antlr4::tree::TerminalNode *INDEX_SS_ASC();
    antlr4::tree::TerminalNode *INDEX_SS_DESC();
    antlr4::tree::TerminalNode *INDEX_SS();
    antlr4::tree::TerminalNode *INDEX_STATS();
    antlr4::tree::TerminalNode *INDEXTYPE();
    antlr4::tree::TerminalNode *INDEXTYPES();
    antlr4::tree::TerminalNode *INDICATOR();
    antlr4::tree::TerminalNode *INFINITE();
    antlr4::tree::TerminalNode *INFORMATIONAL();
    antlr4::tree::TerminalNode *INITCAP();
    antlr4::tree::TerminalNode *INITIALIZED();
    antlr4::tree::TerminalNode *INITIALLY();
    antlr4::tree::TerminalNode *INITIAL();
    antlr4::tree::TerminalNode *INITRANS();
    antlr4::tree::TerminalNode *INLINE();
    antlr4::tree::TerminalNode *INLINE_XMLTYPE_NT();
    antlr4::tree::TerminalNode *IN_MEMORY_METADATA();
    antlr4::tree::TerminalNode *INNER();
    antlr4::tree::TerminalNode *INSERTCHILDXMLAFTER();
    antlr4::tree::TerminalNode *INSERTCHILDXMLBEFORE();
    antlr4::tree::TerminalNode *INSERTCHILDXML();
    antlr4::tree::TerminalNode *INSERTXMLAFTER();
    antlr4::tree::TerminalNode *INSERTXMLBEFORE();
    antlr4::tree::TerminalNode *INSTANCE();
    antlr4::tree::TerminalNode *INSTANCES();
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *INSTANTLY();
    antlr4::tree::TerminalNode *INSTEAD();
    antlr4::tree::TerminalNode *INSTR2();
    antlr4::tree::TerminalNode *INSTR4();
    antlr4::tree::TerminalNode *INSTRB();
    antlr4::tree::TerminalNode *INSTRC();
    antlr4::tree::TerminalNode *INSTR();
    antlr4::tree::TerminalNode *INTERMEDIATE();
    antlr4::tree::TerminalNode *INTERNAL_CONVERT();
    antlr4::tree::TerminalNode *INTERNAL_USE();
    antlr4::tree::TerminalNode *INTERPRETED();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *INT();
    antlr4::tree::TerminalNode *INVALIDATE();
    antlr4::tree::TerminalNode *INVISIBLE();
    antlr4::tree::TerminalNode *IN_XQUERY();
    antlr4::tree::TerminalNode *ISOLATION_LEVEL();
    antlr4::tree::TerminalNode *ISOLATION();
    antlr4::tree::TerminalNode *ITERATE();
    antlr4::tree::TerminalNode *ITERATION_NUMBER();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *JOB();
    antlr4::tree::TerminalNode *JOIN();
    antlr4::tree::TerminalNode *KEEP_DUPLICATES();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *KERBEROS();
    antlr4::tree::TerminalNode *KEY_LENGTH();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *KEYSIZE();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *KILL();
    antlr4::tree::TerminalNode *LAG();
    antlr4::tree::TerminalNode *LAST_DAY();
    antlr4::tree::TerminalNode *LAST();
    antlr4::tree::TerminalNode *LAST_VALUE();
    antlr4::tree::TerminalNode *LATERAL();
    antlr4::tree::TerminalNode *LAYER();
    antlr4::tree::TerminalNode *LDAP_REGISTRATION_ENABLED();
    antlr4::tree::TerminalNode *LDAP_REGISTRATION();
    antlr4::tree::TerminalNode *LDAP_REG_SYNC_INTERVAL();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *LEAD();
    antlr4::tree::TerminalNode *LEAST();
    antlr4::tree::TerminalNode *LEFT();
    antlr4::tree::TerminalNode *LENGTH2();
    antlr4::tree::TerminalNode *LENGTH4();
    antlr4::tree::TerminalNode *LENGTHB();
    antlr4::tree::TerminalNode *LENGTHC();
    antlr4::tree::TerminalNode *LENGTH();
    antlr4::tree::TerminalNode *LESS();
    antlr4::tree::TerminalNode *LEVEL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *LIBRARY();
    antlr4::tree::TerminalNode *LIFE();
    antlr4::tree::TerminalNode *LIFETIME();
    antlr4::tree::TerminalNode *LIKE2();
    antlr4::tree::TerminalNode *LIKE4();
    antlr4::tree::TerminalNode *LIKEC();
    antlr4::tree::TerminalNode *LIKE_EXPAND();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *LINK();
    antlr4::tree::TerminalNode *LISTAGG();
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *LN();
    antlr4::tree::TerminalNode *LNNVL();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *LOB();
    antlr4::tree::TerminalNode *LOBNVL();
    antlr4::tree::TerminalNode *LOBS();
    antlr4::tree::TerminalNode *LOCAL_INDEXES();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *LOCALTIME();
    antlr4::tree::TerminalNode *LOCALTIMESTAMP();
    antlr4::tree::TerminalNode *LOCATION();
    antlr4::tree::TerminalNode *LOCATOR();
    antlr4::tree::TerminalNode *LOCKED();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *LOGFILES();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_CALL();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_SESSION();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *LOGOFF();
    antlr4::tree::TerminalNode *LOGON();
    antlr4::tree::TerminalNode *LOG_READ_ONLY_VIOLATIONS();
    antlr4::tree::TerminalNode *LOWER();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *LPAD();
    antlr4::tree::TerminalNode *LTRIM();
    antlr4::tree::TerminalNode *MAIN();
    antlr4::tree::TerminalNode *MAKE_REF();
    antlr4::tree::TerminalNode *MANAGED();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *MANAGE();
    antlr4::tree::TerminalNode *MANAGER();
    antlr4::tree::TerminalNode *MANUAL();
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *MASTER();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *MATERIALIZE();
    antlr4::tree::TerminalNode *MAXARCHLOGS();
    antlr4::tree::TerminalNode *MAXDATAFILES();
    antlr4::tree::TerminalNode *MAXEXTENTS();
    antlr4::tree::TerminalNode *MAXIMIZE();
    antlr4::tree::TerminalNode *MAXINSTANCES();
    antlr4::tree::TerminalNode *MAXLOGFILES();
    antlr4::tree::TerminalNode *MAXLOGHISTORY();
    antlr4::tree::TerminalNode *MAXLOGMEMBERS();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MAXSIZE();
    antlr4::tree::TerminalNode *MAXTRANS();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *MEASURES();
    antlr4::tree::TerminalNode *MEDIAN();
    antlr4::tree::TerminalNode *MEDIUM();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *MEMORY();
    antlr4::tree::TerminalNode *MERGEACTIONS();
    antlr4::tree::TerminalNode *MERGE_AJ();
    antlr4::tree::TerminalNode *MERGE_CONST_ON();
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *MERGE_SJ();
    antlr4::tree::TerminalNode *METHOD();
    antlr4::tree::TerminalNode *MIGRATE();
    antlr4::tree::TerminalNode *MIGRATION();
    antlr4::tree::TerminalNode *MINEXTENTS();
    antlr4::tree::TerminalNode *MINIMIZE();
    antlr4::tree::TerminalNode *MINIMUM();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *MINUS_NULL();
    antlr4::tree::TerminalNode *MINUTE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *MIRRORCOLD();
    antlr4::tree::TerminalNode *MIRRORHOT();
    antlr4::tree::TerminalNode *MIRROR();
    antlr4::tree::TerminalNode *MLSLABEL();
    antlr4::tree::TerminalNode *MODEL_COMPILE_SUBQUERY();
    antlr4::tree::TerminalNode *MODEL_DONTVERIFY_UNIQUENESS();
    antlr4::tree::TerminalNode *MODEL_DYNAMIC_SUBQUERY();
    antlr4::tree::TerminalNode *MODEL_MIN_ANALYSIS();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *MODEL_NO_ANALYSIS();
    antlr4::tree::TerminalNode *MODEL_PBY();
    antlr4::tree::TerminalNode *MODEL_PUSH_REF();
    antlr4::tree::TerminalNode *MODIFY_COLUMN_TYPE();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *MOD();
    antlr4::tree::TerminalNode *MONITORING();
    antlr4::tree::TerminalNode *MONITOR();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *MONTHS_BETWEEN();
    antlr4::tree::TerminalNode *MOUNT();
    antlr4::tree::TerminalNode *MOUNTPATH();
    antlr4::tree::TerminalNode *MOVEMENT();
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *MULTISET();
    antlr4::tree::TerminalNode *MV_MERGE();
    antlr4::tree::TerminalNode *NAMED();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *NAMESPACE();
    antlr4::tree::TerminalNode *NAN();
    antlr4::tree::TerminalNode *NANVL();
    antlr4::tree::TerminalNode *NATIONAL();
    antlr4::tree::TerminalNode *NATIVE_FULL_OUTER_JOIN();
    antlr4::tree::TerminalNode *NATIVE();
    antlr4::tree::TerminalNode *NATURAL();
    antlr4::tree::TerminalNode *NAV();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *NCHAR();
    antlr4::tree::TerminalNode *NCHR();
    antlr4::tree::TerminalNode *NCLOB();
    antlr4::tree::TerminalNode *NEEDED();
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *NESTED_TABLE_FAST_INSERT();
    antlr4::tree::TerminalNode *NESTED_TABLE_GET_REFS();
    antlr4::tree::TerminalNode *NESTED_TABLE_ID();
    antlr4::tree::TerminalNode *NESTED_TABLE_SET_REFS();
    antlr4::tree::TerminalNode *NESTED_TABLE_SET_SETID();
    antlr4::tree::TerminalNode *NETWORK();
    antlr4::tree::TerminalNode *NEVER();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *NEW_TIME();
    antlr4::tree::TerminalNode *NEXT_DAY();
    antlr4::tree::TerminalNode *NEXT();
    antlr4::tree::TerminalNode *NL_AJ();
    antlr4::tree::TerminalNode *NLJ_BATCHING();
    antlr4::tree::TerminalNode *NLJ_INDEX_FILTER();
    antlr4::tree::TerminalNode *NLJ_INDEX_SCAN();
    antlr4::tree::TerminalNode *NLJ_PREFETCH();
    antlr4::tree::TerminalNode *NLS_CALENDAR();
    antlr4::tree::TerminalNode *NLS_CHARACTERSET();
    antlr4::tree::TerminalNode *NLS_CHARSET_DECL_LEN();
    antlr4::tree::TerminalNode *NLS_CHARSET_ID();
    antlr4::tree::TerminalNode *NLS_CHARSET_NAME();
    antlr4::tree::TerminalNode *NLS_COMP();
    antlr4::tree::TerminalNode *NLS_CURRENCY();
    antlr4::tree::TerminalNode *NLS_DATE_FORMAT();
    antlr4::tree::TerminalNode *NLS_DATE_LANGUAGE();
    antlr4::tree::TerminalNode *NLS_INITCAP();
    antlr4::tree::TerminalNode *NLS_ISO_CURRENCY();
    antlr4::tree::TerminalNode *NL_SJ();
    antlr4::tree::TerminalNode *NLS_LANG();
    antlr4::tree::TerminalNode *NLS_LANGUAGE();
    antlr4::tree::TerminalNode *NLS_LENGTH_SEMANTICS();
    antlr4::tree::TerminalNode *NLS_LOWER();
    antlr4::tree::TerminalNode *NLS_NCHAR_CONV_EXCP();
    antlr4::tree::TerminalNode *NLS_NUMERIC_CHARACTERS();
    antlr4::tree::TerminalNode *NLS_SORT();
    antlr4::tree::TerminalNode *NLSSORT();
    antlr4::tree::TerminalNode *NLS_SPECIAL_CHARS();
    antlr4::tree::TerminalNode *NLS_TERRITORY();
    antlr4::tree::TerminalNode *NLS_UPPER();
    antlr4::tree::TerminalNode *NO_ACCESS();
    antlr4::tree::TerminalNode *NOAPPEND();
    antlr4::tree::TerminalNode *NOARCHIVELOG();
    antlr4::tree::TerminalNode *NOAUDIT();
    antlr4::tree::TerminalNode *NO_BASETABLE_MULTIMV_REWRITE();
    antlr4::tree::TerminalNode *NO_BIND_AWARE();
    antlr4::tree::TerminalNode *NO_BUFFER();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *NO_CARTESIAN();
    antlr4::tree::TerminalNode *NO_CHECK_ACL_REWRITE();
    antlr4::tree::TerminalNode *NO_CLUSTER_BY_ROWID();
    antlr4::tree::TerminalNode *NO_COALESCE_SQ();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_CB_WHR_ONLY();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_COMBINE_SW();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_COST_BASED();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_ELIM_DUPS();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_FILTERING();
    antlr4::tree::TerminalNode *NO_COST_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *NO_CPU_COSTING();
    antlr4::tree::TerminalNode *NOCPU_COSTING();
    antlr4::tree::TerminalNode *NOCYCLE();
    antlr4::tree::TerminalNode *NODELAY();
    antlr4::tree::TerminalNode *NO_DOMAIN_INDEX_FILTER();
    antlr4::tree::TerminalNode *NO_DST_UPGRADE_INSERT_CONV();
    antlr4::tree::TerminalNode *NO_ELIMINATE_JOIN();
    antlr4::tree::TerminalNode *NO_ELIMINATE_OBY();
    antlr4::tree::TerminalNode *NO_ELIMINATE_OUTER_JOIN();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *NO_EXPAND_GSET_TO_UNION();
    antlr4::tree::TerminalNode *NO_EXPAND();
    antlr4::tree::TerminalNode *NO_EXPAND_TABLE();
    antlr4::tree::TerminalNode *NO_FACT();
    antlr4::tree::TerminalNode *NO_FACTORIZE_JOIN();
    antlr4::tree::TerminalNode *NO_FILTERING();
    antlr4::tree::TerminalNode *NOFORCE();
    antlr4::tree::TerminalNode *NO_FULL_OUTER_JOIN_TO_OUTER();
    antlr4::tree::TerminalNode *NO_GBY_PUSHDOWN();
    antlr4::tree::TerminalNode *NOGUARANTEE();
    antlr4::tree::TerminalNode *NO_INDEX_FFS();
    antlr4::tree::TerminalNode *NO_INDEX();
    antlr4::tree::TerminalNode *NO_INDEX_SS();
    antlr4::tree::TerminalNode *NO_LOAD();
    antlr4::tree::TerminalNode *NOLOCAL();
    antlr4::tree::TerminalNode *NOLOGGING();
    antlr4::tree::TerminalNode *NOMAPPING();
    antlr4::tree::TerminalNode *NOMAXVALUE();
    antlr4::tree::TerminalNode *NO_MERGE();
    antlr4::tree::TerminalNode *NOMINIMIZE();
    antlr4::tree::TerminalNode *NOMINVALUE();
    antlr4::tree::TerminalNode *NO_MODEL_PUSH_REF();
    antlr4::tree::TerminalNode *NO_MONITORING();
    antlr4::tree::TerminalNode *NOMONITORING();
    antlr4::tree::TerminalNode *NO_MONITOR();
    antlr4::tree::TerminalNode *NO_MULTIMV_REWRITE();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *NO_NATIVE_FULL_OUTER_JOIN();
    antlr4::tree::TerminalNode *NONBLOCKING();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *NO_NLJ_BATCHING();
    antlr4::tree::TerminalNode *NO_NLJ_PREFETCH();
    antlr4::tree::TerminalNode *NONSCHEMA();
    antlr4::tree::TerminalNode *NOORDER();
    antlr4::tree::TerminalNode *NO_ORDER_ROLLUPS();
    antlr4::tree::TerminalNode *NO_OUTER_JOIN_TO_ANTI();
    antlr4::tree::TerminalNode *NO_OUTER_JOIN_TO_INNER();
    antlr4::tree::TerminalNode *NOOVERRIDE();
    antlr4::tree::TerminalNode *NO_PARALLEL_INDEX();
    antlr4::tree::TerminalNode *NOPARALLEL_INDEX();
    antlr4::tree::TerminalNode *NO_PARALLEL();
    antlr4::tree::TerminalNode *NOPARALLEL();
    antlr4::tree::TerminalNode *NO_PARTIAL_COMMIT();
    antlr4::tree::TerminalNode *NO_PLACE_DISTINCT();
    antlr4::tree::TerminalNode *NO_PLACE_GROUP_BY();
    antlr4::tree::TerminalNode *NO_PQ_MAP();
    antlr4::tree::TerminalNode *NO_PRUNE_GSETS();
    antlr4::tree::TerminalNode *NO_PULL_PRED();
    antlr4::tree::TerminalNode *NO_PUSH_PRED();
    antlr4::tree::TerminalNode *NO_PUSH_SUBQ();
    antlr4::tree::TerminalNode *NO_PX_JOIN_FILTER();
    antlr4::tree::TerminalNode *NO_QKN_BUFF();
    antlr4::tree::TerminalNode *NO_QUERY_TRANSFORMATION();
    antlr4::tree::TerminalNode *NO_REF_CASCADE();
    antlr4::tree::TerminalNode *NORELY();
    antlr4::tree::TerminalNode *NOREPAIR();
    antlr4::tree::TerminalNode *NORESETLOGS();
    antlr4::tree::TerminalNode *NO_RESULT_CACHE();
    antlr4::tree::TerminalNode *NOREVERSE();
    antlr4::tree::TerminalNode *NO_REWRITE();
    antlr4::tree::TerminalNode *NOREWRITE();
    antlr4::tree::TerminalNode *NORMAL();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOSCHEMACHECK();
    antlr4::tree::TerminalNode *NOSEGMENT();
    antlr4::tree::TerminalNode *NO_SEMIJOIN();
    antlr4::tree::TerminalNode *NO_SEMI_TO_INNER();
    antlr4::tree::TerminalNode *NO_SET_TO_JOIN();
    antlr4::tree::TerminalNode *NOSORT();
    antlr4::tree::TerminalNode *NO_SQL_TUNE();
    antlr4::tree::TerminalNode *NO_STAR_TRANSFORMATION();
    antlr4::tree::TerminalNode *NO_STATEMENT_QUEUING();
    antlr4::tree::TerminalNode *NO_STATS_GSETS();
    antlr4::tree::TerminalNode *NOSTRICT();
    antlr4::tree::TerminalNode *NO_SUBQUERY_PRUNING();
    antlr4::tree::TerminalNode *NO_SUBSTRB_PAD();
    antlr4::tree::TerminalNode *NO_SWAP_JOIN_INPUTS();
    antlr4::tree::TerminalNode *NOSWITCH();
    antlr4::tree::TerminalNode *NO_TABLE_LOOKUP_BY_NL();
    antlr4::tree::TerminalNode *NO_TEMP_TABLE();
    antlr4::tree::TerminalNode *NOTHING();
    antlr4::tree::TerminalNode *NOTIFICATION();
    antlr4::tree::TerminalNode *NO_TRANSFORM_DISTINCT_AGG();
    antlr4::tree::TerminalNode *NO_UNNEST();
    antlr4::tree::TerminalNode *NO_USE_HASH_AGGREGATION();
    antlr4::tree::TerminalNode *NO_USE_HASH_GBY_FOR_PUSHDOWN();
    antlr4::tree::TerminalNode *NO_USE_HASH();
    antlr4::tree::TerminalNode *NO_USE_INVISIBLE_INDEXES();
    antlr4::tree::TerminalNode *NO_USE_MERGE();
    antlr4::tree::TerminalNode *NO_USE_NL();
    antlr4::tree::TerminalNode *NOVALIDATE();
    antlr4::tree::TerminalNode *NO_XDB_FASTPATH_INSERT();
    antlr4::tree::TerminalNode *NO_XML_DML_REWRITE();
    antlr4::tree::TerminalNode *NO_XMLINDEX_REWRITE_IN_SELECT();
    antlr4::tree::TerminalNode *NO_XMLINDEX_REWRITE();
    antlr4::tree::TerminalNode *NO_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *NTH_VALUE();
    antlr4::tree::TerminalNode *NTILE();
    antlr4::tree::TerminalNode *NULLIF();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *NUMERIC();
    antlr4::tree::TerminalNode *NUM_INDEX_KEYS();
    antlr4::tree::TerminalNode *NUMTODSINTERVAL();
    antlr4::tree::TerminalNode *NUMTOYMINTERVAL();
    antlr4::tree::TerminalNode *NVARCHAR2();
    antlr4::tree::TerminalNode *NVL2();
    antlr4::tree::TerminalNode *NVL();
    antlr4::tree::TerminalNode *OBJECT2XML();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *OBJNO();
    antlr4::tree::TerminalNode *OBJNO_REUSE();
    antlr4::tree::TerminalNode *OCCURENCES();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *OFF();
    antlr4::tree::TerminalNode *OIDINDEX();
    antlr4::tree::TerminalNode *OID();
    antlr4::tree::TerminalNode *OLAP();
    antlr4::tree::TerminalNode *OLD();
    antlr4::tree::TerminalNode *OLD_PUSH_PRED();
    antlr4::tree::TerminalNode *OLTP();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *OPAQUE();
    antlr4::tree::TerminalNode *OPAQUE_TRANSFORM();
    antlr4::tree::TerminalNode *OPAQUE_XCANONICAL();
    antlr4::tree::TerminalNode *OPCODE();
    antlr4::tree::TerminalNode *OPEN();
    antlr4::tree::TerminalNode *OPERATIONS();
    antlr4::tree::TerminalNode *OPERATOR();
    antlr4::tree::TerminalNode *OPT_ESTIMATE();
    antlr4::tree::TerminalNode *OPTIMAL();
    antlr4::tree::TerminalNode *OPTIMIZE();
    antlr4::tree::TerminalNode *OPTIMIZER_FEATURES_ENABLE();
    antlr4::tree::TerminalNode *OPTIMIZER_GOAL();
    antlr4::tree::TerminalNode *OPT_PARAM();
    antlr4::tree::TerminalNode *ORA_BRANCH();
    antlr4::tree::TerminalNode *ORADEBUG();
    antlr4::tree::TerminalNode *ORA_DST_AFFECTED();
    antlr4::tree::TerminalNode *ORA_DST_CONVERT();
    antlr4::tree::TerminalNode *ORA_DST_ERROR();
    antlr4::tree::TerminalNode *ORA_GET_ACLIDS();
    antlr4::tree::TerminalNode *ORA_GET_PRIVILEGES();
    antlr4::tree::TerminalNode *ORA_HASH();
    antlr4::tree::TerminalNode *ORA_ROWSCN();
    antlr4::tree::TerminalNode *ORA_ROWSCN_RAW();
    antlr4::tree::TerminalNode *ORA_ROWVERSION();
    antlr4::tree::TerminalNode *ORA_TABVERSION();
    antlr4::tree::TerminalNode *ORDERED();
    antlr4::tree::TerminalNode *ORDERED_PREDICATES();
    antlr4::tree::TerminalNode *ORDINALITY();
    antlr4::tree::TerminalNode *OR_EXPAND();
    antlr4::tree::TerminalNode *ORGANIZATION();
    antlr4::tree::TerminalNode *OR_PREDICATES();
    antlr4::tree::TerminalNode *OTHER();
    antlr4::tree::TerminalNode *OUTER_JOIN_TO_ANTI();
    antlr4::tree::TerminalNode *OUTER_JOIN_TO_INNER();
    antlr4::tree::TerminalNode *OUTER();
    antlr4::tree::TerminalNode *OUTLINE_LEAF();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *OUT_OF_LINE();
    antlr4::tree::TerminalNode *OVERFLOW();
    antlr4::tree::TerminalNode *OVERFLOW_NOMOVE();
    antlr4::tree::TerminalNode *OVERLAPS();
    antlr4::tree::TerminalNode *OVER();
    antlr4::tree::TerminalNode *OWNER();
    antlr4::tree::TerminalNode *OWNERSHIP();
    antlr4::tree::TerminalNode *OWN();
    antlr4::tree::TerminalNode *PACKAGE();
    antlr4::tree::TerminalNode *PACKAGES();
    antlr4::tree::TerminalNode *PARALLEL_INDEX();
    antlr4::tree::TerminalNode *PARALLEL();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *PARAM();
    antlr4::tree::TerminalNode *PARENT();
    antlr4::tree::TerminalNode *PARITY();
    antlr4::tree::TerminalNode *PARTIALLY();
    antlr4::tree::TerminalNode *PARTITION_HASH();
    antlr4::tree::TerminalNode *PARTITION_LIST();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *PARTITION_RANGE();
    antlr4::tree::TerminalNode *PARTITIONS();
    antlr4::tree::TerminalNode *PARTNUMINST();
    antlr4::tree::TerminalNode *PASSING();
    antlr4::tree::TerminalNode *PASSWORD_GRACE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_LIFE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_LOCK_TIME();
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_MAX();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_VERIFY_FUNCTION();
    antlr4::tree::TerminalNode *PATH();
    antlr4::tree::TerminalNode *PATHS();
    antlr4::tree::TerminalNode *PBL_HS_BEGIN();
    antlr4::tree::TerminalNode *PBL_HS_END();
    antlr4::tree::TerminalNode *PCTINCREASE();
    antlr4::tree::TerminalNode *PCTTHRESHOLD();
    antlr4::tree::TerminalNode *PCTUSED();
    antlr4::tree::TerminalNode *PCTVERSION();
    antlr4::tree::TerminalNode *PENDING();
    antlr4::tree::TerminalNode *PERCENTILE_CONT();
    antlr4::tree::TerminalNode *PERCENTILE_DISC();
    antlr4::tree::TerminalNode *PERCENT_KEYWORD();
    antlr4::tree::TerminalNode *PERCENT_RANKM();
    antlr4::tree::TerminalNode *PERCENT_RANK();
    antlr4::tree::TerminalNode *PERFORMANCE();
    antlr4::tree::TerminalNode *PERMANENT();
    antlr4::tree::TerminalNode *PERMISSION();
    antlr4::tree::TerminalNode *PFILE();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *PIKEY();
    antlr4::tree::TerminalNode *PIV_GB();
    antlr4::tree::TerminalNode *PIVOT();
    antlr4::tree::TerminalNode *PIV_SSF();
    antlr4::tree::TerminalNode *PLACE_DISTINCT();
    antlr4::tree::TerminalNode *PLACE_GROUP_BY();
    antlr4::tree::TerminalNode *PLAN();
    antlr4::tree::TerminalNode *PLSCOPE_SETTINGS();
    antlr4::tree::TerminalNode *PLSQL_CCFLAGS();
    antlr4::tree::TerminalNode *PLSQL_CODE_TYPE();
    antlr4::tree::TerminalNode *PLSQL_DEBUG();
    antlr4::tree::TerminalNode *PLSQL_OPTIMIZE_LEVEL();
    antlr4::tree::TerminalNode *PLSQL_WARNINGS();
    antlr4::tree::TerminalNode *POINT();
    antlr4::tree::TerminalNode *POLICY();
    antlr4::tree::TerminalNode *POST_TRANSACTION();
    antlr4::tree::TerminalNode *POWERMULTISET_BY_CARDINALITY();
    antlr4::tree::TerminalNode *POWERMULTISET();
    antlr4::tree::TerminalNode *POWER();
    antlr4::tree::TerminalNode *PQ_DISTRIBUTE();
    antlr4::tree::TerminalNode *PQ_MAP();
    antlr4::tree::TerminalNode *PQ_NOMAP();
    antlr4::tree::TerminalNode *PREBUILT();
    antlr4::tree::TerminalNode *PRECEDES();
    antlr4::tree::TerminalNode *PRECEDING();
    antlr4::tree::TerminalNode *PRECISION();
    antlr4::tree::TerminalNode *PRECOMPUTE_SUBQUERY();
    antlr4::tree::TerminalNode *PREDICATE_REORDERS();
    antlr4::tree::TerminalNode *PREDICTION_BOUNDS();
    antlr4::tree::TerminalNode *PREDICTION_COST();
    antlr4::tree::TerminalNode *PREDICTION_DETAILS();
    antlr4::tree::TerminalNode *PREDICTION();
    antlr4::tree::TerminalNode *PREDICTION_PROBABILITY();
    antlr4::tree::TerminalNode *PREDICTION_SET();
    antlr4::tree::TerminalNode *PREPARE();
    antlr4::tree::TerminalNode *PRESENT();
    antlr4::tree::TerminalNode *PRESENTNNV();
    antlr4::tree::TerminalNode *PRESENTV();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *PRESERVE_OID();
    antlr4::tree::TerminalNode *PREVIOUS();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *PRIVATE();
    antlr4::tree::TerminalNode *PRIVATE_SGA();
    antlr4::tree::TerminalNode *PRIVILEGE();
    antlr4::tree::TerminalNode *PRIVILEGES();
    antlr4::tree::TerminalNode *PROCEDURAL();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *PROCESS();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *PROGRAM();
    antlr4::tree::TerminalNode *PROJECT();
    antlr4::tree::TerminalNode *PROPAGATE();
    antlr4::tree::TerminalNode *PROTECTED();
    antlr4::tree::TerminalNode *PROTECTION();
    antlr4::tree::TerminalNode *PULL_PRED();
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *PUSH_PRED();
    antlr4::tree::TerminalNode *PUSH_SUBQ();
    antlr4::tree::TerminalNode *PX_GRANULE();
    antlr4::tree::TerminalNode *PX_JOIN_FILTER();
    antlr4::tree::TerminalNode *QB_NAME();
    antlr4::tree::TerminalNode *QUERY_BLOCK();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *QUEUE_CURR();
    antlr4::tree::TerminalNode *QUEUE();
    antlr4::tree::TerminalNode *QUEUE_ROWP();
    antlr4::tree::TerminalNode *QUIESCE();
    antlr4::tree::TerminalNode *QUORUM();
    antlr4::tree::TerminalNode *QUOTA();
    antlr4::tree::TerminalNode *RANDOM_LOCAL();
    antlr4::tree::TerminalNode *RANDOM();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *RANKM();
    antlr4::tree::TerminalNode *RANK();
    antlr4::tree::TerminalNode *RAPIDLY();
    antlr4::tree::TerminalNode *RATIO_TO_REPORT();
    antlr4::tree::TerminalNode *RAWTOHEX();
    antlr4::tree::TerminalNode *RAWTONHEX();
    antlr4::tree::TerminalNode *RBA();
    antlr4::tree::TerminalNode *RBO_OUTLINE();
    antlr4::tree::TerminalNode *RDBA();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *READS();
    antlr4::tree::TerminalNode *REAL();
    antlr4::tree::TerminalNode *REBALANCE();
    antlr4::tree::TerminalNode *REBUILD();
    antlr4::tree::TerminalNode *RECORDS_PER_BLOCK();
    antlr4::tree::TerminalNode *RECOVERABLE();
    antlr4::tree::TerminalNode *RECOVER();
    antlr4::tree::TerminalNode *RECOVERY();
    antlr4::tree::TerminalNode *RECYCLEBIN();
    antlr4::tree::TerminalNode *RECYCLE();
    antlr4::tree::TerminalNode *REDACTION();
    antlr4::tree::TerminalNode *REDO();
    antlr4::tree::TerminalNode *REDUCED();
    antlr4::tree::TerminalNode *REDUNDANCY();
    antlr4::tree::TerminalNode *REF_CASCADE_CURSOR();
    antlr4::tree::TerminalNode *REFERENCED();
    antlr4::tree::TerminalNode *REFERENCE();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *REFERENCING();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *REFTOHEX();
    antlr4::tree::TerminalNode *REGEXP_COUNT();
    antlr4::tree::TerminalNode *REGEXP_INSTR();
    antlr4::tree::TerminalNode *REGEXP_LIKE();
    antlr4::tree::TerminalNode *REGEXP_REPLACE();
    antlr4::tree::TerminalNode *REGEXP_SUBSTR();
    antlr4::tree::TerminalNode *REGISTER();
    antlr4::tree::TerminalNode *REGR_AVGX();
    antlr4::tree::TerminalNode *REGR_AVGY();
    antlr4::tree::TerminalNode *REGR_COUNT();
    antlr4::tree::TerminalNode *REGR_INTERCEPT();
    antlr4::tree::TerminalNode *REGR_R2();
    antlr4::tree::TerminalNode *REGR_SLOPE();
    antlr4::tree::TerminalNode *REGR_SXX();
    antlr4::tree::TerminalNode *REGR_SXY();
    antlr4::tree::TerminalNode *REGR_SYY();
    antlr4::tree::TerminalNode *REGULAR();
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *REKEY();
    antlr4::tree::TerminalNode *RELATIONAL();
    antlr4::tree::TerminalNode *RELY();
    antlr4::tree::TerminalNode *REMAINDER();
    antlr4::tree::TerminalNode *REMOTE_MAPPED();
    antlr4::tree::TerminalNode *REMOVE();
    antlr4::tree::TerminalNode *REPAIR();
    antlr4::tree::TerminalNode *REPEAT();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *REPLICATION();
    antlr4::tree::TerminalNode *REQUIRED();
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *RESET();
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *RESOLVE();
    antlr4::tree::TerminalNode *RESOLVER();
    antlr4::tree::TerminalNode *RESPECT();
    antlr4::tree::TerminalNode *RESTORE_AS_INTERVALS();
    antlr4::tree::TerminalNode *RESTORE();
    antlr4::tree::TerminalNode *RESTRICT_ALL_REF_CONS();
    antlr4::tree::TerminalNode *RESTRICTED();
    antlr4::tree::TerminalNode *RESTRICT();
    antlr4::tree::TerminalNode *RESULT_CACHE();
    antlr4::tree::TerminalNode *RESUMABLE();
    antlr4::tree::TerminalNode *RESUME();
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *RETRY_ON_ROW_CHANGE();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *REVERSE();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *REWRITE_OR_ERROR();
    antlr4::tree::TerminalNode *RIGHT();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *ROLES();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *ROLLING();
    antlr4::tree::TerminalNode *ROLLUP();
    antlr4::tree::TerminalNode *ROUND();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *ROWIDTOCHAR();
    antlr4::tree::TerminalNode *ROWIDTONCHAR();
    antlr4::tree::TerminalNode *ROW_LENGTH();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROW_NUMBER();
    antlr4::tree::TerminalNode *ROWNUM();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *RPAD();
    antlr4::tree::TerminalNode *RTRIM();
    antlr4::tree::TerminalNode *RULE();
    antlr4::tree::TerminalNode *RULES();
    antlr4::tree::TerminalNode *SALT();
    antlr4::tree::TerminalNode *SAMPLE();
    antlr4::tree::TerminalNode *SAVE_AS_INTERVALS();
    antlr4::tree::TerminalNode *SAVEPOINT();
    antlr4::tree::TerminalNode *SB4();
    antlr4::tree::TerminalNode *SCALE();
    antlr4::tree::TerminalNode *SCALE_ROWS();
    antlr4::tree::TerminalNode *SCAN_INSTANCES();
    antlr4::tree::TerminalNode *SCAN();
    antlr4::tree::TerminalNode *SCHEDULER();
    antlr4::tree::TerminalNode *SCHEMACHECK();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *SCN_ASCENDING();
    antlr4::tree::TerminalNode *SCN();
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *SD_ALL();
    antlr4::tree::TerminalNode *SD_INHIBIT();
    antlr4::tree::TerminalNode *SD_SHOW();
    antlr4::tree::TerminalNode *SEARCH();
    antlr4::tree::TerminalNode *SECOND();
    antlr4::tree::TerminalNode *SECUREFILE_DBA();
    antlr4::tree::TerminalNode *SECUREFILE();
    antlr4::tree::TerminalNode *SECURITY();
    antlr4::tree::TerminalNode *SEED();
    antlr4::tree::TerminalNode *SEG_BLOCK();
    antlr4::tree::TerminalNode *SEG_FILE();
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SELECTIVITY();
    antlr4::tree::TerminalNode *SEMIJOIN_DRIVER();
    antlr4::tree::TerminalNode *SEMIJOIN();
    antlr4::tree::TerminalNode *SEMI_TO_INNER();
    antlr4::tree::TerminalNode *SEQUENCED();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *SEQUENTIAL();
    antlr4::tree::TerminalNode *SERIALIZABLE();
    antlr4::tree::TerminalNode *SERVERERROR();
    antlr4::tree::TerminalNode *SESSION_CACHED_CURSORS();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *SESSIONS_PER_USER();
    antlr4::tree::TerminalNode *SESSIONTIMEZONE();
    antlr4::tree::TerminalNode *SESSIONTZNAME();
    antlr4::tree::TerminalNode *SETS();
    antlr4::tree::TerminalNode *SETTINGS();
    antlr4::tree::TerminalNode *SET_TO_JOIN();
    antlr4::tree::TerminalNode *SEVERE();
    antlr4::tree::TerminalNode *SHARED();
    antlr4::tree::TerminalNode *SHARED_POOL();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SHUTDOWN();
    antlr4::tree::TerminalNode *SIBLINGS();
    antlr4::tree::TerminalNode *SID();
    antlr4::tree::TerminalNode *SIGNAL_COMPONENT();
    antlr4::tree::TerminalNode *SIGNAL_FUNCTION();
    antlr4::tree::TerminalNode *SIGN();
    antlr4::tree::TerminalNode *SIMPLE();
    antlr4::tree::TerminalNode *SINGLE();
    antlr4::tree::TerminalNode *SINGLETASK();
    antlr4::tree::TerminalNode *SINH();
    antlr4::tree::TerminalNode *SIN();
    antlr4::tree::TerminalNode *SKIP_EXT_OPTIMIZER();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *SKIP_UNQ_UNUSABLE_IDX();
    antlr4::tree::TerminalNode *SKIP_UNUSABLE_INDEXES();
    antlr4::tree::TerminalNode *SMALLFILE();
    antlr4::tree::TerminalNode *SNAPSHOT();
    antlr4::tree::TerminalNode *SOME();
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *SOUNDEX();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *SPECIFICATION();
    antlr4::tree::TerminalNode *SPFILE();
    antlr4::tree::TerminalNode *SPLIT();
    antlr4::tree::TerminalNode *SPREADSHEET();
    antlr4::tree::TerminalNode *SQLLDR();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *SQL_TRACE();
    antlr4::tree::TerminalNode *SQRT();
    antlr4::tree::TerminalNode *STALE();
    antlr4::tree::TerminalNode *STANDALONE();
    antlr4::tree::TerminalNode *STANDBY_MAX_DATA_DELAY();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *STAR();
    antlr4::tree::TerminalNode *STAR_TRANSFORMATION();
    antlr4::tree::TerminalNode *STARTUP();
    antlr4::tree::TerminalNode *STATEMENT_ID();
    antlr4::tree::TerminalNode *STATEMENT_QUEUING();
    antlr4::tree::TerminalNode *STATEMENTS();
    antlr4::tree::TerminalNode *STATIC();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *STATS_BINOMIAL_TEST();
    antlr4::tree::TerminalNode *STATS_CROSSTAB();
    antlr4::tree::TerminalNode *STATS_F_TEST();
    antlr4::tree::TerminalNode *STATS_KS_TEST();
    antlr4::tree::TerminalNode *STATS_MODE();
    antlr4::tree::TerminalNode *STATS_MW_TEST();
    antlr4::tree::TerminalNode *STATS_ONE_WAY_ANOVA();
    antlr4::tree::TerminalNode *STATS_T_TEST_INDEP();
    antlr4::tree::TerminalNode *STATS_T_TEST_INDEPU();
    antlr4::tree::TerminalNode *STATS_T_TEST_ONE();
    antlr4::tree::TerminalNode *STATS_T_TEST_PAIRED();
    antlr4::tree::TerminalNode *STATS_WSR_TEST();
    antlr4::tree::TerminalNode *STDDEV();
    antlr4::tree::TerminalNode *STDDEV_POP();
    antlr4::tree::TerminalNode *STDDEV_SAMP();
    antlr4::tree::TerminalNode *STOP();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *STREAMS();
    antlr4::tree::TerminalNode *STRICT();
    antlr4::tree::TerminalNode *STRING();
    antlr4::tree::TerminalNode *STRIPE_COLUMNS();
    antlr4::tree::TerminalNode *STRIPE_WIDTH();
    antlr4::tree::TerminalNode *STRIP();
    antlr4::tree::TerminalNode *STRUCTURE();
    antlr4::tree::TerminalNode *SUBMULTISET();
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *SUBPARTITION_REL();
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    antlr4::tree::TerminalNode *SUBQUERIES();
    antlr4::tree::TerminalNode *SUBQUERY_PRUNING();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *SUBSTR2();
    antlr4::tree::TerminalNode *SUBSTR4();
    antlr4::tree::TerminalNode *SUBSTRB();
    antlr4::tree::TerminalNode *SUBSTRC();
    antlr4::tree::TerminalNode *SUBSTR();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    antlr4::tree::TerminalNode *SUMMARY();
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *SUPPLEMENTAL();
    antlr4::tree::TerminalNode *SUSPEND();
    antlr4::tree::TerminalNode *SWAP_JOIN_INPUTS();
    antlr4::tree::TerminalNode *SWITCH();
    antlr4::tree::TerminalNode *SWITCHOVER();
    antlr4::tree::TerminalNode *SYNCHRONOUS();
    antlr4::tree::TerminalNode *SYNC();
    antlr4::tree::TerminalNode *SYSASM();
    antlr4::tree::TerminalNode *SYS_AUDIT();
    antlr4::tree::TerminalNode *SYSAUX();
    antlr4::tree::TerminalNode *SYS_CHECKACL();
    antlr4::tree::TerminalNode *SYS_CONNECT_BY_PATH();
    antlr4::tree::TerminalNode *SYS_CONTEXT();
    antlr4::tree::TerminalNode *SYSDATE();
    antlr4::tree::TerminalNode *SYSDBA();
    antlr4::tree::TerminalNode *SYS_DBURIGEN();
    antlr4::tree::TerminalNode *SYS_DL_CURSOR();
    antlr4::tree::TerminalNode *SYS_DM_RXFORM_CHR();
    antlr4::tree::TerminalNode *SYS_DM_RXFORM_NUM();
    antlr4::tree::TerminalNode *SYS_DOM_COMPARE();
    antlr4::tree::TerminalNode *SYS_DST_PRIM2SEC();
    antlr4::tree::TerminalNode *SYS_DST_SEC2PRIM();
    antlr4::tree::TerminalNode *SYS_ET_BFILE_TO_RAW();
    antlr4::tree::TerminalNode *SYS_ET_BLOB_TO_IMAGE();
    antlr4::tree::TerminalNode *SYS_ET_IMAGE_TO_BLOB();
    antlr4::tree::TerminalNode *SYS_ET_RAW_TO_BFILE();
    antlr4::tree::TerminalNode *SYS_EXTPDTXT();
    antlr4::tree::TerminalNode *SYS_EXTRACT_UTC();
    antlr4::tree::TerminalNode *SYS_FBT_INSDEL();
    antlr4::tree::TerminalNode *SYS_FILTER_ACLS();
    antlr4::tree::TerminalNode *SYS_FNMATCHES();
    antlr4::tree::TerminalNode *SYS_FNREPLACE();
    antlr4::tree::TerminalNode *SYS_GET_ACLIDS();
    antlr4::tree::TerminalNode *SYS_GET_PRIVILEGES();
    antlr4::tree::TerminalNode *SYS_GETTOKENID();
    antlr4::tree::TerminalNode *SYS_GETXTIVAL();
    antlr4::tree::TerminalNode *SYS_GUID();
    antlr4::tree::TerminalNode *SYS_MAKEXML();
    antlr4::tree::TerminalNode *SYS_MAKE_XMLNODEID();
    antlr4::tree::TerminalNode *SYS_MKXMLATTR();
    antlr4::tree::TerminalNode *SYS_OP_ADT2BIN();
    antlr4::tree::TerminalNode *SYS_OP_ADTCONS();
    antlr4::tree::TerminalNode *SYS_OP_ALSCRVAL();
    antlr4::tree::TerminalNode *SYS_OP_ATG();
    antlr4::tree::TerminalNode *SYS_OP_BIN2ADT();
    antlr4::tree::TerminalNode *SYS_OP_BITVEC();
    antlr4::tree::TerminalNode *SYS_OP_BL2R();
    antlr4::tree::TerminalNode *SYS_OP_BLOOM_FILTER_LIST();
    antlr4::tree::TerminalNode *SYS_OP_BLOOM_FILTER();
    antlr4::tree::TerminalNode *SYS_OP_C2C();
    antlr4::tree::TerminalNode *SYS_OP_CAST();
    antlr4::tree::TerminalNode *SYS_OP_CEG();
    antlr4::tree::TerminalNode *SYS_OP_CL2C();
    antlr4::tree::TerminalNode *SYS_OP_COMBINED_HASH();
    antlr4::tree::TerminalNode *SYS_OP_COMP();
    antlr4::tree::TerminalNode *SYS_OP_CONVERT();
    antlr4::tree::TerminalNode *SYS_OP_COUNTCHG();
    antlr4::tree::TerminalNode *SYS_OP_CSCONV();
    antlr4::tree::TerminalNode *SYS_OP_CSCONVTEST();
    antlr4::tree::TerminalNode *SYS_OP_CSR();
    antlr4::tree::TerminalNode *SYS_OP_CSX_PATCH();
    antlr4::tree::TerminalNode *SYS_OP_DECOMP();
    antlr4::tree::TerminalNode *SYS_OP_DESCEND();
    antlr4::tree::TerminalNode *SYS_OP_DISTINCT();
    antlr4::tree::TerminalNode *SYS_OP_DRA();
    antlr4::tree::TerminalNode *SYS_OP_DUMP();
    antlr4::tree::TerminalNode *SYS_OP_DV_CHECK();
    antlr4::tree::TerminalNode *SYS_OP_ENFORCE_NOT_NULL();
    antlr4::tree::TerminalNode *SYSOPER();
    antlr4::tree::TerminalNode *SYS_OP_EXTRACT();
    antlr4::tree::TerminalNode *SYS_OP_GROUPING();
    antlr4::tree::TerminalNode *SYS_OP_GUID();
    antlr4::tree::TerminalNode *SYS_OP_IIX();
    antlr4::tree::TerminalNode *SYS_OP_ITR();
    antlr4::tree::TerminalNode *SYS_OP_LBID();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2BLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2CLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2ID();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2NCLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2TYP();
    antlr4::tree::TerminalNode *SYS_OP_LSVI();
    antlr4::tree::TerminalNode *SYS_OP_LVL();
    antlr4::tree::TerminalNode *SYS_OP_MAKEOID();
    antlr4::tree::TerminalNode *SYS_OP_MAP_NONNULL();
    antlr4::tree::TerminalNode *SYS_OP_MSR();
    antlr4::tree::TerminalNode *SYS_OP_NICOMBINE();
    antlr4::tree::TerminalNode *SYS_OP_NIEXTRACT();
    antlr4::tree::TerminalNode *SYS_OP_NII();
    antlr4::tree::TerminalNode *SYS_OP_NIX();
    antlr4::tree::TerminalNode *SYS_OP_NOEXPAND();
    antlr4::tree::TerminalNode *SYS_OP_NTCIMG();
    antlr4::tree::TerminalNode *SYS_OP_NUMTORAW();
    antlr4::tree::TerminalNode *SYS_OP_OIDVALUE();
    antlr4::tree::TerminalNode *SYS_OP_OPNSIZE();
    antlr4::tree::TerminalNode *SYS_OP_PAR_1();
    antlr4::tree::TerminalNode *SYS_OP_PARGID_1();
    antlr4::tree::TerminalNode *SYS_OP_PARGID();
    antlr4::tree::TerminalNode *SYS_OP_PAR();
    antlr4::tree::TerminalNode *SYS_OP_PIVOT();
    antlr4::tree::TerminalNode *SYS_OP_R2O();
    antlr4::tree::TerminalNode *SYS_OP_RAWTONUM();
    antlr4::tree::TerminalNode *SYS_OP_RDTM();
    antlr4::tree::TerminalNode *SYS_OP_REF();
    antlr4::tree::TerminalNode *SYS_OP_RMTD();
    antlr4::tree::TerminalNode *SYS_OP_ROWIDTOOBJ();
    antlr4::tree::TerminalNode *SYS_OP_RPB();
    antlr4::tree::TerminalNode *SYS_OPTLOBPRBSC();
    antlr4::tree::TerminalNode *SYS_OP_TOSETID();
    antlr4::tree::TerminalNode *SYS_OP_TPR();
    antlr4::tree::TerminalNode *SYS_OP_TRTB();
    antlr4::tree::TerminalNode *SYS_OPTXICMP();
    antlr4::tree::TerminalNode *SYS_OPTXQCASTASNQ();
    antlr4::tree::TerminalNode *SYS_OP_UNDESCEND();
    antlr4::tree::TerminalNode *SYS_OP_VECAND();
    antlr4::tree::TerminalNode *SYS_OP_VECBIT();
    antlr4::tree::TerminalNode *SYS_OP_VECOR();
    antlr4::tree::TerminalNode *SYS_OP_VECXOR();
    antlr4::tree::TerminalNode *SYS_OP_VERSION();
    antlr4::tree::TerminalNode *SYS_OP_VREF();
    antlr4::tree::TerminalNode *SYS_OP_VVD();
    antlr4::tree::TerminalNode *SYS_OP_XMLCONS_FOR_CSX();
    antlr4::tree::TerminalNode *SYS_OP_XPTHATG();
    antlr4::tree::TerminalNode *SYS_OP_XPTHIDX();
    antlr4::tree::TerminalNode *SYS_OP_XPTHOP();
    antlr4::tree::TerminalNode *SYS_OP_XTXT2SQLT();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_DEPTH();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_MAXCHILD();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_PARENT();
    antlr4::tree::TerminalNode *SYS_PARALLEL_TXN();
    antlr4::tree::TerminalNode *SYS_PATHID_IS_ATTR();
    antlr4::tree::TerminalNode *SYS_PATHID_IS_NMSPC();
    antlr4::tree::TerminalNode *SYS_PATHID_LASTNAME();
    antlr4::tree::TerminalNode *SYS_PATHID_LASTNMSPC();
    antlr4::tree::TerminalNode *SYS_PATH_REVERSE();
    antlr4::tree::TerminalNode *SYS_PXQEXTRACT();
    antlr4::tree::TerminalNode *SYS_RID_ORDER();
    antlr4::tree::TerminalNode *SYS_ROW_DELTA();
    antlr4::tree::TerminalNode *SYS_SC_2_XMLT();
    antlr4::tree::TerminalNode *SYS_SYNRCIREDO();
    antlr4::tree::TerminalNode *SYSTEM_DEFINED();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *SYSTIMESTAMP();
    antlr4::tree::TerminalNode *SYS_TYPEID();
    antlr4::tree::TerminalNode *SYS_UMAKEXML();
    antlr4::tree::TerminalNode *SYS_XMLANALYZE();
    antlr4::tree::TerminalNode *SYS_XMLCONTAINS();
    antlr4::tree::TerminalNode *SYS_XMLCONV();
    antlr4::tree::TerminalNode *SYS_XMLEXNSURI();
    antlr4::tree::TerminalNode *SYS_XMLGEN();
    antlr4::tree::TerminalNode *SYS_XMLI_LOC_ISNODE();
    antlr4::tree::TerminalNode *SYS_XMLI_LOC_ISTEXT();
    antlr4::tree::TerminalNode *SYS_XMLINSTR();
    antlr4::tree::TerminalNode *SYS_XMLLOCATOR_GETSVAL();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETCID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETLOCATOR();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETOKEY();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETPATHID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETPTRID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETRID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETSVAL();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETTID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID();
    antlr4::tree::TerminalNode *SYS_XMLT_2_SC();
    antlr4::tree::TerminalNode *SYS_XMLTRANSLATE();
    antlr4::tree::TerminalNode *SYS_XMLTYPE2SQL();
    antlr4::tree::TerminalNode *SYS_XQ_ASQLCNV();
    antlr4::tree::TerminalNode *SYS_XQ_ATOMCNVCHK();
    antlr4::tree::TerminalNode *SYS_XQBASEURI();
    antlr4::tree::TerminalNode *SYS_XQCASTABLEERRH();
    antlr4::tree::TerminalNode *SYS_XQCODEP2STR();
    antlr4::tree::TerminalNode *SYS_XQCODEPEQ();
    antlr4::tree::TerminalNode *SYS_XQCON2SEQ();
    antlr4::tree::TerminalNode *SYS_XQCONCAT();
    antlr4::tree::TerminalNode *SYS_XQDELETE();
    antlr4::tree::TerminalNode *SYS_XQDFLTCOLATION();
    antlr4::tree::TerminalNode *SYS_XQDOC();
    antlr4::tree::TerminalNode *SYS_XQDOCURI();
    antlr4::tree::TerminalNode *SYS_XQDURDIV();
    antlr4::tree::TerminalNode *SYS_XQED4URI();
    antlr4::tree::TerminalNode *SYS_XQENDSWITH();
    antlr4::tree::TerminalNode *SYS_XQERRH();
    antlr4::tree::TerminalNode *SYS_XQERR();
    antlr4::tree::TerminalNode *SYS_XQESHTMLURI();
    antlr4::tree::TerminalNode *SYS_XQEXLOBVAL();
    antlr4::tree::TerminalNode *SYS_XQEXSTWRP();
    antlr4::tree::TerminalNode *SYS_XQEXTRACT();
    antlr4::tree::TerminalNode *SYS_XQEXTRREF();
    antlr4::tree::TerminalNode *SYS_XQEXVAL();
    antlr4::tree::TerminalNode *SYS_XQFB2STR();
    antlr4::tree::TerminalNode *SYS_XQFNBOOL();
    antlr4::tree::TerminalNode *SYS_XQFNCMP();
    antlr4::tree::TerminalNode *SYS_XQFNDATIM();
    antlr4::tree::TerminalNode *SYS_XQFNLNAME();
    antlr4::tree::TerminalNode *SYS_XQFNNM();
    antlr4::tree::TerminalNode *SYS_XQFNNSURI();
    antlr4::tree::TerminalNode *SYS_XQFNPREDTRUTH();
    antlr4::tree::TerminalNode *SYS_XQFNQNM();
    antlr4::tree::TerminalNode *SYS_XQFNROOT();
    antlr4::tree::TerminalNode *SYS_XQFORMATNUM();
    antlr4::tree::TerminalNode *SYS_XQFTCONTAIN();
    antlr4::tree::TerminalNode *SYS_XQFUNCR();
    antlr4::tree::TerminalNode *SYS_XQGETCONTENT();
    antlr4::tree::TerminalNode *SYS_XQINDXOF();
    antlr4::tree::TerminalNode *SYS_XQINSERT();
    antlr4::tree::TerminalNode *SYS_XQINSPFX();
    antlr4::tree::TerminalNode *SYS_XQIRI2URI();
    antlr4::tree::TerminalNode *SYS_XQLANG();
    antlr4::tree::TerminalNode *SYS_XQLLNMFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQMKNODEREF();
    antlr4::tree::TerminalNode *SYS_XQNILLED();
    antlr4::tree::TerminalNode *SYS_XQNODENAME();
    antlr4::tree::TerminalNode *SYS_XQNORMSPACE();
    antlr4::tree::TerminalNode *SYS_XQNORMUCODE();
    antlr4::tree::TerminalNode *SYS_XQ_NRNG();
    antlr4::tree::TerminalNode *SYS_XQNSP4PFX();
    antlr4::tree::TerminalNode *SYS_XQNSPFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQPFXFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQ_PKSQL2XML();
    antlr4::tree::TerminalNode *SYS_XQPOLYABS();
    antlr4::tree::TerminalNode *SYS_XQPOLYADD();
    antlr4::tree::TerminalNode *SYS_XQPOLYCEL();
    antlr4::tree::TerminalNode *SYS_XQPOLYCSTBL();
    antlr4::tree::TerminalNode *SYS_XQPOLYCST();
    antlr4::tree::TerminalNode *SYS_XQPOLYDIV();
    antlr4::tree::TerminalNode *SYS_XQPOLYFLR();
    antlr4::tree::TerminalNode *SYS_XQPOLYMOD();
    antlr4::tree::TerminalNode *SYS_XQPOLYMUL();
    antlr4::tree::TerminalNode *SYS_XQPOLYRND();
    antlr4::tree::TerminalNode *SYS_XQPOLYSQRT();
    antlr4::tree::TerminalNode *SYS_XQPOLYSUB();
    antlr4::tree::TerminalNode *SYS_XQPOLYUMUS();
    antlr4::tree::TerminalNode *SYS_XQPOLYUPLS();
    antlr4::tree::TerminalNode *SYS_XQPOLYVEQ();
    antlr4::tree::TerminalNode *SYS_XQPOLYVGE();
    antlr4::tree::TerminalNode *SYS_XQPOLYVGT();
    antlr4::tree::TerminalNode *SYS_XQPOLYVLE();
    antlr4::tree::TerminalNode *SYS_XQPOLYVLT();
    antlr4::tree::TerminalNode *SYS_XQPOLYVNE();
    antlr4::tree::TerminalNode *SYS_XQREF2VAL();
    antlr4::tree::TerminalNode *SYS_XQRENAME();
    antlr4::tree::TerminalNode *SYS_XQREPLACE();
    antlr4::tree::TerminalNode *SYS_XQRESVURI();
    antlr4::tree::TerminalNode *SYS_XQRNDHALF2EVN();
    antlr4::tree::TerminalNode *SYS_XQRSLVQNM();
    antlr4::tree::TerminalNode *SYS_XQRYENVPGET();
    antlr4::tree::TerminalNode *SYS_XQRYVARGET();
    antlr4::tree::TerminalNode *SYS_XQRYWRP();
    antlr4::tree::TerminalNode *SYS_XQSEQ2CON4XC();
    antlr4::tree::TerminalNode *SYS_XQSEQ2CON();
    antlr4::tree::TerminalNode *SYS_XQSEQDEEPEQ();
    antlr4::tree::TerminalNode *SYS_XQSEQINSB();
    antlr4::tree::TerminalNode *SYS_XQSEQRM();
    antlr4::tree::TerminalNode *SYS_XQSEQRVS();
    antlr4::tree::TerminalNode *SYS_XQSEQSUB();
    antlr4::tree::TerminalNode *SYS_XQSEQTYPMATCH();
    antlr4::tree::TerminalNode *SYS_XQSTARTSWITH();
    antlr4::tree::TerminalNode *SYS_XQSTATBURI();
    antlr4::tree::TerminalNode *SYS_XQSTR2CODEP();
    antlr4::tree::TerminalNode *SYS_XQSTRJOIN();
    antlr4::tree::TerminalNode *SYS_XQSUBSTRAFT();
    antlr4::tree::TerminalNode *SYS_XQSUBSTRBEF();
    antlr4::tree::TerminalNode *SYS_XQTOKENIZE();
    antlr4::tree::TerminalNode *SYS_XQTREATAS();
    antlr4::tree::TerminalNode *SYS_XQ_UPKXML2SQL();
    antlr4::tree::TerminalNode *SYS_XQXFORM();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *TABLE_LOOKUP_BY_NL();
    antlr4::tree::TerminalNode *TABLES();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *TABLESPACE_NO();
    antlr4::tree::TerminalNode *TABLE_STATS();
    antlr4::tree::TerminalNode *TABNO();
    antlr4::tree::TerminalNode *TANH();
    antlr4::tree::TerminalNode *TAN();
    antlr4::tree::TerminalNode *TBLORIDXPARTNUM();
    antlr4::tree::TerminalNode *TEMPFILE();
    antlr4::tree::TerminalNode *TEMPLATE();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *TEMP_TABLE();
    antlr4::tree::TerminalNode *TEST();
    antlr4::tree::TerminalNode *THAN();
    antlr4::tree::TerminalNode *THE();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *THREAD();
    antlr4::tree::TerminalNode *THROUGH();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *TIMEOUT();
    antlr4::tree::TerminalNode *TIMES();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *TIMEZONE_ABBR();
    antlr4::tree::TerminalNode *TIMEZONE_HOUR();
    antlr4::tree::TerminalNode *TIMEZONE_MINUTE();
    antlr4::tree::TerminalNode *TIME_ZONE();
    antlr4::tree::TerminalNode *TIMEZONE_OFFSET();
    antlr4::tree::TerminalNode *TIMEZONE_REGION();
    antlr4::tree::TerminalNode *TIV_GB();
    antlr4::tree::TerminalNode *TIV_SSF();
    antlr4::tree::TerminalNode *TO_BINARY_DOUBLE();
    antlr4::tree::TerminalNode *TO_BINARY_FLOAT();
    antlr4::tree::TerminalNode *TO_BLOB();
    antlr4::tree::TerminalNode *TO_CHAR();
    antlr4::tree::TerminalNode *TO_CLOB();
    antlr4::tree::TerminalNode *TO_DATE();
    antlr4::tree::TerminalNode *TO_DSINTERVAL();
    antlr4::tree::TerminalNode *TO_LOB();
    antlr4::tree::TerminalNode *TO_MULTI_BYTE();
    antlr4::tree::TerminalNode *TO_NCHAR();
    antlr4::tree::TerminalNode *TO_NCLOB();
    antlr4::tree::TerminalNode *TO_NUMBER();
    antlr4::tree::TerminalNode *TOPLEVEL();
    antlr4::tree::TerminalNode *TO_SINGLE_BYTE();
    antlr4::tree::TerminalNode *TO_TIME();
    antlr4::tree::TerminalNode *TO_TIMESTAMP();
    antlr4::tree::TerminalNode *TO_TIMESTAMP_TZ();
    antlr4::tree::TerminalNode *TO_TIME_TZ();
    antlr4::tree::TerminalNode *TO_YMINTERVAL();
    antlr4::tree::TerminalNode *TRACE();
    antlr4::tree::TerminalNode *TRACING();
    antlr4::tree::TerminalNode *TRACKING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *TRANSFORM_DISTINCT_AGG();
    antlr4::tree::TerminalNode *TRANSITIONAL();
    antlr4::tree::TerminalNode *TRANSITION();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *TREAT();
    antlr4::tree::TerminalNode *TRIGGERS();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *TRUE();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *TRUNC();
    antlr4::tree::TerminalNode *TRUSTED();
    antlr4::tree::TerminalNode *TUNING();
    antlr4::tree::TerminalNode *TX();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *TYPES();
    antlr4::tree::TerminalNode *TZ_OFFSET();
    antlr4::tree::TerminalNode *UB2();
    antlr4::tree::TerminalNode *UBA();
    antlr4::tree::TerminalNode *UID();
    antlr4::tree::TerminalNode *UNARCHIVED();
    antlr4::tree::TerminalNode *UNBOUNDED();
    antlr4::tree::TerminalNode *UNBOUND();
    antlr4::tree::TerminalNode *UNDER();
    antlr4::tree::TerminalNode *UNDO();
    antlr4::tree::TerminalNode *UNDROP();
    antlr4::tree::TerminalNode *UNIFORM();
    antlr4::tree::TerminalNode *UNISTR();
    antlr4::tree::TerminalNode *UNLIMITED();
    antlr4::tree::TerminalNode *UNLOAD();
    antlr4::tree::TerminalNode *UNLOCK();
    antlr4::tree::TerminalNode *UNNEST_INNERJ_DISTINCT_VIEW();
    antlr4::tree::TerminalNode *UNNEST();
    antlr4::tree::TerminalNode *UNNEST_NOSEMIJ_NODISTINCTVIEW();
    antlr4::tree::TerminalNode *UNNEST_SEMIJ_VIEW();
    antlr4::tree::TerminalNode *UNPACKED();
    antlr4::tree::TerminalNode *UNPIVOT();
    antlr4::tree::TerminalNode *UNPROTECTED();
    antlr4::tree::TerminalNode *UNQUIESCE();
    antlr4::tree::TerminalNode *UNRECOVERABLE();
    antlr4::tree::TerminalNode *UNRESTRICTED();
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *UNUSABLE();
    antlr4::tree::TerminalNode *UNUSED();
    antlr4::tree::TerminalNode *UPDATABLE();
    antlr4::tree::TerminalNode *UPDATED();
    antlr4::tree::TerminalNode *UPDATEXML();
    antlr4::tree::TerminalNode *UPD_INDEXES();
    antlr4::tree::TerminalNode *UPD_JOININDEX();
    antlr4::tree::TerminalNode *UPGRADE();
    antlr4::tree::TerminalNode *UPPER();
    antlr4::tree::TerminalNode *UPSERT();
    antlr4::tree::TerminalNode *UROWID();
    antlr4::tree::TerminalNode *USAGE();
    antlr4::tree::TerminalNode *USE_ANTI();
    antlr4::tree::TerminalNode *USE_CONCAT();
    antlr4::tree::TerminalNode *USE_HASH_AGGREGATION();
    antlr4::tree::TerminalNode *USE_HASH_GBY_FOR_PUSHDOWN();
    antlr4::tree::TerminalNode *USE_HASH();
    antlr4::tree::TerminalNode *USE_INVISIBLE_INDEXES();
    antlr4::tree::TerminalNode *USE_MERGE_CARTESIAN();
    antlr4::tree::TerminalNode *USE_MERGE();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *USE_NL();
    antlr4::tree::TerminalNode *USE_NL_WITH_INDEX();
    antlr4::tree::TerminalNode *USE_PRIVATE_OUTLINES();
    antlr4::tree::TerminalNode *USER_DEFINED();
    antlr4::tree::TerminalNode *USERENV();
    antlr4::tree::TerminalNode *USERGROUP();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *USER_RECYCLEBIN();
    antlr4::tree::TerminalNode *USERS();
    antlr4::tree::TerminalNode *USE_SEMI();
    antlr4::tree::TerminalNode *USE_STORED_OUTLINES();
    antlr4::tree::TerminalNode *USE_TTT_FOR_GSETS();
    antlr4::tree::TerminalNode *USE_WEAK_NAME_RESL();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *VALIDATE();
    antlr4::tree::TerminalNode *VALIDATION();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *VARIANCE();
    antlr4::tree::TerminalNode *VAR_POP();
    antlr4::tree::TerminalNode *VARRAY();
    antlr4::tree::TerminalNode *VARRAYS();
    antlr4::tree::TerminalNode *VAR_SAMP();
    antlr4::tree::TerminalNode *VARYING();
    antlr4::tree::TerminalNode *VECTOR_READ();
    antlr4::tree::TerminalNode *VECTOR_READ_TRACE();
    antlr4::tree::TerminalNode *VERIFY();
    antlr4::tree::TerminalNode *VERSIONING();
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *VERSIONS_ENDSCN();
    antlr4::tree::TerminalNode *VERSIONS_ENDTIME();
    antlr4::tree::TerminalNode *VERSIONS();
    antlr4::tree::TerminalNode *VERSIONS_OPERATION();
    antlr4::tree::TerminalNode *VERSIONS_STARTSCN();
    antlr4::tree::TerminalNode *VERSIONS_STARTTIME();
    antlr4::tree::TerminalNode *VERSIONS_XID();
    antlr4::tree::TerminalNode *VIRTUAL();
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *VOLUME();
    antlr4::tree::TerminalNode *VSIZE();
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *WALLET();
    antlr4::tree::TerminalNode *WELLFORMED();
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *WHITESPACE();
    antlr4::tree::TerminalNode *WIDTH_BUCKET();
    antlr4::tree::TerminalNode *WITHIN();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *WORK();
    antlr4::tree::TerminalNode *WRAPPED();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *XDB_FASTPATH_INSERT();
    antlr4::tree::TerminalNode *X_DYN_PRUNE();
    antlr4::tree::TerminalNode *XID();
    antlr4::tree::TerminalNode *XML2OBJECT();
    antlr4::tree::TerminalNode *XMLATTRIBUTES();
    antlr4::tree::TerminalNode *XMLCAST();
    antlr4::tree::TerminalNode *XMLCDATA();
    antlr4::tree::TerminalNode *XMLCOLATTVAL();
    antlr4::tree::TerminalNode *XMLCOMMENT();
    antlr4::tree::TerminalNode *XMLCONCAT();
    antlr4::tree::TerminalNode *XMLDIFF();
    antlr4::tree::TerminalNode *XML_DML_RWT_STMT();
    antlr4::tree::TerminalNode *XMLELEMENT();
    antlr4::tree::TerminalNode *XMLEXISTS2();
    antlr4::tree::TerminalNode *XMLEXISTS();
    antlr4::tree::TerminalNode *XMLFOREST();
    antlr4::tree::TerminalNode *XMLINDEX_REWRITE_IN_SELECT();
    antlr4::tree::TerminalNode *XMLINDEX_REWRITE();
    antlr4::tree::TerminalNode *XMLINDEX_SEL_IDX_TBL();
    antlr4::tree::TerminalNode *XMLISNODE();
    antlr4::tree::TerminalNode *XMLISVALID();
    antlr4::tree::TerminalNode *XML();
    antlr4::tree::TerminalNode *XMLNAMESPACES();
    antlr4::tree::TerminalNode *XMLPARSE();
    antlr4::tree::TerminalNode *XMLPATCH();
    antlr4::tree::TerminalNode *XMLPI();
    antlr4::tree::TerminalNode *XMLQUERY();
    antlr4::tree::TerminalNode *XMLQUERYVAL();
    antlr4::tree::TerminalNode *XMLROOT();
    antlr4::tree::TerminalNode *XMLSCHEMA();
    antlr4::tree::TerminalNode *XMLSERIALIZE();
    antlr4::tree::TerminalNode *XMLTABLE();
    antlr4::tree::TerminalNode *XMLTRANSFORMBLOB();
    antlr4::tree::TerminalNode *XMLTRANSFORM();
    antlr4::tree::TerminalNode *XMLTYPE();
    antlr4::tree::TerminalNode *XPATHTABLE();
    antlr4::tree::TerminalNode *XS_SYS_CONTEXT();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *YES();
    antlr4::tree::TerminalNode *ZONE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_reserved_keywords_pre12cContext* non_reserved_keywords_pre12c();

  class  String_function_nameContext : public antlr4::ParserRuleContext {
  public:
    String_function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHR();
    antlr4::tree::TerminalNode *DECODE();
    antlr4::tree::TerminalNode *SUBSTR();
    antlr4::tree::TerminalNode *TO_CHAR();
    antlr4::tree::TerminalNode *TRIM();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  String_function_nameContext* string_function_name();

  class  Numeric_function_nameContext : public antlr4::ParserRuleContext {
  public:
    Numeric_function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *NVL();
    antlr4::tree::TerminalNode *ROUND();
    antlr4::tree::TerminalNode *SUM();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_function_nameContext* numeric_function_name();


  virtual bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;
  bool unified_auditingSempred(Unified_auditingContext *_localctx, size_t predicateIndex);
  bool audit_direct_pathSempred(Audit_direct_pathContext *_localctx, size_t predicateIndex);
  bool audit_container_clauseSempred(Audit_container_clauseContext *_localctx, size_t predicateIndex);
  bool auditing_on_clauseSempred(Auditing_on_clauseContext *_localctx, size_t predicateIndex);
  bool sql_statement_shortcutSempred(Sql_statement_shortcutContext *_localctx, size_t predicateIndex);
  bool library_editionableSempred(Library_editionableContext *_localctx, size_t predicateIndex);
  bool library_debugSempred(Library_debugContext *_localctx, size_t predicateIndex);
  bool alter_view_editionableSempred(Alter_view_editionableContext *_localctx, size_t predicateIndex);
  bool partial_database_recovery_10gSempred(Partial_database_recovery_10gContext *_localctx, size_t predicateIndex);
  bool period_definitionSempred(Period_definitionContext *_localctx, size_t predicateIndex);
  bool logical_expressionSempred(Logical_expressionContext *_localctx, size_t predicateIndex);
  bool relational_expressionSempred(Relational_expressionContext *_localctx, size_t predicateIndex);
  bool concatenationSempred(ConcatenationContext *_localctx, size_t predicateIndex);

private:
  static std::vector<antlr4::dfa::DFA> _decisionToDFA;
  static antlr4::atn::PredictionContextCache _sharedContextCache;
  static std::vector<std::string> _ruleNames;
  static std::vector<std::string> _tokenNames;

  static std::vector<std::string> _literalNames;
  static std::vector<std::string> _symbolicNames;
  static antlr4::dfa::Vocabulary _vocabulary;
  static antlr4::atn::ATN _atn;
  static std::vector<uint16_t> _serializedATN;


  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};

}  // namespace oracle
