示例
--插入记录。
INSERT INTO customer_demographics_t1 VALUES(1920801,'M', 'U', 'DOCTOR DEGREE', 200, 'GOOD', 1,
0,0);
--开启事务。
START TRANSACTION;
--更新字段值。
UPDATE customer_demographics_t1 SET cd_education_status= 'Unknown';
--终止事务,上面所执行的更新会被撤销掉。
ABORT;
--查询数据。
SELECT * FROM customer_demographics_t1 WHERE cd_demo_sk = 1920801;

示例
-- 创建一个资源池,其控制组指定为"DefaultClass"组下属的"High" Timeshare Workload控制组。
CREATE RESOURCE POOL pool1 WITH (CONTROL_GROUP="High");
-- 创建一个负载组,关联已创建的资源池。
CREATE WORKLOAD GROUP wg_hr1 USING RESOURCE POOL pool1;
--创建一个默认应用映射组,关联默认的负载组。
CREATE APP WORKLOAD GROUP MAPPING app_wg_map1;
-- 更新一个应用映射组关联的负载组名称。
ALTER APP WORKLOAD GROUP MAPPING app_wg_map1 WITH(WORKLOAD_GPNAME=wg_hr1);
--删除应用映射组。
DROP APP WORKLOAD GROUP MAPPING app_wg_map1;
--删除负载组。
DROP WORKLOAD GROUP wg_hr1;
--删除资源池。
DROP RESOURCE POOL pool1;

示例
--创建一个空Data Source对象。
CREATE DATA SOURCE ds_test1;
--修改名字。
ALTER DATA SOURCE ds_test1 RENAME TO ds_test;
--修改属主。
CREATE USER user_test1 IDENTIFIED BY 'Gs@123456';
ALTER USER user_test1 WITH SYSADMIN;
ALTER DATA SOURCE ds_test OWNER TO user_test1;
--修改TYPE和VERSION。
ALTER DATA SOURCE ds_test TYPE 'MPPDB_TYPE' VERSION 'XXX';
--添加字段。
ALTER DATA SOURCE ds_test OPTIONS (add dsn 'mppdb', username 'test_user');
--修改字段。
ALTER DATA SOURCE ds_test OPTIONS (set dsn 'unknown');
--删除字段。
ALTER DATA SOURCE ds_test OPTIONS (drop username);
--删除Data Source和user对象。
DROP DATA SOURCE ds_test;
DROP USER user_test1;

示例
--将创建在模式tpcds里的所有表(和视图)的SELECT权限授予每一个用户。
ALTER DEFAULT PRIVILEGES IN SCHEMA tpcds GRANT SELECT ON TABLES TO PUBLIC;
--创建用户普通用户jack。
CREATE USER jack PASSWORD 'Bigdata123@';
--将tpcds下的所有表的插入权限授予用户jack。
ALTER DEFAULT PRIVILEGES IN SCHEMA tpcds GRANT INSERT ON TABLES TO jack;
--撤销上述权限。
ALTER DEFAULT PRIVILEGES IN SCHEMA tpcds REVOKE SELECT ON TABLES FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA tpcds REVOKE INSERT ON TABLES FROM jack;
--删除用户jack。
DROP USER jack;

示例
--创建目录。
CREATE OR REPLACE DIRECTORY
dir
as '/tmp/';
--修改目录的owner。
ALTER DIRECTORY dir OWNER TO system;
--删除外部表。
DROP DIRECTORY dir;

示例
--修改外表属性,删除mode选项。
ALTER FOREIGN TABLE tpcds.customer_ft options(drop mode);
--删除外部表。
DROP FOREIGN TABLE tpcds.customer_ft;
相关链接
16.14.50 CREATE FOREIGN TABLE (导入导出),16.14.84 DROP FOREIGN TABLE
16.14.8 ALTER FOREIGN TABLE (SQL on Hadoop)
功能描述
用于对HDFS外表进行修改。
注意事项
无。
语法格式
l
设置外表属性
ALTER FOREIGN TABLE [ IF EXISTS ] table_name
OPTIONS ( {[ ADD | SET | DROP ] option ['value']} [, ... ]);
l
设置外表的所有者。
ALTER FOREIGN TABLE [ IF EXISTS ] tablename
OWNER TO new_owner;
l
修改外表的列。
ALTER FOREIGN TABLE [ IF EXISTS ] tablename
action [, ... ];
其中action语法为。
ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type
| ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL
| ALTER [ COLUMN ] column_name SET STATISTICS [PERCENT] integer
| ALTER [ COLUMN ] column_name OPTIONS ( {[ ADD | SET | DROP ] option ['value'] }
[, ... ])
参考16.14.24 ALTER TABLE。
l
增加外表信息约束(Informational Constraint)的语法为:
ALTER FOREIGN TABLE [ IF EXISTS ] tablename
ADD [ CONSTRAINT constraint_name ]
{ PRIMARY KEY | UNIQUE } ( column_name )
[ NOT ENFORCED [ ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION ] | ENFORCED ];
对于增加外表信息约束(Informational Constraint)相关参数请参考CREATE
FOREIGN TABLE (For HDFS)的参数说明。
l
删除外表的信息约束(Informational Constraint)语法为:
ALTER FOREIGN TABLE [ IF EXISTS ] tablename
DROP CONSTRAINT constraint_name ;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
719GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
IF EXISTS
如果不存在相同名称的表,不会抛出一个错误,而会发出一个通知,告知表不存
在。
l
tablename
需要修改的外表名称。
取值范围:已存在的外表名。
l
new_owner
外表的新所有者。
取值范围:字符串,有效的用户名。
l
data_type
现存字段的新类型。
取值范围:字符串,要符合标识符的命名规范
l
constraint_name
要添加/删除的约束的名称。
l
column_name
现存字段的名称。
取值范围:字符串,要符合标识符的命名规范。
修改外表语法中其他参数如IF EXISTS,请参见ALTER TABLE的参数说明。
示例
请参见CREATE FOREIGN TABLE (For HDFS)的示例。
相关链接
16.14.51 CREATE FOREIGN TABLE (SQL on Hadoop ),16.14.84 DROP FOREIGN
TABLE
16.14.9 ALTER FOREIGN TABLE (SQL on other GaussDB 200)
功能描述
对协同分析的外表进行修改。
注意事项
无。
语法格式
l
设置外表属性
ALTER FOREIGN TABLE [ IF EXISTS ] tablename
OPTIONS ( {[ SET ] option ['value']} [, ... ]);
l
设置外表的所有者。
ALTER FOREIGN TABLE [ IF EXISTS ] tablename
OWNER TO new_owner;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
720GaussDB 200
开发者指南
16 SQL 参考
l
修改外表的列。
ALTER FOREIGN TABLE [ IF EXISTS ] tablename
action [, ... ];
其中action语法为。
ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type
参考16.14.24 ALTER TABLE。
参数说明
l
IF EXISTS
如果不存在相同名称的表,不会抛出一个错误,而会发出一个通知,告知表不存
在。
l
tablename
需要修改的外表名称。
取值范围:已存在的外表名。
l
new_owner
外表的新所有者。
取值范围:字符串,有效的用户名。
l
data_type
现存字段的新类型。
取值范围:字符串,要符合标识符的命名规范
l
column_name
现存字段的名称。
取值范围:字符串,要符合标识符的命名规范。
修改外表语法中其它参数,请参见ALTER TABLE的参数说明。
示例
请参见CREATE FOREIGN TABLE (SQL on other GaussDB 200)的示例。
相关链接
16.14.84 DROP FOREIGN TABLE,16.14.52 CREATE FOREIGN TABLE (SQL on
other GaussDB 200)
16.14.10 ALTER FUNCTION
功能描述
修改自定义函数的属性。
注意事项
只有该函数的所有者,才有权限执行该命令,系统管理员默认拥有该权限。如果函数
中涉及对临时表相关的操作,则无法使用ALTER FUNCTION。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
721GaussDB 200
开发者指南
16 SQL 参考
语法格式
l
修改自定义函数的附加参数。
ALTER FUNCTION function_name ( [ { [ argmode ] [ argname ] argtype} [, ...] ] )
action [ ... ] [ RESTRICT ];
其中附加参数action子句语法为。
{CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT}
| {IMMUTABLE | STABLE | VOLATILE}
| {SHIPPABLE | NOT SHIPPABLE}
| {NOT FENCED | FENCED}
| [ NOT ] LEAKPROOF
| { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }
| AUTHID { DEFINER | CURRENT_USER }
| COST execution_cost
| ROWS result_rows
| SET configuration_parameter { { TO | = } { value | DEFAULT }| FROM CURRENT}
| RESET {configuration_parameter | ALL}
l
修改自定义函数的名字。
ALTER FUNCTION funname ( [ { [ argmode ] [ argname ] argtype} [, ...] ] )
RENAME TO new_name;
l
修改自定义函数的所属者。
ALTER FUNCTION funname ( [ { [ argmode ] [ argname ] argtype} [, ...] ] )
OWNER TO new_owner;
l
修改自定义函数的模式。
ALTER FUNCTION funname ( [ { [ argmode ] [ argname ] argtype} [, ...] ] )
SET SCHEMA new_schema;
参数说明
l
function_name
要修改的函数名称。
取值范围:已存在的函数名。
l
argmode
标识该参数是输入、输出参数。
取值范围:IN/OUT/IN OUT
l
argname
参数名称。
取值范围:字符串,符合标识符命名规范。
l
argtype
参数类型。
取值范围:有效的类型,请参考16.3 数据类型。
l
CALLED ON NULL INPUT
表明该函数的某些参数是NULL的时候可以按照正常的方式调用。缺省时与指定此
参数的作用相同。
l
RETURNS NULL ON NULL INPUT
STRICT
STRICT用于指定如果函数的某个参数是NULL,此函数总是返回NULL。如果声
明了这个参数,则如果存在NULL参数时不会执行该函数;而只是自动假设一个
NULL结果。
RETURNS NULL ON NULL INPUT和STRICT的功能相同。
l
IMMUTABLE
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
722GaussDB 200
开发者指南
16 SQL 参考
表示该函数在给出同样的参数值时总是返回同样的结果。
l
STABLE
表示该函数不能修改数据库,对相同参数值,在同一次表扫描里,该函数的返回
值不变,但是返回值可能在不同SQL语句之间变化。
l
VOLATILE
表示该函数值可以在一次表扫描内改变,不会做任何优化。
l SHIPPABLE
l NOT SHIPPABLE
表示该函数是否可以下推到DN上执行。
对于IMMUTABLE类型的函数,函数始终可以下推到DN上执行。
对于STABLE/VOLATILE类型的函数,仅当函数的属性是SHIPPABLE的时候,函
数可以下推到DN执行。
l
LEAKPROOF
表示该函数没有副作用,指出参数只包括返回值。LEAKROOF只能由系统管理员
设置。
l
EXTERNAL
(可选)目的是和SQL兼容,这个特性适合于所有函数,而不仅是外部函数
l
SECURITY INVOKER
AUTHID CURREN_USER
表明该函数将以调用它的用户的权限执行。缺省时与指定此参数的作用相同。
SECURITY INVOKER和AUTHID CURREN_USER的功能相同。
l
SECURITY DEFINER
AUTHID DEFINER
声明该函数将以创建它的用户的权限执行。
AUTHID DEFINER和SECURITY DEFINER的功能相同。
l
COST execution_cost
用来估计函数的执行成本。
execution_cost以cpu_operator_cost为单位。
取值范围:正数
l
ROWS result_rows
估计函数返回的行数。用于函数返回的是一个集合。
取值范围:正数,默认值是1000行。
l
configuration_parameter
–
value
把指定的数据库会话参数值设置为给定的值。如果value是DEFAULT或者
RESET,则在新的会话中使用系统的缺省设置。OFF关闭设置。
取值范围:字符串
n DEFAULT
n OFF
n RESET
指定默认值。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
723GaussDB 200
开发者指南
16 SQL 参考
–
from current
取当前会话中的值设置为configuration_parameter的值。
l
new_name
函数的新名称。要修改函数的所属模式,必须拥有新模式的CREATE权限。
取值范围:字符串,符合标识符命名规范。
l
new_owner
函数的新所有者。要修改函数的所有者,新所有者必须拥有该函数所属模式的
CREATE权限。
取值范围:已存在的用户角色。
l
new_schema
函数的新模式。
取值范围:已存在的模式。
示例
请参见CREATE FUNCTION的示例。
相关链接
16.14.53 CREATE FUNCTION,16.14.85 DROP FUNCTION
16.14.11 ALTER GROUP
功能描述
修改一个用户组的属性。
注意事项
ALTER GROUP是ALTER ROLE的别名,非SQL标准语法,不推荐使用,建议用户直接
使用ALTER ROLE替代。
语法格式
l
向用户组中添加用户。
ALTER GROUP group_name
ADD USER user_name [, ... ];
l
从用户组中删除用户。
ALTER GROUP group_name
DROP USER user_name [, ... ];
l
修改用户组的名称。
ALTER GROUP group_name
RENAME TO new_name;
参数说明
请参考ALTER ROLE的参数说明。
相关链接
16.14.54 CREATE GROUP,16.14.86 DROP GROUP,16.14.17 ALTER ROLE
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
724GaussDB 200
开发者指南
16 SQL 参考
16.14.12 ALTER INDEX
功能描述
ALTER INDEX用于修改现有索引的定义。
它有几种子形式:
l
IF EXISTS
如果指定的索引不存在,则发出一个notice而不是error。
l
RENAME TO
只改变索引的名字。对存储的数据没有影响。
l
SET TABLESPACE
这个选项会改变索引的表空间为指定表空间,并且把索引相关的数据文件移动到
新的表空间里。
l
SET ( { STORAGE_PARAMETER = value } [, ...] )
改变索引的一个或多个索引方法特定的存储参数。 需要注意的是索引内容不会被
这个命令立即修改,根据参数的不同,可能需要使用REINDEX重建索引来获得期
望的效果。
l
RESET ( { storage_parameter } [, ...] )
重置索引的一个或多个索引方法特定的存储参数为缺省值。与SET一样,可能需
要使用REINDEX来完全更新索引。
l
[ MODIFY PARTITION index_partition_name ] UNUSABLE
用于设置表或者索引分区上的索引不可用。
l
REBUILD [ PARTITION index_partition_name ]
用于重建表或者索引分区上的索引。
l
RENAME PARTITION
用于重命名索引分区
l
MOVE PARTITION
用于修改索引分区的所属表空间。
注意事项
l
只有索引的所有者有权限执行此命令,系统管理员默认拥有此权限。
语法格式
l
重命名表索引的名字。
ALTER INDEX [ IF EXISTS ] index_name
RENAME TO new_name;
l
修改表索引的所属空间。
ALTER INDEX [ IF EXISTS ] index_name
SET TABLESPACE tablespace_name;
l
修改表索引的存储参数。
ALTER INDEX [ IF EXISTS ] index_name
SET ( {storage_parameter = value} [, ... ] );
l
重置表索引的存储参数。
ALTER INDEX [ IF EXISTS ] index_name
RESET ( storage_parameter [, ... ] ) ;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
725GaussDB 200
开发者指南
16 SQL 参考
l
设置表索引或索引分区不可用。
ALTER INDEX [ IF EXISTS ] index_name
[ MODIFY PARTITION index_partition_name ] UNUSABLE;
说明
列存表不支持该语法。
l
重建表索引或索引分区。
ALTER INDEX index_name
REBUILD [ PARTITION index_partition_name ];
l
重命名索引分区。
ALTER INDEX [ IF EXISTS ] index_name
RENAME PARTITION index_partition_name TO new_index_partition_name;
l
修改索引分区的所属表空间。
ALTER INDEX [ IF EXISTS ] index_name
MOVE PARTITION index_partition_name TABLESPACE new_tablespace;
参数说明
l
index_name
要修改的索引名。
l
new_name
新的索引名。
取值范围:字符串,且符合标识符命名规范。
l
tablespace_name
表空间的名字。
取值范围:已存在的表空间。
l
storage_parameter
索引方法特定的参数名。
l
value
索引方法特定的存储参数的新值。根据参数的不同,这可能是一个数字或单词。
l
new_index_partition_name
新索引分区名。
l
index_partition_name
索引分区名。
l
new_tablespace
新表空间。
示例
请参见CREATE INDEX的示例。
相关链接
16.14.55 CREATE INDEX,16.14.87 DROP INDEX,16.14.120 REINDEX
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
726GaussDB 200
开发者指南
16 SQL 参考
16.14.13 ALTER LARGE OBJECT
功能描述
ALTER LARGE OBJECT用于更改一个large object的定义。它的唯一的功能是分配一个
新的所有者。
注意事项
使用ALTER LARGE OBJECT必须是系统管理员或者是其所有者。
语法格式
ALTER LARGE OBJECT large_object_oid
OWNER TO new_owner;
参数说明
l
large_object_oid
要被变large object的OID 。
取值范围:已存在的大对象名。
l
OWNER TO new_owner
large object新的所有者。
取值范围:已存在的用户名/角色名。
示例
无。
16.14.14 ALTER NODE
功能描述
修改一个现有节点的定义。
注意事项
ALTER NODE是集群管理工具封装的内部接口,用来实现集群管理。该接口不建议用
户直接使用,以免对集群状态造成影响。
语法格式
ALTER
(
[
[
[
[
[
[
[
[
[
[
[
文档版本 01 (2019-08-01)
NODE nodename WITH
TYPE = nodetype,]
HOST = hostname,]
PORT = portnum,]
HOST1 = 'hostname',]
PORT1 = portnum,]
HOSTPRIMARY [ = boolean ],]
PRIMARY [ = boolean ],]
PREFERRED [ = boolean ],]
SCTP_PORT = portnum,]
CONTROL_PORT = portnum,]
SCTP_PORT1 = portnum,]
版权所有 © 华为技术有限公司
727GaussDB 200
开发者指南
16 SQL 参考
[ CONTROL_PORT1 = portnum, ]
[ NODEIS_CENTRAL [ = boolean ]]
);
说明
PORT选项指定的端口号为节点间内部通信绑定的端口号,不同于外部客户端连接节点的端口
号,可通过pgxc_node表查询。
参数说明
请参见CREATE NODE的参数说明。
相关链接
16.14.56 CREATE NODE,16.14.88 DROP NODE
16.14.15 ALTER NODE GROUP
功能描述
修改一个node group的信息。
注意事项
l 只有系统管理员可以修改node group信息。
l 修改node group操作都是系统内部操作,除了SET DEFAULT语法之外,其他操作
都需要在维护模式下(调用set xc_maintenance_mode=on;)。
l ALTER NODE GROUP语法仅仅应该在数据库内部使用,使用者不应该手动调用
这些SQL语句,否则会导致数据库系统数据不一致。
语法格式
ALTER
|
|
|
|
|
|
|
|
|
|
NODE GROUP groupname
SET DEFAULT
RENAME TO new_group_name
SET VCGROUP RENAME TO new_group_name
SET NOT VCGROUP
SET TABLE GROUP new_group_name
COPY BUCKETS FROM src_group_name
ADD NODE ( nodename [, ... ] )
DELETE NODE ( nodename [, ... ] )
RESIZE TO dest_group_name
SET VCGROUP WITH GROUP new_group_name
参数说明
l
groupname
需要修改的node group名称。
取值范围:字符串,要符合标识符的命名规范。
l
SET DEFAULT
将系统中除了groupname指定的node group之外的其他node group对象的
in_redistribution字段设置为'y'。考虑到兼容以前版本,该语法仍然保留,且不需要
设置维护模式。
l
RENAME TO new_group_name
将groupname指定的node group的名字修改为new_group_name。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
728GaussDB 200
开发者指南
16 SQL 参考
l
SET VCGROUP RENAME TO new_group_name
将整个物理集群转换为一个逻辑集群,转换后groupname是逻辑集群名称,原物理
集群名称修改为new_group_name。
l
SET NOT VCGROUP
将所有逻辑集群转换为普通的node group,所有逻辑集群的group_kind从'v' 变成
'n'。
l
SET TABLE GROUP new_group_name
将所有CN节点的pgxc_class表中pgroup字段是group_name的记录修改为
new_group_name。
l
COPY BUCKETS FROM src_group_name
从src_group_name表示的NodeGroup中,将group_members字段和group_buckets字
段的内容拷贝到groupname所表示的NodeGroup中。
l
ADD NODE ( nodename [, ... ] )
从groupname指定的NodeGroup中增加指定的节点,这些新增节点在pgxc_node系
统表中存在。该语句仅仅修改系统表,不会进行实际的节点添加和数据重分布,
用户不应该直接调用该SQL语句。
l
DELETE NODE ( nodename [, ... ] )
从groupname指定的NodeGroup中,将指定的节点移除,这些被移除的节点仍然存
在于pgxc_node系统表中。该语句仅仅修改系统表,不会进行实际的节点移除和数
据重分布,用户不应该直接调用该SQL语句。
l
RESIZE TO dest_group_name
设置集群resize操作标志,将groupname所表示的NodeGroup设置为重分布的源
NodeGroup,并取消is_installation标志;同时将desst_group_name设置为重分布的
目的NodeGroup,并设置is_installation标志。
l
SET VCGROUP WITH GROUP new_group_name
将整个物理集群转换为一个逻辑集群,转换后groupname仍是物理集群,
new_group_name为转换后的逻辑集群名称。
16.14.16 ALTER RESOURCE POOL
功能描述
修改一个资源池,指定其他控制组。
注意事项
只要用户对当前数据库有ALTER权限,就可以修改资源池。
语法格式
ALTER RESOURCE POOL pool_name
WITH ({MEM_PERCENT= pct | CONTROL_GROUP="group_name" | ACTIVE_STATEMENTS=stmt | MAX_DOP = dop
| MEMORY_LIMIT='memory_size' | io_limits=io_limits | io_priority='io_priority'}[, ... ]);
参数说明
l
pool_name
资源池名称。
资源池名称为已创建的资源池。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
729GaussDB 200
开发者指南
16 SQL 参考
取值范围:字符串,要符合标识符的命名规范。
l
group_name
控制组名称。
说明
l 设置控制组名称时,语法可以使用双引号,也可以使用单引号。
l group_name对大小写敏感。
l 不指定group_name时,默认指定的字符串为 "Medium",代表指定DefaultClass控制组的
"Medium" Timeshare控制组。
l 若数据库管理员指定自定义Class组下的Workload控制组,如control_group的字符串为:
"class1:workload1";代表此资源池指定到class1控制组下的workload1控制组。也可同时
指定Workload控制组的层次,如control_group的字符串为:"class1:workload1:1"。
l 若数据库用户指定Timeshare控制组代表的字符串,即"Rush"、"High"、"Medium"或
"Low"其中一种,如control_group的字符串为"High";代表资源池指定到DefaultClass控
制组下的"High" Timeshare控制组。
l 多租户场景下,组资源池关联的控制组为class级别,业务资源池关联Workload控制组。
且不允许在各种资源池间相互切换。
取值范围:已创建的控制组。
l
stmt
资源池语句执行的最大并发数量。
取值范围:数值型,-1~INT_MAX。
l
dop
资源池最大并发度, 语句执行时能够创建的最多线程数量。
取值范围:数值型,1~INT_MAX。
l
memory_size
资源池最大使用内存。
取值范围:字符串,内容范围1KB~2047GB。
l
mem_percent
资源池可用内存占全部内存或者组用户内存使用的比例。
在多租户场景下,组用户和业务用户的mem_percent范围为1-100的整数,默认为
20。
在普通场景下,普通用户的mem_percent范围为0-100的整数,默认值为0。
说明
mem_percent和memory_limit同时指定时,只有mem_percent起作用。
l
io_limits
资源池每秒可触发IO次数上限。
对于行存,以万次为单位计数,而列存则以正常次数计数。
l
io_priority
IO利用率高达90%时,重消耗IO作业进行IO资源管控时关联的优先级等级。
包括三档可选:Low、Medium和High。不控制时可设置为None,默认为None。
说明
io_limits和io_priority的设置都仅对复杂作业有效。包括批量导入(INSERT INTO SELECT, COPY
FROM, CREATE TABLE AS等),单DN数据量大约超过500MB的复杂查询和VACUUM FULL等
操作。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
730GaussDB 200
开发者指南
16 SQL 参考
示例
本示例假定用户已成功创建自定义的class1控制组及其下属的Low、wg1、wg2 三个
Workload控制组。详细信息请参见13.5 优先级控制。
--创建一个资源池。
CREATE RESOURCE POOL pool1;
--更新一个资源池,其控制组指定为"DefaultClass"组下属的"High" Timeshare Workload控制组。
ALTER RESOURCE POOL pool1 WITH (CONTROL_GROUP="High");
--更新一个资源池,其控制组指定为"class1"组下属的"Low" Timeshare Workload控制组。
ALTER RESOURCE POOL pool1 WITH (CONTROL_GROUP="class1:Low");
--更新一个资源池,其控制组指定为"class1"组下属的"wg1" Workload控制组。
ALTER RESOURCE POOL pool1 WITH (CONTROL_GROUP="class1:wg1");
--更新一个资源池,其控制组指定为"class1"组下属的"wg2" Workload控制组。
ALTER RESOURCE POOL pool1 WITH (CONTROL_GROUP="class1:wg2:3");
--删除资源池pool1。
DROP RESOURCE POOL pool1;
相关链接
16.14.60 CREATE RESOURCE POOL,16.14.93 DROP RESOURCE POOL
16.14.17 ALTER ROLE
功能描述
修改角色属性。
注意事项
无。
语法格式
l
修改角色的权限。
ALTER ROLE role_name [ [ WITH ] option [ ... ] ];
其中权限项子句option为。
{CREATEDB | NOCREATEDB}
| {CREATEROLE | NOCREATEROLE}
| {INHERIT | NOINHERIT}
| {AUDITADMIN | NOAUDITADMIN}
| {SYSADMIN | NOSYSADMIN}
| {USEFT | NOUSEFT}
| {LOGIN | NOLOGIN}
| {REPLICATION | NOREPLICATION}
| {INDEPENDENT | NOINDEPENDENT}
| {VCADMIN | NOVCADMIN}
| CONNECTION LIMIT connlimit
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'
| [ ENCRYPTED | UNENCRYPTED ] IDENTIFIED BY 'password' [ REPLACE 'old_password' ]
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD { 'password' | DISABLE }
| [ ENCRYPTED | UNENCRYPTED ] IDENTIFIED BY { 'password' [ REPLACE 'old_password' ] |
DISABLE }
| VALID BEGIN 'timestamp'
| VALID UNTIL 'timestamp'
| RESOURCE POOL 'respool'
| USER GROUP 'groupuser'
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
731GaussDB 200
开发者指南
16 SQL 参考
|
|
|
|
l
PERM SPACE 'spacelimit'
NODE GROUP logic_cluster_name
ACCOUNT { LOCK | UNLOCK }
PGUSER
修改角色的名字。
ALTER ROLE role_name
RENAME TO new_name;
l
设置角色的配置参数。
ALTER ROLE role_name [ IN DATABASE database_name ]
SET configuration_parameter {{ TO | = } { value | DEFAULT } | FROM CURRENT};
l
重置角色的配置参数。
ALTER ROLE role_name
[ IN DATABASE database_name ] RESET {configuration_parameter|ALL};
参数说明
l
role_name
现有角色名。
取值范围:已存在的用户名。
l
IN DATABASE database_name
表示修改角色在指定数据库上的参数。
l
SET configuration_parameter
设置角色的参数。ALTER ROLE中修改的会话参数只针对指定的角色,且在下一
次该角色启动的会话中有效。
取值范围:
configuration_parameter和value的取值请参见16.14.130 SET。
DEFAULT:表示清除configuration_parameter参数的值,configuration_parameter参
数的值将继承本角色新产生的SESSION的默认值。
FROM CURRENT:取当前会话中的值设置为configuration_parameter参数的值。
l
RESET configuration_parameter/ALL
清除configuration_parameter参数的值。与SET configuration_parameter TO
DEFAULT的效果相同。
取值范围:ALL表示清除所有参数的值。
l
l
ACCOUNT LOCK | ACCOUNT UNLOCK
– ACCOUNT LOCK:锁定帐户,禁止登录数据库。
– ACCOUNT UNLOCK:解锁帐户,允许登录数据库。
PGUSER
当前版本不允许修改角色的PGUSER属性
其他参数请参见CREATE ROLE的参数说明。
示例
请参见CREATE ROLE的示例。
相关链接
16.14.61 CREATE ROLE,16.14.94 DROP ROLE,16.14.130 SET
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
732GaussDB 200
开发者指南
16 SQL 参考
16.14.18 ALTER ROW LEVEL SECURITY POLICY
功能描述
对已存在的行访问控制策略(包括行访问控制策略的名称,行访问控制指定的用户,
行访问控制的策略表达式)进行修改。
注意事项
表的所有者或管理员用户才能进行此操作。
语法格式
ALTER [ ROW LEVEL SECURITY ] POLICY [ IF EXISTS ] policy_name ON table_name RENAME TO
new_policy_name
ALTER [ ROW LEVEL SECURITY ] POLICY policy_name ON table_name
[ TO { role_name | PUBLIC } [, ...] ]
[ USING ( using_expression ) ]
参数说明
l
policy_name
行访问控制策略名称。
l
table_name
行访问控制策略的表名。
l
new_policy_name
新的行访问控制策略名称。
l
role_name
行访问控制策略应用的数据库用户,可以指定多个用户,PUBLIC表示应用到所有
用户。
l
using_expression
行访问控制的表达式,返回值为boolean类型。
示例
--创建数据表all_data
CREATE TABLE all_data(id int, role varchar(100), data varchar(100));
--创建行访问控制策略,当前用户只能查看用户自身的数据
CREATE ROW LEVEL SECURITY POLICY all_data_rls ON all_data USING(role = CURRENT_USER);
\d+ all_data
Table "public.all_data"
Column |
Type
| Modifiers | Storage | Stats target | Description
--------+------------------------+-----------+----------+--------------+-------------
id
| integer
|
| plain
|
|
role
| character varying(100) |
| extended |
|
data
| character varying(100) |
| extended |
|
Row Level Security Policies:
POLICY "all_data_rls"
USING (((role)::name = "current_user"()))
Has OIDs: no
Distribute By: HASH(id)
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no
--修改行访问控制all_data_rls的名称
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
733GaussDB 200
开发者指南
16 SQL 参考
ALTER ROW LEVEL SECURITY POLICY all_data_rls ON all_data RENAME TO all_data_new_rls;
--修改行访问控制策略影响的用户
ALTER ROW LEVEL SECURITY POLICY all_data_new_rls ON all_data TO alice, bob;
\d+ all_data
Table "public.all_data"
Column |
Type
| Modifiers | Storage | Stats target | Description
--------+------------------------+-----------+----------+--------------+-------------
id
| integer
|
| plain
|
|
role
| character varying(100) |
| extended |
|
data
| character varying(100) |
| extended |
|
Row Level Security Policies:
POLICY "all_data_new_rls"
TO alice,bob
USING (((role)::name = "current_user"()))
Has OIDs: no
Distribute By: HASH(id)
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no, enable_rowsecurity=true
--修改行访问控制策略表达式
ALTER ROW LEVEL SECURITY POLICY all_data_new_rls ON all_data USING (id > 100 AND role =
current_user);
\d+ all_data
Table "public.all_data"
Column |
Type
| Modifiers | Storage | Stats target | Description
--------+------------------------+-----------+----------+--------------+-------------
id
| integer
|
| plain
|
|
role
| character varying(100) |
| extended |
|
data
| character varying(100) |
| extended |
|
Row Level Security Policies:
POLICY "all_data_new_rls"
TO alice,bob
USING (((id > 100) AND ((role)::name = "current_user"())))
Has OIDs: no
Distribute By: HASH(id)
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no, enable_rowsecurity=true
相关链接
16.14.58 CREATE ROW LEVLEL SECURITY POLICY,16.14.91 DROP ROW
LEVEL SECURITY POLICY
16.14.19 ALTER SCHEMA
功能描述
修改模式属性。
注意事项
只有模式的所有者有权限执行ALTER SCHEMA命令,系统管理员默认拥有此权限。
语法格式
l
修改模式的名称。
ALTER SCHEMA schema_name
RENAME TO new_name;
l
修改模式的所有者。
ALTER SCHEMA schema_name
OWNER TO new_owner;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
734GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
schema_name
现有模式的名字。
取值范围:已存在的模式名。
l
RENAME TO new_name
修改模式的名字。
new_name:模式的新名字。
取值范围:字符串,要符合标识符命名规范。
l
OWNER TO new_owner
修改模式的所有者。非系统管理员要改变模式的所有者,该用户还必须是新的所
有角色的直接或间接成员, 并且该成员必须在此数据库上有CREATE权限。
new_owner:模式的新所有者。
取值范围:已存在的用户名/角色名。
示例
--创建模式ds。
CREATE SCHEMA ds;
--将当前模式ds更名为ds_new。
ALTER SCHEMA ds RENAME TO ds_new;
--创建用户jack。
CREATE USER jack PASSWORD 'Bigdata123@';
--将DS_NEW的所有者修改为jack。
ALTER SCHEMA ds_new OWNER TO jack;
--删除用户jack和模式ds_new。
DROP SCHEMA ds_new;
DROP USER jack;
相关链接
16.14.62 CREATE SCHEMA,16.14.95 DROP SCHEMA
16.14.20 ALTER SEQUENCE
功能描述
修改一个现有的序列的参数。
注意事项
l 使用ALTER SEQUENCE的用户必须是该序列的所有者。
l 当前版本仅支持修改拥有者和归属列。若要修改其他参数,可以删除重建,并用
Setval函数恢复当前值。
语法格式
修改序列归属列
ALTER SEQUENCE [ IF EXISTS ] name
[ OWNED BY { table_name.column_name | NONE } ] ;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
735GaussDB 200
开发者指南
16 SQL 参考
修改序列的拥有者
ALTER SEQUENCE [ IF EXISTS ] name OWNER TO new_owner;
参数说明
l
name
将要修改的序列名称。
l
IF EXISTS
当序列不存在时使用该选项不会出现错误消息,仅有一个通知。
l
OWNED BY
将序列和一个表的指定字段进行关联。这样,在删除那个字段或其所在表的时候
会自动删除已关联的序列。
如果序列已经和表有关联后,使用这个选项后新的关联关系会覆盖旧的关联。
关联的表和序列的所有者必须是同一个用户,并且在同一个模式中。
使用OWNED BY NONE将删除任何已经存在的关联。
l
new_owner
序列新所有者的用户名。用户要修改序列的所有者,必须是新角色的直接或者间
接成员,并且那个角色必须有序列所在模式上的CREATE权限。
示例
--创建一个名为serial的递增序列,从101开始。
CREATE SEQUENCE serial START 101;
--创建一个表,定义默认值。
CREATE TABLE T1(C1 bigint default nextval('serial'));
--将序列serial的归属列变为T1.C1。
ALTER SEQUENCE serial OWNED BY T1.C1;
--删除序列
DROP SEQUENCE serial cascade;
DROP TABLE T1;
相关链接
16.14.63 CREATE SEQUENCE,16.14.96 DROP SEQUENCE
16.14.21 ALTER SERVER
功能描述
增加、修改和删除一个现有server的参数。现有server可以从pg_foreign_server系统表查
询。
注意事项
除系统管理员外,只有server的owner才可以进行Alter操作。
语法格式
l
修改外部服务的参数。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
736GaussDB 200
开发者指南
16 SQL 参考
ALTER SERVER server_name [ VERSION 'new_version' ]
[ OPTIONS ( {[ ADD | SET | DROP ] option ['value']} [, ... ] ) ];
在OPTIONS选项里,ADD、SET和DROP指定要执行的操作,未指定时默认为ADD操
作。option和value为对应操作的参数。
对于HDFS Server和GC server目前只支持SET操作,ADD/DROP操作现有版本不支持。
语法中SET和DROP操作语法依然保留,以便后续扩展使用。
l
修改外部服务的所有者。
ALTER SERVER server_name
OWNER TO new_owner;
l
修改外部服务的名字。
ALTER SERVER server_name
RENAME TO new_name;
参数说明
修改server的参数如下所示:
l
server_name
所修改的server的名字。
l
new_version
修改后server的新版本名称。
l
修改server所支持的OPTIONS如下所示:
–
address
HDFS集群的主备节点所在的IP地址以及端口。
说明
l address必须存在,所以ADD和DROP操作不被允许。
l address目前只支持点分十进制格式的ipv4格式,且address字符串中不能出现空
格,多组address以逗号作为分隔符。ip和port之间使用’:’来区分。HDFS集群中
ip、port组对推荐设置两组,分别对应HDFS NameNode主备节点的address。
–
hdfscfgpath
HDFS集群的配置文件。
说明
l 若HDFS走安全模式时,hdfscfgpath是必选项,否则为可选项。
l 若设置hdfscfgpath时,path仅能设置一个。
–
dbname
用于协同分析,表示将要连接的远端集群的数据库名字。
–
username
用于协同分析,表示将要连接的远端集群的用户名。
–
password
用于协同分析,表示将要连接的远端集群的用户名密码。
l
new_owner
修改后server的新拥有者。更改所有者,你必须是外部服务器的所有者并且也是新
的所有者角色的直接或者间接成员,并且你必须对外部服务器的外部数据封装器
有USAGE权限。
l
new_name
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
737GaussDB 200
开发者指南
16 SQL 参考
修改后server的新名字。
示例
--建立一个hdfs_server,其中hdfs_fdw为数据库中存在的foreign data wrapper。
CREATE SERVER hdfs_server FOREIGN DATA WRAPPER HDFS_FDW OPTIONS (address , hdfscfgpath '/opt/
hadoop_client/HDFS/hadoop/etc/hadoop',type'HDFS');
SELECT * FROM pg_foreign_server WHERE srvname='hdfs_server';
srvname
| srvowner | srvfdw | srvtype | srvversion | srvacl
|
srvoptions
-------------+----------+--------+---------+------------+--------
+--------------------------------------------------------------------------------------------------
-
----
hdfs_server |
10 | 13332 |
|
|
| {"address= ",hdfscfgpath=/opt/
hadoop_client/HDFS/hadoop/etc/hadoop}
(1 row)
--修改现有名为hdfs_server的address。
ALTER SERVER hdfs_server OPTIONS ( SET address '10.10.0.110:25000,10.10.0.120:25000');
SELECT * FROM pg_foreign_server WHERE srvname='hdfs_server';
srvname
| srvowner | srvfdw | srvtype | srvversion | srvacl
|
srvoptions
-------------+----------+--------+---------+------------+--------
+--------------------------------------------------------------------------------------------------
-----
hdfs_server |
10 | 13167 |
|
|
| {"address= ",hdfscfgpath=/opt/
hadoop_client/HDFS/hadoop/etc/hadoop}
(1 row)
--修改现有名为hdfs_server的hdfscfgpath。
ALTER SERVER hdfs_server OPTIONS ( SET hdfscfgpath '/opt/bigdata/hadoop');
SELECT * FROM pg_foreign_server WHERE srvname='hdfs_server';
srvname
| srvowner | srvfdw | srvtype | srvversion | srvacl
|
srvoptions
-------------+----------+--------+---------+------------+--------
+---------------------------------------------------------------------------------
hdfs_server |
10 | 13332 |
|
|
| {"address= ",hdfscfgpath=/opt/
bigdata/hadoop}
(1 row)
--删除hdfs_server。
DROP SERVER hdfs_server;
相关链接
16.14.64 CREATE SERVER 16.14.97 DROP SERVER
16.14.22 ALTER SESSION
功能描述
ALTER SESSION命令用于定义或修改那些对当前会话有影响的条件或参数。修改后的
会话参数会一直保持,直到断开当前会话。
注意事项
l 如果执行SET TRANSACTION之前没有执行START TRANSACTION,则事务立即
结束,命令无法显示效果。
l 可以用START TRANSACTION里面声明所需要的transaction_mode(s)的方法来避免
使用SET TRANSACTION。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
738GaussDB 200
开发者指南
16 SQL 参考
语法格式
l
设置会话的事务参数。
ALTER SESSION SET [ SESSION CHARACTERISTICS AS ] TRANSACTION
{ ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED } | { READ ONLY
[, ...] ;
l
| READ WRITE } }
设置会话的其他运行时参数。
ALTER SESSION SET
{{config_parameter { { TO | = } { value | DEFAULT }
| FROM CURRENT }} | CURRENT_SCHEMA [ TO | = ] { schema | DEFAULT }
| TIME ZONE time_zone
| SCHEMA schema
| NAMES encoding_name
| ROLE role_name PASSWORD 'password'
| SESSION AUTHORIZATION { role_name PASSWORD 'password' | DEFAULT }
| XML OPTION { DOCUMENT | CONTENT }
} ;
参数说明
修改会话涉及到的参数说明请参见SET语法中的参数说明。
示例
-- 创建模式ds。
CREATE SCHEMA ds;
--设置模式搜索路径。
SET SEARCH_PATH TO ds, public;
--设置日期时间风格为传统的POSTGRES风格(日在月前)。
SET DATESTYLE TO postgres, dmy;
--设置当前会话的字符编码为UTF8。
ALTER SESSION SET NAMES 'UTF8';
--设置时区为加州伯克利。
SET TIME ZONE 'PST8PDT';
--设置时区为意大利。
SET TIME ZONE 'Europe/Rome';
--设置当前模式。
ALTER SESSION SET CURRENT_SCHEMA TO tpcds;
--设置XML OPTION为DOCUMENT。
ALTER SESSION SET XML OPTION DOCUMENT;
--创建角色joe,并设置会话的角色为omm。
CREATE ROLE joe WITH PASSWORD 'Bigdata123@';
ALTER SESSION SET SESSION AUTHORIZATION joe PASSWORD 'Bigdata123@';
--切换到默认用户。
postgres=> ALTER SESSION SET SESSION AUTHORIZATION default;
--删除ds模式。
DROP SCHEMA ds;
--删除joe。
DROP ROLE joe;
相关链接
16.14.130 SET
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
739GaussDB 200
开发者指南
16 SQL 参考
16.14.23 ALTER SYSTEM KILL SESSION
功能描述
ALTER SYSTEM KILL SESSION命令用于结束一个会话。
注意事项
无。
语法格式
ALTER SYSTEM KILL SESSION 'session_sid, serial' [ IMMEDIATE ];
参数说明
l
session_sid, serial
会话的SID和SERIAL(格式请参考示例)。
取值范围:通过查看系统表V$SESSION可查看所有会话的SID和SERIAL。
l
IMMEDIATE
表明会话将在命令执行后立即结束。
示例
--查询会话信息。
SELECT sid,serial#,username FROM V$SESSION;
sid
| serial# | username
-----------------+---------+----------
140131075880720 |
0 | omm
140131025549072 |
0 | omm
140131073779472 |
0 | omm
140131071678224 |
0 | omm
140131125774096 |
0 |
140131127875344 |
0 |
140131113629456 |
0 |
140131094742800 |
0 |
(8 rows)
--结束SID为140131075880720的会话。
ALTER SYSTEM KILL SESSION '140131075880720,0' IMMEDIATE;
16.14.24 ALTER TABLE
功能描述
修改表,包括修改表的定义、重命名表、重命名表中指定的列、重命名表的约束、设
置表的所属模式、添加/更新多个列、打开/关闭行访问控制开关。
注意事项
l 只有表的所有者有权限执行ALTER TABLE命令,系统管理员默认拥有此权限。
l 不能修改分区表的tablespace,但可以修改分区的tablespace。
l 不支持修改存储参数ORIENTATION。
l SET SCHEMA操作不支持修改为系统内部模式,当前仅支持用户模式之间的修
改。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
740GaussDB 200
开发者指南
16 SQL 参考
l 不允许对表的分布列(distribute column)进行修改。
l 列存表只支持PARTIAL CLUSTER KEY表级约束,不支持主外键等表级约束。
l 列存表只支持添加字段ADD COLUMN、修改字段的数据类型ALTER TYPE、设置
单个字段的收集目标SET STATISTICS、支持更改表名字、支持更改表空间,支持
删除字段DROP COLUMN。对于添加的字段和修改的字段类型要求是列存支持的
16.3 数据类型。ALTER TYPE的USING选项只支持常量表达式和涉及本字段的表
达式,暂不支持涉及其他字段的表达式。
l 列存表支持的字段约束包括NULL、NOT NULL和DEFAULT常量值;对字段约束
的修改当前只支持对DEFAULT值的修改(SET DEFAULT)和删除(DROP
DEFAULT),暂不支持对非空约束NULL/NOT NULL的修改。
l 不支持增加自增列,或者增加DEFAULT值中包含nextval()表达式的列。
l 不支持对HDFS表、外表、临时表开启行访问控制开关。
语法格式
l
修改表的定义。
ALTER TABLE [ IF EXISTS ] { table_name [*] | ONLY table_name | ONLY ( table_name ) }
action [, ... ];
其中具体表操作action可以是以下子句之一:
column_clause
| ADD table_constraint [ NOT VALID ]
| ADD table_constraint_using_index
| VALIDATE CONSTRAINT constraint_name
| DROP CONSTRAINT [ IF EXISTS ] constraint_name [ RESTRICT | CASCADE ]
| CLUSTER ON index_name
| SET WITHOUT CLUSTER
| SET ( {storage_parameter = value} [, ... ] )
| RESET ( storage_parameter [, ... ] )
| OWNER TO new_owner
| SET TABLESPACE new_tablespace
| SET {COMPRESS|NOCOMPRESS}
|
|
|
|
|
|
|
|
|
|
|
文档版本 01 (2019-08-01)
TO { GROUP groupname | NODE ( nodename [, ... ] ) }
ADD NODE ( nodename [, ... ] )
DELETE NODE ( nodename [, ... ] )
DISABLE TRIGGER [ trigger_name | ALL | USER ]
ENABLE TRIGGER [ trigger_name | ALL | USER ]
ENABLE REPLICA TRIGGER trigger_name
ENABLE ALWAYS TRIGGER trigger_name
DISABLE ROW LEVEL SECURITY
ENABLE ROW LEVEL SECURITY
FORCE ROW LEVEL SECURITY
NO FORCE ROW LEVEL SECURITY
版权所有 © 华为技术有限公司
741GaussDB 200
开发者指南
16 SQL 参考
说明
l ADD table_constraint [ NOT VALID ]
给表增加一个新的约束。
l ADD table_constraint_using_index
根据已有唯一索引为表增加主键约束或唯一约束。
l VALIDATE CONSTRAINT constraint_name
验证一个外键或是一个使用NOT VALID选项创建的检查类约束,通过扫描全表来保证
所有记录都符合约束条件。如果约束已标记为有效时,什么操作也不会发生。
l DROP CONSTRAINT [ IF EXISTS ] constraint_name [ RESTRICT | CASCADE ]
删除一个表上的约束。
l CLUSTER ON index_name
为将来的CLUSTER操作选择默认索引。实际上并没有重新盘簇化处理该表。
l SET WITHOUT CLUSTER
从表中删除最新使用的CLUSTER索引。这样会影响将来那些没有声明索引的集群操
作。
l SET ( {storage_parameter = value} [, ... ] )
修改表的一个或多个存储参数。
l RESET ( storage_parameter [, ... ] )
重置表的一个或多个存储参数。与SET一样,根据参数的不同可能需要重写表才能获得
想要的效果。
l OWNER TO new_owner
将表、序列、视图的属主改变成指定的用户。
l SET TABLESPACE new_tablespace
这种形式将表空间修改为指定的表空间并将相关的数据文件移动到新的表空间。但是表
上的所有索引都不会被移动,索引可以通过ALTER INDEX语法的SET TABLESPACE选
项来修改索引的表空间。
l SET {COMPRESS|NOCOMPRESS}
修改表的压缩特性。表压缩特性的改变只会影响后续批量插入的数据的存储方式,对已
有数据的存储毫无影响。也就是说,表压缩特性的修改会导致该表中同时存在着已压缩
和未压缩的数据。
l TO { GROUP groupname | NODE ( nodename [, ... ] ) }
此语法仅在扩展模式(GUC参数support_extended_features为on时)下可用。该模式谨慎
打开,主要供内部扩容工具使用,一般用户不应使用该模式。
l ADD NODE ( nodename [, ... ] )
此语法主要供内部扩容工具使用,一般用户不建议使用。
l DELETE NODE ( nodename [, ... ] )
此语法主要供内部缩容工具使用,一般用户不建议使用。
l DISABLE TRIGGER [ trigger_name | ALL | USER ]
禁用trigger_name所表示的单个触发器,或禁用所有触发器,或仅禁用用户触发器(此
选项不包括内部生成的约束触发器,例如,可延迟唯一性和排除约束的约束触发器)。
说明
应谨慎使用此功能,因为如果不执行触发器,则无法保证原先期望的约束的完整
性。
l | ENABLE TRIGGER [ trigger_name | ALL | USER ]
启用trigger_name所表示的单个触发器,或启用所有触发器,或仅启用用户触发器。
l | ENABLE REPLICA TRIGGER trigger_name
触发器触发机制受配置变量session_replication_role的影响,当复制角色为“origin”
(默认值)或“local”时,将触发简单启用的触发器。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
742GaussDB 200
开发者指南
16 SQL 参考
配置为ENABLE REPLICA的触发器仅在会话处于“replica”模式时触发。
l | ENABLE ALWAYS TRIGGER trigger_name
无论当前复制模式如何,配置为ENABLE ALWAYS的触发器都将触发。
l | DISABLE/ENABLE ROW LEVEL SECURITY
开启或关闭表的行访问控制开关。
当开启行访问控制开关时,如果未在该数据表定义相关行访问控制策略,数据表的行级
访问将不受影响;如果关闭表的行访问控制开关,即使定义了行访问控制策略,数据表
的行访问也不受影响。详细信息参见16.14.58 CREATE ROW LEVLEL SECURITY
POLICY章节。
l | NO FORCE/FORCE ROW LEVEL SECURITY
强制开启或关闭表的行访问控制开关。
默认情况,表所有者不受行访问控制特性影响,但当强制开启表的行访问控制开关时,
表的所有者(不包含系统管理员用户)会受影响。系统管理员可以绕过所有的行访问控
制策略,不受影响。
–
其中列相关的操作column_clause可以是以下子句之一:
ADD [ COLUMN ] column_name data_type [ compress_mode ] [ COLLATE collation ]
[ column_constraint [ ... ] ]
| MODIFY column_name data_type
| DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
| ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ]
[ USING expression ]
| ALTER [ COLUMN ] column_name { SET DEFAULT expression | DROP DEFAULT }
| ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL
| ALTER [ COLUMN ] column_name SET STATISTICS [PERCENT] integer
| ADD STATISTICS (( column_1_name, column_2_name [, ...] ))
| DELETE STATISTICS (( column_1_name, column_2_name [, ...] ))
| ALTER [ COLUMN ] column_name SET ( {attribute_option = value} [, ... ] )
| ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )
| ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
743GaussDB 200
开发者指南
16 SQL 参考
说明
l ADD [ COLUMN ] column_name data_type [ compress_mode ] [ COLLATE
collation ] [ column_constraint [ ... ] ]
向表中增加一个新的字段。用ADD COLUMN增加一个字段,所有表中现有行都
初始化为该字段的缺省值(如果没有声明DEFAULT子句,值为NULL)。
l ADD ( { column_name data_type [ compress_mode ] } [, ...] )
向表中增加多列。
l MODIFY ( { column_name data_type } [, ...] )
修改表已存在字段的数据类型。
l DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
从表中删除一个字段,和这个字段相关的索引和表约束也会被自动删除。如果任
何表之外的对象依赖于这个字段,必须声明CASCADE ,比如外键参考、视图
等。
DROP COLUMN命令并不是物理上把字段删除,而只是简单地把它标记为对SQL
操作不可见。随后对该表的插入和更新将在该字段存储一个NULL。因此,删除一
个字段是很快的,但是它不会立即释放表在磁盘上的空间,因为被删除了的字段
占据的空间还没有回收。这些空间将在执行VACUUM时而得到回收。
l ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE
collation ] [ USING expression ]
改变表字段的数据类型。该字段涉及的索引和简单的表约束将被自动地转换为使
用新的字段类型,方法是重新分析最初提供的表达式。
ALTER TYPE要求重写整个表的特性有时候是一个优点,因为重写的过程消除了
表中没用的空间。比如,要想立刻回收被一个已经删除的字段占据的空间,最快
的方法是
ALTER TABLE table ALTER COLUMN anycol TYPE anytype;
这里的anycol是任何在表中还存在的字段,而anytype是和该字段的原类型一样的
类型。这样的结果是在表上没有任何可见的语意的变化,但是这个命令强迫重
写,这样就删除了不再使用的数据。
l ALTER [ COLUMN ] column_name { SET DEFAULT expression | DROP
DEFAULT }
为一个字段设置或者删除缺省值。请注意缺省值只应用于随后的INSERT命令,它
们不会修改表中已经存在的行。也可以为视图创建缺省,这个时候它们是在视图
的ON INSERT规则应用之前插入到INSERT句中的。
l ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL
修改一个字段是否允许NULL值或者拒绝NULL值。如果表在字段中包含非
NULL,则只能使用SET NOT NULL。
l ALTER [ COLUMN ] column_name SET STATISTICS [PERCENT] integer
为随后的ANALYZE操作设置针对每个字段的统计收集目标。目标的范围可以在0
到10000之内设置。设置为-1时表示重新恢复到使用系统缺省的统计目标。
l {ADD | DELETE} STATISTICS ((column_1_name, column_2_name [, ...]))
用于添加和删除多列统计信息声明(不实际进行多列统计信息收集),以便在后
续进行全表或全库analyze时进行多列统计信息收集。每组多列统计信息最多支持
32列。不支持添加/删除多列统计信息声明的表:系统表、外表。
l ALTER [ COLUMN ] column_name SET ( {attribute_option = value} [, ... ] )
ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )
设置/重置属性选项。
目前,属性选项只定义了n_distinct和n_distinct_inherited。n_distinct影响表本身的
统计值,而n_distinct_inherited影响表及其继承子表的统计。目前,只支持SET/
RESET n_distinct参数,禁止SET/RESET n_distinct_inherited参数。
l ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL |
EXTENDED | MAIN }
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
744GaussDB 200
开发者指南
16 SQL 参考
为一个字段设置存储模式。这个设置控制这个字段是内联保存还是保存在一个附
属的表里,以及数据是否要压缩。仅支持对行存表的设置;对列存表没有意义,
执行时报错。SET STORAGE本身并不改变表上的任何东西,只是设置将来的表操
作时,建议使用的策略。
n
其中列约束column_constraint为:
[ CONSTRAINT constraint_name ]
{ NOT NULL |
NULL |
CHECK ( expression ) |
DEFAULT default_expr |
UNIQUE index_parameters |
PRIMARY KEY index_parameters }
[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
n
其中列的压缩可选项compress_mode为:
[ DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS ]
–
其中根据已有唯一索引为表增加主键约束或唯一约束
table_constraint_using_index为:
[ CONSTRAINT constraint_name ]
{ UNIQUE | PRIMARY KEY } USING INDEX index_name
[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
–
其中表约束table_constraint为:
[ CONSTRAINT constraint_name ]
{ CHECK ( expression ) |
UNIQUE ( column_name [, ... ] ) index_parameters |
PRIMARY KEY ( column_name [, ... ] ) index_parameters |
PARTIAL CLUSTER KEY ( column_name [, ... ] }
[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
其中索引参数index_parameters为:
[ WITH ( {storage_parameter = value} [, ... ] ) ]
[ USING INDEX TABLESPACE tablespace_name ]
l
重命名表。对名字的修改不会影响所存储的数据。
ALTER TABLE [ IF EXISTS ] table_name
RENAME TO new_table_name;
l
重命名表中指定的列。
ALTER TABLE [ IF EXISTS ] { table_name [*] | ONLY table_name | ONLY ( table_name )}
RENAME [ COLUMN ] column_name TO new_column_name;
l
重命名表的约束。
ALTER TABLE [ IF EXISTS ] { table_name [*] | ONLY table_name | ONLY ( table_name ) }
RENAME CONSTRAINT constraint_name TO new_constraint_name;
l
设置表的所属模式。
ALTER TABLE [ IF EXISTS ] table_name
SET SCHEMA new_schema;
说明
l 这种形式把表移动到另外一个模式。相关的索引、约束都跟着移动。目前序列不支持改
变schema。 若该表拥有序列,需要将序列删除,重建,或者取消拥有关系, 才能将表
schema更改成功。
l 要修改一个表的模式,用户必须在新模式上拥有CREATE权限。要把该表添加为一个父
表的新子表,用户必须同时又是父表的所有者。要修改所有者,用户还必须是新的所有
角色的直接或间接成员,并且该成员必须在此表的模式上有CREATE权限。这些限制规
定了该用户不能做出了重建和删除表之外的事情。不过,系统管理员可以以任何方式修
改任意表的所有权限。
l 除了RENAME和SET SCHEMA之外所有动作都可以捆绑在一个经过多次修改的列表中
并行使用。比如,可以在一个命令里增加几个字段或修改几个字段的类型。对于大表,
此种操作带来的效率提升更明显,原因在于只需要对该大表做一次处理。
l 增加一个CHECK或NOT NULL约束将会扫描该表,以保证现有的行符合约束要求。
l 用一个非空缺省值增加一个字段或者改变一个字段的现有类型会重写整个表。对于大表
来说,这个操作可能会花很长时间,并且它还临时需要两倍的磁盘空间。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
745GaussDB 200
开发者指南
16 SQL 参考
l
添加多个列。
ALTER TABLE [ IF EXISTS ] table_name
ADD ( { column_name data_type [ compress_mode ] [ COLLATE collation ]
[ column_constraint [ ... ] ]} [, ...] );
l
更新多个列。
ALTER TABLE [ IF EXISTS ] table_name
MODIFY ( { column_name data_type } [, ...] );
参数说明
l
IF EXISTS
如果不存在相同名称的表,不会抛出一个错误,而会发出一个通知,告知表不存
在。
l
table_name [*] | ONLY table_name | ONLY ( table_name )
table_name是需要修改的表名。
若声明了ONLY选项,则只有那个表被更改。若未声明ONLY,该表及其所有子表
都将会被更改。另外,可以在表名称后面显示地增加*选项来指定包括子表,即表
示所有后代表都被扫描,这是默认行为。
l
constraint_name
要删除的现有约束的名字。
l
index_name
索引名称。
l
storage_parameter
表的存储参数的名字。
在线扩容新增的两个选项:
–
append_mode(枚举类型)
设置表上扩容方式为在线扩容,离线扩容,非扩容方式 ,在线扩容时允许对
表进行部分的修改操作;离线扩容时,在扩容时不允许对表进行操作。
正在扩容表上需要新增数据要追加方式写入,便于记录增量数据。
on: 标记表为在线扩容模式,在线扩容时,设置后后续数据以追加方式写入。
off: 关闭扩容模式,设置后表上数据按正常方式写入,并且在
pg_class.reloptions中不显示在线扩容相关的选项。
read_only: 标记表为离线扩容 。离线扩容时,不允许对表进行操作。
–
rel_cn_oid (OID类型)
记录当前CN结点中表的OID,用于在DN结点上生成delete_delta表
当append_mode=on时,必须同时指定rel_cn_oid.
这append_mode ,rel_cn_oid两个选项只在在线扩容工具中使用,不建议用户使
用。
l
new_owner
表新拥有者的名字。
l
new_tablespace
表所属新的表空间名字。
l
column_name,column_1_name, column_2_name
现存的或新字段的名称。
l
data_type
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
746GaussDB 200
开发者指南
16 SQL 参考
新字段的类型,或者现存字段的新类型。
l
compress_mode
表字段的压缩可选项,当前仅对行存表有效。该子句指定该字段优先使用的压缩
算法。
l
collation
字段排序规则名称。可选字段COLLATE指定了新字段的排序规则,如果省略,排
序规则为新字段的默认类型。
l
USING expression
USING子句声明如何从旧的字段值里计算新的字段值;如果省略,缺省从旧类型
向新类型的赋值转换。如果从旧数据类型到新类型没有隐含或者赋值的转换,则
必须提供一个USING子句。
说明
ALTER TYPE的USING选项实际上可以声明涉及该行旧值的任何表达式,即它可以引用除
了正在被转换的字段之外其他的字段。这样,就可以用ALTER TYPE语法做非常普遍性的
转换。因为这个灵活性,USING表达式并没有作用于该字段的缺省值(如果有的话),结
果可能不是缺省表达式要求的常量表达式。这就意味着如果从旧类型到新类型没有隐含或
者赋值转换的话,即使存在USING子句,ALTER TYPE也可能无法把缺省值转换成新的类
型。在这种情况下,应该用DROP DEFAULT先删除缺省,执行ALTER TYPE,然后使用
SET DEFAULT增加一个合适的新缺省值。类似的考虑也适用于涉及该字段的索引和约束。
l
NOT NULL | NULL
设置列是否允许空值。
l
integer
带符号的整数常值。当使用PERCENT时表示按照表数据的百分比收集统计信息,
integer的取值范围为0-100。
l
attribute_option
属性选项。
l
PLAIN | EXTERNAL | EXTENDED | MAIN
字段存储模式。
l
– PLAIN必需用于定长的数值(比如integer)并且是内联的、不压缩的。
– MAIN用于内联、可压缩的数据。
– EXTERNAL用于外部保存、不压缩的数据。使用EXTERNAL将令在text和
bytea字段上的子字符串操作更快,但付出的代价是增加了存储空间。
– EXTENDED用于外部的压缩数据,EXTENDED是大多数支持非PLAIN存储的
数据的缺省。
CHECK ( expression )
每次将要插入的新行或者将要被更新的行必须使表达式结果为真才能成功,否则
会抛出一个异常并且不会修改数据库。
声明为字段约束的检查约束应该只引用该字段的数值,而在表约束里出现的表达
式可以引用多个字段。
目前,CHECK表达式不能包含子查询也不能引用除当前行字段之外的变量。
l
DEFAULT default_expr
给字段指定缺省值。
缺省表达式的数据类型必须和字段类型匹配。
缺省表达式将被用于任何未声明该字段数值的插入操作。如果没有指定缺省值则
缺省值为NULL 。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
747GaussDB 200
开发者指南
16 SQL 参考
l
UNIQUE index_parameters
UNIQUE ( column_name [, ... ] ) index_parameters
UNIQUE约束表示表里的一个或多个字段的组合必须在全表范围内唯一。
l
PRIMARY KEY index_parameters
PRIMARY KEY ( column_name [, ... ] ) index_parameters
主键约束表明表中的一个或者一些字段只能包含唯一(不重复)的非NULL值。
l
DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY
IMMEDIATE
设置该约束是否可推迟。
l
– DEFERRABLE:可以推迟到事务结尾使用SET CONSTRAINTS命令检查。
– NOT DEFERRABLE:在每条命令之后马上检查。
– INITIALLY IMMEDIATE:那么每条语句之后就立即检查它。
– INITIALLY DEFERRED:只有在事务结尾才检查它。
WITH ( {storage_parameter = value} [, ... ] )
为表或索引指定一个可选的存储参数。
l
tablespace_name
索引所在表空间的名称。
l
l
COMPRESS|NOCOMPRESS
– NOCOMPRESS:如果指定关键字NOCOMPRESS则不会修改表的现有压缩特
性。
– COMPRESS:如果指定COMPRESS关键字,则对该表进行批量插入元组时触
发该特性。
new_table_name
修改后新的表名称。
l
new_column_name
表中指定列修改后新的列名称。
l
new_constraint_name
修改后表约束的新名称。
l
new_schema
修改后新的模式名称。
l
CASCADE
级联删除依赖于被依赖字段或者约束的对象(比如引用该字段的视图)。
l
RESTRICT
如果字段或者约束还有任何依赖的对象,则拒绝删除该字段。这是缺省行为。
l
schema_name
表所在的模式名称。
示例
请参考CREATE TABLE的示例。
相关链接
16.14.65 CREATE TABLE,16.14.98 DROP TABLE
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
748GaussDB 200
开发者指南
16 SQL 参考
16.14.25 ALTER TABLE PARTITION
功能描述
修改表分区,包括增删分区、切割分区、合成分区,以及修改分区属性等。
注意事项
l 添加分区的表空间不能是PG_GLOBAL。
l 添加分区的名字不能与该分区表已有分区的名字相同。
l 添加分区的分区键值要和分区表的分区键的类型一致,且要大于分区表中最后一
个范围分区的上边界。
l 如果目标分区表中已有分区数达到了最大值(32767),则不能继续添加分区。
l 当分区表只有一个分区时,不能删除该分区。
l 选择分区使用PARTITION FOR(),括号里指定值个数应该与定义分区时使用的列
个数相同,并且一一对应。
l Value分区表不支持相应的Alter Partition操作。
l 列存分区表不支持切割分区。
语法格式
l
修改表分区主语法。
ALTER TABLE [ IF EXISTS ] { table_name
action [, ... ];
[*] | ONLY table_name | ONLY ( table_name
)}
其中action统指如下分区维护子语法。当存在多个分区维护子句时,保证了分区的
连续性,无论这些子句的排序如何,GaussDB 200总会先执行DROP PARTITION再
执行ADD PARTITION操作,最后顺序执行其它分区维护操作。
move_clause |
exchange_clause |
row_clause |
merge_clause |
modify_clause |
split_clause |
add_clause |
drop_clause
–
move_clause子语法用于移动分区到新的表空间。
MOVE PARTITION { partion_name | FOR ( partition_value [, ...] ) } TABLESPACE
tablespacename
–
exchange_clause子语法用于把普通表的数据迁移到指定的分区。
EXCHANGE PARTITION { ( partition_name ) | FOR ( partition_value [, ...] ) }
WITH TABLE {[ ONLY ] ordinary_table_name | ordinary_table_name * | ONLY
( ordinary_table_name )}
[ { WITH | WITHOUT } VALIDATION ] [ VERBOSE ]
进行交换的普通表和分区必须满足如下条件:
文档版本 01 (2019-08-01)
n 普通表和分区的列数目相同,对应列的信息严格一致,包括:列名、列
的数据类型、列约束、列的Collation信息、列的存储参数、列的压缩信
息等。
n 普通表和分区的表压缩信息严格一致。
n 普通表和分区的分布列信息严格一致。
n 普通表和分区的索引个数相同,且对应索引的信息严格一致。
n 普通表和分区的表约束个数相同,且对应表约束的信息严格一致。
版权所有 © 华为技术有限公司
749GaussDB 200
开发者指南
16 SQL 参考
n
普通表不可以是临时表。
完成交换后,普通表和分区的数据被置换,同时普通表和分区的表空间信息
被置换。此时,普通表和分区的统计信息变得不可靠,需要对普通表和分区
重新执行analyze。
–
row_clause子语法用于设置分区表的行迁移开关。
{ ENABLE | DISABLE } ROW MOVEMENT
–
merge_clause子语法用于把多个分区合并成一个分区。
MERGE PARTITIONS { partition_name } [, ...] INTO PARTITION partition_name
[ TABLESPACE tablespacename ]
–
modify_clause子语法用于设置分区索引是否可用。
MODIFY PARTITION partition_name { UNUSABLE LOCAL INDEXES | REBUILD UNUSABLE LOCAL
INDEXES }
–
split_clause子语法用于把一个分区切割成多个分区。
SPLIT PARTITION { partition_name | FOR ( partition_value [, ...] ) }
{ split_point_clause | no_split_point_clause }
n
指定切割点split_point_clause的语法为。
AT ( partition_value ) INTO ( PARTITION partition_name [ TABLESPACE
tablespacename ] , PARTITION partition_name [ TABLESPACE tablespacename ] )
l 列存分区表不支持切割分区。
l 切割点的大小要位于正在被切割的分区的分区键范围内,指定切割点
的方式只能把一个分区切割成两个新分区。
n
不指定切割点no_split_point_clause的语法为。
INTO { ( partition_less_than_item [, ...] ) | ( partition_start_end_item
[, ...] ) }
l 不指定切割点的方式,partition_less_than_item指定的第一个新分区的
分区键要大于正在被切割的分区的前一个分区(如果存在的话)的分
区键,partition_less_than_item指定的最后一个分区的分区键要等于正
在被切割的分区的分区键大小。
l 不指定切割点的方式,partition_start_end_item指定的第一个新分区的
起始点(如果存在的话)必须等于正在被切割的分区的前一个分区
(如果存在的话)的分区键,partition_start_end_item指定的最后一个
分区的终止点(如果存在的话)必须等于正在被切割的分区的分区
键。
l partition_less_than_item支持的分区键个数最多为4,而
partition_start_end_item仅支持1个分区键,其支持的数据类型参见
Partition Key。
l 在同一语句中partition_less_than_item和partition_start_end_item两者不
可同时使用;不同split语句之间没有限制。
n
分区项partition_less_than_item的语法为。
PARTITION partition_name VALUES LESS THAN ( { partition_value | MAXVALUE }
[, ...] )
[ TABLESPACE tablespacename ]
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
750GaussDB 200
开发者指南
16 SQL 参考
n
分区项partition_start_end_item的语法为,其约束参见START END语法描
述。
PARTITION partition_name {
{START(partition_value) END (partition_value) EVERY (interval_value)} |
{START(partition_value) END ({partition_value | MAXVALUE})} |
{START(partition_value)} |
{END({partition_value | MAXVALUE})}
} [TABLESPACE tablespace_name]
–
add_clause子语法用于为指定的分区表添加一个或多个分区。
ADD {partition_less_than_item | partition_start_end_item}
–
drop_clause子语法用于删除分区表中的指定分区。
DROP PARTITION
l
{ partition_name | FOR (
partition_value [, ...] )
}
修改表分区名字的语法。
ALTER TABLE [ IF EXISTS ] { table_name [*] | ONLY table_name | ONLY ( table_name
RENAME PARTITION { partion_name | FOR ( partition_value [, ...] ) } TO
partition_new_name;
)}
参数说明
l
table_name
分区表名。
取值范围:已存在的分区表名。
l
partition_name
分区名。
取值范围:已存在的分区名。
l
tablespacename
指定分区要移动到哪个表空间。
取值范围:已存在的表空间名。
l
partition_value
分区键值。
通过PARTITION FOR ( partition_value [, ...] )子句指定的这一组值,可以唯一确定
一个分区。
取值范围:需要进行重命名的分区的分区键的取值范围。
l
UNUSABLE LOCAL INDEXES
设置该分区上的所有索引不可用。
l
REBUILD UNUSABLE LOCAL INDEXES
重建该分区上的所有索引。
l
ENABLE/DISABLE ROW MOVEMET
行迁移开关。
如果进行UPDATE操作时,更新了元组在分区键上的值,造成了该元组所在分区
发生变化,就会根据该开关给出报错信息,或者进行元组在分区间的转移。
取值范围:
– ENABLE:打开行迁移开关。
– DISABLE:关闭行迁移开关。
默认是关闭状态。
l
ordinary_table_name
进行迁移的普通表的名称。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
751GaussDB 200
开发者指南
16 SQL 参考
取值范围:已存在的普通表名。
l
{ WITH | WITHOUT } VALIDATION
在进行数据迁移时,是否检查普通表中的数据满足指定分区的分区键范围。
取值范围:
– WITH:对于普通表中的数据要检查是否满足分区的分区键范围,如果有数据
不满足,则报错。
– WITHOUT:对于普通表中的数据不检查是否满足分区的分区键范围。
默认是WITH状态。
由于检查比较耗时,特别是当数据量很大的情况下更甚。所以在保证当前普通表
中的数据满足分区的分区键范围时,可以加上WITHOUT来指明不进行检查。
l
VERBOSE
在VALIDATION是WITH状态时,如果检查出普通表有不满足要交换分区的分区键
范围的数据,那么把这些数据插入到正确的分区,如果路由不到任何分区,再报
错。
只有在VALIDATION是WITH状态时,才可以指定VERBOSE。
l
partition_new_name
分区的新名字。
取值范围:字符串,要符合标识符的命名规范。
示例
请参考CREATE TABLE PARTITION的示例。
相关链接
16.14.67 CREATE TABLE PARTITION,16.14.98 DROP TABLE
16.14.26 ALTER TABLESPACE
功能描述
修改表空间的属性。
注意事项
l 只有表空间的所有者有权限执行ALTER TABLESPACE命令,系统管理员默认拥有
此权限。
l 要修改表空间的所有者A为B,则A必须是B的直接或者间接成员。
说明
如果new_owner与old_owner一致,此处不再校验当前执行操作的用户是否具有修改权限,
而直接显示ALTER成功。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
752GaussDB 200
开发者指南
16 SQL 参考
语法格式
l
重命名表空间的语法。
ALTER TABLESPACE tablespace_name
RENAME TO new_tablespace_name;
l
设置表空间所有者的语法。
ALTER TABLESPACE tablespace_name
OWNER TO new_owner;
l
设置表空间属性的语法。
ALTER TABLESPACE tablespace_name
SET ( {tablespace_option = value} [, ... ] );
l
重置表空间属性的语法。
ALTER TABLESPACE tablespace_name
RESET ( { tablespace_option } [, ...] )
l
设置表空间限额的语法
ALTER TABLESPACE tablespace_name
RESIZE MAXSIZE { UNLIMITED | 'space_size'};
参数说明
l
tablespace_name
要修改的表空间。
取值范围:已存在的表空间名。
l
new_tablespace_name
表空间的新名字。
新名字不能以"PG_"开头。
取值范围:字符串,符合标识符命名规范。
l
new_owner
表空间的新所有者。
取值范围:已存在的用户名。
l
tablespace_option
设置或者重置表空间的参数。
取值范围:
– seq_page_cost:设置优化器计算一次顺序获取磁盘页面的开销。缺省为1.0。
– random_page_cost:设置优化器计算一次非顺序获取磁盘页面的开销。缺省为
4.0。
说明
l random_page_cost是相对于seq_page_cost的取值,等于或者小于seq_page_cost时毫
无意义。
l 默认值为4.0的前提条件是,优化器采用索引来扫描表数据,并且表数据在cache中
命中率可以90%左右。
l 如果表数据空间要比物理内存小,那么减小该值到一个适当水平;相反地,如果
表数据在cache中命中率要低于90%,那么适当增大该值。
l 如果采用了类似于SSD的随机访问代价较小的存储器,可以适当减小该值,以反
映真正的随机扫描代价。
value的取值范围:正的浮点类型。
l
RESIZE MAXSIZE
重新设置表空间限额的数值。
取值范围:
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
753GaussDB 200
开发者指南
16 SQL 参考
– UNLIMITED,此表空间不设置限额。
– 由space_size来确定,其格式参考16.14.68 CREATE TABLESPACE。
说明
修改参数MAXSIZE时也可使用:
ALTER TABLESPACE tablespace_name RESIZE MAXSIZE
{ 'UNLIMITED' | 'space_size'};
示例
请参考CREATE TABLESPACE的示例。
相关链接
16.14.68 CREATE TABLESPACE,16.14.99 DROP TABLESPACE
16.14.27 ALTER TEXT SEARCH CONFIGURATION
功能描述
更改文本搜索配置的定义。用户可以将映射从字串类型调整为字典,或者改变配置的
名称或者所有者,或者修改搜索配置的配置参数。
ADD MAPPING FOR选项为文本搜索配置增加字串类型映射;如果ADD MAPPING
FOR后面任何一个字串类型的映射已经存在于此文本搜索配置中,那么系统将会报
错。
ALTER MAPPING FOR选项会首先清除已有的字串类型映射,然后添加指定的字串类
型映射。
ALTER MAPPING REPLACE ... WITH ... 与ALTER MAPPING FOR ... REPLACE ...
WITH ...选项会直接使用new_dictionary替换old_dictionary。需要注意的是,只有
pg_ts_config_map系统表中存在maptokentype与old_dictionary对应关系的元组时,才能
更新成功,否则不会成功,也不会有任何提示信息返回。
DROP MAPPING FOR选项会删除当前文本搜索配置中指定的字串类型映射。 如果没
有指定IF EXISTS选项,当DROP MAPPING FOR选项指定的字串类型映射在文本搜索
配置中不存在时,数据库会报错。
注意事项
l 当一个搜索配置已经被引用(如被用来创建索引),则不允许用户修改此文本搜
索配置。
l 要使用ALTER TEXT SEARCH CONFIGURATION,用户必须是配置的所有者。
l 增加文本搜索配置字串类型映射语法
语法格式
ALTER TEXT SEARCH CONFIGURATION name
ADD MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ];
l
修改文本搜索配置字典语法
ALTER TEXT SEARCH CONFIGURATION name
ALTER MAPPING FOR token_type [, ... ] REPLACE old_dictionary WITH new_dictionary;
l
修改文本搜索配置字串类型语法
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
754GaussDB 200
开发者指南
16 SQL 参考
ALTER TEXT SEARCH CONFIGURATION name
ALTER MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ];
l
更改文本搜索配置字典语法
ALTER TEXT SEARCH CONFIGURATION name
ALTER MAPPING REPLACE old_dictionary WITH new_dictionary;
l
删除文本搜索配置字串类型映射语法
ALTER TEXT SEARCH CONFIGURATION name
DROP MAPPING [ IF EXISTS ] FOR token_type [, ... ];
l
重命名文本搜索配置所有者语法
ALTER TEXT SEARCH CONFIGURATION name OWNER TO new_owner;
l
重命名文本搜索配置名称语法
ALTER TEXT SEARCH CONFIGURATION name RENAME TO new_name;
l
重命名文本搜索配置命名空间语法
ALTER TEXT SEARCH CONFIGURATION name SET SCHEMA new_schema;
l
修改文本搜索配置属性语法
ALTER TEXT SEARCH CONFIGURATION name SET ( { configuration_option = value } [, ...] );
l
重置文本搜索配置属性语法
ALTER TEXT SEARCH CONFIGURATION name RESET ( {configuration_option} [, ...] );
参数说明
l
name
已有文本搜索配置的名称(可以有模式修饰)。
l
token_type
与配置的语法解析器关联的字串类型的名称。详细信息参见16.8.5 解析器。
l
dictionary_name
文本搜索字典名称。 如果有多个字典,则它们会按指定的顺序搜索。
l
old_dictionary
映身中拟被替换的文本搜索字典名称。
l
new_dictionary
替换old_dictionary的文本搜索字典的名称。
l
new_owner
文本搜索配置的新所有者。
l
new_name
文本搜索配置的新名称。
l
new_schema
文本搜索配置的新模式名。
l
configuration_option
文本搜索配置项。详细信息参见16.14.69 CREATE TEXT SEARCH
CONFIGURATION。
l
value
文本搜索配置项的值。
示例
--创建文本搜索配置。
CREATE TEXT SEARCH CONFIGURATION english_1 (parser=default);
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
755GaussDB 200
开发者指南
16 SQL 参考
CREATE TEXT SEARCH CONFIGURATION
--增加文本搜索配置字串类型映射语法。
ALTER TEXT SEARCH CONFIGURATION english_1 ADD MAPPING FOR word WITH simple,english_stem;
ALTER TEXT SEARCH CONFIGURATION
--增加文本搜索配置字串类型映射语法。
ALTER TEXT SEARCH CONFIGURATION english_1 ADD MAPPING FOR email WITH english_stem, french_stem;
ALTER TEXT SEARCH CONFIGURATION
--查询文本搜索配置相关信息。
SELECT b.cfgname,a.maptokentype,a.mapseqno,a.mapdict,c.dictname FROM pg_ts_config_map
a,pg_ts_config b, pg_ts_dict c WHERE a.mapcfg=b.oid AND a.mapdict=c.oid AND b.cfgname='english_1'
ORDER BY 1,2,3,4,5;
cfgname | maptokentype | mapseqno | mapdict |
dictname
-----------+--------------+----------+---------+--------------
english_1 |
2 |
1 |
3765 | simple
english_1 |
2 |
2 |
12960 | english_stem
english_1 |
4 |
1 |
12960 | english_stem
english_1 |
4 |
2 |
12964 | french_stem
(4 rows)
--增加文本搜索配置字串类型映射语法。
ALTER TEXT SEARCH CONFIGURATION english_1 ALTER MAPPING REPLACE french_stem with german_stem;
ALTER TEXT SEARCH CONFIGURATION
--查询文本搜索配置相关信息。
SELECT b.cfgname,a.maptokentype,a.mapseqno,a.mapdict,c.dictname FROM pg_ts_config_map
a,pg_ts_config b, pg_ts_dict c WHERE a.mapcfg=b.oid AND a.mapdict=c.oid AND b.cfgname='english_1'
ORDER BY 1,2,3,4,5;
cfgname | maptokentype | mapseqno | mapdict |
dictname
-----------+--------------+----------+---------+--------------
english_1 |
2 |
1 |
3765 | simple
english_1 |
2 |
2 |
12960 | english_stem
english_1 |
4 |
1 |
12960 | english_stem
english_1 |
4 |
2 |
12966 | german_stem
(4 rows)
请参见CREATE TEXT SEARCH CONFIGURATION的示例。
相关链接
16.14.69 CREATE TEXT SEARCH CONFIGURATION, 16.14.100 DROP TEXT
SEARCH CONFIGURATION
16.14.28 ALTER TEXT SEARCH DICTIONARY
功能描述
修改全文检索词典的相关定义,包括参数、名称、所有者、以及模式等。
注意事项
l 预定义词典不支持ALTER操作。
l 只有词典的所有者可以执行ALTER操作,系统管理员默认拥有此权限。
l 创建或修改词典之后,任何对于filepath路径下用户自定义的词典定义文件的修
改,将不会影响到数据库中的词典。如果需要在数据库中使用这些修改,需使用
ALTER TEXT SEARCH DICTIONARY语句更新对应词典的定义文件。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
756GaussDB 200
开发者指南
16 SQL 参考
语法格式
l
修改词典定义。
ALTER TEXT SEARCH DICTIONARY name (
option [ = value ] [, ... ]
);
l
重命名词典。
ALTER TEXT SEARCH DICTIONARY name RENAME TO new_name;
l
设置词典的所属模式。
ALTER TEXT SEARCH DICTIONARY name SET SCHEMA new_schema;
l
修改词典的所属者。
ALTER TEXT SEARCH DICTIONARY name OWNER TO new_owner;
参数说明
l
name
已存在的词典名(可指定模式名,否则默认在当前模式下)。
取值范围:已存在的词典名。
l
option
要修改的参数名。与template对应,不同的词典类型具有不同的参数列表,且与指
定顺序无关。详细参数说明请见option。
说明
l 不支持修改词典的TEMPLATE参数值。
l 不支持仅修改FILEPATH参数而不修改对应的词典定义文件参数。
l 词典定义文件的文件名仅支持小写字母、数据、下划线混合。
l
value
要修改的参数值。如果省略等号(=)和value,则表示删除该option的先前设置,
使用默认值。
取值范围:对应option定义。
l
new_name
词典的新名称。
取值范围:符合标识符命名规范的字符串,且最大长度不超过63个字符。
l
new_owner
词典新的所有者。
取值范围:已存在的用户。
l
new_schema
词典的新模式。
取值范围:已存在的模式。
示例
--更改Snowball类型字典的停用词定义,其他参数保持不变。
ALTER TEXT SEARCH DICTIONARY my_dict ( StopWords = newrussian, FilePath = 'file:///home/dicts' );
--更改Snowball类型字典的Language参数,并删除停用词定义。
ALTER TEXT SEARCH DICTIONARY my_dict ( Language = dutch, StopWords );
--更新词典定义,不实际更改任何内容。
ALTER TEXT SEARCH DICTIONARY my_dict ( dummy );
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
757GaussDB 200
开发者指南
16 SQL 参考
相关链接
16.14.70 CREATE TEXT SEARCH DICTIONARY,16.14.101 DROP TEXT SEARCH
DICTIONARY
16.14.29 ALTER TRIGGER
功能描述
修改触发器定义。
注意事项
只有触发器所在表的所有者可以执行ALTER TRIGGER操作,系统管理员默认拥有此权
限。
语法格式
ALTER TRIGGER trigger_name ON table_name RENAME TO new_name;
参数说明
l
trigger_name
要修改的触发器名字。
取值范围:已存在的触发器。
l
table_name
要修改的触发器所在的表名称。
取值范围:已存在的含触发器的表。
l
new_name
修改后的新名字。
取值范围:符合标识符命名规范的字符串,最大长度不超过63个字符,且不能与
所在表上其他触发器同名。
示例
请参见16.14.71 CREATE TRIGGER的示例。
相关链接
16.14.71 CREATE TRIGGER,16.14.102 DROP TRIGGER,16.14.24 ALTER TABLE
16.14.30 ALTER TYPE
功能描述
修改一个类型的定义。
语法格式
l
修改类型
ALTER TYPE name action [, ... ]
ALTER TYPE name OWNER TO { new_owner | CURRENT_USER | SESSION_USER }
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
758GaussDB 200
开发者指南
16 SQL 参考
ALTER TYPE name RENAME ATTRIBUTE attribute_name TO new_attribute_name [ CASCADE | RESTRICT ]
ALTER TYPE name RENAME TO new_name
ALTER TYPE name SET SCHEMA new_schema
ALTER TYPE name ADD VALUE [ IF NOT EXISTS ] new_enum_value [ { BEFORE | AFTER }
neighbor_enum_value ]
ALTER TYPE name RENAME VALUE existing_enum_value TO new_enum_value
where action is one of:
ADD ATTRIBUTE attribute_name data_type [ COLLATE collation ] [ CASCADE | RESTRICT ]
DROP ATTRIBUTE [ IF EXISTS ] attribute_name [ CASCADE | RESTRICT ]
ALTER ATTRIBUTE attribute_name [ SET DATA ] TYPE data_type [ COLLATE collation ]
[ CASCADE | RESTRICT ]
l
给复合类型增加新的属性。
ALTER TYPE name ADD ATTRIBUTE attribute_name data_type [ COLLATE collation ] [ CASCADE |
RESTRICT ]
l
从复合类型删除一个属性。
ALTER TYPE name DROP ATTRIBUTE [ IF EXISTS ] attribute_name [ CASCADE | RESTRICT ]
l
改变一种复合类型中某个属性的类型。
ALTER TYPE name ALTER ATTRIBUTE attribute_name [ SET DATA ] TYPE data_type [ COLLATE
collation ] [ CASCADE | RESTRICT ]
l
改变类型的所有者。
ALTER TYPE name OWNER TO { new_owner | CURRENT_USER | SESSION_USER }
l
改变类型的名称或是一个复合类型中的一个属性的名称。
ALTER TYPE name RENAME TO new_name
ALTER TYPE name RENAME ATTRIBUTE attribute_name TO new_attribute_name [ CASCADE | RESTRICT ]
l
将类型移至一个新的模式中。
ALTER TYPE name SET SCHEMA new_schema
l
为枚举类型增加一个新值。
ALTER TYPE name ADD VALUE [ IF NOT EXISTS ] new_enum_value [ { BEFORE | AFTER }
neighbor_enum_value ]
l
重命名枚举类型的一个标签值。
ALTER TYPE name RENAME VALUE existing_enum_value TO new_enum_value
参数说明
l
name
一个需要修改的现有的类型的名字(可以有模式修饰) 。
l
new_name
该类型的新名称。
l
new_owner
新所有者的用户名 。
l
new_schema
该类型的新模式 。
l
attribute_name
拟增加、更改或删除的属性的名称。
l
new_attribute_name
拟改名的属性的新名称。
l
data_type
拟新增属性的数据类型,或是拟更改的属性的新类型名。
l
new_enum_value
枚举类型新增加的标签值,是一个非空的长度不超过64个字节的字符串。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
759GaussDB 200
开发者指南
16 SQL 参考
l
neighbor_enum_value
一个已有枚举标签值,新值应该被增加在紧接着该枚举值之前或者之后的位置
上。
l
existing_enum_value
现有的要重命名的枚举值,是一个非空的长度不超过64个字节的字符串
l
CASCADE
自动级联更新需更新类型以及相关联的记录和继承它们的子表。
l
RESTRICT
如果需联动更新类型是已更新类型的关联记录,则拒绝更新。这是缺省选项。
l ADD ATTRIBUTE、DROP ATTRIBUTE和ALTER ATTRIBUTE选项可以组合成
一个列表同时处理。 例如,在一条命令中同时增加几个属性或是更改几个属性
的类型是可以实现的。
l 要使用ALTER TYPE,必须是该类型的所有者。 要修改一个类型的模式,还必
须在新模式上拥有CREATE权限。 要修改所有者,必须是新的所有角色的直接
或间接成员, 并且该成员必须在此类型的模式上有CREATE权限。 (这些限制
强制了修改所有者不会做任何通过删除和重建类型不能做的事情。 不过,系统
管理员可以以任何方式修改任意类型的所有权。) 要增加一个属性或是修改一
个属性的类型,也必须有该类型的USAGE权限。
示例
请参考CREATE TYPE的示例。
相关链接
16.14.72 CREATE TYPE,16.14.103 DROP TYPE
16.14.31 ALTER USER
功能描述
修改数据库用户的属性。
注意事项
ALTER USER中修改的会话参数只针对指定的用户,且在下一次会话中有效。
语法格式
l
修改用户的权限等信息。
ALTER USER user_name [ [ WITH ] option [ ... ] ];
其中option子句为。
{ CREATEDB | NOCREATEDB }
| { CREATEROLE | NOCREATEROLE }
| { INHERIT | NOINHERIT }
| { AUDITADMIN | NOAUDITADMIN }
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
760GaussDB 200
开发者指南
16 SQL 参考
| { SYSADMIN | NOSYSADMIN }
| { USEFT | NOUSEFT }
| { LOGIN | NOLOGIN }
| { REPLICATION | NOREPLICATION }
| {INDEPENDENT | NOINDEPENDENT}
| {VCADMIN | NOVCADMIN}
| CONNECTION LIMIT connlimit
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD { 'password' | DISABLE }
| [ ENCRYPTED | UNENCRYPTED ] IDENTIFIED BY { 'password' [ REPLACE 'old_password' ] |
DISABLE }
| VALID BEGIN 'timestamp'
| VALID UNTIL 'timestamp'
| RESOURCE POOL 'respool'
| USER GROUP 'groupuser'
| PERM SPACE 'spacelimit'
| NODE GROUP logic_cluster_name
| ACCOUNT { LOCK | UNLOCK }
| PGUSER
l
修改用户名。
ALTER USER user_name
RENAME TO new_name;
l
修改与用户关联的指定会话参数值。
ALTER USER user_name
SET configuration_parameter { { TO | = } { value | DEFAULT } | FROM CURRENT };
l
重置与用户关联的指定会话参数值。
ALTER USER user_name
RESET { configuration_parameter | ALL };
参数说明
l
user_name
现有用户名。
取值范围:已存在的用户名。
l
new_password
新密码。
密码规则如下:
– 不能与当前密码相同。
– 密码默认不少于8个字符。
– 不能与用户名及用户名倒序相同。
– 至少包含大写字母(A-Z),小写字母(a-z),数字(0-9),非字母数字字
符(限定为~!@#$%^&*()-_=+\|[{}];:,<.>/?)四类字符中的三类字符。
取值范围:字符串。
l
old_password
旧密码。
l
l
ACCOUNT LOCK | ACCOUNT UNLOCK
– ACCOUNT LOCK:锁定帐户,禁止登录数据库。
– ACCOUNT UNLOCK:解锁帐户,允许登录数据库。
PGUSER
当前版本不允许修改用户的PGUSER属性。
其他参数请参见16.14.61 CREATE ROLE和16.14.17 ALTER ROLE的参数说明。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
761GaussDB 200
开发者指南
16 SQL 参考
示例
请参考CREATE USER的示例。
相关链接
16.14.61 CREATE ROLE,16.14.73 CREATE USER,16.14.104 DROP USER
16.14.32 ALTER VIEW
功能描述
ALTER VIEW更改视图的各种辅助属性。(如果用户是更改视图的查询定义,要使用
CREATE OR REPLACE VIEW。)
注意事项
l 用户必须是视图的所有者才可以使用ALTER VIEW。
l 要改变视图的模式,用户必须要有新模式的CREATE权限。
l 要改变视图的所有者,用户必须是新所属角色的直接或者间接的成员,并且此角
色必须有视图模式的CREATE权限。
l 管理员用户可以更改任何视图的所属关系。
语法格式
l
设置视图列的默认值。
ALTER VIEW [ IF EXISTS ] view_name
ALTER [ COLUMN ] column_name SET DEFAULT expression;
l
取消列视图列的默认值。
ALTER VIEW [ IF EXISTS ] view_name
ALTER [ COLUMN ] column_name DROP DEFAULT;
l
修改视图的所有者。
ALTER VIEW [ IF EXISTS ] view_name
OWNER TO new_owner;
l
重命名视图。
ALTER VIEW [ IF EXISTS ] view_name
RENAME TO new_name;
l
设置视图的所属模式。
ALTER VIEW [ IF EXISTS ] view_name
SET SCHEMA new_schema;
l
设置视图的选项。
ALTER VIEW [ IF EXISTS ] view_name
SET ( { view_option_name [ = view_option_value ] } [, ... ] );
l
重置视图的选项。
ALTER VIEW [ IF EXISTS ] view_name
RESET ( view_option_name [, ... ] );
参数说明
l
IF EXISTS
使用这个选项,如果视图不存在时不会产生错误,仅有会有一个提示信息。
l
view_name
视图名称,可以用模式修饰。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
762GaussDB 200
开发者指南
16 SQL 参考
取值范围:字符串,符合标识符命名规范。
l
column_name
可选的名字列表,视图的字段名。如果没有给出,字段名取自查询中的字段名。
取值范围:字符串,符合标识符命名规范。
l
SET/DROP DEFAULT
设置或删除一个列的缺省值,该参数暂无实际意义。
l
new_owner
视图新所有者的用户名称。
l
new_name
视图的新名称。
l
new_schema
视图的新模式。
l
view_option_name [ = view_option_value ]
该子句为视图指定一个可选的参数。
目前view_option_name支持的参数仅有security_barrier,当VIEW试图提供行级安全
时,应使用该参数。
取值范围:boolean类型,TRUE、FALSE。
示例
--创建一个由c_customer_sk小于150的内容组成的视图。
CREATE VIEW tpcds.customer_details_view_v1 AS
SELECT * FROM tpcds.customer
WHERE c_customer_sk < 150;
--修改视图名称。
ALTER VIEW tpcds.customer_details_view_v1 RENAME TO customer_details_view_v2;
--修改视图所属schema。
ALTER VIEW tpcds.customer_details_view_v2 SET schema public;
--删除视图。
DROP VIEW public.customer_details_view_v2;
相关链接
16.14.74 CREATE VIEW,16.14.105 DROP VIEW
16.14.33 ALTER WORKLOAD GROUP
功能描述
修改一个负载组,设置并发数量。
注意事项
只要用户对当前数据库有ALTER权限,就可以修改负载组。
语法格式
ALTER WORKLOAD GROUP wg_name
USING RESOURCE POOL pool_name [ WITH ( ACT_STATEMENTS = count ) ];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
763GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
wg_name
负载组名称。
说明
负载组名称不能和当前数据库里其他负载组重名。
取值范围:字符串,要符合标识符的命名规范。
l
pool_name
资源池名称。
取值范围:字符串,已创建的资源池。
l
counts
负载组所在资源池内的并发数量。
取值范围:整型,取值范围为-1 ~ INT_MAX。
示例
--创建资源池pool1。
CREATE RESOURCE POOL pool1;
--创建负载组group1。
CREATE WORKLOAD GROUP group1;
-- 更新一个负载组group1的并发数量为10。其关联的资源池为pool1。
ALTER WORKLOAD GROUP group1 USING RESOURCE POOL pool1 WITH (ACT_STATEMENTS=10);
--删除负载组group1和资源池pool1。
DROP WORKLOAD GROUP group1;
DROP RESOURCE POOL pool1;
相关链接
16.14.75 CREATE WORKLOAD GROUP,16.14.106 DROP WORKLOAD GROUP
16.14.34 ANALYZE | ANALYSE
功能描述
用于收集与数据库中普通表内容相关的统计信息,统计结果存储在系统表
PG_STATISTIC下。执行计划生成器会使用这些统计数据,以确定最有效的执行计划。
如果没有指定参数,ANALYZE会分析当前数据库中的每个表和分区表。同时也可以通
过指定table_name、column和partition_name参数把分析限定在特定的表、列或分区表
中。
注意事项
ANALYZE非临时表不能在一个匿名块、事务块、函数或存储过程内被执行。支持存储
过程中ANALYZE临时表,不支持统计信息回滚操作。
语法格式
l
收集表的统计信息。
{ ANALYZE | ANALYSE } [ VERBOSE ]
[ table_name [ ( column_name [, ...] ) ] ];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
764GaussDB 200
开发者指南
16 SQL 参考
l
收集分区表的统计信息。
{ ANALYZE | ANALYSE } [ VERBOSE ]
[ table_name [ ( column_name [, ...] ) ] ]
PARTITION ( patrition_name ) ;
说明
普通分区表目前支持针对某个分区的统计信息的语法,但功能上不支持针对某个分区的统
计信息收集。
l
收集外表的统计信息。
{ ANALYZE | ANALYSE } [ VERBOSE ]
{ foreign_table_name | FOREIGN TABLES };
l
收集多列统计信息
{ANALYZE | ANALYSE} [ VERBOSE ]
table_name (( column_1_name, column_2_name [, ...] ));
说明
l 收集多列统计信息时,请设置GUC参数default_statistics_target为负数,以使用百分比
采样方式。
l 每组多列统计信息最多支持32列。
l 不支持收集多列统计信息的表:系统表、HDFS外表复制表。
l 在逻辑集群模式下,只有管理员用户可以对数据库中所有表执行analyze,关联逻辑集群
的用户只会对逻辑集群范围的表收集统计信息。
参数说明
l
VERBOSE
启用显示进度信息。
说明
如果指定了VERBOSE,ANALYZE发出进度信息,表明目前正在处理的表。各种有关表的
统计信息也会打印出来。
l
table_name
需要分析的特定表的表名(可能会带模式名),如果省略,将对数据库中的所有
表(非外部表)进行分析。
对于ANALYZE收集统计信息,目前仅支持行存表、列存表、HDFS表、orc格式的
OBS外表、协同分析的外表。
取值范围:已有的表名。
l
column_name,column_1_name,column_2_name
需要分析特定列的列名,默认为所有列。
取值范围:已有的列名。
l
partition_name
如果table为分区表,在关键字PARTITION后面指定分区名partition_name表示分析
该分区表的统计信息。目前语法上支持分区表做ANALYZE,但功能实现上暂不支
持对指定分区统计信息的分析。
取值范围:表的某一个分区名。
l
foreign_table_name
需要分析的特定表的表名(可能会带模式名),该表的数据存放于HDFS分布式文
件系统中。
取值范围:已有的表名。
l
FOREIGN TABLES
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
765GaussDB 200
开发者指南
16 SQL 参考
分析所有当前用户权限下,数据位于HDFS分布式文件系统中的HDFS外表。
示例
--- 创建表。
postgres=# CREATE TABLE customer_info
(
WR_RETURNED_DATE_SK
INTEGER
WR_RETURNED_TIME_SK
INTEGER
WR_ITEM_SK
INTEGER
WR_REFUNDED_CUSTOMER_SK
INTEGER
)
DISTRIBUTE BY HASH (WR_ITEM_SK);
,
,
NOT NULL,
--- 创建分区表。
postgres=# CREATE TABLE customer_par
(
WR_RETURNED_DATE_SK
INTEGER
WR_RETURNED_TIME_SK
INTEGER
WR_ITEM_SK
INTEGER
WR_REFUNDED_CUSTOMER_SK
INTEGER
)
DISTRIBUTE BY HASH (WR_ITEM_SK)
PARTITION BY RANGE(WR_RETURNED_DATE_SK)
(
PARTITION P1 VALUES LESS THAN(2452275),
PARTITION P2 VALUES LESS THAN(2452640),
PARTITION P3 VALUES LESS THAN(2453000),
PARTITION P4 VALUES LESS THAN(MAXVALUE)
)
ENABLE ROW MOVEMENT;
,
,
NOT NULL,
--- 使用ANALYZE语句更新统计信息。
postgres=# ANALYZE customer;
--- 使用ANALYZE VERBOSE语句更新统计信息,并输出表的相关信息。
postgres=# ANALYZE VERBOSE customer_info;
INFO: analyzing "cstore.pg_delta_3394584009"(cn_5002 pid=53078)
INFO: analyzing "public.customer_info"(cn_5002 pid=53078)
INFO: analyzing "public.customer_info" inheritance tree(cn_5002 pid=53078)
ANALYZE
说明
若环境若有故障,需查看CN的log。
--- 删除表。
postgres=# DROP TABLE customer;
postgres=# DROP TABLE customer_par;
16.14.35 BEGIN
功能描述
BEGIN可以用于开始一个匿名块,也可以用于开始一个事务。本节描述用BEGIN开始
匿名块的语法,以BEGIN开始事务的语法见16.14.136 START TRANSACTION。
匿名块是能够动态地创建和执行过程代码的结构,而不需要以持久化的方式将代码作
为数据库对象储存在数据库中。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
766GaussDB 200
开发者指南
16 SQL 参考
注意事项
无。
语法格式
l
开启匿名块
[DECLARE [declare_statements]]
BEGIN
execution_statements
END;
/
l
开启事务
BEGIN [ WORK | TRANSACTION ]
[
{
ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ }
| { READ WRITE | READ ONLY }
} [, ...]
];
参数说明
l
declare_statements
声明变量,包括变量名和变量类型,如“sales_cnt int”。
l
execution_statements
匿名块中要执行的语句。
取值范围:已存在的函数名称。
示例
--使用匿名块输出字符串。
BEGIN
dbms_output.put_line('Hello');
END;
/
相关链接
16.14.136 START TRANSACTION
16.14.36 CALL
功能描述
使用CALL命令可以调用已定义的函数和存储过程。
注意事项
无。
语法格式
CALL [schema.] {func_name| procedure_name} ( param_expr );
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
767GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
schema
函数或存储过程所在的模式名称。
l
func_name
所调用函数或存储过程的名称。
取值范围:已存在的函数名称。
l
param_expr
参数列表可以用符号":="或者"=>"将参数名和参数值隔开,这种方法的好处是参数
可以以任意顺序排列。若参数列表中仅出现参数值,则参数值的排列顺序必须和
函数或存储过程定义时的相同。
取值范围:已存在的函数参数名称或存储过程参数名称。
说明
参数可以包含入参(参数名和类型之间指定“IN”关键字)和出参(参数名和类型之间指
定“OUT”关键字),使用CALL命令调用函数或存储过程时,对于非重载的函数,参数
列表必须包含出参,出参可以传入一个变量或者任一常量,详见示例。对于重载的package
函数,参数列表里可以忽略出参,忽略出参时可能会导致函数找不到。包含出参时,出参
只能是常量。
示例
--创建一个函数func_add_sql,计算两个整数的和,并返回结果。
CREATE FUNCTION func_add_sql(num1 integer, num2 integer) RETURN integer
AS
BEGIN
RETURN num1 + num2;
END;
/
--按参数值传递。
CALL func_add_sql(1, 3);
--使用命名标记法传参。
CALL func_add_sql(num1 => 1,num2 => 3);
CALL func_add_sql(num2 := 2, num1 := 3);
--删除函数。
DROP FUNCTION func_add_sql;
--创建带出参的函数。
CREATE FUNCTION func_increment_sql(num1 IN integer, num2 IN integer, res OUT integer)
RETURN integer
AS
BEGIN
res := num1 + num2;
END;
/
--出参传入常量。
CALL func_increment_sql(1,2,1);
--出参传入变量。
DECLARE
res int;
BEGIN
func_increment_sql(1, 2, res);
dbms_output.put_line(res);
END;
/
--创建重载的函数。
create or replace procedure package_func_overload(col int, col2 out int) package
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
768GaussDB 200
开发者指南
16 SQL 参考
as
declare
col_type text;
begin
col := 122;
dbms_output.put_line('two out parameters ' || col2);
end;
/
create or replace procedure package_func_overload(col int, col2 out varchar)
package
as
declare
col_type text;
begin
col2 := '122';
dbms_output.put_line('two varchar parameters ' || col2);
end;
/
--函数调用。
call package_func_overload(1, 'test');
call package_func_overload(1, 1);
--删除函数。
DROP FUNCTION func_increment_sql;
16.14.37 CHECKPOINT
功能描述
检查点(CHECKPOINT)是一个事务日志中的点,所有数据文件都在该点被更新以反
映日志中的信息,所有数据文件都将被刷新到磁盘。
设置事务日志检查点。预写式日志(WAL)缺省时在事务日志中每隔一段时间放置一
个检查点。可以使用gs_guc命令设置相关运行时参数(checkpoint_segments和
checkpoint_timeout)来调整这个原子化检查点的间隔。
注意事项
l 只有系统管理员可以调用CHECKPOINT。
l CHECKPOINT强迫立即进行检查,而不是等到下一次调度时的检查点。
语法格式
CHECKPOINT;
参数说明
无。
示例
--设置检查点。
CHECKPOINT;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
769GaussDB 200
开发者指南
16 SQL 参考
16.14.38 CLEAN CONNECTION
功能描述
当数据库有异常时,用来清理数据库连接。允许在指定节点上清理指定数据库的指定
用户的相关连接。
注意事项
无
语法格式
CLEAN CONNECTION
TO { COORDINATOR ( nodename [, ... ] ) | NODE ( nodename [, ... ] )| ALL [ CHECK ] [ FORCE ] }
[ FOR DATABASE dbname ]
[ TO USER username ];
参数说明
l
CHECK
仅在节点列表为TO ALL时可以指定。如果指定该参数,会在清理连接之前检查数
据库是否被其他会话连接访问。此参数主要用于DROP DATABASE之前的连接访
问检查,如果发现有其他会话连接,则将报错并停止删除数据库。
l
FORCE
仅在节点列表为TO ALL时可以指定,如果指定该参数,所有和指定dbname和
username相关的线程都会收到SIGTERM信号,然后被强制关闭。
l
COORDINATOR ( nodename ,nodename ... } ) | NODE ( nodename , nodename ... )
| ALL
删除指定节点上的连接。有三种场景:
– 删除指定CN上的连接。
– 删除指定DN上的连接。
– 删除所有节点上的连接,包括CN和DN。
取值范围:可替换其中的nodename为已存在的节点名。
l
dbname
删除指定数据库上的连接。如果不指定,则删除所有数据库的连接。
取值范围:已存在数据库名。
l
username
删除指定用户上的连接。如果不指定,则删除所有用户的连接。
取值范围:已存在的用户。
示例
--创建jack用户。
CREATE USER jack PASSWORD 'Bigdata123@';
--删除数据库template1在dn1和dn2节点上的连接。
CLEAN CONNECTION TO NODE (dn_6001_6002,dn_6003_6004) FOR DATABASE template1;
--删除用户jack在dn1节点上的连接。
CLEAN CONNECTION TO NODE (dn_6001_6002) TO USER jack;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
770GaussDB 200
开发者指南
16 SQL 参考
--删除在数据库postgres上的所有连接。
CLEAN CONNECTION TO ALL FORCE FOR DATABASE postgres;
--删除用户jack。
DROP USER jack;
16.14.39 CLOSE
功能描述
CLOSE释放和一个游标关联的所有资源。
注意事项
l 不允许对一个已关闭的游标再做任何操作。
l 一个不再使用的游标应该尽早关闭。
l 当创建游标的事务用COMMIT或ROLLBACK终止之后,每个不可保持的已打开游
标都隐含关闭。
l 当创建游标的事务通过ROLLBACK退出之后,每个可以保持的游标都将隐含关
闭。
l 当创建游标的事务成功提交,可保持的游标将保持打开,直到执行一个明确的
CLOSE或者客户端断开。
l GaussDB 200没有明确打开游标的OPEN语句,因为一个游标在使用CURSOR命令
定义的时候就打开了。可以通过查询系统视图pg_cursors看到所有可用的游标。
语法格式
CLOSE { cursor_name | ALL } ;
参数说明
l
cursor_name
一个待关闭的游标名称。
l
ALL
关闭所有已打开的游标。
示例
请参考FETCH的示例。
相关链接
16.14.111 FETCH,16.14.115 MOVE
16.14.40 CLUSTER
功能描述
根据一个索引对表进行聚簇排序。
CLUSTER指定GaussDB 200通过索引名指定的索引聚簇由表名指定的表。 表名上必须
已经定义该索引。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
771GaussDB 200
开发者指南
16 SQL 参考
当对一个表聚集后,该表将基于索引信息进行物理存储。聚集是一次性操作:当表被
更新之后, 更改的内容不会被聚集。也就是说,系统不会试图按照索引顺序对新的存
储内容及更新记录进行重新聚集。
在对一个表聚簇之后,GaussDB 200会记录在哪个索引上建立了聚集。 CLUSTER
table_name的聚集形式在之前的同一个索引的表上重新聚集。用户也可以用ALTER
TABLE的CLUSTER或SET WITHOUT CLUSTER形式来设置索引来用于后续的聚集操
作或清除任何之前的设置。
不含参数的CLUSTER会将当前用户所拥有的数据库中的先前做过聚簇的所有表重新处
理,或者系统管理员调用的这些表。
在对一个表进行聚簇的时候,会在其上请求一个ACCESS EXCLUSIVE锁。这样就避免
了在CLUSTER完成之前对此表执行其它的操作(包括读写)。
注意事项
只有行存B-tree索引支持CLUSTER操作。
如果用户只是随机访问表中的行,那么表中数据的实际存储顺序是无关紧要的。但
是, 如果对某些数据的访问多于其它数据,而且有一个索引将这些数据分组, 那么将
使用CLUSTER中会有所帮助。如果从一个表中请求一定索引范围的值, 或者是一个索
引值对应多行,CLUSTER也会有助于应用,因为如果索引标识出第一匹配行所在的存
储页,所有其它行也可能已经在同一个存储页里了,这样便节省了磁盘访问的时间,
加速了查询。
在聚簇过程中,系统先创建一个按照索引顺序建立的表的临时拷贝。同时也建立表上
的每个索引的临时拷贝。因此,需要磁盘上有足够的剩余空间, 至少是表大小和索引
大小的和。
因为CLUSTER记忆聚集信息,可以在第一次的时候手工对表进行聚簇,然后设置一个
类似VACUUM的时间,这样就可以周期地自动对表进行聚簇操作。
因为优化器记录着有关表的排序的统计,所以建议在新近聚簇的表上运行ANALYZE。
否则,优化器可能会选择很差劲的查询规划。
CLUSTER不允许在事务中执行。
语法格式
l
对一个表进行聚簇排序。
CLUSTER [ VERBOSE ] table_name [ USING index_name ];
l
对一个分区进行聚簇排序。
CLUSTER [ VERBOSE ] table_name PARTITION ( partition_name ) [ USING index_name ];
l
对已做过聚簇的表重新进行聚簇。
CLUSTER [ VERBOSE ];
参数说明
l
VERBOSE
启用显示进度信息。
l
table_name
表名称。
取值范围:已存在的表名称。
l
index_name
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
772GaussDB 200
开发者指南
16 SQL 参考
索引名称。
取值范围:已存在的索引名称。
l
partition_name
分区名称。
取值范围:已存在的分区名称。
示例
-- 创建一个分区表。
CREATE TABLE tpcds.inventory_p1
(
INV_DATE_SK
INTEGER
INV_ITEM_SK
INTEGER
INV_WAREHOUSE_SK
INTEGER
INV_QUANTITY_ON_HAND
INTEGER
)
DISTRIBUTE BY HASH(INV_ITEM_SK)
PARTITION BY RANGE(INV_DATE_SK)
(
PARTITION P1 VALUES LESS THAN(2451179),
PARTITION P2 VALUES LESS THAN(2451544),
PARTITION P3 VALUES LESS THAN(2451910),
PARTITION P4 VALUES LESS THAN(2452275),
PARTITION P5 VALUES LESS THAN(2452640),
PARTITION P6 VALUES LESS THAN(2453005),
PARTITION P7 VALUES LESS THAN(MAXVALUE)
);
NOT NULL,
NOT NULL,
NOT NULL,
-- 创建索引ds_inventory_p1_index1。
CREATE INDEX ds_inventory_p1_index1 ON tpcds.inventory_p1 (INV_ITEM_SK) LOCAL;
-- 对表tpcds.inventory_p1进行聚集。
CLUSTER tpcds.inventory_p1 USING ds_inventory_p1_index1;
-- 对分区p3进行聚集。
CLUSTER tpcds.inventory_p1 PARTITION (p3) USING ds_inventory_p1_index1;
-- 对数据库中可以进行聚集的表进聚集。
CLUSTER;
--删除索引。
DROP INDEX tpcds.ds_inventory_p1_index1;
--删除分区表。
DROP TABLE tpcds.inventory_p1;
16.14.41 COMMENT
功能描述
定义或修改一个对象的注释。
注意事项
l 每个对象只存储一条注释,因此要修改一个注释,对同一个对象发出一条新的
COMMENT命令即可。要删除注释,在文本字符串的位置写上NULL即可。当删
除对象时,注释自动被删除掉。
l 目前注释浏览没有安全机制:任何连接到某数据库上的用户都可以看到所有该数
据库对象的注释。共享对象(比如数据库、角色、表空间)的注释是全局存储
的,连接到任何数据库的任何用户都可以看到它们。因此,不要在注释里存放与
安全有关的敏感信息。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
773GaussDB 200
开发者指南
16 SQL 参考
l
对大多数对象,只有对象的所有者可以设置注释。角色没有所有者,所以
COMMENT ON ROLE命令仅可以由系统管理员对系统管理员角色执行,有
CREATEROLE权限的角色也可以为非系统管理员角色设置注释。系统管理员可以
对所有对象进行注释。
语法格式
COMMENT ON
{
AGGREGATE agg_name (agg_type [, ...] ) |
CAST (source_type AS target_type) |
COLLATION object_name |
COLUMN { table_name.column_name | view_name.column_name } |
CONSTRAINT constraint_name ON table_name |
CONVERSION object_name |
DATABASE object_name |
DOMAIN object_name |
EXTENSION object_name |
FOREIGN DATA WRAPPER object_name |
FOREIGN TABLE object_name |
FUNCTION function_name ( [ {[ argmode ] [ argname ] argtype} [, ...] ] ) |
INDEX object_name |
LARGE OBJECT large_object_oid |
OPERATOR operator_name (left_type, right_type) |
OPERATOR CLASS object_name USING index_method |
OPERATOR FAMILY object_name USING index_method |
[ PROCEDURAL ] LANGUAGE object_name |
ROLE object_name |
RULE rule_name ON table_name |
SCHEMA object_name |
SERVER object_name |
TABLE object_name |
TABLESPACE object_name |
TEXT SEARCH CONFIGURATION object_name |
TEXT SEARCH DICTIONARY object_name |
TEXT SEARCH PARSER object_name |
TEXT SEARCH TEMPLATE object_name |
TYPE object_name |
VIEW object_name
}
IS 'text';
参数说明
l
agg_name
聚集函数的名称
l
agg_type
聚集函数参数的类型
l
source_type
类型转换的源数据类型。
l
target_type
类型转换的目标数据类型。
l
object_name
对象名。
l
table_name.column_name
view_name.column_name
定义/修改注释的列名称。前缀可加表名称或者视图名称。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
774GaussDB 200
开发者指南
16 SQL 参考
l
constraint_name
定义/修改注释的表约束的名称。
l
table_name
表的名称。
l
function_name
定义/修改注释的函数名称。
l
argmode,argname,argtype
函数参数的模式、名称、类型。
l
large_object_oid
定义/修改注释的大对象的OID值。
l
operator_name
操作符名称。
l
left_type,right_type
操作参数的数据类型(可以用模式修饰)。当前置或者后置操作符不存在时,可
以增加NONE选项。
l
text
注释。
示例
CREATE TABLE tpcds.customer_demographics_t2
(
CD_DEMO_SK
INTEGER
CD_GENDER
CHAR(1)
CD_MARITAL_STATUS
CHAR(1)
CD_EDUCATION_STATUS
CHAR(20)
CD_PURCHASE_ESTIMATE
INTEGER
CD_CREDIT_RATING
CHAR(10)
CD_DEP_COUNT
INTEGER
CD_DEP_EMPLOYED_COUNT
INTEGER
CD_DEP_COLLEGE_COUNT
INTEGER
)
WITH (ORIENTATION = COLUMN,COMPRESSION=MIDDLE)
DISTRIBUTE BY HASH (CD_DEMO_SK);
NOT NULL,
,
,
,
,
,
,
,
-- 为tpcds.customer_demographics_t2.cd_demo_sk列加注释。
COMMENT ON COLUMN tpcds.customer_demographics_t2.cd_demo_sk IS 'Primary key of customer
demographics table.';
--创建一个由c_customer_sk小于150的内容组成的视图。
CREATE VIEW tpcds.customer_details_view_v2 AS
SELECT *
FROM tpcds.customer
WHERE c_customer_sk < 150;
-- 为tpcds.customer_details_view_v2视图加注释。
COMMENT ON VIEW tpcds.customer_details_view_v2 IS 'View of customer detail';
-- 删除view。
DROP VIEW tpcds.customer_details_view_v2;
-- 删除tpcds.customer_demographics_t2。
DROP TABLE tpcds.customer_demographics_t2;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
775GaussDB 200
开发者指南
16 SQL 参考
16.14.42 COMMIT | END
功能描述
通过COMMIT或者END可完成提交事务的功能,即提交事务的所有操作。
注意事项
执行COMMIT这个命令的时候,命令执行者必须是该事务的创建者或系统管理员,且
创建和提交操作可以不在同一个会话中。
语法格式
{ COMMIT | END } [ WORK | TRANSACTION ] ;
参数说明
l
COMMIT | END
提交当前事务,让所有当前事务的更改为其他事务可见。
l
WORK | TRANSACTION
可选关键字,除了增加可读性没有其他任何作用。
示例
--创建表。
CREATE TABLE tpcds.customer_demographics_t2
(
CD_DEMO_SK
INTEGER
CD_GENDER
CHAR(1)
CD_MARITAL_STATUS
CHAR(1)
CD_EDUCATION_STATUS
CHAR(20)
CD_PURCHASE_ESTIMATE
INTEGER
CD_CREDIT_RATING
CHAR(10)
CD_DEP_COUNT
INTEGER
CD_DEP_EMPLOYED_COUNT
INTEGER
CD_DEP_COLLEGE_COUNT
INTEGER
)
WITH (ORIENTATION = COLUMN,COMPRESSION=MIDDLE)
DISTRIBUTE BY HASH (CD_DEMO_SK);
NOT NULL,
,
,
,
,
,
,
,
--开启事务。
START TRANSACTION;
--插入数据。
INSERT INTO tpcds.customer_demographics_t2 VALUES(1,'M', 'U', 'DOCTOR DEGREE', 1200, 'GOOD', 1, 0,
0);
INSERT INTO tpcds.customer_demographics_t2 VALUES(2,'F', 'U', 'MASTER DEGREE', 300, 'BAD', 1, 0,
0);
--提交事务,让所有更改永久化。
COMMIT;
--查询数据。
SELECT * FROM tpcds.customer_demographics_t2;
--删除表tpcds.customer_demographics_t2。
DROP TABLE tpcds.customer_demographics_t2;
相关链接
16.14.124 ROLLBACK
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
776GaussDB 200
开发者指南
16 SQL 参考
16.14.43 COMMIT PREPARED
功能描述
提交一个早先为两阶段提交准备好的事务。
注意事项
l 该功能仅在维护模式(GUC参数xc_maintenance_mode为on时)下可用。该模式谨慎
打开,一般供维护人员排查问题使用,一般用户不应使用该模式。
l 命令执行者必须是该事务的创建者或系统管理员,且创建和提交操作可以不在同
一个会话中。
l 事务功能由数据库自动维护,不应显式使用事务功能。
语法格式
COMMIT PREPARED transaction_id ;
COMMIT PREPARED transaction_id WITH CSN;
参数说明
l
transaction_id
待提交事务的标识符。它不能和任何当前预备事务已经使用了的标识符同名。
l
CSN(commit sequence number)
待提交事务的序列号。它是一个64位递增无符号数。
相关链接
16.14.118 PREPARE TRANSACTION,16.14.125 ROLLBACK PREPARED。
16.14.44 COPY
功能描述
通过COPY命令实现在表和文件之间拷贝数据。
COPY FROM从一个文件拷贝数据到一个表,COPY TO把一个表的数据拷贝到一个文
件。
注意事项
l 当前模式下禁止使用COPY FROM FILENAME或COPY TO FILENAME语法。
l COPY只能用于表,不能用于视图。
l 对任何要插入数据的表必须有插入权限。
l 如果声明了一个字段列表,COPY将只在文件和表之间拷贝已声明字段的数据。如
果表中有任何不在字段列表里的字段,COPY FROM将为那些字段插入缺省值。
l 如果声明了数据源文件,服务器必须可以访问该文件;如果指定了STDIN,数据
将在客户前端和服务器之间流动,输入时,表的列与列之间使用TAB键分隔,在
新的一行中以反斜杠和句点(\.)表示输入结束。
l 如果数据文件的任意行包含比预期多或者少的字段,COPY FROM将抛出一个错
误。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
777GaussDB 200
开发者指南
16 SQL 参考
l 数据的结束可以用一个只包含反斜杠和句点(\.)的行表示。如果从文件中读取数
据,数据结束的标记是不必要的;如果在客户端应用之间拷贝数据,必须要有结
束标记。
l COPY FROM中\N为空字符串,如果要输入实际数据值\N ,使用\\N。
l COPY FROM不支持在导入过程中对数据做预处理(比如说表达式运算,填充指定
默认值等)。如果需要在导入过程中对数据做预处理,用户需先把数据导入到临
时表中,然后执行SQL语句通过运算插入到表中,但此方法会导致I/O膨胀,降低
导入性能。
l COPY FROM在遇到数据格式错误时会回滚事务,但没有足够的错误信息,不方便
用户从大量的原始数据中定位错误数据。
l COPY FROM/TO适合低并发,本地小数据量导入导出。
语法格式
l
从一个文件拷贝数据到一个表。
COPY table_name [ ( column_name [, ...] ) ]
FROM { 'filename' | STDIN }
[ [ USING ] DELIMITERS 'delimiters' ]
[ WITHOUT ESCAPING ]
[ LOG ERRORS ]
[ REJECT LIMIT 'limit' ]
[ [ WITH ] ( option [, ...] ) ]
| copy_option
| FIXED FORMATTER ( { column_name( offset, length ) } [, ...] ) [ ( option [, ...] ) |
copy_option [ ...] ] ];
说明
语法中的FIXED FORMATTER ( { column_name( offset, length ) } [, ...] )以及 [ ( option [, ...] ) |
copy_option [ ...] ] 可以任意排列组合。
l
把一个表的数据拷贝到一个文件。
COPY table_name [ ( column_name [, ...] ) ]
TO { 'filename' | STDOUT }
[ [ USING ] DELIMITERS 'delimiters' ]
[ WITHOUT ESCAPING ]
[ [ WITH ] ( option [, ...] ) ]
| copy_option
| FIXED FORMATTER ( { column_name( offset, length ) } [, ...] ) [ ( option [, ...] ) |
copy_option [ ...] ] ];
COPY query
TO { 'filename' | STDOUT }
[ WITHOUT ESCAPING ]
[ [ WITH ] ( option [, ...] ) ]
| copy_option
| FIXED FORMATTER ( { column_name( offset, length ) } [, ...] ) [ ( option [, ...] ) |
copy_option [ ...] ] ];
说明
1. COPY TO语法形式约束如下:
(query)与[USING] DELIMITER不兼容,即若COPY TO的数据来自于一个query的查询结
果,那么COPY TO语法不能再指定[USING] DELIMITERS语法子句。
2. 对于FIXED FORMATTTER语法后面跟随的copy_option是以空格进行分隔的。
3. copy_option是指COPY原生的参数形式,而option是兼容外表导入的参数形式。
4. 语法中的FIXED FORMATTER ( { column_name( offset, length ) } [, ...] )以及 [ ( option
[, ...] ) | copy_option [ ...] ] 可以任意排列组合。
其中可选参数option子句语法为:
FORMAT 'format_name'
| OIDS [ boolean ]
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
778GaussDB 200
开发者指南
16 SQL 参考
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
DELIMITER 'delimiter_character'
NULL 'null_string'
HEADER [ boolean ]
FILEHEADER 'header_file_string'
FREEZE [ boolean ]
QUOTE 'quote_character'
ESCAPE 'escape_character'
EOL 'newline_character'
NOESCAPING [ boolean ]
FORCE_QUOTE { ( column_name [, ...] ) | * }
FORCE_NOT_NULL ( column_name [, ...] )
ENCODING 'encoding_name'
IGNORE_EXTRA_DATA [ boolean ]
FILL_MISSING_FIELDS [ boolean ]
COMPATIBLE_ILLEGAL_CHARS [ boolean ]
DATE_FORMAT 'date_format_string'
TIME_FORMAT 'time_format_string'
TIMESTAMP_FORMAT 'timestamp_format_string'
SMALLDATETIME_FORMAT 'smalldatetime_format_string'
其中可选参数copy_option子句语法为:
OIDS
| NULL 'null_string'
| HEADER
| FILEHEADER 'header_file_string'
| FREEZE
| FORCE_NOT_NULL column_name [, ...]
| FORCE_QUOTE { column_name [, ...] | * }
| BINARY
| CSV
| QUOTE [ AS ] 'quote_character'
| ESCAPE [ AS ] 'escape_character'
| EOL 'newline_character'
| ENCODING 'encoding_name'
| IGNORE_EXTRA_DATA
| FILL_MISSING_FIELDS
| COMPATIBLE_ILLEGAL_CHARS
| DATE_FORMAT 'date_format_string'
| TIME_FORMAT 'time_format_string'
| TIMESTAMP_FORMAT 'timestamp_format_string'
| SMALLDATETIME_FORMAT 'smalldatetime_format_string'
参数说明
l
query
其结果将被拷贝。
取值范围:一个必须用圆括弧包围的SELECT或VALUES命令。
l
table_name
表的名字(可以有模式修饰)。
取值范围:已存在的表名。
l
column_name
可选的待拷贝字段列表。
取值范围:如果没有声明字段列表,将使用所有字段。
l
STDIN
声明输入是来自标准输入。
l
STDOUT
声明输出打印到标准输出。
l
FIXED
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
779GaussDB 200
开发者指南
16 SQL 参考
打开字段固定长度模式。在字段固定长度模式下,不能声明DELIMITER,
NULL,CSV选项。指定FIXED类型后,不能再通过option或copy_option指定
BINARY、CSV、TEXT等类型。
说明
定长格式定义如下:
1. 每条记录的每个字段长度相同。
2. 长度不足的字段以空格填充,数字类型字段左对齐,字符字段右对齐。
3. 字段和字段之间没有分隔符。
l
[USING] DELIMITER 'delimiters'
在文件中分隔各个字段的字符串,分隔符最大长度不超过10个字节。
取值范围:不允许包含\.abcdefghijklmnopqrstuvwxyz0123456789中的任何一个字
符。
缺省值:在文本模式下,缺省是水平制表符,在CSV模式下是一个逗号。
l
WITHOUT ESCAPING
在TEXT格式中,不对'\'和后面的字符进行转义。
取值范围:仅支持TEXT格式。
l
LOG ERRORS
若指定,则开启对于COPY FROM语句中数据类型错误的容错机制,相关错误行的
错误记录会记录到此库中public.pgxc_copy_error_log表中,备后续查阅。
取值范围:仅支持导入(即COPY FROM)时指定。
说明
此容错选项的使用限制如下:
l 此容错机制仅捕捉COPY FROM过程中CN节点上数据解析过程中相关的数据类型错误
(DATA_EXCEPTION),诸如CN与DN之间的网络交互错误或者是DN上的表达式转换
错误等CN数据解析逻辑之外的过程无法涵盖在内。
l 在每个库第一次使用时COPY FROM容错时,请先行检查public.pgxc_copy_error_log
(COPY错误表)是否存在,若不存在请调用copy_error_log_create() 函数创建;若存
在,请转移此表数据并删除这张表后,调用copy_error_log_create() 函数创建。更多关于
表public.pgxc_copy_error_log的字段信息,请参见表16-34。
l 若在指定了LOG ERRORS的COPY FROM运行时,public.pgxc_copy_error_log不存在
(未创建或者已删除)或表定义不符合copy_error_log_create() 中的预设表定义,则会报
错。因此请确定此COPY错误表是使用copy_error_log_create() 函数创建的,否则可能导
致容错的COPY FROM语句无法正常执行。
l COPY已有的容错选项(如IGNORE_EXTRA_DATA)开启时,对应类型的错误会按照
已有的方式处理而不会报出异常,因此错误表也不会有相应数据。
l 此容错机制的覆盖范围与GDS Foreign Table的容错范围相同。推荐用户通过表名列以及
COPY FROM语句开始时间戳对查询结果进行过滤。错误数据处理可参考8.1.7 处理错误
表。
l
REJECT LIMIT 'limit'
与LOG ERROR选项共同使用,对COPY FROM的容错机制设置数值上限,一旦此
COPY FROM语句错误数据超过选项指定条数,则会按照原有机制报错。
取值范围:正整数(1-INTMAX),'unlimited'(无最大值限制)
缺省值:若未指定LOG ERRORS,则会报错;若指定LOG ERRORS,则默认为
0。
说明
如上述LOG ERRORS中描述的容错机制,REJECT LIMIT的计数也是按照执行COPY FROM
的CN上遇到的解析错误数量计算,而不是每个DN上的错误数量,这点请与GDS容错机制
区别开。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
780GaussDB 200
开发者指南
16 SQL 参考
l
FORMATTER
在固定长度模式中,定义每一个字段在数据文件中的位置。按照
column(offset,length)格式定义每一列在数据文件中的位置。
取值范围:
– offset取值不能小于0,以字节为单位。
– length取值不能小于0,以字节为单位。
所有列的总长度和不能大于1GB。
文件中没有出现的列默认以空值代替。
l
OPTION { option_name ' value ' }
用于指定兼容外表的各类参数。
–
FORMAT
数据源文件的格式。
取值范围:CSV、TEXT、FIXED、BINARY。
n CSV格式的文件,可以有效处理数据列中的换行符,但对一些特殊字符
处理有欠缺。
n TEXT格式的文件,可以有效处理一些特殊字符,但无法正确处理数据列
中的换行符。
n FIXED格式的文件,适用于每条数据的数据列都比较固定的数据,长度
不足的列会添加空格补齐,过长的列则会自动截断。
n BINARY形式的选项会使得所有的数据被存储/读作二进制格式而不是文
本。 这比TEXT和CSV格式的要快一些,但是一个BINARY格式文件可移
植性比较差。
缺省值:TEXT
–
OIDS
为每行拷贝内部对象标识(oid)。
说明
若COPY FROM对象为query或者对于没有oid的表,指定oids标识报错。
取值范围:true/on,false/off。
缺省值:false
–
DELIMITER
指定数据文件行数据的字段分隔符。
说明
l 分隔符不能是\r和\n。
l 分隔符不能和null参数相同,CSV格式数据的分隔符不能和quote参数相同。
l TEXT格式数据的分隔符不能包含: 小写字母、数字和特殊字符.\。
l 数据文件中单行数据长度需<1GB,如果分隔符较长且数据列较多的情况下,会影
响导出有效数据的长度。
l 分隔符推荐使用多字符和不可见字符。多字符例如'$^&';不可见字符例如0x07,
0x08,0x1b等。
取值范围:支持多字符分隔符,但分隔符不能超过10个字节。
缺省值:
文档版本 01 (2019-08-01)
n TEXT格式的默认分隔符是水平制表符(tab)。
n CSV格式的默认分隔符为“,”。
版权所有 © 华为技术有限公司
781GaussDB 200
开发者指南
16 SQL 参考
n
–
FIXED格式没有分隔符。
NULL
用来指定数据文件中空值的表示。
取值范围:
n null值不能是\r和\n,最大为100个字符。
n null值不能和分隔符、quote参数相同。
缺省值:
–
n CSV格式下默认值是一个没有引号的空字符串。
n 在TEXT格式下默认值是\N。
HEADER
指定导出数据文件是否包含标题行,标题行一般用来描述表中每个字段的信
息。header只能用于CSV,FIXED格式的文件中。
在导入数据时,如果header选项为on,则数据文本第一行会被识别为标题行,
会忽略此行。如果header为off,而数据文件中第一行会被识别为数据。
在导出数据时,如果header选项为on,则需要指定fileheader。如果header为
off,则导出数据文件不包含标题行。
取值范围:true/on,false/off。
缺省值:false
–
QUOTE
CSV格式文件下的引号字符。
缺省值:双引号
说明
l quote参数不能和分隔符、null参数相同。
l quote参数只能是单字节的字符。
l 推荐不可见字符作为quote,例如0x07,0x08,0x1b等。
–
ESCAPE
CSV格式下,用来指定逃逸字符,逃逸字符只能指定为单字节字符。
缺省值:双引号。当与quote值相同时,会被替换为'\0'。
–
EOL 'newline_character'
指定导入导出数据文件换行符样式。
取值范围:支持多字符换行符,但换行符不能超过10个字节。常见的换行
符,如\r、\n、\r\n(设成0x0D、0x0A、0x0D0A效果是相同的),其他字符或
字符串,如$、#。
说明
l EOL参数只能用于TEXT格式的导入导出,不支持CSV格式和FIXED格式导入。为
了兼容原有EOL参数,仍然支持导出CSV格式和FIXED格式时指定EOL参数为
0x0D或0x0D0A。
l EOL参数不能和分隔符、null参数相同。
l EOL参数不能包含:.abcdefghijklmnopqrstuvwxyz0123456789。
–
FORCE_QUOTE { ( column_name [, ...] ) | * }
在CSV COPY TO模式下,强制在每个声明的字段周围对所有非NULL值都使
用引号包围。NULL输出不会被引号包围。
取值范围:已存在的字段。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
782GaussDB 200
开发者指南
16 SQL 参考
–
FORCE_NOT_NULL ( column_name [, ...] )
在CSV COPY FROM模式下,指定的字段输入不能为空。
取值范围:已存在的字段。
–
ENCODING
指定数据文件的编码格式名称,缺省为当前数据库编码格式。
–
IGNORE_EXTRA_DATA
若数据源文件比外表定义列数多,是否会忽略对多出的列。该参数只在数据
导入过程中使用。
取值范围:true/on、false/off。
n 参数为true/on,若数据源文件比外表定义列数多,则忽略行尾多出来的
列。
n 参数为false/off,若数据源文件比外表定义列数多,会显示如下错误信
息。
extra data after last expected column
缺省值:false。
如果行尾换行符丢失,使两行变成一行时,设置此参数为true将导致后一行数
据被忽略掉。
–
COMPATIBLE_ILLEGAL_CHARS
导入非法字符容错参数。此语法仅对COPY FROM导入有效。
取值范围:true/on,false/off。
n 参数为true/on,则导入时遇到非法字符进行容错处理,非法字符转换后
入库,不报错,不中断导入。
n 参数为false/off,导入时遇到非法字符进行报错,中断导入。
缺省值:false/off
说明
导入非法字符容错规则如下:
(1)对于'\0',容错后转换为空格;
(2)对于其他非法字符,容错后转换为问号;
(3)若compatible_illegal_chars为true/on标识导入时对于非法字符进行容错处理,则
若NULL、DELIMITER、QUOTE、ESCAPE设置为空格或问号则会通过如"illegal
chars conversion may confuse COPY escape 0x20"等报错信息提示用户修改可能引起混
淆的参数以避免导入错误。
–
FILL_MISSING_FIELD
当数据加载时,若数据源文件中一行的最后一个字段缺失的处理方式。
取值范围:true/on,false/off。
缺省值:false/off
–
DATE_FORMAT
导入对于DATE类型指定格式。此参数不支持BINARY格式,会报“cannot
specify bulkload compatibility options in BINARY mode”错误信息。此参数仅
对COPY FROM导入有效。
取值范围:合法DATE格式。可参考16.5.8 时间和日期处理函数和操作符。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
783GaussDB 200
开发者指南
16 SQL 参考
说明
对于指定为ORACLE兼容类型的数据库,则DATE类型内建为TIMESTAMP类型。在导
入的时候,若需指定格式,可以参考下面的timestamp_format参数。
–
TIME_FORMAT
导入对于TIME类型指定格式。此参数不支持BINARY格式,会报“cannot
specify bulkload compatibility options in BINARY mode”错误信息。此参数仅
对COPY FROM导入有效。
取值范围:合法TIME格式,不支持时区。可参考16.5.8 时间和日期处理函数
和操作符。
–
TIMESTAMP_FORMAT
导入对于TIMESTAMP类型指定格式。此参数不支持BINARY格式,会报
“cannot specify bulkload compatibility options in BINARY mode”错误信息。
此参数仅对COPY FROM导入有效。
取值范围:合法TIMESTAMP格式,不支持时区。可参考16.5.8 时间和日期处
理函数和操作符。
–
SMALLDATETIME_FORMAT
导入对于SMALLDATETIME类型指定格式。此参数不支持BINARY格式,会
报“cannot specify bulkload compatibility options in BINARY mode”错误信
息。此参数仅对COPY FROM导入有效。
取值范围:合法SMALLDATETIME格式。可参考16.5.8 时间和日期处理函数
和操作符。
l
COPY_OPTION { option_name ' value ' }
用于指定COPY原生的各类参数。
–
OIDS
为每行拷贝内部对象标识(oid)。
说明
若COPY FROM对象为query或者对于没有oid的表,指定oids标识报错。
–
NULL null_string
用来指定数据文件中空值的表示。
在使用COPY FROM的时候,任何匹配这个字符串的字符串将被存储为NULL
值,所以应该确保指定的字符串和COPY TO相同。
取值范围:
n null值不能是\r和\n,最大为100个字符。
n null值不能和分隔符、quote参数相同。
缺省值:
–
n 在TEXT格式下默认值是\N。
n CSV格式下默认值是一个没有引号的空字符串。
HEADER
指定导出数据文件是否包含标题行,标题行一般用来描述表中每个字段的信
息。header只能用于CSV,FIXED格式的文件中。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
784GaussDB 200
开发者指南
16 SQL 参考
在导入数据时,如果header选项为on,则数据文本第一行会被识别为标题行,
会忽略此行。如果header为off,而数据文件中第一行会被识别为数据。
在导出数据时,如果header选项为on,则需要指定fileheader。如果header为
off,则导出数据文件不包含标题行。
–
FILEHEADER
导出数据时用于定义标题行的文件,一般用来描述每一列的数据信息。
l 仅在header为on或true的情况下有效。
l fileheader指定的是绝对路径。
l 该文件只能包含一行标题信息,并以换行符结尾,多余的行将被丢弃(标
题信息不能包含换行符)。
l 该文件包括换行符在内长度不超过1M。
–
FREEZE
将COPY加载的数据行设置为已经被frozen,就像这些数据行执行过VACUUM
FREEZE。
这是一个初始数据加载的性能选项。仅当以下三个条件同时满足时,数据行
会被frozen:
n 在同一事务中create或truncate这张表之后执行COPY。
n 当前事务中没有打开的游标。
n 当前事务中没有原有的快照。
说明
COPY完成后,所有其他会话将会立刻看到这些数据。但是这违反了MVCC可见性的
一般原则,用户应当了解这样会导致潜在的风险。
–
FORCE NOT NULL column_name [, ...]
在CSV COPY FROM模式下,指定的字段输入不能为空。
取值范围:已存在的字段。
–
FORCE QUOTE { column_name [, ...] | * }
在CSV COPY TO模式下,强制在每个声明的字段周围对所有非NULL值都使
用引号包围。NULL输出不会被引号包围。
取值范围:已存在的字段。
–
BINARY
使用二进制格式存储和读取,而不是以文本的方式。在二进制模式下,不能
声明DELIMITER,NULL,CSV选项。指定BINARY类型后,不能再通过
option或copy_option指定CSV、FIXED、TEXT等类型。
–
CSV
打开逗号分隔变量(CSV)模式。指定CSV类型后,不能再通过option或
copy_option指定BINARY、FIXED、TEXT等类型。
–
QUOTE [AS] 'quote_character'
CSV格式文件下的引号字符。
缺省值:双引号。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
785GaussDB 200
开发者指南
16 SQL 参考
说明
l quote参数不能和分隔符、null参数相同。
l quote参数只能是单字节的字符。
l 推荐不可见字符作为quote,例如0x07,0x08,0x1b等。
–
ESCAPE [AS] 'escape_character'
CSV格式下,用来指定逃逸字符,逃逸字符只能指定为单字节字符。
默认值为双引号。当与quote值相同时,会被替换为'\0'。
–
EOL 'newline_character'
指定导入导出数据文件换行符样式。
取值范围:支持多字符换行符,但换行符不能超过10个字节。常见的换行
符,如\r、\n、\r\n(设成0x0D、0x0A、0x0D0A效果是相同的),其他字符或
字符串,如$、#。
说明
l EOL参数只能用于TEXT格式的导入导出,不支持CSV格式和FIXED格式。为了兼
容原有EOL参数,仍然支持导出CSV格式和FIXED格式时指定EOL参数为0x0D或
0x0D0A。
l EOL参数不能和分隔符、null参数相同。
l EOL参数不能包含:.abcdefghijklmnopqrstuvwxyz0123456789。
–
ENCODING 'encoding_name'
指定文件编码格式名称。
取值范围:有效的编码格式。
缺省值:当前编码格式。
–
IGNORE_EXTRA_DATA
指定当数据源文件比外表定义列数多时,忽略行尾多出来的列。该参数只在
数据导入过程中使用。
若不使用该参数,在数据源文件比外表定义列数多,会显示如下错误信息。
extra data after last expected column
–
COMPATIBLE_ILLEGAL_CHARS
指定导入时对非法字符进行容错处理,非法字符转换后入库。不报错,不中
断导入。此参数不支持BINARY格式,会报“cannot specify bulkload
compatibility options in BINARY mode”错误信息。此参数仅对COPY FROM
导入有效。
若不使用该参数,导入时遇到非法字符进行报错,中断导入。
说明
导入非法字符容错规则如下:
(1)对于'\0',容错后转换为空格;
(2)对于其他非法字符,容错后转换为问号;
(3)若compatible_illegal_chars为true/on标识,导入时对于非法字符进行容错处理,
则若NULL、DELIMITER、QUOTE、ESCAPE设置为空格或问号则会通过如"illegal
chars conversion may confuse COPY escape 0x20"等报错信息提示用户修改可能引起混
淆的参数以避免导入错误。
–
FILL_MISSING_FIELD
当数据加载时,若数据源文件中一行的最后一个字段缺失的处理方式。
取值范围:true/on,false/off。
缺省值:false/off。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
786GaussDB 200
开发者指南
16 SQL 参考
目前COPY指定此Option实际不会生效,即不会有相应的容错处理效果(不生
效)。需要额外注意的是,打开此选项会导致解析器在CN数据解析阶段(即
COPY错误表容错的涵盖范围)忽略此数据问题,而到DN重新报错,从而使
得COPY错误表(打开LOG ERRORS REJECT LIMIT)在此选项打开的情况下
无法成功捕获这类少列的数据异常。因此请不要指定此选项。
–
DATE_FORMAT 'date_format_string'
导入对于DATE类型指定格式。此参数不支持BINARY格式,会报“cannot
specify bulkload compatibility options in BINARY mode”错误信息。此参数仅
对COPY FROM导入有效。
取值范围:合法DATE格式。可参考16.5.8 时间和日期处理函数和操作符
说明
对于指定为ORACLE兼容类型的数据库,则DATE类型内建为TIMESTAMP类型。在导
入的时候,若需指定格式,可以参考下面的timestamp_format参数。
–
TIME_FORMAT 'time_format_string'
导入对于TIME类型指定格式。此参数不支持BINARY格式,会报“cannot
specify bulkload compatibility options in BINARY mode”错误信息。此参数仅
对COPY FROM导入有效。
取值范围:合法TIME格式,不支持时区。可参考16.5.8 时间和日期处理函数
和操作符。
–
TIMESTAMP_FORMAT 'timestamp_format_string'
导入对于TIMESTAMP类型指定格式。此参数不支持BINARY格式,会报
“cannot specify bulkload compatibility options in BINARY mode”错误信息。
此参数仅对COPY FROM导入有效。
取值范围:合法TIMESTAMP格式,不支持时区。可参考16.5.8 时间和日期处
理函数和操作符。
–
SMALLDATETIME_FORMAT 'smalldatetime_format_string'
导入对于SMALLDATETIME类型指定格式。此参数不支持BINARY格式,会
报“cannot specify bulkload compatibility options in BINARY mode”错误信
息。此参数仅对COPY FROM导入有效。
取值范围:合法SMALLDATETIME格式。可参考16.5.8 时间和日期处理函数
和操作符。
COPY FROM能够识别的特殊反斜杠序列如下所示。
– \b:反斜杠 (ASCII 8)
– \f:换页(ASCII 12)
– \n:换行符 (ASCII 10)
– \r:回车符 (ASCII 13)
– \t:水平制表符 (ASCII 9)
– \v:垂直制表符 (ASCII 11)
– \digits:反斜杠后面跟着一到三个八进制数,表示ASCII值为该数的字符。
– \xdigits:反斜杠x后面跟着一个或两个十六进制位声明指定数值编码的字符。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
787GaussDB 200
开发者指南
16 SQL 参考
示例
--将tpcds.ship_mode中的数据拷贝到/home/omm/ds_ship_mode.dat文件中。
COPY tpcds.ship_mode TO '/home/omm/ds_ship_mode.dat';
--将tpcds.ship_mode 输出到stdout。
COPY tpcds.ship_mode TO stdout;
--创建tpcds.ship_mode_t1表。
CREATE TABLE tpcds.ship_mode_t1
(
SM_SHIP_MODE_SK
INTEGER
SM_SHIP_MODE_ID
CHAR(16)
SM_TYPE
CHAR(30)
SM_CODE
CHAR(10)
SM_CARRIER
CHAR(20)
SM_CONTRACT
CHAR(20)
)
WITH (ORIENTATION = COLUMN,COMPRESSION=MIDDLE)
DISTRIBUTE BY HASH(SM_SHIP_MODE_SK );
NOT NULL,
NOT NULL,
,
,
,
--从stdin拷贝数据到表tpcds.ship_mode_t1。
COPY tpcds.ship_mode_t1 FROM stdin;
--从/home/omm/ds_ship_mode.dat文件拷贝数据到表tpcds.ship_mode_t1。
COPY tpcds.ship_mode_t1 FROM '/home/omm/ds_ship_mode.dat';
--从/home/omm/ds_ship_mode.dat文件拷贝数据到表tpcds.ship_mode_t1,使用参数如下:导入格式为TEXT
(format 'text'),分隔符为'\t'(delimiter E'\t'),忽略多余列(ignore_extra_data 'true'),不指定
转义(noescaping 'true')。
COPY tpcds.ship_mode_t1 FROM '/home/omm/ds_ship_mode.dat' WITH(format 'text', delimiter E'\t',
ignore_extra_data 'true', noescaping 'true');
--从/home/omm/ds_ship_mode.dat文件拷贝数据到表tpcds.ship_mode_t1,使用参数如下:导入格式为FIXED
(FIXED),指定定长格式(FORMATTER(SM_SHIP_MODE_SK(0, 2), SM_SHIP_MODE_ID(2,16), SM_TYPE(18,30),
SM_CODE(50,10), SM_CARRIER(61,20), SM_CONTRACT(82,20))),忽略多余列(ignore_extra_data),有数据头
(header)。
COPY tpcds.ship_mode_t1 FROM '/home/omm/ds_ship_mode.dat' FIXED FORMATTER(SM_SHIP_MODE_SK(0, 2),
SM_SHIP_MODE_ID(2,16), SM_TYPE(18,30), SM_CODE(50,10), SM_CARRIER(61,20), SM_CONTRACT(82,20))
header ignore_extra_data;
--删除tpcds.ship_mode_t1。
DROP TABLE tpcds.ship_mode_t1;
16.14.45 CREATE APP WORKLOAD GROUP MAPPING
功能描述
创建一个应用映射组,关联已创建的负载组。
注意事项
只要用户对当前数据库有CREATE权限,就可以创建应用映射组。
语法格式
CREATE APP WORKLOAD GROUP MAPPING app_name
[ WITH ( WORKLOAD_GPNAME = workload_gpname ) ];
参数说明
l
app_name
应用映射组名称。应用映射组名称不能和当前数据库里其他应用映射组重名。
取值范围:字符串,要符合标识符的命名规范。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
788GaussDB 200
开发者指南
16 SQL 参考
l
workload_gpname
负载组名称。
取值范围:字符串,已创建的负载组。
示例
-- 创建一个资源池,其控制组指定为"DefaultClass"组下属的"High" Timeshare Workload控制组。
CREATE RESOURCE POOL pool1 WITH (CONTROL_GROUP="High");
-- 创建一个负载组,关联已创建的资源池。
CREATE WORKLOAD GROUP group1 USING RESOURCE POOL pool1;
-- 创建一个应用映射组,关联已创建的负载组。
CREATE APP WORKLOAD GROUP MAPPING app_wg_map1 WITH (WORKLOAD_GPNAME=group1);
--创建一个默认应用映射组,关联默认的负载组。
CREATE APP WORKLOAD GROUP MAPPING app_wg_map2;
--删除应用映射组。
DROP APP WORKLOAD GROUP MAPPING app_wg_map1;
DROP APP WORKLOAD GROUP MAPPING app_wg_map2;
--删除负载组。
DROP WORKLOAD GROUP group1;
--删除资源池。
DROP RESOURCE POOL pool1;
相关链接
16.14.2 ALTER APP WORKLOAD GROUP MAPPING,16.14.81 DROP APP
WORKLOAD GROUP MAPPING
16.14.46 CREATE BARRIER
功能描述
创建一个新集群节点间的同步点。该同步点可用于数据恢复。
注意事项
在创建同步点之前,首先要确认集群中CN和DN的gtm_backup_barrier参数已设置为
on。
语法格式
CREATE BARRIER [ barrier_name ] ;
参数说明
barrier_name
可选参数。同步点名称。
取值范围:字符串,要符合标识符的命名规范。
示例
--创建一个barrier,不指定名称。
CREATE BARRIER;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
789GaussDB 200
开发者指南
16 SQL 参考
--指定barrier名称。
CREATE BARRIER 'barrier1';
16.14.47 CREATE DATABASE
功能描述
创建一个新的数据库。缺省情况下新数据库将通过复制标准系统数据库template1来创
建。可以通过TEMPLATE template指定不同的模板。
注意事项
l 只有拥有CREATEDB权限的用户才可以创建新数据库,系统管理员默认拥有此权
限。
l 不能在事务块中执行创建数据库语句。
l 在创建数据库过程中,若出现类似“could not initialize database directory”的错误
提示,可能是由于文件系统上数据目录的权限不足或磁盘满等原因引起。
语法格式
CREATE DATABASE database_name
[ [ WITH ] { [ OWNER [=] user_name ] |
[ TEMPLATE [=] template ] |
[ ENCODING [=] encoding ] |
[ LC_COLLATE [=] lc_collate ] |
[ LC_CTYPE [=] lc_ctype ] |
[ DBCOMPATIBILITY [=] compatibilty_type ] |
[ TABLESPACE [=] tablespace_name ] |
[ CONNECTION LIMIT [=] connlimit ]}[...] ];
参数说明
l
database_name
数据库名称。
取值范围:字符串,要符合标识符的命名规范。
l
OWNER [ = ] user_name
数据库所有者。缺省时,新数据库的所有者是当前用户。
取值范围:已存在的用户名。
l
TEMPLATE [ = ] template
模板名。即从哪个模板创建新数据库。GaussDB 200采用从模板数据库复制的方式
来创建新的数据库。初始时,GaussDB 200包含两个模板数据库template0、
template1,以及一个默认的用户数据库postgres。
取值范围:已有数据库的名称。不指定时,系统默认拷贝template1。另外,不支
持指定为postgres数据库。
l
ENCODING [ = ] encoding
指定数据库使用的字符编码,可以是字符串(如'SQL_ASCII')、整数编号。
不指定时,默认使用模版数据库的编码。模板数据库template0和template1的编码
默认与操作系统环境相关。template1不允许修改字符编码,因此若要变更编码,
请使用template0创建数据库。
常用取值:GBK、UTF8、Latin1。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
790GaussDB 200
开发者指南
16 SQL 参考
l 指定新的数据库字符集编码必须与所选择的本地环境中(LC_COLLATE和
LC_CTYPE)的设置兼容。
l 当指定的字符编码集为GBK时,部分中文生僻字无法直接作为对象名。这是因
为GBK第二个字节的编码范围在0x40-0x7E之间时,字节编码与ASCII字符@A-
Z[\]^_`a-z{|}重叠。其中@[\]^_'{|}是数据库中的操作符,直接作为对象名时,会
语法报错。例如“侤”字,GBK16进制编码为0x8240,第二个字节为0x40,与
ASCII“@”符号编码相同,因此无法直接作为对象名使用。如果确实要使
用,可以在创建和访问对象时,通过增加双引号来规避这个问题。
l
LC_COLLATE [ = ] lc_collate
指定新数据库使用的字符集。例如,通过lc_collate = 'zh_CN.gbk'设定该参数。
该参数的使用会影响到对字符串的排序顺序(如使用ORDER BY执行,以及在文
本列上使用索引的顺序)。默认是使用模板数据库的排序顺序。
取值范围:有效的排序类型。
l
LC_CTYPE [ = ] lc_ctype
指定新数据库使用的字符分类。例如,通过lc_ctype = 'zh_CN.gbk'设定该参数。该
参数的使用会影响到字符的分类,如大写、小写和数字。默认是使用模板数据库
的字符分类。
取值范围:有效的字符分类。
l
DBCOMPATIBILITY [ = ] compatibilty_type
指定兼容的数据库的类型。
取值范围:TD、ORA。分别表示兼容TD(Teradata)和Oracle。
l
TABLESPACE [ = ] tablespace_name
指定数据库对应的表空间。
取值范围:已存在表空间名。
l
CONNECTION LIMIT [ = ] connlimit
数据库可以接受的并发连接数。
系统管理员不受此参数的限制。
取值范围:>=-1的整数。默认值为-1,表示没有限制。
有关字符编码的一些限制:
l 若区域设置为C(或POSIX),则允许所有的编码类型,但是对于其他的区域设
置,字符编码必须和区域设置相同。
l 编码和区域设置必须匹配模板数据库,除了将template0当作模板。 因为其他数据
库可能会包含不匹配指定编码的数据,或者可能包含排序顺序受LC_COLLATE和
LC_CTYPE影响的索引。复制这些数据会导致在新数据库中的索引失效。
template0是不包含任何会受到影响的数据或者索引。
示例
--创建jim和tom用户。
CREATE USER jim PASSWORD 'Bigdata123@';
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
791GaussDB 200
开发者指南
16 SQL 参考
CREATE USER tom PASSWORD 'Bigdata123@';
--创建一个GBK编码的数据库music(本地环境的编码格式必须也为GBK)。
CREATE DATABASE music ENCODING 'GBK' template = template0;
--创建数据库music2,并指定所有者为jim。
CREATE DATABASE music2 OWNER jim;
--用模板template0创建数据库music3,并指定所有者为jim。
CREATE DATABASE music3 OWNER jim TEMPLATE template0;
--设置music数据库的连接数为10。
ALTER DATABASE music CONNECTION LIMIT= 10;
--将music名称改为music4。
ALTER DATABASE music RENAME TO music4;
--将数据库music2的所属者改为tom。
ALTER DATABASE music2 OWNER TO tom;
--设置music3的表空间为PG_DEFAULT。
ALTER DATABASE music3 SET TABLESPACE PG_DEFAULT;
--关闭在数据库music3上缺省的索引扫描。
ALTER DATABASE music3 SET enable_indexscan TO off;
--重置enable_indexscan参数。
ALTER DATABASE music3 RESET enable_indexscan;
--删除数据库。
DROP DATABASE music2;
DROP DATABASE music3;
DROP DATABASE music4;
--删除jim和tom用户。
DROP USER jim;
DROP USER tom;
--创建兼容TD格式的数据库。
CREATE DATABASE td_compatible_db DBCOMPATIBILITY 'TD';
--创建兼容ORA格式的数据库。
CREATE DATABASE ora_compatible_db DBCOMPATIBILITY 'ORA';
--删除兼容TD、ORA格式的数据库。
DROP DATABASE td_compatible_db;
DROP DATABASE ora_compatible_db;
相关链接
16.14.3 ALTER DATABASE,16.14.80 DROP DATABASE
16.14.48 CREATE DATA SOURCE
功能描述
创建一个新的外部数据源对象,该对象用于定义GaussDB 200要连接的目标库信息。
注意事项
l Data Source名称在数据库中需唯一,遵循标识符命名规范,长度限制为63字节,
过长则会被截断。
l 只有系统管理员或初始用户才有权限创建Data Source对象。且创建该对象的用户
为其默认属主。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
792GaussDB 200
开发者指南
16 SQL 参考
语法格式
CREATE DATA SOURCE src_name
[TYPE 'type_str']
[VERSION {'version_str' | NULL}]
[OPTIONS (optname 'optvalue' [, ...])];
参数说明
l
src_name
新建Data Source对象的名称,需在数据库内部唯一。
取值范围:字符串,要符标识符的命名规范。
l
TYPE
新建Data Source对象的类型,可缺省。
取值范围:空串或非空字符串。
l
VERSION
新建Data Source对象的版本号,可缺省或NULL值。
取值范围:空串或非空字符串或NULL。
l
OPTIONS
Data Source对象的选项字段,创建时可省略,如若指定,其关键字如下:
–
optname
选项名称。
取值范围:dsn, username, password, encoding。不区分大小写。
n dsn对应odbc配置文件中的DSN。
n username/password对应连接目标库的用户名和密码。
GaussDB 200在后台会对用户输入的username/password加密以保证安全
性。该加密所需密钥文件可以使用系统默认自带的文件,也可以通过
gs_guc生成,并在生成后通过 gs_om部署到集群所有节点。
n
–
encoding表示与目标库交互的字符串编码方式(含发送的SQL语句和返回
的字符类型数据),此处创建对象时不检查encoding取值的合法性,能否
正确编解码取决于用户提供的编码方式是否在数据库本身支持的字符编
码范围内。
optvalue
选项值。
取值范围:空或者非空字符串。
示例
--创建一个空的Data Source对象,不含任何信息。
CREATE DATA SOURCE ds_test1;
--创建一个Data Source对象,含TYPE信息,VERSION为NULL。
CREATE DATA SOURCE ds_test2 TYPE 'MPPDB' VERSION NULL;
--创建一个Data Source对象,仅含OPTIONS。
CREATE DATA SOURCE ds_test3 OPTIONS (dsn 'GaussDB 200', encoding 'utf8');
--创建一个Data Source对象,含TYPE, VERSION, OPTIONS。
CREATE DATA SOURCE ds_test4 TYPE 'unknown' VERSION '11.2.3' OPTIONS (dsn 'GaussDB 200', username
'userid', password 'pwd@123456', encoding '');
--删除Data Source对象。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
793GaussDB 200
开发者指南
16 SQL 参考
DROP
DROP
DROP
DROP
DATA
DATA
DATA
DATA
SOURCE
SOURCE
SOURCE
SOURCE
ds_test1;
ds_test2;
ds_test3;
ds_test4;
相关链接
ALTER DATA SOURCE, DROP DATA SOURCE
16.14.49 CREATE DIRECTORY
功能描述
使用CREATE DIRECTORY 语句创建一个目录对象,该目录对象定义了服务器文件系
统上目录的别名,用于存放用户使用的数据文件,用户可以通过utl_file高级包来读写
这些文件。
该目录对象对于指定用户可以赋予READ和WRITE的操作权限,用于给utl_file提供权限
控制。
注意事项
l 只允许有sysadmin权限的用户创建。
l 创建用户默认拥有此路径的READ和WRITE操作权限。
l 目录的默认owner为创建directory的用户。
l 以下路径禁止创建:
l
l
– 路径含特殊字符。
– 路径是相对路径。
– 路径是符号连接。
创建目录时会进行以下合法性校验:
– 创建时会检查添加路径是否为操作系统实际存在路径,如不存在会提示用户
使用风险。
– 创建时会校验数据库初始化(omm)用户对于添加路径的权限(即操作系统目
录权限,读/写/执行 - R/W/X),如果权限不全,会提示用户使用风险。
在集群环境下用户指定的路径需要用户保证各节点上路径的一致性,否则在不同
节点上执行会产生找不到路径的问题。
语法格式
CREATE [OR REPLACE] DIRECTORY directory_name
AS 'path_name';
参数说明
l
directory_name
目录名称。
取值范围:字符串,要符标识符的命名规范。
l
path_name
操作系统的路径。
取值范围: 有效的操作系统路径。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
794GaussDB 200
开发者指南
16 SQL 参考
示例
--创建目录。
CREATE OR REPLACE DIRECTORY
dir
as '/tmp/';
相关链接
16.14.6 ALTER DIRECTORY,16.14.83 DROP DIRECTORY
16.14.50 CREATE FOREIGN TABLE (导入导出)
创建GDS外表。
功能描述
在当前数据库创建一个GDS外表,用于数据并行导入导出。GDS外表分为只读外表和
只写外表,分别用于数据并行导入和并行导出,缺省为只读外表。
注意事项
l 外表由命令执行者所有;
l GDS外表不需要显式指定分布方式,默认支持ROUNDROBIN分布方式;
l 对于GDS外表指定任何约束(列约束、表约束等)均不生效。
语法格式
CREATE FOREIGN TABLE [ IF NOT EXISTS ] table_name
( [ { column_name type_name POSITION(offset,length) | LIKE source_table } [, ...]
SERVER gsmpp_server
OPTIONS ( { option_name ' value ' } [, ...] )
[ { WRITE ONLY | READ ONLY }]
[ WITH error_table_name | LOG INTO error_table_name]
[REMOTE LOG 'name']
[PER NODE REJECT LIMIT 'value']
[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ];
] )
参数概览
创建外表语法提供了多个参数,常用参数分类如下。
l
l
必需参数
– table_name
– column_name
– type_name
– SERVER gsmpp_server
– OPTIONS 可选参数
可选参数
– 外表的数据源位置参数location
– 数据格式参数
文档版本 01 (2019-08-01)
n format
n header(仅支持CSV,FIXED格式)
n fileheader(仅支持CSV,FIXED格式)
版权所有 © 华为技术有限公司
795GaussDB 200
开发者指南
16 SQL 参考
–
n out_filename_prefix
n delimiter
n quote(仅支持CSV格式)
n escape(仅支持CSV格式)
n null
n noescaping(仅支持TEXT格式)
n encoding
n eol
容错性参数
n fill_missing_fields
n ignore_extra_data
n reject_limit
n compatible_illegal_chars
n WITH error_table_name
n LOG INTO error_table_nam...
n REMOTE LOG 'name'
n PER NODE REJECT LIMIT 'v...
参数说明
l
IF NOT EXISTS
如果已经存在相同名称的表,不会抛出一个错误,而会发出一个通知,告知表关
系已存在。
l
table_name
外表的表名。
取值范围:字符串,要符合标识符的命名规范。
l
column_name
外表中的字段名。
取值范围:字符串,要符合标识符的命名规范。
l
type_name
字段的数据类型。
l
POSITION(offset,length)
在固定长度模式中,定义每一个字段在数据文件中的位置。
说明
offset为该字段在数据源文件中的起始位置,length为该字段的长度。
取值范围:offset取值不能小于0字节,单位为字节。
每条记录的长度不能大于1GB,文件中没有出现的列默认以空值代替。
l
SERVER gsmpp_server
外表的server名字。对于GDS外表,其server是初始数据库默认创建的,即
gsmpp_server。
l
OPTIONS ( { option_name ' value ' } [, ...] )
用于指定外表数据的各类参数。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
796GaussDB 200
开发者指南
16 SQL 参考
–
location
外表的数据源位置,目前支持URL和本地文件方式的描述。多个URL和多个
本地文件都使用‘|’分割。
说明
l 对于使用GDS从远端服务器并行导入时的只读外部表(默认为只读)的URL末尾
必须指定文件的匹配模式或者文件名。
例如: gsfs://192.168.0.90:5000/*或者file:///data/data.txt或者gsfs:// 192.168.0.90:5000/*
| gsfs:// 192.168.0.91:5000/*
l 对于使用GDS并行导出到远端服务器时的可写外部表,URL不需要指定文件名。
当数据源位置为本地时,例如:file:///data/,外部表数据源位置只可指定一个,并
且每个节点上都要预先创建好对应目录。当导出数据文件存储位置为远端URL
时,例如gsfs:// 192.168.0.90:5000/,则数据源位置可指定多个,此时:若导出数据
文件存储位置数量小于等于数据节点数量时,使用此外部表执行导出任务,数据
将被平均分配至各数据源位置;若导出数据存储位置数量大于数据节点数量时,
执行导出任务,数据将被平均分配给此位置列表中从前端开始等于数据节点数量
的数据源位置下,剩余数据源位置仍会创建数据文件,但文件中不会有任何数
据。
l 对于使用GDS从远端服务器并行导入时的只读外表,URL个数应小于DN个数,且
不能使用多个location相同的URL。
l 当使用gsfss协议,即当URL为“gsfss://”开头,走加密导入导出时,并发不能超
过10.
–
format
外表中数据源文件的格式。
取值范围:CSV、TEXT、FIXED,缺省值为TEXT。
n CSV格式的文件,对一些转义序列按照普通字符串进行处理, 因此可以有
效处理数据列中的换行符。
n TEXT格式的文件,可以有效处理一些转义序列,因此无法正确处理数据
列中的换行符。
n FIXED格式的文件,适用于每条数据的数据列都比较固定的数据,长度
不足的列会添加空格补齐。
说明
l 转义序列指的是反斜杠开头的字符串,包括:\b(退格)、\f(换页)、\n(换
行)、\r(回车)、\t(横向制表)、\v(纵向制表)、\数字(八进制编码)、\x
数字(十六进制编码)。TEXT格式可以按照本身含义进行处理,其他格式只能按
照普通字符串进行处理。
l 定长格式(FIXED)定义如下。当为FIXED时,必须为每一列指定POSITION。
1. 每条记录的每个字段长度相同。
2. 长度不足的字段以空格填充,数字类型字段左对齐,字符字段右对齐。
3. 字段和字段之间没有分隔符。
–
header
指定导出数据文件是否包含标题行,标题行一般用来描述表中每个字段的信
息。header只能用于CSV,FIXED格式的文件中。
在导入数据时,如果header选项为on,则数据文本第一行会被识别为标题行,
会忽略此行。如果header为off,而数据文件中第一行会被识别为数据。
在导出数据时,如果header选项为on,则需要指定▪fileheader。fileheader用来
指定导出头文件的格式。如果header为off,则导出数据文件不包含标题行。
取值范围:true/on,false/off。缺省值为false/off。
–
文档版本 01 (2019-08-01)
fileheader
版权所有 © 华为技术有限公司
797GaussDB 200
开发者指南
16 SQL 参考
指定导出数据要包含的标题行定义的文件,文件一般只包含一行用来描述每
一列数据信息的字符串。
例如:在包含商品信息的数据前加标题行,定义文件如下
The information of products.\n
l 标题行定义文件仅在header为on或true的情况下有效,且需要提前写好备
用。
l 在Remote导出模式下,定义文件必须放在GDS的工作目录(即启动gds时
指定的-d路径)下。
l 在Local导出模式下,定义文件必须放在各个节点的相同路径,且fileheader
指定的是绝对路径。
l 定义文件只能包含一行标题信息,并以换行符结尾,多余的行将被丢弃
(标题信息不能包含换行符)。
l 定义文件包括换行符在内长度不超过1M。
–
out_filename_prefix
指定write only外表导出时,GDS端生成导出数据文件的文件名前缀。
l 指定文件名前缀需合法,符合GDS部署物理环境使用的文件系统的约束,
否则出现文件创建失败:
l 指定的导出文件名前缀中不含有非法字符,其中非法字符包含但不限
于'/', '?', '*', ':', '|', '\\', '<', '>', '@', '#', '$', '&', '(', ')', '+', '-',允许的字符范围
为[a-z]*[A-Z]*[0-9]*和'_'
l 指定的导出文件名前缀中不可以是一些Windows和linux预留的特性字
段,其中包括但不限于:
"con","aux","nul","prn","com0","com1","com2","com3","com4","com5","c
om6","com7","com8","com9","lpt0","lpt1","lpt2","lpt3","lpt4","lpt5","lpt6
","lpt7","lpt8","lpt9"
l 指定的导出文件名前缀,在与gds –d目录和".dat.x"拼接为绝对路径后
必须符合GDS所在的部署文件系统的文件名长度要求
l 指定的导出文件名前缀,需要可以被数据文件的最终接收方正确解析
识别(包括但不限于GDS再次导入库中),对于造成文件名解析问题
的指定选项,需要用户自己识别
l 在多文件同时导出的高并发导出场景下,请确认并发的导出任务不要使用
同一个文件名前缀设定,否则从操作系统/文件系统层面可能会出现导出文
件的覆盖和丢失。
–
delimiter
指定数据文件行数据的字段分隔符,不指定则使用默认分隔符,TEXT格式的
默认分隔符是水平制表符(tab),CSV格式的默认分隔符为“,”,FIXED格
式没有分隔符。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
798GaussDB 200
开发者指南
16 SQL 参考
说明
l 分隔符不能是\r和\n。
l 分隔符不能和null参数相同,CSV格式数据的分隔符不能和quote参数相同。
l TEXT格式数据的分隔符不能包含: \.abcdefghijklmnopqrstuvwxyz0123456789。
l 数据文件中单行数据长度需<1GB,如果分隔符较长且数据列较多的情况下,会影
响导出有效数据的长度。
l 分隔符推荐使用多字符(例如'$^&')和不可见字符(例如0x07、0x08、0x1b
等)。
取值范围:
支持多字符分隔符,但分隔符不能超过10个字节。
–
quote
用于设置将CSV格式数据源文件中的什么字符识别为引号字符。缺省值为双
引号。
说明
l quote参数不能和分隔符、null参数相同。
l quote参数只能是单字节的字符。
l 推荐不可见字符作为quote,例如0x07,0x08,0x1b等。
–
escape
用来指定CSV格式的数据源文件中,什么字符为逃逸字符。逃逸字符只能指
定为单字节字符。
缺省值为双引号。当与quote值相同时,会被替换为'\0'。
–
null
用来指定数据文件中空值的表示。
说明
l null值不能是\r和\n,最大为100个字符。
l null值不能和分隔符、quote参数相同。
取值范围:
–
n 在TEXT格式下缺省值是\n。
n CSV格式下缺省值是一个没有引号的空字符串。
noescaping
TEXT格式下,不对'\'和后面的字符进行转义。
说明
noescaping参数只在TEXT格式下有效。
取值范围:true/on,false/off。缺省值为false/off。
–
encoding
指定数据文件的编码格式名称,即需要以何编码格式对数据文件进行解析和
校验/输出文件为何种编码格式。缺省值为当前数据库的默认客户端编码格
式,即client_encoding。
导入外表此处强烈建议指定为文件的编码格式,或根据文件的字符集在导入
前对client_encoding进行设置。否则可能会导致不必要的解析、校验错误以及
其导致的导入报错回滚,甚至非法数据入库。导出外表同样希望指定此选
项,以避免导出采用默认字符集设置时与预期不符。
在创建外表时此选项未指定,会在客户端给出对应Warning信息。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
799GaussDB 200
开发者指南
16 SQL 参考
说明
目前GDS导入外表不支持解析带有多种字符集编码格式混合的文件,GDS导出外表不
支持写出带有多种字符集编码格式混合的文件。
–
fill_missing_fields
当数据导入时,若数据源文件中一行的最后一个字段缺失的处理方式。
取值范围:true/on,false/off。缺省值为false/off。
n
n
参数为true/on,当数据导入时,若数据源文件中一行数据的最后一个字
段缺失,则把最后一个字段的值设置为NULL,不报错。
参数为false/off,如果最后一个字段缺失会显示如下错误信息。
missing data for column "tt"
–
ignore_extra_data
若数据源文件比外表定义列数多,是否会忽略对多出的列。该参数只在数据
导入过程中使用。
取值范围:true/on,false/off。缺省值为false/off。
n 参数为true/on,若数据源文件比外表定义列数多,则忽略行尾多出来的
列。
n 参数为false/off,若数据源文件比外表定义列数多,会显示如下错误信
息。
extra data after last expected column
如果行尾换行符丢失,使两行变成一行时,设置此参数为true将导致后一行数
据被忽略掉。
–
reject_limit
指定本次数据导入允许出现的数据格式错误个数,当导入过程中出现的数据
格式错误未达到限定值时,本次数据导入可以成功。
此语法建议用PER NODE REJECT LIMIT 'value'替代。
数据格式错误是指缺少或者多出字段值,数据类型错误或者编码错误。对于
非数据格式错误,一旦发生就将导致整个数据导入失败。
取值范围:正整型值、unlimited(无限制)。
缺省值为0,有错误信息立即返回。
说明
指定正整型参数时需要添加单引号。
–
mode
指定数据导入过程中,数据导入策略。
取值范围:
n
文档版本 01 (2019-08-01)
Normal(缺省值):支持所有文件格式(包括CSV、TEXT、FIXED),数
据导入需要在数据服务器上启动Gauss data service协助完成。
版权所有 © 华为技术有限公司
800GaussDB 200
开发者指南
16 SQL 参考
–
n Shared:支持TEXT文集格式,此时导入无需Gauss data service的协助,
但是需要将用户数据通过NFS或挂载到所有节点的相同路径下。
n Private:适用于用户数据已经存放到DN的本地目录下,并且位于相同的
路径。
eol
指定导入导出数据文件换行符样式。
取值范围:支持多字符换行符,但换行符不能超过10个字节。常见的换行
符,如\r、\n、\r\n(设成0x0D、0x0A、0x0D0A效果是相同的),其他字符或
字符串,如$、#。
说明
l eol参数只能用于TEXT格式的导入导出,不支持CSV格式和FIXED格式导入。为了
兼容原有eol参数,仍然支持导出CSV格式和FIXED格式时指定eol参数为0x0D或
0x0D0A。
l eol参数不能和分隔符、null参数相同。
l eol参数不能包含:.abcdefghijklmnopqrstuvwxyz0123456789。
–
fix
指定每一行定长格式数据的长度。按字节计算。此语法仅对READ ONLY的外
表有效。
取值范围:N >= POSITION指定的总长度(总长度即为表定义最后一个字段
的offset与length的和)AND N < 1GB
–
out_fix_alignment
指定定长导出中,指定BYTEAOID、CHAROID、NAMEOID、TEXTOID、
BPCHAROID、VARCHAROID、NVARCHAR2OID、CSTRINGOID对应类型
所在列的对齐方式
取值范围:align_left、align_right
默认值:align_right
由于bytea数据类型要求十六进制格式(如"\XXXX")或八进制格式(如
"\XXX\XXX\XXX"),导入时需要左对齐(即列数据以两种格式开头,而非
空格)。因此若导出文件需要重新以GDS外表入库且数据长度小于外表
formatter指定长度,导出时需要指定左对齐,否则会在入库的过程中报错。
–
date_format
导入对于DATE类型指定格式。此语法仅对READ ONLY的外表有效。
取值范围:合法DATE格式。可参考16.5.8 时间和日期处理函数和操作符。
说明
对于指定为ORACLE兼容类型的数据库,则DATE类型内建为TIMESTAMP类型。在导
入的时候,若需指定格式,可以参考下面的timestamp_format参数。
–
time_format
导入对于TIME类型指定格式。此语法仅对READ ONLY的外表有效。
取值范围:合法TIME格式,不支持时区。可参考16.5.8 时间和日期处理函数
和操作符。
–
文档版本 01 (2019-08-01)
timestamp_format
版权所有 © 华为技术有限公司
801GaussDB 200
开发者指南
16 SQL 参考
导入对于TIMESTAMP类型指定格式。此语法仅对READ ONLY的外表有效。
取值范围:合法TIMESTAMP格式,不支持时区。可参考16.5.8 时间和日期处
理函数和操作符。
–
smalldatetime_format
导入对于SMALLDATETIME类型指定格式。此语法仅对READ ONLY的外表
有效。
取值范围:合法SMALLDATETIME格式。可参考16.5.8 时间和日期处理函数
和操作符。
–
compatible_illegal_chars
导入非法字符容错参数。此语法仅对READ ONLY的外表有效。
取值范围:true/on,false/off。缺省值为false/off。
n 参数为true/on,则导入时遇到非法字符进行容错处理,非法字符转换后
入库,不报错,不中断导入。
n 参数为false/off,导入时遇到非法字符进行报错,中断导入。
说明
导入非法字符容错规则如下:
(1)对于'\0',容错后转换为空格;
(2)对于其他非法字符,容错后转换为问号;
(3)如果compatible_illegal_chars为true/on标识导入时对于非法字符进行容错处理,
如果NULL、DELIMITER、QUOTE、ESCAPE设置为空格或问号则会通过如"illegal
chars conversion may confuse COPY escape 0x20"等报错信息提示用户修改可能引起混
淆的参数,以避免导入错误。
l
READ ONLY
外表只读,该参数只供数据导入使用。
l
WRITE ONLY
外表只写。该参数只供数据导出使用。
l
WITH error_table_name
数据导入过程中出现的数据格式错误信息将被写入error_table_name指定的错误信
息表中,可以在并行导入结束后查询此错误信息表,获取详细的错误信息。此参
数只在设置了reject_limit参数时有效。
说明
如果为了兼容postgres开源接口,此语法建议用LOG INTO代替。
取值范围:字符串,要符合标识符的命名规范。
l
LOG INTO error_table_name
数据导入过程中出现的数据格式错误信息将被写入error_table_name指定的错误信
息表中,可以在并行导入结束后查询此错误信息表,获取详细的错误信息。
说明
若没有指定PER NODE REJECT LIMIT参数,则此参数不起作用。
取值范围:字符串,要符合标识符的命名规范。
l
REMOTE LOG 'name'
数据导入过程中出现的数据格式错误信息将被写到GDS端以文件方式保存。name
为错误数据文件的文件名前缀。
l
PER NODE REJECT LIMIT 'value'
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
802GaussDB 200
开发者指南
16 SQL 参考
指定本次数据导入过程中每个DN实例上允许出现的数据格式错误的数量,如果有
一个DN实例上的错误数量大于设定值,本次导入失败,报错退出。
此语法指定的是单个节点的错误容忍度。
数据格式错误是指缺少或者多出字段值,数据类型错误或者编码错误。对于非数
据格式错误,一旦发生就将导致整个数据扫描失败。
取值范围:整型值,unlimited(无限),缺省值为0,有错误信息立即返回。
l
TO { GROUP groupname | NODE ( nodename [, ... ] ) }
TO GROUP目前不支持使用。TO NODE主要供内部扩容工具使用,一般用户不应
使用。
示例
--建立外表,用来以TEXT格式导入GDS服务器192.168.0.90和192.168.0.91上的数据,导入过程错误信息将记录到
err_HR_staffS中。
CREATE FOREIGN TABLE foreign_HR_staffS
(
staff_ID
NUMBER(6) ,
FIRST_NAME
VARCHAR2(20),
LAST_NAME
VARCHAR2(25),
EMAIL
VARCHAR2(25),
PHONE_NUMBER
VARCHAR2(20),
HIRE_DATE
DATE,
employment_ID VARCHAR2(10),
SALARY
NUMBER(8,2),
COMMISSION_PCT NUMBER(2,2),
MANAGER_ID
NUMBER(6),
section_ID NUMBER(4)
) SERVER gsmpp_server OPTIONS (location 'gsfs://192.168.0.90:5000/* | gsfs://192.168.0.91:5000/*',
format 'TEXT', delimiter E'\x08', null '') WITH err_HR_staffS;
--建立外表,用来以TEXT格式导入GDS服务器192.168.0.90和192.168.0.91上的数据,导入过程错误信息将记录到
err_HR_staffS中。本次数据导入允许出现的数据格式错误个数为2。
CREATE FOREIGN TABLE foreign_HR_staffS_ft3
(
staff_ID
NUMBER(6) ,
FIRST_NAME
VARCHAR2(20),
LAST_NAME
VARCHAR2(25),
EMAIL
VARCHAR2(25),
PHONE_NUMBER
VARCHAR2(20),
HIRE_DATE
DATE,
employment_ID VARCHAR2(10),
SALARY
NUMBER(8,2),
COMMISSION_PCT NUMBER(2,2),
MANAGER_ID
NUMBER(6),
section_ID NUMBER(4)
) SERVER gsmpp_server OPTIONS (location 'gsfs://192.168.0.90:5000/* | gsfs://192.168.0.91:5000/*',
format 'TEXT', delimiter E'\x08', null '',reject_limit '2') WITH err_HR_staffS_ft3;
--建立外表,用来以CSV格式导入input_data目录下存放在各个节点名文件下的所有文件。
CREATE FOREIGN TABLE foreign_HR_staffS_ft1
(
staff_ID
NUMBER(6) ,
FIRST_NAME
VARCHAR2(20),
LAST_NAME
VARCHAR2(25),
EMAIL
VARCHAR2(25),
PHONE_NUMBER
VARCHAR2(20),
HIRE_DATE
DATE,
employment_ID VARCHAR2(10),
SALARY
NUMBER(8,2),
COMMISSION_PCT NUMBER(2,2),
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
803GaussDB 200
开发者指南
16 SQL 参考
MANAGER_ID
NUMBER(6),
section_ID
NUMBER(4)
) SERVER gsmpp_server OPTIONS (location 'file:///input_data/*', format 'csv', mode 'private',
delimiter ',') WITH err_HR_staffS_ft1;
--建立外表,用来以CSV格式导出数据到output_data目录下。
CREATE FOREIGN TABLE foreign_HR_staffS_ft2
(
staff_ID
NUMBER(6) ,
FIRST_NAME
VARCHAR2(20),
LAST_NAME
VARCHAR2(25),
EMAIL
VARCHAR2(25),
PHONE_NUMBER
VARCHAR2(20),
HIRE_DATE
DATE,
employment_ID VARCHAR2(10),
SALARY
NUMBER(8,2),
COMMISSION_PCT NUMBER(2,2),
MANAGER_ID
NUMBER(6),
section_ID NUMBER(4)
) SERVER gsmpp_server OPTIONS (location 'file:///output_data/', format 'csv', delimiter '|',
header 'on') WRITE ONLY;
--删除外表。
DROP FOREIGN
DROP FOREIGN
DROP FOREIGN
DROP FOREIGN
TABLE
TABLE
TABLE
TABLE
foreign_HR_staffS;
foreign_HR_staffS_ft1;
foreign_HR_staffS_ft2;
foreign_HR_staffS_ft3;
相关链接
16.14.7 ALTER FOREIGN TABLE (导入导出),16.14.84 DROP FOREIGN TABLE
16.14.51 CREATE FOREIGN TABLE (SQL on Hadoop )
功能描述
在当前数据库创建一个HDFS外表,用来访问存储在HDFS分布式集群文件系统上的
Hadoop结构化数据。HDFS外表是只读的,只能用于查询操作,可直接使用SELECT查
询其数据。
语法格式
创建HDFS外表。
CREATE FOREIGN TABLE [ IF NOT EXISTS ] table_name
( [ { column_name type_name
[ { [CONSTRAINT constraint_name] NULL |
[CONSTRAINT constraint_name] NOT NULL |
column_constraint [...]} ] |
table_constraint [, ...]} [, ...] ] )
SERVER server_name
OPTIONS ( { option_name ' value ' } [, ...] )
DISTRIBUTE BY {ROUNDROBIN | REPLICATION}
[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ]
[ PARTITION BY ( column_name ) [ AUTOMAPPED ] ] ;
l
其中column_constraint为:
[CONSTRAINT constraint_name]
{PRIMARY KEY | UNIQUE}
[NOT ENFORCED [ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION] | ENFORCED]
l
其中table_constraint为:
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
804GaussDB 200
开发者指南
16 SQL 参考
[CONSTRAINT constraint_name]
{PRIMARY KEY | UNIQUE} (column_name)
[NOT ENFORCED [ENABLE QUERY OPTIMIZATION | DISABLE QUERY OPTIMIZATION] | ENFORCED]
参数说明
l
IF NOT EXISTS
如果已经存在相同名称的表,不会抛出一个错误,而会发出一个通知,告知表关
系已存在。
l
table_name
外表的表名。
取值范围:字符串,要符合标识符的命名规范。
l
column_name
外表中的字段名。可以选择多个字段名,中间用“,”隔开。
取值范围:字符串,要符合标识符的命名规范。
l
type_name
字段的数据类型。
orc表支持的数据类型有:SMALLINT、INTEGER、BIGINT、FLOAT4 (REAL)、
FLOAT8 (DOUBLE PRECISION)、DECIMAL[p(,s)] 最大支持38位精度、DATE、
TIMESTAMP、BOOLEAN、CHAR (n)、VARCHAR (n)、TEXT (CLOB)。
txt表支持的数据类型与行存表保持一致。
l
constraint_name
外表的表约束名。
l
{ NULL | NOT NULL }
标识此列是否允许NULL值。
在创建表时,对于列的约束NULL/NOT NULL,并不能保证该表在HDFS系统中的
数据为NULL或者NOT NULL,数据的一致性由用户保证。所以需要由用户判断该
列是否一定不为空或者一定为空,在建表的时候选用NULL或NOT NULL。(优化
器对列为NULL/NOT NULL做了优化处理,会产生更优的计划。)
l
SERVER server_name
外表的server名字。允许用户自定义名字。
取值范围:字符串,要符合标识符的命名规范,并且这个server必须存在。
l
OPTIONS ( { option_name ' value ' } [, ...] )
用于指定外表数据的各类参数,参数类型如下所示。
–
header
指定导出数据文件是否包含标题行,标题行一般用来描述表中每个字段的信
息。header只能用于CSV格式的文件中。
如果header选项为on,则数据文件第一行会被识别为标题行,导出时会忽略此
行。如果header为off,而数据文件中第一行会被识别为数据。
取值范围:true/on,false/off。缺省值为false/off。
–
quote
CSV格式文件下的引号字符,缺省值为双引号。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
805GaussDB 200
开发者指南
16 SQL 参考
说明
quote参数不能和分隔符、null参数相同。
quote参数只能是单字节的字符。
推荐不可见字符作为quote,例如0x07,0x08,0x1b等。
–
escape
CSV格式下,用来指定逃逸字符,逃逸字符只能指定为单字节字符。
缺省值为双引号。当与quote值相同时,会被替换为'\0'。
– format:外表中数据源文件的格式。支持ORC,TEXT,CSV文件格式。
– foldername:外表中数据源文件目录,即表数据目录在HDFS文件系统上对应
的文件目录。
– encoding:外表中数据源文件的编码格式名称,缺省为utf8。此选项为可选参
数。
– filenames:外表中数据源文件,以","间隔。
说明
l 推荐通过使用foldername参数指定数据源的位置。
l foldername必须为绝对路径,不能有多个路径。
l 查询分区表时,会先根据分区信息进行剪枝,然后查询满足条件的数据文件。由
于剪枝操作会涉及多次扫描HDFS分区目录内容,不建议使用重复度非常小的列作
为分区列,因为这可能导致分区目录非常的多,增加对HDFS的查询压力。
–
delimiter
指定数据文件行数据的字段分隔符,不指定则使用默认分隔符,TEXT格式的
默认分隔符是水平制表符(tab)。
说明
l 分隔符不能是\r和\n。
l 分隔符不能和null参数相同。
l 分隔符不能包含: \.abcdefghijklmnopqrstuvwxyz0123456789。
l 数据文件中单行数据长度需<1GB,如果分隔符较长且数据列较多的情况下,会影
响导出有效数据的长度。
l 分隔符推荐使用多字符(例如'$^&')和不可见字符(例如0x07、0x08、0x1b
等)。
l delimiter参数只在TEXT和CSV格式下有效。
取值范围:
支持多字符分隔符,但分隔符不能超过10个字节。
–
null
用来指定数据文件中空值的表示。
说明
l null值不能是\r和\n,最大为100个字符。
l null值不能是分隔符。
l null参数只在TEXT和CSV格式下有效。
取值范围:
在TEXT格式下缺省值是\N。
–
noescaping
TEXT格式下,不对'\'和后面的字符进行转义。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
806GaussDB 200
开发者指南
16 SQL 参考
说明
noescaping参数只在TEXT格式下有效。
取值范围:true/on,false/off。缺省值为false/off。
–
fill_missing_fields
当数据加载时,若数据源文件中一行的最后一个字段缺失时的处理方式。
取值范围:true/on,false/off。缺省值为false/off。
n
n
参数为true/on,当数据加载时,若数据源文件中一行数据的最后一个字
段缺失,则把最后一个字段的值设置为NULL,不报错。
参数为false/off,如果最后一个字段缺失会显示如下错误信息。
missing data for column "tt"
说明
l TEXT格式下执行SELECT COUNT(*) 不会去解析具体字段,因此不会对字段缺失
情况报错。
l fill_missing_fields参数只在TEXT和CSV格式下有效。
–
ignore_extra_data
若数据源文件比外表定义列数多,是否会忽略多出的列。该参数只在数据导
入过程中使
取值范围:true/on,false/off。缺省值为false/off。
n 参数为true/on,若数据源文件比外表定义列数多,则忽略行尾多出来的
列。
n 参数为false/off,若数据源文件比外表定义列数多,会显示如下错误信
息。
extra data after last expected column
l 如果行尾换行符丢失,使两行变成一行时,设置此参数为true将导致后一
行数据被忽略掉。
l TEXT格式下执行SELECT COUNT(*) 不会去解析具体字段,因此不会对多
余的情况报错。
l ignore_extra_data参数只在TEXT和CSV格式下有效。
–
date_format
导入对于DATE类型指定格式。此语法仅对READ ONLY的外表有效。
取值范围:合法DATE格式。可参考16.5.8 时间和日期处理函数和操作符。
说明
l 对于指定为ORACLE兼容类型的数据库,则DATE类型内建为TIMESTAMP类型。
在导入的时候,若需指定格式,可以参考下面的timestamp_format参数。
l date_format参数只在TEXT和CSV格式下有效。
–
time_format
导入对于TIME类型指定格式。此语法仅对READ ONLY的外表有效。
取值范围:合法TIME格式,不支持时区。可参考16.5.8 时间和日期处理函数
和操作符。
说明
time_format参数只在TEXT和CSV格式下有效。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
807GaussDB 200
开发者指南
16 SQL 参考
–
timestamp_format
导入对于TIMESTAMP类型指定格式。此语法仅对READ ONLY的外表有效。
取值范围:合法TIMESTAMP格式,不支持时区。可参考16.5.8 时间和日期处
理函数和操作符。
说明
timestamp_format参数只在TEXT和CSV格式下有效。
–
smalldatetime_format
导入对于SMALLDATETIME类型指定格式。此语法仅对READ ONLY的外表
有效。
取值范围:合法SMALLDATETIME格式。可参考16.5.8 时间和日期处理函数
和操作符。
说明
smalldatetime_format参数只在TEXT和CSV格式下有效。
–
checkencoding
是否检查字符编码
取值范围:low,high 。缺省值为low。
说明
TEXT格式下,导入非法字符容错规则如下:
l 对于'\0',容错后转换为空格;
l 对于其他非法字符,容错后转换为问号;
l 若checkencoding为low标识,导入时对于非法字符进行容错处理,则若NULL、
DELIMITER设置为空格或问号则会通过如"illegal chars conversion may confuse null
0x20"等报错信息提示用户修改可能引起混淆的参数以避免导入错误。
ORC格式下,导入非法字符容错规则如下:
l checkencoding为low标识,若导入时检查到某个字段中包含非法字符,则自动将当
前列当前行的字段整体替换为同样长度的‘?’字符;
l checkencoding为high标识,若导入时检查到某个字段中包含非法字符,则报错退
出。
表 16-56 text、csv、orc 格式对 option 支持说明
文档版本 01 (2019-08-01)
参数名称 OBS
HDFS
- text csv orc text csv orc
location 支持 支持 支持 不支
持 不支持 不支持
format 支持 支持 支持 支持 支持 支持
header 不支持 支持 不支持 不支
持 支持 不支持
delimiter 支持 支持 不支持 支持 支持 不支持
quote 不支持 支持 不支持 不支
持 支持 不支持
escape 不支持 支持 不支持 不支
持 支持 不支持
版权所有 © 华为技术有限公司
808GaussDB 200
开发者指南
16 SQL 参考
l
参数名称 OBS
HDFS
null 支持 支持 不支持 支持 支持 不支持
noescaping 支持 不支
持 不支持 支持 不支持 不支持
encoding 支持 支持 支持 支持 支持 支持
fill_missing_field
s 支持 支持 不支持 支持 支持 不支持
ignore_extra_dat
a 支持 支持 不支持 支持 支持 不支持
date_format 支持 支持 不支持 支持 支持 不支持
time_format 支持 支持 不支持 支持 支持 不支持
timestamp_forma
t 支持 支持 不支持 支持 支持 不支持
smalldatetime_fo
rmat 支持 支持 不支持 支持 支持 不支持
chunksize 支持 支持 不支持 支持 支持 不支持
filenames 不支持 不支
持 不支持 支持 支持 支持
foldername 支持 支持 支持 支持 支持 支持
checkencoding 支持 支持 支持 支持 支持 支持
totalrows 支持 支持 支持 不支
持 不支持 不支持
DISTRIBUTE BY ROUNDROBIN
指定HDFS外表为ROUNDROBIN分布方式。
l
DISTRIBUTE BY REPLICATION
指定HDFS外表为REPLICATION分布方式。
l
TO { GROUP groupname | NODE ( nodename [, ... ] ) }
TO GROUP目前不支持使用。TO NODE主要供内部扩容工具使用,一般用户不应
使用。
l
PARTITION BY ( column_name ) AUTOMAPPED
column_name指定分区列。对于分区表,AUTOMAPPED表示HDFS分区外表指定
的分区列会和HDFS数据中的分区目录信息自动对应,前提是必须保证HDFS分区
外表指定分区列的顺序和HDFS数据中分区目录定义的顺序一致。
说明
HDFS外表支持分区表,OBS外表不支持分区表。
l
CONSTRAINT constraint_name
用于指定外表所建立的信息约束(Informational Constraint)的名字。
取值范围:字符串,要符合标识符的命名规范。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
809GaussDB 200
开发者指南
16 SQL 参考
l
PRIMARY KEY
主键约束,表示表里的一个或者一些字段只能包含唯一(不重复)的非NULL值。
一个表只能声明一个主键。
l
UNIQUE
唯一约束,表示表里的一个或者多个字段的组合必须在全表范围内唯一。对于唯
一约束,NULL被认为是互相不等的。
l
NOT ENFORCED
指定所建立的约束为信息约束,该约束不由数据库来保证,而由用户来保证。
l
ENFORCED
ENFORCED为默认值。预留参数,目前对于ENFORCED不支持。
l
PRIMARY KEY (column_name)
指定所建立的信息约束位于column_name列上。
取值范围:字符串,要符合标识符的命名规范,并且这个column_name必须存在。
l
ENABLE QUERY OPTIMIZATION
利用信息约束对执行计划进行优化。
l
DISABLE QUERY OPTIMIZATION
禁止利用信息约束对执行计划优化。
信息约束(Informational Constraint)
背景信息
数据库系统对数据的约束共分五种,分别为:Not Null约束(非空约束)、Unique约束(唯
一约束)、Primary Key约束(主键约束)、Foreign Key约束(外键约束)以及Check约束(检查
约束),数据库在执行数据插入或更新时由数据库强制执行的五种约束可能会产生大量
的系统开销,影响数据导入或变更时的性能。
如果装入的数据已经提前完成某种形式的约束,而数据库系统也遵守这些约束,称为
信息约束(Informational Constraint)。信息约束并不是一种数据库系统对数据的约
束,数据库中的编译器可以使用这个约束来改善访问数据和算子操作时的效率,信息
约束不是数据库在数据库插入数据或更改数据时强制执行,不用于数据的附加验证,
其主要目的是提高查询性能。
在GaussDB 200中,数据本身存储在HDFS中,GaussDB 200并不提供向HDFS写数据的
功能,数据的约束完全由使用者保证,数据源数据能够严格遵守某种信息约束条件,
能够加速对已经具有这种约束特征数据的查询。
数据库系统中Unique和Primary Key都是在创建的时候就直接建立了Index,所以在优化
器阶段扫描算子就可以考虑使用Index Scan,用以提升数据的查询效率。目前HDFS外
表不支持索引Index,所以采取使用Informational Constraint信息优化Plan,提搞查询能
力。
建立HDFS外表信息约束的约束条件:
l 只有用户保证表中的其中一列的非空值具有唯一性时才可以建立Informational
Constraint,否则查询结果将与期望值不同。
l Informational Constraint目前只支持PRIMARY KEY和UNIQUE两种约束。
l Informational Constraint目前支持NOT ENFORCED属性,ENFORCED属性不支
持,创建时直接报错。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
810GaussDB 200
开发者指南
16 SQL 参考
l HDFS外表和HDFS分区外表都支持Informational Constraint(分区列上同样可以建
立约束)。
l 一个表上的多列可以分别建立UNIQUE类型的Informational Constraint,但是
PRIMARY KEY一个表中只能建立一个。
l 一个表的一列上可以建立多个Informational Constraint(由于一个列上有多个约束
和一个的作用一致,所以不建议一个列上建立多个Informational Constraint),但
是Primary Key类型只能建立一个。
l 不支持多列组合约束。
示例
示例一:在HDFS通过HIVE导入TPC-H benchmark测试数据表part表及region表。文件的
part表路径为/user/hive/warehouse/partition.db/part_4 , region表路径为/user/hive/
warehouse/mppdb.db/region_orc11_64stripe/ 。
l
建立HDFS_Server,对应的foreign data wrapper为HDFS_FDW或者DFS_FDW。
--创建HDFS_Server。
CREATE SERVER hdfs_server FOREIGN DATA WRAPPER HDFS_FDW OPTIONS (address
hadoop_client/HDFS/hadoop/etc/hadoop',type'HDFS');
,hdfscfgpath '/opt/
说明
在可选项options里面写入了HDFS集群对应的NameNode的IP地址及端口号。
‘10.10.0.100:25000,10.10.0.101:25000’中列出了两组NameNode的地址及端口号,分别表
示HDFS的主NameNode及备NameNode,这里推荐使用该种主备方式填写。两组参量中间
使用“,”进行分割,以第一组参量‘10.10.0.100:25000’为例,其IP地址为10.10.0.100,端
口号为25000 。
l
建立HDFS外表。
--建立不包含分区列的HDFS外表,表关联的HDFS server为hdfs_server,表region对应的HDFS服务器上的
文件格式为‘orc’,在HDFS文件系统上对应的文件目录为'/user/hive/warehouse/mppdb.db/
region_orc11_64stripe/'。
CREATE FOREIGN TABLE region
(
R_REGIONKEY INT4,
R_NAME TEXT,
R_COMMENT TEXT
)
SERVER
hdfs_server
OPTIONS
(
FORMAT 'orc',
encoding 'utf8',
FOLDERNAME '/user/hive/warehouse/mppdb.db/region_orc11_64stripe/'
)
DISTRIBUTE BY
roundrobin;
--建立包含分区列的HDFS外表。
CREATE FOREIGN TABLE part
(
p_partkey int,
p_name text,
p_mfgr text,
p_brand text,
p_type text,
p_size int,
p_container text,
p_retailprice float8,
p_comment text
)
SERVER
hdfs_server
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
811GaussDB 200
开发者指南
16 SQL 参考
OPTIONS
(
FORMAT 'orc',
encoding 'utf8',
FOLDERNAME '/user/hive/warehouse/partition.db/part_4'
)
DISTRIBUTE BY
roundrobin
PARTITION BY
(p_mfgr) AUTOMAPPED;
说明
GaussDB 200支持2种文件指定方式:通过关键字filenames指定和通过foldername指定。推荐
通过使用foldername进行指定。关键字distribute指定了表region的存储分布方式。
l
查看建立的外表。
--查看外表。
SELECT * FROM pg_foreign_table WHERE ftrelid='region'::regclass;
ftrelid | ftserver | ftwriteonly |
ftoptions
---------+----------+-------------
+------------------------------------------------------------------------------
16510 |
16509 | f
| {format=orc,foldername=/user/hive/warehouse/mppdb.db/
region_orc11_64stripe/}
(1 row)
select * from pg_foreign_table where ftrelid='part'::regclass;
ftrelid | ftserver | ftwriteonly |
ftoptions
---------+----------+-------------
+------------------------------------------------------------------
16513 |
16509 | f
| {format=orc,foldername=/user/hive/warehouse/partition.db/
part_4}
(1 row)
l
修改、删除外表。
--修改外表。
ALTER FOREIGN TABLE region ALTER r_name TYPE TEXT;
ALTER FOREIGN TABLE
ALTER FOREIGN TABLE region ALTER r_name SET NOT NULL;
ALTER FOREIGN TABLE
--删除外表。
DROP FOREIGN TABLE region;
DROP FOREIGN TABLE
示例二:关于包含信息约束(Informational Constraint)HDFS外表的相关操作。
--创建含有信息约束(Informational Constraint)的HDFS外表。
CREATE FOREIGN TABLE region (
R_REGIONKEY int,
R_NAME TEXT,
R_COMMENT TEXT
, primary key (R_REGIONKEY) not enforced)
SERVER hdfs_server
OPTIONS(format 'orc',
encoding 'utf8',
foldername '/user/hive/warehouse/mppdb.db/region_orc11_64stripe')
DISTRIBUTE BY roundrobin;
--查看region表是否有信息约束索引。
SELECT relname,relhasindex FROM pg_class WHERE oid='region'::regclass;
relname
| relhasindex
------------------------+-------------
region
| f
(1 row)
SELECT conname, contype, consoft, conopt, conindid, conkey FROM pg_constraint WHERE conname
='region_pkey';
conname
| contype | consoft | conopt | conindid | conkey
-------------+---------+---------+--------+----------+--------
region_pkey | p
| t
| t
|
0 | {1}
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
812GaussDB 200
开发者指南
16 SQL 参考
(1 row)
--删除信息约束。
ALTER FOREIGN TABLE region DROP CONSTRAINT region_pkey RESTRICT;
SELECT conname, contype, consoft, conindid, conkey FROM pg_constraint WHERE conname ='region_pkey';
conname | contype | consoft | conindid | conkey
---------+---------+---------+----------+--------
(0 rows)
--添加一个唯一信息约束。
ALTER FOREIGN TABLE region ADD CONSTRAINT constr_unique UNIQUE(R_REGIONKEY) NOT ENFORCED;
--删除信息约束。
ALTER FOREIGN TABLE region DROP CONSTRAINT constr_unique RESTRICT;
SELECT conname, contype, consoft, conindid, conkey FROM pg_constraint WHERE conname
='constr_unique';
conname | contype | consoft | conindid | conkey
---------+---------+---------+----------+--------
(0 rows)
--为外表添加一个唯一信息约束。
ALTER FOREIGN TABLE region ADD CONSTRAINT constr_unique UNIQUE(R_REGIONKEY) NOT ENFORCED disable
query optimization;
SELECT relname,relhasindex FROM pg_class WHERE oid='region'::regclass;
relname
| relhasindex
------------------------+-------------
region
| f
(1 row)
--删除信息约束。
ALTER FOREIGN TABLE region DROP CONSTRAINT constr_unique CASCADE;
--删除region表。
DROP FOREIGN TABLE region;
--删除hdfs_server
DROP SERVER hdfs_server;
相关链接
16.14.8 ALTER FOREIGN TABLE (SQL on Hadoop),16.14.84 DROP FOREIGN
TABLE
16.14.52 CREATE FOREIGN TABLE (SQL on other GaussDB 200)
功能描述
在当前数据库创建一个协同分析的外表,用来访问存储在协同分析其他集群数据库中
的表。
该外表是只读的,只能用于查询操作,可直接使用SELECT语句查询其数据。
语法格式
CREATE FOREIGN TABLE [ IF NOT EXISTS ] table_name
( [ { column_name type_name | LIKE source_table } [, ...] ] )
SERVER server_name
OPTIONS ( { option_name ' value ' } [, ...] )
[ READ ONLY ]
[ DISTRIBUTE BY {ROUNDROBIN} ]
[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
813GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
IF NOT EXISTS
如果已经存在相同名称的表,不会抛出一个错误,而会发出一个通知,告知表关
系已存在。
l
table_name
外表的表名。
取值范围:字符串,要符合标识符的命名规范。
l
column_name
外表中的字段名。可以选择多个字段名,中间用“,”隔开。
取值范围:字符串,要符合标识符的命名规范。
说明
不允许在列上创建约束,也不允许创建索引。
l
type_name
字段的数据类型。
说明
不允许使用序列当作类型和使用自定义类型。
l
SERVER hdfs_server
外表的server名字。允许用户自定义名字。
取值范围:字符串,要符合标识符的命名规范,并且这个server必须存在。
l
OPTIONS ( { option_name ' value ' } [, ...] )
用于指定外表数据的各类参数,参数类型如下所示。
l
– table_name:对应关联集群的表名,如果省略此option则认为该值和外表名字
一样。
– schema_name:对应关联集群的schema,如果省略此option则认为该值和外表
所在的schema一样。
– encoding:对应关联集群的编码,如果省略此option则使用关联集群的数据库
编码。
READ ONLY
显示表是外表为只读。
l
DISTRIBUTE BY ROUNDROBIN
显示指定外表为ROUNDROBIN分布方式。
l
TO { GROUP groupname | NODE ( nodename [, ... ] ) }
TO GROUP目前不支持使用。TO NODE主要供内部扩容工具使用,一般用户不应
使用。
示例
l
建立remort_server,对应的foreign data wrapper为GC_FDW。
--创建Server。
CREATE SERVER server_remote FOREIGN DATA WRAPPER GC_FDW OPTIONS (address
'10.146.187.231:8000,10.180.157.130:8000' ,dbname 'test', username 'test', password
'Xx123456@');
说明
在可选项options里面写入了关联集群CN对应的IP地址及端口号。这里推荐使用填写一个
LVS的地址或者多个CN的地址。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
814GaussDB 200
开发者指南
16 SQL 参考
l
创建外表
CREATE FOREIGN TABLE region
(
R_REGIONKEY INT4,
R_NAME TEXT,
R_COMMENT TEXT
)
SERVER
server_remote
OPTIONS
(
schema_name 'test',
table_name 'region',
encoding 'gbk'
);
l
查看建立的外表。
--查看外表。
\d+ region
Foreign table "public.region"
Column
| Type
| Modifiers | FDW Options | Storage | Stats target | Description
-------------+---------+-----------+-------------+----------+--------------+-------------
r_regionkey | integer |
|
| plain
|
|
r_name
| text
|
|
| extended |
|
r_comment
| text
|
|
| extended |
|
Server: server_remote
FDW Options: (schema_name 'test', table_name 'region', encoding 'gbk')
FDW permition: read only
Has OIDs: no
Distribute By: ROUND ROBIN
Location Nodes: ALL DATANODES
l
修改、删除外表。
--修改外表。
ALTER FOREIGN TABLE region ALTER r_name TYPE TEXT;
ALTER FOREIGN TABLE
ALTER FOREIGN TABLE region OPTIONS (SET schema_name 'test');
ALTER FOREIGN TABLE
--删除外表。
DROP FOREIGN TABLE region;
DROP FOREIGN TABLE
相关链接
16.14.84 DROP FOREIGN TABLE,16.14.9 ALTER FOREIGN TABLE (SQL on other
GaussDB 200)
16.14.53 CREATE FUNCTION
功能描述
创建一个函数。
注意事项
l 如果创建函数时参数或返回值带有精度,不进行精度检测。
l 创建函数时,函数定义中对表对象的操作建议都显式指定模式,否则可能会导致
函数执行异常。
l 在创建函数时,函数内部通过SET语句设置current_schema和search_path无效。执
行完函数search_path和current_schema与执行函数前的search_path和current_schema
保持一致。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
815GaussDB 200
开发者指南
16 SQL 参考
l 如果函数参数中带有出参,SELECT调用函数必须缺省出参,CALL调用函数适配
Oracle必须指定出参,对于调用重载的带有PACKAGE属性的函数,CALL调用函
数可以缺省出参,具体信息参见16.14.36 CALL的示例。
l 兼容Postgresql风格的函数或者带有PACKAGE属性的函数支持重载。在指定
REPLACE的时候,如果参数个数、类型、返回值有变化,不会替换原有函数,而
是会建立新的函数。
l SELECT调用可以指定不同参数来进行同名函数调用。由于语法CALL适配自
Oracle,因此不支持调用不带有PACKAGE属性的同名函数。
l 在创建function时,不能在avg函数外面嵌套其他agg函数,或者其他系统函数。
l 在非逻辑集群模式下,暂不支持将返回值、参数以及变量设置为建在非系统默认
安装Node Group的表,sql function内部语句暂不支持对建在非系统默认安装Node
Group的表操作。
l 在逻辑集群模式下,如果函数返回值和参数是用户表类型,所有涉及表都必须在
同一逻辑集群内;如果函数体内部涉及对多个逻辑集群表操作,函数定义时不能
为IMMUTABLE和SHIPPABLE类型,以避免函数被下推到DN执行。
l 在逻辑集群模式下,函数参数、返回值不能用%type引用表字段类型,否则会导致
函数创建失败。
l 新创建的函数默认会给PUBLIC授予执行权限(详见16.14.112 GRANT)。用户可
以选择收回PUBLIC默认执行权限,然后根据需要将执行权限授予其他用户,为了
避免出现新函数能被所有人访问的时间窗口,应在一个事务中创建函数并且设置
函数执行权限。
l 兼容PostgreSQL风格的创建自定义函数语法。
语法格式
CREATE [ OR REPLACE ] FUNCTION function_name
( [ { argname [ argmode ] argtype [ { DEFAULT | := | = } expression ]}
[, ...] ] )
[ RETURNS rettype [ DETERMINISTIC ] | RETURNS TABLE ( { column_name column_type }
[, ...] )]
LANGUAGE lang_name
[
{IMMUTABLE | STABLE | VOLATILE }
| {SHIPPABLE | NOT SHIPPABLE}
| WINDOW
| [ NOT ] LEAKPROOF
| {CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
| {[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER | AUTHID DEFINER
| AUTHID CURRENT_USER}
| {fenced | not fenced}
| {PACKAGE}
| COST execution_cost
| ROWS result_rows
| SET configuration_parameter { {TO | =} value | FROM CURRENT }}
][...]
{
AS 'definition'
| AS 'obj_file', 'link_symbol'
}
l
Oracle风格的创建自定义函数的语法。
CREATE [ OR REPLACE ] FUNCTION function_name
( [ { argname [ argmode ] argtype [ { DEFAULT | := | =
[, ...] ] )
RETURN rettype [ DETERMINISTIC ]
[
{IMMUTABLE | STABLE | VOLATILE }
| {SHIPPABLE | NOT SHIPPABLE}
| {PACKAGE}
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
} expression
] }
816GaussDB 200
开发者指南
16 SQL 参考
| {FENCED | NOT FENCED}
| [ NOT ] LEAKPROOF
| {CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
| {[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER |
AUTHID DEFINER | AUTHID CURRENT_USER
}
| COST execution_cost
| ROWS result_rows
| SET configuration_parameter { {TO | =} value | FROM CURRENT
][...]
{
IS | AS
} plsql_body
/
参数说明
l
function_name
要创建的函数名字(可以用模式修饰)。
取值范围:字符串,要符合标识符的命名规范。
l
argname
函数参数的名字。
取值范围:字符串,要符合标识符的命名规范。
l
argmode
函数参数的模式。
取值范围:IN,OUT,INOUT或VARIADIC。缺省值是IN。只有OUT模式的参数
后面能跟VARIADIC。并且OUT和INOUT模式的参数不能用在RETURNS TABLE
的函数定义中。
说明
VARIADIC用于声明数组类型的参数。
l
argtype
函数参数的类型。
l
expression
参数的默认表达式。
l
rettype
函数返回值的数据类型。
如果存在OUT或IN OUT参数,可以省略RETURNS子句。如果存在,该子句必须
和输出参数所表示的结果类型一致:如果有多个输出参数,则为RECORD,否则
与单个输出参数的类型相同。
SETOF修饰词表示该函数将返回一个集合,而不是单独一项。
l
DETERMINISTIC
为适配oracle SQL语法,未实现功能,不推荐使用。
l
column_name
字段名称。
l
column_type
字段类型。
l
definition
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
817GaussDB 200
开发者指南
16 SQL 参考
一个定义函数的字符串常量,含义取决于语言。它可以是一个内部函数名字、一
个指向某个目标文件的路径、一个SQL查询、一个过程语言文本。
l
LANGUAGE lang_name
用以实现函数的语言的名字。可以是SQL,C,internal,或者是用户定义的过程语
言名字。为了保证向下兼容,该名字可以用单引号(包围)。若采用单引号,则
引号内必须为大写。
l
WINDOW
表示该函数是窗口函数,通常只用于C语言编写的函数。替换函数定义时不能改变
WINDOW属性。
自定义窗口函数只支持LANGUAGE是internal,并且引用的内部函数必须是窗口函
数。
l
IMMUTABLE
表示该函数在给出同样的参数值时总是返回同样的结果。
l
STABLE
表示该函数不能修改数据库,对相同参数值,在同一次表扫描里,该函数的返回
值不变,但是返回值可能在不同SQL语句之间变化。
l
VOLATILE
表示该函数值可以在一次表扫描内改变,因此不会做任何优化。
l
SHIPPABLE
NOT SHIPPABLE
表示该函数是否可以下推到DN上执行。
l
– 对于IMMUTABLE类型的函数,函数始终可以下推到DN上执行。
– 对于STABLE/VOLATILE类型的函数,仅当函数的属性是SHIPPABLE的时
候,函数可以下推到DN执行。
PACKAGE
表示该函数是否支持重载。PostgreSQL风格的函数本身就支持重载,此参数主要
是针对Oracle风格的函数。
l
– 不允许package函数和非package函数重载或者替换。
– package函数不支持VARIADIC类型的参数。
– 不允许修改函数的package属性。
LEAKPROOF
指出该函数的参数只包括返回值。LEAKPROOF只能由系统管理员设置。
l
CALLED ON NULL INPUT
表明该函数的某些参数是NULL的时候可以按照正常的方式调用。该参数可以省
略。
l
RETURNS NULL ON NULL INPUT
STRICT
STRICT用于指定如果函数的某个参数是NULL,此函数总是返回NULL。如果声
明了这个参数,当有NULL值参数时该函数不会被执行;而只是自动返回一个
NULL结果。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
818GaussDB 200
开发者指南
16 SQL 参考
RETURNS NULL ON NULL INPUT和STRICT的功能相同。
l
EXTERNAL
目的是和SQL兼容,是可选的,这个特性适合于所有函数,而不仅是外部函数。
l
SECURITY INVOKER
AUTHID CURRENT_USER
表明该函数将带着调用它的用户的权限执行。该参数可以省略。
SECURITY INVOKER和AUTHID CURRENT_USER的功能相同。
l
SECURITY DEFINER
AUTHID DEFINER
声明该函数将以创建它的用户的权限执行。
AUTHID DEFINER和SECURITY DEFINER的功能相同。
l
FENCED
NOT FENCED
该函数只对用户定义的C函数生效,声明函数是在保护模式还是非保护模式下执
行。如果函数声明为NOT FENCED模式,则函数的执行在CN或者DN进程中进
行。如果函数声明为FENCED模式,则函数在新fork的进程执行,这样函数的异常
不会影响CN或者DN进程。
FENCED/NOT FENCED模式的选择:
l
– 正在开发或者调试的Function使用FENCED模式。开发测试完成,使用NOT
FENCED模式执行,减少fork进程以及通信的开销。
– 复杂的操作系统操作,例:打开文件,信号处理,线程处理等操作,使用
FENCED模式。否则可能影响GaussDB 200数据库的执行。
– 默认值为FENCED。
– C函数定义以及示例请参考:17.1 C语言函数
COST execution_cost
用来估计函数的执行成本。
execution_cost以cpu_operator_cost为单位。
取值范围:正数
l
ROWS result_rows
估计函数返回的行数。用于函数返回的是一个集合。
取值范围:正数,默认值是1000行。
l
configuration_parameter
–
value
把指定的数据库会话参数值设置为给定的值。如果value是DEFAULT或者
RESET,则在新的会话中使用系统的缺省设置。OFF关闭设置。
取值范围:字符串
n DEFAULT
n OFF
n RESET
指定默认值。
–
from current
取当前会话中的值设置为configuration_parameter的值。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
819GaussDB 200
开发者指南
16 SQL 参考
l
obj_file, link_symbol
适用于C语言函数,字符串obj_file指定了动态库的绝对路径;link_symbol 指定了
该函数的链接符号,也就是该函数在C代码中的函数名称。
l
plsql_body
PL/SQL存储过程体。
当在函数体中创建用户时,日志中会记录密码的明文。因此不建议用户在函数体
中创建用户。
示例
--定义函数为SQL查询。
CREATE FUNCTION func_add_sql(integer, integer) RETURNS integer
AS 'select $1 + $2;'
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;
--利用参数名用 PL/pgSQL 自增一个整数。
CREATE OR REPLACE FUNCTION func_increment_plsql(i integer) RETURNS integer AS $$
BEGIN
RETURN i + 1;
END;
$$ LANGUAGE plpgsql;
--返回RECORD类型
CREATE OR REPLACE FUNCTION compute(i int, out result_1 bigint, out result_2 bigint)
returns SETOF RECORD
as $$
begin
result_1 = i + 1;
result_2 = i * 10;
return next;
end;
$$language plpgsql;
--返回一个包含多个输出参数的记录。
CREATE FUNCTION func_dup_sql(in int, out f1 int, out f2 text)
AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
LANGUAGE SQL;
SELECT * FROM func_dup_sql(42);
--计算两个整数的和,并返回结果。若果输入为null,则返回null。
CREATE FUNCTION func_add_sql2(num1 integer, num2 integer) RETURN integer
AS
BEGIN
RETURN num1 + num2;
END;
/
--创建package属性的重载函数
create or replace function package_func_overload(col int, col2 int)
return integer package
as
declare
col_type text;
begin
col := 122;
dbms_output.put_line('two int parameters ' || col2);
return 0;
end;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
820GaussDB 200
开发者指南
16 SQL 参考
/
create or replace function package_func_overload(col int, col2 smallint)
return integer package
as
declare
col_type text;
begin
col := 122;
dbms_output.put_line('two smallint parameters ' || col2);
return 0;
end;
/
--修改函数add的执行规则为IMMUTABLE,即参数不变时返回相同结果。
ALTER FUNCTION func_add_sql2(INTEGER, INTEGER) IMMUTABLE;
--将函数add的名称修改为add_two_number。
ALTER FUNCTION func_add_sql2(INTEGER, INTEGER) RENAME TO add_two_number;
--将函数add的属者改为omm。
ALTER FUNCTION add_two_number(INTEGER, INTEGER) OWNER TO omm;
--删除函数。
DROP FUNCTION
DROP FUNCTION
DROP FUNCTION
DROP FUNCTION
DROP FUNCTION
add_two_number;
func_increment_sql;
func_dup_sql;
func_increment_plsql;
func_add_sql;
相关链接
16.14.10 ALTER FUNCTION,16.14.85 DROP FUNCTION
16.14.54 CREATE GROUP
功能描述
创建一个新用户组。
注意事项
CREATE GROUP是CREATE ROLE的别名,非SQL标准语法,不推荐使用,建议用户
直接使用CREATE ROLE替代。
语法格式
CREATE GROUP group_name [ [ WITH ] option [ ... ] ]
[ ENCRYPTED | UNENCRYPTED ] { PASSWORD | IDENTIFIED BY } { 'password' | DISABLE };
其中可选项action子句语法为:
where option can be:
{SYSADMIN | NOSYSADMIN}
| {AUDITADMIN | NOAUDITADMIN}
| {CREATEDB | NOCREATEDB}
| {USEFT | NOUSEFT}
| {CREATEROLE | NOCREATEROLE}
| {INHERIT | NOINHERIT}
| {LOGIN | NOLOGIN}
| {REPLICATION | NOREPLICATION}
| {INDEPENDENT | NOINDEPENDENT}
| {VCADMIN | NOVCADMIN}
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
821GaussDB 200
开发者指南
16 SQL 参考
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
CONNECTION LIMIT connlimit
VALID BEGIN 'timestamp'
VALID UNTIL 'timestamp'
RESOURCE POOL 'respool'
USER GROUP 'groupuser'
PERM SPACE 'spacelimit'
NODE GROUP logic_group_name
IN ROLE role_name [, ...]
IN GROUP role_name [, ...]
ROLE role_name [, ...]
ADMIN role_name [, ...]
USER role_name [, ...]
SYSID uid
DEFAULT TABLESPACE tablespace_name
PROFILE DEFAULT
PROFILE profile_name
PGUSER
参数说明
请参考CREATE ROLE的参数说明。
相关链接
16.14.11 ALTER GROUP,16.14.86 DROP GROUP,16.14.61 CREATE ROLE
16.14.55 CREATE INDEX
功能描述
在指定的表上创建索引。
索引可以用来提高数据库查询性能,但是不恰当的使用将导致数据库性能下降。建议
仅在匹配如下某条原则时创建索引:
l 经常执行查询的字段。
l 在连接条件上创建索引,对于存在多字段连接的查询,建议在这些字段上建立组
合索引。例如,select * from t1 join t2 on t1.a=t2.a and t1.b=t2.b,可以在t1表上的
a,b字段上建立组合索引。
l where子句的过滤条件字段上(尤其是范围条件)。
l 在经常出现在order by、group by和distinct后的字段。
在分区表上创建索引与在普通表上创建索引的语法不太一样,使用时请注意,如分区
表上不支持并行创建索引、不支持创建部分索引、不支持NULL FIRST特性。
注意事项
l 索引自身也占用存储空间、消耗计算资源,创建过多的索引将对数据库性能造成
负面影响(尤其影响数据导入的性能,建议在数据导入后再建索引)。因此,仅
在必要时创建索引。
l 索引定义里的所有函数和操作符都必须是immutable类型的,即它们的结果必须只
能依赖于它们的输入参数,而不受任何外部的影响(如另外一个表的内容或者当
前时间)。这个限制可以确保该索引的行为是定义良好的。要在一个索引上或
WHERE中使用用户定义函数,请把它标记为immutable类型函数。
l 在分区表上创建唯一索引时,索引项中必须包含分布列和所有分区键。
l 列存表和HDFS表支持的PSORT和B-tree索引都不支持创建表达式索引、部分索引
和唯一索引。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
822GaussDB 200
开发者指南
16 SQL 参考
l 列存表支持的GIN索引支持创建表达式索引,但表达式不能包含空分词、空列和
多列,不支持创建部分索引和唯一索引。
l HDFS表支持创建多个索引,索引涉及的总列数建议不超过16个。
语法格式
l
在表上创建索引。
CREATE [ UNIQUE ] INDEX [ index_name ] ON table_name [ USING method ]
({ { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ]
[ NULLS { FIRST | LAST } ] }[, ...] )
[ WITH ( {storage_parameter = value} [, ... ] ) ]
[ TABLESPACE tablespace_name ]
[ WHERE predicate ];
l
在分区表上创建索引。
CREATE [ UNIQUE ] INDEX [ index_name ] ON table_name [ USING method ]
( {{ column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ]
[ NULLS LAST ] }[, ...] )
LOCAL [ ( { PARTITION index_partition_name [ TABLESPACE index_partition_tablespace ] }
[, ...] ) ]
[ WITH ( { storage_parameter = value } [, ...] ) ]
[ TABLESPACE tablespace_name ];
参数说明
l
UNIQUE
创建唯一性索引,每次添加数据时检测表中是否有重复值。如果插入或更新的值
会引起重复的记录时,将导致一个错误。
目前只有行存表B-tree索引支持唯一索引。
l
index_name
要创建的索引名,不能包含模式名,索引的模式与表相同。
取值范围:字符串,要符合标识符的命名规范。
l
table_name
需要为其创建索引的表的名字,可以用模式修饰。
取值范围:已存在的表名。
l
USING method
指定创建索引的方法。
取值范围:
– btree:B-tree索引使用一种类似于B+树的结构来存储数据的键值,通过这种结
构能够快速的查找索引。btree适合支持比较查询以及查询范围。
– gin:GIN索引是倒排索引,可以处理包含多个键的值(比如数组)。
– gist:Gist索引适用于几何和地理等多维数据类型和集合数据类型。
– Psort:Psort索引。针对列存表进行局部排序索引。
行存表支持的索引类型:btree(行存表缺省值)、gin、gist。列存表支持的索引类
型:Psort(列存表缺省值)、btree、gin。
l
column_name
表中需要创建索引的列的名字(字段名)。
如果索引方式支持多字段索引,可以声明多个字段。最多可以声明32个字段。
l
expression
创建一个基于该表的一个或多个字段的表达式索引,通常必须写在圆括弧中。如
果表达式有函数调用的形式,圆括弧可以省略。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
823GaussDB 200
开发者指南
16 SQL 参考
表达式索引可用于获取对基本数据的某种变形的快速访问。比如,一个在
upper(col)上的函数索引将允许WHERE upper(col) = 'JIM'子句使用索引。
在创建表达式索引时,如果表达式中包含IS NULL子句,则这种索引是无效的。
此时,建议用户尝试创建一个部分索引。
l
COLLATE collation
COLLATE子句指定列的排序规则(该列必须是可排列的数据类型)。如果没有指
定,则使用默认的排序规则。
l
opclass
操作符类的名字。对于索引的每一列可以指定一个操作符类,操作符类标识了索
引那一列的使用的操作符。例如一个B-tree索引在一个四字节整数上可以使用
int4_ops;这个操作符类包括四字节整数的比较函数。实际上对于列上的数据类型
默认的操作符类是足够用的。操作符类主要用于一些有多种排序的数据。例如,
用户想按照绝对值或者实数部分排序一个复数。能通过定义两个操作符类然后当
建立索引时选择合适的类。
l
ASC
指定按升序排序 (默认)。
l
DESC
指定按降序排序。
l
NULLS FIRST
指定空值在排序中排在非空值之前,当指定DESC排序时,本选项为默认的。
l
NULLS LAST
指定空值在排序中排在非空值之后,未指定DESC排序时,本选项为默认的。
l
WITH ( {storage_parameter = value} [, ... ] )
指定索引方法的存储参数。
取值范围:
只有GIN索引支持FASTUPDATE,GIN_PENDING_LIST_LIMIT参数。GIN和Psort
之外的索引都支持FILLFACTOR参数。
–
FILLFACTOR
一个索引的填充因子(fillfactor)是一个介于10和100之间的百分数。
取值范围:10~100
–
FASTUPDATE
GIN索引是否使用快速更新。
取值范围:ON,OFF
默认值:ON
–
GIN_PENDING_LIST_LIMIT
当GIN索引启用fastupdate时,设置该索引pending list容量的最大值。
取值范围:64~INT_MAX,单位KB。
默认值:gin_pending_list_limit的默认取决于GUC中gin_pending_list_limit的值
(默认为4MB)
l
TABLESPACE tablespace_name
指定索引的表空间,如果没有声明则使用默认的表空间。
取值范围:已存在的表空间名。
l
WHERE predicate
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
824GaussDB 200
开发者指南
16 SQL 参考
创建一个部分索引。部分索引是一个只包含表的一部分记录的索引,通常是该表
中比其他部分数据更有用的部分。例如,有一个表,表里包含已记账和未记账的
定单,未记账的定单只占表的一小部分而且这部分是最常用的部分,此时就可以
通过只在未记账部分创建一个索引来改善性能。另外一个可能的用途是使用带有
UNIQUE的WHERE强制一个表的某个子集的唯一性。
取值范围:predicate表达式只能引用表的字段,它可以使用所有字段,而不仅是被
索引的字段。目前,子查询和聚集表达式不能出现在WHERE子句里。
l
PARTITION index_partition_name
索引分区的名称。
取值范围:字符串,要符合标识符的命名规范。
l
TABLESPACE index_partition_tablespace
索引分区的表空间。
取值范围:如果没有声明,将使用分区表索引的表空间index_tablespace。
示例
--创建表tpcds.ship_mode_t1。
CREATE TABLE tpcds.ship_mode_t1
(
SM_SHIP_MODE_SK
INTEGER
SM_SHIP_MODE_ID
CHAR(16)
SM_TYPE
CHAR(30)
SM_CODE
CHAR(10)
SM_CARRIER
CHAR(20)
SM_CONTRACT
CHAR(20)
)
DISTRIBUTE BY HASH(SM_SHIP_MODE_SK);
NOT NULL,
NOT NULL,
,
,
,
--在表tpcds.ship_mode_t1上的SM_SHIP_MODE_SK字段上创建普通索引。
CREATE UNIQUE INDEX ds_ship_mode_t1_index1 ON tpcds.ship_mode_t1(SM_SHIP_MODE_SK);
--在表tpcds.ship_mode_t1上的SM_SHIP_MODE_SK字段上创建指定B-tree索引。
CREATE INDEX ds_ship_mode_t1_index4 ON tpcds.ship_mode_t1 USING btree(SM_SHIP_MODE_SK);
--在表tpcds.ship_mode_t1上SM_CODE字段上创建表达式索引。
CREATE INDEX ds_ship_mode_t1_index2 ON tpcds.ship_mode_t1(SUBSTR(SM_CODE,1 ,4));
--在表tpcds.ship_mode_t1上的SM_SHIP_MODE_SK字段上创建SM_SHIP_MODE_SK大于10的部分索引。
CREATE UNIQUE INDEX ds_ship_mode_t1_index3 ON tpcds.ship_mode_t1(SM_SHIP_MODE_SK) WHERE
SM_SHIP_MODE_SK>10;
--重命名一个现有的索引。
ALTER INDEX tpcds.ds_ship_mode_t1_index1 RENAME TO ds_ship_mode_t1_index5;
--设置索引不可用。
ALTER INDEX tpcds.ds_ship_mode_t1_index2 UNUSABLE;
--重建索引。
ALTER INDEX tpcds.ds_ship_mode_t1_index2 REBUILD;
--删除一个现有的索引。
DROP INDEX tpcds.ds_ship_mode_t1_index2;
--删除表。
DROP TABLE tpcds.ship_mode_t1;
--创建表tpcds.customer_address_p1。
CREATE TABLE tpcds.customer_address_p1
(
CA_ADDRESS_SK
INTEGER
CA_ADDRESS_ID
CHAR(16)
CA_STREET_NUMBER
CHAR(10)
文档版本 01 (2019-08-01)
NOT NULL,
NOT NULL,
,
版权所有 © 华为技术有限公司
825GaussDB 200
开发者指南
16 SQL 参考
CA_STREET_NAME
CA_STREET_TYPE
CA_SUITE_NUMBER
CA_CITY
CA_COUNTY
CA_STATE
CA_ZIP
CA_COUNTRY
CA_GMT_OFFSET
CA_LOCATION_TYPE
VARCHAR(60)
CHAR(15)
CHAR(10)
VARCHAR(60)
VARCHAR(30)
CHAR(2)
CHAR(10)
VARCHAR(20)
DECIMAL(5,2)
CHAR(20)
,
,
,
,
,
,
,
,
,
)
TABLESPACE example1
DISTRIBUTE BY HASH(CA_ADDRESS_SK)
PARTITION BY RANGE(CA_ADDRESS_SK)
(
PARTITION p1 VALUES LESS THAN (3000),
PARTITION p2 VALUES LESS THAN (5000) TABLESPACE example1,
PARTITION p3 VALUES LESS THAN (MAXVALUE) TABLESPACE example2
)
ENABLE ROW MOVEMENT;
--创建分区表索引ds_customer_address_p1_index1,不指定索引分区的名字。
CREATE INDEX ds_customer_address_p1_index1 ON tpcds.customer_address_p1(CA_ADDRESS_SK) LOCAL;
--创建分区表索引ds_customer_address_p1_index2,并指定索引分区的名字。
CREATE INDEX ds_customer_address_p1_index2 ON tpcds.customer_address_p1(CA_ADDRESS_SK) LOCAL
(
PARTITION CA_ADDRESS_SK_index1,
PARTITION CA_ADDRESS_SK_index2 TABLESPACE example3,
PARTITION CA_ADDRESS_SK_index3 TABLESPACE example4
)
TABLESPACE example2;
--修改分区表索引CA_ADDRESS_SK_index2的表空间为example1。
ALTER INDEX tpcds.ds_customer_address_p1_index2 MOVE PARTITION CA_ADDRESS_SK_index2 TABLESPACE
example1;
--修改分区表索引CA_ADDRESS_SK_index3的表空间为example2。
ALTER INDEX tpcds.ds_customer_address_p1_index2 MOVE PARTITION CA_ADDRESS_SK_index3 TABLESPACE
example2;
--重命名分区表索引。
ALTER INDEX tpcds.ds_customer_address_p1_index2 RENAME PARTITION CA_ADDRESS_SK_index1 TO
CA_ADDRESS_SK_index4;
--删除索引和分区表。
DROP INDEX tpcds.ds_customer_address_p1_index1;
DROP INDEX tpcds.ds_customer_address_p1_index2;
DROP TABLE tpcds.customer_address_p1;
--删除表空间。
DROP TABLESPACE
DROP TABLESPACE
DROP TABLESPACE
DROP TABLESPACE
example1;
example2;
example3;
example4;
相关链接
16.14.12 ALTER INDEX,16.14.87 DROP INDEX
16.14.56 CREATE NODE
功能描述
创建一个新的集群节点。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
826GaussDB 200
开发者指南
16 SQL 参考
注意事项
CREATE NODE是集群管理工具封装的内部接口,用来实现集群管理。该接口不建议
用户直接使用,以免对集群状态造成影响。
语法格式
CREATE NODE nodename WITH
(
[ TYPE = nodetype,]
[ HOST = hostname,]
[ PORT = portnum,]
[ HOST1 = 'hostname',]
[ PORT1 = portnum,]
[ HOSTPRIMARY [ = boolean ],]
[ PRIMARY [ = boolean ],]
[ PREFERRED [ = boolean ],]
[ SCTP_PORT = portnum,]
[ CONTROL_PORT = portnum,]
[ SCTP_PORT1 = portnum,]
[ CONTROL_PORT1 = portnum ]
);
参数说明
l
nodename
节点名称。
取值范围:字符串,要符合标识符的命名规范。
l
TYPE = nodetype
指定节点的类型。
取值范围:
l
– 'coordinator'
– 'datanode'
HOST = hostname
指定节点对应的主机名称或者IP地址。
l
PORT = portnum
指定节点绑定的主机端口号。
l
HOST1 = hostname
指定节点对应的备机名称或者IP地址。
l
PORT1 = portnum
指定节点绑定的备机端口号。
l HOSTPRIMARY
l PRIMARY = boolean
声明该节点是否为主节点。主节点允许做读写操作,否则只允许读操作。
取值范围:
l
– true
– false(默认值)
PREFERRED = boolean
声明该节点是否为读操作的首选节点。
取值范围:
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
827GaussDB 200
开发者指南
16 SQL 参考
l
– true
– false(默认值)
SCTP_PORT = portnum
主机TCP代理通信库或SCTP通信库使用的数据传输通道监听端口,使用TCP或
SCTP协议监听连接。
l
CONTROL_PORT = portnum
主机TCP代理通信库或SCTP通信库使用的控制传输通道监听端口,使用TCP协议
监听连接。
l
SCTP_PORT1 = portnum
备机TCP代理通信库或SCTP通信库使用的数据传输通道监听端口,使用TCP或
SCTP协议监听连接。
l
CONTROL_PORT 1= portnum
备机TCP代理通信库或SCTP通信库使用的控制传输通道监听端口,使用TCP协议
监听连接。
相关链接
16.14.14 ALTER NODE,16.14.88 DROP NODE。
16.14.57 CREATE NODE GROUP
功能描述
创建一个新的集群节点组。
注意事项
l CREATE NODE GROUP是集群管理工具封装的内部接口,用来实现集群管理。
l 该接口仅对管理员用户开放使用。
语法格式
CREATE NODE GROUP groupname
WITH ( nodename [, ... ] )
[ BUCKETS [ ( bucketnumber [, ... ] ) ] ] [VCGROUP] [DISTRIBUTE FROM src_group_name];
参数说明
l
groupname
节点组名称。
取值范围:字符串,要符合标识符的命名规范。且最大长度不超过63个字符。
说明
节点组命名支持ASCII字符集上所有字符,但是建议用户按照标识符命名规范命名。
l
nodename
节点名称。
取值范围:字符串,要符合标识符的命名规范。且最大长度不超过63个字符。
l
BUCKETS [ ( bucketnumber [, ... ] ) ]
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
828GaussDB 200
开发者指南
16 SQL 参考
BUCKETS子句是集群管理工具的内部用法,该子句不建议用户直接使用,以免对
集群的正常使用造成影响。
l
VCGROUP
创建一个逻辑集群类型的节点组。
l
DISTRIBUTE FROM src_group_name
创建一个逻辑集群节点组,用于从src_group_name指定的逻辑集群节点组重分布数
据。该子句不建议用户直接使用,以免导致数据分布错误和逻辑集群不可用。
相关链接
16.14.89 DROP NODE GROUP
16.14.58 CREATE ROW LEVLEL SECURITY POLICY
功能描述
对表创建行访问控制策略。
当对表创建了行访问控制策略,只有打开该表的行访问控制开关(ALTER TABLE ...
ENABLE ROW LEVEL SECURITY),策略才能生效。否则不生效。
当前行访问控制影响数据表的读取操作(SELECT、UPDATE、DELETE),暂不影响数
据表的写入操作(INSERT、MERGE INTO)。表所有者或系统管理员可以在USING子句
中创建表达式,在客户端执行数据表读取操作时,数据库后台在查询重写阶段会将满
足条件的表达式拼接并应用到执行计划中。针对数据表的每一条元组,当USING表达
式返回TRUE时,元组对当前用户可见,当USING表达式返回FALSE或NULL时,元组
对当前用户不可见。
行访问控制策略名称是针对表的,同一个数据表上不能有同名的行访问控制策略;对
不同的数据表,可以有同名的行访问控制策略。
行访问控制策略可以应用到指定的操作(SELECT、UPDATE、DELETE、ALL),ALL
表示会影响SELECT、UPDATE、DELETE三种操作;定义行访问控制策略时,若未指
定受影响的相关操作,默认为ALL。
行访问控制策略可以应用到指定的用户(角色),也可应用到全部用户(PUBLIC);定义
行访问控制策略时,若未指定受影响的用户,默认为PUBLIC。
注意事项
l 支持对行存表、行存分区表、列存表、列存分区表、复制表、unlogged表、hash表
定义行访问控制策略。
l 不支持HDFS表、外表、临时表定义行访问控制策略。
l 不支持对视图定义行访问控制策略。
l 同一张表上可以创建多个行访问控制策略,一张表最多创建100个行访问控制策
略。
l 系统管理员不受行访问控制影响,可以查看表的全量数据。
l 通过SQL语句、视图、函数、存储过程查询包含行访问控制策略的表,都会受影
响。
语法格式
CREATE [ ROW LEVEL SECURITY ] POLICY policy_name ON table_name
[ AS { PERMISSIVE | RESTRICTIVE } ]
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
829GaussDB 200
开发者指南
16 SQL 参考
[ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
[ TO { role_name | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]
USING ( using_expression )
参数说明
l
policy_name
行访问控制策略名称,同一个数据表上行访问控制策略名称不能相同。
l
table_name
行访问控制策略的表名。
l
command
当前行访问控制影响的SQL操作,可指定操作包括:ALL、SELECT、UPDATE、
DELETE。当未指定时,ALL为默认值,涵盖SELECT、UPDATE、DELETE操
作。
当command为SELECT时,SELECT类操作受行访问控制的影响,只能查看到满足
条件(using_expression返回值为TRUE)的元组数据,受影响的操作包括SELECT,
UPDATE ... RETURNING,DELETE ... RETURNING。
当command为UPDATE时,UPDATE类操作受行访问控制的影响,只能更新满足条
件(using_expression返回值为TRUE)的元组数据,受影响的操作包括UPDATE,
UPDATE ... RETURNING, SELECT ... FOR UPDATE/SHARE。
当command为DELETE时,DELETE类操作受行访问控制的影响,只能删除满足条
件(using_expression返回值为TRUE)的元组数据,受影响的操作包括DELETE,
DELETE ... RETURNING。
行访问控制策略与适配的SQL语法关系参加下表:
表 16-57 ROW LEVLEL SECURITY 策略与适配 SQL 语法关系
l
Command SELECT/ALL
policy UPDATE/ALL
policy DELETE/ALL
policy
SELECT Existing row No No
SELECT FOR
UPDATE/SHARE Existing row Existing row No
UPDATE No Existing row No
UPDATE
RETURNING Existing row Existing row No
DELETE No No Existing row
DELETE
RETURNING Existing row No Existing row
role_name
行访问控制影响的数据库用户。
当未指定时,PUBLIC为默认值,PUBLIC表示影响所有数据库用户,可以指定多
个受影响的数据库用户。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
830GaussDB 200
开发者指南
16 SQL 参考
系统管理员不受行访问控制特性影响。
l
using_expression
行访问控制的表达式(返回boolean值)。
条件表达式中不能包含AGG函数和窗口(WINDOW)函数。在查询重写阶段,如
果数据表的行访问控制开关打开,满足条件的表达式会添加到计划树中。针对数
据表的每条元组,会进行表达式计算,只有表达式返回值为TRUE时,行数据对用
户才可见(SELECT、UPDATE、DELETE);当表达式返回FALSE时,该元组对
当前用户不可见,用户无法通过SELECT语句查看此元组,无法通过UPDATE语句
更新此元组,无法通过DELETE语句删除此元组。
示例
--创建用户alice
CREATE ROLE alice PASSWORD 'Gauss@123';
--创建用户bob
CREATE ROLE bob PASSWORD 'Gauss@123';
--创建数据表all_data
CREATE TABLE all_data(id int, role varchar(100), data varchar(100));
--向数据表插入数据
INSERT INTO all_data VALUES(1, 'alice', 'alice data');
INSERT INTO all_data VALUES(2, 'bob', 'bob data');
INSERT INTO all_data VALUES(3, 'peter', 'peter data');
--将表all_data的读取权限赋予alice和bob用户
GRANT SELECT ON all_data TO alice, bob;
--打开行访问控制策略开关
ALTER TABLE all_data ENABLE ROW LEVEL SECURITY;
--创建行访问控制策略,当前用户只能查看用户自身的数据
CREATE ROW LEVEL SECURITY POLICY all_data_rls ON all_data USING(role = CURRENT_USER);
--查看表all_data相关信息
\d+ all_data
Table "public.all_data"
Column |
Type
| Modifiers | Storage | Stats target | Description
--------+------------------------+-----------+----------+--------------+-------------
id
| integer
|
| plain
|
|
role
| character varying(100) |
| extended |
|
data
| character varying(100) |
| extended |
|
Row Level Security Policies:
POLICY "all_data_rls"
USING (((role)::name = "current_user"()))
Has OIDs: no
Distribute By: HASH(id)
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no, enable_rowsecurity=true
--当前用户执行SELECT操作
SELECT * FROM all_data;
id | role |
data
----+-------+------------
1 | alice | alice data
2 | bob
| bob data
3 | peter | peter data
(3 rows)
EXPLAIN(COSTS OFF) SELECT * FROM all_data;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
831GaussDB 200
开发者指南
16 SQL 参考
QUERY PLAN
----------------------------
Streaming (type: GATHER)
Node/s: All datanodes
-> Seq Scan on all_data
(3 rows)
--切换至alice用户执行SELECT操作
SELECT * FROM all_data;
id | role |
data
----+-------+------------
1 | alice | alice data
(1 row)
EXPLAIN(COSTS OFF) SELECT * FROM all_data;
QUERY PLAN
----------------------------------------------------------------
Streaming (type: GATHER)
Node/s: All datanodes
-> Seq Scan on all_data
Filter: ((role)::name = 'alice'::name)
Notice: This query is influenced by row level security feature
(5 rows)
相关链接
16.14.91 DROP ROW LEVEL SECURITY POLICY
16.14.59 CREATE PROCEDURE
功能描述
创建一个新的存储过程。
注意事项
l 如果创建存储过程时参数或返回值带有精度,不进行精度检测。
l 创建存储过程时,存储过程定义中对表对象的操作建议都显示指定模式,否则可
能会导致存储过程执行异常。
l 在创建存储过程时,存储过程内部通过SET语句设置current_schema和search_path
无效。执行完函数search_path和current_schema与执行函数前的search_path和
current_schema保持一致。
l 如果存储过程参数中带有出参,SELECT调用存储过程必须缺省出参,CALL调用
存储过程适配Oracle,调用非重载函数时必须指定出参,对于重载的package函
数,out参数可以缺省,具体信息参见16.14.36 CALL的示例。
l 存储过程指定package属性时支持重载。
l 在创建procedure时,不能在avg函数外面嵌套其他agg函数,或者其他系统函数。
语法格式
CREATE [ OR REPLACE ] PROCEDURE procedure_name
[ ( {[ argmode ] [ argname ] argtype [ { DEFAULT | := | = } expression ]}[,...]) ]
[
{ IMMUTABLE | STABLE | VOLATILE }
| { SHIPPABLE | NOT SHIPPABLE }
| {PACKAGE}
| [ NOT ] LEAKPROOF
| { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
| {[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER | AUTHID DEFINER | AUTHID
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
832GaussDB 200
开发者指南
16 SQL 参考
CURRENT_USER}
| COST execution_cost
| ROWS result_rows
| SET configuration_parameter { [ TO | = ] value | FROM CURRENT }
][ ... ]
{ IS | AS }
plsql_body
/
参数说明
l
OR REPLACE
当存在同名的存储过程时,替换原来的定义。
l
procedure_name
创建的存储过程名字,可以带有模式名。
取值范围:字符串,要符合标识符的命名规范。
l
argmode
参数的模式。
VARIADIC用于声明数组类型的参数。
取值范围: IN,OUT,INOUT或VARIADIC。缺省值是IN。只有OUT模式的参数
后面能跟VARIADIC。并且OUT和INOUT模式的参数不能用在RETURNS TABLE
的过程定义中。
l
argname
参数的名字。
取值范围:字符串,要符合标识符的命名规范。
l
argtype
参数的数据类型。
取值范围:可用的数据类型。
l
IMMUTABLE、STABLE等
行为约束可选项。各参数的功能与CREATE FUNCTION类似,详细说明见
5.18.17.13-CREATE FUNCTION
l
plsql_body
PL/SQL存储过程体。
当在存储过程体中进行创建用户等涉及用户密码相关操作时,系统表及csv日志中
会记录密码的明文。因此不建议用户在存储过程体中进行涉及用户密码的相关操
作。
说明
argument_name和argmode的顺序没有严格要求,推荐按照argument_name、argmode、
argument_type的顺序使用。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
833GaussDB 200
开发者指南
16 SQL 参考
示例
--创建一个存储过程。
CREATE OR REPLACE PROCEDURE prc_add
(
param1
IN
INTEGER,
param2
IN OUT INTEGER
)
AS
BEGIN
param2:= param1 + param2;
dbms_output.put_line('result is: '||to_char(param2));
END;
/
--调用此存储过程。
SELECT prc_add(2,3);
--创建一个参数模式为VARIADIC的存储过程。
CREATE OR REPLACE PROCEDURE pro_variadic (var1 VARCHAR2(10) DEFAULT 'hello!',var4 VARIADIC int4[])
AS
BEGIN
dbms_output.put_line(var1);
END;
/
--执行此存储过程。
SELECT pro_variadic(var1=>'hello', VARIADIC var4=> array[1,2,3,4]);
--创建一个存储过程,将带着调用它的用户的权限执行。
CREATE PROCEDURE insert_data(v integer)
SECURITY
INVOKER
AS
BEGIN
INSERT INTO tb1 VALUES(v);
END;
/
--调用此存储过程。
CALL insert_data1(1);
--创建带有package属性的存储过程。
create or replace procedure package_func_overload(col int, col2 out varchar)
package
as
declare
col_type text;
begin
col2 := '122';
dbms_output.put_line('two varchar parameters ' || col2);
end;
/
--删除一个存储过程。
DROP PROCEDURE prc_add;
DROP PROCEDURE pro_variadic;
DROP PROCEDURE insert_data;
DROP PROCEDURE package_func_overload;
相关链接
16.14.92 DROP PROCEDURE
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
834GaussDB 200
开发者指南
16 SQL 参考
16.14.60 CREATE RESOURCE POOL
功能描述
创建一个资源池,并指定此资源池相关联的控制组。
注意事项
只要用户对当前数据库有CREATE权限,就可以创建资源池。
语法格式
CREATE RESOURCE POOL pool_name
[WITH ({MEM_PERCENT=pct | CONTROL_GROUP="group_name" | ACTIVE_STATEMENTS=stmt | MAX_DOP = dop
| MEMORY_LIMIT='memory_size' | io_limits=io_limits | io_priority='io_priority' |
nodegroup="nodegroupname" | is_foreign=boolean }[, ... ])];
参数说明
l
pool_name
资源池名称。
资源池名称不能和当前数据库里已有的资源池重名。
取值范围:字符串,要符合标识符的命名规范。
l
group_name
控制组名称。
说明
l 设置控制组名称时,语法可以使用双引号,也可以使用单引号。
l group_name对大小写敏感。
l 不指定group_name时,默认指定的字符串为 "Medium",代表指定DefaultClass控制组的
"Medium" Timeshare控制组。
l 若数据库管理员指定自定义Class组下的Workload控制组,如control_group的字符串为:
"class1:workload1";代表此资源池指定到class1控制组下的workload1控制组。也可同时
指定Workload控制组的层次,如control_group的字符串为:"class1:workload1:1"。
l 若数据库用户指定Timeshare控制组代表的字符串,即"Rush"、"High"、"Medium"或
"Low"其中一种,如control_group的字符串为"High";代表资源池指定到DefaultClass控
制组下的"High" Timeshare控制组。
l 多租户场景下,组资源池关联的控制组为Class级别,业务资源池关联Workload控制
组。且不允许在各种资源池间相互切换。
取值范围:字符串,要符合说明中的规则,其指定已创建的控制组。
l
stmt
资源池语句执行的最大并发数量。
取值范围:数值型,-1~INT_MAX。
l
dop
资源池最大并发度,语句执行时能够创建的最多线程数量。
取值范围:数值型,1~INT_MAX
l
memory_size
资源池最大使用内存。
取值范围:字符串,内容范围1KB~2047GB
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
835GaussDB 200
开发者指南
16 SQL 参考
l
mem_percent
资源池可用内存占全部内存或者组用户内存使用的比例。
在多租户场景下,组用户和业务用户的mem_percent范围1-100,默认为20。
在普通场景下,普通用户的mem_percent范围为0-100,默认值为0。
说明
mem_percent和memory_limit同时指定时,只有mem_percent起作用。
l
io_limits
资源池每秒可触发IO次数上限。
对于行存,以万次为单位计数,而列存则以正常次数计数。
l
io_priority
IO利用率高达90%时,重消耗IO作业进行IO资源管控时关联的优先级等级。
包括三档可选:Low、Medium和High。不控制时可设置为None。默认为None。
说明
io_limits和io_priority的设置都仅对复杂作业有效。包括批量导入(INSERT INTO SELECT,
COPY FROM, CREATE TABLE AS等),单DN数据量大约超过500MB的复杂查询和
VACUUM FULL等操作。
l
nodegroup
在逻辑集群模式下,指定逻辑集群名称。必须是存在的逻辑集群。
如果逻辑集群名称包含大写字符、特殊符号或以数字开头,SQL语句中对逻辑集
群名称需要加双引号。
l
is_foreign
在逻辑集群模式下,指定当前资源池用于控制没有关联本逻辑集群的普通用户的
资源。这里的逻辑集群是由资源池nodegroup字段指定的。
说明
l nodegroup必须是存在的逻辑集群,不能是elastic_group和安装的nodegroup
(group_version1)。
l 如果指定了is_foreign为true,则资源池不能再关联用户,即不允许通过CREATE
USER ... RESOURCE POOL语句来将该资源池配置给用户。该资源池自动检查用户是否
关联到资源池指定的逻辑集群,如果用户没有关联到该逻辑集群,则这些用户在逻辑集
群所包含的DN上运行将受到该资源池的资源控制。
示例
本示例假定用户已预先成功创建控制组。(创建控制组请参考13.2.3 设置控制组)
--创建一个默认资源池,其控制组为"DefaultClass"组下属的"Medium" Timeshare Workload控制组。
CREATE RESOURCE POOL pool1;
-- 创建一个资源池,其控制组指定为"DefaultClass"组下属的"High" Timeshare Workload控制组。
CREATE RESOURCE POOL pool2 WITH (CONTROL_GROUP="High");
-- 创建一个资源池,其控制组指定为"class1"组下属的"Low" Timeshare Workload控制组。
CREATE RESOURCE POOL pool3 WITH (CONTROL_GROUP="class1:Low");
-- 创建一个资源池,其控制组指定为"class1"组下属的"wg1" Workload控制组。
CREATE RESOURCE POOL pool4 WITH (CONTROL_GROUP="class1:wg1");
-- 创建一个资源池,其控制组指定为"class1"组下属的"wg2" Workload控制组。
CREATE RESOURCE POOL pool5 WITH (CONTROL_GROUP="class1:wg2:3");
--删除资源池。
DROP RESOURCE POOL pool1;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
836GaussDB 200
开发者指南
16 SQL 参考
DROP
DROP
DROP
DROP
RESOURCE
RESOURCE
RESOURCE
RESOURCE
POOL
POOL
POOL
POOL
pool2;
pool3;
pool4;
pool5;
相关链接
16.14.16 ALTER RESOURCE POOL,16.14.93 DROP RESOURCE POOL
16.14.61 CREATE ROLE
功能描述
创建角色。
角色是拥有数据库对象和权限的实体。在不同的环境中角色可以认为是一个用户,一
个组或者兼顾两者。
注意事项
l 在数据库中添加一个新角色,角色无登录权限。
l 创建角色的用户必须具备CREATE ROLE的权限或者是系统管理员。
语法格式
CREATE ROLE role_name [ [ WITH ] option [ ... ] ] [ ENCRYPTED | UNENCRYPTED ] { PASSWORD |
IDENTIFIED BY } { 'password' | DISABLE };
其中角色信息设置子句option语法为:
{SYSADMIN | NOSYSADMIN}
| {AUDITADMIN | NOAUDITADMIN}
| {CREATEDB | NOCREATEDB}
| {USEFT | NOUSEFT}
| {CREATEROLE | NOCREATEROLE}
| {INHERIT | NOINHERIT}
| {LOGIN | NOLOGIN}
| {REPLICATION | NOREPLICATION}
| {INDEPENDENT | NOINDEPENDENT}
| {VCADMIN | NOVCADMIN}
| CONNECTION LIMIT connlimit
| VALID BEGIN 'timestamp'
| VALID UNTIL 'timestamp'
| RESOURCE POOL 'respool'
| USER GROUP 'groupuser'
| PERM SPACE 'spacelimit'
| NODE GROUP logic_cluster_name
| IN ROLE role_name [, ...]
| IN GROUP role_name [, ...]
| ROLE role_name [, ...]
| ADMIN rol e_name [, ...]
| USER role_name [, ...]
| SYSID uid
| DEFAULT TABLESPACE tablespace_name
| PROFILE DEFAULT
| PROFILE profile_name
| PGUSER
参数说明
l
role_name
角色名称。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
837GaussDB 200
开发者指南
16 SQL 参考
取值范围:字符串,要符合标识符的命名规范。且最多为63个字符。
l
password
登录密码。
密码规则如下:
– 密码默认不少于8个字符。
– 不能与用户名及用户名倒序相同。
– 至少包含大写字母(A-Z),小写字母(a-z),数字(0-9),非字母数字字
符(限定为~!@#$%^&*()-_=+\|[{}];:,<.>/?)四类字符中的三类字符。
取值范围:字符串。
l
DISABLE
默认情况下,用户可以更改自己的密码,除非密码被禁用。要禁用用户的密码,
请指定DISABLE。禁用某个用户的密码后,将从系统中删除该密码,此类用户只
能通过外部认证来连接数据库,例如:IAM认证或kerberos认证。只有管理员才能
启用或禁用密码。普通用户不能禁用初始用户的密码。要启用密码,请运行
ALTER USER并指定密码。
l
ENCRYPTED | UNENCRYPTED
控制密码存储在系统表里的口令是否加密。(如果没有指定,那么缺省的行为由
配置参数password_encryption控制。)按照产品安全要求,密码必须加密存储,所
以,UNENCRYPTED在GaussDB 200中禁止使用。因为系统无法对指定的加密口
令字符串进行解密,所以如果目前的口令字符串已经是用SHA256加密的格式,则
会继续照此存放,而不管是否声明了ENCRYPTED或UNENCRYPTED。这样就允
许在dump/restore的时候重新加载加密的口令。
l
SYSADMIN | NOSYSADMIN
决定一个新角色是否为“系统管理员”,具有SYSADMIN属性的角色拥有系统最
高权限。
缺省为NOSYSADMIN。
l
AUDITADMIN | NOAUDITADMIN
定义角色是否有审计管理属性。
缺省为NOAUDITADMIN。
l
CREATEDB | NOCREATEDB
决定一个新角色是否能创建数据库。
新角色没有创建数据库的权限。
缺省为NOCREATEDB。
l
USEFT | NOUSEFT
该参数为保留参数,暂未启用。
l
CREATEROLE | NOCREATEROLE
决定一个角色是否可以创建新角色(也就是执行CREATE ROLE和CREATE
USER)。 一个拥有CREATEROLE权限的角色也可以修改和删除其他角色。
缺省为NOCREATEROLE。
l
INHERIT | NOINHERIT
这些子句决定一个角色是否“继承”它所在组的角色的权限。不推荐使用。
l
LOGIN | NOLOGIN
具有LOGIN属性的角色才可以登录数据库。一个拥有LOGIN属性的角色可以认为
是一个用户。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
838GaussDB 200
开发者指南
16 SQL 参考
缺省为NOLOGIN。
l
REPLICATION | NOREPLICATION
定义角色是否允许流复制或设置系统为备份模式。REPLICATION属性是特定的角
色,仅用于复制。
缺省为NOREPLICATION。
l
INDEPENDENT | NOINDEPENDENT
定义私有、独立的角色。具有INDEPENDENT属性的角色,管理员对其进行的控
制、访问的权限被分离,具体规则如下:
l
– 未经INDEPENDENT角色授权,管理员无权对其表对象进行增、删、查、
改、拷贝、授权操作。
– 未经INDEPENDENT角色授权,管理员无权修改INDEPENDENT角色的继承
关系。
– 管理员无权修改INDEPENDENT角色的表对象的属主。
– 管理员无权去除INDEPENDENT角色的INDEPENDENT属性。
– 管理员无权修改INDEPENDENT角色的数据库口令,INDEPENDENT角色需
管理好自身口令,口令丢失无法重置。
– 管理员属性用户不允许定义修改为INDEPENDENT属性。
VCADMIN | NOVCADMIN
定义逻辑集群管理员角色。具有逻辑集群管理员属性的角色,和普通用户相比,
有如下额外权限:
l
– 在所关联逻辑集群中创建、修改和删除资源池的权限。
– 将所关联的逻辑集群的访问权限授予其他用户或角色,或回收其他用户或角
色对关联逻辑集群的访问权限。
CONNECTION LIMIT
声明该角色可以使用的并发连接数量。
取值范围:整数,>=-1,缺省值为-1,表示没有限制。
l
VALID BEGIN
设置角色生效的时间戳。如果省略了该子句,角色无有效开始时间限制。
l
VALID UNTIL
设置角色失效的时间戳。如果省略了该子句,角色无有效结束时间限制。
l
RESOURCE POOL
设置角色使用的resource pool名字,该名字属于系统表:pg_resource_pool
l
USER GROUP 'groupuser'
创建一个user的子用户。使用规则可以参考13.3.1 用户层级管理。
l
PERM SPACE
设置用户使用空间的大小。
l
NODE GROUP
设置用户关联的逻辑集群名称。如果需要关联的逻辑集群名称包含大写字符或特
殊字符,指定逻辑集群名称时需要加双引号。
l
IN ROLE
新角色立即拥有IN ROLE子句中列出的一个或多个现有角色拥有的权限。不推荐
使用。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
839GaussDB 200
开发者指南
16 SQL 参考
l
IN GROUP
IN GROUP是IN ROLE过时的拼法。不推荐使用。
l
ROLE
ROLE子句列出一个或多个现有的角色,它们将自动添加为这个新角色的成员,拥
有新角色所有的权限。
l
ADMIN
ADMIN子句类似ROLE子句,不同的是ADMIN后的角色可以把新角色的权限赋给
其他角色。
l
USER
USER子句是ROLE子句过时的拼法。
l
SYSID
SYSID子句将被忽略,无实际意义。
l
DEFAULT TABLESPACE
DEFAULT TABLESPACE子句将被忽略,无实际意义。
l
PROFILE
PROFILE子句将被忽略,无实际意义。
l
PGUSER
该属性用于兼容开源Postgres的连接通讯,开源的Postgres客户端接口(推荐使用
Postgres 9.2.19版本的相关客户端接口)可以使用具有该属性的数据库用户连接数
据库。
该属性只用于兼容连接过程,而由于本产品与Postgres的内核差异导致的不兼容,
不在此属性控制范围内。
由于具有PGUSER属性的用户的认证方式与其他用户不同,开源客户端的报错信
息可能导致数据库用户PGUSER属性被枚举,建议使用本产品自有的客户端。例
如:
#normaluser是不具有PGUSER属性的用户,psql是Postgres的客户端工具
pg@MPPDB04: ~ > psql -d postgres -p 25308 -h 10.11.12.13 -U normaluser
psql: authentication method 10 not supported
#pguser用户是具有PGUSER属性的用户
pg@MPPDB04: ~ > psql -d postgres -p 25308 -h 10.11.12.13 -U pguser
Password for user pguser:
示例
--创建一个角色,名为manager,密码为Bigdata123@。
CREATE ROLE manager IDENTIFIED BY 'Bigdata123@';
--创建一个角色,从2015年1月1日开始生效,到2026年1月1日失效。
CREATE ROLE miriam WITH LOGIN PASSWORD 'Bigdata123@' VALID BEGIN '2015-01-01' VALID UNTIL
'2026-01-01';
--修改角色manager的密码为abcd@123。
ALTER ROLE manager IDENTIFIED BY 'abcd@123' REPLACE 'Bigdata123@';
--修改角色manager为系统管理员。
ALTER ROLE manager SYSADMIN;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
840GaussDB 200
开发者指南
16 SQL 参考
--删除角色manager。
DROP ROLE manager;
--删除角色miriam。
DROP ROLE miriam;
相关链接
16.14.132 SET ROLE,16.14.17 ALTER ROLE,16.14.94 DROP ROLE,16.14.112
GRANT,16.14.123 REVOKE
16.14.62 CREATE SCHEMA
功能描述
创建模式。
访问命名对象时可以使用模式名作为前缀进行访问,如果无模式名前缀,则访问当前
模式下的命名对象。创建命名对象时也可用模式名作为前缀修饰。
另外,CREATE SCHEMA可以包括在新模式中创建对象的子命令,这些子命令和那些
在创建完模式后发出的命令没有任何区别。如果使用了AUTHORIZATION子句,则所
有创建的对象都将被该用户所拥有。
注意事项
l 只要用户对当前数据库有CREATE权限,就可以创建模式。
l 系统管理员在普通用户同名schema下创建的对象,所有者为schema的同名用户
(非系统管理员)。
l 根据指定的名字创建模式。
语法格式
CREATE SCHEMA schema_name
[ AUTHORIZATION user_name ] [ schema_element [ ... ] ];
l
根据用户名创建模式。
CREATE SCHEMA AUTHORIZATION user_name [ schema_element [ ... ] ];
参数说明
l
schema_name
模式名字。
模式名不能和当前数据库里其他的模式重名。
模式的名字不可以“pg_”开头。
取值范围:字符串,要符合标识符的命名规范。
l
AUTHORIZATION user_name
指定模式的所有者。当不指定schema_name时,把user_name当作模式名,此时
user_name只能是角色名。
取值范围:已存在的用户名/角色名。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
841GaussDB 200
开发者指南
16 SQL 参考
l
schema_element
在模式里创建对象的SQL语句。目前仅支持CREATE TABLE、CREATE VIEW、
CREATE INDEX、CREATE PARTITION、GRANT子句。
子命令所创建的对象都被AUTHORIZATION子句指定的用户所拥有。
说明
如果当前搜索路径上的模式中存在同名对象时,需要明确指定引用对象所在的模式。可以通过命
令SHOW SEARCH_PATH来查看当前搜索路径上的模式。
示例
--创建一个角色role1。
CREATE ROLE role1 IDENTIFIED BY 'Bigdata123@';
-- 为用户role1创建一个同名schema,子命令创建的表films和winners的拥有者为role1。
CREATE SCHEMA AUTHORIZATION role1
CREATE TABLE films (title text, release date, awards text[])
CREATE VIEW winners AS
SELECT title, release FROM films WHERE awards IS NOT NULL;
--删除schema。
DROP SCHEMA role1 CASCADE;
--删除用户。
DROP USER role1 CASCADE;
相关链接
16.14.19 ALTER SCHEMA,16.14.95 DROP SCHEMA
16.14.63 CREATE SEQUENCE
功能描述
CREATE SEQUENCE用于向当前数据库里增加一个新的序列。序列的Owner为创建此
序列的用户。
注意事项
l Sequence是一个存放等差数列的特殊表,该表受DBMS控制。这个表没有实际意
义,通常用于为行或者表生成唯一的标识符。
l 如果给出一个模式名,则该序列就在给定的模式中创建,否则会在当前模式中创
建。序列名必须和同一个模式中的其他序列、表、索引、视图或外表的名字不
同。
l 创建序列后,在表中使用序列的nextval()函数和generate_series(1,N)函数对表插入
数据,请保证nextval的可调用次数大于等于N+1次,否则会因为generate_series()函
数会调用N+1次而导致报错。
语法格式
CREATE SEQUENCE name [ INCREMENT [ BY ] increment ]
[ MINVALUE minvalue | NO MINVALUE | NOMINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE |
NOMAXVALUE]
[ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE | NOCYCLE ]
[ OWNED BY { table_name.column_name | NONE } ];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
842GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
name
将要创建的序列名称。
取值范围: 仅可以使用小写字母(a~z)、 大写字母(A~Z),数字和特殊字符
"#","_","$"的组合。
l
increment
指定序列的步长。一个正数将生成一个递增的序列,一个负数将生成一个递减的
序列。
缺省值为1。
l
MINVALUE minvalue | NO MINVALUE| NOMINVALUE
执行序列的最小值。如果没有声明minvalue或者声明了NO MINVALUE,则递增序
列的缺省值为1,递减序列的缺省值为-2 63 -1。NOMINVALUE等价于NO
MINVALUE
l
MAXVALUE maxvalue | NO MAXVALUE| NOMAXVALUE
执行序列的最大值。如果没有声明maxvalue或者声明了NO MAXVALUE,则递增
序列的缺省值为2 63 -1,递减序列的缺省值为-1。NOMAXVALUE等价于NO
MAXVALUE
l
start
指定序列的起始值。缺省值:对于递增序列为minvalue,递减序列为maxvalue。
l
cache
为了快速访问,而在内存中预先存储序列号的个数。
缺省值为1,表示一次只能生成一个值,也就是没有缓存。
说明
不建议同时定义cache和maxvalue或minvalue。因为定义cache后不能保证序列的连续性,可
能会产生空洞,造成序列号段浪费。
l
CYCLE
用于使序列达到maxvalue或者minvalue后可循环并继续下去。
如果声明了NO CYCLE,则在序列达到其最大值后任何对nextval的调用都会返回
一个错误。
NOCYCLE的作用等价于NO CYCLE。
缺省值为NO CYCLE。
若定义序列为CYCLE,则不能保证序列的唯一性。
l
OWNED BY-
将序列和一个表的指定字段进行关联。这样,在删除那个字段或其所在表的时候
会自动删除已关联的序列。关联的表和序列的所有者必须是同一个用户,并且在
同一个模式中。需要注意的是,通过指定OWNED BY,仅仅是建立了表的对应列
和sequence之间关联关系,并不会在插入数据时在该列上产生自增序列。
缺省值为OWNED BY NONE,表示不存在这样的关联。
通过OWNED BY创建的Sequence不建议用于其他表,如果希望多个表共享
Sequence,该Sequence不应该从属于特定表。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
843GaussDB 200
开发者指南
16 SQL 参考
示例
创建一个名为serial的递增序列,从101开始:
CREATE SEQUENCE serial
START 101
CACHE 20;
从序列中选出下一个数字:
SELECT nextval('serial');
nextval
---------
101
从序列中选出下一个数字:
SELECT nextval('serial');
nextval
---------
102
创建与表关联的序列:
CREATE TABLE customer_address
(
ca_address_sk
ca_address_id
ca_street_number
ca_street_name
ca_street_type
ca_suite_number
ca_city
ca_county
ca_state
ca_zip
ca_country
ca_gmt_offset
ca_location_type
) ;
integer
char(16)
char(10)
varchar(60)
char(15)
char(10)
varchar(60)
varchar(30)
char(2)
char(10)
varchar(20)
decimal(5,2)
char(20)
not null,
not null,
,
,
,
,
,
,
,
,
,
,
CREATE SEQUENCE serial1
START 101
CACHE 20
OWNED BY customer_address.ca_address_sk;
--删除序列
DROP TABLE customer_address;
DROP SEQUENCE serial cascade;
DROP SEQUENCE serial1 cascade;
相关链接
16.14.96 DROP SEQUENCE 16.14.20 ALTER SEQUENCE
16.14.64 CREATE SERVER
功能描述
创建一个外部服务器。
外部服务器是存储HDFS集群信息、OBS服务器信息或其他同构集群信息的载体。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
844GaussDB 200
开发者指南
16 SQL 参考
注意事项
默认只有系统管理员才可以创建外部服务器,否则需要对所使用的FOREIGN DATA
WRAPPER授权才可以创建,授权语法为:
GRANT USAGE ON FOREIGN DATA WRAPPER fdw_name TO username
其中fdw_name为FOREIGN DATA WRAPPER的名字,username为创建SERVER的用户
名。
语法格式
CREATE SERVER server_name
FOREIGN DATA WRAPPER fdw_name
OPTIONS ( { option_name ' value ' } [, ...] ) ;
参数说明
l
server_name
server的名字。
取值范围:长度必须小于等于63。
l
FOREIGN DATA WRAPPER fdw_name
指定外部数据封装器的名字。
取值范围:fdw_name是数据库初始化时系统创建的数据封装器,目前对于HDFS
集群,fdw_name的名字可以是hdfs_fdw或者dfs_fdw,对于其他同构集群,
fdw_name为gc_fdw。
l
OPTIONS ( { option_name ' value ' } [, ...] )
用于指定外部服务器的各类参数,详细的参数说明如下所示。
–
address
HDFS集群的元数据节点(NameNode)所在的IP地址以及端口,或者同构其
他集群的CN的IP地址以及端口。
为保证HA(High Availability),HDFS NameNode经常采用主备模式。主备
NameNode的地址都需要加入到address值中。GaussDB 200访问HDFS服务时,
会动态查找当前处于active状态的主NameNode。
说明
l address option必须存在。
l address option目前只支持点分十进制格式的ipv4格式,且address字符串中不能出现
空格,多组address以逗号作为分隔符。ip和port之间使用’:’来区分,HDFS集群
中,ip、port组推荐设置两组,分别对应HDFS NameNode主备节点的address。
–
hdfscfgpath
用户通过配置hdfscfgpath参数来指定HDFS配置文件路径。GaussDB 200会根
据配置文件路径下的HDFS配置文件指定的连接配置方式,以及安全模式,来
访问HDFS集群。
非安全模式连接HDFS集群时,不支持数据传输加密。在指定address的前提
下,不需要指定HDFS配置文件。如果没有指定address,依然需要通过
hdfscfgpath指定配置文件。
–
type
表示dfs_fdw连接的是HDFS。
取值范围:
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
845GaussDB 200
开发者指南
16 SQL 参考
n
–
HDFS表示连接的是HDFS。
dbname
用于协同分析,表示将要连接的远端集群的数据库名字。
–
username
用于协同分析,表示将要连接的远端集群的用户名。
–
password
用于协同分析,表示将要连接的远端集群的用户名密码。
示例
建立一个hdfs_server,其中hdfs_fdw为数据库中存在的foreign data wrapper。
--创建hdfs_server。
CREATE SERVER hdfs_server FOREIGN DATA WRAPPER HDFS_FDW OPTIONS
(address '10.146.187.231:8000,10.180.157.130:8000' ,
hdfscfgpath '/opt/hadoop_client/HDFS/hadoop/etc/hadoop',
type 'HDFS'
) ;
--删除hdfs_server。
DROP SERVER hdfs_server;
建立另外一个同构集群的server,其中gc_fdw为数据库中存在的foreign data wrapper。
--创建server。
CREATE SERVER server_remote FOREIGN DATA WRAPPER GC_FDW OPTIONS
(address '10.146.187.231:8000,10.180.157.130:8000' ,
dbname 'test',
username 'test',
password 'xxxxxxxx'
);
--删除server。
DROP SERVER server_remote;
相关链接
16.14.21 ALTER SERVER 16.14.97 DROP SERVER
16.14.65 CREATE TABLE
功能描述
在当前数据库中创建一个新的空白表,该表由命令执行者所有。
注意事项
l 列存表支持的数据类型请参考16.3.16 列存表支持的数据类型。
l 创建列存和HDFS分区表的数量建议不超过1000个。
l 表中的主键约束和唯一约束必须包含分布列。
l 如果在建表过程中数据库系统发生故障,系统恢复后可能无法自动清除之前已创
建的、大小为0的磁盘文件。此种情况出现概率小,不影响数据库系统的正常运
行。
l 列存表的表级约束只支持PARTIAL CLUSTER KEY,不支持主外键等表级约束。
l 列存表的字段约束只支持NULL、NOT NULL和DEFAULT常量值。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
846GaussDB 200
开发者指南
16 SQL 参考
l 列存表支持delta表,受参数enable_delta_store 控制是否开启,受参数
deltarow_threshold控制进入delta表的阀值。
l 创建表。
语法格式
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ]
table_name
({ column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint
[ ... ] ]
| table_constraint
| LIKE source_table [ like_option [...] ] }
[, ... ])
[ WITH ( {storage_parameter = value} [, ... ] ) ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ COMPRESS | NOCOMPRESS ]
[ TABLESPACE tablespace_name ]
[ DISTRIBUTE BY { REPLICATION | { HASH ( column_name [,...] ) } } ]
[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ];
–
其中列约束column_constraint为:
[ CONSTRAINT constraint_name ]
{ NOT NULL |
NULL |
CHECK ( expression ) |
DEFAULT default_expr |
UNIQUE index_parameters |
PRIMARY KEY index_parameters }
[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
–
其中列的压缩可选项compress_mode为:
{ DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS }
–
其中表约束table_constraint为:
[ CONSTRAINT constraint_name ]
{ CHECK ( expression ) |
UNIQUE ( column_name [, ... ] ) index_parameters |
PRIMARY KEY ( column_name [, ... ] ) index_parameters |
PARTIAL CLUSTER KEY ( column_name [, ... ] ) }
[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
–
其中like选项like_option为:
{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS |
PARTITION | RELOPTIONS | DISTRIBUTION | ALL }
其中索引参数index_parameters为:
[ WITH ( {storage_parameter = value} [, ... ] ) ]
[ USING INDEX TABLESPACE tablespace_name ]
参数说明
l
UNLOGGED
如果指定此关键字,则创建的表为非日志表。在非日志表中写入的数据不会被写
入到预写日志中,这样就会比普通表快很多。但是非日志表在冲突、执行操作系
统重启、强制重启、切断电源操作或异常关机后会被自动截断,会造成数据丢失
的风险。非日志表中的内容也不会被复制到备服务器中。在非日志表中创建的索
引也不会被自动记录。
使用场景:非日志表不能保证数据的安全性,用户应该在确保数据已经做好备份
的前提下使用,例如系统升级时进行数据的备份。
故障处理:当异常关机等操作导致非日志表上的索引发生数据丢失时,用户应该
对发生错误的索引进行重建。
l
GLOBAL | LOCAL
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
847GaussDB 200
开发者指南
16 SQL 参考
创建临时表时可以在TEMP或TEMPORARY前指定GLOBAL或LOCAL关键字。目
前这两个关键字的设立,仅是为了兼容SQL标准,实际上无论指定GLOBAL还是
LOCAL,GaussDB 200都会创建本地临时表。
l
TEMPORARY | TEMP
如果指定TEMP或TEMPORARY关键字,则创建的表为临时表。临时表只在当前
会话可见,本会话结束后会自动删除。因此,在除当前会话连接的CN以外的其他
CN故障时,仍然可以在当前会话上创建和使用临时表。由于临时表只在当前会话
创建,对于涉及对临时表操作的DDL语句,会产生DDL失败的报错。因此,建议
DDL语句中不要对临时表进行操作。TEMP和TEMPORARY等价。
l 临时表通过每个会话独立的以pg_temp开头的schema来保证只对当前会话可
见,因此,不建议用户在日常操作中手动删除以pg_temp,pg_toast_temp开头的
schema。
l 如果建表时不指定TEMPORARY/TEMP关键字,而指定表的schema为当前会话
的pg_temp_开头的schema,则此表会被创建为临时表。
l
IF NOT EXISTS
如果已经存在相同名称的表,不会报出错误,而会发出通知,告知通知此表已存
在。
l
table_name
要创建的表名。
l
column_name
新表中要创建的字段名。
l
data_type
字段的数据类型。
l
compress_mode
表字段的压缩选项,当前仅对行存表有效。该选项指定表字段优先使用的压缩算
法。
取值范围:DELTA、PREFIX、DICTIONARY、NUMSTR、NOCOMPRESS
l
COLLATE collation
COLLATE子句指定列的排序规则(该列必须是可排列的数据类型)。如果没有指
定,则使用默认的排序规则。
l
LIKE source_table [ like_option ... ]
LIKE子句声明一个表,新表自动从这个表中继承所有字段名及其数据类型和非空
约束。
新表与源表之间在创建动作完毕之后是完全无关的。在源表做的任何修改都不会
传播到新表中,并且也不可能在扫描源表的时候包含新表的数据。
被复制的列和约束并不使用相同的名字进行融合。如果明确的指定了相同的名字
或者在另外一个LIKE子句中,将会报错。
–
文档版本 01 (2019-08-01)
源表上的字段缺省表达式只有在指定INCLUDING DEFAULTS时,才会复制
到新表中。缺省是不包含缺省表达式的,即新表中的所有字段的缺省值都是
NULL。
版权所有 © 华为技术有限公司
848GaussDB 200
开发者指南
16 SQL 参考
– 源表上的CHECK约束仅在指定INCLUDING CONSTRAINTS时,会复制到新
表中,而其他类型的约束永远不会复制到新表中。非空约束总是复制到新表
中。此规则同时适用于表约束和列约束。
– 如果指定了INCLUDING INDEXES,则源表上的索引也将在新表上创建,默
认不建立索引。
– 如果指定了INCLUDING STORAGE,则复制列的STORAGE设置会复制到新
表中,默认情况下不包含STORAGE设置。
– 如果指定了INCLUDING COMMENTS,则源表列、约束和索引的注释会复制
到新表中。默认情况下,不复制源表的注释。
– 如果指定了INCLUDING PARTITION,则源表的分区定义会复制到新表中,
同时新表将不能再使用PARTITION BY子句。默认情况下,不拷贝源表的分
区定义。
– 如果指定了INCLUDING RELOPTIONS,则源表的存储参数(即源表的WITH
子句)会复制到新表中。默认情况下,不复制源表的存储参数。
– 如果指定了INCLUDING DISTRIBUTION,则源表的分布信息会复制到新表
中,包括分布类型和分布列,同时新表将不能再使用DISTRIBUTE BY子句。
默认情况下,不拷贝源表的分布信息。
– INCLUDING ALL包含了INCLUDING DEFAULTS、INCLUDING
CONSTRAINTS、INCLUDING INDEXES、INCLUDING STORAGE、
INCLUDING COMMENTS、INCLUDING PARTITION、INCLUDING
RELOPTIONS和INCLUDING DISTRIBUTION的内容。
l 如果源表包含serial、bigserial、smallseriral类型,或者源表字段的默认值是
sequence,且sequence属于源表(通过CREATE SEQUENCE ... OWNED BY创
建),这些Sequence不会关联到新表中,新表中会重新创建属于自己的
sequence。这和之前版本的处理逻辑不同。如果用户希望源表和新表共享
Sequence,需要首先创建一个共享的Sequence(避免使用OWNED BY),并配
置为源表字段默认值,这样创建的新表会和源表共享该Sequence。
l 不建议将其他表私有的Sequence配置为源表字段的默认值,尤其是其他表只分
布在特定的NodeGroup上,这可能导致CREATE TABLE ... LIKE执行失败。另
外,如果源表配置其他表私有的Sequence,当该表删除时Sequence也会连带删
除,这样源表的Sequence将不可用。如果用户希望多个表共享Sequence,建议
创建共享的Sequence。
l
WITH ( { storage_parameter = value } [, ... ] )
这个子句为表或索引指定一个可选的存储参数。
说明
使用任意精度类型Numeric定义列时,建议指定精度p以及刻度s。在不指定精度和刻度时,
会按输入的显示出来。
参数的详细描述如下所示。
–
FILLFACTOR
一个表的填充因子(fillfactor)是一个介于10和100之间的百分数。100(完全
填充)是默认值。如果指定了较小的填充因子,INSERT操作仅按照填充因子
指定的百分率填充表页。每个页上的剩余空间将用于在该页上更新行,这就
使得UPDATE有机会在同一页上放置同一条记录的新版本,这比把新版本放
置在其他页上更有效。对于一个从不更新的表将填充因子设为100是最佳选
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
849GaussDB 200
开发者指南
16 SQL 参考
择,但是对于频繁更新的表,选择较小的填充因子则更加合适。该参数对于
列存表没有意义。
取值范围:10~100
–
ORIENTATION
指定表数据的存储方式,即行存方式、列存方式、ORC格式的方式,该参数
设置成功后就不再支持修改。
取值范围:
n
ROW,表示表的数据将以行式存储。
行存储适合于OLTP业务,此类型的表上交互事务比较多,一次交互会涉
及表中的多个列,用行存查询效率较高。
n
COLUMN,表示表的数据将以列式存储。
列存储适合于数据仓库业务,此类型的表上会做大量的汇聚计算,且涉
及的列操作较少。
n
ORC,表示表的数据以ORC格式存储。
ORC格式存储适合于数据存储在HDFS上,此类型的表数据量较大,主要
用于数据查询。
默认值:
若指定表空间为HDFS表空间,默认值为ORC。
若指定表空间为普通表空间,默认值为ROW。
–
COMPRESSION
指定表数据的压缩级别,它决定了表数据的压缩比以及压缩时间。一般来
讲,压缩级别越高,压缩比也越大,压缩时间也越长;反之亦然。实际压缩
比取决于加载的表数据的分布特征。
取值范围:
–
n 列存表的有效值为YES/NO/LOW/MIDDLE/HIGH,默认值为LOW。
n 行存表的有效值为YES/NO,默认值为NO。
COMPRESSLEVEL
指定表数据同一压缩级别下的不同压缩水平,它决定了同一压缩级别下表数
据的压缩比以及压缩时间。对同一压缩级别进行了更加详细的划分,为用户
选择压缩比和压缩时间提供了更多的空间。总体来讲,此值越大,表示同一
压缩级别下压缩比越大,压缩时间越长;反之亦然。
取值范围:0~3,默认值为0。
–
MAX_BATCHROW
指定了在数据加载过程中一个存储单元可以容纳记录的最大数目。该参数只
对列存表有效。
取值范围:10000~60000
–
PARTIAL_CLUSTER_ROWS
指定了在数据加载过程中进行将局部聚簇存储的记录数目。该参数只对列存
表有效。
取值范围:600000~2147483647
–
DELTAROW_THRESHOLD
指定列存表导入时小于多少行的数据进入delta表,只在GUC参数
enable_delta_store开启时生效。该参数只对列存表有效。
取值范围:0~9999,默认值为100
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
850GaussDB 200
开发者指南
16 SQL 参考
–
VERSION
指定ORC存储格式的版本。
取值范围:0.12,目前支持ORC 0.12格式,后续会随着ORC格式的发展,支
持更多格式。
默认值:0.12
l
ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP }
ON COMMIT选项决定在事务中执行创建临时表操作,当事务提交时,此临时表
的后续操作。有以下三个选项,当前支持PRESERVE ROWS和DELETE ROWS选
项。
l
– PRESERVE ROWS(缺省值):提交时不对临时表做任何操作,临时表及其
表数据保持不变。
– DELETE ROWS:提交时删除临时表中数据。
– DROP:提交时删除此临时表。
COMPRESS | NOCOMPRESS
创建新表时,需要在CREATE TABLE语句中指定关键字COMPRESS,这样,当对
该表进行批量插入时就会触发压缩特性。该特性会在页范围内扫描所有元组数
据,生成字典、压缩元组数据并进行存储。指定关键字NOCOMPRESS则不对表进
行压缩。
缺省值:NOCOMPRESS,即不对元组数据进行压缩。
l
TABLESPACE tablespace_name
创建新表时指定此关键字,表示新表将要在指定表空间内创建。如果没有声明,
将使用默认表空间。
l
DISTRIBUTE BY
指定表如何在节点之间分布或者复制。
取值范围:
– REPLICATION:表的每一行存在所有数据节点(DN)中,即每个数据节点
都有完整的表数据。
– HASH (column_name ) :对指定的列进行Hash,通过映射,把数据分布到指
定DN。
说明
l 当指定DISTRIBUTE BY HASH (column_name)参数时,创建主键和唯一索引必须
包含“ column_name”列。
l 当被参照表指定DISTRIBUTE BY HASH (column_name)参数时,参照表的外键必
须包含“ column_name”列。
默认值:HASH(column_name),column_name取表的主键列(如果有的话)或首个
数据类型支持作为分布列的列。
column_name的数据类型必须是以下类型之一:
– INTEGER TYPES:TINYINT,SMALLINT,INT,BIGINT,NUMERIC/
DECIMAL
– CHARACTER TYPES:CHAR,BPCHAR,VARCHAR,VARCHAR2,
NVARCHAR2,TEXT
– DATE/TIME TYPES:DATE,TIME,TIMETZ,TIMESTAMP,
TIMESTAMPTZ,INTERVAL,SMALLDATETIME
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
851GaussDB 200
开发者指南
16 SQL 参考
说明
在建表时,选择分布列和分区键可对SQL查询性能产生重大影响。因此,需要根据一定策
略选择合适的分布列和分区键。
l 选择合适的分布列
对于采用散列(Hash)方式的数据分布表,一个合适的分布列应将一个表内的数据,均
匀分散存储在多个DN内,避免出现数据倾斜现象(即多个DN内数据分布不均)。请按
照如下原则判定合适的分布列:
1. 判断是否已发生数据倾斜现象。
连接数据库,执行如下语句,查看各DN内元组数目。命令中的斜体部分
tablename,请填入待分析的表名。
SELECT a.count,b.node_name FROM (SELECT count(*) AS count,xc_node_id FROM
tablename GROUP BY xc_node_id) a, pgxc_node b WHERE a.xc_node_id=b.node_id ORDER
BY a.count DESC;
如果各DN内元组数目相差较大(如相差数倍、数十倍),则表明已发生数据倾斜现
象,请按照下面原则调整分布列。
2. 重新选择分布列,重新建表。当前不支持通过ALTER TABLE语句调整分布列,因
此调整分布列时需要重新建表。
选择原则如下:
分布列的列值应比较离散,以便数据能够均匀分布到各个DN。例如,考虑选择表的
主键为分布列,如在人员信息表中选择身份证号码为分布列。
在满足上面原则的情况下,考虑选择查询中的连接条件为分布列,以便Join任务能
够下推到DN中执行,且减少DN之间的通信数据量。
l 选择合适的分区键
数据分区功能,可根据表的一列或者多列,将要插入表的记录分为若干个范围(这些范
围在不同的分区里没有重叠)。然后为每个范围创建一个分区,用来存储相应的数据。
调整分区键,使每次查询结果尽可能存储在相同或者最少的分区内(称为“分区剪
枝”),通过获取连续I/O大幅度提升查询性能。
实际业务中,经常将时间作为查询对象的过滤条件,因此,可考虑选择时间列为分区
键,键值范围可根据总数据量、一次查询数据量调整。
l
TO { GROUP groupname | NODE ( nodename [, ... ] ) }
TO GROUP指定创建表所在的Node Group,目前不支持hdfs表使用。TO NODE主
要供内部扩容工具使用,一般用户不应该使用。
l
CONSTRAINT constraint_name
列约束或表约束的名字。可选的约束子句用于声明约束,新行或者更新的行必须
满足这些约束才能成功插入或更新。
定义约束有两种方法:
l
– 列约束:作为一个列定义的一部分,仅影响该列。
– 表约束:不和某个列绑在一起,可以作用于多个列。
NOT NULL
字段值不允许为NULL。
l
NULL
字段值允许为NULL ,这是缺省值。
这个子句只是为和非标准SQL数据库兼容。不建议使用。
l
CHECK ( expression )
CHECK约束声明一个布尔表达式,每次要插入的新行或者要更新的行的新值必须
使表达式结果为真或未知才能成功,否则会抛出一个异常并且不会修改数据库。
声明为字段约束的检查约束应该只引用该字段的数值,而在表约束里出现的表达
式可以引用多个字段。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
852GaussDB 200
开发者指南
16 SQL 参考
说明
expression表达式中,如果存在“<>NULL”或“!=NULL”,这种写法是无效的,需要写
成“is NOT NULL”。
l
DEFAULT default_expr
DEFAULT子句给字段指定缺省值。该数值可以是任何不含变量的表达式(不允许使
用子查询和对本表中的其他字段的交叉引用)。缺省表达式的数据类型必须和字段
类型匹配。
缺省表达式将被用于任何未声明该字段数值的插入操作。如果没有指定缺省值则
缺省值为NULL 。
l
UNIQUE index_parameters
UNIQUE ( column_name [, ... ] ) index_parameters
UNIQUE约束表示表里的一个字段或多个字段的组合必须在全表范围内唯一。
对于唯一约束,NULL被认为是互不相等的。
说明
如果没有声明DISTRIBUTE BY REPLICATION,则唯一约束的列集合中必须包含分布列。
l
PRIMARY KEY index_parameters
PRIMARY KEY ( column_name [, ... ] ) index_parameters
主键约束声明表中的一个或者多个字段只能包含唯一的非NULL值。
一个表只能声明一个主键。
说明
如果没有声明DISTRIBUTE BY REPLICATION,则主键约束的列集合中必须包含分布列。
l
DEFERRABLE | NOT DEFERRABLE
这两个关键字设置该约束是否可推迟。一个不可推迟的约束将在每条命令之后马
上检查。可推迟约束可以推迟到事务结尾使用SET CONSTRAINTS命令检查。缺
省是NOT DEFERRABLE。目前,UNIQUE约束和主键约束可以接受这个子句。所
有其他约束类型都是不可推迟的。
l
PARTIAL CLUSTER KEY
局部聚簇存储,列存表导入数据时按照指定的列(单列或多列),进行局部排序。
l
INITIALLY IMMEDIATE | INITIALLY DEFERRED
如果约束是可推迟的,则这个子句声明检查约束的缺省时间。
– 如果约束是INITIALLY IMMEDIATE(缺省),则在每条语句执行之后就立
即检查它;
– 如果约束是INITIALLY DEFERRED ,则只有在事务结尾才检查它。
约束检查的时间可以用SET CONSTRAINTS命令修改。
l
USING INDEX TABLESPACE tablespace_name
为UNIQUE或PRIMARY KEY约束相关的索引声明一个表空间。如果没有提供这个
子句,这个索引将在default_tablespace中创建,如果default_tablespace为空,将使
用数据库的缺省表空间。
示例
--创建简单的表。
CREATE TABLE tpcds.warehouse_t1
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
文档版本 01 (2019-08-01)
NOT NULL,
NOT NULL,
版权所有 © 华为技术有限公司
853GaussDB 200
开发者指南
16 SQL 参考
W_WAREHOUSE_NAME
W_WAREHOUSE_SQ_FT
W_STREET_NUMBER
W_STREET_NAME
W_STREET_TYPE
W_SUITE_NUMBER
W_CITY
W_COUNTY
W_STATE
W_ZIP
W_COUNTRY
W_GMT_OFFSET
VARCHAR(20)
INTEGER
CHAR(10)
VARCHAR(60)
CHAR(15)
CHAR(10)
VARCHAR(60)
VARCHAR(30)
CHAR(2)
CHAR(10)
VARCHAR(20)
DECIMAL(5,2)
,
,
,
,
,
,
,
,
,
,
,
);
CREATE TABLE tpcds.warehouse_t2
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
);
--创建表,并指定W_STATE字段的缺省值为GA。
CREATE TABLE tpcds.warehouse_t3
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
);
NOT NULL,
NOT NULL,
,
,
,
DICTIONARY,
,
,
,
,
,
,
,
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
DEFAULT 'GA',
,
,
--创建表,并在事务结束时检查W_WAREHOUSE_NAME字段是否有重复。
CREATE TABLE tpcds.warehouse_t4
(
W_WAREHOUSE_SK
INTEGER
NOT NULL,
W_WAREHOUSE_ID
CHAR(16)
NOT NULL,
W_WAREHOUSE_NAME
VARCHAR(20)
UNIQUE DEFERRABLE,
W_WAREHOUSE_SQ_FT
INTEGER
,
W_STREET_NUMBER
CHAR(10)
,
W_STREET_NAME
VARCHAR(60)
,
W_STREET_TYPE
CHAR(15)
,
W_SUITE_NUMBER
CHAR(10)
,
W_CITY
VARCHAR(60)
,
W_COUNTY
VARCHAR(30)
,
W_STATE
CHAR(2)
,
W_ZIP
CHAR(10)
,
W_COUNTRY
VARCHAR(20)
,
W_GMT_OFFSET
DECIMAL(5,2)
);
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
854GaussDB 200
开发者指南
16 SQL 参考
--创建一个带有70%填充因子的表。
CREATE TABLE tpcds.warehouse_t5
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2),
UNIQUE(W_WAREHOUSE_NAME) WITH(fillfactor=70)
);
--或者用下面的语法。
CREATE TABLE tpcds.warehouse_t6
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
) WITH(fillfactor=70);
--创建表,并指定该表数据不写入预写日志。
CREATE UNLOGGED TABLE tpcds.warehouse_t7
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
);
--创建表临时表。
CREATE TEMPORARY TABLE warehouse_t24
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
文档版本 01 (2019-08-01)
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
NOT NULL,
UNIQUE,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
NOT NULL,
,
,
,
,
,
,
版权所有 © 华为技术有限公司
855GaussDB 200
开发者指南
16 SQL 参考
W_CITY
W_COUNTY
W_STATE
W_ZIP
W_COUNTRY
W_GMT_OFFSET
VARCHAR(60)
VARCHAR(30)
CHAR(2)
CHAR(10)
VARCHAR(20)
DECIMAL(5,2)
,
,
,
,
,
);
--事务中创建表临时表,并指定提交事务时删除该临时表数据。
CREATE TEMPORARY TABLE warehouse_t25
(
W_WAREHOUSE_SK
INTEGER
NOT NULL,
W_WAREHOUSE_ID
CHAR(16)
NOT NULL,
W_WAREHOUSE_NAME
VARCHAR(20)
,
W_WAREHOUSE_SQ_FT
INTEGER
,
W_STREET_NUMBER
CHAR(10)
,
W_STREET_NAME
VARCHAR(60)
,
W_STREET_TYPE
CHAR(15)
,
W_SUITE_NUMBER
CHAR(10)
,
W_CITY
VARCHAR(60)
,
W_COUNTY
VARCHAR(30)
,
W_STATE
CHAR(2)
,
W_ZIP
CHAR(10)
,
W_COUNTRY
VARCHAR(20)
,
W_GMT_OFFSET
DECIMAL(5,2)
) ON COMMIT DELETE ROWS;
--创建表时,不希望因为表已存在而报错。
CREATE TABLE IF NOT EXISTS tpcds.warehouse_t8
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
);
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
--创建普通表空间。
CREATE TABLESPACE DS_TABLESPACE1 RELATIVE LOCATION ' tablespace/tablespace_1';
--创建表时,指定表空间。
CREATE TABLE tpcds.warehouse_t9
(
W_WAREHOUSE_SK
INTEGER
NOT NULL,
W_WAREHOUSE_ID
CHAR(16)
NOT NULL,
W_WAREHOUSE_NAME
VARCHAR(20)
,
W_WAREHOUSE_SQ_FT
INTEGER
,
W_STREET_NUMBER
CHAR(10)
,
W_STREET_NAME
VARCHAR(60)
,
W_STREET_TYPE
CHAR(15)
,
W_SUITE_NUMBER
CHAR(10)
,
W_CITY
VARCHAR(60)
,
W_COUNTY
VARCHAR(30)
,
W_STATE
CHAR(2)
,
W_ZIP
CHAR(10)
,
W_COUNTRY
VARCHAR(20)
,
W_GMT_OFFSET
DECIMAL(5,2)
) TABLESPACE DS_TABLESPACE1;
--创建表时,单独指定W_WAREHOUSE_NAME的索引表空间。
CREATE TABLE tpcds.warehouse_t10
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
856GaussDB 200
开发者指南
16 SQL 参考
(
W_WAREHOUSE_SK
W_WAREHOUSE_ID
W_WAREHOUSE_NAME
W_WAREHOUSE_SQ_FT
W_STREET_NUMBER
W_STREET_NAME
W_STREET_TYPE
W_SUITE_NUMBER
W_CITY
W_COUNTY
W_STATE
W_ZIP
W_COUNTRY
W_GMT_OFFSET
INTEGER
CHAR(16)
VARCHAR(20)
INTEGER
CHAR(10)
VARCHAR(60)
CHAR(15)
CHAR(10)
VARCHAR(60)
VARCHAR(30)
CHAR(2)
CHAR(10)
VARCHAR(20)
DECIMAL(5,2)
);
--创建一个有主键约束的表。
CREATE TABLE tpcds.warehouse_t11
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
);
---或是用下面的语法,效果完全一样。
CREATE TABLE tpcds.warehouse_t12
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2),
PRIMARY KEY(W_WAREHOUSE_SK)
);
--或是用下面的语法,指定约束的名称。
CREATE TABLE tpcds.warehouse_t13
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
文档版本 01 (2019-08-01)
NOT NULL,
NOT NULL,
UNIQUE USING INDEX TABLESPACE DS_TABLESPACE1,
,
,
,
,
,
,
,
,
,
,
PRIMARY KEY,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
版权所有 © 华为技术有限公司
857GaussDB 200
开发者指南
16 SQL 参考
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2),
CONSTRAINT W_CSTR_KEY1 PRIMARY KEY(W_WAREHOUSE_SK)
,
,
);
--创建一个有复合主键约束的表。
CREATE TABLE tpcds.warehouse_t14
(
W_WAREHOUSE_SK
INTEGER
NOT NULL,
W_WAREHOUSE_ID
CHAR(16)
NOT NULL,
W_WAREHOUSE_NAME
VARCHAR(20)
,
W_WAREHOUSE_SQ_FT
INTEGER
,
W_STREET_NUMBER
CHAR(10)
,
W_STREET_NAME
VARCHAR(60)
,
W_STREET_TYPE
CHAR(15)
,
W_SUITE_NUMBER
CHAR(10)
,
W_CITY
VARCHAR(60)
,
W_COUNTY
VARCHAR(30)
,
W_STATE
CHAR(2)
,
W_ZIP
CHAR(10)
,
W_COUNTRY
VARCHAR(20)
,
W_GMT_OFFSET
DECIMAL(5,2),
CONSTRAINT W_CSTR_KEY2 PRIMARY KEY(W_WAREHOUSE_SK, W_WAREHOUSE_ID)
);
--创建列存表。
CREATE TABLE tpcds.warehouse_t15
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
) WITH (ORIENTATION = COLUMN);
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
--创建局部聚簇存储的列存表。
CREATE TABLE tpcds.warehouse_t16
(
W_WAREHOUSE_SK
INTEGER
NOT NULL,
W_WAREHOUSE_ID
CHAR(16)
NOT NULL,
W_WAREHOUSE_NAME
VARCHAR(20)
,
W_WAREHOUSE_SQ_FT
INTEGER
,
W_STREET_NUMBER
CHAR(10)
,
W_STREET_NAME
VARCHAR(60)
,
W_STREET_TYPE
CHAR(15)
,
W_SUITE_NUMBER
CHAR(10)
,
W_CITY
VARCHAR(60)
,
W_COUNTY
VARCHAR(30)
,
W_STATE
CHAR(2)
,
W_ZIP
CHAR(10)
,
W_COUNTRY
VARCHAR(20)
,
W_GMT_OFFSET
DECIMAL(5,2),
PARTIAL CLUSTER KEY(W_WAREHOUSE_SK, W_WAREHOUSE_ID)
) WITH (ORIENTATION = COLUMN);
--定义一个带压缩的列存表。
CREATE TABLE tpcds.warehouse_t17
(
W_WAREHOUSE_SK
INTEGER
文档版本 01 (2019-08-01)
NOT NULL,
版权所有 © 华为技术有限公司
858GaussDB 200
开发者指南
16 SQL 参考
W_WAREHOUSE_ID
W_WAREHOUSE_NAME
W_WAREHOUSE_SQ_FT
W_STREET_NUMBER
W_STREET_NAME
W_STREET_TYPE
W_SUITE_NUMBER
W_CITY
W_COUNTY
W_STATE
W_ZIP
W_COUNTRY
W_GMT_OFFSET
) WITH (ORIENTATION = COLUMN,
CHAR(16)
VARCHAR(20)
INTEGER
CHAR(10)
VARCHAR(60)
CHAR(15)
CHAR(10)
VARCHAR(60)
VARCHAR(30)
CHAR(2)
CHAR(10)
VARCHAR(20)
DECIMAL(5,2)
COMPRESSION=HIGH);
--定义一个带压缩的表。
CREATE TABLE tpcds.warehouse_t18
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
) COMPRESS;
--定义一个检查列约束。
CREATE TABLE tpcds.warehouse_t19
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
);
CREATE TABLE tpcds.warehouse_t20
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2),
文档版本 01 (2019-08-01)
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
PRIMARY KEY CHECK (W_WAREHOUSE_SK > 0),
NOT NULL,
CHECK (W_WAREHOUSE_NAME IS NOT NULL),
,
,
,
,
,
,
,
,
,
,
PRIMARY KEY,
NOT NULL,
CHECK (W_WAREHOUSE_NAME IS NOT NULL),
,
,
,
,
,
,
,
,
,
,
版权所有 © 华为技术有限公司
859GaussDB 200
开发者指南
16 SQL 参考
CONSTRAINT W_CONSTR_KEY2 CHECK(W_WAREHOUSE_SK > 0 AND W_WAREHOUSE_NAME IS NOT NULL)
);
--定义一个表,表中每一个行存在所有DN中。
CREATE TABLE tpcds.warehouse_t21
(
W_WAREHOUSE_SK
INTEGER
W_WAREHOUSE_ID
CHAR(16)
W_WAREHOUSE_NAME
VARCHAR(20)
W_WAREHOUSE_SQ_FT
INTEGER
W_STREET_NUMBER
CHAR(10)
W_STREET_NAME
VARCHAR(60)
W_STREET_TYPE
CHAR(15)
W_SUITE_NUMBER
CHAR(10)
W_CITY
VARCHAR(60)
W_COUNTY
VARCHAR(30)
W_STATE
CHAR(2)
W_ZIP
CHAR(10)
W_COUNTRY
VARCHAR(20)
W_GMT_OFFSET
DECIMAL(5,2)
)DISTRIBUTE BY REPLICATION;
NOT NULL,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
,
--定义一个表,使用HASH分布。
CREATE TABLE tpcds.warehouse_t22
(
W_WAREHOUSE_SK
INTEGER
NOT NULL,
W_WAREHOUSE_ID
CHAR(16)
NOT NULL,
W_WAREHOUSE_NAME
VARCHAR(20)
,
W_WAREHOUSE_SQ_FT
INTEGER
,
W_STREET_NUMBER
CHAR(10)
,
W_STREET_NAME
VARCHAR(60)
,
W_STREET_TYPE
CHAR(15)
,
W_SUITE_NUMBER
CHAR(10)
,
W_CITY
VARCHAR(60)
,
W_COUNTY
VARCHAR(30)
,
W_STATE
CHAR(2)
,
W_ZIP
CHAR(10)
,
W_COUNTRY
VARCHAR(20)
,
W_GMT_OFFSET
DECIMAL(5,2),
CONSTRAINT W_CONSTR_KEY3 UNIQUE(W_WAREHOUSE_SK)
)DISTRIBUTE BY HASH(W_WAREHOUSE_SK);
--向tpcds.warehouse_t19表中增加一个varchar列。
ALTER TABLE tpcds.warehouse_t19 ADD W_GOODS_CATEGORY varchar(30);
--给tpcds.warehouse_t19表增加一个检查约束。
ALTER TABLE tpcds.warehouse_t19 ADD CONSTRAINT W_CONSTR_KEY4 CHECK (W_STATE IS NOT NULL);
--在一个操作中改变两个现存字段的类型。
ALTER TABLE tpcds.warehouse_t19
ALTER COLUMN W_GOODS_CATEGORY TYPE varchar(80),
ALTER COLUMN W_STREET_NAME TYPE varchar(100);
--此语句与上面语句等效。
ALTER TABLE tpcds.warehouse_t19 MODIFY (W_GOODS_CATEGORY varchar(30), W_STREET_NAME varchar(60));
--给一个已存在字段添加非空约束。
ALTER TABLE tpcds.warehouse_t19 ALTER COLUMN W_GOODS_CATEGORY SET NOT NULL;
--移除已存在字段的非空约束。
ALTER TABLE tpcds.warehouse_t19 ALTER COLUMN W_GOODS_CATEGORY DROP NOT NULL;
--如果列存表中还未指定局部聚簇,向在一个列存表中添加局部聚簇列。
ALTER TABLE tpcds.warehouse_t17 ADD PARTIAL CLUSTER KEY(W_WAREHOUSE_SK);
--查看约束的名称,并删除一个列存表中的局部聚簇列。
\d+ tpcds.warehouse_t17
Table "tpcds.warehouse_t17"
Column
|
Type
| Modifiers | Storage
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
| Stats target | Description
860GaussDB 200
开发者指南
16 SQL 参考
-------------------+-----------------------+-----------+----------+--------------+-------------
w_warehouse_sk
| integer
| not null | plain
|
|
w_warehouse_id
| character(16)
| not null | extended |
|
w_warehouse_name | character varying(20) |
| extended |
|
w_warehouse_sq_ft | integer
|
| plain
|
|
w_street_number
| character(10)
|
| extended |
|
w_street_name
| character varying(60) |
| extended |
|
w_street_type
| character(15)
|
| extended |
|
w_suite_number
| character(10)
|
| extended |
|
w_city
| character varying(60) |
| extended |
|
w_county
| character varying(30) |
| extended |
|
w_state
| character(2)
|
| extended |
|
w_zip
| character(10)
|
| extended |
|
w_country
| character varying(20) |
| extended |
|
w_gmt_offset
| numeric(5,2)
|
| main
|
|
Partial Cluster :
"warehouse_t17_cluster" PARTIAL CLUSTER KEY (w_warehouse_sk)
Has OIDs: no
Tablespace: "hdfs"
Distribute By: HASH(w_warehouse_sk)
Location Nodes: ALL DATANODES
Options: orientation=orc, compression=no, version=0.12
ALTER TABLE tpcds.warehouse_t17 DROP CONSTRAINT warehouse_t17_cluster;
--将表移动到另一个表空间。
ALTER TABLE tpcds.warehouse_t19 SET TABLESPACE PG_DEFAULT;
--创建模式joe。
CREATE SCHEMA joe;
--将表移动到另一个模式中。
ALTER TABLE tpcds.warehouse_t19 SET SCHEMA joe;
--重命名已存在的表。
ALTER TABLE joe.warehouse_t19 RENAME TO warehouse_t23;
--从warehouse_t23表中删除一个字段。
ALTER TABLE joe.warehouse_t23 DROP COLUMN W_STREET_NAME;
--删除表空间、模式joe和模式表warehouse。
DROP TABLESPA DS_TABLESPACE1;
DROP TABLE tpcds.warehouse_t1;
DROP TABLE tpcds.warehouse_t2;
DROP TABLE tpcds.warehouse_t3;
DROP TABLE tpcds.warehouse_t4;
DROP TABLE tpcds.warehouse_t5;
DROP TABLE tpcds.warehouse_t6;
DROP TABLE tpcds.warehouse_t7;
DROP TABLE tpcds.warehouse_t8;
DROP TABLE tpcds.warehouse_t9;
DROP TABLE tpcds.warehouse_t10;
DROP TABLE tpcds.warehouse_t11;
DROP TABLE tpcds.warehouse_t12;
DROP TABLE tpcds.warehouse_t13;
DROP TABLE tpcds.warehouse_t14;
DROP TABLE tpcds.warehouse_t15;
DROP TABLE tpcds.warehouse_t16;
DROP TABLE tpcds.warehouse_t17;
DROP TABLE tpcds.warehouse_t18;
DROP TABLE tpcds.warehouse_t20;
DROP TABLE tpcds.warehouse_t21;
DROP TABLE tpcds.warehouse_t22;
DROP TABLE joe.warehouse_t23;
DROP TABLE tpcds.warehouse_t24;
DROP TABLE tpcds.warehouse_t25;
DROP SCHEMA IF EXISTS joe CASCADE;
相关链接
16.14.24 ALTER TABLE,16.14.98 DROP TABLE,16.14.68 CREATE TABLESPACE
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
861GaussDB 200
开发者指南
16 SQL 参考
16.14.66 CREATE TABLE AS
功能描述
根据查询结果创建表。
CREATE TABLE AS创建一个表并且用来自SELECT命令的结果填充该表。该表的字段
和SELECT输出字段的名字及数据类型相关。不过用户可以通过明确地给出一个字段名
字列表来覆盖SELECT输出字段的名字。
CREATE TABLE AS对源表进行一次查询,然后将数据写入新表中,而查询视图结果会
根据源表的变化而有所改变。相比之下,每次做查询的时候,视图都重新计算定义它
的SELECT语句。
注意事项
l 分区表不能采用此方式进行创建。
l 如果在建表过程中数据库系统发生故障,系统恢复后可能无法自动清除之前已创
建的、大小非0的磁盘文件。此种情况出现概率小,不影响数据库系统的正常运
行。
语法格式
CREATE [ UNLOGGED ] TABLE table_name
[ (column_name [, ...] ) ]
[ WITH ( {storage_parameter = value} [, ... ] ) ]
[ COMPRESS | NOCOMPRESS ]
[ TABLESPACE tablespace_name ]
[ DISTRIBUTE BY { REPLICATION | { [HASH ] ( column_name ) } } ]
[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ]
AS query
[ WITH [ NO ] DATA ];
参数说明
l
UNLOGGED
指定表为非日志表。在非日志表中写入的数据不会被写入到预写日志中,这样就
会比普通表快很多。但是,它也是不安全的,非日志表在冲突或异常关机后会被
自动删截。非日志表中的内容也不会被复制到备用服务器中。在该类表中创建的
索引也不会被自动记录。
l
– 使用场景:非日志表不能保证数据的安全性,用户应该在确保数据已经做好
备份的前提下使用,例如系统升级时进行数据的备份。
– 故障处理:当异常关机等操作导致非日志表上的索引发生数据丢失时,用户
应该对发生错误的索引进行重建。
table_name
要创建的表名。
取值范围:字符串,要符合标识符的命名规范。
l
column_name
新表中要创建的字段名。
取值范围:字符串,要符合标识符的命名规范。
l
WITH ( storage_parameter [= value] [, ... ] )
这个子句为表或索引指定一个可选的存储参数。参数的详细说明如下所示。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
862GaussDB 200
开发者指南
16 SQL 参考
–
FILLFACTOR
一个表的填充因子(fillfactor)是一个介于10和100之间的百分数。100(完全
填充)是默认值。如果指定了较小的填充因子,INSERT操作仅按照填充因子
指定的百分率填充表页。每个页上的剩余空间将用于在该页上更新行,这就
使得UPDATE有机会在同一页上放置同一条记录的新版本,这比把新版本放
置在其他页上更有效。对于一个从不更新的表将填充因子设为100是最佳选
择,但是对于频繁更新的表,选择较小的填充因子则更加合适。该参数只对
行存表有效。
取值范围:10~100
–
ORIENTATION
取值范围:
COLUMN:表的数据将以列式存储。
ROW(缺省值):表的数据将以行式存储。
–
COMPRESSION
指定表数据的压缩级别,它决定了表数据的压缩比以及压缩时间。一般来
讲,压缩级别越高,压缩比也越大,压缩时间也越长;反之亦然。实际压缩
比取决于加载的表数据的分布特征。
取值范围:
列存表的有效值为YES/NO/LOW/MIDDLE/HIGH,默认值为LOW。
行存表的有效值为YES/NO,默认值为NO。
–
MAX_BATCHROW
指定了在数据加载过程中一个存储单元可以容纳记录的最大数目。该参数只
对列存表有效。
取值范围:10000~60000
–
PARTIAL_CLUSTER_ROWS
指定了在数据加载过程中进行将局部聚簇存储的记录数目。该参数只对列存
表有效。
取值范围:600000~2147483647
l
COMPRESS / NOCOMPRESS
创建一个新表时,需要在创建表语句中指定关键字COMPRESS,这样,当对该表
进行批量插入时就会触发压缩特性。该特性会在页范围内扫描所有元组数据,生
成字典、压缩元组数据并进行存储。指定关键字NOCOMPRESS则不对表进行压
缩。
缺省值:NOCOMPRESS,即不对元组数据进行压缩。
l
TABLESPACE tablespace_name
指定新表将要在tablespace_name表空间内创建。如果没有声明,将使用默认表空
间。
l
DISTRIBUTE BY
指定表如何在节点之间分布或者复制。
– REPLICATION:表的每一行存在所有数据节点( DN )中,即每个数据节点都
有完整的表数据。
– HASH (column_name ) :对指定的列进行Hash,通过映射,把数据分布到指
定DN。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
863GaussDB 200
开发者指南
16 SQL 参考
l 当指定DISTRIBUTE BY HASH (column_name)参数时,创建主键和唯一索引必
须包含“ column_name”列。
l 当被参照表指定DISTRIBUTE BY HASH (column_name)参数时,参照表的外键
必须包含“ column_name”列。
缺省值:HASH(column_name),column_name取表的主键列(如果有的话)或首个
数据类型支持作为分布列的列。
column_name的数据类型必须是以下类型之一:
l
– INTEGER TYPES:TINYINT,SMALLINT,INT,BIGINT,NUMERIC/
DECIMAL
– CHARACTER TYPES: CHAR,BPCHAR,VARCHAR,VARCHAR2,
NVARCHAR2
– DATE/TIME TYPES: DATE,TIME,TIMETZ,TIMESTAMP,
TIMESTAMPTZ,INTERVAL,SMALLDATETIME
TO { GROUP groupname | NODE ( nodename [, ... ] ) }
TO GROUP指定创建表所在的Node Group,目前不支持hdfs表使用。TO NODE主
要供内部扩容工具使用,一般用户不应该使用。
l
AS query
一个SELECT VALUES命令或者一个运行预备好的SELECT或VALUES查询的
EXECUTE命令。
l
[ WITH [ NO ] DATA ]
创建表时,是否也插入查询到的数据。默认是要数据,选择“NO”参数时,则不
要数据。
示例
--创建一个表tpcds.store_returns_t1并插入tpcds.store_returns表中sr_item_sk字段中大于16的数值。
CREATE TABLE tpcds.store_returns_t1 AS SELECT * FROM tpcds.store_returns WHERE sr_item_sk >
'4795';
--使用tpcds.store_returns拷贝一个新表tpcds.store_returns_t2。
CREATE TABLE tpcds.store_returns_t2 AS table tpcds.store_returns;
--删除表。
DROP TABLE tpcds.store_returns_t1 ;
DROP TABLE tpcds.store_returns_t2 ;
相关链接
16.14.65 CREATE TABLE,16.14.128 SELECT
16.14.67 CREATE TABLE PARTITION
功能描述
创建分区表。分区表是把逻辑上的一张表根据某种方案分成几张物理块进行存储,这
张逻辑上的表称之为分区表,物理块称之为分区。分区表是一张逻辑表,不存储数
据,数据实际是存储在分区上的。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
864GaussDB 200
开发者指南
16 SQL 参考
常见的分区方案有范围分区(Range Partitioning)、哈希分区(Hash Partitioning)、列
表分区(List Partitioning)、数值分区(Value Partition)等。目前行存表、列存表仅支
持范围分区。
范围分区是根据表的一列或者多列,将要插入表的记录分为若干个范围,这些范围在
不同的分区里没有重叠。为每个范围创建一个分区,用来存储相应的数据。
范围分区的分区策略是指记录插入分区的方式。目前范围分区仅支持范围分区策略。
范围分区策略:根据分区键值将记录映射到已创建的某个分区上,如果可以映射到已
创建的某一分区上,则把记录插入到对应的分区上,否则给出报错和提示信息。这是
最常用的分区策略。
分区可以提供若干好处:
l 某些类型的查询性能可以得到极大提升。特别是表中访问率较高的行位于一个单
独分区或少数几个分区上的情况下。分区可以减少数据的搜索空间,提高数据访
问效率。
l 当查询或更新一个分区的大部分记录时,连续扫描那个分区而不是访问整个表可
以获得巨大的性能提升。
l 如果需要大量加载或者删除的记录位于单独的分区上,则可以通过直接读取或删
除那个分区以获得巨大的性能提升,同时还可以避免由于大量DELETE导致的
VACUUM超载(仅范围分区)。
注意事项
有限地支持唯一约束和主键约束,即唯一约束和主键约束的约束键必须包含所有分区
键。
语法格式
CREATE TABLE [ IF NOT EXISTS ] partition_table_name
( [
{ column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ]
| table_constraint
| LIKE source_table [ like_option [...] ] }[, ... ]
] )
[ WITH ( {storage_parameter = value} [, ... ] ) ]
[ COMPRESS | NOCOMPRESS ]
[ TABLESPACE tablespace_name ]
[ DISTRIBUTE BY { REPLICATION | { [ HASH ] ( column_name ) } } ]
[ TO { GROUP groupname | NODE ( nodename [, ... ] ) } ]
PARTITION BY {
{VALUES (partition_key)} |
{RANGE (partition_key) ( partition_less_than_item [, ... ] )} |
{RANGE (partition_key) ( partition_start_end_item [, ... ] )}
} [ { ENABLE | DISABLE } ROW MOVEMENT ];
l
列约束column_constraint:
[ CONSTRAINT constraint_name ]
{ NOT NULL |
NULL |
CHECK ( expression ) |
DEFAULT default_expr |
UNIQUE index_parameters |
PRIMARY KEY index_parameters }
[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
l
表约束table_constraint:
[ CONSTRAINT constraint_name ]
{ CHECK ( expression ) |
UNIQUE ( column_name [, ... ] ) index_parameters |
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
865GaussDB 200
开发者指南
16 SQL 参考
PRIMARY KEY ( column_name [, ... ] ) index_parameters}
[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
l
like选项like_option:
{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS |
RELOPTIONS | DISTRIBUTION | ALL }
l
索引存储参数index_parameters:
[ WITH ( {storage_parameter = value} [, ... ] ) ]
[ USING INDEX TABLESPACE tablespace_name ]
l
partition_less_than_item:
PARTITION partition_name VALUES LESS THAN ( { partition_value | MAXVALUE } ) [TABLESPACE
tablespace_name]
l
partition_start_end_item:
PARTITION partition_name {
{START(partition_value) END (partition_value) EVERY (interval_value)} |
{START(partition_value) END ({partition_value | MAXVALUE})} |
{START(partition_value)} |
{END({partition_value | MAXVALUE})}
} [TABLESPACE tablespace_name]
参数说明
l
IF NOT EXISTS
如果已经存在相同名称的表,不会抛出一个错误,而会发出一个通知,告知表关
系已存在。
l
partition_table_name
分区表的名称。
取值范围:字符串,要符合标识符的命名规范。
l
column_name
新表中要创建的字段名。
取值范围:字符串,要符合标识符的命名规范。
l
data_type
字段的数据类型。
l
COLLATE collation
COLLATE子句指定列的排序规则(该列必须是可排列的数据类型)。如果没有指
定,则使用默认的排序规则。
l
CONSTRAINT constraint_name
列约束或表约束的名字。可选的约束子句用于声明约束,新行或者更新的行必须
满足这些约束才能成功插入或更新。
定义约束有两种方法:
l
– 列约束:作为一个列定义的一部分,仅影响该列。
– 表约束:不和某个列绑在一起,可以作用于多个列。
LIKE source_table [ like_option ... ]
LIKE子句声明一个表,新表自动从这个表里面继承所有字段名及其数据类型和非
空约束。
和INHERITS不同,新表与原来的表之间在创建动作完毕之后是完全无关的。在源
表做的任何修改都不会传播到新表中,并且也不可能在扫描源表的时候包含新表
的数据。
字段缺省表达式只有在声明了INCLUDING DEFAULTS之后才会包含进来。缺省是
不包含缺省表达式的,即新表中所有字段的缺省值都是NULL。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
866GaussDB 200
开发者指南
16 SQL 参考
非空约束将总是复制到新表中,CHECK约束则仅在指定了INCLUDING
CONSTRAINTS的时候才复制,而其他类型的约束则永远也不会被复制。此规则
同时适用于表约束和列约束。
和INHERITS不同,被复制的列和约束并不使用相同的名字进行融合。如果明确的
指定了相同的名字或者在另外一个LIKE子句中,将会报错。
l
– 如果指定了INCLUDING INDEXES,则源表上的索引也将在新表上创建,默
认不建立索引。
– 如果指定了INCLUDING STORAGE,则拷贝列的STORAGE设置也将被拷
贝,默认情况下不包含STORAGE设置。
– 如果指定了INCLUDING COMMENTS,则源表列、约束和索引的注释也会被
拷贝过来。默认情况下,不拷贝源表的注释。
– 如果指定了INCLUDING RELOPTIONS,则源表的存储参数(即源表的WITH
子句)也将拷贝至新表。默认情况下,不拷贝源表的存储参数。
– 如果指定了INCLUDING DISTRIBUTION,则新表将拷贝源表的分布信息,
包括分布类型和分布列,同时新表将不能再使用DISTRIBUTE BY子句。默认
情况下,不拷贝源表的分布信息。
– INCLUDING ALL是INCLUDING DEFAULTS INCLUDING CONSTRAINTS
INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS
INCLUDING RELOPTIONS INCLUDING DISTRIBUTION的简写形式。
WITH ( storage_parameter [= value] [, ... ] )
这个子句为表或索引指定一个可选的存储参数。参数的详细描述如下所示:
–
FILLFACTOR
一个表的填充因子(fillfactor)是一个介于10和100之间的百分数。100(完全
填充)是默认值。如果指定了较小的填充因子,INSERT操作仅按照填充因子
指定的百分率填充表页。每个页上的剩余空间将用于在该页上更新行,这就
使得UPDATE有机会在同一页上放置同一条记录的新版本,这比把新版本放
置在其他页上更有效。对于一个从不更新的表将填充因子设为100是最佳选
择,但是对于频繁更新的表,选择较小的填充因子则更加合适。该参数对于
列存表没有意义。
取值范围:10~100
–
ORIENTATION
决定了表的数据的存储方式。
取值范围:
n COLUMN:表的数据将以列式存储。
n ROW(缺省值):表的数据将以行式存储。
n ORC:表的数据将以ORC格式存储(仅HDFS表)。
orientation不支持修改。
–
文档版本 01 (2019-08-01)
COMPRESSION
n 列存表的有效值为LOW/MIDDLE/HIGH/YES/NO,压缩级别依次升高,
默认值为LOW。
n 行存表的有效值为YES/NO,默认值为NO。
版权所有 © 华为技术有限公司
867GaussDB 200
开发者指南
16 SQL 参考
n
–
HDFS表的有效值为ZLIB/SNAPPY/NO,ZLIB的压缩比大于SNAPPY,默
认值为SNAPPY。
MAX_BATCHROW
指定了在数据加载过程中一个存储单元可以容纳记录的最大数目。该参数只
对列存表有效。
取值范围:10000~60000
–
PARTIAL_CLUSTER_ROWS
指定了在数据加载过程中进行将局部聚簇存储的记录数目。该参数只对列存
表有效。
取值范围:其有效值为大于等于10万。此值是MAX_BATCHROW的倍数。
–
DELTAROW_THRESHOLD
预留参数。该参数只对列存表有效。
取值范围:0~9999
l
COMPRESS / NOCOMPRESS
创建一个新表时,需要在创建表语句中指定关键字COMPRESS,这样,当对该表
进行批量插入时就会触发压缩特性。该特性会在页范围内扫描所有元组数据,生
成字典、压缩元组数据并进行存储。指定关键字NOCOMPRESS则不对表进行压
缩。
缺省值为NOCOMPRESS,即不对元组数据进行压缩。
l
TABLESPACE tablespace_name
指定新表将要在tablespace_name表空间内创建。如果没有声明,将使用默认表空
间。
l
DISTRIBUTE BY
指定表如何在节点之间分布或者复制。
取值范围:
– REPLICATION:表的每一行存在所有数据节点( DN )中,即每个数据节点都
有完整的表数据。
– HASH (column_name ) :对指定的列进行Hash,通过映射,把数据分布到指
定DN。
l 当指定DISTRIBUTE BY HASH (column_name)参数时,创建主键和唯一索引必
须包含“ column_name”列。
l 当被参照表指定DISTRIBUTE BY HASH (column_name)参数时,参照表的外键
必须包含“ column_name”列。
缺省值:HASH(column_name),column_name取表的主键列(如果有的话)或首个
数据类型支持作为分布列的列。
column_name的数据类型必须是以下类型之一:
– INTEGER TYPES: TINYINT, SMALLINT, INT, BIGINT, NUMERIC/DECIMAL
– CHARACTER TYPES: CHAR, BPCHAR, VARCHAR, VARCHAR2,
NVARCHAR2
– DATA/TIME TYPES: DATE, TIME, TIMETZ, TIMESTAMP, TIMESTAMPTZ,
INTERVAL, SMALLDATETIME
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
868GaussDB 200
开发者指南
16 SQL 参考
l
TO { GROUP groupname | NODE ( nodename [, ... ] ) }
TO GROUP指定创建表所在的Node Group,目前不支持hdfs表使用。TO NODE主
要供内部扩容工具使用,一般用户不应该使用。
l
PARTITION BY RANGE(partition_key)
创建范围分区。partition_key为分区键的名称。
(1)对于从句是VALUES LESS THAN的语法格式:
对于从句是VALUE LESS THAN的语法格式,范围分区策略的分区键最多支持4
列。
该情形下,分区键支持的数据类型为:SMALLINT、INTEGER、BIGINT、
DECIMAL、NUMERIC、REAL、DOUBLE PRECISION、CHARACTER
VARYING(n)、VARCHAR(n)、CHARACTER(n)、CHAR(n)、CHARACTER、
CHAR、TEXT、NVARCHAR2、NAME、TIMESTAMP[(p)] [WITHOUT TIME
ZONE]、TIMESTAMP[(p)] [WITH TIME ZONE]、DATE。
(2)对于从句是START END的语法格式:
对于从句是START END的语法格式,范围分区策略的分区键仅支持1列。
该情形下,分区键支持的数据类型为:SMALLINT、INTEGER、BIGINT、
DECIMAL、NUMERIC、REAL、DOUBLE PRECISION、TIMESTAMP[(p)]
[WITHOUT TIME ZONE]、TIMESTAMP[(p)] [WITH TIME ZONE]、DATE。
l
PARTITION partition_name VALUES LESS THAN ( { partition_value |
MAXVALUE } )
指定各分区的信息。partition_name为范围分区的名称。partition_value为范围分区
的上边界,取值依赖于partition_key的类型。MAXVALUE表示分区的上边界,它
通常用于设置最后一个范围分区的上边界。
l 每个分区都需要指定一个上边界。
l 分区上边界的类型应当和分区键的类型一致。
l 分区列表是按照分区上边界升序排列的,值较小的分区位于值较大的分区之
前。
l
PARTITION partition_name {START (partition_value) END (partition_value)
EVERY (interval_value)} | {START (partition_value) END (partition_value|
MAXVALUE)} | {START(partition_value)} | {END (partition_value |
MAXVALUE)}
指定各分区的信息,各参数意义如下:
–
文档版本 01 (2019-08-01)
partition_name:范围分区的名称或名称前缀,除以下情形外(假定其中的
partition_name是p1),均为分区的名称。
版权所有 © 华为技术有限公司
869GaussDB 200
开发者指南
16 SQL 参考
n 若该定义是START+END+EVERY从句,则语义上定义的分区的名称依次
为p1_1, p1_2, ...。例如对于定义“PARTITION p1 START(1) END(4)
EVERY(1)”,则生成的分区是:[1, 2), [2, 3) 和 [3, 4),名称依次为p1_1,
p1_2和p1_3,即此处的p1是名称前缀。
n 若该定义是第一个分区定义,且该定义有START值,则范围
(MINVALUE, START)将自动作为第一个实际分区,其名称为p1_0,
然后该定义语义描述的分区名称依次为p1_1, p1_2, ...。例如对于完整定
义“PARTITION p1 START(1), PARTITION p2 START(2)”,则生成的分
区是:(MINVALUE, 1), [1, 2) 和 [2, MAXVALUE),其名称依次为p1_0,
p1_1和p2,即此处p1是名称前缀,p2是分区名称。这里MINVALUE表示
最小值。
– partition_value:范围分区的端点值(起始或终点),取值依赖于partition_key
的类型,不可是MAXVALUE。
– interval_value:对[START,END) 表示的范围进行切分,interval_value是指定
切分后每个分区的宽度,不可是MAXVALUE;如果(END-START)值不能
整除以EVERY值,则仅最后一个分区的宽度小于EVERY值。
– MAXVALUE:表示最大值,它通常用于设置最后一个范围分区的上边界。
1. 在创建分区表若第一个分区定义含START值,则范围(MINVALUE,START)
将自动作为实际的第一个分区。
2. START END语法需要遵循以下限制:
l 每个partition_start_end_item中的START值(如果有的话,下同)必须小于
其END值;
l 相邻的两个partition_start_end_item,第一个的END值必须等于第二个的
START值;
l 每个partition_start_end_item中的EVERY值必须是正向递增的,且必须小于
(END-START)值;
l 每个分区包含起始值,不包含终点值,即形如:[起始值,终点值),起始
值是MINVALUE时则不包含;
l 一个partition_start_end_item创建的每个分区所属的TABLESPACE一样;
l partition_name作为分区名称前缀时,其长度不要超过57字节,超过时自动
截断;
l 在创建、修改分区表时请注意分区表的分区总数不可超过最大限制
(32767);
3. 在创建分区表时START END与LESS THAN语法不可混合使用。
4. 即使创建分区表时使用START END语法,备份(gs_dump)出的SQL语句也是
VALUES LESS THAN语法格式。
l
{ ENABLE | DISABLE } ROW MOVEMENT
行迁移开关。
如果进行UPDATE操作时,更新了元组在分区键上的值,造成了该元组所在分区
发生变化,就会根据该开关给出报错信息,或者进行元组在分区间的转移。
取值范围:
–
文档版本 01 (2019-08-01)
ENABLE:行迁移开关打开。
版权所有 © 华为技术有限公司
870GaussDB 200
开发者指南
16 SQL 参考
–
l
DISABLE(缺省值):行迁移开关关闭。
NOT NULL
字段值不允许为NULL。ENABLE用于语法兼容,可省略。
l
NULL
字段值允许NULL ,这是缺省。
这个子句只是为和非标准SQL数据库兼容。不建议使用。
l
CHECK (condition) [ NO INHERIT ]
CHECK约束声明一个布尔表达式,每次要插入的新行或者要更新的行的新值必须
使表达式结果为真或未知才能成功,否则会抛出一个异常并且不会修改数据库。
声明为字段约束的检查约束应该只引用该字段的数值,而在表约束里出现的表达
式可以引用多个字段。
用NO INHERIT标记的约束将不会传递到子表中去。
ENABLE用于语法兼容,可省略。
l
DEFAULT default_expr
DEFAULT子句给字段指定缺省值。该数值可以是任何不含变量的表达式(不允许使
用子查询和对本表中的其他字段的交叉引用)。缺省表达式的数据类型必须和字段
类型匹配。
缺省表达式将被用于任何未声明该字段数值的插入操作。如果没有指定缺省值则
缺省值为NULL 。
l
UNIQUE index_parameters
UNIQUE ( column_name [, ... ] ) index_parameters
UNIQUE约束表示表里的一个字段或多个字段的组合必须在全表范围内唯一。
对于唯一约束,NULL被认为是互不相等的。
说明
如果没有声明DISTRIBUTE BY REPLICATION,则唯一约束的列集合中必须包含分布列。
l
PRIMARY KEY index_parameters
PRIMARY KEY ( column_name [, ... ] ) index_parameters
主键约束声明表中的一个或者多个字段只能包含唯一的非NULL值。
一个表只能声明一个主键。
说明
如果没有声明DISTRIBUTE BY REPLICATION,则主键约束的列集合中必须包含分布列。
l
DEFERRABLE | NOT DEFERRABLE
这两个关键字设置该约束是否可推迟。一个不可推迟的约束将在每条命令之后马
上检查。可推迟约束可以推迟到事务结尾使用SET CONSTRAINTS命令检查。缺
省是NOT DEFERRABLE。目前,UNIQUE约束和主键约束可以接受这个子句。所
有其他约束类型都是不可推迟的。
l
INITIALLY IMMEDIATE | INITIALLY DEFERRED
如果约束是可推迟的,则这个子句声明检查约束的缺省时间。
– 如果约束是INITIALLY IMMEDIATE(缺省),则在每条语句执行之后就立
即检查它;
– 如果约束是INITIALLY DEFERRED ,则只有在事务结尾才检查它。
约束检查的时间可以用SET CONSTRAINTS命令修改。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
871GaussDB 200
开发者指南
16 SQL 参考
l
USING INDEX TABLESPACE tablespace_name
为UNIQUE或PRIMARY KEY约束相关的索引声明一个表空间。如果没有提供这个
子句,这个索引将在default_tablespace中创建,如果default_tablespace为空,将使
用数据库的缺省表空间。
示例
l
示例1:创建范围分区表tpcds.web_returns_p1,含有8个分区,分区键为integer类
型。 分区的范围分别为:wr_returned_date_sk< 2450815,2450815<=
wr_returned_date_sk< 2451179,2451179<=wr_returned_date_sk< 2451544,2451544
<= wr_returned_date_sk< 2451910,2451910 <= wr_returned_date_sk< 2452275,
2452275 <= wr_returned_date_sk< 2452640,2452640 <= wr_returned_date_sk<
2453005,wr_returned_date_sk>=2453005。
--创建分区表tpcds.web_returns_p1。
CREATE TABLE tpcds.web_returns_p1
(
WR_RETURNED_DATE_SK
INTEGER
WR_RETURNED_TIME_SK
INTEGER
WR_ITEM_SK
INTEGER
WR_REFUNDED_CUSTOMER_SK
INTEGER
WR_REFUNDED_CDEMO_SK
INTEGER
WR_REFUNDED_HDEMO_SK
INTEGER
WR_REFUNDED_ADDR_SK
INTEGER
WR_RETURNING_CUSTOMER_SK INTEGER
WR_RETURNING_CDEMO_SK
INTEGER
WR_RETURNING_HDEMO_SK
INTEGER
WR_RETURNING_ADDR_SK
INTEGER
WR_WEB_PAGE_SK
INTEGER
WR_REASON_SK
INTEGER
WR_ORDER_NUMBER
BIGINT
WR_RETURN_QUANTITY
INTEGER
WR_RETURN_AMT
DECIMAL(7,2)
WR_RETURN_TAX
DECIMAL(7,2)
WR_RETURN_AMT_INC_TAX
DECIMAL(7,2)
WR_FEE
DECIMAL(7,2)
WR_RETURN_SHIP_COST
DECIMAL(7,2)
WR_REFUNDED_CASH
DECIMAL(7,2)
WR_REVERSED_CHARGE
DECIMAL(7,2)
WR_ACCOUNT_CREDIT
DECIMAL(7,2)
WR_NET_LOSS
DECIMAL(7,2)
)
WITH (ORIENTATION = COLUMN,COMPRESSION=MIDDLE)
DISTRIBUTE BY HASH (WR_ITEM_SK)
PARTITION BY RANGE(WR_RETURNED_DATE_SK)
(
PARTITION P1 VALUES LESS THAN(2450815),
PARTITION P2 VALUES LESS THAN(2451179),
PARTITION P3 VALUES LESS THAN(2451544),
PARTITION P4 VALUES LESS THAN(2451910),
PARTITION P5 VALUES LESS THAN(2452275),
PARTITION P6 VALUES LESS THAN(2452640),
PARTITION P7 VALUES LESS THAN(2453005),
PARTITION P8 VALUES LESS THAN(MAXVALUE)
);
,
,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
,
,
,
,
,
,
,
,
,
--从示例数据表导入数据。
INSERT INTO tpcds.web_returns_p1 SELECT * FROM tpcds.web_returns;
--删除分区P8。
ALTER TABLE tpcds.web_returns_p1 DROP PARTITION P8;
--增加分区WR_RETURNED_DATE_SK介于2453005和2453105之间。
ALTER TABLE tpcds.web_returns_p1 ADD PARTITION P8 VALUES LESS THAN (2453105);
--增加分区WR_RETURNED_DATE_SK介于2453105和MAXVALUE之间。
ALTER TABLE tpcds.web_returns_p1 ADD PARTITION P9 VALUES LESS THAN (MAXVALUE);
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
872GaussDB 200
开发者指南
16 SQL 参考
--删除分区P8。
ALTER TABLE tpcds.web_returns_p1 DROP PARTITION FOR (2453005);
--分区P7重命名为P10。
ALTER TABLE tpcds.web_returns_p1 RENAME PARTITION P7 TO P10;
--分区P6重命名为P11。
ALTER TABLE tpcds.web_returns_p1 RENAME PARTITION FOR (2452639) TO P11;
--查询分区P10的行数。
SELECT count(*) FROM tpcds.web_returns_p1 PARTITION (P10);
count
--------
929340
(1 row)
--查询分区P1的行数。
SELECT COUNT(*) FROM tpcds.web_returns_p1 PARTITION FOR (2450815);
count
--------
446854
(1 row)
l
示例2:创建范围分区表tpcds.web_returns_p2,含有8个分区,分区键类型为integer
类型,其中第8个分区上边界为MAXVALUE。
八个分区的范围分别为: wr_returned_date_sk< 2450815,2450815<=
wr_returned_date_sk< 2451179,2451179<=wr_returned_date_sk< 2451544,2451544
<= wr_returned_date_sk< 2451910,2451910 <= wr_returned_date_sk< 2452275,
2452275 <= wr_returned_date_sk< 2452640,2452640 <= wr_returned_date_sk<
2453005,wr_returned_date_sk>=2453005。
分区表tpcds.web_returns_p2的表空间为example1;分区P1到P7没有声明表空间,
使用采用分区表tpcds.web_returns_p2的表空间example1;指定分区P8的表空间为
example2。
假定CN和DN的数据目录/pg_location/mount1/path1,CN和DN的数据目录/
pg_location/mount2/path2,CN和DN的数据目录/pg_location/mount3/path3,CN和
DN的数据目录/pg_location/mount4/path4是dwsadmin用户拥有读写权限的空目录。
CREATE
CREATE
CREATE
CREATE
TABLESPACE
TABLESPACE
TABLESPACE
TABLESPACE
example1
example2
example3
example4
RELATIVE
RELATIVE
RELATIVE
RELATIVE
LOCATION
LOCATION
LOCATION
LOCATION
'tablespace1/tablespace_1';
'tablespace2/tablespace_2';
'tablespace3/tablespace_3';
'tablespace4/tablespace_4';
CREATE TABLE tpcds.web_returns_p2
(
WR_RETURNED_DATE_SK
INTEGER
WR_RETURNED_TIME_SK
INTEGER
WR_ITEM_SK
INTEGER
WR_REFUNDED_CUSTOMER_SK
INTEGER
WR_REFUNDED_CDEMO_SK
INTEGER
WR_REFUNDED_HDEMO_SK
INTEGER
WR_REFUNDED_ADDR_SK
INTEGER
WR_RETURNING_CUSTOMER_SK INTEGER
WR_RETURNING_CDEMO_SK
INTEGER
WR_RETURNING_HDEMO_SK
INTEGER
WR_RETURNING_ADDR_SK
INTEGER
WR_WEB_PAGE_SK
INTEGER
WR_REASON_SK
INTEGER
WR_ORDER_NUMBER
BIGINT
WR_RETURN_QUANTITY
INTEGER
WR_RETURN_AMT
DECIMAL(7,2)
WR_RETURN_TAX
DECIMAL(7,2)
WR_RETURN_AMT_INC_TAX
DECIMAL(7,2)
WR_FEE
DECIMAL(7,2)
WR_RETURN_SHIP_COST
DECIMAL(7,2)
WR_REFUNDED_CASH
DECIMAL(7,2)
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
,
,
NOT NULL,
,
,
,
,
,
,
,
,
,
,
NOT NULL,
,
,
,
,
,
,
,
873GaussDB 200
开发者指南
16 SQL 参考
WR_REVERSED_CHARGE
WR_ACCOUNT_CREDIT
WR_NET_LOSS
DECIMAL(7,2)
DECIMAL(7,2)
DECIMAL(7,2)
,
,
)
TABLESPACE example1
DISTRIBUTE BY HASH (WR_ITEM_SK)
PARTITION BY RANGE(WR_RETURNED_DATE_SK)
(
PARTITION P1 VALUES LESS THAN(2450815),
PARTITION P2 VALUES LESS THAN(2451179),
PARTITION P3 VALUES LESS THAN(2451544),
PARTITION P4 VALUES LESS THAN(2451910),
PARTITION P5 VALUES LESS THAN(2452275),
PARTITION P6 VALUES LESS THAN(2452640),
PARTITION P7 VALUES LESS THAN(2453005),
PARTITION P8 VALUES LESS THAN(MAXVALUE) TABLESPACE example2
)
ENABLE ROW MOVEMENT;
--以like方式创建一个分区表。
CREATE TABLE tpcds.web_returns_p3 (LIKE tpcds.web_returns_p2 INCLUDING PARTITION);
--修改分区P1的表空间为example2。
ALTER TABLE tpcds.web_returns_p2 MOVE PARTITION P1 TABLESPACE example2;
--修改分区P2的表空间为example3。
ALTER TABLE tpcds.web_returns_p2 MOVE PARTITION P2 TABLESPACE example3;
--以2453010为分割点切分P8。
ALTER TABLE tpcds.web_returns_p2 SPLIT PARTITION P8 AT (2453010) INTO
(
PARTITION P9,
PARTITION P10
);
--将P6,P7合并为一个分区。
ALTER TABLE tpcds.web_returns_p2 MERGE PARTITIONS P6, P7 INTO PARTITION P8;
--修改分区表迁移属性。
ALTER TABLE tpcds.web_returns_p2 DISABLE ROW MOVEMENT;
--删除表和表空间。
DROP TABLE tpcds.web_returns_p1;
DROP TABLE tpcds.web_returns_p2;
DROP TABLE tpcds.web_returns_p3;
DROP TABLESPACE example1;
DROP TABLESPACE example2;
DROP TABLESPACE example3;
DROP TABLESPACE example4;
l
示例3:START END语法创建、修改Range分区表。
假定/home/omm/startend_tbs1,/home/omm/startend_tbs2,/home/omm/
startend_tbs3,/home/omm/startend_tbs4是omm用户拥有读写权限的空目录。
-- 创建表空间
CREATE TABLESPACE
CREATE TABLESPACE
CREATE TABLESPACE
CREATE TABLESPACE
startend_tbs1
startend_tbs2
startend_tbs3
startend_tbs4
LOCATION
LOCATION
LOCATION
LOCATION
'/home/omm/startend_tbs1';
'/home/omm/startend_tbs2';
'/home/omm/startend_tbs3';
'/home/omm/startend_tbs4';
-- 创建临时schema
CREATE SCHEMA tpcds;
SET CURRENT_SCHEMA TO tpcds;
-- 创建分区表,分区键是integer类型
CREATE TABLE tpcds.startend_pt (c1 INT, c2 INT)
TABLESPACE startend_tbs1
DISTRIBUTE BY HASH (c1)
PARTITION BY RANGE (c2) (
PARTITION p1 START(1) END(1000) EVERY(200) TABLESPACE startend_tbs2,
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
874GaussDB 200
开发者指南
16 SQL 参考
PARTITION
PARTITION
PARTITION
PARTITION
p2
p3
p4
p5
END(2000),
START(2000) END(2500) TABLESPACE startend_tbs3,
START(2500),
START(3000) END(5000) EVERY(1000) TABLESPACE startend_tbs4
)
ENABLE ROW MOVEMENT;
-- 查看分区表信息
SELECT relname, boundaries, spcname FROM pg_partition p JOIN pg_tablespace t ON
p.reltablespace=t.oid and p.parentid='tpcds.startend_pt'::regclass ORDER BY 1;
relname
| boundaries |
spcname
-------------+------------+---------------
p1_0
| {1}
| startend_tbs2
p1_1
| {201}
| startend_tbs2
p1_2
| {401}
| startend_tbs2
p1_3
| {601}
| startend_tbs2
p1_4
| {801}
| startend_tbs2
p1_5
| {1000}
| startend_tbs2
p2
| {2000}
| startend_tbs1
p3
| {2500}
| startend_tbs3
p4
| {3000}
| startend_tbs1
p5_1
| {4000}
| startend_tbs4
p5_2
| {5000}
| startend_tbs4
startend_pt |
| startend_tbs1
(12 rows)
-- 导入数据,查看分区数据量
INSERT INTO tpcds.startend_pt VALUES (GENERATE_SERIES(0, 4999), GENERATE_SERIES(0, 4999));
SELECT COUNT(*) FROM tpcds.startend_pt PARTITION FOR (0);
count
-------
1
(1 row)
SELECT COUNT(*) FROM tpcds.startend_pt PARTITION (p3);
count
-------
500
(1 row)
-- 增加分区: [5000, 5300), [5300, 5600), [5600, 5900), [5900, 6000)
ALTER TABLE tpcds.startend_pt ADD PARTITION p6 START(5000) END(6000) EVERY(300) TABLESPACE
startend_tbs4;
-- 增加MAXVALUE分区: p7
ALTER TABLE tpcds.startend_pt ADD PARTITION p7 END(MAXVALUE);
-- 重命名分区p7为p8
ALTER TABLE tpcds.startend_pt RENAME PARTITION p7 TO p8;
-- 删除分区p8
ALTER TABLE tpcds.startend_pt DROP PARTITION p8;
-- 重命名5950所在的分区为:p71
ALTER TABLE tpcds.startend_pt RENAME PARTITION FOR(5950) TO p71;
-- 分裂4500所在的分区[4000, 5000)
ALTER TABLE tpcds.startend_pt SPLIT PARTITION FOR(4500) INTO(PARTITION q1 START(4000)
END(5000) EVERY(250) TABLESPACE startend_tbs3);
-- 修改分区p2的表空间为startend_tbs4
ALTER TABLE tpcds.startend_pt MOVE PARTITION p2 TABLESPACE startend_tbs4;
-- 查看分区情形
SELECT relname, boundaries, spcname FROM pg_partition p JOIN pg_tablespace t ON
p.reltablespace=t.oid and p.parentid='tpcds.startend_pt'::regclass ORDER BY 1;
relname
| boundaries |
spcname
-------------+------------+---------------
p1_0
| {1}
| startend_tbs2
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
875GaussDB 200
开发者指南
16 SQL 参考
p1_1
p1_2
p1_3
p1_4
p1_5
p2
p3
p4
p5_1
p6_1
p6_2
p6_3
p71
q1_1
q1_2
q1_3
q1_4
startend_pt
(19 rows)
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
{201}
{401}
{601}
{801}
{1000}
{2000}
{2500}
{3000}
{4000}
{5300}
{5600}
{5900}
{6000}
{4250}
{4500}
{4750}
{5000}
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
startend_tbs2
startend_tbs2
startend_tbs2
startend_tbs2
startend_tbs2
startend_tbs4
startend_tbs3
startend_tbs1
startend_tbs4
startend_tbs4
startend_tbs4
startend_tbs4
startend_tbs4
startend_tbs3
startend_tbs3
startend_tbs3
startend_tbs3
startend_tbs1
-- 删除表和表空间
DROP SCHEMA tpcds CASCADE;
DROP TABLESPACE startend_tbs1;
DROP TABLESPACE startend_tbs2;
DROP TABLESPACE startend_tbs3;
DROP TABLESPACE startend_tbs4;
相关链接
16.14.25 ALTER TABLE PARTITION,16.14.98 DROP TABLE
16.14.68 CREATE TABLESPACE
功能描述
在数据库中创建一个新的表空间。
注意事项
l 只有系统管理员可以创建表空间。
l 不允许在一个事务块内部执行CREATE TABLESPACE。
l 执行CREATE TABLESPACE失败,如果内部创建目录(文件)操作成功了就会产
生残留的目录(文件),重新创建时需要用户手动清理表空间指定的目录下残留
的内容。如果在创建过程中涉及到数据目录下的表空间软连接残留,需要先将软
连接的残留文件删除,再重新执行OM相关操作。
l CREATE TABLESPACE不支持两阶段事务,如果部分节点执行失败,不支持回
滚。
l 创建表空间前的准备工作参考下述参数说明。
语法格式
CREATE TABLESPACE tablespace_name
[ OWNER user_name ] RELATIVE LOCATION 'directory' [ MAXSIZE 'space_size' ]
[with_option_clause];
其中普通表空间的with_option_clause为:
WITH ( {filesystem= { 'general'| "general" | general} |
random_page_cost = { 'value ' | value } |
seq_page_cost = { 'value ' | value }}[,...])
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
876GaussDB 200
开发者指南
16 SQL 参考
其中HDFS表空间的with_option_clause为:
WITH ( filesystem= { 'systemtype '| "systemtype" | systemtype }
[ { , address = 'ip:port [ {, ip:port }]' ],
cfgpath = 'path' ,storepath = 'rootpath'
[{, random_page_cost = { 'value'| value }}]
[{,seq_page_cost = { 'value'| value }}])
参数说明
l
tablespace_name
要创建的表空间名称。
表空间名字不能和数据集群中的其他表空间重名,且名字不能以"pg"开头,这样
的名字留给系统表空间使用。
取值范围:字符串,要符合标识符的命名规范。
l
OWNER user_name
指定该表空间的所有者。缺省时,新表空间的所有者是当前用户。
只有系统管理员可以创建表空间,但是可以通过OWNER子句把表空间的所有权赋
给其他非系统管理员。
取值范围:字符串,已存在的用户。
l
RELATIVE
使用相对路径,LOCATION目录是相对于各个CN/DN数据目录下的。
目录层次:CN和DN的数据目录/pg_location/相对路径
相对路径最多指定两层。
l
LOCATION directory
用于表空间的目录,对于目录有如下要求:
– GaussDB 200系统用户必须对该目录拥有读写权限,并且目录为空。如果该目
录不存在,将由系统自动创建。
– 目录必须是绝对路径,目录中不得含有特殊字符(如$,> 等)。
– 目录不允许指定在数据库数据目录下。
– 目录需为本地路径。
取值范围:字符串,有效的目录。
l
MAXSIZE 'space_size'
指定表空间在单个DN上的最大值。
取值范围:字符串格式为正整数+单位,单位当前支持K/M/G/T/P。解析后的数值
以K为单位,且范围不能够超过64比特表示的有符号整数,即
1KB~9007199254740991KB。
l
filesystem
指定表空间是否为HDFS表空间。
取值范围:
– general:创建普通表空间。
– hdfs:创建HDFS表空间。
默认值:general。
说明
只有指定了filesystem,才可以在“pg_tablespace”的“spcoptions”字段中显示相关信息。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
877GaussDB 200
开发者指南
16 SQL 参考
l
random_page_cost
指定随机读取page的开销。
取值范围:0~1.79769e+308。
默认值:使用GUC参数random_page_cost的值。
l
seq_page_cost
指定顺序读取page的开销。
取值范围:0~1.79769e+308。
默认值:使用GUC参数seq_page_cost的值。
l
address
指定HDFS集群NameNode主备节点的IP和port。
取值范围:最多两个NameNode节点的IP、port组成的字符串。
取值规则:只支持点分十进制格式的IPv4格式,且address字符串中不能出现空
格,多组address以逗号作为分隔符。IP和port之间使用“:”来区分,IP、port组推
荐设置两组,分别对应HDFS NameNode主备节点的address。
说明
l 若不指定该参数,则HDFS的address的信息从HDFS集群配置文件中获取。若指定了
address,则直接使用指定的address信息。
l 创建HDFS表空间时,若address参数中IP格式正确,但不是有效的IP或者HDFS集群配置
文件中配置错误的IP或者hostname,连接HDFS时会尝试重连,直到超时。超时时间的
默认值为1分钟。因此,若用户配置无效地址时,系统会反复尝试连接HDFS服务器,期
间无法中断,直到超时退出。
l IP、port组不能超过两个。
l 若创建的是普通表空间,则不允许指定。
l
cfgpath
指定HDFS集群配置文件路径。
取值范围:字符串。
取值规则:必须为一个绝对路径,且为HDFS集群有效的配置文件路径。
说明
l 若创建HDFS表空间,则必须指定,否则不指定。
l 连接安全模式HDFS时,该路径必须是一个合法地址,且必须包含有效的配置文件。
l 连接非安全模式HDFS时,如果指定了address,则不会对该路径地址及其中内容进行校
验;如果没有指定address,该路径必须是一个合法地址,且必须包含有效的配置文件。
l
storepath
指定HDFS上数据存储路径。
取值范围:字符串。
取值规则:
– 目录必须为绝对路径。
– 路径可以存在也可不存在,但是必须为有效的HDFS路径。
– 必须为数据库用户可访问或者有权限创建的目录。
说明
若创建HDFS表空间,则必须指定,否则不指定。
示例
--创建表空间。
CREATE TABLESPACE ds_location1 RELATIVE LOCATION 'hdfs_tablespace/hdfs_tablespace_1' ;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
878GaussDB 200
开发者指南
16 SQL 参考
--创建用户joe。
CREATE ROLE joe IDENTIFIED BY 'Bigdata123@';
--创建用户jay。
CREATE ROLE jay IDENTIFIED BY 'Bigdata123@';
--创建表空间,且所有者指定为用户joe。
CREATE TABLESPACE ds_location2 OWNER joe RELATIVE LOCATION 'hdfs_tablespace/hdfs_tablespace_1' ;
--把表空间ds_location1重命名为ds_location3。
ALTER TABLESPACE ds_location1 RENAME TO ds_location3;
--改变表空间ds_location2的所有者。
ALTER TABLESPACE ds_location2 OWNER TO jay;
--删除表空间。
DROP TABLESPACE ds_location2;
DROP TABLESPACE ds_location3;
DROP TABLESPACE ds_location4;
--删除用户。
DROP ROLE joe;
DROP ROLE jay;
相关链接
16.14.47 CREATE DATABASE,16.14.65 CREATE TABLE,16.14.55 CREATE
INDEX,16.14.99 DROP TABLESPACE,16.14.26 ALTER TABLESPACE
16.14.69 CREATE TEXT SEARCH CONFIGURATION
功能描述
创建新的文本搜索配置。一个文本搜索配置声明一个能将一个字符串划分成符号的文
本搜索解析器,加上可以用于确定搜索对哪些标记感兴趣的字典。
注意事项
l 若仅声明分析器,那么新的文本搜索配置初始没有从符号类型到词典的映射, 因
此会忽略所有的单词。后面必须调用ALTER TEXT SEARCH CONFIGURATION命
令创建映射使配置生效。如果声明了COPY选项,那么会自动拷贝指定的文本搜索
配置的解析器、映射、配置选项等信息。
l 若模式名称已给出,那么文本搜索配置会在声明的模式中创建。否则会在当前模
式创建。
l 定义文本搜索配置的用户成为其所有者。
l PARSER和COPY选项是互相排斥的,因为当一个现有配置被复制,其分析器配置
也被复制了。
l 若仅声明分析器,那么新的文本搜索配置初始没有从符号类型到词典的映射, 因
此会忽略所有的单词。
语法格式
CREATE TEXT SEARCH CONFIGURATION name
( PARSER = parser_name | COPY = source_config )
[ WITH ( {configuration_option = value} [, ...] )];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
879GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
name
要创建的文本搜索配置的名称。该名称可以有模式修饰。
l
parser_name
用于该配置的文本搜索分析器的名称。
l
source_config
要复制的现有文本搜索配置的名称。
l
configuration_option
文本搜索配置的配置参数,主要是针对parser_name执行的解析器,或者
source_config隐含的解析器而言的。
取值范围:目前共支持default、ngram、zhparser三种类型的解析器,其中default类
型的解析器没有对应的configuration_option,ngram、zhparser类型解析器对应的
configuration_option如表16-58所示。
表 16-58 ngram、zhparser 类型解析器对应的配置参数
解析
器 配置参数 参数描述 取值范围
ngram gram_size 分词长度。 正整数,1~4
默认值:2
punctuatio
n_ignore
是否忽略标点符号。
l true(默认值):忽略标
点符号。
l false:不忽略标点符
号。
zhpars
er
l true:忽略图形化字符。
grapsymbo
l_ignore 是否忽略图形化字符。 punctuatio
n_ignore 分词结果是否忽略所有的标
点等特殊符号(不会忽略\r
和\n)。 l true(默认值):忽略所
有的标点等特殊符号。
是否将闲散文字自动以二字
分词法聚合。 l true:将闲散文字自动以
二字分词法聚合。
seg_with_
duality
l false(默认值):不忽
略图形化字符。
l false:不忽略所有的标
点等特殊符号。
l false(默认值):不将
闲散文字自动以二字分
词法聚合。
multi_shor
t
分词执行时是否执行针对长
词复合切分。
l true(默认值):执行针
对长词复合切分。
l false:不执行针对长词
复合切分。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
880GaussDB 200
开发者指南
16 SQL 参考
解析
器
配置参数 参数描述 取值范围
multi_dual
ity 设定是否将长词内的文字自
动以二字分词法聚合。 l true:将长词内的文字自
动以二字分词法聚合。
l false(默认值):不将
长词内的文字自动以二
字分词法聚合。
multi_zma
in
是否将重要单字单独显示。
l true:将重要单字单独显
示。
l false(默认值):不将
重要单字单独显示。
multi_zall
是否将全部单字单独显示。
l true:将全部单字单独显
示。
l false(默认值):不将
全部单字单独显示。
示例
--创建文本搜索配置。
CREATE TEXT SEARCH CONFIGURATION ngram2 (parser=ngram) WITH (gram_size = 2, grapsymbol_ignore =
false);
--创建文本搜索配置。
CREATE TEXT SEARCH CONFIGURATION ngram3 (copy=ngram2) WITH (gram_size = 2, grapsymbol_ignore =
false);
--添加类型映射。
ALTER TEXT SEARCH CONFIGURATION ngram2 ADD MAPPING FOR multisymbol WITH simple;
--创建用户joe。
CREATE USER joe IDENTIFIED BY 'Bigdata123@';
--修改文本搜索配置的所有者。
ALTER TEXT SEARCH CONFIGURATION ngram2 OWNER TO joe;
--修改文本搜索配置的schema。
ALTER TEXT SEARCH CONFIGURATION ngram2 SET SCHEMA joe;
--重命名文本搜索配置。
ALTER TEXT SEARCH CONFIGURATION joe.ngram2 RENAME TO ngram_2;
--删除类型映射。
ALTER TEXT SEARCH CONFIGURATION joe.ngram_2 DROP MAPPING IF EXISTS FOR multisymbol;
--删除文本搜索配置。
DROP TEXT SEARCH CONFIGURATION joe.ngram_2;
DROP TEXT SEARCH CONFIGURATION ngram3;
--删除Schema及用户joe。
DROP SCHEMA IF EXISTS joe CASCADE;
DROP ROLE IF EXISTS joe;
相关链接
16.14.27 ALTER TEXT SEARCH CONFIGURATION, 16.14.100 DROP TEXT
SEARCH CONFIGURATION
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
881GaussDB 200
开发者指南
16 SQL 参考
16.14.70 CREATE TEXT SEARCH DICTIONARY
功能描述
创建一个新的全文检索词典。词典是一种指定在全文检索时识别特定词并处理的方
法。
词典的创建依赖于预定义模板(在系统表19.2.62 PG_TS_TEMPLATE中定义),支持
创建五种类型的词典,分别是Simple、Ispell、Synonym、Thesaurus、以及Snowball,每
种类型的词典可以完成不同的任务。
注意事项
l 具有SYSADMIN权限的用户可以执行创建词典操作,创建该词典的用户自动成为
其所有者。
l 临时模式(pg_temp)下不允许创建词典。
l 创建或修改词典之后,任何对于用户自定义的词典定义文件的修改,将不会影响
到数据库中的词典。如果需要在数据库中使用这些修改,需使用ALTER语句更新
对应词典的定义文件。
语法格式
CREATE TEXT SEARCH DICTIONARY name (
TEMPLATE = template
[, option = value [, ... ]]
);
参数说明
l
name
要创建的词典的名称(可指定模式名,否则在当前模式下创建)。
取值范围:符合标识符命名规范的字符串,且最大长度不超过63个字符。
l
template
模板名。
取值范围:系统表19.2.62 PG_TS_TEMPLATE中定义的模板:Simple/Synonym/
Thesaurus/Ispell/Snowball。
l
option
参数名。与template值对应,不同的词典模板具有不同的参数列表,且与指定顺序
无关。
–
Simple词典对应的option
n
STOPWORDS
停用词表文件名,默认后缀名为stop。停用词文件格式为一组word列
表,每行定义一个停用词。词典处理时,文件中的空行和空格会被忽
略,并将stopword词组转换为小写形式。
n
ACCEPT
是否将非停用词设置为已识别。默认值为true。
当Simple词典设置参数ACCEPT=true时,将不会传递任何token给后继词
典,此时建议将其放置在词典列表的最后。反之,当ACCEPT=false时,
建议将该Simple词典放置在列表中的至少一个词典之前。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
882GaussDB 200
开发者指南
16 SQL 参考
n
FILEPATH
词典文件所在目录。目录可以指定为本地目录和OBS目录。其中,本地
目录格式为"file://absolute_path",OBS目录格式为"obs://bucket_name/path
accesskey=ak secretkey=sk region=rg"。默认值为预定义词典文件所在目
录。FILEPATH参数必须和STOPWORDS参数同时指定,不允许单独指
定。
–
Synonym词典对应的option
n
SYNONYM
同义词词典的定义文件名,默认后缀名为syn。
文件格式为一组同义词列表,每行格式为"token synonym",即token和其
对应的synonym,中间以空格相连。
n
CASESENSITIVE
设置是否大小写敏感,默认值为false,此时词典文件中的token和
synonym均会转为小写形式处理。如果设置为true,则不会进行小写转
换。
n
FILEPATH
同义词词典文件所在目录。目录可以指定为本地目录和OBS目录两种形
式。其中,本地目录格式为"file://absolute_path",OBS目录格式为"obs://
bucket_name/path accesskey=ak secretkey=sk region=rg"。默认值为预定义
词典文件所在目录。
–
Thesaurus词典对应的option
n
DICTFILE
词典定义文件名,默认后缀名为ths。
文件格式为一组同义词列表,每行格式为"sample words : indexed
words",中间冒号(:)作为短语和其替换词间的分隔符。TZ词典处理
时,如果有多个匹配的sample words,将选择最长匹配输出。
n
DICTIONARY
用于词规范化的子词典名,必须且仅能定义一个。该词典必须是已经存
在的,在检查短语匹配之前使用,用于识别和规范输入文本。
如果子词典无法识别输入词,将会报错。此时,需要移除该词或者更新
子词典使其识别。此外,可在indexed words的开头放上一个星号(*)来
跳过在其上应用子词典,但是所有sample words必须可以被子词典识别。
如果词典文件定义的sample words中,含有子词典中定义的停用词,需要
用问号(?)替代停用词。假设a和the是子词典中所定义的停用词,如
下:
? one ? two : swsw
上述同义词组定义会匹配"a one the two"以及"the one a two",这两个短语
均会被swsw替代输出。
n
FILEPATH
词典定义文件所在目录。目录可以指定为本地目录和OBS目录两种形
式。其中,本地目录格式为"file://absolute_path",OBS目录格式为"obs://
bucket_name/path accesskey=ak secretkey=sk region=rg"。默认值为预定义
词典文件所在目录。
–
Ispell词典
n
DICTFILE
词典定义文件名,默认后缀名为dict。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
883GaussDB 200
开发者指南
16 SQL 参考
n
AFFFILE
词缀文件名,默认后缀名为affix。
n
STOPWORDS
停用词文件名,默认后缀名为stop,文件格式要求与Simple类型词典的停
用词文件相同。
n
FILEPATH
词典文件所在目录。可以指定为本地目录和OBS目录两种形式。其中,
本地目录格式为"file://absolute_path",OBS目录格式为"obs://
bucket_name/path accesskey=ak secretkey=sk region=rg"。默认值为预定义
词典文件所在目录。
–
Snowball词典
n
LANGUAGE
语言名,标识使用哪种语言的词干分析算法。算法按照对应语言中的拼
写规则,缩减输入词的常见变体形式为一个基础词或词干。
n
STOPWORDS
停用词表文件名,默认后缀名为stop,文件格式要求与Simple类型词典的
停用词文件相同。
n
FILEPATH
词典定义文件所在目录。可以指定为本地目录或者OBS目录。其中,本
地目录格式为"file://absolute_path",OBS目录格式为"obs://bucket_name/
path accesskey=ak secretkey=sk region=rg"。默认值为预定义词典文件所在
目录。FILEPATH参数必须和STOPWORDS参数同时指定,不允许单独指
定。
说明
词典定义文件的文件名仅支持小写字母、数据、下划线混合。
l
value
参数值。如果不是简单的标识符或数字,则参数值必须加单引号(标示符和数字
同样可以加上单引号)。
示例
请参见16.8.7 配置示例一节的示例。
相关链接
16.14.28 ALTER TEXT SEARCH DICTIONARY,16.14.70 CREATE TEXT SEARCH
DICTIONARY
16.14.71 CREATE TRIGGER
功能描述
创建一个触发器。 触发器将与指定的表或视图关联,并在特定条件下执行指定的函
数。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
884GaussDB 200
开发者指南
16 SQL 参考
注意事项
l 当前仅支持在普通行存表上创建触发器,不支持在列存表、临时表、unlogged表等
类型表上创建触发器。
l 如果为同一事件定义了多个相同类型的触发器,则按触发器的名称字母顺序触发
它们。
l 触发器常用于多表间数据关联同步场景,对SQL执行性能影响较大,不建议在大
数据量同步及对性能要求高的场景中使用。
l 当触发器满足如下条件时,触发语句能和触发器一起下推到DN执行并提升触发器
执行性能:
– 开关enable_trigger_shipping和enable_fast_query_shipping开启(默认均开
启)。
– 源表触发器使用的触发器函数为plpgsql类型(推荐类型)。
– 源表与触发表分布键的类型、数量完全相同,均为行存表,且所属相同的
nodegroup。
– 原INSERT/UPDATE/DELETE语句条件中包含所有分布键与NEW/OLD等值比
较表达式。
– 原INSERT/UPDATE/DELETE语句在没有触发器的情况下原本就能query
shipping。
– 源表上只有INSERT/UPDATE/DELETE AFTER/BEFORE FOR EACH ROW六
类触发器,且所有触发器都可下推。
语法格式
CREATE [ CONSTRAINT ] TRIGGER trigger_name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }
ON table_name
[ FROM referenced_table_name ]
{ NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }
[ FOR [ EACH ] { ROW | STATEMENT } ]
[ WHEN ( condition ) ]
EXECUTE PROCEDURE function_name ( arguments );
其中event包含以下几种:
INSERT
UPDATE [ OF column_name [, ... ] ]
DELETE
TRUNCATE
参数说明
l
CONSTRAINT
可选项,指定此参数将创建约束触发器,即触发器作为约束来使用。除了可以使
用SET CONSTRAINTS调整触发器触发的时间之外,这与常规触发器相同。 约束
触发器必须是AFTER ROW触发器。
l
trigger_name
触发器名称,该名称不能限定模式,因为触发器自动继承其所在表的模式,且同
一个表的触发器不能重名。 对于约束触发器,使用16.14.131 SET
CONSTRAINTS修改触发器行为时也使用此名称。
取值范围:符合标识符命名规范的字符串,且最大长度不超过63个字符。
l
BEFORE
触发器函数是在触发事件发生前执行。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
885GaussDB 200
开发者指南
16 SQL 参考
l
AFTER
触发器函数是在触发事件发生后执行,约束触发器只能指定为AFTER。
l
INSTEAD OF
触发器函数直接替代触发事件。
l
event
启动触发器的事件,取值范围包括:INSERT、UPDATE、DELETE或
TRUNCATE,也可以通过OR同时指定多个触发事件。
对于UPDATE事件类型,可以使用下面语法指定列:
UPDATE OF column_name1 [, column_name2 ... ]
表示只有这些列作为UPDATE语句的目标列时,才会启动触发器,但是INSTEAD
OF UPDATE类型不支持指定列信息。
l
table_name
需要创建触发器的表名称。
取值范围:数据库中已经存在的表名称。
l
referenced_table_name
约束引用的另一个表的名称。 只能为约束触发器指定,常见于外键约束。由于当
前不支持外键,因此不建议使用。
取值范围:数据库中已经存在的表名称。
l
DEFERRABLE | NOT DEFERRABLE
约束触发器的启动时机,仅作用于约束触发器。这两个关键字设置该约束是否可
推迟。
详细介绍请参见16.14.65 CREATE TABLE。
l
INITIALLY IMMEDIATE | INITIALLY DEFERRED
如果约束是可推迟的,则这个子句声明检查约束的缺省时间,仅作用于约束触发
器。
详细介绍请参见16.14.65 CREATE TABLE。
l
FOR EACH ROW | FOR EACH STATEMENT
触发器的触发频率。
– FOR EACH ROW是指该触发器是受触发事件影响的每一行触发一次。
– FOR EACH STATEMENT是指该触发器是每个SQL语句只触发一次。
未指定时默认值为FOR EACH STATEMENT。约束触发器只能指定为FOR EACH
ROW。
l
condition
决定是否实际执行触发器函数的条件表达式。当指定WHEN时,只有在条件返回
true时才会调用该函数。
在FOR EACH ROW触发器中,WHEN条件可以通过分别写入OLD.column_name或
NEW.column_name来引用旧行或新行值的列。 当然,INSERT触发器不能引用
OLD和DELETE触发器不能引用NEW。
INSTEAD OF触发器不支持WHEN条件。
WHEN表达式不能包含子查询。
对于约束触发器,WHEN条件的评估不会延迟,而是在执行更新操作后立即发
生。 如果条件返回值不为true,则触发器不会排队等待延迟执行。
l
function_name
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
886GaussDB 200
开发者指南
16 SQL 参考
用户定义的函数,必须声明为不带参数并返回类型为触发器,在触发器触发时执
行。
l
arguments
执行触发器时要提供给函数的可选的以逗号分隔的参数列表。参数是文字字符串
常量,简单的名称和数字常量也可以写在这里,但它们都将被转换为字符串。 请
检查触发器函数的实现语言的描述,以了解如何在函数内访问这些参数。
说明
关于触发器种类:
l INSTEAD OF的触发器必须标记为FOR EACH ROW,并且只能在视图上定义。
l BEFORE和AFTER触发器作用在视图上时,只能标记为FOR EACH STATEMENT。
l TRUNCATE类型触发器仅限FOR EACH STATEMENT。
表 16-59 表和视图上支持的触发器种类:
触发时机 触发事件 行级 语句级
BEFORE INSERT/UPDATE/
DELETE 表 表和视图
TRUNCATE 不支持 表
INSERT/UPDATE/
DELETE 表 表和视图
TRUNCATE 不支持 表
INSERT/UPDATE/
DELETE 视图 不支持
TRUNCATE 不支持 不支持
AFTER
INSTEAD
OF
表 16-60 PLPGSQL 类型触发器函数特殊变量:
文档版本 01 (2019-08-01)
变量名 变量含义
NEW INSERT及UPDATE操作涉及tuple信息
中的新值,对DELETE为空。
OLD UPDATE及DELETE操作涉及tuple信息
中的旧值,对INSERT为空。
TG_NAME 触发器名称。
TG_WHEN 触发器触发时机(BEFORE/AFTER/
INSTEAD OF)。
TG_LEVEL 触发频率(ROW/STATEMENT)。
TG_OP 触发操作(INSERT/UPDATE/
DELETE/TRUNCATE)。
TG_RELID 触发器所在表OID。
版权所有 © 华为技术有限公司
887GaussDB 200
开发者指南
16 SQL 参考
变量名 变量含义
TG_RELNAME 触发器所在表名(已废弃,现用
TG_TABLE_NAME替代)。
TG_TABLE_NAME 触发器所在表名。
TG_TABLE_SCHEMA 触发器所在表的SCHEMA信息。
TG_NARGS 触发器函数参数个数。
TG_ARGV[] 触发器函数参数列表。
示例
--创建源表及触发表
CREATE TABLE test_trigger_src_tbl(id1 INT, id2 INT, id3 INT);
CREATE TABLE test_trigger_des_tbl(id1 INT, id2 INT, id3 INT);
--创建触发器函数
CREATE OR REPLACE FUNCTION tri_insert_func() RETURNS TRIGGER AS
$$
DECLARE
BEGIN
INSERT INTO test_trigger_des_tbl VALUES(NEW.id1, NEW.id2, NEW.id3);
RETURN NEW;
END
$$ LANGUAGE PLPGSQL;
CREATE OR REPLACE FUNCTION tri_update_func() RETURNS TRIGGER AS
$$
DECLARE
BEGIN
UPDATE test_trigger_des_tbl SET id3 = NEW.id3 WHERE id1=OLD.id1;
RETURN OLD;
END
$$ LANGUAGE PLPGSQL;
CREATE OR REPLACE FUNCTION TRI_DELETE_FUNC() RETURNS TRIGGER AS
$$
DECLARE
BEGIN
DELETE FROM test_trigger_des_tbl WHERE id1=OLD.id1;
RETURN OLD;
END
$$ LANGUAGE PLPGSQL;
--创建INSERT触发器
CREATE TRIGGER insert_trigger
BEFORE INSERT ON test_trigger_src_tbl
FOR EACH ROW
EXECUTE PROCEDURE tri_insert_func();
--创建UPDATE触发器
CREATE TRIGGER update_trigger
AFTER UPDATE ON test_trigger_src_tbl
FOR EACH ROW
EXECUTE PROCEDURE tri_update_func();
--创建DELETE触发器
CREATE TRIGGER delete_trigger
BEFORE DELETE ON test_trigger_src_tbl
FOR EACH ROW
EXECUTE PROCEDURE tri_delete_func();
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
888GaussDB 200
开发者指南
16 SQL 参考
--执行INSERT触发事件并检查触发结果
INSERT INTO test_trigger_src_tbl VALUES(100,200,300);
SELECT * FROM test_trigger_src_tbl;
SELECT * FROM test_trigger_des_tbl; //查看触发操作是否生效。
--执行UPDATE触发事件并检查触发结果
UPDATE test_trigger_src_tbl SET id3=400 WHERE id1=100;
SELECT * FROM test_trigger_src_tbl;
SELECT * FROM test_trigger_des_tbl; //查看触发操作是否生效
--执行DELETE触发事件并检查触发结果
DELETE FROM test_trigger_src_tbl WHERE id1=100;
SELECT * FROM test_trigger_src_tbl;
SELECT * FROM test_trigger_des_tbl; //查看触发操作是否生效
--修改触发器
ALTER TRIGGER delete_trigger ON test_trigger_src_tbl RENAME TO delete_trigger_renamed;
--禁用insert_trigger触发器
ALTER TABLE test_trigger_src_tbl DISABLE TRIGGER insert_trigger;
--禁用当前表上所有触发器
ALTER TABLE test_trigger_src_tbl DISABLE TRIGGER ALL;
--删除触发器
DROP TRIGGER insert_trigger ON test_trigger_src_tbl;
DROP TRIGGER update_trigger ON test_trigger_src_tbl;
DROP TRIGGER delete_trigger_renamed ON test_trigger_src_tbl;
相关链接
16.14.29 ALTER TRIGGER,16.14.102 DROP TRIGGER,16.14.24 ALTER TABLE
16.14.72 CREATE TYPE
功能描述
在当前数据库中定义一种新的数据类型。定义数据类型的用户将成为该数据类型的拥
有者。类型只适用于行存表
有四种形式的CREATE TYPE,分别为:复合类型、基本类型、shell类型和枚举类型。
l
复合类型
复合类型由一个属性名和数据类型的列表指定。如果属性的数据类型是可排序
的,也可以指定该属性的排序规则。复合类型本质上和表的行类型相同,但是如
果只想定义一种类型,使用CREATE TYPE避免了创建一个实际的表。单独的复合
类型也是很有用的,例如可以作为函数的参数或者返回类型。
为了能够创建复合类型,必须拥有在其所有属性类型上的USAGE特权。
l
基本类型
用户可以自定义一种新的基本类型(标量类型)。通常来说这些函数必须是用C或
者另外一种低层语言所编写。
l
shell类型
shell类型是一种用于后面要定义的类型的占位符,通过发出一个不带除类型名之
外其他参数的CREATE TYPE命令可以创建这种类型。在创建基本类型时,需要
shell类型作为一种向前引用。
l
枚举类型
由若干个标签构成的列表,每一个标签值都是一个非空字符串,且字符串长度必
须不超过64个字节。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
889GaussDB 200
开发者指南
16 SQL 参考
注意事项
如果给定一个模式名,那么该类型将被创建在指定的模式中。否则它会被创建在当前
模式中。类型名称必须与同一个模式中任何现有的类型或者域相区别(因为表具有相
关的数据类型,类型名称也必须与同一个模式中任何现有表的名字不同)。
语法格式
CREATE TYPE name AS
( [ attribute_name data_type [ COLLATE collation ] [, ... ] ] )
CREATE TYPE name (
INPUT = input_function,
OUTPUT = output_function
[ , RECEIVE = receive_function ]
[ , SEND = send_function ]
[ , TYPMOD_IN =
type_modifier_input_function ]
[ , TYPMOD_OUT =
type_modifier_output_function ]
[ , ANALYZE = analyze_function ]
[ , INTERNALLENGTH = { internallength |
VARIABLE } ]
[ , PASSEDBYVALUE ]
[ , ALIGNMENT = alignment ]
[ , STORAGE = storage ]
[ , LIKE = like_type ]
[ , CATEGORY = category ]
[ , PREFERRED = preferred ]
[ , DEFAULT = default ]
[ , ELEMENT = element ]
[ , DELIMITER = delimiter ]
[ , COLLATABLE = collatable ]
)
CREATE TYPE name
CREATE TYPE name AS ENUM
( [ 'label' [, ... ] ] )
参数说明
复合类型
l
name
要创建的类型的名称(可以被模式限定)。
l
attribute_name
复合类型的一个属性(列)的名称。
l
data_type
要成为复合类型的一个列的现有数据类型的名称。
l
collation
要关联到复合类型的一列的现有排序规则的名称。
基本类型
自定义基本类型时,参数可以以任意顺序出现,input_function和output_function为必选
参数,其它为可选参数。
l
input_function
将数据从类型的外部文本形式转换为内部形式的函数名。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
890GaussDB 200
开发者指南
16 SQL 参考
输入函数可以被声明为有一个cstring类型的参数,或者有三个类型分别为cstring、
oid、integer的参数。
– cstring参数是以C字符串存在的输入文本。
– oid参数是该类型自身的OID(对于数组类型则是其元素类型的OID)。
– integer参数是目标列的typmod(如果知道,不知道则将传递 -1)。
输入函数必须返回一个该数据类型本身的值。通常,一个输入函数应该被声明为
STRICT。 如果不是这样,在读到一个NULL输入值时,调用输入函数时第一个参
数会是NULL。在这种情况下,该函数必须仍然返回NULL,除非调用函数发生了
错误(这种情况主要是想支持域输入函数,域输入函数可能需要拒绝NULL输
入)。
说明
输入和输出函数能被声明为具有新类型的结果或参数是因为:必须在创建新类型之前创建
这两个函数。而新类型应该首先被定义为一种shell type,它是一种占位符类型,除了名称
和拥有者之外它没有其他属性。这可以通过不带额外参数的命令CREATE TYPE name做
到。然后用C写的I/O函数可以被定义为引用这种shell type。最后,用带有完整定义的
CREATE TYPE把该shell type替换为一个完全的、合法的类型定义,之后新类型就可以正常
使用了。
l
output_function
将数据从类型的内部形式转换为外部文本形式的函数名。
输出函数必须被声明为有一个新数据类型的参数。输出函数必须返回类型cstring。
对于NULL值不会调用输出函数。
l
receive_function
可选参数。将数据从类型的外部二进制形式转换成内部形式的函数名。
如果没有该函数,该类型不能参与到二进制输入中。二进制表达转换成内部形式
代价更低,然而却更容易移植(例如,标准的整数数据类型使用网络字节序作为
外部二进制表达,而内部表达是机器本地的字节序)。receive_function应该执行足
够的检查以确保该值是有效的。
接收函数可以被声明为有一个internal类型的参数,或者有三个类型分别为
internal、oid、integer的参数。
– internal参数是一个指向StringInfo缓冲区的指针,其中保存着接收到的字节
串。
– oid和integer参数和文本输入函数的相同。
接收函数必须返回一个该数据类型本身的值。通常,一个接收函数应该被声明为
STRICT。如果不是这样,在读到一个NULL输入值时调用接收函数时第一个参数
会是NULL。在这种情况下,该函数必须仍然返回NULL,除非接收函数发生了错
误(这种情况主要是想支持域接收函数,域接收函数可能需要拒绝NULL输入)。
l
send_function
可选参数。将数据从类型的内部形式转换为外部二进制形式的函数名。
如果没有该函数,该类型将不能参与到二进制输出中。发送函数必须被声明为有
一个新数据类型的参数。发送函数必须返回类型bytea。对于NULL值不会调用发
送函数。
l
type_modifier_input_function
可选参数。将类型的修饰符数组转换为内部形式的函数名。
l
type_modifier_output_function
可选参数。将类型的修饰符的内部形式转换为外部文本形式的函数名。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
891GaussDB 200
开发者指南
16 SQL 参考
说明
如果该类型支持修饰符(附加在类型声明上的可选约束,例如,char(5)或numeric(30,2)),
则需要可选的type_modifier_input_function以及type_modifier_output_function。 GaussDB 200
允许用户定义的类型有一个或者多个简单常量或者标识符作为修饰符。不过,为了存储在
系统目录中,该信息必须能被打包到一个非负整数值中。所声明的修饰符会被以cstring数
组的形式传递给type_modifier_input_function。 type_modifier_input_function必须检查该值的
合法性(如果值错误就抛出一个错误),如果值正确,要返回一个非负integer值,该值将
被存储在“typmod”列中。如果类型没有 type_modifier_input_function则类型修饰符将被拒
绝。type_modifier_output_function把内部的整数typmod值转换回正确的形式用于用户显示。
type_modifier_output_function必须返回一个cstring值,该值就是追加到类型名称后的字符
串。例如,numeric的函数可能会返回(30,2)。如果默认的显示格式就是只把存储的typmod
整数值放在圆括号内,则允许省略 type_modifier_output_function。
l
analyze_function
可选参数。为该数据类型执行统计分析的函数名的可选参数。
默认情况下,如果该类型有一个默认的B-tree操作符类,ANALYZE将尝试用类型
的“equals”和“less-than”操作符来收集统计信息。这种行为对于非标量类型并
不合适,因此可以通过指定一个自定义分析函数来覆盖这种行为。分析函数必须
被声明为有一个类型为internal的参数,并且返回一个boolean结果。
l
internallength
可选参数。一个数字常量,用于指定新类型的内部表达的字节长度。默认为变
长。
虽然只有I/O函数和其他为该类型创建的函数才知道新类型的内部表达的细节, 但
是内部表达的一些属性必须被向GaussDB 200声明。其中最重要的是
internallength。基本数据类型可以是定长的(这种情况下internallength是一个正整
数)或者是变长的(把internallength设置为VARIABLE,在内部通过把typlen设置
为-1表示)。所有变长类型的内部表达都必须以一个4字节整数开始,
internallength定义了总长度。
l
PASSEDBYVALUE
可选参数。表示这种数据类型的值需要被传值而不是传引用。传值的类型必须是
定长的,并且它们的内部表达不能超过Datum类型(某些机器上是4字节,其他机
器上是8字节)的尺寸。
l
alignment
可选参数。该参数指定数据类型的存储对齐需求。如果被指定,必须是char、
int2、int4或者double。默认是int4。
允许的值等同于以1、2、4或8字节边界对齐。要注意变长类型的alignment参数必
须至少为4,因为它们需要包含一个int4作为它们的第一个组成部分。
l
storage
可选参数。该数据类型的存储策略。
如果被指定,必须是plain、external、extended或者main。 默认是plain。
– plain指定该类型的数据将总是被存储在线内并且不会被压缩。(对定长类型
只允许plain)
– extended 指定系统将首先尝试压缩一个长的数据值,并且将在数据仍然太长
的情况下把值移出主表行。
– external允许值被移出主表, 但是系统将不会尝试对它进行压缩。
– main允许压缩,但是不鼓励把值移出主表(如果没有其他办法让行的大小变
得合适,具有这种存储策略的数据项仍将被移出主表,但比起extended以及
external项来,这种存储策略的数据项会被优先考虑保留在主表中)。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
892GaussDB 200
开发者指南
16 SQL 参考
除plain之外所有的storage值都暗示该数据类型的函数能处理被TOAST过的
值。指定的值仅仅是决定一种可TOAST数据类型的列的默认TOAST存储策
略,用户可以使用ALTER TABLE SET STORAGE为列选取其他策略。
l
like_type
可选参数。与新类型具有相同表达的现有数据类型的名称。会从这个类型中复制
internallength、 passedbyvalue、 alignment以及storage的值( 除非在这个CREATE
TYPE命令的其他地方用显式说明覆盖)。
当新类型的低层实现是以一种现有的类型为参考时,用这种方式指定表达特别有
用。
l
category
可选参数。这种类型的分类码(一个ASCII 字符)。 默认是“用户定义类型”的
'U'。为了创建自定义分类, 也可以选择其他 ASCII字符。
l
preferred
可选参数。如果这种类型是其类型分类中的优先类型则为TRUE,否则为FALSE。
默认为假。在一个现有类型分类中创建一种新的优先类型要非常谨慎, 因为这可
能会导致很大的改变。
说明
category和preferred参数可以被用来帮助控制在混淆的情况下应用哪一种隐式造型。每一种
数据类型都属于一个用单个ASCII 字符命名的分类,并且每一种类型可以是其所属分类中
的“首选”。当有助于解决重载函数或操作符时,解析器将优先造型到首选类型(但是只
能从同类的其他类型造型)。对于没有隐式转换到或来自任意其他类型的类型,让这些设
置保持默认即可。不过,对于有隐式转换的相关类型的组,把它们都标记为属于同一个类
别并且选择一种或两种“最常用”的类型作为该类别的首选通常是很有用的。在把一种用
户定义的类型增加到一个现有的内建类别(例如,数字或者字符串类型)中时,category参
数特别有用。不过,也可以创建新的全部是用户定义类型的类别。对这样的类别,可选择
除大写字母之外的任何ASCII 字符。
l
default
可选参数。数据类型的默认值。如果被省略,默认值是空。
如果用户希望该数据类型的列被默认为某种非空值,可以指定一个默认值。默认
值可以用DEFAULT关键词指定(这样一个默认值可以被附加到一个特定列的显式
DEFAULT子句覆盖)。
l
element
可选参数。被创建的类型是一个数组,element指定了数组元素的类型。例如,要
定义一个4字节整数的数组(int4), 应指定ELEMENT = int4。
l
delimiter
可选参数。指定这种类型组成的数组中分隔值的定界符。
可以把delimiter设置为一个特定字符,默认的定界符是逗号(,)。注意定界符是
与数组元素类型相关的,而不是数组类型本身相关。
l
collatable
可选参数。如果这个类型的操作可以使用排序规则信息,则为TRUE。默认为
FALSE。
如果collatable为TRUE,这种类型的列定义和表达式可能通过使用COLLATE子句
携带有排序规则信息。在该类型上操作的函数的实现负责真正利用这些信息,仅
把类型标记为可排序的并不会让它们自动地去使用这类信息。
l
lable
可选参数。与枚举类型的一个值相关的文本标签,其值为长度不超过64个字符的
非空字符串。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
893GaussDB 200
开发者指南
16 SQL 参考
说明
在创建用户定义类型的时候, GaussDB 200会自动创建一个与之关联的数组类型,其名字由该元
素类型的名字前缀一个下划线组成。
示例
--创建一种复合类型,建表并插入数据以及查询:
CREATE TYPE compfoo AS (f1 int, f2 text);
CREATE TABLE t1_compfoo(a int, b compfoo);
CREATE TABLE t2_compfoo(a int, b compfoo);
INSERT INTO t1_compfoo values(1,(1,'demo'));
INSERT INTO t2_compfoo select * from t1_typ5;
SELECT (b).f1 FROM t1_compfoo;
SELECT * FROM t1_compfoo t1 join t2_compfoo t2 on (t1.b).f1=(t1.b).f1;
--重命名数据类型:
ALTER TYPE compfoo RENAME TO compfoo1;
--要改变一个用户定义类型compfoo1的所有者为usr1:
CREATE USER usr1 PASSWORD 'Bigdata123@';
ALTER TYPE compfoo1 OWNER TO usr1;
--把用户定义类型compfoo1的模式改变为usr1:
ALTER TYPE compfoo1 SET SCHEMA usr1;
给一个数据类型增加一个新的属性:
ALTER TYPE usr1.compfoo1 ADD ATTRIBUTE f3 int;
删除compfoo1类型:
DROP TYPE usr1.compfoo1 cascade;
删除相关表和用户:
DROP TABLE t1_compfoo;
DROP TABLE t2_compfoo;
DROP SCHEMA usr1;
DROP USER usr1;
--创建一个枚举类型
CREATE TYPE bugstatus AS ENUM ('create', 'modify', 'closed');
--添加一个标签值
ALTER TYPE bugstatus ADD VALUE IF NOT EXISTS 'regress' BEFORE 'closed';
--重命名一个标签值
ALTER TYPE bugstatus RENAME VALUE 'create' BEFORE 'new';
--编译.so文件,并创建shell类型:
CREATE TYPE complex;
--这个语句的作用是为要定义的类型创建了一个占位符,这样允许我们在定义其I/O函数时引用该类型。现在可以
定义 I/O函数,需要注意的是在创建函数时function必须声明为NOT FENCED模式:
CREATE FUNCTION
complex_in(cstring)
RETURNS complex
AS 'filename'
LANGUAGE C IMMUTABLE STRICT not fenced;
CREATE FUNCTION
complex_out(complex)
RETURNS cstring
AS 'filename'
LANGUAGE C IMMUTABLE STRICT not fenced;
CREATE FUNCTION
complex_recv(internal)
RETURNS complex
AS 'filename'
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
894GaussDB 200
开发者指南
16 SQL 参考
LANGUAGE C IMMUTABLE STRICT not fenced;
CREATE FUNCTION
complex_send(complex)
RETURNS bytea
AS 'filename'
LANGUAGE C IMMUTABLE STRICT not fenced;
--最后,提供该数据类型的完整定义:
CREATE TYPE complex (
internallength = 16,
input = complex_in,
output = complex_out,
receive = complex_recv,
send = complex_send,
alignment = double
);
input、output、receive及send函数对应的C函数定义如下:
--定义结构体Complex如下:
typedef struct Complex {
double
x;
double
y;
} Complex;
--定义input函数:
PG_FUNCTION_INFO_V1(complex_in);
Datum
complex_in(PG_FUNCTION_ARGS)
{
char
*str = PG_GETARG_CSTRING(0);
double
x,
y;
Complex
*result;
if (sscanf(str, " ( %lf , %lf )", &x, &y) != 2)
ereport(ERROR,
(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
errmsg("invalid input syntax for complex: \"%s\"",
str)));
result = (Complex *) palloc(sizeof(Complex));
result->x = x;
result->y = y;
PG_RETURN_POINTER(result);
}
--定义output函数:
PG_FUNCTION_INFO_V1(complex_out);
Datum
complex_out(PG_FUNCTION_ARGS)
{
Complex
*complex = (Complex *) PG_GETARG_POINTER(0);
char
*result;
result = (char *) palloc(100);
snprintf(result, 100, "(%g,%g)", complex->x, complex->y);
PG_RETURN_CSTRING(result);
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
895GaussDB 200
开发者指南
16 SQL 参考
}
--定义receive函数:
PG_FUNCTION_INFO_V1(complex_recv);
Datum
complex_recv(PG_FUNCTION_ARGS)
{
StringInfo buf = (StringInfo) PG_GETARG_POINTER(0);
Complex
*result;
result = (Complex *) palloc(sizeof(Complex));
result->x = pq_getmsgfloat8(buf);
result->y = pq_getmsgfloat8(buf);
PG_RETURN_POINTER(result);
}
--定义send函数:
PG_FUNCTION_INFO_V1(complex_send);
Datum
complex_send(PG_FUNCTION_ARGS)
{
Complex
*complex = (Complex *) PG_GETARG_POINTER(0);
StringInfoData buf;
pq_begintypsend(&buf);
pq_sendfloat8(&buf, complex->x);
pq_sendfloat8(&buf, complex->y);
PG_RETURN_BYTEA_P(pq_endtypsend(&buf));
}
相关链接
16.14.30 ALTER TYPE,16.14.103 DROP TYPE
16.14.73 CREATE USER
功能描述
创建一个用户。
注意事项
l 通过CREATE USER创建的用户,默认具有LOGIN权限;
l 通过CREATE USER创建用户的同时系统会在执行该命令的数据库中,为该用户创
建一个同名的SCHEMA;其他数据库中,则不自动创建同名的SCHEMA;用户可
使用CREATE SCHEMA命令,分别在其他数据库中,为该用户创建同名
SCHEMA。
l 系统管理员在普通用户同名schema下创建的对象,所有者为schema的同名用户
(非系统管理员)。
语法格式
CREATE USER user_name [ [ WITH ] option [ ... ] ] [ ENCRYPTED | UNENCRYPTED ] { PASSWORD |
IDENTIFIED BY } { 'password' | DISABLE };
其中option子句用于设置权限及属性等信息。
{SYSADMIN | NOSYSADMIN}
| {AUDITADMIN | NOAUDITADMIN}
| {CREATEDB | NOCREATEDB}
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
896GaussDB 200
开发者指南
16 SQL 参考
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
{USEFT | NOUSEFT}
{CREATEROLE | NOCREATEROLE}
{INHERIT | NOINHERIT}
{LOGIN | NOLOGIN}
{REPLICATION | NOREPLICATION}
{INDEPENDENT | NOINDEPENDENT}
{VCADMIN | NOVCADMIN}
CONNECTION LIMIT connlimit
VALID BEGIN 'timestamp'
VALID UNTIL 'timestamp'
RESOURCE POOL 'respool'
USER GROUP 'groupuser'
PERM SPACE 'spacelimit'
NODE GROUP logic_cluster_name
IN ROLE role_name [, ...]
IN GROUP role_name [, ...]
ROLE role_name [, ...]
ADMIN role_name [, ...]
USER role_name [, ...]
SYSID uid
DEFAULT TABLESPACE tablespace_name
PROFILE DEFAULT
PROFILE profile_name
PGUSER
参数说明
l
user_name
用户名称。
取值范围:字符串,要符合标识符的命名规范。且最大长度不超过63个字符。
l
password
登录密码。
密码规则如下:
– 密码默认不少于8个字符。
– 不能与用户名及用户名倒序相同。
– 至少包含大写字母(A-Z),小写字母(a-z),数字(0-9),非字母数字字
符(限定为~!@#$%^&*()-_=+\|[{}];:,<.>/?)四类字符中的三类字符。
– 创建用户时,应当使用双引号或单引号将用户密码括起来。
取值范围:字符串。
CREATE USER的其他参数值请参考CREATE ROLE参数说明。
示例
--创建用户jim,登录密码为Bigdata123@。
CREATE USER jim PASSWORD 'Bigdata123@';
--下面语句与上面的等价。
CREATE USER kim IDENTIFIED BY 'Bigdata123@';
--如果创建有“创建数据库”权限的用户,则需要加CREATEDB关键字。
CREATE USER dim CREATEDB PASSWORD 'Bigdata123@';
--将用户jim的登录密码由Bigdata123@修改为Abcd@123。
ALTER USER jim IDENTIFIED BY 'Abcd@123' REPLACE 'Bigdata123@';
--为用户jim追加CREATEROLE权限。
ALTER USER jim CREATEROLE;
--将enable_seqscan的值设置为on, 设置成功后,在下一会话中生效。
ALTER USER jim SET enable_seqscan TO on;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
897GaussDB 200
开发者指南
16 SQL 参考
--重置jim的enable_seqscan参数。
ALTER USER jim RESET enable_seqscan;
--锁定jim帐户。
ALTER USER jim ACCOUNT LOCK;
--删除用户。
DROP USER kim CASCADE;
DROP USER jim CASCADE;
DROP USER dim CASCADE;
相关链接
16.14.31 ALTER USER,16.14.61 CREATE ROLE,16.14.104 DROP USER
16.14.74 CREATE VIEW
功能描述
创建一个视图。视图与基本表不同,是一个虚拟的表。数据库中仅存放视图的定义,
而不存放视图对应的数据,这些数据仍存放在原来的基本表中。若基本表中的数据发
生变化,从视图中查询出的数据也随之改变。从这个意义上讲,视图就像一个窗口,
透过它可以看到数据库中用户感兴趣的数据及变化。
注意事项
无。
语法格式
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] VIEW view_name [ ( column_name [, ...] ) ]
[ WITH ( {view_option_name [= view_option_value]} [, ... ] ) ]
AS query;
说明
创建视图时使用WITH(security_barriers)可以创建一个相对安全的视图,避免攻击者利用低成本函
数的RAISE语句打印出隐藏的基表数据。
参数说明
l
OR REPLACE
如果视图已存在,则重新定义。
l
TEMP | TEMPORARY
创建临时视图。
l
view_name
要创建的视图名称。可以用模式修饰。
取值范围:字符串,符合标识符命名规范。
l
column_name
可选的名字列表,用作视图的字段名。如果没有给出,字段名取自查询中的字段
名。
取值范围:字符串,符合标识符命名规范。
l
view_option_name [= view_option_value]
该子句为视图指定一个可选的参数。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
898GaussDB 200
开发者指南
16 SQL 参考
目前view_option_name支持的参数仅有security_barrier,当VIEW试图提供行级安全
时,应使用该参数。
取值范围:boolean类型,TRUE、FALSE
l
query
为视图提供行和列的SELECT或VALUES语句。
示例
--创建字段spcname为pg_default组成的视图。
CREATE VIEW myView AS
SELECT * FROM pg_tablespace WHERE spcname = 'pg_default';
--查看视图。
SELECT * FROM myView ;
--删除视图myView。
DROP VIEW myView;
相关链接
16.14.32 ALTER VIEW,16.14.105 DROP VIEW
16.14.75 CREATE WORKLOAD GROUP
功能描述
创建一个负载组,关联已创建的资源池,指定资源池内可并发的作业数量。
注意事项
只要用户对当前数据库有CREATE权限,就可以创建负载组。
语法格式
CREATE WORKLOAD GROUP wg_name
[ USING RESOURCE POOL pool_name [ WITH ( ACT_STATEMENTS = counts) ] ];
参数说明
l
wg_name
负载组名称。
说明
负载组名称不能和当前数据库里其他负载组重名。
取值范围:字符串,要符合标识符的命名规范。
l
pool_name
资源池名称。
取值范围:字符串,要符合标识符的命名规范。
l
counts
负载组所在资源池内的并发数量。
取值范围:整型,取值范围为-1 ~ INT_MAX。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
899GaussDB 200
开发者指南
16 SQL 参考
示例
--创建一个默认负载组,其资源池为默认的资源池。
CREATE WORKLOAD GROUP wg_name1;
--创建资源池pool1。
CREATE RESOURCE POOL pool1;
--创建一个负载组,关联已创建的资源池。
CREATE WORKLOAD GROUP wg_name2 USING RESOURCE POOL pool1;
--创建一个负载组,关联已创建的资源池,并设置并发数量为10。
CREATE WORKLOAD GROUP wg_name3 USING RESOURCE POOL pool1 WITH (ACT_STATEMENTS=10);
--删除负载组和资源池。
DROP WORKLOAD GROUP wg_name1;
DROP WORKLOAD GROUP wg_name2;
DROP WORKLOAD GROUP wg_name3;
DROP RESOURCE POOL pool1;
相关链接
16.14.33 ALTER WORKLOAD GROUP,16.14.106 DROP WORKLOAD GROUP
16.14.76 CURSOR
功能描述
CURSOR命令定义一个游标,用于在一个大的查询里面检索少数几行数据。
为了处理SQL语句,存储过程进程分配一段内存区域来保存上下文联系。游标是指向
上下文区域的句柄或指针。借助游标,存储过程可以控制上下文区域的变化。
注意事项
l 游标命令只能在事务块里使用。
l 通常游标和SELECT一样返回文本格式。因为数据在系统内部是用二进制格式存储
的,系统必须对数据做一定转换以生成文本格式。一旦数据是以文本形式返回,
客户端应用需要把它们转换成二进制进行操作。使用FETCH语句,游标可以返回
文本或二进制格式。
l 应该小心使用二进制游标。文本格式一般都比对应的二进制格式占用的存储空间
大。二进制游标返回内部二进制形态的数据,可能更易于操作。如果想以文本方
式显示数据,则以文本方式检索会为用户节约很多客户端的工作。比如,如果查
询从某个整数列返回1,在缺省的游标里将获得一个字符串1,但在二进制游标里
将得到一个4字节的包含该数值内部形式的数值(大端顺序)。
语法格式
CURSOR cursor_name
[ BINARY ] [ NO SCROLL ]
FOR query ;
[ { WITH | WITHOUT } HOLD ]
参数说明
l
cursor_name
将要创建的游标名。
取值范围:遵循数据库对象命名规范。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
900GaussDB 200
开发者指南
16 SQL 参考
l
BINARY
指明游标以二进制而不是文本格式返回数据。
l
NO SCROLL
声明游标检索数据行的方式。
l
– NO SCROLL:声明该游标不能用于以倒序的方式检索数据行。
– 未声明:根据执行计划的不同,自动判断该游标是否可以用于以倒序的方式
检索数据行。
WITH HOLD | WITHOUT HOLD
声明当创建游标的事务结束后,游标是否能继续使用。
l
– WITH HOLD:声明该游标在创建它的事务结束后仍可继续使用。
– WITHOUT HOLD:声明该游标在创建它的事务之外不能再继续使用,此游标
将在事务结束时被自动关闭。
– 如果不指定WITH HOLD或WITHOUT HOLD,默认行为是WITHOUT
HOLD。
query
使用SELECT或VALUES子句指定游标返回的行。
取值范围:SELECT或VALUES子句。
示例
请参考FETCH的示例。
相关链接
16.14.111 FETCH
16.14.77 DEALLOCATE
功能描述
DEALLOCATE用于删除前面编写的预备语句。如果用户没有明确删除一个预备语句,
那么它将在会话结束的时候被删除。
PREPARE关键字总被忽略。
注意事项
无。
语法格式
DEALLOCATE [ PREPARE ] { name | ALL };
参数说明
l
name
将要删除的预备语句。
l
ALL
删除所有预备语句。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
901GaussDB 200
开发者指南
16 SQL 参考
示例
无。
16.14.78 DELETE
功能描述
DELETE从指定的表里删除满足WHERE子句的行。如果WHERE子句不存在,将删除
表中所有行,结果只保留表结构。
注意事项
l 要删除表中的数据,用户必须对它有DELETE权限。同样也必须有USING子句引
用的表以及condition上读取的表的SELECT权限。
l 对于行存复制表,仅支持两种场景下的delete操作:1)有主键约束的场景;2)执
行计划能下推的场景。
l 对于列存复制表只支持执行计划能下推的场景。
l 对于列存表,暂时不支持RETURNING子句。
语法格式
[ WITH [ RECURSIVE ] with_query [, ...] ]
DELETE FROM [ ONLY ] table_name [ * ] [ [ AS ] alias ]
[ USING using_list ]
[ WHERE condition | WHERE CURRENT OF cursor_name ]
[ RETURNING { * | { output_expr [ [ AS ] output_name ] } [, ...] } ];
参数说明
l
WITH [ RECURSIVE ] with_query [, ...]
用于声明一个或多个可以在主查询中通过名字引用的子查询,相当于临时表。
如果声明了RECURSIVE,那么允许SELECT子查询通过名字引用它自己。
其中with_query的详细格式为:
with_query_name [ ( column_name [, ...] ) ] AS
( {select | values | insert | update | delete} )
– with_query_name指定子查询生成的结果集名字,在查询中可使用该名称访问
子查询的结果集。
– column_name指定子查询结果集中显示的列名。
– 每个子查询可以是SELECT,VALUES,INSERT,UPDATE或DELETE语句。
l
ONLY
如果指定ONLY则只有该表被删除;如果没有声明,则该表和它的所有子表将都被
删除。
l
table_name
目标表的名字(可以有模式修饰)。
取值范围:已存在的表名。
l
alias
目标表的别名。
取值范围:字符串,符合标识符命名规范。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
902GaussDB 200
开发者指南
16 SQL 参考
l
using_list
using子句。
l
condition
一个返回boolean值的表达式,用于判断哪些行需要被删除。
l
WHERE CURRENT OF cursor_name
当前不支持,仅保留语法接口。
l
output_expr
DELETE命令删除行之后计算输出结果的表达式。该表达式可以使用表的任意字
段。可以使用*返回被删除行的所有字段。
l
output_name
一个字段的输出名称。
取值范围:字符串,符合标识符命名规范。
示例
--创建表tpcds.customer_address_bak。
CREATE TABLE tpcds.customer_address_bak AS TABLE tpcds.customer_address;
--删除tpcds.customer_address_bak中ca_address_sk小于14888的职员。
DELETE FROM tpcds.customer_address_bak WHERE ca_address_sk < 14888;
--删除tpcds.customer_address_bak中所有数据。
DELETE FROM tpcds.customer_address_bak;
--删除tpcds.customer_address_bak表。
DROP TABLE tpcds.customer_address_bak;
16.14.79 DO
功能描述
执行匿名代码块。
代码块被看做是没有参数的一段函数体,返回值类型是void。它的解析和执行是同一时
刻发生的。
注意事项
l 程序语言在使用之前,必须通过命令CREATE LANGUAGE安装到当前的数据库
中。 plpgsql是默认的安装语言,其它语言安装时必须指定。
l 如果语言是不受信任的,用户必须有使用程序语言的USAGE权限,或者是系统管
理员。
语法格式
DO [ LANGUAGE lang_name ] code;
参数说明
l
lang_name
用来解析代码的程序语言的名字,如果缺省,默认的语言是plpgsql。
l
code
程序语言代码可以被执行的。程序语言必须指定为字符串才行。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
903GaussDB 200
开发者指南
16 SQL 参考
示例
--创建用户webuser。
CREATE USER webuser PASSWORD 'Bigdata123@';
--授予用户webuser对模式tpcds下视图的所有操作权限。
DO $$DECLARE r record;
BEGIN
FOR r IN SELECT c.relname,n.nspname FROM pg_class c,pg_namespace n
WHERE c.relnamespace = n.oid AND n.nspname = 'tpcds' AND relkind IN ('r','v')
LOOP
EXECUTE 'GRANT ALL ON ' || quote_ident(r.table_schema) || '.' || quote_ident(r.table_name)
|| ' TO webuser';
END LOOP;
END$$;
--删除用户webuser。
DROP USER webuser CASCADE;
16.14.80 DROP DATABASE
功能描述
删除一个数据库。
注意事项
l 只有数据库所有者有权限执行DROP DATABASE命令,系统管理员默认拥有此权
限。
l 不能对系统默认安装的三个数据库(POSTGRES、TEMPLATE0和TEMPLATE1)
执行删除操作,系统做了保护。如果想查看当前服务中有哪几个数据库,可以用
gsql的\l命令查看。
l 如果有用户正在与要删除的数据库连接,则删除操作失败。如果要查看当前存在
哪些数据库连接,可以通过视图v$session查看。
l 不能在事务块中执行DROP DATABASE命令。
l 如果执行DROP DATABASE失败,事务回滚,需要再次执行一次DROP
DATABASE IF EXISTS。
DROP DATABASE一旦执行将无法撤销,请谨慎使用。
语法格式
DROP DATABASE [ IF EXISTS ] database_name ;
参数说明
l
IF EXISTS
如果指定的数据库不存在,则发出一个notice而不是抛出一个错误。
l
database_name
要删除的数据库名称。
取值范围:字符串,已存在的数据库名称。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
904GaussDB 200
开发者指南
16 SQL 参考
示例
请参见CREATE DATABASE的示例。
相关链接
16.14.47 CREATE DATABASE
16.14.81 DROP APP WORKLOAD GROUP MAPPING
功能描述
删除一个应用映射组。
注意事项
只要用户对当前数据库有DROP权限,就可以删除应用映射组。
语法格式
DROP APP WORKLOAD GROUP MAPPING [ IF EXISTS ] app_name;
参数说明
l
IF EXISTS
如果不存在相同名称的应用映射组,不会抛出一个错误,而会发出一个通知,告
知应用映射组不存在。
l
app_name
通过create app workload group mapping语句创建出的应用映射组名称。
取值范围:字符串,要符合标识符的命名规范。
示例
请参考CREATE APP WORKLOAD GROUP MAPPING的示例。
相关链接
16.14.2 ALTER APP WORKLOAD GROUP MAPPING,16.14.45 CREATE APP
WORKLOAD GROUP MAPPING
16.14.82 DROP DATA SOURCE
功能描述
删除一个Data Source对象。
注意事项
只有属主/系统管理员/初始用户才可以删除一个Data Source对象。
语法格式
DROP DATA SOURCE [IF EXISTS] src_name [CASCADE | RESTRICT];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
905GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
src_name
待删除的Data Source对象名称。
取值范围:字符串,符合标识符命名规范。
l
IF EXISTS
如果指定的Data Source不存在,则发出一个notice而不是报错。
l
CASCADE | RESTRICT
– CASCADE:表示允许级联删除依赖于Data Source的对象
– RESTRICT(缺省值):表示有依赖于该Data Source的对象存在,则该Data
Source无法删除。
目前Data Source对象没有被依赖的对象,CASCADE和RESTRICT效果一样,
保留此选项是为了向后兼容性。
示例
--创建Data Source对象。
CREATE DATA SOURCE ds_tst1;
--删除Data Source对象。
DROP DATA SOURCE ds_tst1 CASCADE;
DROP DATA SOURCE IF EXISTS ds_tst1 RESTRICT;
相关链接
CREATE DATA SOURCE,ALTER DATA SOURCE
16.14.83 DROP DIRECTORY
功能描述
删除指定的directory表项。
注意事项
只有sysadmin权限的用户可以执行drop操作。
语法格式
DROP DIRECTORY [ IF EXISTS ] directory_name;
参数说明
l
directory_name
目录名称。
取值范围:已经存在的目录名。
示例
--创建目录。
CREATE OR REPLACE DIRECTORY
dir
as '/tmp/';
--删除外部表。
DROP DIRECTORY dir;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
906GaussDB 200
开发者指南
16 SQL 参考
相关链接
16.14.49 CREATE DIRECTORY,16.14.6 ALTER DIRECTORY
16.14.84 DROP FOREIGN TABLE
功能描述
删除指定的外表。
注意事项
DROP FOREIGN TABLE会强制删除指定的表,删除表后,依赖该表的索引会被删除,
而使用到该表的函数和存储过程将无法执行。
语法格式
DROP FOREIGN TABLE [ IF EXISTS ]
table_name [, ...] [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的表不存在,则发出一个notice而不是抛出一个错误。
l
table_name
表名称。
取值范围:已存在的表名。
l
CASCADE | RESTRICT
– CASCADE:级联删除依赖于表的对象(比如视图)。
– RESTRICT:如果存在依赖对象,则拒绝删除该表。这个是缺省。
示例
请参考CREATE FOREIGN TABLE的示例和示例。
相关链接
16.14.7 ALTER FOREIGN TABLE (导入导出),16.14.8 ALTER FOREIGN TABLE
(SQL on Hadoop),16.14.50 CREATE FOREIGN TABLE (导入导出),16.14.51
CREATE FOREIGN TABLE (SQL on Hadoop )
16.14.85 DROP FUNCTION
功能描述
删除一个已存在的函数。
注意事项
如果函数中涉及对临时表相关操作,则无法使用DROP FUNCTION删除函数。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
907GaussDB 200
开发者指南
16 SQL 参考
语法格式
DROP FUNCTION [ IF EXISTS ] function_name
[ ( [ {[ argmode ] [ argname ] argtype} [, ...] ] ) [ CASCADE | RESTRICT ] ];
参数说明
l
IF EXISTS
IF EXISTS表示,如果函数存在则执行删除操作,函数不存在也不会报错,只是发
出一个notice。
l
function_name
要删除的函数名字。
取值范围:已存在的函数名。
l
argmode
函数参数的模式。
l
argname
函数参数的名称。
l
argtype
函数参数的类型
l
CASCADE | RESTRICT
– CASCADE:级联删除依赖于函数的对象(比如操作符) 。
– RESTRICT:如果有任何依赖对象存在,则拒绝删除该函数(缺省行为)。
示例
请参见CREATE FUNCTION的示例。
相关链接
16.14.10 ALTER FUNCTION,16.14.53 CREATE FUNCTION
16.14.86 DROP GROUP
功能描述
删除用户组。
DROP GROUP是DROP ROLE的别名。
注意事项
DROP GROUP是集群管理工具封装的内部接口,用来实现集群管理。该接口不建议用
户直接使用,以免对集群状态造成影响。
语法格式
DROP GROUP [ IF EXISTS ] group_name [, ...];
参数说明
请参见DROP ROLE的参数说明。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
908GaussDB 200
开发者指南
16 SQL 参考
相关链接
16.14.54 CREATE GROUP,16.14.11 ALTER GROUP,16.14.94 DROP ROLE
16.14.87 DROP INDEX
功能描述
删除索引。
注意事项
只有索引的所有者有权限执行DROP INDEX命令,系统管理员默认拥有此权限。
语法格式
DROP INDEX [ CONCURRENTLY ] [ IF EXISTS ]
index_name [, ...] [ CASCADE | RESTRICT ];
参数说明
l
CONCURRENTLY
以不加锁的方式删除索引。删除索引时,一般会阻塞其他语句对该索引所依赖表
的访问。加此关键字,可实现删除过程中不做阻塞。
此选项只能指定一个索引的名称, 并且CASCADE选项不支持。
普通DROP INDEX命令可以在事务内执行,但是DROP INDEX CONCURRENTLY
不可以在事务内执行。
l
IF EXISTS
如果指定的索引不存在,则发出一个notice而不是抛出一个错误。
l
index_name
要删除的索引名。
取值范围:已存在的索引。
l
CASCADE | RESTRICT
– CASCADE:表示允许级联删除依赖于该索引的对象。
– RESTRICT(缺省值):表示有依赖与此索引的对象存在,则该索引无法被删
除。
示例
请参见CREATE INDEX的示例。
相关链接
16.14.12 ALTER INDEX,16.14.55 CREATE INDEX
16.14.88 DROP NODE
功能描述
删除节点。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
909GaussDB 200
开发者指南
16 SQL 参考
注意事项
CREATE NODE是集群管理工具封装的内部接口,用来实现集群管理。该接口不建议
用户直接使用,以免对集群状态造成影响。
语法格式
DROP NODE [ IF EXISTS ] nodename [WITH ( cnnodename [, ... ] )];
参数说明
IF EXISTS
如果指定的节点不存在,则发出一个notice而不是抛出一个错误。
nodename
要删除的节点名。
取值范围:已存在的节点nodename。
cnnodename
CN名称。如果定义,则除当前连接CN外,还将在该节点上执行。否则,如果是删除
DN,将在所有CN上执行;如果是删除CN,将在除待删除CN外所有CN上执行。
取值范围:已存在的CN的nodename。
相关链接
16.14.56 CREATE NODE,16.14.14 ALTER NODE。
16.14.89 DROP NODE GROUP
功能描述
删除节点组。
注意事项
l DROP NODE GROUP是集群管理工具封装的内部接口,用来实现集群管理。
l 该接口仅对管理员用户开放使用。
语法格式
DROP NODE GROUP groupname [DISTRIBUTE FROM src_group_name];
参数说明
groupname
要删除的节点组名。
取值范围:已存在的节点组。
DISTRIBUTE FROM src_group_name
如果被删除的节点组是从src_group_name逻辑集群节点组重分布过来的,删除该节点组
需要指定src_group_name,以便将重分布后的节点分布信息同步到src_group_name指定
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
910GaussDB 200
开发者指南
16 SQL 参考
的逻辑集群节点组。该语句仅仅用于扩容重分布,用户不建议直接使用,以免导致数
据分布错误和逻辑集群不可用。
相关链接
16.14.57 CREATE NODE GROUP
16.14.90 DROP OWNED
功能描述
删除一个数据库角色所拥有的数据库对象。
注意事项
所有该角色在当前数据库里和共享对象(数据库,表空间) 上的所有对象上的权限都
将被撤销。
语法格式
DROP OWNED BY name [, ...] [ CASCADE | RESTRICT ];
参数说明
l
name
角色名。
取值范围:
l
CASCADE | RESTRICT
– CASCADE:级联删除所有依赖于被删除对象的对象。
– RESTRICT(缺省值):拒绝删除那些有任何依赖对象存在的对象。
16.14.91 DROP ROW LEVEL SECURITY POLICY
功能描述
删除表上某个行访问控制策略。
注意事项
仅表的所有者或者管理员用户才能删除表的行访问控制策略。
语法格式
DROP [ ROW LEVEL SECURITY ] POLICY [ IF EXISTS ] policy_name ON table_name [ CASCADE | RESTRICT ]
参数说明
l
IF EXISTS
如果指定的行访问控制策略不存在,发出一个notice而不是抛出一个错误。
l
policy_name
要删除的行访问控制策略的名称。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
911GaussDB 200
开发者指南
16 SQL 参考
–
table_name
行访问控制策略所在的数据表名。
–
CASCADE/RESTRICT
仅适配此语法,无对象依赖于该行访问控制策略,CASCADE和RESTRICT效
果相同。
示例
--创建数据表all_data
CREATE TABLE all_data(id int, role varchar(100), data varchar(100));
--创建行访问控制策略
CREATE ROW LEVEL SECURITY POLICY all_data_rls ON all_data USING(role = CURRENT_USER);
--删除行访问控制策略
DROP ROW LEVEL SECURITY POLICY all_data_rls ON all_data;
相关链接
16.14.18 ALTER ROW LEVEL SECURITY POLICY,16.14.58 CREATE ROW
LEVLEL SECURITY POLICY
16.14.92 DROP PROCEDURE
功能描述
删除已存在的存储过程。
注意事项
无。
语法格式
DROP PROCEDURE [ IF EXISTS
] procedure_name ;
参数说明
l
IF EXISTS
如果指定的存储过程不存在,发出一个notice而不是抛出一个错误。
l
procedure_name
要删除的存储过程名字。
取值范围:已存在的存储过程名。
示例
请参见CREATE PROCEDURE的示例。
相关链接
16.14.59 CREATE PROCEDURE
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
912GaussDB 200
开发者指南
16 SQL 参考
16.14.93 DROP RESOURCE POOL
功能描述
删除一个资源池。
说明
如果某个角色已关联到该资源池,无法删除。
注意事项
只要用户对当前数据库有DROP权限,就可以删除资源池。
语法格式
DROP RESOURCE POOL [ IF EXISTS ] pool_name;
参数说明
l
IF EXISTS
如果指定的存储过程不存在,发出一个notice而不是抛出一个错误。
l
pool_name
已创建过的资源池名称。
取值范围:字符串,要符合标识符的命名规范。
说明
多租户场景下,如果删除组资源池,其业务资源池都将被删除。只有不关联用户时,资源池才能
被删除。
示例
请参见CREATE RESOURCE POOL的示例。
相关链接
16.14.16 ALTER RESOURCE POOL,16.14.60 CREATE RESOURCE POOL
16.14.94 DROP ROLE
功能描述
删除指定的角色。
注意事项
无。
语法格式
DROP ROLE [ IF EXISTS ] role_name [, ...];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
913GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
IF EXISTS
如果指定的角色不存在,则发出一个notice而不是抛出一个错误。
l
role_name
要删除的角色名称。
取值范围:已存在的角色。
示例
请参见CREATE ROLE的示例。
相关链接
16.14.61 CREATE ROLE,16.14.17 ALTER ROLE,16.14.132 SET ROLE
16.14.95 DROP SCHEMA
功能描述
从数据库中删除模式。
注意事项
只有模式的所有者有权限执行DROP SCHEMA命令,系统管理员默认拥有此权限。
语法格式
DROP SCHEMA [ IF EXISTS ] schema_name [, ...] [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的模式不存在,发出一个notice而不是抛出一个错误。
l
schema_name
模式的名字。
取值范围:已存在模式名。
l
CASCADE | RESTRICT
– CASCADE:自动删除包含在模式中的对象。
– RESTRICT:如果模式包含任何对象,则删除失败(缺省行为)。
不要随意删除pg_temp或pg_toast_temp开头的模式,这些模式是系统内部使用的,如果
删除,可能导致无法预知的结果。
说明
无法删除当前模式。如果要删除当前模式,须切换到其他模式下。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
914GaussDB 200
开发者指南
16 SQL 参考
示例
请参见CREATE SCHEMA的示例。
相关链接
16.14.19 ALTER SCHEMA,16.14.62 CREATE SCHEMA。
16.14.96 DROP SEQUENCE
功能描述
从当前数据库里删除序列。
注意事项
只有序列的所有者或者系统管理员才能删除。
语法格式
DROP SEQUENCE [ IF EXISTS ] {[schema.]sequence_name} [ , ... ] [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的序列不存在,则发出一个notice而不是抛出一个错误。
l
name
序列名称。
l
CASCADE
级联删除依赖序列的对象。
l
RESTRICT
如果存在任何依赖的对象,则拒绝删除序列。此项是缺省值。
示例
--创建一个名为serial的递增序列,从101开始。
CREATE SEQUENCE serial START 101;
--删除序列。
DROP SEQUENCE serial;
相关链接
16.14.63 CREATE SEQUENCE 16.14.20 ALTER SEQUENCE
16.14.97 DROP SERVER
功能描述
删除现有的一个数据服务器。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
915GaussDB 200
开发者指南
16 SQL 参考
注意事项
只有server的owner才可以删除。
语法格式
DROP SERVER [ IF EXISTS ] server_name [ {CASCADE | RESTRICT} ] ;
参数描述
l
IF EXISTS
如果指定的表不存在,则发出一个notice而不是抛出一个错误。
l
server_name
服务器名称。
l
CASCADE | RESTRICT
– CASCADE:级联删除依赖于server的对象 。
– RESTRICT(缺省值):如果存在依赖对象,则拒绝删除该server。
示例
请参见CREATE SERVER的示例。
相关链接
16.14.64 CREATE SERVER,16.14.21 ALTER SERVER
16.14.98 DROP TABLE
功能描述
删除指定的表。
注意事项
DROP TABLE会强制删除指定的表,删除表后,依赖该表的索引会被删除,而使用到
该表的函数和存储过程将无法执行。删除分区表,会同时删除分区表中的所有分区。
语法格式
DROP TABLE [ IF EXISTS ]
{ [schema.]table_name } [, ...] [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的表不存在,则发出一个notice而不是抛出一个错误。
l
schema
模式名称。
l
table_name
表名称。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
916GaussDB 200
开发者指南
16 SQL 参考
l
CASCADE | RESTRICT
– CASCADE:级联删除依赖于表的对象(比如视图)。
– RESTRICT(缺省项):如果存在依赖对象,则拒绝删除该表。这个是缺省。
示例
请参考CREATE TABLE的示例。
相关链接
16.14.24 ALTER TABLE,16.14.65 CREATE TABLE
16.14.99 DROP TABLESPACE
功能描述
删除一个表空间。
注意事项
l 只有表空间所有者有权限执行DROP TABLESPACE命令,系统管理员默认拥有此
权限。
l 在删除一个表空间之前,表空间里面不能有任何数据库对象,否则会报错。
l DROP TABLESPACE不支持回滚,因此,不能出现在事务块内部。
l 执行DROP TABLESPACE操作时,如果有另外的会话执行\db查询操作,可能会由
于tablespace事务的原因导致查询失败,请重新执行\db查询操作。
l 如果执行DROP TABLESPACE失败,需要再次执行一次DROP TABLESPACE IF
EXISTS。
语法格式
DROP TABLESPACE [ IF EXISTS ] tablespace_name;
参数说明
l
IF EXISTS
如果指定的表空间不存在,则发出一个notice而不是抛出一个错误。
l
tablespace_name
表空间的名字。
取值范围:已存在的表空间的名字。
示例
请参见CREATE TABLESPACE的示例。
相关链接
16.14.26 ALTER TABLESPACE, 16.14.68 CREATE TABLESPACE
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
917GaussDB 200
开发者指南
16 SQL 参考
16.14.100 DROP TEXT SEARCH CONFIGURATION
功能描述
删除已有文本搜索配置。
注意事项
要执行这个命令,用户必须是该配置的所有者。
语法格式
DROP TEXT SEARCH CONFIGURATION [ IF EXISTS ] name [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的文本搜索配置不存在,那么发出一个notice而不是抛出一个错误。
l
name
要删除的文本搜索配置名称(可有模式修饰)。
l
CASCADE
级联删除依赖文本搜索配置的对象。
l
RESTRICT
若有任何对象依赖文本搜索配置则拒绝删除它。这是默认情况。
示例
请参见CREATE TEXT SEARCH CONFIGURATION的示例。
相关链接
16.14.27 ALTER TEXT SEARCH CONFIGURATION, 16.14.69 CREATE TEXT
SEARCH CONFIGURATION
16.14.101 DROP TEXT SEARCH DICTIONARY
功能描述
删除全文检索词典。
注意事项
l 预定义词典不支持DROP操作。
l 只有词典的所有者可以执行DROP操作,系统管理员默认拥有此权限。
l 谨慎执行DROP...CASCADE操作,该操作将级联删除使用该词典的文本搜索配置
(TEXT SEARCH CONFIGURATION)。
语法格式
DROP TEXT SEARCH DICTIONARY [ IF EXISTS ] name [ CASCADE | RESTRICT ]
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
918GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
IF EXISTS
如果指定的全文检索词典不存在,那么发出一个Notice而不是报错。
l
name
要删除的词典名称(可指定模式名,否则默认在当前模式下)。
取值范围:已存在的词典名。
l
CASCADE
自动删除依赖于该词典的对象,并依次删除依赖于这些对象的所有对象。
如果存在任何一个使用该词典的文本搜索配置,此DROP命令将不会成功。可添加
CASCADE以删除引用该词典的所有文本搜索配置以及词典。
l
RESTRICT
如果任何对象依赖词典,则拒绝删除该词典。这是缺省值。
示例
--删除词典english
DROP TEXT SEARCH DICTIONARY english;
相关链接
16.14.28 ALTER TEXT SEARCH DICTIONARY,16.14.70 CREATE TEXT SEARCH
DICTIONARY
16.14.102 DROP TRIGGER
功能描述
删除触发器。
注意事项
只有触发器的所有者可以执行DROP TRIGGER操作,系统管理员默认拥有此权限。
语法格式
DROP TRIGGER [ IF EXISTS ] trigger_name ON table_name [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的触发器不存在,则发出一个notice而不是抛出一个错误。
l
trigger_name
要删除的触发器名字。
取值范围:已存在的触发器。
l
table_name
要删除的触发器所在的表名称。
取值范围:已存在的含触发器的表。
l
CASCADE | RESTRICT
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
919GaussDB 200
开发者指南
16 SQL 参考
– CASCADE:级联删除依赖此触发器的对象。
– RESTRICT:如果有依赖对象存在,则拒绝删除此触发器。此选项为缺省值。
示例
请参见16.14.71 CREATE TRIGGER的示例。
相关链接
16.14.71 CREATE TRIGGER,16.14.29 ALTER TRIGGER,16.14.24 ALTER TABLE
16.14.103 DROP TYPE
功能描述
删除一个用户定义的数据类型。只有类型所有者才有删除权限。
语法格式
DROP TYPE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]
参数说明
l
IF EXISTS
如果指定的类型不存在,那么发出一个notice而不是抛出一个错误。
l
name
要删除的类型名(可以有模式修饰)。
l
CASCADE
级联删除依赖该类型的对象(比如字段、函数、操作符等)
RESTRICT
如果有依赖对象,则拒绝删除该类型(缺省行为)。
示例
请参考CREATE TYPE的示例。
相关链接
16.14.30 ALTER TYPE,16.14.72 CREATE TYPE
16.14.104 DROP USER
功能描述
删除用户,同时会删除同名的schema。
注意事项
l
须使用CASCADE级联删除依赖用户的对象(除数据库外)。当删除用户的级联对
象时,如果级联对象处于锁定状态,则此级联对象无法被删除,直到对象被解锁
或锁定级联对象的进程被杀死。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
920GaussDB 200
开发者指南
16 SQL 参考
l
在GaussDB 200中,存在一个配置参数enable_kill_query,此参数在配置文件
postgresql.conf中。此参数影响级联删除用户对象的行为:
– 当参数enable_kill_query为on ,且使用CASCADE模式删除用户时,会自动kill
锁定用户级联对象的进程,并删除用户。
– 当参数enable_kill_query为off,且使用CASCADE模式删除用户时,会等待锁
定级联对象的进程结束之后再删除用户。
l 在数据库中删除用户时,如果依赖用户的对象在其他数据库中或者依赖用户的对
象是其他数据库,请用户先手动删除其他数据库中的依赖对象或直接删除依赖数
据库,再删除用户。即drop user不支持跨数据库进行级联删除。
l 在多租户场景下,删除组用户时,业务用户也会同时被删除,如果指定CASCADE
级联删除,那么删除业务用户时同时也指定CASCADE。如果在删除某个用户失败
时,会报错,同时其他用户也无法成功删除。
l 如果用户下存在创建GDS外表时指定的错误表,则无法通过drop user指定cascade
关键字直接删除用户。
l 如果该用户被DATA SOURCE对象依赖时,无法直接级联删除该用户,需要手动
删除对应的DATA SOURCE对象之后再删除该用户。
语法格式
DROP USER [ IF EXISTS ] user_name [, ...] [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的用户不存在,发出一个notice而不是抛出一个错误。
l
user_name
待删除的用户名。
取值范围:已存在的用户名。
l
CASCADE | RESTRICT
– CASCADE:级联删除依赖用户的对象。
– RESTRICT:如果用户还有任何依赖的对象,则拒绝删除该用户(缺省行
为)。
说明
在GaussDB 200中,存在一个配置参数enable_kill_query,此参数在配置文件
postgresql.conf中。此参数影响级联删除用户对象的行为:
l 当参数enable_kill_query为on ,且使用CASCADE模式删除用户时,会自动kill锁定
用户级联对象的进程,并删除用户。
l 当参数enable_kill_query为off,且使用CASCADE模式删除用户时,会等待锁定级
联对象的进程结束之后再删除用户。
示例
请参考CREATE USER的示例。
相关链接
16.14.31 ALTER USER,16.14.73 CREATE USER
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
921GaussDB 200
开发者指南
16 SQL 参考
16.14.105 DROP VIEW
功能描述
数据库中强制删除已有的视图。
注意事项
只有视图的所有者有权限执行DROP VIEW的命令,系统管理员默认拥有此权限。
语法格式
DROP VIEW [ IF EXISTS ] view_name [, ...] [ CASCADE | RESTRICT ];
参数说明
l
IF EXISTS
如果指定的视图不存在,则发出一个notice而不是抛出一个错误。
l
view_name
要删除的视图名字。
取值范围:已存在的视图。
l
CASCADE | RESTRICT
– CASCADE:级联删除依赖此视图的对象(比如其他视图)。
– RESTRICT:如果有依赖对象存在,则拒绝删除此视图。此选项为缺省值。
示例
请参见CREATE VIEW的示例。
相关链接
16.14.32 ALTER VIEW,16.14.74 CREATE VIEW
16.14.106 DROP WORKLOAD GROUP
功能描述
删除一个负载组。
注意事项
只要用户对当前数据库有DROP权限,就可以删除负载组。
语法格式
DROP WORKLOAD GROUP [ IF EXISTS ] wg_name;
参数说明
l
IF EXISTS
如果指定的视图不存在,则发出一个notice而不是抛出一个错误。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
922GaussDB 200
开发者指南
16 SQL 参考
l
wg_name
负载组名称。负载组名称不能和当前数据库里其他负载组重名。
取值范围:字符串,已有的负载组名称。
示例
请参见CREATE WORKLOAD GROUP的示例。
相关链接
16.14.33 ALTER WORKLOAD GROUP,16.14.75 CREATE WORKLOAD GROUP
16.14.107 EXECUTE
功能描述
执行一个前面准备好的预备语句。因为一个预备语句只在会话的生命期里存在,那么
预备语句必须是在当前会话的前些时候用PREPARE语句创建的。
注意事项
如果创建预备语句的PREPARE语句声明了一些参数,那么传递给EXECUTE语句的必
须是一个兼容的参数集,否则就会生成一个错误。
语法格式
EXECUTE name [ ( parameter [, ...] ) ];
参数说明
l
name
要执行的预备语句的名字。
l
parameter
给预备语句的一个参数的具体数值。它必须是一个生成与创建这个预备语句时指
定参数的数据类型相兼容的值的表达式。
示例
--创建表reason。
CREATE TABLE tpcds.reason (
CD_DEMO_SK
INTEGER
CD_GENDER
character(16)
CD_MARITAL_STATUS
character(100)
)
;
NOT NULL,
,
--插入数据。
INSERT INTO tpcds.reason VALUES(51, 'AAAAAAAADDAAAAAA', 'reason 51');
--创建表reason_t1。
CREATE TABLE tpcds.reason_t1 AS TABLE reason;
--为一个INSERT语句创建一个预备语句然后执行它。
PREPARE insert_reason(integer,character(16),character(100)) AS INSERT INTO tpcds.reason_t1
VALUES($1,$2,$3);
EXECUTE insert_reason(52, 'AAAAAAAADDAAAAAA', 'reason 52');
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
923GaussDB 200
开发者指南
16 SQL 参考
--删除表reason和reason_t1。
DROP TABLE tpcds.reason;
DROP TABLE tpcds.reason_t1;
16.14.108 EXECUTE DIRECT
功能描述
在指定的节点上执行SQL语句。一般情况下,SQL语句的执行是由集群负载自动分配到
合适的节点上,execute direct主要用于数据库维护和测试。
注意事项
l 只有系统管理员才能执行EXECUTE DIRECT。
l 为了各个节点上数据的一致性,SQL语句仅支持SELECT,不允许执行事务语句、
DDL、DML。
l 使用此类型语句在指定的DN执行AVG聚集计算时,返回结果集是以数组形式返
回,如{4,2},表示sum结果为4,count结果为2。
l 由于CN节点不存储用户表数据,不允许指定CN节点执行用户表上的SELECT查
询。
l 不允许执行嵌套的EXECUTE DIRECT语句,即执行的SQL语句不能同样是
EXECUTE DIRECT语句,此时可直接执行最内层EXECUTE DIRECT语句代替。
语法格式
EXECUTE DIRECT ON ( nodename [, ... ] ) query ;
参数说明
l
nodename
节点名称。
取值范围:已存在的节点。
l
query
要执行查询语句。
示例
--查询当前集群的节点分布状态。
SELECT * FROM pgxc_node;
node_name
| node_type | node_port |
node_host
| node_port1 |
node_host1
|
hostis_primary | nodeis_primary | nodeis_preferred |
node_id
| sctp_port | control_port |
sctp_port1 | control_port1
--------------+-----------+-----------+----------------+------------+----------------
+----------------+----------------+------------------+-------------+-----------+--------------
+------------+---------------
cn_5001
| C
|
8050 | 10.180.155.74 |
8050 | 10.180.155.74 |
t
| f
| f
| 1120683504 |
0 |
0
|
0 |
0
cn_5003
| C
|
8050 | 10.180.157.130 |
8050 | 10.180.157.130 |
t
| f
| f
| -125853378 |
0 |
0
|
0 |
0
dn_6001_6002 | D
|
40050 | 10.180.155.74 |
45050 | 10.146.187.231 |
t
| f
| f
| 1644780306 |
40052 |
40052 |
45052 |
45052
dn_6003_6004 | D
|
40050 | 10.146.187.231 |
45050 | 10.180.157.130 |
t
| f
| f
| -966646068 |
40052 |
40052 |
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
924GaussDB 200
开发者指南
16 SQL 参考
45052 |
45052
dn_6005_6006 | D
t
| f
45052 |
45052
cn_5002
| C
t
| f
|
0 |
(6 rows)
|
|
40050 | 10.180.157.130 |
45050 | 10.180.155.74
| f
|
868850011 |
40052 | |
8050 | localhost
| f |
|
8050 | localhost
| -1736975100 |
0 |
40052 |
0
0
--查询dn_6001_6002上tpcds.customer_address记录。
EXECUTE DIRECT ON(dn_6001_6002) 'select count(*) from tpcds.customer_address';
count
-------
16922
(1 row)
--查询tpcds.customer_address所有记录。
SELECT count(*) FROM tpcds.customer_address;
count
-------
50000
(1 row)
16.14.109 EXPLAIN
功能描述
显示SQL语句的执行计划。
执行计划将显示SQL语句所引用的表会采用什么样的扫描方式,如:简单的顺序扫
描、索引扫描等。如果引用了多个表,执行计划还会显示用到的JOIN算法。
执行计划的最关键的部分是语句的预计执行开销,这是计划生成器估算执行该语句将
花费多长的时间。
若指定了ANALYZE选项,则该语句会被执行,然后根据实际的运行结果显示统计数
据,包括每个计划节点内时间总开销(毫秒为单位)和实际返回的总行数。这对于判
断计划生成器的估计是否接近现实非常有用。
注意事项
在指定ANALYZE选项时,语句会被执行。如果用户想使用EXPLAIN分析INSERT,
UPDATE,DELETE,CREATE TABLE AS或EXECUTE语句,而不想改动数据(执行
这些语句会影响数据),请使用这种方法:
START TRANSACTION;
EXPLAIN ANALYZE ...;
ROLLBACK;
语法格式
l
显示SQL语句的执行计划,支持多种选项,对选项顺序无要求。
EXPLAIN [ (
option
[, ...] )
] statement;
其中选项option子句的语法为。
ANALYZE [ boolean ] |
ANALYSE [ boolean ] |
VERBOSE [ boolean ] |
COSTS [ boolean ] |
CPU [ boolean ] |
DETAIL [ boolean ] |
NODES [ boolean ] |
NUM_NODES [ boolean ] |
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
925GaussDB 200
开发者指南
16 SQL 参考
BUFFERS [ boolean ] |
TIMING [ boolean ] |
PLAN [ boolean ] |
FORMAT { TEXT | XML | JSON | YAML }
l
显示SQL语句的执行计划,且要按顺序给出选项。
EXPLAIN
{ [
{ ANALYZE | ANALYSE
}
] [ VERBOSE
]
| PERFORMANCE
} statement;
参数说明
l
statement
指定要分析的SQL语句。
l
ANALYZE boolean | ANALYSE boolean
显示实际运行时间和其他统计数据。
取值范围:
l
– TRUE(缺省值):显示实际运行时间和其他统计数据。
– FALSE:不显示。
VERBOSE boolean
显示有关计划的额外信息。
取值范围:
l
– TRUE(缺省值):显示额外信息。
– FALSE:不显示。
COSTS boolean
包括每个规划节点的估计总成本,以及估计的行数和每行的宽度。
取值范围:
l
– TRUE(缺省值):显示估计总成本和宽度。
– FALSE:不显示。
CPU boolean
打印CPU的使用情况的信息。
取值范围:
l
– TRUE(缺省值):显示CPU的使用情况。
– FALSE:不显示。
DETAIL boolean
打印DN上的信息。
取值范围:
l
– TRUE(缺省值):打印DN的信息。
– FALSE:不打印。
NODES boolean
打印query执行的节点信息。
取值范围:
l
– TRUE(缺省值):打印执行的节点的信息。
– FALSE:不打印。
NUM_NODES boolean
打印执行中的节点的个数信息。
取值范围:
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
926GaussDB 200
开发者指南
16 SQL 参考
l
– TRUE(缺省值):打印DN个数的信息。
– FALSE:不打印。
BUFFERS boolean
包括缓冲区的使用情况的信息。
取值范围:
l
– TRUE:显示缓冲区的使用情况。
– FALSE(缺省值):不显示。
TIMING boolean
包括实际的启动时间和花费在输出节点上的时间信息。
取值范围:
l
– TRUE(缺省值):显示启动时间和花费在输出节点上的时间信息。
– FALSE:不显示。
PLAN
是否将执行计划存储在plan_table中。当该选项开启时,会将执行计划存储在
PLAN_TABLE中,不打印到当前屏幕,因此该选项为on时,不能与其他选项同时
使用。
取值范围:
l
– ON(缺省值):将执行计划存储在plan_table中,不打印到当前屏幕。执行成
功返回 EXPLAIN SUCCESS。
– OFF:不存储执行计划,将执行计划打印到当前屏幕。
FORMAT
指定输出格式。
取值范围:TEXT,XML,JSON和YAML。
默认值:TEXT。
l
PERFORMANCE
使用此选项时,即打印执行中的所有相关信息。
示例
--创建一个表tpcds.customer_address_p1。
CREATE TABLE tpcds.customer_address_p1 AS TABLE tpcds.customer_address;
--修改explain_perf_mode为normal
SET explain_perf_mode=normal;
--显示表简单查询的执行计划。
EXPLAIN SELECT * FROM tpcds.customer_address_p1;
QUERY PLAN
--------------------------------------------------
Data Node Scan (cost=0.00..0.00 rows=0 width=0)
Node/s: All datanodes
(2 rows)
--以JSON格式输出的执行计划(explain_perf_mode为normal时)。
EXPLAIN(FORMAT JSON) SELECT * FROM tpcds.customer_address_p1;
QUERY PLAN
--------------------------------------
[
+
{
+
"Plan": {
+
"Node Type": "Data Node Scan",+
"Startup Cost": 0.00,
+
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
927GaussDB 200
开发者指南
16 SQL 参考
"Total Cost": 0.00,
"Plan Rows": 0,
"Plan Width": 0,
"Node/s": "All datanodes"
}
}
+
+
+
+
+
+
]
(1 row)
--如果有一个索引,当使用一个带索引WHERE条件的查询,可能会显示一个不同的计划。
EXPLAIN SELECT * FROM tpcds.customer_address_p1 WHERE ca_address_sk=10000;
QUERY PLAN
--------------------------------------------------
Data Node Scan (cost=0.00..0.00 rows=0 width=0)
Node/s: dn_6005_6006
(2 rows)
--以YAML格式输出的执行计划(explain_perf_mode为normal时)。
EXPLAIN(FORMAT YAML) SELECT * FROM tpcds.customer_address_p1 WHERE ca_address_sk=10000;
QUERY PLAN
---------------------------------
- Plan:
+
Node Type: "Data Node Scan"+
Startup Cost: 0.00
+
Total Cost: 0.00
+
Plan Rows: 0
+
Plan Width: 0
+
Node/s: "dn_6005_6006"
(1 row)
--禁止开销估计的执行计划。
EXPLAIN(COSTS FALSE)SELECT * FROM tpcds.customer_address_p1 WHERE ca_address_sk=10000;
QUERY PLAN
------------------------
Data Node Scan
Node/s: dn_6005_6006
(2 rows)
--带有聚集函数查询的执行计划。
EXPLAIN SELECT SUM(ca_address_sk) FROM tpcds.customer_address_p1 WHERE ca_address_sk<10000;
QUERY PLAN
---------------------------------------------------------------------------------------
Aggregate (cost=18.19..14.32 rows=1 width=4)
-> Streaming (type: GATHER) (cost=18.19..14.32 rows=3 width=4)
Node/s: All datanodes
-> Aggregate (cost=14.19..14.20 rows=3 width=4)
-> Seq Scan on customer_address_p1 (cost=0.00..14.18 rows=10 width=4)
Filter: (ca_address_sk < 10000)
(6 rows)
--删除表tpcds.customer_address_p1。
DROP TABLE tpcds.customer_address_p1;
相关链接
16.14.34 ANALYZE | ANALYSE
16.14.110 EXPLAIN PLAN
功能描述
通过EXPLAIN PLAN命令可以将查询执行的计划信息存储于PLAN_TABLE表中。与
EXPLAIN命令不同的是,EXPLAIN PLAN仅将计划信息进行存储,而不会打印到屏
幕。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
928GaussDB 200
开发者指南
16 SQL 参考
语法格式
EXPLAIN PLAN
[ SET STATEMENT_ID = string ]
FOR statement ;
参数说明
l EXPLAIN 中的PLAN 选项表示需要将计划信息存储于PLAN_TABLE中,存储成功
将返回“EXPLAIN SUCCESS”。
l STATEMENT_ID用户可以对查询设置标签,输入的标签信息也将存储于
PLAN_TABLE中。
说明
用户在执行EXPLAIN PLAN时,如果没有进行SET STATEMENT_ID,则默认为空值。同
时,用户可输入的STATEMENT_ID最大长度为30个字节,超过长度将会产生报错。
注意事项
l EXPLAIN PLAN 不支持在DN上执行。
l 对于执行错误的SQL无法进行计划信息的收集。
l PLAN_TABLE中的数据是session级生命周期并且session隔离和用户隔离,用户只
能看到当前session、当前用户的数据。
l PLAN_TABLE无法与GDS外表进行关联查询。
l 对于不能下推的查询,无法收集到具体的object信息,object只能收集到
REMOTE_QUERY或CTE等信息。详见示例 2。
示例 1
使用EXPLAIN PLAN收集SQL语句的执行计划,通常包括以下步骤:
步骤1 执行EXPLAN PLAN。
说明
执行EXPLAIN PLAN 后会将计划信息自动存储于PLAN_TABLE中,不支持对PLAN_TABLE进行
INSERT、UPDATE、ANALYZE等操作。
PLAN_TABLE详细介绍见19.3.152 PLAN_TABLE。
explain plan set statement_id='TPCH-Q4' for
select
o_orderpriority,
count(*) as order_count
from
orders
where
o_orderdate >= '1993-07-01'::date
and o_orderdate < '1993-07-01'::date + interval '3 month'
and exists (
select
*
from
lineitem
where
l_orderkey = o_orderkey
and l_commitdate < l_receiptdate
)
group by
o_orderpriority
order by
o_orderpriority;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
929GaussDB 200
开发者指南
16 SQL 参考
步骤2 查询PLAN_TABLE。
SELECT * FROM PLAN_TABLE;
步骤3 清理PLAN_TABLE表中的数据。
DELETE FROM PLAN_TABLE WHERE xxx;
----结束
示例 2
对于不能下推的查询,执行explain plan后plan_table中object仅收集到REMOTE_QUERY
或CTE等信息。
场景一:优化器生成下发语句的计划,此时仅能收集到REMOTE_QUERY。
explain plan set statement_id = 'test remote query' for
select
current_user
from
customer;
查询PLAN_TABLE。
SELECT * FROM PLAN_TABLE;
场景二:对于with recursive场景中不能下推的查询,仅能收集到CTE。
关闭enable_stream_recursive,使得查询不能下推。
set enable_stream_recursive = off;
执行explain plan SQL
explain plan set statement_id = 'cte can not be push down'
for
with recursive rq as
(
select id, name from chinamap where id = 11
union all
select origin.id, rq.name || ' > ' || origin.name
from rq join chinamap origin on origin.pid = rq.id
)
select id, name from rq order by 1;
查询PLAN_TABLE。
SELECT * FROM PLAN_TABLE;
16.14.111 FETCH
功能描述
FETCH通过已创建的游标来检索数据。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
930GaussDB 200
开发者指南
16 SQL 参考
每个游标都有一个供FETCH使用的关联位置。游标的关联位置可以在查询结果的第一
行之前,或者在结果中的任意行,或者在结果的最后一行之后:
l 游标刚创建完之后,关联位置在第一行之前的。
l 在抓取了一些移动行之后,关联位置在检索到的最后一行上。
l 如果FETCH抓取完了所有可用行,它就停在最后一行后面,或者在反向抓取的情
况下是停在第一行前面。
l FETCH ALL或FETCH BACKWARD ALL将总是把游标的关联位置放在最后一行或
者在第一行前面。
l 如果游标定义了NO SCROLL,则不允许使用例如FETCH BACKWARD之类的反向
抓取。
l NEXT,PRIOR,FIRST,LAST,ABSOLUTE,RELATIVE形式在恰当地移动游
标之后抓取一条记录。如果后面没有数据行,就返回一个空的结果,此时游标就
会停在查询结果的最后一行之后(向后查询时)或者第一行之前(向前查询
时)。
l FORWARD和BACKWARD形式在向前或者向后移动的过程中抓取指定的行数,然
后把游标定位在最后返回的行上;或者是,如果count大于可用的行数,则在所有
行之后(向后查询时)或者之前(向前查询时)。
l RELATIVE 0,FORWARD 0,BACKWARD 0都要求在不移动游标的前提下抓取当
前行,也就是重新抓取最近刚抓取过的行。除非游标定位在第一行之前或者最后
一行之后,这个动作都应该成功,而在那两种情况下,不返回任何行。
l 当FETCH的游标上涉及列存表时,不支持BACKWARD、PRIOR、FIRST等涉及反
向获取操作。
注意事项
语法格式
FETCH [ direction { FROM | IN } ] cursor_name;
其中direction子句为可选参数。
NEXT
|
|
|
|
|
|
|
|
|
|
|
|
| PRIOR
FIRST
LAST
ABSOLUTE count
RELATIVE count
count
ALL
FORWARD
FORWARD count
FORWARD ALL
BACKWARD
BACKWARD count
BACKWARD ALL
l direction_clause
参数说明
定义抓取数据的方向。
取值范围:
–
NEXT(缺省值)
从当前关联位置开始,抓取下一行。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
931GaussDB 200
开发者指南
16 SQL 参考
–
PRIOR
从当前关联位置开始,抓取上一行。
–
FIRST
抓取查询的第一行(和ABSOLUTE 1相同)。
–
LAST
抓取查询的最后一行(和ABSOLUTE -1相同)。
–
ABSOLUTE count
抓取查询中第count行。
ABSOLUTE抓取不会比用相对位移移动到需要的数据行更快,因为下层的实
现必须遍历所有中间的行。
count取值范围:有符号的整数
–
n count为正数,就从查询结果的第一行开始,抓取第count行。当count小于
当前游标位置时,涉及到rewind操作,暂不支持。
n count为负数或0,涉及到反向扫描操作,暂不支持。
RELATIVE count
从当前关联位置开始,抓取随后或前面的第count行。
取值范围:有符号的整数
–
n count为正数就抓取当前关联位置之后的第count行。
n count为负数,涉及到反向扫描操作,暂不支持。
n 如果有数据的话,RELATIVE 0重新抓取当前行。
count
抓取随后的count行(和FORWARD count一样)。
–
ALL
从当前关联位置开始,抓取所有剩余的行(和FORWARD ALL一样)。
–
FORWARD
抓取下一行(和NEXT一样)。
–
FORWARD count
与RELATIVE count的效果相同,从当前关联位置开始,抓取随后或前面的第
count行。
–
FORWARD ALL
从当前关联位置开始,抓取所有剩余行。
–
BACKWARD
从当前关联位置开始,抓取前面一行(和PRIOR一样) 。
–
BACKWARD count
从当前关联位置开始,抓取前面的count行(向后扫描)。
取值范围:有符号的整数
–
n count为正数就抓取当前关联位置之前的第count行。
n count为负数就抓取当前关联位置之后的第abs(count)行。
n 如果有数据的话,BACKWARD 0重新抓取当前行。
BACKWARD ALL
从当前关联位置开始,抓取所有前面的行(向后扫描) 。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
932GaussDB 200
开发者指南
16 SQL 参考
l
{ FROM | IN } cursor_name
使用关键字FROM或IN指定游标名称。
取值范围:已创建的游标的名称。
示例
--SELECT语句,用一个游标读取一个表。开始一个事务。
START TRANSACTION;
--建立一个名为cursor1的游标。
CURSOR cursor1 FOR SELECT * FROM tpcds.customer_address ORDER BY 1;
--抓取头3行到游标cursor1里。
FETCH FORWARD 3 FROM cursor1;
ca_address_sk | ca_address_id
| ca_street_number |
ca_street_name
| ca_street_type |
ca_suite_number |
ca_city
|
ca_county
| ca_state |
ca_zip
| ca_country
|
ca_gmt_offset |
ca_location_type
---------------+------------------+------------------+--------------------+-----------------
+-----------------+-----------------+-----------------+----------+------------+---------------
+---------------+----------------------
1 | AAAAAAAABAAAAAAA | 18
| Jackson
| Parkway
|
Suite 280
| Fairfield
| Maricopa County | AZ
| 86192
| United States
|
-7.00 | condo
2 | AAAAAAAACAAAAAAA | 362
| Washington 6th
| RD
|
Suite 80
| Fairview
| Taos County
| NM
| 85709
| United States
|
-7.00 | condo
3 | AAAAAAAADAAAAAAA | 585
| Dogwood Washington | Circle
|
Suite Q
| Pleasant Valley | York County
| PA
| 12477
| United States
|
-5.00 | single family
(3 rows)
--关闭游标并提交事务。
CLOSE cursor1;
--结束一个事务。
END;
--VALUES子句,用一个游标读取VALUES子句中的内容。开始一个事务。
START TRANSACTION;
--建立一个名为cursor2的游标。
CURSOR cursor2 FOR VALUES(1,2),(0,3) ORDER BY 1;
--抓取头2行到游标cursor2里。
FETCH FORWARD 2 FROM cursor2;
column1 | column2
---------+---------
0 |
3
1 |
2
(2 rows)
--关闭游标并提交事务。
CLOSE cursor2;
--结束一个事务。
END;
--WITH HOLD游标的使用,开启事务。
START TRANSACTION;
--创建一个with hold游标。
DECLARE cursor1 CURSOR WITH HOLD FOR SELECT * FROM tpcds.customer_address ORDER BY 1;
--抓取头2行到游标cursor1里。
FETCH FORWARD 2 FROM cursor1;
ca_address_sk | ca_address_id
| ca_street_number |
ca_street_name
| ca_street_type
ca_suite_number |
ca_city
|
ca_county
| ca_state |
ca_zip
| ca_country
ca_gmt_offset |
ca_location_type
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
|
|
933GaussDB 200
开发者指南
16 SQL 参考
---------------+------------------+------------------+--------------------+-----------------
+-----------------+-----------------+-----------------+----------+------------+---------------
+---------------+----------------------
1 | AAAAAAAABAAAAAAA | 18
| Jackson
| Parkway
|
Suite 280
| Fairfield
| Maricopa County | AZ
| 86192
| United States
|
-7.00 | condo
2 | AAAAAAAACAAAAAAA | 362
| Washington 6th
| RD
|
Suite 80
| Fairview
| Taos County
| NM
| 85709
| United States
|
-7.00 | condo
(2 rows)
--结束事务。
END;
--抓取下一行到游标cursor1里。
FETCH FORWARD 1 FROM cursor1;
ca_address_sk | ca_address_id
| ca_street_number |
ca_street_name
| ca_street_type |
ca_suite_number |
ca_city
|
ca_county
| ca_state |
ca_zip
| ca_country
|
ca_gmt_offset |
ca_location_type
---------------+------------------+------------------+--------------------+-----------------
+-----------------+-----------------+-----------------+----------+------------+---------------
+---------------+----------------------
3 | AAAAAAAADAAAAAAA | 585
| Dogwood Washington | Circle
|
Suite Q
| Pleasant Valley | York County
| PA
| 12477
| United States
|
-5.00 | single family
(1 row)
--关闭游标。
CLOSE cursor1;
相关链接
16.14.39 CLOSE,16.14.115 MOVE
16.14.112 GRANT
功能描述
对角色和用户进行授权操作。
使用GRANT命令进行用户授权包括以下三种场景:
l
将系统权限授权给角色或用户
系统权限又称为用户属性,包括SYSADMIN、CREATEDB、CREATEROLE、
AUDITADMIN和LOGIN。
系统权限一般通过CREATE/ALTER ROLE语法来指定。其中,SYSADMIN权限可
以通过GRANT/REVOKE ALL PRIVILEGE授予或撤销。但系统权限无法通过
ROLE和USER的权限被继承,也无法授予PUBLIC。
l
将数据库对象授权给角色或用户
将数据库对象(表和视图、指定字段、数据库、函数、模式、表空间等)的相关
权限授予特定角色或用户;
GRANT命令将数据库对象的特定权限授予一个或多个角色。这些权限会追加到已
有的权限上。
关键字PUBLIC表示该权限要赋予所有角色,包括以后创建的用户。PUBLIC可以
看做是一个隐含定义好的组,它总是包括所有角色。任何角色或用户都将拥有通
过GRANT直接赋予的权限和所属的权限,再加上PUBLIC的权限。
如果声明了WITH GRANT OPTION,则被授权的用户也可以将此权限赋予他人,
否则就不能授权给他人。这个选项不能赋予PUBLIC,这是GaussDB 200特有的属
性。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
934GaussDB 200
开发者指南
16 SQL 参考
GaussDB 200会将某些类型的对象上的权限授予PUBLIC。默认情况下,对表、表
字段、序列、外部数据源、外部服务器、模式或表空间对象的权限不会授予
PUBLIC,而以下这些对象的权限会授予PUBLIC:数据库的CONNECT权限和
CREATE TEMP TABLE权限、函数的EXECUTE特权、语言和数据类型(包括域)
的USAGE特权。当然,对象拥有者可以撤销默认授予PUBLIC的权限并专门授予
权限给其他用户。为了更安全,建议在同一个事务中创建对象并设置权限,这样
其他用户就没有时间窗口使用该对象。另外,这些初始的默认权限可以使用
ALTER DEFAULT PRIVILEGES命令修改。
l
将角色或用户的权限授权给其他角色或用户
将一个角色或用户的权限授予一个或多个其他角色或用户。在这种情况下,每个
角色或用户都可视为拥有一个或多个数据库权限的集合。
当声明了WITH ADMIN OPTION,被授权的用户可以将该权限再次授予其他角色
或用户,以及撤销所有由该角色或用户继承到的权限。当授权的角色或用户发生
变更或被撤销时,所有继承该角色或用户权限的用户拥有的权限都会随之发生变
更。
数据库系统管理员可以给任何角色或用户授予/撤销任何权限。拥有CREATEROLE
权限的角色可以赋予或者撤销任何非系统管理员角色的权限。
注意事项
无。
语法格式
l
将表或视图的访问权限赋予指定的用户或角色。
GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES } [, ...]
| ALL [ PRIVILEGES ] }
ON { [ TABLE ] table_name [, ...]
| ALL TABLES IN SCHEMA schema_name [, ...] }
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
l
将表中字段的访问权限赋予指定的用户或角色。
GRANT { {{ SELECT | INSERT | UPDATE | REFERENCES } ( column_name [, ...] )} [, ...]
| ALL [ PRIVILEGES ] ( column_name [, ...] ) }
ON [ TABLE ] table_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
l
将数据库的访问权限赋予指定的用户或角色。
GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [, ...]
| ALL [ PRIVILEGES ] }
ON DATABASE database_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
l
将域的访问权限赋予指定的用户或角色。
GRANT { USAGE | ALL [ PRIVILEGES ] }
ON DOMAIN domain_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
说明
本版本暂时不支持赋予域的访问权限。
l
将外部数据源的访问权限赋予给指定的用户或角色。
GRANT { USAGE | ALL [ PRIVILEGES ] }
ON FOREIGN DATA WRAPPER fdw_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
935GaussDB 200
开发者指南
16 SQL 参考
l
将外部服务器的访问权限赋予给指定的用户或角色。
GRANT { USAGE | ALL [ PRIVILEGES ] }
ON FOREIGN SERVER server_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
l
将函数的访问权限赋予给指定的用户或角色。
GRANT { EXECUTE | ALL [ PRIVILEGES ] }
ON { FUNCTION {function_name ( [ {[ argmode ] [ arg_name ] arg_type} [, ...] ] )} [, ...]
| ALL FUNCTIONS IN SCHEMA schema_name [, ...] }
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
l
将过程语言的访问权限赋予给指定的用户或角色。
GRANT { USAGE | ALL [ PRIVILEGES ] }
ON LANGUAGE lang_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
说明
本版本只有C函数支持所有用户创建,而Java和Internal只支持拥有sysadmin权限的用户创
建。
l 拥有sysadmin权限的用户通过grant语法来将创建C函数的权限授权给普通用户时,不支
持grant usage on language c to public,只支持授权给特定用户。
l 拥有sysadmin权限的用户通过grant语法来将创建C函数的权限授权给普通用户时,不支
持with grant option。
l
将大对象的访问权限赋予指定的用户或角色。
GRANT { { SELECT | UPDATE } [, ...] | ALL [ PRIVILEGES ] }
ON LARGE OBJECT loid [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
说明
本版本暂时不支持大对象。
l
将子集群的访问权限赋予指定的用户或角色。
GRANT { CREATE | USAGE | COMPUTE | ALL [ PRIVILEGES ] }
ON NODE GROUP group_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
l
将模式的访问权限赋予指定的用户或角色。
GRANT { { CREATE | USAGE } [, ...] | ALL [ PRIVILEGES ] }
ON SCHEMA schema_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
说明
将模式中的表或者视图对象授权给其他用户时,需要将表或视图所属的模式的USAGE权限
同时授予该用户,若没有该权限,则只能看到这些对象的名字,并不能实际进行对象访
问。
l
将表空间的访问权限赋予指定的用户或角色。
GRANT { CREATE | ALL [ PRIVILEGES ] }
ON TABLESPACE tablespace_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
l
将类型的访问权限赋予指定的用户或角色。
GRANT { USAGE | ALL [ PRIVILEGES ] }
ON TYPE type_name [, ...]
TO { [ GROUP ] role_name | PUBLIC } [, ...]
[ WITH GRANT OPTION ];
说明
本版本暂时不支持赋予类型的访问权限。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
936GaussDB 200
开发者指南
16 SQL 参考
l
将角色的权限赋予其他用户或角色的语法。
GRANT role_name [, ...]
TO role_name [, ...]
[ WITH ADMIN OPTION ];
l
将sysadmin权限赋予指定的角色。
GRANT ALL { PRIVILEGES | PRIVILEGE }
TO role_name;
l
将Data Source对象的权限赋予指定的角色。
GRANT {USAGE | ALL [PRIVILEGES]}
ON DATA SOURCE src_name [, ...]
TO {[GROUP] role_name | PUBLIC} [, ...] [WITH GRANT OPTION];
l
将directory对象的权限赋予指定的角色。
GRANT {READ|WRITE| ALL [PRIVILEGES]}
ON DIRECTORY directory_name [, ...]
TO {[GROUP] role_name | PUBLIC} [, ...] [WITH GRANT OPTION];
参数说明
GRANT的权限分类如下所示。
l
SELECT
允许对指定的表、视图、序列执行SELECT语句。
l
INSERT
允许对指定的表执行INSERT语句。
l
UPDATE
允许对声明的表中任意字段执行UPDATE语句。SELECT... FOR UPDATE和
SELECT... FOR SHARE除了需要SELECT权限外,还需要UPDATE权限。
l
DELETE
允许执行DELETE语句删除指定表中的数据。
l
TRUNCATE
允许执行TRUNCATE语句删除指定表中的所有记录。
l
REFERENCES
创建一个外键约束,必须拥有参考表和被参考表的REFERENCES权限。
l
l
CREATE
– 对于数据库,允许在数据库里创建新的模式。
– 对于模式,允许在模式中创建新的对象。如果要重命名一个对象,用户除了
必须是该对象的所有者外,还必须拥有该对象所在模式的CREATE权限。
– 对于表空间,允许在表空间中创建表,允许在创建数据库和模式的时候把该
表空间指定为缺省表空间。
– 对于子集群,允许在子集群中创建表对象。
CONNECT
允许用户连接到指定的数据库。
l
EXECUTE
允许使用指定的函数,以及利用这些函数实现的操作符。
l
USAGE
– 对于过程语言,允许用户在创建函数的时候指定过程语言。
– 对于模式,USAGE允许访问包含在指定模式中的对象,若没有该权限,则只
能看到这些对象的名字。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
937GaussDB 200
开发者指南
16 SQL 参考
l
– 对于序列,USAGE允许使用nextval函数。
– 对于子集群, 对包含在指定模式中的对象有访问权限时,USAGE允许访问指
定子集群下的表对象。
– 对于Data Source对象,USAGE是指访问权限,也是可赋予的所有权限,即
USAGE与ALL PRIVILEGES等价。
COMPUTE
针对计算子集群,允许用户在具有compute权限的计算子集群上进行弹性计算。
l
ALL PRIVILEGES
一次性给指定用户/角色赋予所有可赋予的权限。只有系统管理员有权执行GRANT
ALL PRIVILEGES。
GRANT的参数说明如下所示。
l
role_name
已存在用户名称。
l
table_name
已存在表名称。
l
column_name
已存在字段名称。
l
schema_name
已存在模式名称。
l
database_name
已存在数据库名称。
l
funcation_name
已存在函数名称。
l
sequence_name
已存在序列名称。
l
domain_name
已存在域类型名称。
l
fdw_name
已存在外部数据包名称。
l
lang_name
已存在语言名称。
l
type_name
已存在类型名称。
l
group_name
已存在的子集群名称。
l
src_name
已存在的Data Source对象名称。
l
argmode
参数模式。
取值范围:字符串,要符合标识符命名规范。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
938GaussDB 200
开发者指南
16 SQL 参考
l
arg_name
参数名称。
取值范围:字符串,要符合标识符命名规范。
l
arg_type
参数类型。
取值范围:字符串,要符合标识符命名规范。
l
loid
包含本页的大对象的标识符。
取值范围:字符串,要符合标识符命名规范。
l
tablespace_name
表空间名称。
l
directory_name
目录名称。
取值范围:字符串,要符合标识符命名规范。
l
WITH GRANT OPTION
如果声明了WITH GRANT OPTION,则被授权的用户也可以将此权限赋予他人,
否则就不能授权给他人。这个选项不能赋予PUBLIC。
说明
NODE GROUP不支持WITH GRANT OPTION功能。
非对象所有者给其他用户授予对象权限时,命令按照以下规则执行:
l 如果用户没有该对象上指定的权限,命令立即失败。
l 如果用户有该对象上的部分权限,则GRANT命令只授予他有授权选项的权限。
l 如果用户没有可用的授权选项,GRANT ALL PRIVILEGES形式将发出一个警告信
息,其他命令形式将发出在命令中提到的且没有授权选项的相关警告信息。
说明
数据库系统管理员可以访问所有对象,而不会受对象的权限设置影响。这个特点类似Unix系统的
root的权限。和root一样,除了必要的情况外,建议不要总是以系统管理员身份进行操作。
不允许对表分区进行GRANT操作,对分区表进行GRANT操作会引起告警。
针对NODE GROUP,普通用户不能执行GRANT/REVOKE操作。
示例
示例:将系统权限授权给用户或者角色。
创建名为joe的用户,并将sysadmin权限授权给他。
CREATE USER joe PASSWORD 'Bigdata123@';
GRANT ALL PRIVILEGES TO joe;
授权成功后,用户joe会拥有sysadmin的所有权限。
示例:将对象权限授权给用户或者角色。
1.
撤销joe用户的sysadmin权限,然后将模式tpcds的使用权限和表tpcds.reason的所有
权限授权给用户joe。
REVOKE ALL PRIVILEGES FROM joe;
GRANT USAGE ON SCHEMA tpcds TO joe;
GRANT ALL PRIVILEGES ON tpcds.reason TO joe;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
939GaussDB 200
开发者指南
16 SQL 参考
授权成功后,joe用户就拥有了tpcds.reason表的所有权限,包括增删改查等权限。
2.
将tpcds.reason表中r_reason_sk、r_reason_id、r_reason_desc列的查询权限,
r_reason_desc的更新权限授权给joe。
GRANT select (r_reason_sk,r_reason_id,r_reason_desc),update (r_reason_desc) ON tpcds.reason
TO joe;
授权成功后,用户joe对tpcds.reason表中r_reason_sk,r_reason_id的查询权限会立即
生效。如果joe用户需要拥有将这些权限授权给其他用户的权限,可以通过以下语
法对joe用户进行授权。
GRANT select (r_reason_sk, r_reason_id) ON tpcds.reason TO joe WITH GRANT OPTION;
将数据库postgres的连接权限授权给用户joe,并给予其在postgres中创建schema的
权限,而且允许joe将此权限授权给其他用户。
GRANT create,connect on database postgres TO joe WITH GRANT OPTION;
创建角色tpcds_manager,将模式tpcds的访问权限授权给角色tpcds_manager,并授
予该角色在tpcds下创建对象的权限,不允许该角色中的用户将权限授权给其他
人。
CREATE ROLE tpcds_manager PASSWORD 'Bigdata123@';
GRANT USAGE,CREATE ON SCHEMA tpcds TO tpcds_manager;
将表空间tpcds_tbspc的所有权限授权给用户joe,但用户joe无法将权限继续授予其
他用户。
CREATE TABLESPACE tpcds_tbspc RELATIVE LOCATION 'tablespace/tablespace_1';
GRANT ALL ON TABLESPACE tpcds_tbspc TO joe;
示例:将用户或者角色的权限授权给其他用户或角色。
1.
创建角色manager,将joe的权限授权给manager,并允许该角色将权限授权给其他
人。
CREATE ROLE manager PASSWORD 'Bigdata123@';
GRANT joe TO manager WITH ADMIN OPTION;
2.
创建用户senior_manager,将用户manager的权限授权给该用户。
CREATE ROLE senior_manager PASSWORD 'Bigdata123@';
GRANT manager TO senior_manager;
3.
撤销权限,并清理用户。
REVOKE manager FROM joe;
REVOKE senior_manager FROM manager;
DROP USER manager;
示例:撤销上述授予的权限,并清理角色和用户。
REVOKE ALL PRIVILEGES ON tpcds.reason FROM joe;
REVOKE ALL PRIVILEGES ON SCHEMA tpcds FROM joe;
REVOKE ALL ON TABLESPACE tpcds_tbspc FROM joe;
DROP TABLESPACE tpcds_tbspc;
REVOKE USAGE,CREATE ON SCHEMA tpcds FROM tpcds_manager;
DROP ROLE tpcds_manager;
DROP ROLE senior_manager;
DROP USER joe CASCADE;
相关链接
16.14.123 REVOKE,16.14.5 ALTER DEFAULT PRIVILEGES
16.14.113 INSERT
功能描述
向表中添加一行或多行数据。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
940GaussDB 200
开发者指南
16 SQL 参考
注意事项
l 只有拥有表INSERT权限的用户,才可以向表中插入数据。
l 如果使用RETURNING子句,用户必须要有该表的SELECT权限。
l 如果使用query子句插入来自查询里的数据行,用户还需要拥有在查询里使用的表
的SELECT权限。
l 当连接到TD兼容的数据库时,td_compatible_truncation参数设置为on时,将启用超
长字符串自动截断功能,在后续的insert语句中(不包含外表的场景下),对目标
表中char和varchar类型的列上插入超长字符串时,系统会自动按照目标表中相应列
定义的最大长度对超长字符串进行截断。
说明
如果向字符集为字节类型编码(SQL_ASCII,LATIN1等)的数据库中插入多字节字符数据
(如汉字等),且字符数据跨越截断位置,这种情况下,按照字节长度自动截断,自动截
断后会在尾部产生非预期结果。如果用户有对于截断结果正确性的要求,建议用户采用
UTF8等能够按照字符截断的输入字符集作为数据库的编码集。
语法格式
[ WITH [ RECURSIVE ] with_query [, ...] ]
INSERT INTO table_name [ ( column_name [, ...] ) ]
{ DEFAULT VALUES
| VALUES {( { expression | DEFAULT } [, ...] ) }[, ...]
| query }
[ RETURNING {* | {output_expression [ [ AS ] output_name ] }[, ...]} ];
参数说明
l
WITH [ RECURSIVE ] with_query [, ...]
用于声明一个或多个可以在主查询中通过名字引用的子查询,相当于临时表。
如果声明了RECURSIVE,那么允许SELECT子查询通过名字引用它自己。
其中with_query的详细格式为:with_query_name [ ( column_name [, ...] ) ] AS
( {select | values | insert | update | delete} )
– with_query_name指定子查询生成的结果集名字,在查询中可使用该名称访问
子查询的结果集。
– column_name指定子查询结果集中显示的列名。
– 每个子查询可以是SELECT,VALUES,INSERT,UPDATE或DELETE语句。
l
table_name
要插入数据的目标表名。
取值范围:已存在的表名。
l
column_name
目标表中的字段名:
– 字段名可以有子字段名或者数组下标修饰。
– 没有在字段列表中出现的每个字段,将由系统默认值,或者声明时的默认值
填充,若都没有则用NULL填充。例如,向一个复合类型中的某些字段插入数
据的话,其他字段将是NULL。
– 目标字段(column_name)可以按顺序排列。如果没有列出任何字段,则默认
全部字段,且顺序为表声明时的顺序。
– 如果value子句和query中只提供了N个字段,则目标字段为前N个字段。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
941GaussDB 200
开发者指南
16 SQL 参考
–
value子句和query提供的值在表中从左到右关联到对应列。
取值范围:已存在的字段名。
l
expression
赋予对应column的一个有效表达式或值:
l
– 向表中字段插入单引号 " ' "时需要使用单引号自身进行转义。
– 如果插入行的表达式不是正确的数据类型,系统试图进行类型转换,若转换
不成功,则插入数据失败,系统返回错误信息。
DEFAULT
对应字段名的缺省值。如果没有缺省值,则为NULL。
l
query
一个查询语句(SELECT语句),将查询结果作为插入的数据。
l
RETURNING
返回实际插入的行,RETURNING列表的语法与SELECT的输出列表一致。
l
output_expression
INSERT命令在每一行都被插入之后用于计算输出结果的表达式。
取值范围:该表达式可以使用table的任意字段。可以使用*返回被插入行的所有字
段。
l
output_name
字段的输出名称。
取值范围:字符串,符合标识符命名规范。
示例
--创建表tpcds.reason_t2。
CREATE TABLE tpcds.reason_t2
(
r_reason_sk
integer,
r_reason_id
character(16),
r_reason_desc character(100)
);
--向表中插入一条记录。
INSERT INTO tpcds.reason_t2(r_reason_sk, r_reason_id, r_reason_desc) VALUES (1,
'AAAAAAAABAAAAAAA', 'reason1');
--向表中插入一条记录,和上一条语法等效。
INSERT INTO tpcds.reason_t2 VALUES (2, 'AAAAAAAABAAAAAAA', 'reason2');
--向表中插入多条记录。
INSERT INTO tpcds.reason_t2 VALUES (3, 'AAAAAAAACAAAAAAA','reason3'),(4, 'AAAAAAAADAAAAAAA',
'reason4'),(5, 'AAAAAAAAEAAAAAAA','reason5');
--向表中插入tpcds.reason中r_reason_sk小于5的记录。
INSERT INTO tpcds.reason_t2 SELECT * FROM tpcds.reason WHERE r_reason_sk <5;
--删除表tpcds.reason_t2。
DROP TABLE tpcds.reason_t2;
16.14.114 LOCK
功能描述
LOCK TABLE获取表级锁。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
942GaussDB 200
开发者指南
16 SQL 参考
GaussDB 200在为一个引用了表的命令自动请求锁时,尽可能选择最小限制的锁模式。
如果用户需要一种更为严格的锁模式,可以使用LOCK命令。例如,一个应用是在Read
Committed隔离级别上运行事务,并且它需要保证表中的数据在事务的运行过程中不被
修改。为实现这个目的,则可以在查询之前对表使用SHARE锁模式进行锁定。这样将
防止数据不被并发修改,从而保证后续的查询可以读到已提交的持久化的数据。因为
SHARE锁模式与任何写操作需要的ROW EXCLUSIVE模式冲突,并且LOCK TABLE
name IN SHARE MODE语句将等到所有当前持有ROW EXCLUSIVE模式锁的事务提交
或回滚后才能执行。因此,一旦获得该锁,就不会存在未提交的写操作,并且其他操
作也只能等到该锁释放之后才能开始。
注意事项
l LOCK TABLE只能在一个事务块的内部有用,因为锁在事务结束时就会被释放。
出现在任意事务块外面的LOCK TABLE都会报错。
l 如果没有声明锁模式,缺省为最严格的模式ACCESS EXCLUSIVE。
l LOCK TABLE ... IN ACCESS SHARE MODE需要在目标表上有SELECT权限。所
有其他形式的LOCK需要UPDATE和/或DELETE权限。
l 没有UNLOCK TABLE命令,锁总是在事务结束时释放。
l LOCK TABLE只处理表级的锁,因此那些带“ROW”字样的锁模式都是有歧义
的。这些模式名字通常可理解为用户试图在一个被锁定的表中获取行级的锁。同
样,ROW EXCLUSIVE模式也是一个可共享的表级锁。注意,只要是涉及到
LOCK TABLE ,所有锁模式都有相同的语意,区别仅在于规则中锁与锁之间是否
冲突,规则请参见表16-61。
语法格式
LOCK [ TABLE ] {[ ONLY ] name [, ...]| {name [ * ]} [, ...]}
[ IN {ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE | SHARE | SHARE ROW
EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE} MODE ]
[ NOWAIT ];
参数说明
表 16-61 冲突的锁模式
请求的
锁模
式/当
前锁模
式 ACCE
SS
SHAR
E ROW
SHAR
E ROW
EXCL
USIVE SHAR
E
UPDA
TE
EXCL
USIVE SHAR
E SHAR
E
ROW
EXCL
USIVE EXCL
USIVE ACCE
SS
EXCL
USIVE
ACCE
SS
SHAR
E - - - - - - - X
ROW
SHAR
E - - - - - - X X
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
943GaussDB 200
开发者指南
16 SQL 参考
请求的
锁模
式/当
前锁模
式 ACCE
SS
SHAR
E ROW
SHAR
E ROW
EXCL
USIVE SHAR
E
UPDA
TE
EXCL
USIVE SHAR
E SHAR
E
ROW
EXCL
USIVE EXCL
USIVE ACCE
SS
EXCL
USIVE
ROW
EXCL
USIVE - - - - X X X X
SHAR
E
UPDA
TE
EXCL
USIVE - - - X X X X X
SHAR
E - - X X - X X X
SHAR
E
ROW
EXCL
USIVE - - X X X X X X
EXCL
USIVE - X X X X X X X
ACCE
SS
EXCL
USIVE X X X X X X X X
LOCK的参数说明如下所示:
l
name
要锁定的表的名字,可以有模式修饰。
LOCK TABLE命令中声明的表的顺序就是上锁的顺序。
取值范围:已存在的表名。
l
ONLY
如果指定ONLY只有该表被锁定,如果没有声明该表和他的所有子表将都被锁定。
l
ACCESS SHARE
ACCESS锁只允许对表进行读取,而禁止对表进行修改。所有对表进行读取而不
修改的SQL语句都会自动请求这种锁。例如,SELECT命令会自动在被引用的表上
请求一个这种锁。
l
ROW SHARE
ROW SHARE锁允许对表进行并发读取,禁止对表进行其他操作。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
944GaussDB 200
开发者指南
16 SQL 参考
SELECT FOR UPDATE和SELECT FOR SHARE命令会自动在目标表上请求ROW
SHARE锁(且所有被引用但不是FOR SHARE/FOR UPDATE的其他表上,还会自
动加上ACCESS SHARE锁)。
l
ROW EXCLUSIVE
与ROW SHARE锁相同,ROW EXCLUSIVE允许并发读取表,但是禁止修改表中
数据。UPDATE,DELETE,INSERT命令会自动在目标表上请求这个锁(且所有
被引用的其他表上还会自动加上的ACCESS SHARE锁)。通常情况下,所有会修
改表数据的命令都会请求表的ROW EXCLUSIVE锁。
l
SHARE UPDATE EXCLUSIVE
这个模式保护一个表的模式不被并发修改,以及禁止在目标表上执行垃圾回收命
令(VACUUM )。
VACUUM(不带FULL选项),ANALYZE,CREATE INDEX CONCURRENTLY
命令会自动请求这样的锁。
l
SHARE
SHARE锁允许并发的查询,但是禁止对表进行修改。
CREATE INDEX(不带CONCURRENTLY选项)语句会自动请求这种锁。
l
SHARE ROW EXCLUSIVE
SHARE ROW EXCLUSIVE锁禁止对表进行任何的并发修改,而且是独占锁,因此
一个会话中只能获取一次。
任何SQL语句都不会自动请求这个锁模式。
l
EXCLUSIVE
EXCLUSIVE锁允许对目标表进行并发查询,但是禁止任何其他操作。
这个模式只允许并发加ACCESS SHARE锁,也就是说,只有对表的读动作可以和
持有这个锁模式的事务并发执行。
任何SQL语句都不会在用户表上自动请求这个锁模式。然而在某些操作的时候,
会在某些系统表上请求它。
l
ACCESS EXCLUSIVE
这个模式保证其所有者(事务)是可以访问该表的唯一事务。
ALTER TABLE,DROP TABLE,TRUNCATE,REINDEX,CLUSTER,
VACUUM FULL命令会自动请求这种锁。
在LOCK TABLE命令没有明确声明需要的锁模式时,它是缺省锁模式。
l
NOWAIT
声明LOCK TABLE不去等待任何冲突的锁释放,如果无法立即获取该锁,该命令
退出并且发出一个错误信息。
在不指定NOWAIT的情况下获取表级锁时,如果有其他互斥锁存在的话,则等待
其他锁的释放。
示例
--向一个外键表上插入数据时,在有主键的表上使用SHARE锁。
START TRANSACTION;
LOCK TABLE tpcds.reason IN SHARE MODE;
SELECT r_reason_desc FROM tpcds.reason WHERE r_reason_sk=5;
r_reason_desc
-----------
Parts missing
(1 row)
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
945GaussDB 200
开发者指南
16 SQL 参考
COMMIT;
--在执行删除操作时对一个有主键的表进行 SHARE ROW EXCLUSIVE 锁。
CREATE TABLE tpcds.reason_t1 AS TABLE tpcds.reason;
START TRANSACTION;
LOCK TABLE tpcds.reason_t1 IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM tpcds.reason_t1 WHERE r_reason_desc IN(SELECT r_reason_desc FROM tpcds.reason_t1 WHERE
r_reason_sk < 6 );
DELETE FROM tpcds.reason_t1 WHERE r_reason_sk = 7;
COMMIT;
--删除表tpcds.reason_t1。
DROP TABLE tpcds.reason_t1;
16.14.115 MOVE
功能描述
MOVE在不检索数据的情况下重新定位一个游标。MOVE的作用类似于16.14.111
FETCH命令,但只是重定位游标而不返回行。
注意事项
无。
语法格式
MOVE [ direction [ FROM | IN ] ] cursor_name;
其中direction子句为可选参数。
NEXT
|
|
|
|
|
|
|
|
|
|
|
|
|
PRIOR
FIRST
LAST
ABSOLUTE count
RELATIVE count
count
ALL
FORWARD
FORWARD count
FORWARD ALL
BACKWARD
BACKWARD count
BACKWARD ALL
参数说明
MOVE命令的参数与FETCH的相同,详细请参见FETCH的参数说明。
说明
成功完成时,MOVE命令将返回一个“MOVE count”的标签,count是一个使用相同参数的
FETCH命令会返回的行数(可能为零)。
示例
--开始一个事务。
START TRANSACTION;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
946GaussDB 200
开发者指南
16 SQL 参考
--定义一个名为cursor1的游标。
CURSOR cursor1 FOR SELECT * FROM tpcds.reason;
--忽略游标cursor1的前3行。
MOVE FORWARD 3 FROM cursor1;
--抓取游标cursor1的前4行。
FETCH 4 FROM cursor1;
r_reason_sk |
r_reason_id
|
r_reason_desc
-------------+------------------
+--------------------------------------------------------------------------------------------------
----
4 | AAAAAAAAEAAAAAAA | Not the product that was
ordred
5 | AAAAAAAAFAAAAAAA | Parts
missing
6 | AAAAAAAAGAAAAAAA | Does not work with a product that I
have
7 | AAAAAAAAHAAAAAAA | Gift
exchange
(4 rows)
--关闭游标。
CLOSE cursor1;
--结束一个事务。
END;
相关链接
16.14.39 CLOSE,16.14.111 FETCH
16.14.116 MERGE INTO
功能描述
通过MERGE INTO语句,将目标表和源表中数据针对关联条件进行匹配,若关联条件
匹配时对目标表进行UPDATE,无法匹配时对目标表执行INSERT。此语法可以很方便
地用来合并执行UPDATE和INSERT,避免多次执行。
注意事项
l 进行MERGE INTO操作的用户需要同时拥有目标表的UPDATE和INSERT权限,以
及源表的SELECT权限。
l 不支持PREPARE。
l 不支持重分布过程中MERGE INTO。
语法格式
MERGE INTO table_name [ [ AS ] alias ]
USING { { table_name | view_name } | subquery } [ [ AS ] alias ]
ON ( condition )
[
WHEN MATCHED THEN
UPDATE SET { column_name = { expression | DEFAULT } |
( column_name [, ...] ) = ( { expression | DEFAULT } [, ...] ) } [, ...]
[ WHERE condition ]
]
[
WHEN NOT MATCHED THEN
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
947GaussDB 200
开发者指南
16 SQL 参考
INSERT { DEFAULT VALUES |
[ ( column_name [, ...] ) ] VALUES ( { expression | DEFAULT } [, ...] ) [, ...] [ WHERE
condition ] }
];
参数说明
l
INTO子句
指定正在更新或插入的目标表。目标表暂不支持复制表。
–
talbe_name
目标表的表名。
–
alias
目标表的别名。
取值范围:字符串,符合标识符命名规范。
l
USING子句
指定源表,源表可以为表、视图或子查询。
l
ON子句
关联条件,用于指定目标表和源表的关联条件。不支持更新关联条件中的字段。
l
WHEN MATCHED子句
当源表和目标表中数据针对关联条件可以匹配上时,选择WHEN MATCHED子句
进行UPDATE操作。
不支持更新分布列。不支持更新系统表、系统列。
l
WHEN NOT MATCHED子句
当源表和目标表中数据针对关联条件无法匹配时,选择WHEN NOT MATCHED子
句进行INSERT操作。
不支持INSERT子句中包含多个VALUES。
WHEN MATCHED和WHEN NOT MATCHED子句顺序可以交换,可以缺省其中一
个,但不能同时缺省,不支持同时指定两个WHEN MATCHED或WHEN NOT
MATCHED子句。
l
DEFAULT
用对应字段的缺省值填充该字段。
如果没有缺省值,则为NULL。
l
WHERE condition
UPDATE子句和INSERT子句的条件,只有在条件满足时才进行更新操作,可缺
省。不支持WHERE条件中引用系统列。
示例
-- 创建目标表products和源表newproducts,并插入数据
CREATE TABLE products
(
product_id INTEGER,
product_name VARCHAR2(60),
category VARCHAR2(60)
);
INSERT
INSERT
INSERT
INSERT
INSERT
文档版本 01 (2019-08-01)
INTO
INTO
INTO
INTO
INTO
products
products
products
products
products
VALUES
VALUES
VALUES
VALUES
VALUES
(1501,
(1502,
(1600,
(1601,
(1666,
'vivitar 35mm', 'electrncs');
'olympus is50', 'electrncs');
'play gym', 'toys');
'lamaze', 'toys');
'harry potter', 'dvd');
版权所有 © 华为技术有限公司
948GaussDB 200
开发者指南
16 SQL 参考
CREATE TABLE newproducts
(
product_id INTEGER,
product_name VARCHAR2(60),
category VARCHAR2(60)
);
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
newproducts
newproducts
newproducts
newproducts
VALUES
VALUES
VALUES
VALUES
(1502,
(1601,
(1666,
(1700,
'olympus camera', 'electrncs');
'lamaze', 'toys');
'harry potter', 'toys');
'wait interface', 'books');
-- 进行MERGE INTO操作
MERGE INTO products p
USING newproducts np
ON (p.product_id = np.product_id)
WHEN MATCHED THEN
UPDATE SET p.product_name = np.product_name, p.category = np.category WHERE p.product_name !=
'play gym'
WHEN NOT MATCHED THEN
INSERT VALUES (np.product_id, np.product_name, np.category) WHERE np.category = 'books';
MERGE 4
-- 查询更新后的结果
SELECT * FROM products ORDER BY product_id;
product_id | product_name | category
------------+----------------+-----------
1501 | vivitar 35mm
| electrncs
1502 | olympus camera | electrncs
1600 | play gym
| toys
1601 | lamaze
| toys
1666 | harry potter
| toys
1700 | wait interface | books
(6 rows)
-- 删除表
DROP TABLE products;
DROP TABLE newproducts;
16.14.117 PREPARE
功能描述
创建一个预备语句。
预备语句是服务端的对象,可以用于优化性能。在执行PREPARE语句的时候,指定的
查询被解析、分析、重写。当随后发出EXECUTE语句的时候,预备语句被规划和执
行。这种设计避免了重复解析、分析工作。PREPARE语句创建后在整个数据库会话期
间一直存在,一旦创建成功,即便是在事务块中创建,事务回滚,PREPARE也不会删
除。只能通过显式调用16.14.77 DEALLOCATE进行删除,会话结束时,PREPARE也
会自动删除。
注意事项
无。
语法格式
PREPARE name [ ( data_type [, ...] ) ] AS statement;
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
949GaussDB 200
开发者指南
16 SQL 参考
参数说明
l
name
指定预备语句的名字。它必须在该会话中是唯一的。
l
data_type
参数的数据类型。
l
statement
是SELECT INSERT、UPDATE、DELETE或VALUES语句之一。
示例
请参见EXECUTE的示例。
相关链接
16.14.77 DEALLOCATE
16.14.118 PREPARE TRANSACTION
功能描述
为当前事务做两阶段提交的准备。
在命令之后,事务就不再和当前会话关联了;它的状态完全保存在磁盘上,它被提交
成功的可能性非常高,即使是在请求提交之前数据库发生了崩溃也如此。
一旦准备好了,一个事务就可以在稍后用16.14.43 COMMIT PREPARED或 16.14.125
ROLLBACK PREPARED命令分别进行提交或者回滚。这些命令可以从任何会话中发
出,而不光是最初执行事务的那个会话。
从发出命令的会话的角度来看,PREPARE TRANSACTION不同于ROLLBACK:在执
行它之后,就不再有活跃的当前事务了,并且预备事务的效果无法见到 (在事务提交的
时候其效果会再次可见)。
如果PREPARE TRANSACTION因为某些原因失败,那么它就会变成一个
ROLLBACK,当前事务被取消。
注意事项
l 事务功能由数据库自动维护,不应显式使用事务功能。
l 在运行PREPARE TRANSACTION命令时,必须在postgresql.conf配置文件中增大
max_prepared_transactions的数值。建议至少将其设置为等于max_connections,这
样每个会话都可以有一个等待中的预备事务。
语法格式
PREPARE TRANSACTION transaction_id;
参数说明
transaction_id
待提交事务的标识符,用于后面在COMMIT PREPARED或ROLLBACK PREPARED的
时候标识这个事务。它不能和任何当前预备事务已经使用了的标识符同名。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
950GaussDB 200
开发者指南
16 SQL 参考
取值范围:标识符必须以字符串文本的方式书写,并且必须小于200字节长。
相关链接
16.14.43 COMMIT PREPARED,16.14.125 ROLLBACK PREPARED
16.14.119 REASSIGN OWNED
功能描述
修改数据库对象的属主。
REASSIGN OWNED要求系统将所有old_roles拥有的数据库对象的属主更改为
new_role。
注意事项
l REASSIGN OWNED常用于在删除角色之前的准备工作。
l 执行REASSIGN OWNED需要有原角色和目标角色上的权限。
语法格式
REASSIGN OWNED BY old_role [, ...] TO new_role;
参数说明
l
old_role
旧属主的角色名。
l
new_role
将要成为这些对象属主的新角色的名字。
示例
无。
16.14.120 REINDEX
功能描述
为表中的数据重建索引。
在以下几种情况下需要使用REINDEX重建索引:
l 索引崩溃,并且不再包含有效的数据。
l 索引变得“臃肿”,包含大量的空页或接近空页。
l 为索引更改了存储参数(例如填充因子),并且希望这个更改完全生效。
使用CONCURRENTLY选项创建索引失败,留下了一个“非法”索引。
注意事项
REINDEX DATABASE和SYSTEM这种形式的重建索引不能在事务块中执行。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
951GaussDB 200
开发者指南
16 SQL 参考
语法格式
l
重建普通索引。
REINDEX { INDEX | [INTERNAL] TABLE | DATABASE | SYSTEM } name [ FORCE ];
l
重建索引分区。
REINDEX { INDEX| [INTERNAL] TABLE} name
PARTITION partition_name [ FORCE ];
参数说明
l
INDEX
重新建立指定的索引。
l
INTERNAL TABLE
重建列存表或Hadoop内表的Desc表的索引,如果表有从属的"TOAST"表,则这个
表也会重建索引。
l
TABLE
重新建立指定表的所有索引,如果表有从属的"TOAST"表,则这个表也会重建索
引。
l
DATABASE
重建当前数据库里的所有索引。
l
SYSTEM
在当前数据库上重建所有系统表上的索引。不会处理在用户表上的索引。
l
name
需要重建索引的索引、表、数据库的名称。表和索引可以有模式修饰。
说明
REINDEX DATABASE和SYSTEM只能重建当前数据库的索引,所以name必须和当前数据
库名称相同。
l
FORCE
无效选项,会被忽略。
l
partition_name
需要重建索引的分区的名字或者索引分区的名字。
取值范围:
– 如果前面是REINDEX INDEX,则这里应该指定索引分区的名字;
– 如果前面是REINDEX TABLE,则这里应该指定分区的名字;
– 如果前面是REINDEX INTERNAL TABLE,则这里应该指定列存分区表的分
区的名字。
REINDEX DATABASE和SYSTEM这种形式的重建索引不能在事务块中执行。
示例
--创建一个行存表tpcds.customer_t1,并在tpcds.customer_t1表上的c_customer_sk字段创建索引。
CREATE TABLE tpcds.customer_t1
(
c_customer_sk
integer
not null,
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
952GaussDB 200
开发者指南
16 SQL 参考
c_customer_id
c_current_cdemo_sk
c_current_hdemo_sk
c_current_addr_sk
c_first_shipto_date_sk
c_first_sales_date_sk
c_salutation
c_first_name
c_last_name
c_preferred_cust_flag
c_birth_day
c_birth_month
c_birth_year
c_birth_country
c_login
c_email_address
c_last_review_date
char(16)
integer
integer
integer
integer
integer
char(10)
char(20)
char(30)
char(1)
integer
integer
integer
varchar(20)
char(13)
char(50)
char(10)
not null,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
)
WITH (orientation = row)
DISTRIBUTE BY HASH (c_customer_sk);
CREATE INDEX tpcds_customer_index1 ON tpcds.customer_t1 (c_customer_sk);
INSERT INTO tpcds.customer_t1 SELECT * FROM tpcds.customer WHERE c_customer_sk < 10;
--重建一个单独索引。
REINDEX INDEX tpcds.tpcds_customer_index1;
--重建表tpcds.customer_t1上的所有索引。
REINDEX TABLE tpcds.customer_t1;
--删除tpcds.customer_t1表。
DROP TABLE tpcds.customer_t1;
16.14.121 RELEASE SAVEPOINT
功能描述
RELEASE SAVEPOINT删除一个当前事务先前定义的保存点。
把一个保存点删除就令其无法作为回滚点使用,除此之外它没有其它用户可见的行
为。它并不能撤销在保存点建立起来之后执行的命令的影响。要撤销那些命令可以使
用ROLLBACK TO SAVEPOINT 。在不再需要的时候删除一个保存点可以令系统在事
务结束之前提前回收一些资源。
RELEASE SAVEPOINT也删除所有在指定的保存点建立之后的所有保存点。
注意事项
l 不能RELEASE一个没有定义的保存点,语法上会报错。
l 如果事务在回滚状态,则不能释放保存点。
l 如果多个保存点拥有同样的名字,只有最近定义的那个才被释放。
语法格式
RELEASE [ SAVEPOINT ] savepoint_name;
参数说明
savepoint_name
要删除的保存点的名字
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
953GaussDB 200
开发者指南
16 SQL 参考
示例
--创建一个新表。
CREATE TABLE tpcds.table1(a int);
--开启事务。
START TRANSACTION;
--插入数据。
INSERT INTO tpcds.table1 VALUES (3);
--建立保存点。
SAVEPOINT my_savepoint;
--插入数据。
INSERT INTO tpcds.table1 VALUES (4);
--删除保存点。
RELEASE SAVEPOINT my_savepoint;
--提交事务。
COMMIT;
--查询表的内容,会同时看到3和4。
SELECT * FROM tpcds.table1;
--删除表。
DROP TABLE tpcds.table1;
相关链接
16.14.127 SAVEPOINT,16.14.126 ROLLBACK TO SAVEPOINT
16.14.122 RESET
功能描述
RESET将指定的运行时参数恢复为缺省值。这些参数的缺省值是指postgresql.conf配置
文件中所描述的参数缺省值。
RESET命令与如下命令的作用相同:
SET configuration_parameter TO DEFAULT
注意事项
RESET的事务性行为和SET相同:它的影响将会被事务回滚撤销。
语法格式
RESET {configuration_parameter | CURRENT_SCHEMA | TIME ZONE | TRANSACTION ISOLATION LEVEL |
SESSION AUTHORIZATION | ALL };
参数说明
l
configuration_parameter
运行时参数的名称。
取值范围:可以使用SHOW ALL命令查看运行时参数。
说明
部分通过SHOW ALL查看的参数不能通过SET设置。如max_datanodes。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
954GaussDB 200
开发者指南
16 SQL 参考
l
CURRENT_SCHEMA
当前模式
l
TIME ZONE
时区。
l
TRANSACTION ISOLATION LEVEL
事务的隔离级别。
l
SESSION AUTHORIZATION
当前会话的用户标识符。
l
ALL
所有运行时参数。
示例
--把timezone设为缺省值。
RESET timezone;
--把所有参数设置为缺省值。
RESET ALL;
相关链接
16.14.130 SET,16.14.135 SHOW
16.14.123 REVOKE
功能描述
REVOKE用于撤销一个或多个角色的权限。
注意事项
非对象所有者试图在对象上REVOKE权限,命令按照以下规则执行:
l 如果授权用户没有该对象上的权限,则命令立即失败。
l 如果授权用户有部分权限,则只撤销那些有授权选项的权限。
l 如果授权用户没有授权选项,REVOKE ALL PRIVILEGES形式将发出一个错误信
息,而对于其他形式的命令而言,如果是命令中指定名字的权限没有相应的授权
选项,该命令将发出一个警告。
l 不允许对表分区进行REVOKE操作,对分区表进行REVOKE操作会引起告警。
语法格式
l
回收指定表和视图上权限。
REVOKE [ GRANT OPTION FOR ]
{ { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES }[, ...]
| ALL [ PRIVILEGES ] }
ON { [ TABLE ] table_name [, ...]
| ALL TABLES IN SCHEMA schema_name [, ...] }
FROM { [ GROUP ] role_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ];
l
回收表上指定字段权限。
REVOKE [ GRANT OPTION FOR ]
{ {{ SELECT | INSERT | UPDATE | REFERENCES } ( column_name [, ...] )}[, ...]
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
955GaussDB 200
开发者指南
16 SQL 参考
| ALL [ PRIVILEGES ] ( column_name [, ...] ) }
ON [ TABLE ] table_name [, ...]
FROM { [ GROUP ] role_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ];
l
回收指定数据库上权限。
REVOKE [ GRANT OPTION FOR ]
{ { CREATE | CONNECT | TEMPORARY | TEMP } [, ...]
| ALL [ PRIVILEGES ] }
ON DATABASE database_name [, ...]
FROM { [ GROUP ] role_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ];
l
回收指定函数上权限。
REVOKE [ GRANT OPTION FOR ]
{ EXECUTE | ALL [ PRIVILEGES
ON { FUNCTION {function_name
| ALL FUNCTIONS IN SCHEMA
FROM { [ GROUP ] role_name |
[ CASCADE | RESTRICT ];
l
] }
( [ {[ argmode ] [ arg_name ] arg_type} [, ...] ] )} [, ...]
schema_name [, ...] }
PUBLIC } [, ...]
回收指定大对象上权限。
REVOKE [ GRANT OPTION FOR ]
{ { SELECT | UPDATE } [, ...] | ALL [ PRIVILEGES ] }
ON LARGE OBJECT loid [, ...]
FROM { [ GROUP ] role_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ];
l
回收指定模式上权限。
REVOKE [ GRANT OPTION FOR ]
{ { CREATE | USAGE } [, ...] | ALL [ PRIVILEGES ] }
ON SCHEMA schema_name [, ...]
FROM { [ GROUP ] role_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ];
l
回收指定表空间上权限。
REVOKE [ GRANT OPTION FOR ]
{ CREATE | ALL [ PRIVILEGES ] }
ON TABLESPACE tablespace_name [, ...]
FROM { [ GROUP ] role_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ];
l
回收指定子集群上权限
REVOKE [ GRANT OPTION FOR ]
{ CREATE | USAGE | COMPUTE | ALL [ PRIVILEGES ] }
ON NODE GROUP group_name [, ...]
FROM { [ GROUP ] role_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ];
l
按角色回收角色上的权限。
REVOKE [ ADMIN OPTION FOR ]
role_name [, ...] FROM role_name [, ...]
[ CASCADE | RESTRICT ];
l
回收角色上的sysadmin权限。
REVOKE ALL { PRIVILEGES | PRIVILEGE } FROM role_name;
l
回收Data Source对象上的权限。
REVOKE {USAGE | ALL [PRIVILEGES]}
ON DATA SOURCE src_name [, ...]
FROM {[GROUP] role_name | PUBLIC} [, ...];
l
回收directory对象的权限。
REVOKE {READ|WRITE| ALL [PRIVILEGES]}
ON DIRECTORY src_name [, ...]
FROM {[GROUP] role_name | PUBLIC} [, ...] [WITH GRANT OPTION];
参数说明
关键字PUBLIC表示一个隐式定义的拥有所有角色的组。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
956GaussDB 200
开发者指南
16 SQL 参考
权限类别和参数说明,请参见GRANT的参数说明。
任何特定角色拥有的特权包括直接授予该角色的特权、从该角色作为其成员的角色中
得到的权限以及授予给PUBLIC的权限。因此,从PUBLIC收回SELECT特权并不一定会
意味着所有角色都会失去在该对象上的SELECT特权,那些直接被授予的或者通过另一
个角色被授予的角色仍然会拥有它。类似地,从一个用户收回SELECT后,如果
PUBLIC仍有SELECT权限,该用户还是可以使用SELECT。
指定GRANT OPTION FOR时,只撤销对该权限授权的权力,而不撤销该权限本身。
如用户A拥有某个表的UPDATE权限,及WITH GRANT OPTION选项,同时A把这个权
限赋予了用户B,则用户B持有的权限称为依赖性权限。当用户A持有的权限或者授权
选项被撤销时,依赖性权限仍然存在,但如果声明了CASCADE,则所有依赖性权限都
被撤销。
一个用户只能撤销由它自己直接赋予的权限。例如,如果用户A被指定授权(WITH
ADMIN OPTION)选项,且把一个权限赋予了用户B,然后用户B又赋予了用户C,则
用户A不能直接将C的权限撤销。但是,用户A可以撤销用户B的授权选项,并且使用
CASCADE。这样,用户C的权限就会自动被撤销。另外一个例子:如果A和B都赋予了
C同样的权限,则A可以撤销他自己的授权选项,但是不能撤销B的,因此C仍然拥有该
权限。
如果执行REVOKE的角色持有的权限是通过多层成员关系获得的,则具体是哪个包含
的角色执行的该命令是不确定的。在这种场合下,最好的方法是使用SET ROLE成为特
定角色,然后执行REVOKE,否则可能导致删除了不想删除的权限,或者是任何权限
都没有删除。
示例
请参考GRANT的示例。
相关链接
16.14.112 GRANT
16.14.124 ROLLBACK
功能描述
回滚当前事务并取消当前事务中的所有更新。
在事务运行的过程中发生了某种故障,事务不能继续执行,系统将事务中对数据库的
所有已完成的操作全部撤销,数据库状态回到事务开始时。
注意事项
如果不在一个事务内部发出ROLLBACK不会有问题,但是将抛出一个警告信息。
语法格式
ROLLBACK [ WORK | TRANSACTION ];
参数说明
WORK | TRANSACTION
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
957GaussDB 200
开发者指南
16 SQL 参考
可选关键字。除了增加可读性,没有任何其他作用。
示例
--开启一个事务
START TRANSACTION;
--取消所有更改
ROLLBACK;
相关链接
16.14.42 COMMIT | END
16.14.125 ROLLBACK PREPARED
功能描述
取消一个先前为两阶段提交准备好的事务。
注意事项
l 该功能仅在维护模式(GUC参数xc_maintenance_mode为on时)下可用。该模式谨慎
打开,一般供维护人员排查问题使用,一般用户不应使用该模式。
l 要想回滚一个预备事务,必须是最初发起事务的用户,或者是系统管理员。
l 事务功能由数据库自动维护,不应显式使用事务功能。
语法格式
ROLLBACK PREPARED transaction_id ;
参数说明
transaction_id
待提交事务的标识符。它不能和任何当前预备事务已经使用了的标识符同名。
相关链接
16.14.43 COMMIT PREPARED,16.14.118 PREPARE TRANSACTION。
16.14.126 ROLLBACK TO SAVEPOINT
功能描述
ROLLBACK TO SAVEPOINT用于回滚到一个保存点,隐含地删除所有在该保存点之后
建立的保存点。
回滚所有指定保存点建立之后执行的命令。保存点仍然有效,并且需要时可以再次回
滚到该点。
注意事项
l
不能回滚到一个未定义的保存点,语法上会报错。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
958GaussDB 200
开发者指南
16 SQL 参考
l 在保存点方面,游标有一些非事务性的行为。任何在保存点里打开的游标都会在
回滚掉这个保存点之后关闭。如果一个前面打开了的游标在保存点里面,并且游
标被一个FETCH命令影响,而这个保存点稍后回滚了,那么这个游标的位置仍然
在FETCH让它指向的位置(也就是FETCH不会被回滚)。关闭一个游标的行为也不
会被回滚给撤消掉。如果一个游标的操作导致事务回滚,那么这个游标就会置于
不可执行状态,所以,尽管一个事务可以用ROLLBACK TO SAVEPOINT重新恢
复,但是游标不能再使用了。
l 使用ROLLBACK TO SAVEPOINT回滚到一个保存点。使用RELEASE SAVEPOINT
删除一个保存点,但是保留该保存点建立后执行的命令的效果。
语法格式
ROLLBACK [ WORK | TRANSACTION ] TO [ SAVEPOINT ] savepoint_name;
参数说明
savepoint_name
回滚截至的保存点
示例
--撤销 my_savepoint 建立之后执行的命令的影响。
START TRANSACTION;
SAVEPOINT my_savepoint;
ROLLBACK TO SAVEPOINT my_savepoint;
--游标位置不受保存点回滚的影响。
DECLARE foo CURSOR FOR SELECT 1 UNION SELECT 2;
SAVEPOINT foo;
FETCH 1 FROM foo;
?column?
----------
1
ROLLBACK TO SAVEPOINT foo;
FETCH 1 FROM foo;
?column?
----------
2
RELEASE SAVEPOINT my_savepoint;
COMMIT;
相关链接
16.14.127 SAVEPOINT,16.14.121 RELEASE SAVEPOINT
16.14.127 SAVEPOINT
功能描述
SAVEPOINT用于在当前事务里建立一个新的保存点。
保存点是事务中的一个特殊记号,它允许将那些在它建立后执行的命令全部回滚,把
事务的状态恢复到保存点所在的时刻。
注意事项
l
使用ROLLBACK TO SAVEPOINT回滚到一个保存点。使用RELEASE SAVEPOINT
删除一个保存点,但是保留该保存点建立后执行的命令的效果。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
959GaussDB 200
开发者指南
16 SQL 参考
l 保存点只能在一个事务块里面建立。在一个事务里面可以定义多个保存点。
l 函数、匿名块和存储过程中不支持使用SAVEPOINT语法。
l 由于节点故障或者通信故障引起的分布式节点线程或进程退出导致的报错,以及
由于COPY FROM操作中源数据与目标表的表结构不一致导致的报错,均不能正常
回滚到保存点之前,而是整个事务回滚。
l SQL标准要求,使用savepoint建立一个同名保存点时,需要自动删除前面那个同名
保存点。在GaussDB 200数据库里,我们将保留旧的保存点,但是在回滚或者释放
的时候,只使用最近的那个。释放了新的保存点将导致旧的再次成为ROLLBACK
TO SAVEPOINT和RELEASE SAVEPOINT可以访问的保存点。除此之外,
SAVEPOINT是完全符合SQL标准的。
语法格式
SAVEPOINT savepoint_name;
参数说明
savepoint_name
新建保存点的名字。
示例
--创建一个新表。
CREATE TABLE table1(a int);
--开启事务。
START TRANSACTION;
--插入数据。
INSERT INTO table1 VALUES (1);
--建立保存点。
SAVEPOINT my_savepoint;
--插入数据。
INSERT INTO table1 VALUES (2);
--回滚保存点。
ROLLBACK TO SAVEPOINT my_savepoint;
--插入数据。
INSERT INTO table1 VALUES (3);
--提交事务。
COMMIT;
--查询表的内容,会同时看到1和3,不能看到2,因为2被回滚。
SELECT * FROM table1;
--删除表。
DROP TABLE table1;
--创建一个新表。
CREATE TABLE table2(a int);
--开启事务。
START TRANSACTION;
--插入数据。
INSERT INTO table2 VALUES (3);
--建立保存点。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
960GaussDB 200
开发者指南
16 SQL 参考
SAVEPOINT my_savepoint;
--插入数据。
INSERT INTO table2 VALUES (4);
--回滚保存点。
RELEASE SAVEPOINT my_savepoint;
--提交事务。
COMMIT;
--查询表的内容,会同时看到3和4。
SELECT * FROM table2;
--删除表。
DROP TABLE table2;
相关链接
16.14.121 RELEASE SAVEPOINT,16.14.126 ROLLBACK TO SAVEPOINT
16.14.128 SELECT
功能描述
SELECT用于从表或视图中取出数据。
SELECT语句就像叠加在数据库表上的过滤器,利用SQL关键字从数据表中过滤出用户
需要的数据。
注意事项
l SELECT支持普通表和HDFS的Join,不支持普通表和GDS外表的join。即SELECT
语句中不能同时出现普通表和GDS外表。
l 必须对每个在SELECT命令中使用的字段有SELECT权限。
l 使用FOR UPDATE或FOR SHARE还要求UPDATE权限。
l 查询数据
语法格式
[ WITH [ RECURSIVE ] with_query [, ...] ]
SELECT [/*+ plan_hint */] [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
{ * | {expression [ [ AS ] output_name ]} [, ...] }
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [, ...] ]
[ HAVING condition [, ...] ]
[ WINDOW {window_name AS ( window_definition )} [, ...] ]
[ { UNION | INTERSECT | EXCEPT | MINUS } [ ALL | DISTINCT ] select ]
[ ORDER BY {expression [ [ ASC | DESC | USING operator ] | nlssort_expression_clause ] [ NULLS
{ FIRST | LAST } ]} [, ...] ]
[ LIMIT { count | ALL } ]
[ OFFSET start [ ROW | ROWS ] ]
[ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]
[ {FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ]} [...] ];
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
961GaussDB 200
开发者指南
16 SQL 参考
说明
condition和expression中可以使用targetlist中表达式的别名。
l 只能同一层引用。
l 只能引用targetlist中的别名。
l 只能是后面的表达式引用前面的表达式。
l 不能包含volatile函数。
l 不能包含Window function函数。
l 不支持在join on条件中引用别名。
l targetlist中有多个要应用的别名则报错。
l
其中子查询with_query为:
with_query_name [ ( column_name [, ...] ) ]
AS ( {select | values | insert | update | delete} )
l
其中指定查询源from_item为:
{[ ONLY ] table_name [ * ] [ partition_clause ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]
[ TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ] ]
|( select ) [ AS ] alias [ ( column_alias [, ...] ) ]
|with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]
|function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] |
column_definition [, ...] ) ]
|function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )
|from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column
[, ...] ) ]}
l
其中group子句为:
(
|
|
|
|
|
l
)
expression
( expression [, ...] )
ROLLUP ( { expression | ( expression [, ...] ) } [, ...] )
CUBE ( { expression | ( expression [, ...] ) } [, ...] )
GROUPING SETS ( grouping_element [, ...] )
其中指定分区partition_clause为:
PARTITION { ( partition_name ) |
FOR ( partition_value [, ...] ) }
说明
指定分区只适合普通表。
l
其中设置排序方式nlssort_expression_clause为:
NLSSORT ( column_name, ' NLS_SORT = { SCHINESE_PINYIN_M | generic_m_ci } ' )
l
简化版查询语法,功能相当于select * from table_name。
TABLE { ONLY {(table_name)| table_name} | table_name [ * ]};
参数说明
l
WITH [ RECURSIVE ] with_query [, ...]
用于声明一个或多个可以在主查询中通过名字引用的子查询,相当于临时表。
如果声明了RECURSIVE,那么允许SELECT子查询通过名字引用它自己。
其中with_query的详细格式为:with_query_name [ ( column_name [, ...] ) ] AS
( {select | values | insert | update | delete} )
l
– with_query_name指定子查询生成的结果集名字,在查询中可使用该名称访问
子查询的结果集。
– column_name指定子查询结果集中显示的列名。
– 每个子查询可以是SELECT,VALUES,INSERT,UPDATE或DELETE语句。
plan_hint子句
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
962GaussDB 200
开发者指南
16 SQL 参考
以/*+ */的形式在SELECT关键字后,用于对SELECT对应的语句块生成的计划进行
hint调优,详细用法请参见章节14.4.9 使用Plan Hint进行调优。
l
ALL
声明返回所有符合条件的行,是默认行为,可以省略该关键字。
l
DISTINCT [ ON ( expression [, ...] ) ]
从SELECT的结果集中删除所有重复的行,使结果集中的每行都是唯一的。
ON ( expression [, ...] ) 只保留那些在给出的表达式上运算出相同结果的行集合中的
第一行。
DISTINCT ON表达式是使用与ORDER BY相同的规则进行解释的。除非使用了
ORDER BY来保证需要的行首先出现,否则,"第一行" 是不可预测的。
l
SELECT列表
指定查询表中列名,可以是部分列或者是全部(使用通配符*表示)。
通过使用子句AS output_name可以为输出字段取个别名,这个别名通常用于输出字
段的显示。
列名可以用下面几种形式表达:
l
– 手动输入列名,多个列之间用英文逗号(,)分隔。
– 可以是FROM子句里面计算出来的字段。
FROM子句
为SELECT声明一个或者多个源表。
FROM子句涉及的元素如下所示。
–
table_name
表名或视图名,名称前可加上模式名,如:schema_name.table_name。
–
alias
给表或复杂的表引用起一个临时的表别名,以便被其余的查询引用。
别名用于缩写或者在自连接中消除歧义。如果提供了别名,它就会完全隐藏
表的实际名字。
–
TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ]
table_name之后的TABLESAMPLE子句表示应该用指定的sampling_method来
检索表中行的子集。
可选的REPEATABLE子句指定一个用于产生采样方法中随机数的 种子 数。种
子值可以是任何非空常量值。如果查询时表没有被更改,指定相同种子和
argument值的两个查询将会选择该表相同的采样。但是不同的种子值通常将
会产生不同的采样。如果没有给出REPEATABLE,则会基于一个系统产生的
种子为每一个查询选择一个新的随机采样。
–
column_alias
列别名
–
PARTITION
查询分区表的某个分区的数据。
–
partition_name
分区名。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
963GaussDB 200
开发者指南
16 SQL 参考
–
partition_value
指定的分区键值。在创建分区表时,如果指定了多个分区键,可以通过
PARTITION FOR子句指定的这一组分区键的值,唯一确定一个分区。
–
subquery
FROM子句中可以出现子查询,创建一个临时表保存子查询的输出。
–
with_query_name
WITH子句同样可以作为FROM子句的源,可以通过WITH查询的名字对其进
行引用。
–
function_name
函数名称。函数调用也可以出现在FROM子句中。
–
join_type
有5种类型,如下所示。
n
[ INNER ] JOIN
一个JOIN子句组合两个FROM项。可使用圆括弧以决定嵌套的顺序。如
果没有圆括弧,JOIN从左向右嵌套。
在任何情况下,JOIN都比逗号分隔的FROM项绑定得更紧。
n
LEFT [ OUTER ] JOIN
返回笛卡尔积中所有符合连接条件的行,再加上左表中通过连接条件没
有匹配到右表行的那些行。这样,左边的行将扩展为生成表的全长,方
法是在那些右表对应的字段位置填上NULL。请注意,只在计算匹配的时
候,才使用JOIN子句的条件,外层的条件是在计算完毕之后施加的。
n
RIGHT [ OUTER ] JOIN
返回所有内连接的结果行,加上每个不匹配的右边行(左边用NULL扩
展)。
这只是一个符号上的方便,因为总是可以把它转换成一个LEFT OUTER
JOIN,只要把左边和右边的输入互换位置即可。
n
FULL [ OUTER ] JOIN
返回所有内连接的结果行,加上每个不匹配的左边行(右边用NULL扩
展),再加上每个不匹配的右边行(左边用NULL扩展)。
n
CROSS JOIN
CROSS JOIN等效于INNER JOIN ON(TRUE) ,即没有被条件删除的
行。这种连接类型只是符号上的方便,因为它们与简单的FROM和
WHERE的效果相同。
说明
必须为INNER和OUTER连接类型声明一个连接条件,即NATURAL ON,
join_condition,USING (join_column [, ...]) 之一。但是它们不能出现在CROSS
JOIN中。
其中CROSS JOIN和INNER JOIN生成一个简单的笛卡尔积,和在FROM的顶
层列出两个项的结果相同。
–
ON join_condition
连接条件,用于限定连接中的哪些行是匹配的。如:ON left_table.a =
right_table.a。
–
USING(join_column[,...])
ON left_table.a = right_table.a AND left_table.b = right_table.b ... 的简写。要求
对应的列必须同名。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
964GaussDB 200
开发者指南
16 SQL 参考
–
NATURAL
NATURAL是具有相同名称的两个表的所有列的USING列表的简写。
–
from item
用于连接的查询源对象的名称。
l
WHERE子句
WHERE子句构成一个行选择表达式,用来缩小SELECT查询的范围。condition是
返回值为布尔型的任意表达式,任何不满足该条件的行都不会被检索。
WHERE子句中可以通过指定"(+)"操作符的方法将表的连接关系转换为外连接。但
是不建议用户使用这种用法,因为这并不是SQL的标准语法,在做平台迁移的时
候可能面临语法兼容性的问题。同时,使用"(+)"有很多限制:
a. "(+)"只能出现在where子句中。
b. 如果from子句中已经有指定表连接关系,那么不能再在where子句中使用
"(+)"。
c. "(+)"只能作用在表或者视图的列上,不能作用在表达式上。
d. 如果表A和表B有多个连接条件,那么必须在所有的连接条件中指定"(+)",否
则"(+)"将不会生效,表连接会转化成内连接,并且不给出任何提示信息。
e. "(+)"作用的连接条件中的表不能跨查询或者子查询。如果"(+)"作用的表,不
在当前查询或者子查询的from子句中,则会报错。如果"(+)"作用的对端的表
不存在,则不报错,同时连接关系会转化为内连接。
f. "(+)"作用的表达式不能直接通过"OR"连接。
g. 如果"(+)"作用的列是和一个常量的比较关系, 那么这个表达式会成为join条
件的一部分。
h. 同一个表不能对应多个外表。
i. "(+)"只能出现"比较表达式","NOT表达式",“ANY表达式”,“ALL表达
式”,“IN表达式”,“NULLIF表达式”,“IS DISTINCT FROM表达
式”,“IS OF”表达式。"(+)"不能出现在其他类型表达式中,并且这些表达
式中不允许出现通过“AND”和“OR”连接的表达式。
j. "(+)"只能转化为左外连接或者右外连接,不能转化为全连接,即不能在一个
表达式的两个表上同时指定"(+)"
对于WHERE子句的LIKE操作符,当LIKE中要查询特殊字符“%”、“_”、“\”
的时候需要使用反斜杠“\”来进行转义。
l
GROUP BY子句
将查询结果按某一列或多列的值分组,值相等的为一组。
–
CUBE ( { expression | ( expression [, ...] ) } [, ...] )
CUBE是自动对group by子句中列出的字段进行分组汇总,结果集将包含维度
列中各值的所有可能组合,以及与这些维度值组合相匹配的基础行中的聚合
值。它会为每个分组返回一行汇总信息, 用户可以使用CUBE来产生交叉表
值。比如,在CUBE子句中给出三个表达式(n = 3),运算结果为2 n = 2 3 = 8
组。 以n个表达式的值分组的行称为常规行,其余的行称为超级聚集行。
–
GROUPING SETS ( grouping_element [, ...] )
GROUPING SETS子句是GROUP BY子句的进一步扩展,它可以使用户指定
多个GROUP BY选项。 这样做可以通过裁剪用户不需要的数据组来提高效
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
965GaussDB 200
开发者指南
16 SQL 参考
率。 当用户指定了所需的数据组时,数据库不需要执行完整CUBE或
ROLLUP生成的聚合集合。
如果SELECT列表的表达式中引用了那些没有分组的字段,则会报错,除非使用了
聚集函数,因为对于未分组的字段,可能返回多个数值。
l
HAVING子句
与GROUP BY子句配合用来选择特殊的组。HAVING子句将组的一些属性与一个
常数值比较,只有满足HAVING子句中的逻辑表达式的组才会被提取出来。
l
WINDOW子句
一般形式为WINDOW window_name AS ( window_definition ) [, ...],
window_name是可以被随后的窗口定义所引用的名称,window_definition可以是以
下的形式:
[ existing_window_name ]
[ PARTITION BY expression [, ...] ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST |
LAST } ] [, ...] ]
[ frame_clause ]
frame_clause为窗函数定义一个窗口框架window frame,窗函数(并非所有)依赖
于框架,window frame是当前查询行的一组相关行。frame_clause可以是以下的形
式:
[ RANGE | ROWS ] frame_start
[ RANGE | ROWS ] BETWEEN frame_start AND frame_end
frame_start和frame_end可以是:
UNBOUNDED PRECEDING
value PRECEDING
CURRENT ROW
value FOLLOWING
UNBOUNDED FOLLOWING
对列存表的查询目前只支持row_number窗口函数,不支持frame_clause。
l
UNION子句
UNION计算多个SELECT语句返回行集合的并集。
UNION子句有如下约束条件:
– 除非声明了ALL子句,否则缺省的UNION结果不包含重复的行。
– 同一个SELECT语句中的多个UNION操作符是从左向右计算的,除非用圆括
弧进行了标识。
– FOR UPDATE不能在UNION的结果或输入中声明。
一般表达式:
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
966GaussDB 200
开发者指南
16 SQL 参考
select_statement UNION [ALL] select_statement
l
– select_statement可以是任何没有ORDER BY、LIMIT、FOR UPDATE子句的
SELECT语句。
– 如果用圆括弧包围,ORDER BY和LIMIT可以附着在子表达式里。
INTERSECT子句
INTERSECT计算多个SELECT语句返回行集合的交集,不含重复的记录。
INTERSECT子句有如下约束条件:
– 同一个SELECT语句中的多个INTERSECT操作符是从左向右计算的,除非用
圆括弧进行了标识。
– 当对多个SELECT语句的执行结果进行UNION和INTERSECT操作的时候,会
优先处理INTERSECT。
一般形式:
select_statement INTERSECT select_statement
select_statement可以是任何没有FOR UPDATE子句的SELECT语句。
l
EXCEPT子句
EXCEPT子句有如下的通用形式:
select_statement EXCEPT [ ALL ] select_statement
select_statement是任何没有FOR UPDATE子句的SELECT表达式。
EXCEPT操作符计算存在于左边SELECT语句的输出而不存在于右边SELECT语句
输出的行。
EXCEPT的结果不包含任何重复的行,除非声明了ALL选项。使用ALL时,一个在
左边表中有m个重复而在右边表中有n个重复的行将在结果中出现max(m-n,0) 次。
除非用圆括弧指明顺序,否则同一个SELECT语句中的多个EXCEPT操作符是从左
向右计算的。EXCEPT和UNION的绑定级别相同。
目前,不能给EXCEPT的结果或者任何EXCEPT的输入声明FOR UPDATE子句。
l
MINUS子句
与EXCEPT子句具有相同的功能和用法。
l
ORDER BY子句
对SELECT语句检索得到的数据进行升序或降序排序。对于ORDER BY表达式中包
含多列的情况:
– 首先根据最左边的列进行排序,如果这一列的值相同,则根据下一个表达式
进行比较,依此类推。
– 如果对于所有声明的表达式都相同,则按随机顺序返回。
– ORDER BY中排序的列必须包括在SELECT语句所检索的结果集的列中。
如果要支持中文拼音排序和不区分大小写排序,需要在初始化数据库时指定编码
格式为UTF-8或GBK。 命令如下:
initdb –E UTF8 –D ../data –locale=zh_CN.UTF-8或initdb –E GBK –D ../data –
locale=zh_CN.GBK。
l
LIMIT子句
LIMIT子句由两个独立的子句组成:
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
967GaussDB 200
开发者指南
16 SQL 参考
LIMIT { count | ALL }
OFFSET start count声明返回的最大行数,而start声明开始返回行之前忽略的行
数。如果两个都指定了,会在开始计算count个返回行之前先跳过start行。
l
OFFSET子句
SQL:2008开始提出一种不同的语法:
OFFSET start { ROW | ROWS }
start声明开始返回行之前忽略的行数。
l
FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY
如果不指定count,默认值为1,FETCH子句限定返回查询结果从第一行开始的总
行数。
l
FOR UPDATE子句
FOR UPDATE子句将对SELECT检索出来的行进行加锁。这样避免它们在当前事务
结束前被其他事务修改或者删除,即其他企图UPDATE、 DELETE、 SELECT
FOR UPDATE这些行的事务将被阻塞,直到当前事务结束。
为了避免操作等待其他事务提交,可使用NOWAIT选项,如果被选择的行不能立
即被锁住,执行SELECT FOR UPDATE NOWAIT将会立即汇报一个错误,而不是
等待。
FOR SHARE的行为类似,只是它在每个检索出来的行上要求一个共享锁,而不是
一个排他锁。一个共享锁阻塞其它事务执行UPDATE、DELETE、SELECT,不阻
塞SELECT FOR SHARE。
如果在FOR UPDATE或FOR SHARE中明确指定了表名字,则只有这些指定的表被
锁定,其他在SELECT中使用的表将不会被锁定。否则,将锁定该命令中所有使用
的表。
如果FOR UPDATE或FOR SHARE应用于一个视图或者子查询,它同样将锁定所有
该视图或子查询中使用到的表。
多个FOR UPDATE和FOR SHARE子句可以用于为不同的表指定不同的锁定模式。
如果一个表中同时出现(或隐含同时出现)在FOR UPDATE和FOR SHARE子句
中,则按照FOR UPDATE处理。类似的,如果影响一个表的任意子句中出现了
NOWAIT,该表将按照NOWAIT处理。
l 对于for update/share,执行计划不能下推的SQL,直接返回报错信息;对于执行
计划可以下推的,下推到DN执行。
l 对列存表的查询不支持for update/share。
l
NLS_SORT
指定某字段按照特殊方式排序。目前仅支持中文拼音格式排序和不区分大小写排
序。
取值范围:
l
– SCHINESE_PINYIN_M,按照中文拼音排序。如果要支持此排序方式,在创
建数据库时需要指定编码格式为“GBK”,否则排序无效。
– generic_m_ci,不区分大小写排序。
PARTITION子句
查询某个分区表中相应分区的数据。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
968GaussDB 200
开发者指南
16 SQL 参考
示例
--先通过子查询得到一张临时表temp_t,然后查询表temp_t中的所有数据。
WITH temp_t(name,isdba) AS (SELECT usename,usesuper FROM pg_user) SELECT * FROM temp_t;
--查询tpcds.reason表的所有r_reason_sk记录,且去除重复。
SELECT DISTINCT(r_reason_sk) FROM tpcds.reason;
--LIMIT子句示例:获取表中一条记录。
SELECT * FROM tpcds.reason LIMIT 1;
--查询所有记录,且按字母升序排列。
SELECT r_reason_desc FROM tpcds.reason ORDER BY r_reason_desc;
--通过表别名,从pg_user和pg_user_status这两张表中获取数据。
SELECT a.usename,b.locktime FROM pg_user a,pg_user_status b WHERE a.usesysid=b.roloid;
--FULL JOIN子句示例:将pg_user和pg_user_status这两张表的数据进行全连接显示,即数据的合集。
SELECT a.usename,b.locktime,a.usesuper FROM pg_user a FULL JOIN pg_user_status b on
a.usesysid=b.roloid;
--GROUP BY子句示例:根据查询条件过滤,并对结果进行分组。
SELECT r_reason_id, AVG(r_reason_sk) FROM tpcds.reason GROUP BY r_reason_id HAVING
AVG(r_reason_sk) > 25;
--GROUP BY CUBE子句示例:根据查询条件过滤,并对结果进行分组汇总。
SELECT r_reason_id,AVG(r_reason_sk) FROM tpcds.reason GROUP BY CUBE(r_reason_id,r_reason_sk);
--GROUP BY GROUPING SETS子句示例:根据查询条件过滤,并对结果进行分组汇总。
SELECT r_reason_id,AVG(r_reason_sk) FROM tpcds.reason GROUP BY GROUPING
SETS((r_reason_id,r_reason_sk),r_reason_sk);
--UNION子句示例:将表tpcds.reason里r_reason_desc字段中的内容以W开头和以N开头的进行合并。
SELECT r_reason_sk, tpcds.reason.r_reason_desc
FROM tpcds.reason
WHERE tpcds.reason.r_reason_desc LIKE 'W%'
UNION
SELECT r_reason_sk, tpcds.reason.r_reason_desc
FROM tpcds.reason
WHERE tpcds.reason.r_reason_desc LIKE 'N%';
--NLS_SORT子句示例:中文拼音排序。
SELECT * FROM tpcds.reason ORDER BY NLSSORT( r_reason_desc, 'NLS_SORT = SCHINESE_PINYIN_M');
--不区分大小写排序:
SELECT * FROM tpcds.reason ORDER BY NLSSORT( r_reason_desc, 'NLS_SORT = generic_m_ci');
--创建分区表tpcds.reason_p
CREATE TABLE tpcds.reason_p
(
r_reason_sk integer,
r_reason_id character(16),
r_reason_desc character(100)
)
PARTITION BY RANGE (r_reason_sk)
(
partition P_05_BEFORE values less than (05),
partition P_15 values less than (15),
partition P_25 values less than (25),
partition P_35 values less than (35),
partition P_45_AFTER values less than (MAXVALUE)
)
;
--插入数据。
INSERT INTO tpcds.reason_p values(3,'AAAAAAAABAAAAAAA','reason 1'),(10,'AAAAAAAABAAAAAAA','reason
2'),(4,'AAAAAAAABAAAAAAA','reason 3'),(10,'AAAAAAAABAAAAAAA','reason 4'),
(10,'AAAAAAAABAAAAAAA','reason 5'),(20,'AAAAAAAACAAAAAAA','reason 6'),
(30,'AAAAAAAACAAAAAAA','reason 7');
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
969GaussDB 200
开发者指南
16 SQL 参考
--PARTITION子句示例:从tpcds.reason_p的表分区P_05_BEFORE中获取数据。
SELECT * FROM tpcds.reason_p PARTITION (P_05_BEFORE);
r_reason_sk |
r_reason_id
|
r_reason_desc
-------------+------------------+------------------------------------
4 | AAAAAAAABAAAAAAA | reason 3
3 | AAAAAAAABAAAAAAA | reason 1
(2 rows)
--GROUP BY子句示例:按r_reason_id分组统计tpcds.reason_p表中的记录数。
SELECT COUNT(*),r_reason_id FROM tpcds.reason_p GROUP BY r_reason_id;
count |
r_reason_id
-------+------------------
2 | AAAAAAAACAAAAAAA
5 | AAAAAAAABAAAAAAA
(2 rows)
--GROUP BY CUBE子句示例:根据查询条件过滤,并对查询结果分组汇总。
SELECT * FROM tpcds.reason GROUP BY CUBE (r_reason_id,r_reason_sk,r_reason_desc);
--GROUP BY GROUPING SETS子句示例:根据查询条件过滤,并对查询结果分组汇总。
SELECT * FROM tpcds.reason GROUP BY GROUPING SETS ((r_reason_id,r_reason_sk),r_reason_desc);
--HAVING子句示例:按r_reason_id分组统计tpcds.reason_p表中的记录,并只显示r_reason_id个数大于2的信
息。
SELECT COUNT(*) c,r_reason_id FROM tpcds.reason_p GROUP BY r_reason_id HAVING c>2;
c |
r_reason_id
---+------------------
5 | AAAAAAAABAAAAAAA
(1 row)
--IN子句示例:按r_reason_id分组统计tpcds.reason_p表中的r_reason_id个数,并只显示r_reason_id值为
AAAAAAAABAAAAAAA或AAAAAAAADAAAAAAA的个数。
SELECT COUNT(*),r_reason_id FROM tpcds.reason_p GROUP BY r_reason_id HAVING r_reason_id
IN('AAAAAAAABAAAAAAA','AAAAAAAADAAAAAAA');
count |
r_reason_id
-------+------------------
5 | AAAAAAAABAAAAAAA
(1 row)
--INTERSECT子句示例:查询r_reason_id等于AAAAAAAABAAAAAAA,并且r_reason_sk小于5的信息。
SELECT * FROM tpcds.reason_p WHERE r_reason_id='AAAAAAAABAAAAAAA' INTERSECT SELECT * FROM
tpcds.reason_p WHERE r_reason_sk<5;
r_reason_sk |
r_reason_id
|
r_reason_desc
-------------+------------------+------------------------------------
4 | AAAAAAAABAAAAAAA | reason 3
3 | AAAAAAAABAAAAAAA | reason 1
(2 rows)
--EXCEPT子句示例:查询r_reason_id等于AAAAAAAABAAAAAAA,并且去除r_reason_sk小于4的信息。
SELECT * FROM tpcds.reason_p WHERE r_reason_id='AAAAAAAABAAAAAAA' EXCEPT SELECT * FROM
tpcds.reason_p WHERE r_reason_sk<4;
r_reason_sk |
r_reason_id
|
r_reason_desc
-------------+------------------+------------------------------------
10 | AAAAAAAABAAAAAAA | reason 2
10 | AAAAAAAABAAAAAAA | reason 5
10 | AAAAAAAABAAAAAAA | reason 4
4 | AAAAAAAABAAAAAAA | reason 3
(4 rows)
--通过在where子句中指定"(+)"来实现左连接。
select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where t1.sr_customer_sk
= t2.c_customer_sk(+)
order by 1 desc limit 1;
sr_item_sk | c_customer_id
------------+---------------
18000 |
(1 row)
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
970GaussDB 200
开发者指南
16 SQL 参考
--通过在where子句中指定"(+)"来实现右连接。
select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where
t1.sr_customer_sk(+) = t2.c_customer_sk
order by 1 desc limit 1;
sr_item_sk | c_customer_id
------------+------------------
| AAAAAAAAJNGEBAAA
(1 row)
--通过在where子句中指定"(+)"来实现左连接,并且增加连接条件。
select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where t1.sr_customer_sk
= t2.c_customer_sk(+) and t2.c_customer_sk(+) < 1 order by 1 limit 1;
sr_item_sk | c_customer_id
------------+---------------
1 |
(1 row)
--不支持在where子句中指定"(+)"的同时使用内层嵌套AND/OR的表达式。
select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where
not(t1.sr_customer_sk = t2.c_customer_sk(+) and t2.c_customer_sk(+) < 1);
ERROR: Operator "(+)" can not be used in nesting expression.
LINE 1: ...tomer_id from store_returns t1, customer t2 where not(t1.sr_...
^
--where子句在不支持表达式宏指定"(+)"会报错。
select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where
(t1.sr_customer_sk = t2.c_customer_sk(+))::bool;
ERROR: Operator "(+)" can only be used in common expression.
--where子句在表达式的两边都指定"(+)"会报错。
select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where
t1.sr_customer_sk(+) = t2.c_customer_sk(+);
ERROR: Operator "(+)" can't be specified on more than one relation in one join condition
HINT: "t1", "t2"...are specified Operator "(+)" in one condition.
--删除表。
DROP TABLE tpcds.reason_p;
16.14.129 SELECT INTO
功能描述
SELECT INTO用于根据查询结果创建一个新表,并且将查询到的数据插入到新表中。
数据并不返回给客户端,这一点和普通的SELECT不同。新表的字段具有和SELECT的
输出字段相同的名字和数据类型。
注意事项
CREATE TABLE AS的作用和SELECT INTO类似,且提供了SELECT INTO所提供功能
的超集。建议使用CREATE TABLE AS语法替代SELECT INTO,因为SELECT INTO不
能在存储过程中使用。
语法格式
[ WITH [ RECURSIVE ] with_query [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
{ * | {expression [ [ AS ] output_name ]} [, ...] }
INTO [ UNLOGGED ] [ TABLE ] new_table
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY expression [, ...] ]
[ HAVING condition [, ...] ]
[ WINDOW {window_name AS ( window_definition )} [, ...] ]
[ { UNION | INTERSECT | EXCEPT | MINUS } [ ALL | DISTINCT ] select ]
[ ORDER BY {expression [ [ ASC | DESC | USING operator ] | nlssort_expression_clause ] [ NULLS
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
971GaussDB 200
开发者指南
16 SQL 参考
{ FIRST | LAST } ]} [, ...] ]
[ LIMIT { count | ALL } ]
[ OFFSET start [ ROW | ROWS ] ]
[ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]
[ {FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ]} [...] ];
参数说明
INTO [ UNLOGGED ] [ TABLE ] new_table
UNLOGGED指定表为非日志表。在非日志表中写入的数据不会被写入到预写日志中,
这样就会比普通表快很多。但是,它也是不安全的,非日志表在冲突或异常关机后会
被自动删截。非日志表中的内容也不会被复制到备用服务器中。在该类表中创建的索
引也不会被自动记录。
new_table指定新建表的名字。
说明
SELECT INTO的其它参数可参考SELECT的参数说明。
示例
--将tpcds.reason表中r_reason_sk小于5的值加入到新建表中。
SELECT * INTO tpcds.reason_t1 FROM tpcds.reason WHERE r_reason_sk < 5;
INSERT 0 6
--删除tpcds.reason_t1表。
DROP TABLE tpcds.reason_t1;
相关链接
16.14.128 SELECT
16.14.130 SET
功能描述
用于修改运行时配置参数。
注意事项
大多数运行时参数都可以用SET在运行时设置,但有些则在服务运行过程中或会话开始
之后不能修改。
语法格式
l
设置所处的时区。
SET [ SESSION | LOCAL ] TIME ZONE { timezone | LOCAL | DEFAULT };
l
设置所属的模式。
SET [ SESSION | LOCAL ]
{CURRENT_SCHEMA { TO | = } { schema | DEFAULT }
| SCHEMA 'schema'};
l
设置客户端编码集。
SET [ SESSION | LOCAL ] NAMES encoding_name;
l
设置XML的解析方式。
SET [ SESSION | LOCAL ] XML OPTION { DOCUMENT | CONTENT };
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
972GaussDB 200
开发者指南
16 SQL 参考
l
设置其他运行时参数。
SET [ LOCAL | SESSION ]
{ {config_parameter { { TO | = } { value | DEFAULT }
| FROM CURRENT }}};
参数说明
l
SESSION
声明的参数只对当前会话起作用。如果SESSION和LOCAL都没出现,则SESSION
为缺省值。
如果在事务中执行了此命令,命令的产生影响将在事务回滚之后消失。如果该事
务已提交,影响将持续到会话的结束,除非被另外一个SET命令重置参数。
l
LOCAL
声明的参数只在当前事务中有效。在COMMIT或ROLLBACK之后,会话级别的设
置将再次生效。
不论事务是否提交,此命令的影响只持续到当前事务结束。一个特例是:在一个
事务里面,即有SET命令,又有SET LOCAL命令,且SET LOCAL在SET后面,则
在事务结束之前,SET LOCAL命令会起作用,但事务提交之后,则是SET命令会
生效。
l
TIME ZONE timezone
用于指定当前会话的本地时区。
取值范围:有效的本地时区。该选项对应的运行时参数名称为TimeZone,
DEFAULT缺省值为PRC。
l
CURRENT_SCHEMA
schema
CURRENT_SCHEMA用于指定当前的模式。
取值范围:已存在模式名称。
l
SCHEMA schema
同CURRENT_SCHEMA。此处的schema是个字符串。
例如:set schema 'public';
l
NAMES encoding_name
用于设置客户端的字符编码。等价于set client_encoding to encoding_name。
取值范围:有效的字符编码。该选项对应的运行时参数名称为client_encoding,默
认编码为UTF8。
l
XML OPTION option
用于设置XML的解析方式。
取值范围:CONTENT(缺省)、DOCUMENT
l
config_parameter
可设置的运行时参数的名称。可用的运行时参数可以使用SHOW ALL命令查看。
说明
部分通过SHOW ALL查看的参数不能通过SET设置。如max_datanodes。
l
value
config_parameter的新值。可以声明为字符串常量、标识符、数字,或者逗号分隔
的列表。DEFAULT用于把这些参数设置为它们的缺省值。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
973GaussDB 200
开发者指南
16 SQL 参考
示例
--设置模式搜索路径。
SET search_path TO tpcds, public;
--把日期时间风格设置为传统的 POSTGRES 风格(日在月前)。
SET datestyle TO postgres;
相关链接
16.14.122 RESET,16.14.135 SHOW
16.14.131 SET CONSTRAINTS
功能描述
SET CONSTRAINTS设置当前事务检查行为的约束条件。
IMMEDIATE约束是在每条语句后面进行检查。DEFERRED约束一直到事务提交时才检
查。每个约束都有自己的模式。
从创建约束条件开始,一个约束总是设定为DEFERRABLE INITIALLY DEFERRED,
DEFERRABLE INITIALLY IMMEDIATE,NOT DEFERRABLE三个特性之一。第三种
总是IMMEDIATE,并且不会受SET CONSTRAINTS影响。前两种以指定的方式启动每
个事务,但是其行为可以在事务里用SET CONSTRAINTS改变。
带着一个约束名列表的SET CONSTRAINTS改变这些约束的模式(都必须是可推迟
的)。如果有多个约束匹配某个名字,则所有都会被影响。SET CONSTRAINTS ALL
改变所有可推迟约束的模式。
当SET CONSTRAINTS把一个约束从DEFERRED改成IMMEDIATE的时候,新模式反作
用式地起作用:任何将在事务结束准备进行的数据修改都将在SET CONSTRAINTS的
时候执行检查。如果违反了任何约束,SET CONSTRAINTS都会失败(并且不会修改
约束模式)。因此,SET CONSTRAINTS可以用于强制在事务中某一点进行约束检
查。
目前,只有外键约束被该设置影响。检查和唯一约束总是不可推迟的。
注意事项
SET CONSTRAINTS只在当前事务里设置约束的行为。因此,如果用户在事务块之外
(START TRANSACTION/COMMIT对)执行这个命令,它将没有任何作用。
语法格式
SET CONSTRAINTS
{ ALL
|
{ name
}
[, ...]
}
{ DEFERRED
| IMMEDIATE
} ;
参数说明
l
name
约束名。
取值范围:已存在的约束名。可以在系统表pg_constraint中查到。
l
ALL
所有约束。
l
DEFERRED
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
974GaussDB 200
开发者指南
16 SQL 参考
约束一直到事务提交时才检查。
l
IMMEDIATE
约束在每条语句后进行检查。
示例
--设置所有约束在事务提交时检查。
SET CONSTRAINTS ALL DEFERRED;
16.14.132 SET ROLE
功能描述
设置当前会话的当前用户标识符。
注意事项
l 当前会话的用户必须是指定的rolename角色的成员,但系统管理员可以选择任何角
色。
l 使用这条命令,它可能会增加一个用户的权限,也可能会限制一个用户的权限。
如果会话用户的角色有INHERITS属性,则它自动拥有它能SET ROLE变成的角色
的所有权限;在这种情况下,SET ROLE实际上是删除了所有直接赋予会话用户的
权限,以及它的所属角色的权限,只剩下指定角色的权限。另一方面,如果会话
用户的角色有NOINHERITS属性,SET ROLE删除直接赋予会话用户的权限,而获
取指定角色的权限。
语法格式
l
设置当前会话的当前用户标识符。
SET [ SESSION | LOCAL ] ROLE role_name PASSWORD 'password';
l
重置当前用户标识为当前会话用户标识符。
RESET ROLE;
参数说明
l
SESSION
声明这个命令只对当前会话起作用,此参数为缺省值。
取值范围:字符串,要符合标识符的命名规范。
l
LOCALE
声明该命令只在当前事务中有效。
l
role_name
角色名。
取值范围:字符串,要符合标识符的命名规范。
l
password
角色的密码。要求符合密码的命名规则。
l
RESET ROLE
用于重置当前用户标识。
示例
--创建角色paul。
CREATE ROLE paul IDENTIFIED BY 'Bigdata123@';
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
975GaussDB 200
开发者指南
16 SQL 参考
--设置当前用户为paul。
SET ROLE paul PASSWORD 'Bigdata123@';
--查看当前会话用户,当前用户。
SELECT SESSION_USER, CURRENT_USER;
--重置当前用户。
RESET role;
--删除用户。
DROP USER paul;
16.14.133 SET SESSION AUTHORIZATION
功能描述
把当前会话里的会话用户标识和当前用户标识都设置为指定的用户。
注意事项
只有在初始会话用户有系统管理员权限的时候,会话用户标识符才能改变。否则,只
有在指定了被认证的用户名的情况下,系统才接受该命令。
语法格式
l
为当前会话设置会话用户标识符和当前用户标识符。
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION role_name PASSWORD 'password';
l
重置会话和当前用户标识符为初始认证的用户名。
{SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT
| RESET SESSION AUTHORIZATION};
参数说明
l
SESSION
声明这个命令只对当前会话起作用。
取值范围:字符串,要符合标识符的命名规范。
l
LOCALE
声明该命令只在当前事务中有效。
l
role_name
用户名。
取值范围:字符串,要符合标识符的命名规范。
l
password
角色的密码。要求符合密码的命名规则。
l
DEFAULT
重置会话和当前用户标识符为初始认证的用户名。
示例
--创建角色paul。
CREATE ROLE paul IDENTIFIED BY 'Bigdata123@';
--设置当前用户为paul。
SET SESSION AUTHORIZATION paul password 'Bigdata123@';
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
976GaussDB 200
开发者指南
16 SQL 参考
--查看当前会话用户,当前用户。
SELECT SESSION_USER, CURRENT_USER;
--重置当前用户。
RESET SESSION AUTHORIZATION;
--删除用户。
DROP USER paul;
相关参考
16.14.132 SET ROLE
16.14.134 SET TRANSACTION
功能描述
为当前事务设置特性。它对后面的事务没有影响。事务特性包括事务隔离级别、事务
访问模式(读/写或者只读)。
注意事项
无。
语法格式
设置事务的隔离级别、读写模式。
{ SET [ LOCAL ] TRANSACTION|SET SESSION CHARACTERISTICS AS TRANSACTION }
{ ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ }
| { READ WRITE | READ ONLY } } [, ...]
参数说明
l
LOCAL
声明该命令只在当前事务中有效。
l
SESSION
声明这个命令只对当前会话起作用。
取值范围:字符串,要符合标识符的命名规范。
l
ISOLATION_LEVEL_CLAUSE
指定事务隔离级别,该参数决定当一个事务中存在其他并发运行事务时能够看到
什么数据。
说明
l 在事务中第一个数据修改语句(INSERT,DELETE,UPDATE,FETCH,COPY)执行
之后,事务隔离级别就不能再次设置。
取值范围:
– READ COMMITTED:读已提交隔离级别,只能读到已经提交的数据,而不
会读到未提交的数据。这是缺省值。
– READ UNCOMMITTED:读未提交隔离级别,可能会读到未提交的数据。提
供这个隔离级别可用于在存在某协调节点CN故障等情况下应急使用,建议这
种隔离级别下仅作只读操作,避免造成数据不一致。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
977GaussDB 200
开发者指南
16 SQL 参考
l
– REPEATABLE READ:可重复读隔离级别,仅仅能看到事务开始之前提交的
数据,不能看到未提交的数据,以及在事务执行期间由其它并发事务提交的
修改。
– SERIALIZABLE:GaussDB 200目前功能上不支持此隔离级别,等价于
REPEATABLE READ。
READ WRITE | READ ONLY
指定事务访问模式(读/写或者只读)。
示例
--开启一个事务,设置事务的隔离级别为READ COMMITTED,访问模式为READ ONLY。
START TRANSACTION;
SET LOCAL TRANSACTION ISOLATION LEVEL READ COMMITTED READ ONLY;
COMMIT;
16.14.135 SHOW
功能描述
SHOW将显示当前运行时参数的数值。
注意事项
无。
语法格式
SHOW
{
configuration_parameter |
CURRENT_SCHEMA |
TIME ZONE |
TRANSACTION ISOLATION LEVEL |
SESSION AUTHORIZATION |
ALL
};
参数说明
显示变量的参数请参见RESET的参数说明。
示例
--显示 timezone 参数值。
SHOW timezone;
--显示所有参数。
SHOW ALL;
相关链接
16.14.130 SET,16.14.122 RESET
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
978GaussDB 200
开发者指南
16 SQL 参考
16.14.136 START TRANSACTION
功能描述
通过START TRANSACTION启动事务。如果声明了隔离级别、读写模式,那么新事务
就使用这些特性,类似执行了16.14.134 SET TRANSACTION。
注意事项
无。
语法格式
格式一:START TRANSACTION格式
START TRANSACTION
[
{
ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ }
| { READ WRITE | READ ONLY }
} [, ...]
];
格式二:BEGIN格式
BEGIN [ WORK | TRANSACTION ]
[
{
ISOLATION LEVEL { READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE | REPEATABLE READ }
| { READ WRITE | READ ONLY }
} [, ...]
];
参数说明
l
WORK | TRANSACTION
BEGIN格式中的可选关键字,没有实际作用。
l
ISOLATION LEVEL
指定事务隔离级别,它决定当一个事务中存在其他并发运行事务时它能够看到什
么数据。
说明
在事务中第一个数据修改语句(INSERT,DELETE,UPDATE,FETCH,COPY)执行之
后,事务隔离级别就不能再次设置。
取值范围:
– READ COMMITTED:读已提交隔离级别,只能读到已经提交的数据,而不
会读到未提交的数据。这是缺省值。
– READ UNCOMMITTED:读未提交隔离级别,可能会读到未提交的数据。提
供这个隔离级别可用于在存在某协调节点CN故障等情况下应急使用,建议这
种隔离级别下仅作只读操作,避免造成数据不一致。
– REPEATABLE READ: 可重复读隔离级别,仅仅看到事务开始之前提交的数
据,它不能看到未提交的数据,以及在事务执行期间由其它并发事务提交的
修改。
– SERIALIZABLE:GaussDB 200目前功能上不支持此隔离级别,等价于
REPEATABLE READ。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
979GaussDB 200
开发者指南
16 SQL 参考
l
READ WRITE | READ ONLY
指定事务访问模式(读/写或者只读)。
示例
--以默认方式启动事务。
START TRANSACTION;
SELECT * FROM tpcds.reason;
END;
--以默认方式启动事务。
BEGIN;
SELECT * FROM tpcds.reason;
END;
--以隔离级别为READ COMMITTED,读/写方式启动事务。
START TRANSACTION ISOLATION LEVEL READ COMMITTED READ WRITE;
SELECT * FROM tpcds.reason;
COMMIT;
相关链接
16.14.42 COMMIT | END,16.14.124 ROLLBACK,16.14.134 SET TRANSACTION
16.14.137 TRUNCATE
功能描述
清理表数据,TRUNCATE快速地从表中删除所有行。
它和在目标表上进行无条件的DELETE有同样的效果,但由于TRUNCATE不做表扫
描,因而快得多。在大表上操作效果更明显。
注意事项
l TRUNCATE TABLE在功能上与不带WHERE子句DELETE语句相同:二者均删除
表中的全部行。
l TRUNCATE TABLE比DELETE速度快且使用系统和事务日志资源少:
l
– DELETE语句每次删除一行,并在事务日志中为所删除每行记录一项。
– TRUNCATE TABLE通过释放存储表数据所用数据页来删除数据,并且只在事
务日志中记录页的释放。
TRUNCATE,DELETE,DROP三者的差异如下:
– TRUNCATE TABLE,删除内容,释放空间,但不删除定义。
– DELETE TABLE,删除内容,不删除定义,不释放空间。
– DROP TABLE,删除内容和定义,释放空间。
语法格式
l
清理表数据。
TRUNCATE [ TABLE ] [ ONLY ] {table_name [ * ]} [, ... ]
[ CONTINUE IDENTITY ] [ CASCADE | RESTRICT ];
l
清理表分区的数据。
ALTER TABLE [ IF EXISTS
文档版本 01 (2019-08-01)
] { [ ONLY ] table_name
| table_name *
| ONLY ( table_name ) }
版权所有 © 华为技术有限公司
980GaussDB 200
开发者指南
16 SQL 参考
TRUNCATE PARTITION { partition_name
| FOR ( partition_value
[, ...] )
} ;
参数说明
l
ONLY
如果声明ONLY,只有指定的表会被清空。如果没有声明ONLY,这个表以及其所
有子表(若有)会被清空。
l
table_name
目标表的名字(可以有模式修饰)。
取值范围:已存在的表名。
l
CONTINUE IDENTITY
不改变序列的值。这是缺省值。
l
l
CASCADE | RESTRICT
– CASCADE:级联清空所有在该表上有外键引用的表,或者由于CASCADE而
被添加到组中的表。
– RESTRICT(缺省值):如果其他表在该表上有外键引用则拒绝清空。
partition_name
目标分区表的分区名。
取值范围:已存在的分区名。
l
partition_value
指定的分区键值。
通过PARTITION FOR子句指定的这一组值,可以唯一确定一个分区。
取值范围:需要进行删除数据分区的分区键的取值范围。
使用PARTITION FOR子句时,partition_value所在的整个分区会被清空。
示例
--创建表。
CREATE TABLE tpcds.reason_t1 AS TABLE tpcds.reason;
--清空表tpcds.reason_t1。
TRUNCATE TABLE tpcds.reason_t1;
--删除表。
DROP TABLE tpcds.reason_t1;
--创建分区表。
CREATE TABLE tpcds.reason_p
(
r_reason_sk integer,
r_reason_id character(16),
r_reason_desc character(100)
)PARTITION BY RANGE (r_reason_sk)
(
partition p_05_before values less than (05),
partition p_15 values less than (15),
partition p_25 values less than (25),
partition p_35 values less than (35),
partition p_45_after values less than (MAXVALUE)
);
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
981GaussDB 200
开发者指南
16 SQL 参考
--插入数据。
INSERT INTO tpcds.reason_p SELECT * FROM tpcds.reason;
--清空分区p_05_before。
ALTER TABLE tpcds.reason_p TRUNCATE PARTITION p_05_before;
--清空分区p_15。
ALTER TABLE tpcds.reason_p TRUNCATE PARTITION for (13);
--清空分区表。
TRUNCATE TABLE tpcds.reason_p;
--删除表。
DROP TABLE tpcds.reason_p;
16.14.138 UPDATE
功能描述
更新表中的数据。UPDATE修改满足条件的所有行中指定的字段值,WHERE子句声明
条件,SET子句指定的字段会被修改,没有出现的字段则保持它们的原值。
注意事项
l 要修改表,用户必须对该表有UPDATE权限。
l 对expression或condition条件里涉及到的任何表要有SELECT权限。
l 不允许对表的分布列(distribute column)进行修改。
l 对于列存表,暂时不支持RETURNING子句。
l 列存表不支持结果不确定的更新(non-deterministic update)。试图对列存表用多行数
据更新一行时会报错。
l 列存表的更新操作,旧记录空间不会回收,需要执行VACUUM FULL table_name
进行清理。
l 对于列存复制表,暂不支持UPDATE操作。
语法格式
UPDATE [ ONLY ] table_name [ * ] [ [ AS ] alias ]
SET {column_name = { expression | DEFAULT }
|( column_name [, ...] ) = {( { expression | DEFAULT } [, ...] ) |sub_query }}[, ...]
[ FROM from_list] [ WHERE condition ]
[ RETURNING {*
| {output_expression [ [ AS ] output_name ]} [, ...] }];
where sub_query can be:
SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
{ * | {expression [ [ AS ] output_name ]} [, ...] }
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [, ...] ]
[ HAVING condition [, ...] ]
参数说明
l
table_name
要更新的表名,可以使用模式修饰。
取值范围:已存在的表名称。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
982GaussDB 200
开发者指南
16 SQL 参考
l
alias
目标表的别名。
取值范围:字符串,符合标识符命名规范。
l
column_name
要修改的字段名。
支持使用目标表的别名加字段名来引用这个字段。例如:
UPDATE foo AS f SET f.col_name = 'postgres';
取值范围:已存在的字段名。
l
expression
赋给字段的值或表达式。
l
DEFAULT
用对应字段的缺省值填充该字段。
如果没有缺省值,则为NULL。
l
sub_query
子查询。
使用同一数据库里其他表的信息来更新一个表可以使用子查询的方法。其中
SELECT子句具体介绍请参考16.14.128 SELECT。
l
from_list
一个表的表达式列表,允许在WHERE条件里使用其他表的字段。与在一个
SELECT语句的FROM子句里声明表列表类似。
目标表绝对不能出现在from_list里,除非在使用一个自连接(此时它必须以
from_list的别名出现)。
l
condition
一个返回boolean类型结果的表达式。只有这个表达式返回true的行才会被更新。
l
output_expression
在所有需要更新的行都被更新之后,UPDATE命令用于计算返回值的表达式。
取值范围:使用任何table以及FROM中列出的表的字段。*表示返回所有字段。
l
output_name
字段的返回名称。
示例
--创建表student1。
CREATE TABLE student1
(
stuno
int,
classno
int
)
DISTRIBUTE BY hash(stuno);
--插入数据。
INSERT INTO student1 VALUES(1,1);
INSERT INTO student1 VALUES(2,2);
INSERT INTO student1 VALUES(3,3);
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
983GaussDB 200
开发者指南
16 SQL 参考
--查看数据。
SELECT * FROM student1;
--直接更新所有记录的值。
UPDATE student1 SET classno = classno*2;
--查看数据。
SELECT * FROM student1;
--删除表。
DROP TABLE student1;
16.14.139 VACUUM
功能描述
VACUUM回收表或B-Tree索引中已经删除的行所占据的存储空间。在一般的数据库操
作里,那些已经DELETE的行并没有从它们所属的表中物理删除;在完成VACUUM之
前它们仍然存在。因此有必要周期地运行VACUUM,特别是在经常更新的表上。
注意事项
l 如果没有参数,VACUUM处理当前数据库里用户拥有相应权限的每个表。如果参
数指定了一个表,VACUUM只处理指定的那个表。
l 要对一个表进行VACUUM操作,通常用户必须是表的所有者或系统管理员。数据
库的所有者允许对数据库中除了共享目录以外的所有表进行VACUUM操作(该限
制意味着只有系统管理员才能真正对一个数据库进行VACUUM操作)。VACUUM
命令会跳过那些用户没有权限的表进行垃圾回收操作。
l VACUUM不能在事务块内执行。
l 建议生产数据库经常清理(至少每晚一次),以保证不断地删除失效的行。尤其
是在增删了大量记录之后,对受影响的表执行VACUUM ANALYZE命令是一个很
好的习惯。这样将更新系统目录为最近的更改,并且允许查询优化器在规划用户
查询时有更好的选择。
l 不建议日常使用FULL选项,但是可以在特殊情况下使用。例如在用户删除了一个
表的大部分行之后,希望从物理上缩小该表以减少磁盘空间占用。VACUUM
FULL通常要比单纯的VACUUM收缩更多的表尺寸。FULL选项并不清理索引,所
以推荐周期性的运行16.14.120 REINDEX命令。实际上,首先删除所有索引,再
运行VACUUM FULL命令,最后重建索引通常是更快的选择。如果执行此命令后
所占用物理空间无变化(未减少),请确认是否有其他活跃事务(删除数据事务
开始之前开始的事务,并在VACUUM FULL执行前未结束)存在,如果有等其他
活跃事务退出进行重试。
l VACUUM会导致I/O流量的大幅增加,这可能会影响其他活动会话的性能。因此,
有时候会建议使用基于开销的VACUUM延迟特性。
l 如果指定了VERBOSE选项,VACUUM将打印处理过程中的信息,以表明当前正
在处理的表。各种有关当前表的统计信息也会打印出来。但是对于列存表执行
VACUUM操作,指定了VERBOSE选项,无信息输出。
l 当含有带括号的选项列表时,选项可以以任何顺序写入。如果没有括号,则选项
必须按语法显示的顺序给出。
l VACUUM和VACUUM FULL时,会根据参数vacuum_defer_cleanup_age延迟清理行
存表记录,即不会立即清理刚刚删除的元组。
l VACUUM ANALYZE先执行一个VACUUM操作,然后给每个选定的表执行一个
ANALYZE。对于日常维护脚本而言,这是一个很方便的组合。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
984GaussDB 200
开发者指南
16 SQL 参考
l 简单的VACUUM(不带FULL选项)只是简单地回收空间并且令其可以再次使
用。这种形式的命令可以和对表的普通读写并发操作,因为没有请求排他锁。
VACUUM FULL执行更广泛的处理,包括跨块移动行,以便把表压缩到最少的磁
盘块数目里。这种形式要慢许多并且在处理的时候需要在表上施加一个排他锁。
l VACUUM列存表内部执行的操作包括三个:迁移delta表中的数据到主表、
VACUUM主表的delta表、VACUUM主表的desc表。该操作不会回收delta表的存储
空间,如果要回收delta表的冗余存储空间,需要对该列存表执行VACUUM
DELTAMERGE。
l 回收空间并更新统计信息,对关键字顺序无要求。
语法格式
VACUUM [ ( { FULL | FREEZE | VERBOSE | {ANALYZE | ANALYSE }} [,...] ) ]
[ table_name [ (column_name [, ...] ) ] ] [ PARTITION ( partition_name ) ];
l
仅回收空间,不更新统计信息。
VACUUM [ FULL [COMPACT] ] [ FREEZE ] [ VERBOSE ] [ table_name ] [ PARTITION
( partition_name ) ];
l
回收空间并更新统计信息,且对关键字顺序有要求。
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] { ANALYZE | ANALYSE } [ VERBOSE ]
[ table_name [ (column_name [, ...] ) ] ] [ PARTITION ( partition_name ) ];
l
针对HDFS表和列存表,将delta table中的数据转移到主表存储。
VACUUM DELTAMERGE [ table_name ];
l
针对HDFS表,删除HDFS表在HDFS存储上的空值分区目录。
VACUUM HDFSDIRECTORY [ table_name ];
参数说明
l
FULL
选择“FULL”清理,这样可以恢复更多的空间,但是需要耗时更多,并且在表上
施加了排他锁。
FULL选项还可以带有COMPACT参数,该参数只针对HDFS表,指定该参数的
VACUUM FULL操作性能要好于未指定该参数的VACUUM FULL操作。
COMPACT和PARTITION参数不能同时使用。
说明
使用FULL参数会导致统计信息丢失,如果需要收集统计信息,请在VACUUM FULL语句中
加上analyze关键字。
l
FREEZE
指定FREEZE相当于执行VACUUM时将vacuum_freeze_min_age参数设为0。
l
VERBOSE
为每个表打印一份详细的清理工作报告。
l
ANALYZE | ANALYSE
更新用于优化器的统计信息,以决定执行查询的最有效方法。
l
table_name
要清理的表的名称(可以有模式修饰)。
取值范围:要清理的表的名称。缺省时为当前数据库中的所有表。
l
column_name
要分析的具体的字段名称。
取值范围:要分析的具体的字段名称。缺省时为所有字段。
文档版本 01 (2019-08-01)
版权所有 © 华为技术有限公司
985GaussDB 200
开发者指南
16 SQL 参考
l
PARTITION
HDFS表不支持PARTITION参数,COMPACT和PARTITION参数不能同时使用。
l
partition_name
要清理的表的分区名称。缺省时为所有分区。
l
DELTAMERGE
只针对HDFS表和列存表,将HDFS表或者列存表的delta table中的数据转移到主表
存储上。对HDFS表而言,当delta表中数据量小于六万行,则不作迁移,只有在大
于或者等于六万行数据时,将delta表中所有数据迁移到HDFS上,并通过truncate清
理delta表的存储空间。对列存表而言,此操作受enable_delta_store和参数说明中
的deltarow_threshold控制。
说明
为了检查列存delta表中的信息(HDFS表的delta表数据可以通过explain analyze查到),提
供下述DFX函数,用于获取某个列存表的delta表中数据存储情况:
l pgxc_get_delta_info(TEXT),传入参数为列存表名,搜集并显示各个节点上的对应delta
表信息,包括当前存活tuple数量、表大小、使用的最大block ID。
l get_delta_info(TEXT),传入参数为列存表名,汇总pgxc_get_delta_info得到的结果,返
回其delta表整体的当前存活tuple数量、表大小、使用的最大block ID。
l
HDFSDIRECTORY
只针对HDFS表,删除HDFS表在HDFS存储上表目录下的空值分区目录。
示例
--在表tpcds.reason上创建索引
CREATE UNIQUE INDEX ds_reason_index1 ON tpcds.reason(r_reason_sk);
--对带索引的表tpcds.reason执行VACUUM操作。
VACUUM (VERBOSE, ANALYZE) tpcds.reason;
--删除索引
DROP INDEX ds_reason_index1 CASCADE;
DROP TABLE tpcds.reason;
