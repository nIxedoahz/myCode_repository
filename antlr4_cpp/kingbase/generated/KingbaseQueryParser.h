
// Generated from KingbaseQueryParser.g4 by ANTLR 4.7.1

#pragma once


#include "antlr4-runtime.h"




class  KingbaseQueryParser : public antlr4::Parser {
public:
  enum {
    ABORT = 1, ABS = 2, ACCESS = 3, ACCESSED = 4, ACCOUNT = 5, ACL = 6, 
    ACOS = 7, ACTION = 8, ACTIONS = 9, ACTIVATE = 10, ACTIVE = 11, ACTIVE_COMPONENT = 12, 
    ACTIVE_DATA = 13, ACTIVE_FUNCTION = 14, ACTIVE_TAG = 15, ACTIVITY = 16, 
    ADAPTIVE_PLAN = 17, ADD = 18, ADD_COLUMN = 19, ADD_GROUP = 20, ADD_MONTHS = 21, 
    ADJ_DATE = 22, ADMIN = 23, ADMINISTER = 24, ADMINISTRATOR = 25, ADVANCED = 26, 
    ADVISE = 27, ADVISOR = 28, AFD_DISKSTRING = 29, AFTER = 30, AGENT = 31, 
    AGGREGATE = 32, A_LETTER = 33, ALIAS = 34, ALL = 35, ALLOCATE = 36, 
    ALLOW = 37, ALL_ROWS = 38, ALTER = 39, ALWAYS = 40, ANALYZE = 41, ANCILLARY = 42, 
    AND = 43, AND_EQUAL = 44, ANOMALY = 45, ANSI_REARCH = 46, ANTIJOIN = 47, 
    ANY = 48, ANYSCHEMA = 49, APPEND = 50, APPENDCHILDXML = 51, APPEND_VALUES = 52, 
    APPLICATION = 53, APPLY = 54, APPROX_COUNT_DISTINCT = 55, ARCHIVAL = 56, 
    ARCHIVE = 57, ARCHIVED = 58, ARCHIVELOG = 59, ARRAY = 60, AS = 61, ASC = 62, 
    ASCII = 63, ASCIISTR = 64, ASIN = 65, ASIS = 66, ASSEMBLY = 67, ASSIGN = 68, 
    ASSOCIATE = 69, ASYNC = 70, ASYNCHRONOUS = 71, ATAN2 = 72, ATAN = 73, 
    AT = 74, ATTRIBUTE = 75, ATTRIBUTES = 76, AUDIT = 77, AUTHENTICATED = 78, 
    AUTHENTICATION = 79, AUTHID = 80, AUTHORIZATION = 81, AUTOALLOCATE = 82, 
    AUTO = 83, AUTOBACKUP = 84, AUTOEXTEND = 85, AUTO_LOGIN = 86, AUTOMATIC = 87, 
    AUTONOMOUS_TRANSACTION = 88, AUTO_REOPTIMIZE = 89, AVAILABILITY = 90, 
    AVRO = 91, BACKGROUND = 92, BACKUP = 93, BACKUPSET = 94, BASIC = 95, 
    BASICFILE = 96, BATCH = 97, BATCHSIZE = 98, BATCH_TABLE_ACCESS_BY_ROWID = 99, 
    BECOME = 100, BEFORE = 101, BEGIN = 102, BEGINNING = 103, BEGIN_OUTLINE_DATA = 104, 
    BEHALF = 105, BEQUEATH = 106, BETWEEN = 107, BFILE = 108, BFILENAME = 109, 
    BIGFILE = 110, BINARY = 111, BINARY_DOUBLE = 112, BINARY_DOUBLE_INFINITY = 113, 
    BINARY_DOUBLE_NAN = 114, BINARY_FLOAT = 115, BINARY_FLOAT_INFINITY = 116, 
    BINARY_FLOAT_NAN = 117, BINARY_INTEGER = 118, BIND_AWARE = 119, BINDING = 120, 
    BIN_TO_NUM = 121, BITAND = 122, BITMAP_AND = 123, BITMAP = 124, BITMAPS = 125, 
    BITMAP_TREE = 126, BITS = 127, BLOB = 128, BLOCK = 129, BLOCK_RANGE = 130, 
    BLOCKS = 131, BLOCKSIZE = 132, BODY = 133, BOOLEAN = 134, BOTH = 135, 
    BOUND = 136, BRANCH = 137, BREADTH = 138, BROADCAST = 139, BSON = 140, 
    BUFFER = 141, BUFFER_CACHE = 142, BUFFER_POOL = 143, BUILD = 144, BULK = 145, 
    BY = 146, BYPASS_RECURSIVE_CHECK = 147, BYPASS_UJVC = 148, BYTE = 149, 
    CACHE = 150, CACHE_CB = 151, CACHE_INSTANCES = 152, CACHE_TEMP_TABLE = 153, 
    CACHING = 154, CALCULATED = 155, CALLBACK = 156, CALL = 157, CANCEL = 158, 
    CANONICAL = 159, CAPACITY = 160, CARDINALITY = 161, CASCADE = 162, CASE = 163, 
    CAST = 164, CATEGORY = 165, CDBDEFAULT = 166, CEIL = 167, CELL_FLASH_CACHE = 168, 
    CERTIFICATE = 169, CFILE = 170, CHAINED = 171, CHANGE = 172, CHANGETRACKING = 173, 
    CHANGE_DUPKEY_ERROR_INDEX = 174, CHARACTER = 175, CHAR = 176, CHAR_CS = 177, 
    CHARTOROWID = 178, CHECK_ACL_REWRITE = 179, CHECK = 180, CHECKPOINT = 181, 
    CHILD = 182, CHOOSE = 183, CHR = 184, CHUNK = 185, CLASS = 186, CLASSIFIER = 187, 
    CLEANUP = 188, CLEAR = 189, C_LETTER = 190, CLIENT = 191, CLOB = 192, 
    CLONE = 193, CLOSE_CACHED_OPEN_CURSORS = 194, CLOSE = 195, CLUSTER_BY_ROWID = 196, 
    CLUSTER = 197, CLUSTER_DETAILS = 198, CLUSTER_DISTANCE = 199, CLUSTER_ID = 200, 
    CLUSTERING = 201, CLUSTERING_FACTOR = 202, CLUSTER_PROBABILITY = 203, 
    CLUSTER_SET = 204, COALESCE = 205, COALESCE_SQ = 206, COARSE = 207, 
    CO_AUTH_IND = 208, COLD = 209, COLLECT = 210, COLUMNAR = 211, COLUMN_AUTH_INDICATOR = 212, 
    COLUMN = 213, COLUMNS = 214, COLUMN_STATS = 215, COLUMN_VALUE = 216, 
    COMMENT = 217, COMMIT = 218, COMMITTED = 219, COMMON_DATA = 220, COMPACT = 221, 
    COMPATIBILITY = 222, COMPILE = 223, COMPLETE = 224, COMPLIANCE = 225, 
    COMPONENT = 226, COMPONENTS = 227, COMPOSE = 228, COMPOSITE = 229, COMPOSITE_LIMIT = 230, 
    COMPOUND = 231, COMPRESS = 232, COMPUTE = 233, CONCAT = 234, CON_DBID_TO_ID = 235, 
    CONDITIONAL = 236, CONDITION = 237, CONFIRM = 238, CONFORMING = 239, 
    CON_GUID_TO_ID = 240, CON_ID = 241, CON_NAME_TO_ID = 242, CONNECT_BY_CB_WHR_ONLY = 243, 
    CONNECT_BY_COMBINE_SW = 244, CONNECT_BY_COST_BASED = 245, CONNECT_BY_ELIM_DUPS = 246, 
    CONNECT_BY_FILTERING = 247, CONNECT_BY_ISCYCLE = 248, CONNECT_BY_ISLEAF = 249, 
    CONNECT_BY_ROOT = 250, CONNECT = 251, CONNECT_TIME = 252, CONSIDER = 253, 
    CONSISTENT = 254, CONSTANT = 255, CONST = 256, CONSTRAINT = 257, CONSTRAINTS = 258, 
    CONSTRUCTOR = 259, CONTAINER = 260, CONTAINER_DATA = 261, CONTAINERS = 262, 
    CONTENT = 263, CONTENTS = 264, CONTEXT = 265, CONTINUE = 266, CONTROLFILE = 267, 
    CON_UID_TO_ID = 268, CONVERT = 269, COOKIE = 270, COPY = 271, CORR_K = 272, 
    CORR_S = 273, CORRUPTION = 274, CORRUPT_XID_ALL = 275, CORRUPT_XID = 276, 
    COS = 277, COSH = 278, COST = 279, COST_XML_QUERY_REWRITE = 280, COUNT = 281, 
    COVAR_POP = 282, COVAR_SAMP = 283, CPU_COSTING = 284, CPU_PER_CALL = 285, 
    CPU_PER_SESSION = 286, CRASH = 287, CREATE = 288, CREATE_FILE_DEST = 289, 
    CREATE_STORED_OUTLINES = 290, CREATION = 291, CREDENTIAL = 292, CRITICAL = 293, 
    CROSS = 294, CROSSEDITION = 295, CSCONVERT = 296, CUBE_AJ = 297, CUBE = 298, 
    CUBE_GB = 299, CUBE_SJ = 300, CUME_DISTM = 301, CURRENT = 302, CURRENT_DATE = 303, 
    CURRENT_SCHEMA = 304, CURRENT_TIME = 305, CURRENT_TIMESTAMP = 306, CURRENT_USER = 307, 
    CURRENTV = 308, CURSOR = 309, CURSOR_SHARING_EXACT = 310, CURSOR_SPECIFIC_SEGMENT = 311, 
    CUSTOMDATUM = 312, CV = 313, CYCLE = 314, DANGLING = 315, DATABASE = 316, 
    DATA = 317, DATAFILE = 318, DATAFILES = 319, DATAGUARDCONFIG = 320, 
    DATAMOVEMENT = 321, DATAOBJNO = 322, DATAOBJ_TO_MAT_PARTITION = 323, 
    DATAOBJ_TO_PARTITION = 324, DATAPUMP = 325, DATA_SECURITY_REWRITE_LIMIT = 326, 
    DATE = 327, DATE_MODE = 328, DAY = 329, DAYS = 330, DBA = 331, DBA_RECYCLEBIN = 332, 
    DBMS_STATS = 333, DB_ROLE_CHANGE = 334, DBTIMEZONE = 335, DB_UNIQUE_NAME = 336, 
    DB_VERSION = 337, DDL = 338, DEALLOCATE = 339, DEBUG = 340, DEBUGGER = 341, 
    DEC = 342, DECIMAL = 343, DECLARE = 344, DECOMPOSE = 345, DECORRELATE = 346, 
    DECR = 347, DECREMENT = 348, DECRYPT = 349, DEDUPLICATE = 350, DEFAULT = 351, 
    DEFAULTS = 352, DEFERRABLE = 353, DEFERRED = 354, DEFINED = 355, DEFINE = 356, 
    DEFINER = 357, DEGREE = 358, DELAY = 359, DELEGATE = 360, DELETE_ALL = 361, 
    DELETE = 362, DELETEXML = 363, DEMAND = 364, DENSE_RANKM = 365, DEPENDENT = 366, 
    DEPTH = 367, DEQUEUE = 368, DEREF = 369, DEREF_NO_REWRITE = 370, DESC = 371, 
    DESTROY = 372, DETACHED = 373, DETERMINES = 374, DETERMINISTIC = 375, 
    DICTIONARY = 376, DIMENSION = 377, DIMENSIONS = 378, DIRECT_LOAD = 379, 
    DIRECTORY = 380, DIRECT_PATH = 381, DISABLE_ALL = 382, DISABLE = 383, 
    DISABLE_PARALLEL_DML = 384, DISABLE_PRESET = 385, DISABLE_RPKE = 386, 
    DISALLOW = 387, DISASSOCIATE = 388, DISCARD = 389, DISCONNECT = 390, 
    DISK = 391, DISKGROUP = 392, DISKGROUP_PLUS = 393, DISKS = 394, DISMOUNT = 395, 
    DISTINCT = 396, DISTINGUISHED = 397, DISTRIBUTED = 398, DISTRIBUTE = 399, 
    DML = 400, DML_UPDATE = 401, DOCFIDELITY = 402, DOCUMENT = 403, DOMAIN_INDEX_FILTER = 404, 
    DOMAIN_INDEX_NO_SORT = 405, DOMAIN_INDEX_SORT = 406, DOUBLE = 407, DOWNGRADE = 408, 
    DRIVING_SITE = 409, DROP_COLUMN = 410, DROP = 411, DROP_GROUP = 412, 
    DSINTERVAL_UNCONSTRAINED = 413, DST_UPGRADE_INSERT_CONV = 414, DUMP = 415, 
    DUMPSET = 416, DUPLICATE = 417, DV = 418, DYNAMIC = 419, DYNAMIC_SAMPLING = 420, 
    DYNAMIC_SAMPLING_EST_CDN = 421, EACH = 422, EDITIONABLE = 423, EDITION = 424, 
    EDITIONING = 425, EDITIONS = 426, ELEMENT = 427, ELIM_GROUPBY = 428, 
    ELIMINATE_JOIN = 429, ELIMINATE_OBY = 430, ELIMINATE_OUTER_JOIN = 431, 
    ELSE = 432, ELSIF = 433, EM = 434, EMPTY_BLOB = 435, EMPTY_CLOB = 436, 
    EMPTY = 437, ENABLE_ALL = 438, ENABLE = 439, ENABLE_PARALLEL_DML = 440, 
    ENABLE_PRESET = 441, ENCODING = 442, ENCRYPT = 443, ENCRYPTION = 444, 
    END = 445, END_OUTLINE_DATA = 446, ENFORCED = 447, ENFORCE = 448, ENQUEUE = 449, 
    ENTERPRISE = 450, ENTITYESCAPING = 451, ENTRY = 452, EQUIPART = 453, 
    ERR = 454, ERROR_ARGUMENT = 455, ERROR = 456, ERROR_ON_OVERLAP_TIME = 457, 
    ERRORS = 458, ESCAPE = 459, ESTIMATE = 460, EVAL = 461, EVALNAME = 462, 
    EVALUATE = 463, EVALUATION = 464, EVENTS = 465, EVERY = 466, EXCEPT = 467, 
    EXCEPTION = 468, EXCEPTION_INIT = 469, EXCEPTIONS = 470, EXCHANGE = 471, 
    EXCLUDE = 472, EXCLUDING = 473, EXCLUSIVE = 474, EXECUTE = 475, EXEMPT = 476, 
    EXISTING = 477, EXISTS = 478, EXISTSNODE = 479, EXIT = 480, EXPAND_GSET_TO_UNION = 481, 
    EXPAND_TABLE = 482, EXP = 483, EXPIRE = 484, EXPLAIN = 485, EXPLOSION = 486, 
    EXPORT = 487, EXPR_CORR_CHECK = 488, EXPRESS = 489, EXTENDS = 490, EXTENT = 491, 
    EXTENTS = 492, EXTERNAL = 493, PLAIN = 494, EXTERNALLY = 495, EXTRACTCLOBXML = 496, 
    EXTRACT = 497, EXTRACTVALUE = 498, EXTRA = 499, FACILITY = 500, FACT = 501, 
    FACTOR = 502, FACTORIZE_JOIN = 503, FAILED = 504, FAILED_LOGIN_ATTEMPTS = 505, 
    FAILGROUP = 506, FAILOVER = 507, FAILURE = 508, FALSE = 509, FAMILY = 510, 
    FAR = 511, FAST = 512, FASTSTART = 513, FBTSCAN = 514, FEATURE_DETAILS = 515, 
    FEATURE_ID = 516, FEATURE_SET = 517, FEATURE_VALUE = 518, FETCH = 519, 
    FILE = 520, FILE_NAME_CONVERT = 521, FILESYSTEM_LIKE_LOGGING = 522, 
    FILTER = 523, FINAL = 524, FINE = 525, FINISH = 526, FIRST = 527, FIRSTM = 528, 
    FIRST_ROWS = 529, FIRST_VALUE = 530, FIXED_VIEW_DATA = 531, FLAGGER = 532, 
    FLASHBACK = 533, FLASH_CACHE = 534, FLOAT = 535, FLOB = 536, FLOOR = 537, 
    FLUSH = 538, FOLDER = 539, FOLLOWING = 540, FOLLOWS = 541, FORALL = 542, 
    FORCE = 543, FORCE_XML_QUERY_REWRITE = 544, FOREIGN = 545, FOREVER = 546, 
    FOR = 547, FORMAT = 548, FORWARD = 549, FRAGMENT_NUMBER = 550, FREELIST = 551, 
    FREELISTS = 552, FREEPOOLS = 553, FRESH = 554, FROM = 555, FROM_TZ = 556, 
    FULL = 557, FULL_OUTER_JOIN_TO_OUTER = 558, FUNCTION = 559, FUNCTIONS = 560, 
    GATHER_OPTIMIZER_STATISTICS = 561, GATHER_PLAN_STATISTICS = 562, GBY_CONC_ROLLUP = 563, 
    GBY_PUSHDOWN = 564, GENERATED = 565, GET = 566, GLOBAL = 567, GLOBALLY = 568, 
    GLOBAL_NAME = 569, GLOBAL_TOPIC_ENABLED = 570, GOTO = 571, GRANT = 572, 
    GROUP_BY = 573, GROUP = 574, GROUP_ID = 575, GROUPING = 576, GROUPING_ID = 577, 
    GROUPS = 578, GUARANTEED = 579, GUARANTEE = 580, GUARD = 581, HASH_AJ = 582, 
    HASH = 583, HASHKEYS = 584, HASH_SJ = 585, HAVING = 586, HEADER = 587, 
    HEAP = 588, HELP = 589, HEXTORAW = 590, HEXTOREF = 591, HIDDEN_KEYWORD = 592, 
    HIDE = 593, HIERARCHY = 594, HIGH = 595, HINTSET_BEGIN = 596, HINTSET_END = 597, 
    HOT = 598, HOUR = 599, HWM_BROKERED = 600, HYBRID = 601, IDENTIFIED = 602, 
    IDENTIFIER = 603, IDENTITY = 604, IDGENERATORS = 605, ID = 606, IDLE_TIME = 607, 
    IF = 608, IGNORE = 609, IGNORE_OPTIM_EMBEDDED_HINTS = 610, IGNORE_ROW_ON_DUPKEY_INDEX = 611, 
    IGNORE_WHERE_CLAUSE = 612, ILM = 613, IMMEDIATE = 614, IMPACT = 615, 
    IMPORT = 616, INACTIVE = 617, INCLUDE = 618, INCLUDE_VERSION = 619, 
    INCLUDING = 620, INCREMENTAL = 621, INCREMENT = 622, INCR = 623, INDENT = 624, 
    INDEX_ASC = 625, INDEX_COMBINE = 626, INDEX_DESC = 627, INDEXED = 628, 
    INDEXES = 629, INDEX_FFS = 630, INDEX_FILTER = 631, INDEX = 632, INDEXING = 633, 
    INDEX_JOIN = 634, INDEX_ROWS = 635, INDEX_RRS = 636, INDEX_RS_ASC = 637, 
    INDEX_RS_DESC = 638, INDEX_RS = 639, INDEX_SCAN = 640, INDEX_SKIP_SCAN = 641, 
    INDEX_SS_ASC = 642, INDEX_SS_DESC = 643, INDEX_SS = 644, INDEX_STATS = 645, 
    INDEXTYPE = 646, INDEXTYPES = 647, INDICATOR = 648, INDICES = 649, INFINITE = 650, 
    INFORMATIONAL = 651, INHERIT = 652, IN = 653, INITCAP = 654, INITIAL = 655, 
    INITIALIZED = 656, INITIALLY = 657, INITRANS = 658, INLINE = 659, INLINE_XMLTYPE_NT = 660, 
    INMEMORY = 661, IN_MEMORY_METADATA = 662, INMEMORY_PRUNING = 663, INNER = 664, 
    INOUT = 665, INPLACE = 666, INSERTCHILDXMLAFTER = 667, INSERTCHILDXMLBEFORE = 668, 
    INSERTCHILDXML = 669, INSERT = 670, INSERTXMLAFTER = 671, INSERTXMLBEFORE = 672, 
    INSTANCE = 673, INSTANCES = 674, INSTANTIABLE = 675, INSTANTLY = 676, 
    INSTEAD = 677, INSTR2 = 678, INSTR4 = 679, INSTRB = 680, INSTRC = 681, 
    INSTR = 682, INTEGER = 683, INTERLEAVED = 684, INTERMEDIATE = 685, INTERNAL_CONVERT = 686, 
    INTERNAL_USE = 687, INTERPRETED = 688, INTERSECT = 689, INTERVAL = 690, 
    INT = 691, INTO = 692, INVALIDATE = 693, INVISIBLE = 694, IN_XQUERY = 695, 
    IS = 696, ISOLATION = 697, ISOLATION_LEVEL = 698, ITERATE = 699, ITERATION_NUMBER = 700, 
    JAVA = 701, JOB = 702, JOIN = 703, JSON_ARRAYAGG = 704, JSON_ARRAY = 705, 
    JSON_EQUAL = 706, JSON_EXISTS2 = 707, JSON_EXISTS = 708, JSONGET = 709, 
    JSON = 710, JSON_OBJECTAGG = 711, JSON_OBJECT = 712, JSONPARSE = 713, 
    JSON_QUERY = 714, JSON_SERIALIZE = 715, JSON_TABLE = 716, JSON_TEXTCONTAINS2 = 717, 
    JSON_TEXTCONTAINS = 718, JSON_VALUE = 719, KEEP_DUPLICATES = 720, KEEP = 721, 
    KERBEROS = 722, KEY = 723, KEY_LENGTH = 724, KEYSIZE = 725, KEYS = 726, 
    KEYSTORE = 727, KILL = 728, LABEL = 729, LANGUAGE = 730, STOPWORDS = 731, 
    LAST_DAY = 732, LAST = 733, LAST_VALUE = 734, LATERAL = 735, LAX = 736, 
    LAYER = 737, LDAP_REGISTRATION_ENABLED = 738, LDAP_REGISTRATION = 739, 
    LDAP_REG_SYNC_INTERVAL = 740, LEADING = 741, LEFT = 742, LENGTH2 = 743, 
    LENGTH4 = 744, LENGTHB = 745, LENGTHC = 746, LENGTH = 747, LESS = 748, 
    LEVEL = 749, LEVELS = 750, LIBRARY = 751, LIFECYCLE = 752, LIFE = 753, 
    LIFETIME = 754, LIKE2 = 755, LIKE4 = 756, LIKEC = 757, LIKE_EXPAND = 758, 
    LIKE = 759, LIMIT = 760, LINEAR = 761, LINK = 762, LIST = 763, LN = 764, 
    LNNVL = 765, LOAD = 766, LOB = 767, LOBNVL = 768, LOBS = 769, LOCAL_INDEXES = 770, 
    LOCAL = 771, LOCALTIME = 772, LOCALTIMESTAMP = 773, LOCATION = 774, 
    LOCATOR = 775, LOCKED = 776, LOCKING = 777, LOCK = 778, LOGFILE = 779, 
    LOGFILES = 780, LOGGING = 781, LOGICAL = 782, LOGICAL_READS_PER_CALL = 783, 
    LOGICAL_READS_PER_SESSION = 784, LOG = 785, LOGMINING = 786, LOGOFF = 787, 
    LOGON = 788, LOG_READ_ONLY_VIOLATIONS = 789, LONG = 790, LOOP = 791, 
    LOWER = 792, LOW = 793, LPAD = 794, LTRIM = 795, MAIN = 796, EXTENDED = 797, 
    MAKE_REF = 798, MANAGED = 799, MANAGE = 800, MANAGEMENT = 801, MANAGER = 802, 
    MANUAL = 803, MAP = 804, MAPPING = 805, MASTER = 806, MATCHED = 807, 
    MATCHES = 808, MATCH = 809, MATCH_NUMBER = 810, MATCH_RECOGNIZE = 811, 
    MATERIALIZED = 812, MATERIALIZE = 813, MAXARCHLOGS = 814, MAXDATAFILES = 815, 
    MAXEXTENTS = 816, MAXIMIZE = 817, MAXINSTANCES = 818, MAXLOGFILES = 819, 
    MAXLOGHISTORY = 820, MAXLOGMEMBERS = 821, MAX_SHARED_TEMP_SIZE = 822, 
    MAXSIZE = 823, MAXTRANS = 824, MAXVALUE = 825, MEASURE = 826, MEASURES = 827, 
    MEDIUM = 828, MEMBER = 829, MEMCOMPRESS = 830, MEMORY = 831, MERGEACTIONS = 832, 
    MERGE_AJ = 833, MERGE_CONST_ON = 834, MERGE = 835, MERGE_SJ = 836, METADATA = 837, 
    METHOD = 838, MIGRATE = 839, MIGRATION = 840, MINEXTENTS = 841, MINIMIZE = 842, 
    MINIMUM = 843, MINING = 844, MINUS = 845, MINUS_NULL = 846, MINUTE = 847, 
    MINVALUE = 848, MIRRORCOLD = 849, MIRRORHOT = 850, MIRROR = 851, MLSLABEL = 852, 
    MODEL_COMPILE_SUBQUERY = 853, MODEL_DONTVERIFY_UNIQUENESS = 854, MODEL_DYNAMIC_SUBQUERY = 855, 
    MODEL_MIN_ANALYSIS = 856, MODEL = 857, MODEL_NB = 858, MODEL_NO_ANALYSIS = 859, 
    MODEL_PBY = 860, MODEL_PUSH_REF = 861, MODEL_SV = 862, MODE = 863, MODIFICATION = 864, 
    MODIFY_COLUMN_TYPE = 865, MODIFY = 866, MOD = 867, MODULE = 868, MONITORING = 869, 
    MONITOR = 870, MONTH = 871, MONTHS_BETWEEN = 872, MONTHS = 873, MOUNT = 874, 
    MOUNTPATH = 875, MOVEMENT = 876, MOVE = 877, MULTIDIMENSIONAL = 878, 
    MULTISET = 879, MV_MERGE = 880, NAMED = 881, NAME = 882, NAMESPACE = 883, 
    NAN = 884, NANVL = 885, NATIONAL = 886, NATIVE_FULL_OUTER_JOIN = 887, 
    NATIVE = 888, NATURAL = 889, NATURALN = 890, NAV = 891, NCHAR_CS = 892, 
    NCHAR = 893, NCHR = 894, NCLOB = 895, NEEDED = 896, NEG = 897, NESTED = 898, 
    NESTED_TABLE_FAST_INSERT = 899, NESTED_TABLE_GET_REFS = 900, NESTED_TABLE_ID = 901, 
    NESTED_TABLE_SET_REFS = 902, NESTED_TABLE_SET_SETID = 903, NETWORK = 904, 
    NEVER = 905, NEW = 906, NEW_TIME = 907, NEXT_DAY = 908, NEXT = 909, 
    NL_AJ = 910, NLJ_BATCHING = 911, NLJ_INDEX_FILTER = 912, NLJ_INDEX_SCAN = 913, 
    NLJ_PREFETCH = 914, NLS_CALENDAR = 915, NLS_CHARACTERSET = 916, NLS_CHARSET_DECL_LEN = 917, 
    NLS_CHARSET_ID = 918, NLS_CHARSET_NAME = 919, NLS_COMP = 920, NLS_CURRENCY = 921, 
    NLS_DATE_FORMAT = 922, NLS_DATE_LANGUAGE = 923, NLS_INITCAP = 924, NLS_ISO_CURRENCY = 925, 
    NL_SJ = 926, NLS_LANG = 927, NLS_LANGUAGE = 928, NLS_LENGTH_SEMANTICS = 929, 
    NLS_LOWER = 930, NLS_NCHAR_CONV_EXCP = 931, NLS_NUMERIC_CHARACTERS = 932, 
    NLS_SORT = 933, NLSSORT = 934, NLS_SPECIAL_CHARS = 935, NLS_TERRITORY = 936, 
    NLS_UPPER = 937, NO_ACCESS = 938, NO_ADAPTIVE_PLAN = 939, NO_ANSI_REARCH = 940, 
    NOAPPEND = 941, NOARCHIVELOG = 942, NOAUDIT = 943, NO_AUTO_REOPTIMIZE = 944, 
    NO_BASETABLE_MULTIMV_REWRITE = 945, NO_BATCH_TABLE_ACCESS_BY_ROWID = 946, 
    NO_BIND_AWARE = 947, NO_BUFFER = 948, NOCACHE = 949, NO_CARTESIAN = 950, 
    NO_CHECK_ACL_REWRITE = 951, NO_CLUSTER_BY_ROWID = 952, NO_CLUSTERING = 953, 
    NO_COALESCE_SQ = 954, NO_COMMON_DATA = 955, NOCOMPRESS = 956, NO_CONNECT_BY_CB_WHR_ONLY = 957, 
    NO_CONNECT_BY_COMBINE_SW = 958, NO_CONNECT_BY_COST_BASED = 959, NO_CONNECT_BY_ELIM_DUPS = 960, 
    NO_CONNECT_BY_FILTERING = 961, NOCOPY = 962, NO_COST_XML_QUERY_REWRITE = 963, 
    NO_CPU_COSTING = 964, NOCPU_COSTING = 965, NOCYCLE = 966, NO_DATA_SECURITY_REWRITE = 967, 
    NO_DECORRELATE = 968, NODELAY = 969, NO_DOMAIN_INDEX_FILTER = 970, NO_DST_UPGRADE_INSERT_CONV = 971, 
    NO_ELIM_GROUPBY = 972, NO_ELIMINATE_JOIN = 973, NO_ELIMINATE_OBY = 974, 
    NO_ELIMINATE_OUTER_JOIN = 975, NOENTITYESCAPING = 976, NO_EXPAND_GSET_TO_UNION = 977, 
    NO_EXPAND = 978, NO_EXPAND_TABLE = 979, NO_FACT = 980, NO_FACTORIZE_JOIN = 981, 
    NO_FILTERING = 982, NOFORCE = 983, NO_FULL_OUTER_JOIN_TO_OUTER = 984, 
    NO_GATHER_OPTIMIZER_STATISTICS = 985, NO_GBY_PUSHDOWN = 986, NOGUARANTEE = 987, 
    NO_INDEX_FFS = 988, NO_INDEX = 989, NO_INDEX_SS = 990, NO_INMEMORY = 991, 
    NO_INMEMORY_PRUNING = 992, NOKEEP = 993, NO_LOAD = 994, NOLOCAL = 995, 
    NOLOGGING = 996, NOMAPPING = 997, NOMAXVALUE = 998, NO_MERGE = 999, 
    NOMINIMIZE = 1000, NOMINVALUE = 1001, NO_MODEL_PUSH_REF = 1002, NO_MONITORING = 1003, 
    NOMONITORING = 1004, NO_MONITOR = 1005, NO_MULTIMV_REWRITE = 1006, NO_NATIVE_FULL_OUTER_JOIN = 1007, 
    NONBLOCKING = 1008, NONEDITIONABLE = 1009, NONE = 1010, NO_NLJ_BATCHING = 1011, 
    NO_NLJ_PREFETCH = 1012, NO = 1013, NONSCHEMA = 1014, NO_OBJECT_LINK = 1015, 
    NOORDER = 1016, NO_ORDER_ROLLUPS = 1017, NO_OUTER_JOIN_TO_ANTI = 1018, 
    NO_OUTER_JOIN_TO_INNER = 1019, NOOVERRIDE = 1020, NO_PARALLEL_INDEX = 1021, 
    NOPARALLEL_INDEX = 1022, NO_PARALLEL = 1023, NOPARALLEL = 1024, NO_PARTIAL_COMMIT = 1025, 
    NO_PARTIAL_JOIN = 1026, NO_PARTIAL_ROLLUP_PUSHDOWN = 1027, NOPARTITION = 1028, 
    NO_PLACE_DISTINCT = 1029, NO_PLACE_GROUP_BY = 1030, NO_PQ_CONCURRENT_UNION = 1031, 
    NO_PQ_MAP = 1032, NO_PQ_REPLICATE = 1033, NO_PQ_SKEW = 1034, NO_PRUNE_GSETS = 1035, 
    NO_PULL_PRED = 1036, NO_PUSH_PRED = 1037, NO_PUSH_SUBQ = 1038, NO_PX_FAULT_TOLERANCE = 1039, 
    NO_PX_JOIN_FILTER = 1040, NO_QKN_BUFF = 1041, NO_QUERY_TRANSFORMATION = 1042, 
    NO_REF_CASCADE = 1043, NORELOCATE = 1044, NORELY = 1045, NOREPAIR = 1046, 
    NOREPLAY = 1047, NORESETLOGS = 1048, NO_RESULT_CACHE = 1049, NOREVERSE = 1050, 
    NO_REWRITE = 1051, NOREWRITE = 1052, NORMAL = 1053, NO_ROOT_SW_FOR_LOCAL = 1054, 
    NOROWDEPENDENCIES = 1055, NOSCHEMACHECK = 1056, NOSEGMENT = 1057, NO_SEMIJOIN = 1058, 
    NO_SEMI_TO_INNER = 1059, NO_SET_TO_JOIN = 1060, NOSORT = 1061, NO_SQL_TRANSLATION = 1062, 
    NO_SQL_TUNE = 1063, NO_STAR_TRANSFORMATION = 1064, NO_STATEMENT_QUEUING = 1065, 
    NO_STATS_GSETS = 1066, NOSTRICT = 1067, NO_SUBQUERY_PRUNING = 1068, 
    NO_SUBSTRB_PAD = 1069, NO_SWAP_JOIN_INPUTS = 1070, NOSWITCH = 1071, 
    NO_TABLE_LOOKUP_BY_NL = 1072, NO_TEMP_TABLE = 1073, NOTHING = 1074, 
    NOTIFICATION = 1075, NOT = 1076, NO_TRANSFORM_DISTINCT_AGG = 1077, NO_UNNEST = 1078, 
    NO_USE_CUBE = 1079, NO_USE_HASH_AGGREGATION = 1080, NO_USE_HASH_GBY_FOR_PUSHDOWN = 1081, 
    NO_USE_HASH = 1082, NO_USE_INVISIBLE_INDEXES = 1083, NO_USE_MERGE = 1084, 
    NO_USE_NL = 1085, NO_USE_VECTOR_AGGREGATION = 1086, NOVALIDATE = 1087, 
    NO_VECTOR_TRANSFORM_DIMS = 1088, NO_VECTOR_TRANSFORM_FACT = 1089, NO_VECTOR_TRANSFORM = 1090, 
    NOWAIT = 1091, NO_XDB_FASTPATH_INSERT = 1092, NO_XML_DML_REWRITE = 1093, 
    NO_XMLINDEX_REWRITE_IN_SELECT = 1094, NO_XMLINDEX_REWRITE = 1095, NO_XML_QUERY_REWRITE = 1096, 
    NO_ZONEMAP = 1097, NTH_VALUE = 1098, NULLIF = 1099, NULL_ = 1100, NULLS = 1101, 
    NUMBER = 1102, NUMERIC = 1103, NUM_INDEX_KEYS = 1104, NUMTODSINTERVAL = 1105, 
    NUMTOYMINTERVAL = 1106, NVARCHAR2 = 1107, NVL2 = 1108, OBJECT2XML = 1109, 
    OBJECT = 1110, OBJ_ID = 1111, OBJNO = 1112, OBJNO_REUSE = 1113, OCCURENCES = 1114, 
    OFFLINE = 1115, OFF = 1116, OFFSET = 1117, OF = 1118, OIDINDEX = 1119, 
    OID = 1120, OLAP = 1121, OLD = 1122, OLD_PUSH_PRED = 1123, OLS = 1124, 
    OLTP = 1125, OMIT = 1126, ONE = 1127, ONLINE = 1128, ONLINELOG = 1129, 
    ONLY = 1130, ON = 1131, OPAQUE = 1132, OPAQUE_TRANSFORM = 1133, OPAQUE_XCANONICAL = 1134, 
    OPCODE = 1135, OPEN = 1136, OPERATIONS = 1137, OPERATOR = 1138, OPT_ESTIMATE = 1139, 
    OPTIMAL = 1140, OPTIMIZE = 1141, OPTIMIZER_FEATURES_ENABLE = 1142, OPTIMIZER_GOAL = 1143, 
    OPTION = 1144, OPT_PARAM = 1145, ORA_BRANCH = 1146, ORA_CHECK_ACL = 1147, 
    ORA_CHECK_PRIVILEGE = 1148, ORA_CLUSTERING = 1149, ORADATA = 1150, ORADEBUG = 1151, 
    ORA_DST_AFFECTED = 1152, ORA_DST_CONVERT = 1153, ORA_DST_ERROR = 1154, 
    ORA_GET_ACLIDS = 1155, ORA_GET_PRIVILEGES = 1156, ORA_HASH = 1157, ORA_INVOKING_USERID = 1158, 
    ORA_INVOKING_USER = 1159, ORA_INVOKING_XS_USER_GUID = 1160, ORA_INVOKING_XS_USER = 1161, 
    ORA_RAWCOMPARE = 1162, ORA_RAWCONCAT = 1163, ORA_ROWSCN = 1164, ORA_ROWSCN_RAW = 1165, 
    ORA_ROWVERSION = 1166, ORA_TABVERSION = 1167, ORA_WRITE_TIME = 1168, 
    ORDERED = 1169, ORDERED_PREDICATES = 1170, ORDER = 1171, ORDINALITY = 1172, 
    OR_EXPAND = 1173, ORGANIZATION = 1174, OR = 1175, OR_PREDICATES = 1176, 
    OSERROR = 1177, OTHER = 1178, OUTER_JOIN_TO_ANTI = 1179, OUTER_JOIN_TO_INNER = 1180, 
    OUTER = 1181, OUTLINE_LEAF = 1182, OUTLINE = 1183, OUT_OF_LINE = 1184, 
    OUT = 1185, OVERFLOW_NOMOVE = 1186, OVERFLOW = 1187, OVERLAPS = 1188, 
    OVER = 1189, OVERRIDING = 1190, OWNER = 1191, OWNERSHIP = 1192, OWN = 1193, 
    PACKAGE = 1194, PACKAGES = 1195, PARALLEL_ENABLE = 1196, PARALLEL_INDEX = 1197, 
    PARALLEL = 1198, PARAMETERFILE = 1199, PARAMETERS = 1200, PARAM = 1201, 
    PARENT = 1202, PARITY = 1203, PARTIAL_JOIN = 1204, PARTIALLY = 1205, 
    PARTIAL = 1206, PARTIAL_ROLLUP_PUSHDOWN = 1207, PARTITION_HASH = 1208, 
    PARTITION_LIST = 1209, PARTITION = 1210, PARTITION_RANGE = 1211, PARTITIONS = 1212, 
    PARTNUMINST = 1213, PASSING = 1214, PASSWORD_GRACE_TIME = 1215, PASSWORD_LIFE_TIME = 1216, 
    PASSWORD_LOCK_TIME = 1217, PASSWORD = 1218, PASSWORD_REUSE_MAX = 1219, 
    PASSWORD_REUSE_TIME = 1220, PASSWORD_VERIFY_FUNCTION = 1221, PAST = 1222, 
    PATCH = 1223, PATH = 1224, PATH_PREFIX = 1225, PATHS = 1226, PATTERN = 1227, 
    PBL_HS_BEGIN = 1228, PBL_HS_END = 1229, PCTFREE = 1230, PCTINCREASE = 1231, 
    PCTTHRESHOLD = 1232, PCTUSED = 1233, PCTVERSION = 1234, PENDING = 1235, 
    PERCENT_KEYWORD = 1236, PERCENT_RANKM = 1237, PERFORMANCE = 1238, PERIOD_KEYWORD = 1239, 
    PERMANENT = 1240, PERMISSION = 1241, PERMUTE = 1242, PER = 1243, PFILE = 1244, 
    PHYSICAL = 1245, PIKEY = 1246, PIPELINED = 1247, PIPE = 1248, PIV_GB = 1249, 
    PIVOT = 1250, PIV_SSF = 1251, PLACE_DISTINCT = 1252, PLACE_GROUP_BY = 1253, 
    PLAN = 1254, PLSCOPE_SETTINGS = 1255, PLS_INTEGER = 1256, PLSQL_CCFLAGS = 1257, 
    PLSQL_CODE_TYPE = 1258, PLSQL_DEBUG = 1259, PLSQL_OPTIMIZE_LEVEL = 1260, 
    PLSQL_WARNINGS = 1261, PLUGGABLE = 1262, POINT = 1263, POLICY = 1264, 
    POOL_16K = 1265, POOL_2K = 1266, POOL_32K = 1267, POOL_4K = 1268, POOL_8K = 1269, 
    POSITIVEN = 1270, POSITIVE = 1271, POST_TRANSACTION = 1272, POWERMULTISET_BY_CARDINALITY = 1273, 
    POWERMULTISET = 1274, POWER = 1275, PQ_CONCURRENT_UNION = 1276, PQ_DISTRIBUTE = 1277, 
    PQ_DISTRIBUTE_WINDOW = 1278, PQ_FILTER = 1279, PQ_MAP = 1280, PQ_NOMAP = 1281, 
    PQ_REPLICATE = 1282, PQ_SKEW = 1283, PRAGMA = 1284, PREBUILT = 1285, 
    PRECEDES = 1286, PRECEDING = 1287, PRECISION = 1288, PRECOMPUTE_SUBQUERY = 1289, 
    PREDICATE_REORDERS = 1290, PRELOAD = 1291, PREPARE = 1292, PRESENTNNV = 1293, 
    PRESENT = 1294, PRESENTV = 1295, PRESERVE_OID = 1296, PRESERVE = 1297, 
    PRETTY = 1298, PREVIOUS = 1299, PREV = 1300, PRIMARY = 1301, PRINTBLOBTOCLOB = 1302, 
    PRIORITY = 1303, PRIOR = 1304, PRIVATE = 1305, PRIVATE_SGA = 1306, PRIVILEGED = 1307, 
    PRIVILEGE = 1308, PRIVILEGES = 1309, PROCEDURAL = 1310, PROCEDURE = 1311, 
    PROCESS = 1312, PROFILE = 1313, PROGRAM = 1314, PROJECT = 1315, PROPAGATE = 1316, 
    PROTECTED = 1317, PROTECTION = 1318, PROXY = 1319, PRUNING = 1320, PUBLIC = 1321, 
    PULL_PRED = 1322, PURGE = 1323, PUSH_PRED = 1324, PUSH_SUBQ = 1325, 
    PX_FAULT_TOLERANCE = 1326, PX_GRANULE = 1327, PX_JOIN_FILTER = 1328, 
    QB_NAME = 1329, QUERY_BLOCK = 1330, QUERY = 1331, QUEUE_CURR = 1332, 
    QUEUE = 1333, QUEUE_ROWP = 1334, QUIESCE = 1335, QUORUM = 1336, QUOTA = 1337, 
    RAISE = 1338, RANDOM_LOCAL = 1339, RANDOM = 1340, RANGE = 1341, RANKM = 1342, 
    RAPIDLY = 1343, RAW = 1344, RAWTOHEX = 1345, RAWTONHEX = 1346, RBA = 1347, 
    RBO_OUTLINE = 1348, RDBA = 1349, READ = 1350, READS = 1351, REALM = 1352, 
    REAL = 1353, REBALANCE = 1354, REBUILD = 1355, RECORD = 1356, RECORDS_PER_BLOCK = 1357, 
    RECOVERABLE = 1358, RECOVER = 1359, RECOVERY = 1360, RECYCLEBIN = 1361, 
    RECYCLE = 1362, REDACTION = 1363, REDEFINE = 1364, REDO = 1365, REDUCED = 1366, 
    REDUNDANCY = 1367, REF_CASCADE_CURSOR = 1368, REFERENCED = 1369, REFERENCE = 1370, 
    REFERENCES = 1371, REFERENCING = 1372, REF = 1373, REFRESH = 1374, REFTOHEX = 1375, 
    REGEXP_COUNT = 1376, REGEXP_INSTR = 1377, REGEXP_LIKE = 1378, REGEXP_REPLACE = 1379, 
    REGEXP_SUBSTR = 1380, REGISTER = 1381, REGR_AVGX = 1382, REGR_AVGY = 1383, 
    REGR_COUNT = 1384, REGR_INTERCEPT = 1385, REGR_R2 = 1386, REGR_SLOPE = 1387, 
    REGR_SXX = 1388, REGR_SXY = 1389, REGR_SYY = 1390, REGULAR = 1391, REJECT = 1392, 
    REKEY = 1393, RELATIONAL = 1394, RELIES_ON = 1395, RELOCATE = 1396, 
    RELY = 1397, REMAINDER = 1398, REMOTE_MAPPED = 1399, REMOVE = 1400, 
    RENAME = 1401, REPAIR = 1402, REPEAT = 1403, REPLACE = 1404, REPLICATION = 1405, 
    REQUIRED = 1406, RESETLOGS = 1407, RESET = 1408, RESIZE = 1409, RESOLVE = 1410, 
    RESOLVER = 1411, RESOURCE = 1412, RESPECT = 1413, RESTART = 1414, RESTORE_AS_INTERVALS = 1415, 
    RESTORE = 1416, RESTRICT_ALL_REF_CONS = 1417, RESTRICTED = 1418, RESTRICT_REFERENCES = 1419, 
    RESTRICT = 1420, RESULT_CACHE = 1421, RESULT = 1422, RESUMABLE = 1423, 
    RESUME = 1424, RETENTION = 1425, RETRY_ON_ROW_CHANGE = 1426, RETURNING = 1427, 
    RETURN = 1428, REUSE = 1429, REVERSE = 1430, REVOKE = 1431, REWRITE_OR_ERROR = 1432, 
    REWRITE = 1433, RIGHT = 1434, ROLE = 1435, ROLESET = 1436, ROLES = 1437, 
    ROLLBACK = 1438, ROLLING = 1439, ROLLUP = 1440, ROWDEPENDENCIES = 1441, 
    ROWID_MAPPING_TABLE = 1442, ROWID = 1443, ROWIDTOCHAR = 1444, ROWIDTONCHAR = 1445, 
    ROW_LENGTH = 1446, ROWNUM = 1447, ROW = 1448, ROWS = 1449, RPAD = 1450, 
    RTRIM = 1451, RULE = 1452, RULES = 1453, RUNNING = 1454, SALT = 1455, 
    SAMPLE = 1456, SAVE_AS_INTERVALS = 1457, SAVEPOINT = 1458, SAVE = 1459, 
    SB4 = 1460, SCALE_ROWS = 1461, SCALE = 1462, SCAN_INSTANCES = 1463, 
    SCAN = 1464, SCHEDULER = 1465, SCHEMACHECK = 1466, SCHEMA = 1467, SCN_ASCENDING = 1468, 
    SCN = 1469, SCOPE = 1470, SCRUB = 1471, SD_ALL = 1472, SD_INHIBIT = 1473, 
    SDO_GEOM_MBR = 1474, SD_SHOW = 1475, SEARCH = 1476, SECOND = 1477, SECRET = 1478, 
    SECUREFILE_DBA = 1479, SECUREFILE = 1480, SECURITY = 1481, SEED = 1482, 
    SEG_BLOCK = 1483, SEG_FILE = 1484, SEGMENT = 1485, SELECTIVITY = 1486, 
    SELECT = 1487, SELF = 1488, SEMIJOIN_DRIVER = 1489, SEMIJOIN = 1490, 
    SEMI_TO_INNER = 1491, SEQUENCED = 1492, SEQUENCE = 1493, SEQUENTIAL = 1494, 
    SEQ = 1495, SERIALIZABLE = 1496, SERIALLY_REUSABLE = 1497, SERIAL = 1498, 
    SERVERERROR = 1499, SERVICE_NAME_CONVERT = 1500, SERVICES = 1501, SESSION_CACHED_CURSORS = 1502, 
    SESSION = 1503, SESSIONS_PER_USER = 1504, SESSIONTIMEZONE = 1505, SESSIONTZNAME = 1506, 
    SET = 1507, SETS = 1508, SETTINGS = 1509, SET_TO_JOIN = 1510, SEVERE = 1511, 
    SHARED_POOL = 1512, SHARED = 1513, SHARE = 1514, SHARING = 1515, SHELFLIFE = 1516, 
    SHOW = 1517, SHRINK = 1518, SHUTDOWN = 1519, SIBLINGS = 1520, SID = 1521, 
    SIGNAL_COMPONENT = 1522, SIGNAL_FUNCTION = 1523, SIGN = 1524, SIGNTYPE = 1525, 
    SIMPLE_INTEGER = 1526, SIMPLE = 1527, SINGLE = 1528, SINGLETASK = 1529, 
    SINH = 1530, SIN = 1531, SIZE = 1532, SKIP_EXT_OPTIMIZER = 1533, SKIP_ = 1534, 
    SKIP_UNQ_UNUSABLE_IDX = 1535, SKIP_UNUSABLE_INDEXES = 1536, SMALLFILE = 1537, 
    SMALLINT = 1538, SNAPSHOT = 1539, SOME = 1540, SORT = 1541, SOUNDEX = 1542, 
    SOURCE_FILE_DIRECTORY = 1543, SOURCE_FILE_NAME_CONVERT = 1544, SOURCE = 1545, 
    SPACE_KEYWORD = 1546, SPECIFICATION = 1547, SPFILE = 1548, SPLIT = 1549, 
    SPREADSHEET = 1550, SQLDATA = 1551, SQLERROR = 1552, SQLLDR = 1553, 
    SQL = 1554, SQL_TRACE = 1555, SQL_TRANSLATION_PROFILE = 1556, SQRT = 1557, 
    STALE = 1558, STANDALONE = 1559, STANDARD_HASH = 1560, STANDBY_MAX_DATA_DELAY = 1561, 
    STANDBYS = 1562, STANDBY = 1563, STAR = 1564, STAR_TRANSFORMATION = 1565, 
    START = 1566, STARTUP = 1567, STATEMENT_ID = 1568, STATEMENT_QUEUING = 1569, 
    STATEMENTS = 1570, STATEMENT = 1571, STATE = 1572, STATIC = 1573, STATISTICS = 1574, 
    STATS_BINOMIAL_TEST = 1575, STATS_CROSSTAB = 1576, STATS_F_TEST = 1577, 
    STATS_KS_TEST = 1578, STATS_MODE = 1579, STATS_MW_TEST = 1580, STATS_ONE_WAY_ANOVA = 1581, 
    STATS_T_TEST_INDEP = 1582, STATS_T_TEST_INDEPU = 1583, STATS_T_TEST_ONE = 1584, 
    STATS_T_TEST_PAIRED = 1585, STATS_WSR_TEST = 1586, STDDEV_POP = 1587, 
    STDDEV_SAMP = 1588, STOP = 1589, STORAGE = 1590, STORE = 1591, STREAMS = 1592, 
    STREAM = 1593, STRICT = 1594, STRING = 1595, STRIPE_COLUMNS = 1596, 
    STRIPE_WIDTH = 1597, STRIP = 1598, STRUCTURE = 1599, SUBMULTISET = 1600, 
    SUBPARTITION_REL = 1601, SUBPARTITIONS = 1602, SUBPARTITION = 1603, 
    SUBQUERIES = 1604, SUBQUERY_PRUNING = 1605, SUBSCRIBE = 1606, SUBSET = 1607, 
    SUBSTITUTABLE = 1608, SUBSTR2 = 1609, SUBSTR4 = 1610, SUBSTRB = 1611, 
    SUBSTRC = 1612, SUBTYPE = 1613, SUCCESSFUL = 1614, SUCCESS = 1615, SUMMARY = 1616, 
    SUPPLEMENTAL = 1617, SUSPEND = 1618, SWAP_JOIN_INPUTS = 1619, SWITCHOVER = 1620, 
    SWITCH = 1621, SYNCHRONOUS = 1622, SYNC = 1623, SYNONYM = 1624, SYSASM = 1625, 
    SYS_AUDIT = 1626, SYSAUX = 1627, SYSBACKUP = 1628, SYS_CHECKACL = 1629, 
    SYS_CHECK_PRIVILEGE = 1630, SYS_CONNECT_BY_PATH = 1631, SYS_CONTEXT = 1632, 
    SYSDATE = 1633, SYSDBA = 1634, SYS_DBURIGEN = 1635, SYSDG = 1636, SYS_DL_CURSOR = 1637, 
    SYS_DM_RXFORM_CHR = 1638, SYS_DM_RXFORM_NUM = 1639, SYS_DOM_COMPARE = 1640, 
    SYS_DST_PRIM2SEC = 1641, SYS_DST_SEC2PRIM = 1642, SYS_ET_BFILE_TO_RAW = 1643, 
    SYS_ET_BLOB_TO_IMAGE = 1644, SYS_ET_IMAGE_TO_BLOB = 1645, SYS_ET_RAW_TO_BFILE = 1646, 
    SYS_EXTPDTXT = 1647, SYS_EXTRACT_UTC = 1648, SYS_FBT_INSDEL = 1649, 
    SYS_FILTER_ACLS = 1650, SYS_FNMATCHES = 1651, SYS_FNREPLACE = 1652, 
    SYS_GET_ACLIDS = 1653, SYS_GET_COL_ACLIDS = 1654, SYS_GET_PRIVILEGES = 1655, 
    SYS_GETTOKENID = 1656, SYS_GETXTIVAL = 1657, SYS_GUID = 1658, SYSGUID = 1659, 
    SYSKM = 1660, SYS_MAKE_XMLNODEID = 1661, SYS_MAKEXML = 1662, SYS_MKXMLATTR = 1663, 
    SYS_MKXTI = 1664, SYSOBJ = 1665, SYS_OP_ADT2BIN = 1666, SYS_OP_ADTCONS = 1667, 
    SYS_OP_ALSCRVAL = 1668, SYS_OP_ATG = 1669, SYS_OP_BIN2ADT = 1670, SYS_OP_BITVEC = 1671, 
    SYS_OP_BL2R = 1672, SYS_OP_BLOOM_FILTER_LIST = 1673, SYS_OP_BLOOM_FILTER = 1674, 
    SYS_OP_C2C = 1675, SYS_OP_CAST = 1676, SYS_OP_CEG = 1677, SYS_OP_CL2C = 1678, 
    SYS_OP_COMBINED_HASH = 1679, SYS_OP_COMP = 1680, SYS_OP_CONVERT = 1681, 
    SYS_OP_COUNTCHG = 1682, SYS_OP_CSCONV = 1683, SYS_OP_CSCONVTEST = 1684, 
    SYS_OP_CSR = 1685, SYS_OP_CSX_PATCH = 1686, SYS_OP_CYCLED_SEQ = 1687, 
    SYS_OP_DECOMP = 1688, SYS_OP_DESCEND = 1689, SYS_OP_DISTINCT = 1690, 
    SYS_OP_DRA = 1691, SYS_OP_DUMP = 1692, SYS_OP_DV_CHECK = 1693, SYS_OP_ENFORCE_NOT_NULL = 1694, 
    SYSOPER = 1695, SYS_OP_EXTRACT = 1696, SYS_OP_GROUPING = 1697, SYS_OP_GUID = 1698, 
    SYS_OP_HASH = 1699, SYS_OP_IIX = 1700, SYS_OP_ITR = 1701, SYS_OP_KEY_VECTOR_CREATE = 1702, 
    SYS_OP_KEY_VECTOR_FILTER_LIST = 1703, SYS_OP_KEY_VECTOR_FILTER = 1704, 
    SYS_OP_KEY_VECTOR_SUCCEEDED = 1705, SYS_OP_KEY_VECTOR_USE = 1706, SYS_OP_LBID = 1707, 
    SYS_OP_LOBLOC2BLOB = 1708, SYS_OP_LOBLOC2CLOB = 1709, SYS_OP_LOBLOC2ID = 1710, 
    SYS_OP_LOBLOC2NCLOB = 1711, SYS_OP_LOBLOC2TYP = 1712, SYS_OP_LSVI = 1713, 
    SYS_OP_LVL = 1714, SYS_OP_MAKEOID = 1715, SYS_OP_MAP_NONNULL = 1716, 
    SYS_OP_MSR = 1717, SYS_OP_NICOMBINE = 1718, SYS_OP_NIEXTRACT = 1719, 
    SYS_OP_NII = 1720, SYS_OP_NIX = 1721, SYS_OP_NOEXPAND = 1722, SYS_OP_NTCIMG = 1723, 
    SYS_OP_NUMTORAW = 1724, SYS_OP_OIDVALUE = 1725, SYS_OP_OPNSIZE = 1726, 
    SYS_OP_PAR_1 = 1727, SYS_OP_PARGID_1 = 1728, SYS_OP_PARGID = 1729, SYS_OP_PAR = 1730, 
    SYS_OP_PART_ID = 1731, SYS_OP_PIVOT = 1732, SYS_OP_R2O = 1733, SYS_OP_RAWTONUM = 1734, 
    SYS_OP_RDTM = 1735, SYS_OP_REF = 1736, SYS_OP_RMTD = 1737, SYS_OP_ROWIDTOOBJ = 1738, 
    SYS_OP_RPB = 1739, SYS_OPTLOBPRBSC = 1740, SYS_OP_TOSETID = 1741, SYS_OP_TPR = 1742, 
    SYS_OP_TRTB = 1743, SYS_OPTXICMP = 1744, SYS_OPTXQCASTASNQ = 1745, SYS_OP_UNDESCEND = 1746, 
    SYS_OP_VECAND = 1747, SYS_OP_VECBIT = 1748, SYS_OP_VECOR = 1749, SYS_OP_VECXOR = 1750, 
    SYS_OP_VERSION = 1751, SYS_OP_VREF = 1752, SYS_OP_VVD = 1753, SYS_OP_XMLCONS_FOR_CSX = 1754, 
    SYS_OP_XPTHATG = 1755, SYS_OP_XPTHIDX = 1756, SYS_OP_XPTHOP = 1757, 
    SYS_OP_XTXT2SQLT = 1758, SYS_OP_ZONE_ID = 1759, SYS_ORDERKEY_DEPTH = 1760, 
    SYS_ORDERKEY_MAXCHILD = 1761, SYS_ORDERKEY_PARENT = 1762, SYS_PARALLEL_TXN = 1763, 
    SYS_PATHID_IS_ATTR = 1764, SYS_PATHID_IS_NMSPC = 1765, SYS_PATHID_LASTNAME = 1766, 
    SYS_PATHID_LASTNMSPC = 1767, SYS_PATH_REVERSE = 1768, SYS_PXQEXTRACT = 1769, 
    SYS_RAW_TO_XSID = 1770, SYS_RID_ORDER = 1771, SYS_ROW_DELTA = 1772, 
    SYS_SC_2_XMLT = 1773, SYS_SYNRCIREDO = 1774, SYSTEM_DEFINED = 1775, 
    SYSTEM = 1776, SYSTIMESTAMP = 1777, SYS_TYPEID = 1778, SYS_UMAKEXML = 1779, 
    SYS_XMLANALYZE = 1780, SYS_XMLCONTAINS = 1781, SYS_XMLCONV = 1782, SYS_XMLEXNSURI = 1783, 
    SYS_XMLGEN = 1784, SYS_XMLI_LOC_ISNODE = 1785, SYS_XMLI_LOC_ISTEXT = 1786, 
    SYS_XMLINSTR = 1787, SYS_XMLLOCATOR_GETSVAL = 1788, SYS_XMLNODEID_GETCID = 1789, 
    SYS_XMLNODEID_GETLOCATOR = 1790, SYS_XMLNODEID_GETOKEY = 1791, SYS_XMLNODEID_GETPATHID = 1792, 
    SYS_XMLNODEID_GETPTRID = 1793, SYS_XMLNODEID_GETRID = 1794, SYS_XMLNODEID_GETSVAL = 1795, 
    SYS_XMLNODEID_GETTID = 1796, SYS_XMLNODEID = 1797, SYS_XMLT_2_SC = 1798, 
    SYS_XMLTRANSLATE = 1799, SYS_XMLTYPE2SQL = 1800, SYS_XQ_ASQLCNV = 1801, 
    SYS_XQ_ATOMCNVCHK = 1802, SYS_XQBASEURI = 1803, SYS_XQCASTABLEERRH = 1804, 
    SYS_XQCODEP2STR = 1805, SYS_XQCODEPEQ = 1806, SYS_XQCON2SEQ = 1807, 
    SYS_XQCONCAT = 1808, SYS_XQDELETE = 1809, SYS_XQDFLTCOLATION = 1810, 
    SYS_XQDOC = 1811, SYS_XQDOCURI = 1812, SYS_XQDURDIV = 1813, SYS_XQED4URI = 1814, 
    SYS_XQENDSWITH = 1815, SYS_XQERRH = 1816, SYS_XQERR = 1817, SYS_XQESHTMLURI = 1818, 
    SYS_XQEXLOBVAL = 1819, SYS_XQEXSTWRP = 1820, SYS_XQEXTRACT = 1821, SYS_XQEXTRREF = 1822, 
    SYS_XQEXVAL = 1823, SYS_XQFB2STR = 1824, SYS_XQFNBOOL = 1825, SYS_XQFNCMP = 1826, 
    SYS_XQFNDATIM = 1827, SYS_XQFNLNAME = 1828, SYS_XQFNNM = 1829, SYS_XQFNNSURI = 1830, 
    SYS_XQFNPREDTRUTH = 1831, SYS_XQFNQNM = 1832, SYS_XQFNROOT = 1833, SYS_XQFORMATNUM = 1834, 
    SYS_XQFTCONTAIN = 1835, SYS_XQFUNCR = 1836, SYS_XQGETCONTENT = 1837, 
    SYS_XQINDXOF = 1838, SYS_XQINSERT = 1839, SYS_XQINSPFX = 1840, SYS_XQIRI2URI = 1841, 
    SYS_XQLANG = 1842, SYS_XQLLNMFRMQNM = 1843, SYS_XQMKNODEREF = 1844, 
    SYS_XQNILLED = 1845, SYS_XQNODENAME = 1846, SYS_XQNORMSPACE = 1847, 
    SYS_XQNORMUCODE = 1848, SYS_XQ_NRNG = 1849, SYS_XQNSP4PFX = 1850, SYS_XQNSPFRMQNM = 1851, 
    SYS_XQPFXFRMQNM = 1852, SYS_XQ_PKSQL2XML = 1853, SYS_XQPOLYABS = 1854, 
    SYS_XQPOLYADD = 1855, SYS_XQPOLYCEL = 1856, SYS_XQPOLYCSTBL = 1857, 
    SYS_XQPOLYCST = 1858, SYS_XQPOLYDIV = 1859, SYS_XQPOLYFLR = 1860, SYS_XQPOLYMOD = 1861, 
    SYS_XQPOLYMUL = 1862, SYS_XQPOLYRND = 1863, SYS_XQPOLYSQRT = 1864, SYS_XQPOLYSUB = 1865, 
    SYS_XQPOLYUMUS = 1866, SYS_XQPOLYUPLS = 1867, SYS_XQPOLYVEQ = 1868, 
    SYS_XQPOLYVGE = 1869, SYS_XQPOLYVGT = 1870, SYS_XQPOLYVLE = 1871, SYS_XQPOLYVLT = 1872, 
    SYS_XQPOLYVNE = 1873, SYS_XQREF2VAL = 1874, SYS_XQRENAME = 1875, SYS_XQREPLACE = 1876, 
    SYS_XQRESVURI = 1877, SYS_XQRNDHALF2EVN = 1878, SYS_XQRSLVQNM = 1879, 
    SYS_XQRYENVPGET = 1880, SYS_XQRYVARGET = 1881, SYS_XQRYWRP = 1882, SYS_XQSEQ2CON4XC = 1883, 
    SYS_XQSEQ2CON = 1884, SYS_XQSEQDEEPEQ = 1885, SYS_XQSEQINSB = 1886, 
    SYS_XQSEQRM = 1887, SYS_XQSEQRVS = 1888, SYS_XQSEQSUB = 1889, SYS_XQSEQTYPMATCH = 1890, 
    SYS_XQSTARTSWITH = 1891, SYS_XQSTATBURI = 1892, SYS_XQSTR2CODEP = 1893, 
    SYS_XQSTRJOIN = 1894, SYS_XQSUBSTRAFT = 1895, SYS_XQSUBSTRBEF = 1896, 
    SYS_XQTOKENIZE = 1897, SYS_XQTREATAS = 1898, SYS_XQ_UPKXML2SQL = 1899, 
    SYS_XQXFORM = 1900, SYS_XSID_TO_RAW = 1901, SYS_ZMAP_FILTER = 1902, 
    SYS_ZMAP_REFRESH = 1903, TABLE_LOOKUP_BY_NL = 1904, TABLESPACE_NO = 1905, 
    TABLESPACE = 1906, TABLES = 1907, TABLE_STATS = 1908, TABLE = 1909, 
    TABNO = 1910, TAG = 1911, TANH = 1912, TAN = 1913, TBLORIDXPARTNUM = 1914, 
    TEMPFILE = 1915, TEMPLATE = 1916, TEMPORARY = 1917, TEMP_TABLE = 1918, 
    TEST = 1919, TEXT = 1920, THAN = 1921, THEN = 1922, THE = 1923, THREAD = 1924, 
    THROUGH = 1925, TIER = 1926, TIES = 1927, TIMEOUT = 1928, TIMESTAMP_LTZ_UNCONSTRAINED = 1929, 
    TIMESTAMP = 1930, TIMESTAMP_TZ_UNCONSTRAINED = 1931, TIMESTAMP_UNCONSTRAINED = 1932, 
    TIMES = 1933, TIME = 1934, TIMEZONE = 1935, TIMEZONE_ABBR = 1936, TIMEZONE_HOUR = 1937, 
    TIMEZONE_MINUTE = 1938, TIMEZONE_OFFSET = 1939, TIMEZONE_REGION = 1940, 
    TIME_ZONE = 1941, TIV_GB = 1942, TIV_SSF = 1943, TO_ACLID = 1944, TO_BINARY_DOUBLE = 1945, 
    TO_BINARY_FLOAT = 1946, TO_BLOB = 1947, TO_CLOB = 1948, TO_DSINTERVAL = 1949, 
    TO_LOB = 1950, TO_MULTI_BYTE = 1951, TO_NCHAR = 1952, TO_NCLOB = 1953, 
    TO_NUMBER = 1954, TOPLEVEL = 1955, TO_SINGLE_BYTE = 1956, TO_TIMESTAMP = 1957, 
    TO_TIMESTAMP_TZ = 1958, TO_TIME = 1959, TO_TIME_TZ = 1960, TO = 1961, 
    TO_YMINTERVAL = 1962, TRACE = 1963, TRACING = 1964, TRACKING = 1965, 
    TRAILING = 1966, TRANSACTION = 1967, TRANSFORM_DISTINCT_AGG = 1968, 
    TRANSITIONAL = 1969, TRANSITION = 1970, TRANSLATE = 1971, TRANSLATION = 1972, 
    TREAT = 1973, TRIGGERS = 1974, TRIGGER = 1975, TRUE = 1976, TRUNCATE = 1977, 
    TRUNC = 1978, TRUSTED = 1979, TRUST = 1980, TUNING = 1981, TX = 1982, 
    TYPES = 1983, TYPE = 1984, TZ_OFFSET = 1985, UB2 = 1986, UBA = 1987, 
    UCS2 = 1988, UID = 1989, UNARCHIVED = 1990, UNBOUNDED = 1991, UNBOUND = 1992, 
    UNCONDITIONAL = 1993, UNDER = 1994, UNDO = 1995, UNDROP = 1996, UNIFORM = 1997, 
    UNION = 1998, UNIQUE = 1999, UNISTR = 2000, UNLIMITED = 2001, UNLOAD = 2002, 
    UNLOCK = 2003, UNMATCHED = 2004, UNNEST_INNERJ_DISTINCT_VIEW = 2005, 
    UNNEST_NOSEMIJ_NODISTINCTVIEW = 2006, UNNEST_SEMIJ_VIEW = 2007, UNNEST = 2008, 
    UNPACKED = 2009, UNPIVOT = 2010, UNPLUG = 2011, UNPROTECTED = 2012, 
    UNQUIESCE = 2013, UNRECOVERABLE = 2014, UNRESTRICTED = 2015, UNSUBSCRIBE = 2016, 
    UNTIL = 2017, UNUSABLE = 2018, UNUSED = 2019, UPDATABLE = 2020, UPDATED = 2021, 
    UPDATE = 2022, UPDATEXML = 2023, UPD_INDEXES = 2024, UPD_JOININDEX = 2025, 
    UPGRADE = 2026, UPPER = 2027, UPSERT = 2028, UROWID = 2029, USABLE = 2030, 
    USAGE = 2031, USE_ANTI = 2032, USE_CONCAT = 2033, USE_CUBE = 2034, USE_HASH_AGGREGATION = 2035, 
    USE_HASH_GBY_FOR_PUSHDOWN = 2036, USE_HASH = 2037, USE_HIDDEN_PARTITIONS = 2038, 
    USE_INVISIBLE_INDEXES = 2039, USE_MERGE_CARTESIAN = 2040, USE_MERGE = 2041, 
    USE_NL = 2042, USE_NL_WITH_INDEX = 2043, USE_PRIVATE_OUTLINES = 2044, 
    USER_DATA = 2045, USER_DEFINED = 2046, USERENV = 2047, USERGROUP = 2048, 
    USER_RECYCLEBIN = 2049, USERS = 2050, USER_TABLESPACES = 2051, USER = 2052, 
    USE_SEMI = 2053, USE_STORED_OUTLINES = 2054, USE_TTT_FOR_GSETS = 2055, 
    USE = 2056, USE_VECTOR_AGGREGATION = 2057, USE_WEAK_NAME_RESL = 2058, 
    USING_NO_EXPAND = 2059, USING = 2060, UTF16BE = 2061, UTF16LE = 2062, 
    UTF32 = 2063, UTF8 = 2064, V1 = 2065, V2 = 2066, VALIDATE = 2067, VALIDATION = 2068, 
    VALID_TIME_END = 2069, VALUES = 2070, VALUE = 2071, VARCHAR2 = 2072, 
    VARCHAR = 2073, VARIABLE = 2074, VAR_POP = 2075, VARRAYS = 2076, VARRAY = 2077, 
    VAR_SAMP = 2078, VARYING = 2079, VECTOR_READ_TRACE = 2080, VECTOR_READ = 2081, 
    VECTOR_TRANSFORM_DIMS = 2082, VECTOR_TRANSFORM_FACT = 2083, VECTOR_TRANSFORM = 2084, 
    VERIFIER = 2085, VERIFY = 2086, VERSIONING = 2087, VERSIONS_ENDSCN = 2088, 
    VERSIONS_ENDTIME = 2089, VERSIONS_OPERATION = 2090, VERSIONS_STARTSCN = 2091, 
    VERSIONS_STARTTIME = 2092, VERSIONS = 2093, VERSIONS_XID = 2094, VERSION = 2095, 
    VIEW = 2096, VIOLATION = 2097, VIRTUAL = 2098, VISIBILITY = 2099, VISIBLE = 2100, 
    VOLUME = 2101, VSIZE = 2102, WAIT = 2103, WALLET = 2104, WARNING = 2105, 
    WEEKS = 2106, WEEK = 2107, WELLFORMED = 2108, WHENEVER = 2109, WHEN = 2110, 
    WHERE = 2111, WHILE = 2112, WHITESPACE = 2113, WIDTH_BUCKET = 2114, 
    WITHIN = 2115, WITHOUT = 2116, WITH_PLSQL = 2117, WITH = 2118, WORK = 2119, 
    WRAPPED = 2120, WRAPPER = 2121, WRITE = 2122, XDB_FASTPATH_INSERT = 2123, 
    XDB = 2124, X_DYN_PRUNE = 2125, XID = 2126, XML2OBJECT = 2127, XMLAGG = 2128, 
    XMLATTRIBUTES = 2129, XMLCAST = 2130, XMLCDATA = 2131, XMLCOLATTVAL = 2132, 
    XMLCOMMENT = 2133, XMLCONCAT = 2134, XMLDIFF = 2135, XML_DML_RWT_STMT = 2136, 
    XMLELEMENT = 2137, XMLEXISTS2 = 2138, XMLEXISTS = 2139, XMLFOREST = 2140, 
    XMLINDEX = 2141, XMLINDEX_REWRITE_IN_SELECT = 2142, XMLINDEX_REWRITE = 2143, 
    XMLINDEX_SEL_IDX_TBL = 2144, XMLISNODE = 2145, XMLISVALID = 2146, XMLNAMESPACES = 2147, 
    XMLPARSE = 2148, XMLPATCH = 2149, XMLPI = 2150, XMLQUERYVAL = 2151, 
    XMLQUERY = 2152, XMLROOT = 2153, XMLSCHEMA = 2154, XMLSERIALIZE = 2155, 
    XMLTABLE = 2156, XMLTRANSFORMBLOB = 2157, XMLTRANSFORM = 2158, XMLTYPE = 2159, 
    XML = 2160, XPATHTABLE = 2161, XS_SYS_CONTEXT = 2162, XS = 2163, XTRANSPORT = 2164, 
    YEARS = 2165, YEAR = 2166, YES = 2167, YMINTERVAL_UNCONSTRAINED = 2168, 
    ZONEMAP = 2169, ZONE = 2170, PREDICTION = 2171, PREDICTION_BOUNDS = 2172, 
    PREDICTION_COST = 2173, PREDICTION_DETAILS = 2174, PREDICTION_PROBABILITY = 2175, 
    PREDICTION_SET = 2176, CUME_DIST = 2177, DENSE_RANK = 2178, LISTAGG = 2179, 
    PERCENT_RANK = 2180, PERCENTILE_CONT = 2181, PERCENTILE_DISC = 2182, 
    RANK = 2183, AVG = 2184, CORR = 2185, COVAR_ = 2186, DECODE = 2187, 
    LAG = 2188, LEAD = 2189, MAX = 2190, MEDIAN = 2191, MIN = 2192, NTILE = 2193, 
    NVL = 2194, RATIO_TO_REPORT = 2195, REGR_ = 2196, ROUND = 2197, ROW_NUMBER = 2198, 
    SUBSTR = 2199, TO_CHAR = 2200, TRIM = 2201, SUM = 2202, STDDEV = 2203, 
    VAR_ = 2204, VARIANCE = 2205, LEAST = 2206, GREATEST = 2207, TO_DATE = 2208, 
    DO = 2209, IP = 2210, CSV = 2211, BTREE = 2212, INPUT = 2213, OUTPUT = 2214, 
    CASCADED = 2215, STDIN_ = 2216, STDOUT_ = 2217, QUOTED = 2218, MAXLINENUM = 2219, 
    DELIMITER = 2220, OIDS = 2221, RECURSIVE = 2222, TOP = 2223, WINDOW = 2224, 
    FULLTEXT = 2225, CONFIGURATION = 2226, PARSER = 2227, FILEGROWTH = 2228, 
    FILENAME = 2229, CONNECTION = 2230, ENCRYPTED = 2231, CREATEDB = 2232, 
    NOCREATEDB = 2233, SUPERUSER = 2234, NOSUPERUSER = 2235, SSO = 2236, 
    SAO = 2237, CREATEROLE = 2238, NOCREATEROLE = 2239, VALID = 2240, DURATION = 2241, 
    IDLE = 2242, OWNED = 2243, REASSIGN = 2244, INTERNALLENGTH = 2245, EXTERNALLENGTH = 2246, 
    SEND = 2247, RECEIVE = 2248, PASSEDBYVALUE = 2249, CHECKALLOCATE = 2250, 
    VERBOSE = 2251, DBCC = 2252, CHECKCATALOG = 2253, CHECKTABLE = 2254, 
    NOINDEX = 2255, NOALLOCATE = 2256, CHECKINDEX = 2257, CHECKTABLESPACE = 2258, 
    NOCONSTRAINT = 2259, CHECKDB = 2260, TEMP = 2261, TINYINT = 2262, BIGINT = 2263, 
    BYTEA = 2264, BIT = 2265, AUTOCOMMIT = 2266, REPEATABLE = 2267, UNCOMMITTED = 2268, 
    RELEASE = 2269, RETURNS = 2270, IMMUTABLE = 2271, STABLE = 2272, VOLATILE = 2273, 
    INVOKER = 2274, INTERNAL = 2275, COSTS = 2276, SCROLL = 2277, INSENSITIVE = 2278, 
    HOLD = 2279, ABSOLUTE = 2280, RELATIVE = 2281, BACKWARD = 2282, NATIONAL_CHAR_STRING_LIT = 2283, 
    BIT_STRING_LIT = 2284, HEX_STRING_LIT = 2285, DOUBLE_PERIOD = 2286, 
    PERIOD = 2287, UNSIGNED_INTEGER = 2288, APPROXIMATE_NUM_LIT = 2289, 
    CHAR_STRING = 2290, UNI_STRING = 2291, CHAR_DOUBLE_QUOTED_STRING = 2292, 
    DELIMITED_ID = 2293, PERCENT = 2294, AMPERSAND = 2295, LEFT_PAREN = 2296, 
    RIGHT_PAREN = 2297, DOUBLE_ASTERISK = 2298, ASTERISK = 2299, PLUS_SIGN = 2300, 
    MINUS_SIGN = 2301, COMMA = 2302, SOLIDUS = 2303, AT_SIGN = 2304, ASSIGN_OP = 2305, 
    BINDVAR = 2306, NOT_EQUAL_OP = 2307, CARRET_OPERATOR_PART = 2308, TILDE_OPERATOR_PART = 2309, 
    EXCLAMATION_OPERATOR_PART = 2310, GREATER_THAN_OP = 2311, LESS_THAN_OP = 2312, 
    COLON = 2313, SEMICOLON = 2314, BAR = 2315, EQUALS_OP = 2316, LEFT_BRACKET = 2317, 
    RIGHT_BRACKET = 2318, INTRODUCER = 2319, SINGLE_LINE_COMMENT = 2320, 
    MULTI_LINE_COMMENT = 2321, REMARK_COMMENT = 2322, PROMPT_MESSAGE = 2323, 
    START_CMD = 2324, REGULAR_ID = 2325, SPACES = 2326
  };

  enum {
    RuleData_manipulation_language_statements = 0, RuleMerge_statement = 1, 
    RuleMerge_update_clause = 2, RuleMerge_element = 3, RuleMerge_update_delete_part = 4, 
    RuleMerge_insert_clause = 5, RuleSelected_tableview = 6, RuleTruncate_statement = 7, 
    RuleSelect_statement = 8, RuleWith_clause = 9, RuleWith_query = 10, 
    RuleSubquery = 11, RuleSubquery_basic_elements = 12, RuleSubquery_operation_part = 13, 
    RuleDml_table_expression_clause = 14, RuleTable_collection_expression = 15, 
    RuleSubquery_restriction_clause = 16, RuleSample_clause = 17, RuleSeed_part = 18, 
    RuleQuery_block = 19, RuleTop_clause = 20, RuleStart_value = 21, RuleLine_count = 22, 
    RuleSelected_list = 23, RuleSelected_list_element = 24, RuleFrom_clause = 25, 
    RuleTable_ref_list = 26, RuleTable_ref = 27, RuleTable_ref_aux = 28, 
    RuleTable_ref_aux_internal = 29, RuleWhere_clause = 30, RuleJoin_clause = 31, 
    RuleJoin_on_part = 32, RuleJoin_using_part = 33, RuleOuter_join_type = 34, 
    RuleQuery_partition_clause = 35, RulePivot_clause = 36, RulePivot_element = 37, 
    RuleAggregate_function_name = 38, RulePivot_for_clause = 39, RulePivot_in_clause = 40, 
    RulePivot_in_clause_element = 41, RulePivot_in_clause_elements = 42, 
    RuleUnpivot_clause = 43, RuleUnpivot_in_clause = 44, RuleUnpivot_in_elements = 45, 
    RuleHierarchical_query_clause = 46, RuleStart_part = 47, RuleGroup_by_clause = 48, 
    RuleGroup_by_elements = 49, RuleRollup_cube_expression = 50, RuleEmpty_expression = 51, 
    RuleGrouping_sets_expression = 52, RuleHaving_clause = 53, RuleCell_assignment = 54, 
    RuleUntil_part = 55, RuleOrder_by_clause = 56, RuleOrder_by_elements = 57, 
    RuleLimit_clause = 58, RuleOffset_clause = 59, RuleFetch_clause = 60, 
    RuleFor_update_clause = 61, RuleFor_update_of_part = 62, RuleFor_update_options = 63, 
    RuleKeep_clause = 64, RuleFunction_argument = 65, RuleFunction_argument_analytic = 66, 
    RuleFunction_argument_modeling = 67, RuleRespect_or_ignore_nulls = 68, 
    RuleArgument = 69, RuleDatatype = 70, RulePrecision_part = 71, RuleNative_datatype_element = 72, 
    RuleUpdate_statement = 73, RuleUpdate_set_clause = 74, RuleColumn_based_update_set_clause = 75, 
    RuleDelete_statement = 76, RuleGeneral_table_ref = 77, RuleStatic_returning_clause = 78, 
    RuleInsert_statement = 79, RuleSingle_table_insert = 80, RuleMulti_table_insert = 81, 
    RuleMulti_table_element = 82, RuleConditional_insert_clause = 83, RuleConditional_insert_when_part = 84, 
    RuleConditional_insert_else_part = 85, RuleInsert_into_clause = 86, 
    RuleValues_clause = 87, RuleCopy_statement = 88, RuleCondition = 89, 
    RuleExpressions = 90, RuleExpression = 91, RuleCursor_expression = 92, 
    RuleLogical_expression = 93, RuleMultiset_expression = 94, RuleRelational_expression = 95, 
    RuleCompound_expression = 96, RuleRelational_operator = 97, RuleIn_elements = 98, 
    RuleBetween_elements = 99, RuleConcatenation = 100, RuleInterval_expression = 101, 
    RuleModel_expression = 102, RuleModel_expression_element = 103, RuleSingle_column_for_loop = 104, 
    RuleMulti_column_for_loop = 105, RuleUnary_expression = 106, RuleCase_statement = 107, 
    RuleSimple_case_statement = 108, RuleSimple_case_when_part = 109, RuleSearched_case_statement = 110, 
    RuleSearched_case_when_part = 111, RuleCase_else_part = 112, RuleAtom = 113, 
    RuleQuantified_expression = 114, RuleString_function = 115, RuleStandard_function = 116, 
    RuleNumeric_function_wrapper = 117, RuleNumeric_function = 118, RuleOther_function = 119, 
    RuleOver_clause_keyword = 120, RuleWithin_or_over_clause_keyword = 121, 
    RuleStandard_prediction_function_keyword = 122, RuleOver_clause = 123, 
    RuleWindowing_clause = 124, RuleWindowing_type = 125, RuleWindowing_elements = 126, 
    RuleCollect_order_by_part = 127, RuleWithin_or_over_part = 128, RuleXml_passing_clause = 129, 
    RuleXml_attributes_clause = 130, RuleXml_namespaces_clause = 131, RuleXml_table_column = 132, 
    RuleXml_general_default_part = 133, RuleXml_multiuse_expression_element = 134, 
    RuleXmlroot_param_version_part = 135, RuleXmlroot_param_standalone_part = 136, 
    RuleXmlserialize_param_enconding_part = 137, RuleXmlserialize_param_version_part = 138, 
    RuleXmlserialize_param_ident_part = 139, RuleBind_variable = 140, RuleGeneral_element = 141, 
    RuleGeneral_element_part = 142, RuleTable_element = 143, RuleTableview_name = 144, 
    RuleColumn_name = 145, RuleTable_name = 146, RuleLink_name = 147, RuleChar_set_name = 148, 
    RuleColumn_alias = 149, RuleTable_alias = 150, RuleXml_column_name = 151, 
    RuleParen_column_list = 152, RuleColumn_list = 153, RuleWith_query_name = 154, 
    RuleConstraint_name = 155, RuleLabel_name = 156, RulePartition_extension_clause = 157, 
    RuleConstant = 158, RuleNumeric = 159, RuleNumeric_negative = 160, RuleQuoted_string = 161, 
    RuleIdentifier = 162, RuleId_expression = 163, RuleOuter_join_sign = 164, 
    RuleRegular_id = 165, RuleNon_reserved_keywords_in_12c = 166, RuleNon_reserved_keywords_pre12c = 167
  };

  KingbaseQueryParser(antlr4::TokenStream *input);
  ~KingbaseQueryParser();

  virtual std::string getGrammarFileName() const override;
  virtual const antlr4::atn::ATN& getATN() const override { return _atn; };
  virtual const std::vector<std::string>& getTokenNames() const override { return _tokenNames; }; // deprecated: use vocabulary instead.
  virtual const std::vector<std::string>& getRuleNames() const override;
  virtual antlr4::dfa::Vocabulary& getVocabulary() const override;


  class Data_manipulation_language_statementsContext;
  class Merge_statementContext;
  class Merge_update_clauseContext;
  class Merge_elementContext;
  class Merge_update_delete_partContext;
  class Merge_insert_clauseContext;
  class Selected_tableviewContext;
  class Truncate_statementContext;
  class Select_statementContext;
  class With_clauseContext;
  class With_queryContext;
  class SubqueryContext;
  class Subquery_basic_elementsContext;
  class Subquery_operation_partContext;
  class Dml_table_expression_clauseContext;
  class Table_collection_expressionContext;
  class Subquery_restriction_clauseContext;
  class Sample_clauseContext;
  class Seed_partContext;
  class Query_blockContext;
  class Top_clauseContext;
  class Start_valueContext;
  class Line_countContext;
  class Selected_listContext;
  class Selected_list_elementContext;
  class From_clauseContext;
  class Table_ref_listContext;
  class Table_refContext;
  class Table_ref_auxContext;
  class Table_ref_aux_internalContext;
  class Where_clauseContext;
  class Join_clauseContext;
  class Join_on_partContext;
  class Join_using_partContext;
  class Outer_join_typeContext;
  class Query_partition_clauseContext;
  class Pivot_clauseContext;
  class Pivot_elementContext;
  class Aggregate_function_nameContext;
  class Pivot_for_clauseContext;
  class Pivot_in_clauseContext;
  class Pivot_in_clause_elementContext;
  class Pivot_in_clause_elementsContext;
  class Unpivot_clauseContext;
  class Unpivot_in_clauseContext;
  class Unpivot_in_elementsContext;
  class Hierarchical_query_clauseContext;
  class Start_partContext;
  class Group_by_clauseContext;
  class Group_by_elementsContext;
  class Rollup_cube_expressionContext;
  class Empty_expressionContext;
  class Grouping_sets_expressionContext;
  class Having_clauseContext;
  class Cell_assignmentContext;
  class Until_partContext;
  class Order_by_clauseContext;
  class Order_by_elementsContext;
  class Limit_clauseContext;
  class Offset_clauseContext;
  class Fetch_clauseContext;
  class For_update_clauseContext;
  class For_update_of_partContext;
  class For_update_optionsContext;
  class Keep_clauseContext;
  class Function_argumentContext;
  class Function_argument_analyticContext;
  class Function_argument_modelingContext;
  class Respect_or_ignore_nullsContext;
  class ArgumentContext;
  class DatatypeContext;
  class Precision_partContext;
  class Native_datatype_elementContext;
  class Update_statementContext;
  class Update_set_clauseContext;
  class Column_based_update_set_clauseContext;
  class Delete_statementContext;
  class General_table_refContext;
  class Static_returning_clauseContext;
  class Insert_statementContext;
  class Single_table_insertContext;
  class Multi_table_insertContext;
  class Multi_table_elementContext;
  class Conditional_insert_clauseContext;
  class Conditional_insert_when_partContext;
  class Conditional_insert_else_partContext;
  class Insert_into_clauseContext;
  class Values_clauseContext;
  class Copy_statementContext;
  class ConditionContext;
  class ExpressionsContext;
  class ExpressionContext;
  class Cursor_expressionContext;
  class Logical_expressionContext;
  class Multiset_expressionContext;
  class Relational_expressionContext;
  class Compound_expressionContext;
  class Relational_operatorContext;
  class In_elementsContext;
  class Between_elementsContext;
  class ConcatenationContext;
  class Interval_expressionContext;
  class Model_expressionContext;
  class Model_expression_elementContext;
  class Single_column_for_loopContext;
  class Multi_column_for_loopContext;
  class Unary_expressionContext;
  class Case_statementContext;
  class Simple_case_statementContext;
  class Simple_case_when_partContext;
  class Searched_case_statementContext;
  class Searched_case_when_partContext;
  class Case_else_partContext;
  class AtomContext;
  class Quantified_expressionContext;
  class String_functionContext;
  class Standard_functionContext;
  class Numeric_function_wrapperContext;
  class Numeric_functionContext;
  class Other_functionContext;
  class Over_clause_keywordContext;
  class Within_or_over_clause_keywordContext;
  class Standard_prediction_function_keywordContext;
  class Over_clauseContext;
  class Windowing_clauseContext;
  class Windowing_typeContext;
  class Windowing_elementsContext;
  class Collect_order_by_partContext;
  class Within_or_over_partContext;
  class Xml_passing_clauseContext;
  class Xml_attributes_clauseContext;
  class Xml_namespaces_clauseContext;
  class Xml_table_columnContext;
  class Xml_general_default_partContext;
  class Xml_multiuse_expression_elementContext;
  class Xmlroot_param_version_partContext;
  class Xmlroot_param_standalone_partContext;
  class Xmlserialize_param_enconding_partContext;
  class Xmlserialize_param_version_partContext;
  class Xmlserialize_param_ident_partContext;
  class Bind_variableContext;
  class General_elementContext;
  class General_element_partContext;
  class Table_elementContext;
  class Tableview_nameContext;
  class Column_nameContext;
  class Table_nameContext;
  class Link_nameContext;
  class Char_set_nameContext;
  class Column_aliasContext;
  class Table_aliasContext;
  class Xml_column_nameContext;
  class Paren_column_listContext;
  class Column_listContext;
  class With_query_nameContext;
  class Constraint_nameContext;
  class Label_nameContext;
  class Partition_extension_clauseContext;
  class ConstantContext;
  class NumericContext;
  class Numeric_negativeContext;
  class Quoted_stringContext;
  class IdentifierContext;
  class Id_expressionContext;
  class Outer_join_signContext;
  class Regular_idContext;
  class Non_reserved_keywords_in_12cContext;
  class Non_reserved_keywords_pre12cContext; 

  class  Data_manipulation_language_statementsContext : public antlr4::ParserRuleContext {
  public:
    Data_manipulation_language_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Merge_statementContext *merge_statement();
    Truncate_statementContext *truncate_statement();
    Select_statementContext *select_statement();
    Update_statementContext *update_statement();
    Delete_statementContext *delete_statement();
    Insert_statementContext *insert_statement();
    Copy_statementContext *copy_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Data_manipulation_language_statementsContext* data_manipulation_language_statements();

  class  Merge_statementContext : public antlr4::ParserRuleContext {
  public:
    Merge_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *USING();
    Selected_tableviewContext *selected_tableview();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();
    Merge_update_clauseContext *merge_update_clause();
    Merge_insert_clauseContext *merge_insert_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_statementContext* merge_statement();

  class  Merge_update_clauseContext : public antlr4::ParserRuleContext {
  public:
    Merge_update_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *SET();
    std::vector<Merge_elementContext *> merge_element();
    Merge_elementContext* merge_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Where_clauseContext *where_clause();
    Merge_update_delete_partContext *merge_update_delete_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_update_clauseContext* merge_update_clause();

  class  Merge_elementContext : public antlr4::ParserRuleContext {
  public:
    Merge_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_elementContext* merge_element();

  class  Merge_update_delete_partContext : public antlr4::ParserRuleContext {
  public:
    Merge_update_delete_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    Where_clauseContext *where_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_update_delete_partContext* merge_update_delete_part();

  class  Merge_insert_clauseContext : public antlr4::ParserRuleContext {
  public:
    Merge_insert_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Paren_column_listContext *paren_column_list();
    ExpressionsContext *expressions();
    Where_clauseContext *where_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_insert_clauseContext* merge_insert_clause();

  class  Selected_tableviewContext : public antlr4::ParserRuleContext {
  public:
    Selected_tableviewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_tableviewContext* selected_tableview();

  class  Truncate_statementContext : public antlr4::ParserRuleContext {
  public:
    Truncate_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *TABLE();
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *RESTRICT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Truncate_statementContext* truncate_statement();

  class  Select_statementContext : public antlr4::ParserRuleContext {
  public:
    Select_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SubqueryContext *subquery();
    With_clauseContext *with_clause();
    std::vector<Offset_clauseContext *> offset_clause();
    Offset_clauseContext* offset_clause(size_t i);
    std::vector<Fetch_clauseContext *> fetch_clause();
    Fetch_clauseContext* fetch_clause(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Select_statementContext* select_statement();

  class  With_clauseContext : public antlr4::ParserRuleContext {
  public:
    With_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    std::vector<With_queryContext *> with_query();
    With_queryContext* with_query(size_t i);
    antlr4::tree::TerminalNode *RECURSIVE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  With_clauseContext* with_clause();

  class  With_queryContext : public antlr4::ParserRuleContext {
  public:
    With_queryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    With_query_nameContext *with_query_name();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  With_queryContext* with_query();

  class  SubqueryContext : public antlr4::ParserRuleContext {
  public:
    SubqueryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subquery_basic_elementsContext *subquery_basic_elements();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  SubqueryContext* subquery();

  class  Subquery_basic_elementsContext : public antlr4::ParserRuleContext {
  public:
    Subquery_basic_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Query_blockContext *query_block();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_basic_elementsContext* subquery_basic_elements();

  class  Subquery_operation_partContext : public antlr4::ParserRuleContext {
  public:
    Subquery_operation_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subquery_basic_elementsContext *subquery_basic_elements();
    antlr4::tree::TerminalNode *UNION();
    antlr4::tree::TerminalNode *INTERSECT();
    antlr4::tree::TerminalNode *MINUS();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_operation_partContext* subquery_operation_part();

  class  Dml_table_expression_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dml_table_expression_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_collection_expressionContext *table_collection_expression();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Subquery_restriction_clauseContext *subquery_restriction_clause();
    Tableview_nameContext *tableview_name();
    Sample_clauseContext *sample_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_table_expression_clauseContext* dml_table_expression_clause();

  class  Table_collection_expressionContext : public antlr4::ParserRuleContext {
  public:
    Table_collection_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *THE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    SubqueryContext *subquery();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *PLUS_SIGN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_collection_expressionContext* table_collection_expression();

  class  Subquery_restriction_clauseContext : public antlr4::ParserRuleContext {
  public:
    Subquery_restriction_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *CHECK();
    antlr4::tree::TerminalNode *OPTION();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_restriction_clauseContext* subquery_restriction_clause();

  class  Sample_clauseContext : public antlr4::ParserRuleContext {
  public:
    Sample_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SAMPLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *COMMA();
    Seed_partContext *seed_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sample_clauseContext* sample_clause();

  class  Seed_partContext : public antlr4::ParserRuleContext {
  public:
    Seed_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEED();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Seed_partContext* seed_part();

  class  Query_blockContext : public antlr4::ParserRuleContext {
  public:
    Query_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SELECT();
    Selected_listContext *selected_list();
    From_clauseContext *from_clause();
    Top_clauseContext *top_clause();
    Where_clauseContext *where_clause();
    Hierarchical_query_clauseContext *hierarchical_query_clause();
    Group_by_clauseContext *group_by_clause();
    Order_by_clauseContext *order_by_clause();
    Limit_clauseContext *limit_clause();
    Offset_clauseContext *offset_clause();
    For_update_clauseContext *for_update_clause();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_blockContext* query_block();

  class  Top_clauseContext : public antlr4::ParserRuleContext {
  public:
    Top_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TOP();
    Line_countContext *line_count();
    Start_valueContext *start_value();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Top_clauseContext* top_clause();

  class  Start_valueContext : public antlr4::ParserRuleContext {
  public:
    Start_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_valueContext* start_value();

  class  Line_countContext : public antlr4::ParserRuleContext {
  public:
    Line_countContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Line_countContext* line_count();

  class  Selected_listContext : public antlr4::ParserRuleContext {
  public:
    Selected_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Selected_list_elementContext *> selected_list_element();
    Selected_list_elementContext* selected_list_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_listContext* selected_list();

  class  Selected_list_elementContext : public antlr4::ParserRuleContext {
  public:
    Selected_list_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASTERISK();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PERIOD();
    Column_nameContext *column_name();
    ExpressionContext *expression();
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_list_elementContext* selected_list_element();

  class  From_clauseContext : public antlr4::ParserRuleContext {
  public:
    From_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FROM();
    Table_ref_listContext *table_ref_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  From_clauseContext* from_clause();

  class  Table_ref_listContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Table_refContext *> table_ref();
    Table_refContext* table_ref(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_ref_listContext* table_ref_list();

  class  Table_refContext : public antlr4::ParserRuleContext {
  public:
    Table_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_ref_auxContext *table_ref_aux();
    std::vector<Join_clauseContext *> join_clause();
    Join_clauseContext* join_clause(size_t i);
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_refContext* table_ref();

  class  Table_ref_auxContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_auxContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_ref_aux_internalContext *table_ref_aux_internal();
    Table_aliasContext *table_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_ref_auxContext* table_ref_aux();

  class  Table_ref_aux_internalContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_aux_internalContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    Table_ref_aux_internalContext() : antlr4::ParserRuleContext() { }
    void copyFrom(Table_ref_aux_internalContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  Table_ref_aux_internal_threeContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_threeContext(Table_ref_aux_internalContext *ctx);

    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Dml_table_expression_clauseContext *dml_table_expression_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  class  Table_ref_aux_internal_oneContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_oneContext(Table_ref_aux_internalContext *ctx);

    Dml_table_expression_clauseContext *dml_table_expression_clause();
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();
    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  class  Table_ref_aux_internal_twoContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_twoContext(Table_ref_aux_internalContext *ctx);

    antlr4::tree::TerminalNode *LEFT_PAREN();
    Table_refContext *table_ref();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();
    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  Table_ref_aux_internalContext* table_ref_aux_internal();

  class  Where_clauseContext : public antlr4::ParserRuleContext {
  public:
    Where_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHERE();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Where_clauseContext* where_clause();

  class  Join_clauseContext : public antlr4::ParserRuleContext {
  public:
    Join_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JOIN();
    Table_ref_auxContext *table_ref_aux();
    std::vector<Query_partition_clauseContext *> query_partition_clause();
    Query_partition_clauseContext* query_partition_clause(size_t i);
    antlr4::tree::TerminalNode *NATURAL();
    antlr4::tree::TerminalNode *CROSS();
    antlr4::tree::TerminalNode *INNER();
    Outer_join_typeContext *outer_join_type();
    std::vector<Join_on_partContext *> join_on_part();
    Join_on_partContext* join_on_part(size_t i);
    std::vector<Join_using_partContext *> join_using_part();
    Join_using_partContext* join_using_part(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_clauseContext* join_clause();

  class  Join_on_partContext : public antlr4::ParserRuleContext {
  public:
    Join_on_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    ConditionContext *condition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_on_partContext* join_on_part();

  class  Join_using_partContext : public antlr4::ParserRuleContext {
  public:
    Join_using_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_using_partContext* join_using_part();

  class  Outer_join_typeContext : public antlr4::ParserRuleContext {
  public:
    Outer_join_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FULL();
    antlr4::tree::TerminalNode *LEFT();
    antlr4::tree::TerminalNode *RIGHT();
    antlr4::tree::TerminalNode *OUTER();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Outer_join_typeContext* outer_join_type();

  class  Query_partition_clauseContext : public antlr4::ParserRuleContext {
  public:
    Query_partition_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SubqueryContext *subquery();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_partition_clauseContext* query_partition_clause();

  class  Pivot_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PIVOT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Pivot_for_clauseContext *pivot_for_clause();
    Pivot_in_clauseContext *pivot_in_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *XML();
    std::vector<Pivot_elementContext *> pivot_element();
    Pivot_elementContext* pivot_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_clauseContext* pivot_clause();

  class  Pivot_elementContext : public antlr4::ParserRuleContext {
  public:
    Pivot_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Aggregate_function_nameContext *aggregate_function_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_elementContext* pivot_element();

  class  Aggregate_function_nameContext : public antlr4::ParserRuleContext {
  public:
    Aggregate_function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Aggregate_function_nameContext* aggregate_function_name();

  class  Pivot_for_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_for_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_for_clauseContext* pivot_for_clause();

  class  Pivot_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SubqueryContext *subquery();
    std::vector<antlr4::tree::TerminalNode *> ANY();
    antlr4::tree::TerminalNode* ANY(size_t i);
    std::vector<Pivot_in_clause_elementContext *> pivot_in_clause_element();
    Pivot_in_clause_elementContext* pivot_in_clause_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clauseContext* pivot_in_clause();

  class  Pivot_in_clause_elementContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clause_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pivot_in_clause_elementsContext *pivot_in_clause_elements();
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *AS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clause_elementContext* pivot_in_clause_element();

  class  Pivot_in_clause_elementsContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clause_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clause_elementsContext* pivot_in_clause_elements();

  class  Unpivot_clauseContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNPIVOT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Pivot_for_clauseContext *pivot_for_clause();
    Unpivot_in_clauseContext *unpivot_in_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *INCLUDE();
    antlr4::tree::TerminalNode *EXCLUDE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_clauseContext* unpivot_clause();

  class  Unpivot_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Unpivot_in_elementsContext *> unpivot_in_elements();
    Unpivot_in_elementsContext* unpivot_in_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_in_clauseContext* unpivot_in_clause();

  class  Unpivot_in_elementsContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_in_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *AS();
    std::vector<ConstantContext *> constant();
    ConstantContext* constant(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_in_elementsContext* unpivot_in_elements();

  class  Hierarchical_query_clauseContext : public antlr4::ParserRuleContext {
  public:
    Hierarchical_query_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *BY();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *NOCYCLE();
    Start_partContext *start_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hierarchical_query_clauseContext* hierarchical_query_clause();

  class  Start_partContext : public antlr4::ParserRuleContext {
  public:
    Start_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *WITH();
    ConditionContext *condition();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_partContext* start_part();

  class  Group_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Group_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *BY();
    std::vector<Group_by_elementsContext *> group_by_elements();
    Group_by_elementsContext* group_by_elements(size_t i);
    Having_clauseContext *having_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Group_by_clauseContext* group_by_clause();

  class  Group_by_elementsContext : public antlr4::ParserRuleContext {
  public:
    Group_by_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Grouping_sets_expressionContext *grouping_sets_expression();
    Rollup_cube_expressionContext *rollup_cube_expression();
    Empty_expressionContext *empty_expression();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Group_by_elementsContext* group_by_elements();

  class  Rollup_cube_expressionContext : public antlr4::ParserRuleContext {
  public:
    Rollup_cube_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ROLLUP();
    antlr4::tree::TerminalNode *CUBE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollup_cube_expressionContext* rollup_cube_expression();

  class  Empty_expressionContext : public antlr4::ParserRuleContext {
  public:
    Empty_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Empty_expressionContext* empty_expression();

  class  Grouping_sets_expressionContext : public antlr4::ParserRuleContext {
  public:
    Grouping_sets_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUPING();
    antlr4::tree::TerminalNode *SETS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Group_by_elementsContext *> group_by_elements();
    Group_by_elementsContext* group_by_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grouping_sets_expressionContext* grouping_sets_expression();

  class  Having_clauseContext : public antlr4::ParserRuleContext {
  public:
    Having_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HAVING();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Having_clauseContext* having_clause();

  class  Cell_assignmentContext : public antlr4::ParserRuleContext {
  public:
    Cell_assignmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_expressionContext *model_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cell_assignmentContext* cell_assignment();

  class  Until_partContext : public antlr4::ParserRuleContext {
  public:
    Until_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Until_partContext* until_part();

  class  Order_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Order_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *SIBLINGS();
    std::vector<Order_by_elementsContext *> order_by_elements();
    Order_by_elementsContext* order_by_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Order_by_clauseContext* order_by_clause();

  class  Order_by_elementsContext : public antlr4::ParserRuleContext {
  public:
    Order_by_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *ASC();
    antlr4::tree::TerminalNode *DESC();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Order_by_elementsContext* order_by_elements();

  class  Limit_clauseContext : public antlr4::ParserRuleContext {
  public:
    Limit_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *ALL();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Limit_clauseContext* limit_clause();

  class  Offset_clauseContext : public antlr4::ParserRuleContext {
  public:
    Offset_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OFFSET();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROWS();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Offset_clauseContext* offset_clause();

  class  Fetch_clauseContext : public antlr4::ParserRuleContext {
  public:
    Fetch_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FETCH();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *NEXT();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIES();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *PERCENT_KEYWORD();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Fetch_clauseContext* fetch_clause();

  class  For_update_clauseContext : public antlr4::ParserRuleContext {
  public:
    For_update_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *SHARE();
    For_update_of_partContext *for_update_of_part();
    For_update_optionsContext *for_update_options();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_clauseContext* for_update_clause();

  class  For_update_of_partContext : public antlr4::ParserRuleContext {
  public:
    For_update_of_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    Column_listContext *column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_of_partContext* for_update_of_part();

  class  For_update_optionsContext : public antlr4::ParserRuleContext {
  public:
    For_update_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *LOCKED();
    antlr4::tree::TerminalNode *NOWAIT();
    antlr4::tree::TerminalNode *WAIT();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_optionsContext* for_update_options();

  class  Keep_clauseContext : public antlr4::ParserRuleContext {
  public:
    Keep_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *DENSE_RANK();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();
    Over_clauseContext *over_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Keep_clauseContext* keep_clause();

  class  Function_argumentContext : public antlr4::ParserRuleContext {
  public:
    Function_argumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ArgumentContext *> argument();
    ArgumentContext* argument(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argumentContext* function_argument();

  class  Function_argument_analyticContext : public antlr4::ParserRuleContext {
  public:
    Function_argument_analyticContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ArgumentContext *> argument();
    ArgumentContext* argument(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Respect_or_ignore_nullsContext *> respect_or_ignore_nulls();
    Respect_or_ignore_nullsContext* respect_or_ignore_nulls(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argument_analyticContext* function_argument_analytic();

  class  Function_argument_modelingContext : public antlr4::ParserRuleContext {
  public:
    Function_argument_modelingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argument_modelingContext* function_argument_modeling();

  class  Respect_or_ignore_nullsContext : public antlr4::ParserRuleContext {
  public:
    Respect_or_ignore_nullsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *RESPECT();
    antlr4::tree::TerminalNode *IGNORE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Respect_or_ignore_nullsContext* respect_or_ignore_nulls();

  class  ArgumentContext : public antlr4::ParserRuleContext {
  public:
    ArgumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *GREATER_THAN_OP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ArgumentContext* argument();

  class  DatatypeContext : public antlr4::ParserRuleContext {
  public:
    DatatypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Native_datatype_elementContext *native_datatype_element();
    Precision_partContext *precision_part();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *HOUR();
    antlr4::tree::TerminalNode *MINUTE();
    antlr4::tree::TerminalNode *SECOND();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  DatatypeContext* datatype();

  class  Precision_partContext : public antlr4::ParserRuleContext {
  public:
    Precision_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *BYTE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Precision_partContext* precision_part();

  class  Native_datatype_elementContext : public antlr4::ParserRuleContext {
  public:
    Native_datatype_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TINYINT();
    antlr4::tree::TerminalNode *SMALLINT();
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *BIGINT();
    antlr4::tree::TerminalNode *REAL();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *NUMERIC();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *VARCHAR();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BYTEA();
    antlr4::tree::TerminalNode *TEXT();
    antlr4::tree::TerminalNode *VARYING();
    antlr4::tree::TerminalNode *BIT();
    antlr4::tree::TerminalNode *BOOLEAN();
    antlr4::tree::TerminalNode *DATE();
    std::vector<antlr4::tree::TerminalNode *> TIME();
    antlr4::tree::TerminalNode* TIME(size_t i);
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *ZONE();
    antlr4::tree::TerminalNode *TIMESTAMP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Native_datatype_elementContext* native_datatype_element();

  class  Update_statementContext : public antlr4::ParserRuleContext {
  public:
    Update_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPDATE();
    General_table_refContext *general_table_ref();
    Update_set_clauseContext *update_set_clause();
    With_clauseContext *with_clause();
    Where_clauseContext *where_clause();
    Static_returning_clauseContext *static_returning_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_statementContext* update_statement();

  class  Update_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    Update_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    std::vector<Column_based_update_set_clauseContext *> column_based_update_set_clause();
    Column_based_update_set_clauseContext* column_based_update_set_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_set_clauseContext* update_set_clause();

  class  Column_based_update_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    Column_based_update_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    Paren_column_listContext *paren_column_list();
    SubqueryContext *subquery();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_based_update_set_clauseContext* column_based_update_set_clause();

  class  Delete_statementContext : public antlr4::ParserRuleContext {
  public:
    Delete_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    General_table_refContext *general_table_ref();
    With_clauseContext *with_clause();
    antlr4::tree::TerminalNode *FROM();
    Where_clauseContext *where_clause();
    Static_returning_clauseContext *static_returning_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Delete_statementContext* delete_statement();

  class  General_table_refContext : public antlr4::ParserRuleContext {
  public:
    General_table_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Dml_table_expression_clauseContext *dml_table_expression_clause();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_table_refContext* general_table_ref();

  class  Static_returning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Static_returning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURNING();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Static_returning_clauseContext* static_returning_clause();

  class  Insert_statementContext : public antlr4::ParserRuleContext {
  public:
    Insert_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INSERT();
    Single_table_insertContext *single_table_insert();
    Multi_table_insertContext *multi_table_insert();
    With_clauseContext *with_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Insert_statementContext* insert_statement();

  class  Single_table_insertContext : public antlr4::ParserRuleContext {
  public:
    Single_table_insertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Insert_into_clauseContext *insert_into_clause();
    Values_clauseContext *values_clause();
    Select_statementContext *select_statement();
    Static_returning_clauseContext *static_returning_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Single_table_insertContext* single_table_insert();

  class  Multi_table_insertContext : public antlr4::ParserRuleContext {
  public:
    Multi_table_insertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *ALL();
    Conditional_insert_clauseContext *conditional_insert_clause();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_table_insertContext* multi_table_insert();

  class  Multi_table_elementContext : public antlr4::ParserRuleContext {
  public:
    Multi_table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Insert_into_clauseContext *insert_into_clause();
    Values_clauseContext *values_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_table_elementContext* multi_table_element();

  class  Conditional_insert_clauseContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Conditional_insert_when_partContext *> conditional_insert_when_part();
    Conditional_insert_when_partContext* conditional_insert_when_part(size_t i);
    Conditional_insert_else_partContext *conditional_insert_else_part();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *FIRST();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_clauseContext* conditional_insert_clause();

  class  Conditional_insert_when_partContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_when_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *THEN();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_when_partContext* conditional_insert_when_part();

  class  Conditional_insert_else_partContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_else_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_else_partContext* conditional_insert_else_part();

  class  Insert_into_clauseContext : public antlr4::ParserRuleContext {
  public:
    Insert_into_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    General_table_refContext *general_table_ref();
    Paren_column_listContext *paren_column_list();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Insert_into_clauseContext* insert_into_clause();

  class  Values_clauseContext : public antlr4::ParserRuleContext {
  public:
    Values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Values_clauseContext* values_clause();

  class  Copy_statementContext : public antlr4::ParserRuleContext {
  public:
    Copy_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COPY();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *FROM();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *STDIN_();
    antlr4::tree::TerminalNode *STDOUT_();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *ERRORS();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *MAXLINENUM();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *CSV();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *BINARY();
    antlr4::tree::TerminalNode *OIDS();
    antlr4::tree::TerminalNode *DELIMITER();
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    antlr4::tree::TerminalNode *HEADER();
    antlr4::tree::TerminalNode *FORCE();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> QUOTED();
    antlr4::tree::TerminalNode* QUOTED(size_t i);
    antlr4::tree::TerminalNode *ESCAPE();
    antlr4::tree::TerminalNode *NOT();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Copy_statementContext* copy_statement();

  class  ConditionContext : public antlr4::ParserRuleContext {
  public:
    ConditionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConditionContext* condition();

  class  ExpressionsContext : public antlr4::ParserRuleContext {
  public:
    ExpressionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ExpressionsContext* expressions();

  class  ExpressionContext : public antlr4::ParserRuleContext {
  public:
    ExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Cursor_expressionContext *cursor_expression();
    Logical_expressionContext *logical_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ExpressionContext* expression();

  class  Cursor_expressionContext : public antlr4::ParserRuleContext {
  public:
    Cursor_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_expressionContext* cursor_expression();

  class  Logical_expressionContext : public antlr4::ParserRuleContext {
  public:
    Logical_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Multiset_expressionContext *multiset_expression();
    std::vector<antlr4::tree::TerminalNode *> IS();
    antlr4::tree::TerminalNode* IS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NAN();
    antlr4::tree::TerminalNode* NAN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRESENT();
    antlr4::tree::TerminalNode* PRESENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INFINITE();
    antlr4::tree::TerminalNode* INFINITE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> A_LETTER();
    antlr4::tree::TerminalNode* A_LETTER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SET();
    antlr4::tree::TerminalNode* SET(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EMPTY();
    antlr4::tree::TerminalNode* EMPTY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OF();
    antlr4::tree::TerminalNode* OF(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<DatatypeContext *> datatype();
    DatatypeContext* datatype(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOT();
    antlr4::tree::TerminalNode* NOT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TYPE();
    antlr4::tree::TerminalNode* TYPE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLY();
    antlr4::tree::TerminalNode* ONLY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Logical_expressionContext *> logical_expression();
    Logical_expressionContext* logical_expression(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *OR();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logical_expressionContext* logical_expression();
  Logical_expressionContext* logical_expression(int precedence);
  class  Multiset_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *multiset_type = nullptr;;
    Multiset_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Relational_expressionContext *relational_expression();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *SUBMULTISET();
    antlr4::tree::TerminalNode *OF();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multiset_expressionContext* multiset_expression();

  class  Relational_expressionContext : public antlr4::ParserRuleContext {
  public:
    Relational_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Compound_expressionContext *compound_expression();
    std::vector<Relational_expressionContext *> relational_expression();
    Relational_expressionContext* relational_expression(size_t i);
    Relational_operatorContext *relational_operator();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_expressionContext* relational_expression();
  Relational_expressionContext* relational_expression(int precedence);
  class  Compound_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *like_type = nullptr;;
    Compound_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *IN();
    In_elementsContext *in_elements();
    antlr4::tree::TerminalNode *BETWEEN();
    Between_elementsContext *between_elements();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *LIKE();
    antlr4::tree::TerminalNode *LIKEC();
    antlr4::tree::TerminalNode *LIKE2();
    antlr4::tree::TerminalNode *LIKE4();
    antlr4::tree::TerminalNode *ESCAPE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compound_expressionContext* compound_expression();

  class  Relational_operatorContext : public antlr4::ParserRuleContext {
  public:
    Relational_operatorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *NOT_EQUAL_OP();
    antlr4::tree::TerminalNode *LESS_THAN_OP();
    antlr4::tree::TerminalNode *GREATER_THAN_OP();
    antlr4::tree::TerminalNode *EXCLAMATION_OPERATOR_PART();
    antlr4::tree::TerminalNode *CARRET_OPERATOR_PART();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_operatorContext* relational_operator();

  class  In_elementsContext : public antlr4::ParserRuleContext {
  public:
    In_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    ConstantContext *constant();
    Bind_variableContext *bind_variable();
    General_elementContext *general_element();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  In_elementsContext* in_elements();

  class  Between_elementsContext : public antlr4::ParserRuleContext {
  public:
    Between_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *AND();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Between_elementsContext* between_elements();

  class  ConcatenationContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *op = nullptr;;
    ConcatenationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_expressionContext *model_expression();
    antlr4::tree::TerminalNode *AT();
    Interval_expressionContext *interval_expression();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *SOLIDUS();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *MINUS_SIGN();
    std::vector<antlr4::tree::TerminalNode *> BAR();
    antlr4::tree::TerminalNode* BAR(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConcatenationContext* concatenation();
  ConcatenationContext* concatenation(int precedence);
  class  Interval_expressionContext : public antlr4::ParserRuleContext {
  public:
    Interval_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *SECOND();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Interval_expressionContext* interval_expression();

  class  Model_expressionContext : public antlr4::ParserRuleContext {
  public:
    Model_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Unary_expressionContext *unary_expression();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    Model_expression_elementContext *model_expression_element();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_expressionContext* model_expression();

  class  Model_expression_elementContext : public antlr4::ParserRuleContext {
  public:
    Model_expression_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> ANY();
    antlr4::tree::TerminalNode* ANY(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Single_column_for_loopContext *> single_column_for_loop();
    Single_column_for_loopContext* single_column_for_loop(size_t i);
    Multi_column_for_loopContext *multi_column_for_loop();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_expression_elementContext* model_expression_element();

  class  Single_column_for_loopContext : public antlr4::ParserRuleContext {
  public:
    KingbaseQueryParser::ExpressionContext *fromExpr = nullptr;;
    KingbaseQueryParser::ExpressionContext *toExpr = nullptr;;
    antlr4::Token *action_type = nullptr;;
    KingbaseQueryParser::ExpressionContext *action_expr = nullptr;;
    Single_column_for_loopContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *TO();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *DECREMENT();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *LIKE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Single_column_for_loopContext* single_column_for_loop();

  class  Multi_column_for_loopContext : public antlr4::ParserRuleContext {
  public:
    Multi_column_for_loopContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *IN();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    SubqueryContext *subquery();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_column_for_loopContext* multi_column_for_loop();

  class  Unary_expressionContext : public antlr4::ParserRuleContext {
  public:
    Unary_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Unary_expressionContext *unary_expression();
    antlr4::tree::TerminalNode *MINUS_SIGN();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *PRIOR();
    antlr4::tree::TerminalNode *CONNECT_BY_ROOT();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();
    Case_statementContext *case_statement();
    Quantified_expressionContext *quantified_expression();
    Standard_functionContext *standard_function();
    AtomContext *atom();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unary_expressionContext* unary_expression();

  class  Case_statementContext : public antlr4::ParserRuleContext {
  public:
    Case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Searched_case_statementContext *searched_case_statement();
    Simple_case_statementContext *simple_case_statement();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_statementContext* case_statement();

  class  Simple_case_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;;
    Simple_case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    std::vector<Label_nameContext *> label_name();
    Label_nameContext* label_name(size_t i);
    std::vector<Simple_case_when_partContext *> simple_case_when_part();
    Simple_case_when_partContext* simple_case_when_part(size_t i);
    Case_else_partContext *case_else_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_case_statementContext* simple_case_statement();

  class  Simple_case_when_partContext : public antlr4::ParserRuleContext {
  public:
    Simple_case_when_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *THEN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_case_when_partContext* simple_case_when_part();

  class  Searched_case_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;;
    Searched_case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    std::vector<Label_nameContext *> label_name();
    Label_nameContext* label_name(size_t i);
    std::vector<Searched_case_when_partContext *> searched_case_when_part();
    Searched_case_when_partContext* searched_case_when_part(size_t i);
    Case_else_partContext *case_else_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Searched_case_statementContext* searched_case_statement();

  class  Searched_case_when_partContext : public antlr4::ParserRuleContext {
  public:
    Searched_case_when_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *THEN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Searched_case_when_partContext* searched_case_when_part();

  class  Case_else_partContext : public antlr4::ParserRuleContext {
  public:
    Case_else_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_else_partContext* case_else_part();

  class  AtomContext : public antlr4::ParserRuleContext {
  public:
    AtomContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_elementContext *table_element();
    Outer_join_signContext *outer_join_sign();
    Bind_variableContext *bind_variable();
    ConstantContext *constant();
    General_elementContext *general_element();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  AtomContext* atom();

  class  Quantified_expressionContext : public antlr4::ParserRuleContext {
  public:
    Quantified_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SOME();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quantified_expressionContext* quantified_expression();

  class  String_functionContext : public antlr4::ParserRuleContext {
  public:
    String_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBSTR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *TO_CHAR();
    Table_elementContext *table_element();
    Standard_functionContext *standard_function();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *DECODE();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *CHR();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *NVL();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *TO_DATE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  String_functionContext* string_function();

  class  Standard_functionContext : public antlr4::ParserRuleContext {
  public:
    Standard_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    String_functionContext *string_function();
    Numeric_function_wrapperContext *numeric_function_wrapper();
    Other_functionContext *other_function();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standard_functionContext* standard_function();

  class  Numeric_function_wrapperContext : public antlr4::ParserRuleContext {
  public:
    Numeric_function_wrapperContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Numeric_functionContext *numeric_function();
    Single_column_for_loopContext *single_column_for_loop();
    Multi_column_for_loopContext *multi_column_for_loop();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_function_wrapperContext* numeric_function_wrapper();

  class  Numeric_functionContext : public antlr4::ParserRuleContext {
  public:
    Numeric_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *ASTERISK();
    Over_clauseContext *over_clause();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ROUND();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *LEAST();
    ExpressionsContext *expressions();
    antlr4::tree::TerminalNode *GREATEST();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_functionContext* numeric_function();

  class  Other_functionContext : public antlr4::ParserRuleContext {
  public:
    Other_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Over_clause_keywordContext *over_clause_keyword();
    Function_argument_analyticContext *function_argument_analytic();
    Over_clauseContext *over_clause();
    antlr4::tree::TerminalNode *COUNT();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    DatatypeContext *datatype();
    antlr4::tree::TerminalNode *CAST();
    antlr4::tree::TerminalNode *XMLCAST();
    antlr4::tree::TerminalNode *MULTISET();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *COALESCE();
    Table_elementContext *table_element();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    NumericContext *numeric();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *COLLECT();
    Collect_order_by_partContext *collect_order_by_part();
    Within_or_over_clause_keywordContext *within_or_over_clause_keyword();
    Function_argumentContext *function_argument();
    std::vector<Within_or_over_partContext *> within_or_over_part();
    Within_or_over_partContext* within_or_over_part(size_t i);
    antlr4::tree::TerminalNode *DECOMPOSE();
    antlr4::tree::TerminalNode *CANONICAL();
    antlr4::tree::TerminalNode *COMPATIBILITY();
    antlr4::tree::TerminalNode *EXTRACT();
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *FIRST_VALUE();
    antlr4::tree::TerminalNode *LAST_VALUE();
    Respect_or_ignore_nullsContext *respect_or_ignore_nulls();
    antlr4::tree::TerminalNode *TRANSLATE();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CHAR_CS();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *TREAT();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *XMLAGG();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *PERIOD();
    General_element_partContext *general_element_part();
    antlr4::tree::TerminalNode *XMLCOLATTVAL();
    antlr4::tree::TerminalNode *XMLFOREST();
    std::vector<Xml_multiuse_expression_elementContext *> xml_multiuse_expression_element();
    Xml_multiuse_expression_elementContext* xml_multiuse_expression_element(size_t i);
    antlr4::tree::TerminalNode *XMLELEMENT();
    Xml_attributes_clauseContext *xml_attributes_clause();
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *EVALNAME();
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    antlr4::tree::TerminalNode *XMLEXISTS();
    Xml_passing_clauseContext *xml_passing_clause();
    antlr4::tree::TerminalNode *XMLPARSE();
    antlr4::tree::TerminalNode *DOCUMENT();
    antlr4::tree::TerminalNode *CONTENT();
    antlr4::tree::TerminalNode *WELLFORMED();
    antlr4::tree::TerminalNode *XMLPI();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *XMLQUERY();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *EMPTY();
    antlr4::tree::TerminalNode *XMLROOT();
    Xmlroot_param_version_partContext *xmlroot_param_version_part();
    Xmlroot_param_standalone_partContext *xmlroot_param_standalone_part();
    antlr4::tree::TerminalNode *XMLSERIALIZE();
    Xmlserialize_param_enconding_partContext *xmlserialize_param_enconding_part();
    Xmlserialize_param_version_partContext *xmlserialize_param_version_part();
    Xmlserialize_param_ident_partContext *xmlserialize_param_ident_part();
    antlr4::tree::TerminalNode *DEFAULTS();
    antlr4::tree::TerminalNode *HIDE();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *XMLTABLE();
    Xml_namespaces_clauseContext *xml_namespaces_clause();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<Xml_table_columnContext *> xml_table_column();
    Xml_table_columnContext* xml_table_column(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Other_functionContext* other_function();

  class  Over_clause_keywordContext : public antlr4::ParserRuleContext {
  public:
    Over_clause_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *CORR();
    antlr4::tree::TerminalNode *LAG();
    antlr4::tree::TerminalNode *LEAD();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MEDIAN();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *NTILE();
    antlr4::tree::TerminalNode *RATIO_TO_REPORT();
    antlr4::tree::TerminalNode *ROW_NUMBER();
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *VARIANCE();
    antlr4::tree::TerminalNode *REGR_();
    antlr4::tree::TerminalNode *STDDEV();
    antlr4::tree::TerminalNode *VAR_();
    antlr4::tree::TerminalNode *COVAR_();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Over_clause_keywordContext* over_clause_keyword();

  class  Within_or_over_clause_keywordContext : public antlr4::ParserRuleContext {
  public:
    Within_or_over_clause_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CUME_DIST();
    antlr4::tree::TerminalNode *DENSE_RANK();
    antlr4::tree::TerminalNode *LISTAGG();
    antlr4::tree::TerminalNode *PERCENT_RANK();
    antlr4::tree::TerminalNode *PERCENTILE_CONT();
    antlr4::tree::TerminalNode *PERCENTILE_DISC();
    antlr4::tree::TerminalNode *RANK();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Within_or_over_clause_keywordContext* within_or_over_clause_keyword();

  class  Standard_prediction_function_keywordContext : public antlr4::ParserRuleContext {
  public:
    Standard_prediction_function_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PREDICTION();
    antlr4::tree::TerminalNode *PREDICTION_BOUNDS();
    antlr4::tree::TerminalNode *PREDICTION_COST();
    antlr4::tree::TerminalNode *PREDICTION_DETAILS();
    antlr4::tree::TerminalNode *PREDICTION_PROBABILITY();
    antlr4::tree::TerminalNode *PREDICTION_SET();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standard_prediction_function_keywordContext* standard_prediction_function_keyword();

  class  Over_clauseContext : public antlr4::ParserRuleContext {
  public:
    Over_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OVER();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Query_partition_clauseContext *query_partition_clause();
    Order_by_clauseContext *order_by_clause();
    Windowing_clauseContext *windowing_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Over_clauseContext* over_clause();

  class  Windowing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Windowing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Windowing_typeContext *windowing_type();
    antlr4::tree::TerminalNode *BETWEEN();
    std::vector<Windowing_elementsContext *> windowing_elements();
    Windowing_elementsContext* windowing_elements(size_t i);
    antlr4::tree::TerminalNode *AND();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_clauseContext* windowing_clause();

  class  Windowing_typeContext : public antlr4::ParserRuleContext {
  public:
    Windowing_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *RANGE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_typeContext* windowing_type();

  class  Windowing_elementsContext : public antlr4::ParserRuleContext {
  public:
    Windowing_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNBOUNDED();
    antlr4::tree::TerminalNode *PRECEDING();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *ROW();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *FOLLOWING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_elementsContext* windowing_elements();

  class  Collect_order_by_partContext : public antlr4::ParserRuleContext {
  public:
    Collect_order_by_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collect_order_by_partContext* collect_order_by_part();

  class  Within_or_over_partContext : public antlr4::ParserRuleContext {
  public:
    Within_or_over_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITHIN();
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Over_clauseContext *over_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Within_or_over_partContext* within_or_over_part();

  class  Xml_passing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_passing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PASSING();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *VALUE();
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_passing_clauseContext* xml_passing_clause();

  class  Xml_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLATTRIBUTES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Xml_multiuse_expression_elementContext *> xml_multiuse_expression_element();
    Xml_multiuse_expression_elementContext* xml_multiuse_expression_element(size_t i);
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *SCHEMACHECK();
    antlr4::tree::TerminalNode *NOSCHEMACHECK();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_attributes_clauseContext* xml_attributes_clause();

  class  Xml_namespaces_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_namespaces_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLNAMESPACES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Xml_general_default_partContext *xml_general_default_part();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_namespaces_clauseContext* xml_namespaces_clause();

  class  Xml_table_columnContext : public antlr4::ParserRuleContext {
  public:
    Xml_table_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Xml_column_nameContext *xml_column_name();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *ORDINALITY();
    DatatypeContext *datatype();
    antlr4::tree::TerminalNode *PATH();
    ConcatenationContext *concatenation();
    Xml_general_default_partContext *xml_general_default_part();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_table_columnContext* xml_table_column();

  class  Xml_general_default_partContext : public antlr4::ParserRuleContext {
  public:
    Xml_general_default_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_general_default_partContext* xml_general_default_part();

  class  Xml_multiuse_expression_elementContext : public antlr4::ParserRuleContext {
  public:
    Xml_multiuse_expression_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *AS();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *EVALNAME();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_multiuse_expression_elementContext* xml_multiuse_expression_element();

  class  Xmlroot_param_version_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlroot_param_version_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *VALUE();
    ExpressionContext *expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlroot_param_version_partContext* xmlroot_param_version_part();

  class  Xmlroot_param_standalone_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlroot_param_standalone_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STANDALONE();
    antlr4::tree::TerminalNode *YES();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *VALUE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlroot_param_standalone_partContext* xmlroot_param_standalone_part();

  class  Xmlserialize_param_enconding_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_enconding_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENCODING();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_enconding_partContext* xmlserialize_param_enconding_part();

  class  Xmlserialize_param_version_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_version_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSION();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_version_partContext* xmlserialize_param_version_part();

  class  Xmlserialize_param_ident_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_ident_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *INDENT();
    antlr4::tree::TerminalNode *SIZE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ConcatenationContext *concatenation();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_ident_partContext* xmlserialize_param_ident_part();

  class  Bind_variableContext : public antlr4::ParserRuleContext {
  public:
    Bind_variableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> BINDVAR();
    antlr4::tree::TerminalNode* BINDVAR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COLON();
    antlr4::tree::TerminalNode* COLON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);
    antlr4::tree::TerminalNode *INDICATOR();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Bind_variableContext* bind_variable();

  class  General_elementContext : public antlr4::ParserRuleContext {
  public:
    General_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_elementContext* general_element();

  class  General_element_partContext : public antlr4::ParserRuleContext {
  public:
    General_element_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();
    Function_argumentContext *function_argument();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_element_partContext* general_element_part();

  class  Table_elementContext : public antlr4::ParserRuleContext {
  public:
    Table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_elementContext* table_element();

  class  Tableview_nameContext : public antlr4::ParserRuleContext {
  public:
    Tableview_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_nameContext *table_name();
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();
    Partition_extension_clauseContext *partition_extension_clause();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tableview_nameContext* tableview_name();

  class  Column_nameContext : public antlr4::ParserRuleContext {
  public:
    Column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_nameContext* column_name();

  class  Table_nameContext : public antlr4::ParserRuleContext {
  public:
    Table_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_nameContext* table_name();

  class  Link_nameContext : public antlr4::ParserRuleContext {
  public:
    Link_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Link_nameContext* link_name();

  class  Char_set_nameContext : public antlr4::ParserRuleContext {
  public:
    Char_set_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Char_set_nameContext* char_set_name();

  class  Column_aliasContext : public antlr4::ParserRuleContext {
  public:
    Column_aliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_aliasContext* column_alias();

  class  Table_aliasContext : public antlr4::ParserRuleContext {
  public:
    Table_aliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_aliasContext* table_alias();

  class  Xml_column_nameContext : public antlr4::ParserRuleContext {
  public:
    Xml_column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_column_nameContext* xml_column_name();

  class  Paren_column_listContext : public antlr4::ParserRuleContext {
  public:
    Paren_column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Paren_column_listContext* paren_column_list();

  class  Column_listContext : public antlr4::ParserRuleContext {
  public:
    Column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_listContext* column_list();

  class  With_query_nameContext : public antlr4::ParserRuleContext {
  public:
    With_query_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  With_query_nameContext* with_query_name();

  class  Constraint_nameContext : public antlr4::ParserRuleContext {
  public:
    Constraint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constraint_nameContext* constraint_name();

  class  Label_nameContext : public antlr4::ParserRuleContext {
  public:
    Label_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Label_nameContext* label_name();

  class  Partition_extension_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partition_extension_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *FOR();
    ExpressionsContext *expressions();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_extension_clauseContext* partition_extension_clause();

  class  ConstantContext : public antlr4::ParserRuleContext {
  public:
    ConstantContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TIMESTAMP();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    std::vector<Bind_variableContext *> bind_variable();
    Bind_variableContext* bind_variable(size_t i);
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();
    std::vector<antlr4::tree::TerminalNode *> DAY();
    antlr4::tree::TerminalNode* DAY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HOUR();
    antlr4::tree::TerminalNode* HOUR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MINUTE();
    antlr4::tree::TerminalNode* MINUTE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECOND();
    antlr4::tree::TerminalNode* SECOND(size_t i);
    General_element_partContext *general_element_part();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *TRUE();
    antlr4::tree::TerminalNode *FALSE();
    antlr4::tree::TerminalNode *DBTIMEZONE();
    antlr4::tree::TerminalNode *SESSIONTIMEZONE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *DEFAULT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConstantContext* constant();

  class  NumericContext : public antlr4::ParserRuleContext {
  public:
    NumericContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *APPROXIMATE_NUM_LIT();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  NumericContext* numeric();

  class  Numeric_negativeContext : public antlr4::ParserRuleContext {
  public:
    Numeric_negativeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_SIGN();
    NumericContext *numeric();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_negativeContext* numeric_negative();

  class  Quoted_stringContext : public antlr4::ParserRuleContext {
  public:
    Quoted_stringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *NATIONAL_CHAR_STRING_LIT();
    antlr4::tree::TerminalNode *UNI_STRING();
    antlr4::tree::TerminalNode *CHAR_DOUBLE_QUOTED_STRING();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quoted_stringContext* quoted_string();

  class  IdentifierContext : public antlr4::ParserRuleContext {
  public:
    IdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  IdentifierContext* identifier();

  class  Id_expressionContext : public antlr4::ParserRuleContext {
  public:
    Id_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *DELIMITED_ID();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Id_expressionContext* id_expression();

  class  Outer_join_signContext : public antlr4::ParserRuleContext {
  public:
    Outer_join_signContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Outer_join_signContext* outer_join_sign();

  class  Regular_idContext : public antlr4::ParserRuleContext {
  public:
    Regular_idContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Non_reserved_keywords_pre12cContext *non_reserved_keywords_pre12c();
    Non_reserved_keywords_in_12cContext *non_reserved_keywords_in_12c();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *A_LETTER();
    antlr4::tree::TerminalNode *AGENT();
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *AUTONOMOUS_TRANSACTION();
    antlr4::tree::TerminalNode *BATCH();
    antlr4::tree::TerminalNode *BINARY_INTEGER();
    antlr4::tree::TerminalNode *BOOLEAN();
    antlr4::tree::TerminalNode *C_LETTER();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *CONSTRUCTOR();
    antlr4::tree::TerminalNode *CUSTOMDATUM();
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *DETERMINISTIC();
    antlr4::tree::TerminalNode *DSINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *ERR();
    antlr4::tree::TerminalNode *EXCEPTION();
    antlr4::tree::TerminalNode *EXCEPTION_INIT();
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *EXIT();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *FORALL();
    antlr4::tree::TerminalNode *INDICES();
    antlr4::tree::TerminalNode *INOUT();
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *LANGUAGE();
    antlr4::tree::TerminalNode *LONG();
    antlr4::tree::TerminalNode *LOOP();
    antlr4::tree::TerminalNode *NUMBER();
    antlr4::tree::TerminalNode *ORADATA();
    antlr4::tree::TerminalNode *OSERROR();
    antlr4::tree::TerminalNode *OUT();
    antlr4::tree::TerminalNode *OVERRIDING();
    antlr4::tree::TerminalNode *PARALLEL_ENABLE();
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *PLS_INTEGER();
    antlr4::tree::TerminalNode *POSITIVE();
    antlr4::tree::TerminalNode *POSITIVEN();
    antlr4::tree::TerminalNode *PRAGMA();
    antlr4::tree::TerminalNode *RAISE();
    antlr4::tree::TerminalNode *RAW();
    antlr4::tree::TerminalNode *RECORD();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *RESTRICT_REFERENCES();
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *SELF();
    antlr4::tree::TerminalNode *SERIALLY_REUSABLE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *SIGNTYPE();
    antlr4::tree::TerminalNode *SIMPLE_INTEGER();
    antlr4::tree::TerminalNode *SMALLINT();
    antlr4::tree::TerminalNode *SQLDATA();
    antlr4::tree::TerminalNode *SQLERROR();
    antlr4::tree::TerminalNode *SUBTYPE();
    antlr4::tree::TerminalNode *TIMESTAMP_LTZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_TZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *VARCHAR();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *VARIABLE();
    antlr4::tree::TerminalNode *WARNING();
    antlr4::tree::TerminalNode *WHILE();
    antlr4::tree::TerminalNode *XMLAGG();
    antlr4::tree::TerminalNode *YMINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *REGR_();
    antlr4::tree::TerminalNode *VAR_();
    antlr4::tree::TerminalNode *COVAR_();
    antlr4::tree::TerminalNode *PUBLIC();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Regular_idContext* regular_id();

  class  Non_reserved_keywords_in_12cContext : public antlr4::ParserRuleContext {
  public:
    Non_reserved_keywords_in_12cContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACL();
    antlr4::tree::TerminalNode *ACTION();
    antlr4::tree::TerminalNode *ACTIONS();
    antlr4::tree::TerminalNode *ACTIVE();
    antlr4::tree::TerminalNode *ACTIVE_DATA();
    antlr4::tree::TerminalNode *ACTIVITY();
    antlr4::tree::TerminalNode *ADAPTIVE_PLAN();
    antlr4::tree::TerminalNode *ADVANCED();
    antlr4::tree::TerminalNode *AFD_DISKSTRING();
    antlr4::tree::TerminalNode *ANOMALY();
    antlr4::tree::TerminalNode *ANSI_REARCH();
    antlr4::tree::TerminalNode *APPLICATION();
    antlr4::tree::TerminalNode *APPROX_COUNT_DISTINCT();
    antlr4::tree::TerminalNode *ARCHIVAL();
    antlr4::tree::TerminalNode *ARCHIVED();
    antlr4::tree::TerminalNode *ASIS();
    antlr4::tree::TerminalNode *ASSIGN();
    antlr4::tree::TerminalNode *AUTO_LOGIN();
    antlr4::tree::TerminalNode *AUTO_REOPTIMIZE();
    antlr4::tree::TerminalNode *AVRO();
    antlr4::tree::TerminalNode *BACKGROUND();
    antlr4::tree::TerminalNode *BATCHSIZE();
    antlr4::tree::TerminalNode *BATCH_TABLE_ACCESS_BY_ROWID();
    antlr4::tree::TerminalNode *BEGINNING();
    antlr4::tree::TerminalNode *BEQUEATH();
    antlr4::tree::TerminalNode *BITMAP_AND();
    antlr4::tree::TerminalNode *BSON();
    antlr4::tree::TerminalNode *CACHING();
    antlr4::tree::TerminalNode *CALCULATED();
    antlr4::tree::TerminalNode *CALLBACK();
    antlr4::tree::TerminalNode *CAPACITY();
    antlr4::tree::TerminalNode *CDBDEFAULT();
    antlr4::tree::TerminalNode *CLASSIFIER();
    antlr4::tree::TerminalNode *CLEANUP();
    antlr4::tree::TerminalNode *CLIENT();
    antlr4::tree::TerminalNode *CLUSTER_DETAILS();
    antlr4::tree::TerminalNode *CLUSTER_DISTANCE();
    antlr4::tree::TerminalNode *CLUSTERING();
    antlr4::tree::TerminalNode *COMMON_DATA();
    antlr4::tree::TerminalNode *COMPONENT();
    antlr4::tree::TerminalNode *COMPONENTS();
    antlr4::tree::TerminalNode *CON_DBID_TO_ID();
    antlr4::tree::TerminalNode *CONDITION();
    antlr4::tree::TerminalNode *CONDITIONAL();
    antlr4::tree::TerminalNode *CON_GUID_TO_ID();
    antlr4::tree::TerminalNode *CON_ID();
    antlr4::tree::TerminalNode *CON_NAME_TO_ID();
    antlr4::tree::TerminalNode *CONTAINER_DATA();
    antlr4::tree::TerminalNode *CONTAINERS();
    antlr4::tree::TerminalNode *CON_UID_TO_ID();
    antlr4::tree::TerminalNode *COOKIE();
    antlr4::tree::TerminalNode *COPY();
    antlr4::tree::TerminalNode *CREATE_FILE_DEST();
    antlr4::tree::TerminalNode *CREDENTIAL();
    antlr4::tree::TerminalNode *CRITICAL();
    antlr4::tree::TerminalNode *CUBE_AJ();
    antlr4::tree::TerminalNode *CUBE_SJ();
    antlr4::tree::TerminalNode *DATAMOVEMENT();
    antlr4::tree::TerminalNode *DATAOBJ_TO_MAT_PARTITION();
    antlr4::tree::TerminalNode *DATAPUMP();
    antlr4::tree::TerminalNode *DATA_SECURITY_REWRITE_LIMIT();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *DB_UNIQUE_NAME();
    antlr4::tree::TerminalNode *DECORRELATE();
    antlr4::tree::TerminalNode *DEFINE();
    antlr4::tree::TerminalNode *DELEGATE();
    antlr4::tree::TerminalNode *DELETE_ALL();
    antlr4::tree::TerminalNode *DESTROY();
    antlr4::tree::TerminalNode *DIMENSIONS();
    antlr4::tree::TerminalNode *DISABLE_ALL();
    antlr4::tree::TerminalNode *DISABLE_PARALLEL_DML();
    antlr4::tree::TerminalNode *DISCARD();
    antlr4::tree::TerminalNode *DISTRIBUTE();
    antlr4::tree::TerminalNode *DUPLICATE();
    antlr4::tree::TerminalNode *DV();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *ELIM_GROUPBY();
    antlr4::tree::TerminalNode *EM();
    antlr4::tree::TerminalNode *ENABLE_ALL();
    antlr4::tree::TerminalNode *ENABLE_PARALLEL_DML();
    antlr4::tree::TerminalNode *EQUIPART();
    antlr4::tree::TerminalNode *EVAL();
    antlr4::tree::TerminalNode *EVALUATE();
    antlr4::tree::TerminalNode *EXISTING();
    antlr4::tree::TerminalNode *EXPRESS();
    antlr4::tree::TerminalNode *EXTRACTCLOBXML();
    antlr4::tree::TerminalNode *FACTOR();
    antlr4::tree::TerminalNode *FAILOVER();
    antlr4::tree::TerminalNode *FAILURE();
    antlr4::tree::TerminalNode *FAMILY();
    antlr4::tree::TerminalNode *FAR();
    antlr4::tree::TerminalNode *FASTSTART();
    antlr4::tree::TerminalNode *FEATURE_DETAILS();
    antlr4::tree::TerminalNode *FETCH();
    antlr4::tree::TerminalNode *FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *FIXED_VIEW_DATA();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *GATHER_OPTIMIZER_STATISTICS();
    antlr4::tree::TerminalNode *GET();
    antlr4::tree::TerminalNode *ILM();
    antlr4::tree::TerminalNode *INACTIVE();
    antlr4::tree::TerminalNode *INDEXING();
    antlr4::tree::TerminalNode *INHERIT();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *INMEMORY_PRUNING();
    antlr4::tree::TerminalNode *INPLACE();
    antlr4::tree::TerminalNode *INTERLEAVED();
    antlr4::tree::TerminalNode *JSON();
    antlr4::tree::TerminalNode *JSON_ARRAY();
    antlr4::tree::TerminalNode *JSON_ARRAYAGG();
    antlr4::tree::TerminalNode *JSON_EQUAL();
    antlr4::tree::TerminalNode *JSON_EXISTS();
    antlr4::tree::TerminalNode *JSON_EXISTS2();
    antlr4::tree::TerminalNode *JSONGET();
    antlr4::tree::TerminalNode *JSON_OBJECT();
    antlr4::tree::TerminalNode *JSON_OBJECTAGG();
    antlr4::tree::TerminalNode *JSONPARSE();
    antlr4::tree::TerminalNode *JSON_QUERY();
    antlr4::tree::TerminalNode *JSON_SERIALIZE();
    antlr4::tree::TerminalNode *JSON_TABLE();
    antlr4::tree::TerminalNode *JSON_TEXTCONTAINS();
    antlr4::tree::TerminalNode *JSON_TEXTCONTAINS2();
    antlr4::tree::TerminalNode *JSON_VALUE();
    antlr4::tree::TerminalNode *KEYSTORE();
    antlr4::tree::TerminalNode *LABEL();
    antlr4::tree::TerminalNode *LAX();
    antlr4::tree::TerminalNode *LIFECYCLE();
    antlr4::tree::TerminalNode *LINEAR();
    antlr4::tree::TerminalNode *LOCKING();
    antlr4::tree::TerminalNode *LOGMINING();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *MATCH();
    antlr4::tree::TerminalNode *MATCHES();
    antlr4::tree::TerminalNode *MATCH_NUMBER();
    antlr4::tree::TerminalNode *MATCH_RECOGNIZE();
    antlr4::tree::TerminalNode *MAX_SHARED_TEMP_SIZE();
    antlr4::tree::TerminalNode *MEMCOMPRESS();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *MODEL_NB();
    antlr4::tree::TerminalNode *MODEL_SV();
    antlr4::tree::TerminalNode *MODIFICATION();
    antlr4::tree::TerminalNode *MODULE();
    antlr4::tree::TerminalNode *MONTHS();
    antlr4::tree::TerminalNode *MULTIDIMENSIONAL();
    antlr4::tree::TerminalNode *NEG();
    antlr4::tree::TerminalNode *NO_ADAPTIVE_PLAN();
    antlr4::tree::TerminalNode *NO_ANSI_REARCH();
    antlr4::tree::TerminalNode *NO_AUTO_REOPTIMIZE();
    antlr4::tree::TerminalNode *NO_BATCH_TABLE_ACCESS_BY_ROWID();
    antlr4::tree::TerminalNode *NO_CLUSTERING();
    antlr4::tree::TerminalNode *NO_COMMON_DATA();
    antlr4::tree::TerminalNode *NOCOPY();
    antlr4::tree::TerminalNode *NO_DATA_SECURITY_REWRITE();
    antlr4::tree::TerminalNode *NO_DECORRELATE();
    antlr4::tree::TerminalNode *NO_ELIM_GROUPBY();
    antlr4::tree::TerminalNode *NO_GATHER_OPTIMIZER_STATISTICS();
    antlr4::tree::TerminalNode *NO_INMEMORY();
    antlr4::tree::TerminalNode *NO_INMEMORY_PRUNING();
    antlr4::tree::TerminalNode *NOKEEP();
    antlr4::tree::TerminalNode *NONEDITIONABLE();
    antlr4::tree::TerminalNode *NO_OBJECT_LINK();
    antlr4::tree::TerminalNode *NO_PARTIAL_JOIN();
    antlr4::tree::TerminalNode *NO_PARTIAL_ROLLUP_PUSHDOWN();
    antlr4::tree::TerminalNode *NOPARTITION();
    antlr4::tree::TerminalNode *NO_PQ_CONCURRENT_UNION();
    antlr4::tree::TerminalNode *NO_PQ_REPLICATE();
    antlr4::tree::TerminalNode *NO_PQ_SKEW();
    antlr4::tree::TerminalNode *NO_PX_FAULT_TOLERANCE();
    antlr4::tree::TerminalNode *NORELOCATE();
    antlr4::tree::TerminalNode *NOREPLAY();
    antlr4::tree::TerminalNode *NO_ROOT_SW_FOR_LOCAL();
    antlr4::tree::TerminalNode *NO_SQL_TRANSLATION();
    antlr4::tree::TerminalNode *NO_USE_CUBE();
    antlr4::tree::TerminalNode *NO_USE_VECTOR_AGGREGATION();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM_DIMS();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM_FACT();
    antlr4::tree::TerminalNode *NO_ZONEMAP();
    antlr4::tree::TerminalNode *OBJ_ID();
    antlr4::tree::TerminalNode *OFFSET();
    antlr4::tree::TerminalNode *OLS();
    antlr4::tree::TerminalNode *OMIT();
    antlr4::tree::TerminalNode *ONE();
    antlr4::tree::TerminalNode *ORA_CHECK_ACL();
    antlr4::tree::TerminalNode *ORA_CHECK_PRIVILEGE();
    antlr4::tree::TerminalNode *ORA_CLUSTERING();
    antlr4::tree::TerminalNode *ORA_INVOKING_USER();
    antlr4::tree::TerminalNode *ORA_INVOKING_USERID();
    antlr4::tree::TerminalNode *ORA_INVOKING_XS_USER();
    antlr4::tree::TerminalNode *ORA_INVOKING_XS_USER_GUID();
    antlr4::tree::TerminalNode *ORA_RAWCOMPARE();
    antlr4::tree::TerminalNode *ORA_RAWCONCAT();
    antlr4::tree::TerminalNode *ORA_WRITE_TIME();
    antlr4::tree::TerminalNode *PARTIAL();
    antlr4::tree::TerminalNode *PARTIAL_JOIN();
    antlr4::tree::TerminalNode *PARTIAL_ROLLUP_PUSHDOWN();
    antlr4::tree::TerminalNode *PAST();
    antlr4::tree::TerminalNode *PATCH();
    antlr4::tree::TerminalNode *PATH_PREFIX();
    antlr4::tree::TerminalNode *PATTERN();
    antlr4::tree::TerminalNode *PER();
    antlr4::tree::TerminalNode *PERMUTE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *POOL_16K();
    antlr4::tree::TerminalNode *POOL_2K();
    antlr4::tree::TerminalNode *POOL_32K();
    antlr4::tree::TerminalNode *POOL_4K();
    antlr4::tree::TerminalNode *POOL_8K();
    antlr4::tree::TerminalNode *PQ_CONCURRENT_UNION();
    antlr4::tree::TerminalNode *PQ_DISTRIBUTE_WINDOW();
    antlr4::tree::TerminalNode *PQ_FILTER();
    antlr4::tree::TerminalNode *PQ_REPLICATE();
    antlr4::tree::TerminalNode *PQ_SKEW();
    antlr4::tree::TerminalNode *PRELOAD();
    antlr4::tree::TerminalNode *PRETTY();
    antlr4::tree::TerminalNode *PREV();
    antlr4::tree::TerminalNode *PRINTBLOBTOCLOB();
    antlr4::tree::TerminalNode *PRIORITY();
    antlr4::tree::TerminalNode *PRIVILEGED();
    antlr4::tree::TerminalNode *PROXY();
    antlr4::tree::TerminalNode *PRUNING();
    antlr4::tree::TerminalNode *PX_FAULT_TOLERANCE();
    antlr4::tree::TerminalNode *REALM();
    antlr4::tree::TerminalNode *REDEFINE();
    antlr4::tree::TerminalNode *RELOCATE();
    antlr4::tree::TerminalNode *RESTART();
    antlr4::tree::TerminalNode *ROLESET();
    antlr4::tree::TerminalNode *ROWID_MAPPING_TABLE();
    antlr4::tree::TerminalNode *RUNNING();
    antlr4::tree::TerminalNode *SAVE();
    antlr4::tree::TerminalNode *SCRUB();
    antlr4::tree::TerminalNode *SDO_GEOM_MBR();
    antlr4::tree::TerminalNode *SECRET();
    antlr4::tree::TerminalNode *SERIAL();
    antlr4::tree::TerminalNode *SERVICE_NAME_CONVERT();
    antlr4::tree::TerminalNode *SERVICES();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *SHELFLIFE();
    antlr4::tree::TerminalNode *SOURCE_FILE_DIRECTORY();
    antlr4::tree::TerminalNode *SOURCE_FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *SQL_TRANSLATION_PROFILE();
    antlr4::tree::TerminalNode *STANDARD_HASH();
    antlr4::tree::TerminalNode *STANDBYS();
    antlr4::tree::TerminalNode *STATE();
    antlr4::tree::TerminalNode *STATEMENT();
    antlr4::tree::TerminalNode *STREAM();
    antlr4::tree::TerminalNode *SUBSCRIBE();
    antlr4::tree::TerminalNode *SUBSET();
    antlr4::tree::TerminalNode *SUCCESS();
    antlr4::tree::TerminalNode *SYSBACKUP();
    antlr4::tree::TerminalNode *SYS_CHECK_PRIVILEGE();
    antlr4::tree::TerminalNode *SYSDG();
    antlr4::tree::TerminalNode *SYS_GET_COL_ACLIDS();
    antlr4::tree::TerminalNode *SYSGUID();
    antlr4::tree::TerminalNode *SYSKM();
    antlr4::tree::TerminalNode *SYS_MKXTI();
    antlr4::tree::TerminalNode *SYSOBJ();
    antlr4::tree::TerminalNode *SYS_OP_CYCLED_SEQ();
    antlr4::tree::TerminalNode *SYS_OP_HASH();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_CREATE();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_FILTER();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_FILTER_LIST();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_SUCCEEDED();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_USE();
    antlr4::tree::TerminalNode *SYS_OP_PART_ID();
    antlr4::tree::TerminalNode *SYS_OP_ZONE_ID();
    antlr4::tree::TerminalNode *SYS_RAW_TO_XSID();
    antlr4::tree::TerminalNode *SYS_XSID_TO_RAW();
    antlr4::tree::TerminalNode *SYS_ZMAP_FILTER();
    antlr4::tree::TerminalNode *SYS_ZMAP_REFRESH();
    antlr4::tree::TerminalNode *TAG();
    antlr4::tree::TerminalNode *TEXT();
    antlr4::tree::TerminalNode *TIER();
    antlr4::tree::TerminalNode *TIES();
    antlr4::tree::TerminalNode *TO_ACLID();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *TRUST();
    antlr4::tree::TerminalNode *UCS2();
    antlr4::tree::TerminalNode *UNCONDITIONAL();
    antlr4::tree::TerminalNode *UNMATCHED();
    antlr4::tree::TerminalNode *UNPLUG();
    antlr4::tree::TerminalNode *UNSUBSCRIBE();
    antlr4::tree::TerminalNode *USABLE();
    antlr4::tree::TerminalNode *USE_CUBE();
    antlr4::tree::TerminalNode *USE_HIDDEN_PARTITIONS();
    antlr4::tree::TerminalNode *USER_DATA();
    antlr4::tree::TerminalNode *USER_TABLESPACES();
    antlr4::tree::TerminalNode *USE_VECTOR_AGGREGATION();
    antlr4::tree::TerminalNode *USING_NO_EXPAND();
    antlr4::tree::TerminalNode *UTF16BE();
    antlr4::tree::TerminalNode *UTF16LE();
    antlr4::tree::TerminalNode *UTF32();
    antlr4::tree::TerminalNode *UTF8();
    antlr4::tree::TerminalNode *V1();
    antlr4::tree::TerminalNode *V2();
    antlr4::tree::TerminalNode *VALID_TIME_END();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM_DIMS();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM_FACT();
    antlr4::tree::TerminalNode *VERIFIER();
    antlr4::tree::TerminalNode *VIOLATION();
    antlr4::tree::TerminalNode *VISIBILITY();
    antlr4::tree::TerminalNode *WEEK();
    antlr4::tree::TerminalNode *WEEKS();
    antlr4::tree::TerminalNode *WITH_PLSQL();
    antlr4::tree::TerminalNode *WRAPPER();
    antlr4::tree::TerminalNode *XS();
    antlr4::tree::TerminalNode *YEARS();
    antlr4::tree::TerminalNode *ZONEMAP();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_reserved_keywords_in_12cContext* non_reserved_keywords_in_12c();

  class  Non_reserved_keywords_pre12cContext : public antlr4::ParserRuleContext {
  public:
    Non_reserved_keywords_pre12cContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ABORT();
    antlr4::tree::TerminalNode *ABS();
    antlr4::tree::TerminalNode *ACCESSED();
    antlr4::tree::TerminalNode *ACCESS();
    antlr4::tree::TerminalNode *ACCOUNT();
    antlr4::tree::TerminalNode *ACOS();
    antlr4::tree::TerminalNode *ACTIVATE();
    antlr4::tree::TerminalNode *ACTIVE_COMPONENT();
    antlr4::tree::TerminalNode *ACTIVE_FUNCTION();
    antlr4::tree::TerminalNode *ACTIVE_TAG();
    antlr4::tree::TerminalNode *ADD_COLUMN();
    antlr4::tree::TerminalNode *ADD_GROUP();
    antlr4::tree::TerminalNode *ADD_MONTHS();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *ADJ_DATE();
    antlr4::tree::TerminalNode *ADMINISTER();
    antlr4::tree::TerminalNode *ADMINISTRATOR();
    antlr4::tree::TerminalNode *ADMIN();
    antlr4::tree::TerminalNode *ADVISE();
    antlr4::tree::TerminalNode *ADVISOR();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *ALIAS();
    antlr4::tree::TerminalNode *ALLOCATE();
    antlr4::tree::TerminalNode *ALLOW();
    antlr4::tree::TerminalNode *ALL_ROWS();
    antlr4::tree::TerminalNode *ALWAYS();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *ANCILLARY();
    antlr4::tree::TerminalNode *AND_EQUAL();
    antlr4::tree::TerminalNode *ANTIJOIN();
    antlr4::tree::TerminalNode *ANYSCHEMA();
    antlr4::tree::TerminalNode *APPENDCHILDXML();
    antlr4::tree::TerminalNode *APPEND();
    antlr4::tree::TerminalNode *APPEND_VALUES();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *ARCHIVELOG();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *ASCII();
    antlr4::tree::TerminalNode *ASCIISTR();
    antlr4::tree::TerminalNode *ASIN();
    antlr4::tree::TerminalNode *ASSEMBLY();
    antlr4::tree::TerminalNode *ASSOCIATE();
    antlr4::tree::TerminalNode *ASYNCHRONOUS();
    antlr4::tree::TerminalNode *ASYNC();
    antlr4::tree::TerminalNode *ATAN2();
    antlr4::tree::TerminalNode *ATAN();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ATTRIBUTE();
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *AUTHENTICATED();
    antlr4::tree::TerminalNode *AUTHENTICATION();
    antlr4::tree::TerminalNode *AUTHID();
    antlr4::tree::TerminalNode *AUTHORIZATION();
    antlr4::tree::TerminalNode *AUTOALLOCATE();
    antlr4::tree::TerminalNode *AUTOEXTEND();
    antlr4::tree::TerminalNode *AUTOMATIC();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *AVAILABILITY();
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *BASICFILE();
    antlr4::tree::TerminalNode *BASIC();
    antlr4::tree::TerminalNode *BATCH();
    antlr4::tree::TerminalNode *BECOME();
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *BEGIN();
    antlr4::tree::TerminalNode *BEGIN_OUTLINE_DATA();
    antlr4::tree::TerminalNode *BEHALF();
    antlr4::tree::TerminalNode *BFILE();
    antlr4::tree::TerminalNode *BFILENAME();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *BINARY_DOUBLE_INFINITY();
    antlr4::tree::TerminalNode *BINARY_DOUBLE();
    antlr4::tree::TerminalNode *BINARY_DOUBLE_NAN();
    antlr4::tree::TerminalNode *BINARY_FLOAT_INFINITY();
    antlr4::tree::TerminalNode *BINARY_FLOAT();
    antlr4::tree::TerminalNode *BINARY_FLOAT_NAN();
    antlr4::tree::TerminalNode *BINARY();
    antlr4::tree::TerminalNode *BIND_AWARE();
    antlr4::tree::TerminalNode *BINDING();
    antlr4::tree::TerminalNode *BIN_TO_NUM();
    antlr4::tree::TerminalNode *BITAND();
    antlr4::tree::TerminalNode *BITMAP();
    antlr4::tree::TerminalNode *BITMAPS();
    antlr4::tree::TerminalNode *BITMAP_TREE();
    antlr4::tree::TerminalNode *BITS();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *BLOCK_RANGE();
    antlr4::tree::TerminalNode *BLOCKSIZE();
    antlr4::tree::TerminalNode *BLOCKS();
    antlr4::tree::TerminalNode *BODY();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *BOUND();
    antlr4::tree::TerminalNode *BRANCH();
    antlr4::tree::TerminalNode *BREADTH();
    antlr4::tree::TerminalNode *BROADCAST();
    antlr4::tree::TerminalNode *BUFFER_CACHE();
    antlr4::tree::TerminalNode *BUFFER();
    antlr4::tree::TerminalNode *BUFFER_POOL();
    antlr4::tree::TerminalNode *BUILD();
    antlr4::tree::TerminalNode *BULK();
    antlr4::tree::TerminalNode *BYPASS_RECURSIVE_CHECK();
    antlr4::tree::TerminalNode *BYPASS_UJVC();
    antlr4::tree::TerminalNode *BYTE();
    antlr4::tree::TerminalNode *CACHE_CB();
    antlr4::tree::TerminalNode *CACHE_INSTANCES();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *CACHE_TEMP_TABLE();
    antlr4::tree::TerminalNode *CALL();
    antlr4::tree::TerminalNode *CANCEL();
    antlr4::tree::TerminalNode *CARDINALITY();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CASE();
    antlr4::tree::TerminalNode *CAST();
    antlr4::tree::TerminalNode *CATEGORY();
    antlr4::tree::TerminalNode *CEIL();
    antlr4::tree::TerminalNode *CELL_FLASH_CACHE();
    antlr4::tree::TerminalNode *CERTIFICATE();
    antlr4::tree::TerminalNode *CFILE();
    antlr4::tree::TerminalNode *CHAINED();
    antlr4::tree::TerminalNode *CHANGE_DUPKEY_ERROR_INDEX();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *CHAR_CS();
    antlr4::tree::TerminalNode *CHARTOROWID();
    antlr4::tree::TerminalNode *CHECK_ACL_REWRITE();
    antlr4::tree::TerminalNode *CHECKPOINT();
    antlr4::tree::TerminalNode *CHILD();
    antlr4::tree::TerminalNode *CHOOSE();
    antlr4::tree::TerminalNode *CHR();
    antlr4::tree::TerminalNode *CHUNK();
    antlr4::tree::TerminalNode *CLASS();
    antlr4::tree::TerminalNode *CLEAR();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *CLONE();
    antlr4::tree::TerminalNode *CLOSE_CACHED_OPEN_CURSORS();
    antlr4::tree::TerminalNode *CLOSE();
    antlr4::tree::TerminalNode *CLUSTER_BY_ROWID();
    antlr4::tree::TerminalNode *CLUSTER_ID();
    antlr4::tree::TerminalNode *CLUSTERING_FACTOR();
    antlr4::tree::TerminalNode *CLUSTER_PROBABILITY();
    antlr4::tree::TerminalNode *CLUSTER_SET();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *COALESCE_SQ();
    antlr4::tree::TerminalNode *COARSE();
    antlr4::tree::TerminalNode *CO_AUTH_IND();
    antlr4::tree::TerminalNode *COLD();
    antlr4::tree::TerminalNode *COLLECT();
    antlr4::tree::TerminalNode *COLUMNAR();
    antlr4::tree::TerminalNode *COLUMN_AUTH_INDICATOR();
    antlr4::tree::TerminalNode *COLUMN();
    antlr4::tree::TerminalNode *COLUMNS();
    antlr4::tree::TerminalNode *COLUMN_STATS();
    antlr4::tree::TerminalNode *COLUMN_VALUE();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *COMMITTED();
    antlr4::tree::TerminalNode *COMPACT();
    antlr4::tree::TerminalNode *COMPATIBILITY();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *COMPLETE();
    antlr4::tree::TerminalNode *COMPLIANCE();
    antlr4::tree::TerminalNode *COMPOSE();
    antlr4::tree::TerminalNode *COMPOSITE_LIMIT();
    antlr4::tree::TerminalNode *COMPOSITE();
    antlr4::tree::TerminalNode *COMPOUND();
    antlr4::tree::TerminalNode *COMPUTE();
    antlr4::tree::TerminalNode *CONCAT();
    antlr4::tree::TerminalNode *CONFIRM();
    antlr4::tree::TerminalNode *CONFORMING();
    antlr4::tree::TerminalNode *CONNECT_BY_CB_WHR_ONLY();
    antlr4::tree::TerminalNode *CONNECT_BY_COMBINE_SW();
    antlr4::tree::TerminalNode *CONNECT_BY_COST_BASED();
    antlr4::tree::TerminalNode *CONNECT_BY_ELIM_DUPS();
    antlr4::tree::TerminalNode *CONNECT_BY_FILTERING();
    antlr4::tree::TerminalNode *CONNECT_BY_ISCYCLE();
    antlr4::tree::TerminalNode *CONNECT_BY_ISLEAF();
    antlr4::tree::TerminalNode *CONNECT_BY_ROOT();
    antlr4::tree::TerminalNode *CONNECT_TIME();
    antlr4::tree::TerminalNode *CONSIDER();
    antlr4::tree::TerminalNode *CONSISTENT();
    antlr4::tree::TerminalNode *CONSTANT();
    antlr4::tree::TerminalNode *CONST();
    antlr4::tree::TerminalNode *CONSTRAINT();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *CONTENT();
    antlr4::tree::TerminalNode *CONTENTS();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *CONTINUE();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *CORR_K();
    antlr4::tree::TerminalNode *CORR();
    antlr4::tree::TerminalNode *CORR_S();
    antlr4::tree::TerminalNode *CORRUPTION();
    antlr4::tree::TerminalNode *CORRUPT_XID_ALL();
    antlr4::tree::TerminalNode *CORRUPT_XID();
    antlr4::tree::TerminalNode *COSH();
    antlr4::tree::TerminalNode *COS();
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *COST_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *COVAR_POP();
    antlr4::tree::TerminalNode *COVAR_SAMP();
    antlr4::tree::TerminalNode *CPU_COSTING();
    antlr4::tree::TerminalNode *CPU_PER_CALL();
    antlr4::tree::TerminalNode *CPU_PER_SESSION();
    antlr4::tree::TerminalNode *CRASH();
    antlr4::tree::TerminalNode *CREATE_STORED_OUTLINES();
    antlr4::tree::TerminalNode *CREATION();
    antlr4::tree::TerminalNode *CROSSEDITION();
    antlr4::tree::TerminalNode *CROSS();
    antlr4::tree::TerminalNode *CSCONVERT();
    antlr4::tree::TerminalNode *CUBE_GB();
    antlr4::tree::TerminalNode *CUBE();
    antlr4::tree::TerminalNode *CUME_DISTM();
    antlr4::tree::TerminalNode *CUME_DIST();
    antlr4::tree::TerminalNode *CURRENT_DATE();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *CURRENT_SCHEMA();
    antlr4::tree::TerminalNode *CURRENT_TIME();
    antlr4::tree::TerminalNode *CURRENT_TIMESTAMP();
    antlr4::tree::TerminalNode *CURRENT_USER();
    antlr4::tree::TerminalNode *CURRENTV();
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *CURSOR_SHARING_EXACT();
    antlr4::tree::TerminalNode *CURSOR_SPECIFIC_SEGMENT();
    antlr4::tree::TerminalNode *CV();
    antlr4::tree::TerminalNode *CYCLE();
    antlr4::tree::TerminalNode *DANGLING();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *DATAFILES();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *DATAOBJNO();
    antlr4::tree::TerminalNode *DATAOBJ_TO_PARTITION();
    antlr4::tree::TerminalNode *DATE_MODE();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *DBA();
    antlr4::tree::TerminalNode *DBA_RECYCLEBIN();
    antlr4::tree::TerminalNode *DBMS_STATS();
    antlr4::tree::TerminalNode *DB_ROLE_CHANGE();
    antlr4::tree::TerminalNode *DBTIMEZONE();
    antlr4::tree::TerminalNode *DB_VERSION();
    antlr4::tree::TerminalNode *DDL();
    antlr4::tree::TerminalNode *DEALLOCATE();
    antlr4::tree::TerminalNode *DEBUGGER();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *DECLARE();
    antlr4::tree::TerminalNode *DEC();
    antlr4::tree::TerminalNode *DECOMPOSE();
    antlr4::tree::TerminalNode *DECREMENT();
    antlr4::tree::TerminalNode *DECR();
    antlr4::tree::TerminalNode *DECRYPT();
    antlr4::tree::TerminalNode *DEDUPLICATE();
    antlr4::tree::TerminalNode *DEFAULTS();
    antlr4::tree::TerminalNode *DEFERRABLE();
    antlr4::tree::TerminalNode *DEFERRED();
    antlr4::tree::TerminalNode *DEFINED();
    antlr4::tree::TerminalNode *DEFINER();
    antlr4::tree::TerminalNode *DEGREE();
    antlr4::tree::TerminalNode *DELAY();
    antlr4::tree::TerminalNode *DELETEXML();
    antlr4::tree::TerminalNode *DEMAND();
    antlr4::tree::TerminalNode *DENSE_RANKM();
    antlr4::tree::TerminalNode *DENSE_RANK();
    antlr4::tree::TerminalNode *DEPENDENT();
    antlr4::tree::TerminalNode *DEPTH();
    antlr4::tree::TerminalNode *DEQUEUE();
    antlr4::tree::TerminalNode *DEREF();
    antlr4::tree::TerminalNode *DEREF_NO_REWRITE();
    antlr4::tree::TerminalNode *DETACHED();
    antlr4::tree::TerminalNode *DETERMINES();
    antlr4::tree::TerminalNode *DICTIONARY();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *DIRECT_LOAD();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *DIRECT_PATH();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *DISABLE_PRESET();
    antlr4::tree::TerminalNode *DISABLE_RPKE();
    antlr4::tree::TerminalNode *DISALLOW();
    antlr4::tree::TerminalNode *DISASSOCIATE();
    antlr4::tree::TerminalNode *DISCONNECT();
    antlr4::tree::TerminalNode *DISKGROUP();
    antlr4::tree::TerminalNode *DISK();
    antlr4::tree::TerminalNode *DISKS();
    antlr4::tree::TerminalNode *DISMOUNT();
    antlr4::tree::TerminalNode *DISTINGUISHED();
    antlr4::tree::TerminalNode *DISTRIBUTED();
    antlr4::tree::TerminalNode *DML();
    antlr4::tree::TerminalNode *DML_UPDATE();
    antlr4::tree::TerminalNode *DOCFIDELITY();
    antlr4::tree::TerminalNode *DOCUMENT();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_FILTER();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_NO_SORT();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_SORT();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *DOWNGRADE();
    antlr4::tree::TerminalNode *DRIVING_SITE();
    antlr4::tree::TerminalNode *DROP_COLUMN();
    antlr4::tree::TerminalNode *DROP_GROUP();
    antlr4::tree::TerminalNode *DST_UPGRADE_INSERT_CONV();
    antlr4::tree::TerminalNode *DUMP();
    antlr4::tree::TerminalNode *DYNAMIC();
    antlr4::tree::TerminalNode *DYNAMIC_SAMPLING_EST_CDN();
    antlr4::tree::TerminalNode *DYNAMIC_SAMPLING();
    antlr4::tree::TerminalNode *EACH();
    antlr4::tree::TerminalNode *EDITIONING();
    antlr4::tree::TerminalNode *EDITION();
    antlr4::tree::TerminalNode *EDITIONS();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *ELIMINATE_JOIN();
    antlr4::tree::TerminalNode *ELIMINATE_OBY();
    antlr4::tree::TerminalNode *ELIMINATE_OUTER_JOIN();
    antlr4::tree::TerminalNode *EMPTY_BLOB();
    antlr4::tree::TerminalNode *EMPTY_CLOB();
    antlr4::tree::TerminalNode *EMPTY();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *ENABLE_PRESET();
    antlr4::tree::TerminalNode *ENCODING();
    antlr4::tree::TerminalNode *ENCRYPTION();
    antlr4::tree::TerminalNode *ENCRYPT();
    antlr4::tree::TerminalNode *END_OUTLINE_DATA();
    antlr4::tree::TerminalNode *ENFORCED();
    antlr4::tree::TerminalNode *ENFORCE();
    antlr4::tree::TerminalNode *ENQUEUE();
    antlr4::tree::TerminalNode *ENTERPRISE();
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *ENTRY();
    antlr4::tree::TerminalNode *ERROR_ARGUMENT();
    antlr4::tree::TerminalNode *ERROR();
    antlr4::tree::TerminalNode *ERROR_ON_OVERLAP_TIME();
    antlr4::tree::TerminalNode *ERRORS();
    antlr4::tree::TerminalNode *ESCAPE();
    antlr4::tree::TerminalNode *ESTIMATE();
    antlr4::tree::TerminalNode *EVALNAME();
    antlr4::tree::TerminalNode *EVALUATION();
    antlr4::tree::TerminalNode *EVENTS();
    antlr4::tree::TerminalNode *EVERY();
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *EXCEPT();
    antlr4::tree::TerminalNode *EXCHANGE();
    antlr4::tree::TerminalNode *EXCLUDE();
    antlr4::tree::TerminalNode *EXCLUDING();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *EXEMPT();
    antlr4::tree::TerminalNode *EXISTSNODE();
    antlr4::tree::TerminalNode *EXPAND_GSET_TO_UNION();
    antlr4::tree::TerminalNode *EXPAND_TABLE();
    antlr4::tree::TerminalNode *EXPIRE();
    antlr4::tree::TerminalNode *EXPLAIN();
    antlr4::tree::TerminalNode *EXPLOSION();
    antlr4::tree::TerminalNode *EXP();
    antlr4::tree::TerminalNode *EXPORT();
    antlr4::tree::TerminalNode *EXPR_CORR_CHECK();
    antlr4::tree::TerminalNode *EXTENDS();
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *EXTENTS();
    antlr4::tree::TerminalNode *EXTERNALLY();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *EXTRACT();
    antlr4::tree::TerminalNode *EXTRACTVALUE();
    antlr4::tree::TerminalNode *EXTRA();
    antlr4::tree::TerminalNode *FACILITY();
    antlr4::tree::TerminalNode *FACT();
    antlr4::tree::TerminalNode *FACTORIZE_JOIN();
    antlr4::tree::TerminalNode *FAILED_LOGIN_ATTEMPTS();
    antlr4::tree::TerminalNode *FAILED();
    antlr4::tree::TerminalNode *FAILGROUP();
    antlr4::tree::TerminalNode *FALSE();
    antlr4::tree::TerminalNode *FAST();
    antlr4::tree::TerminalNode *FBTSCAN();
    antlr4::tree::TerminalNode *FEATURE_ID();
    antlr4::tree::TerminalNode *FEATURE_SET();
    antlr4::tree::TerminalNode *FEATURE_VALUE();
    antlr4::tree::TerminalNode *FILE();
    antlr4::tree::TerminalNode *FILESYSTEM_LIKE_LOGGING();
    antlr4::tree::TerminalNode *FILTER();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *FINE();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *FIRSTM();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *FIRST_ROWS();
    antlr4::tree::TerminalNode *FIRST_VALUE();
    antlr4::tree::TerminalNode *FLAGGER();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *FLASH_CACHE();
    antlr4::tree::TerminalNode *FLOB();
    antlr4::tree::TerminalNode *FLOOR();
    antlr4::tree::TerminalNode *FLUSH();
    antlr4::tree::TerminalNode *FOLDER();
    antlr4::tree::TerminalNode *FOLLOWING();
    antlr4::tree::TerminalNode *FOLLOWS();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *FORCE_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *FOREIGN();
    antlr4::tree::TerminalNode *FOREVER();
    antlr4::tree::TerminalNode *FORWARD();
    antlr4::tree::TerminalNode *FRAGMENT_NUMBER();
    antlr4::tree::TerminalNode *FREELIST();
    antlr4::tree::TerminalNode *FREELISTS();
    antlr4::tree::TerminalNode *FREEPOOLS();
    antlr4::tree::TerminalNode *FRESH();
    antlr4::tree::TerminalNode *FROM_TZ();
    antlr4::tree::TerminalNode *FULL();
    antlr4::tree::TerminalNode *FULL_OUTER_JOIN_TO_OUTER();
    antlr4::tree::TerminalNode *FUNCTION();
    antlr4::tree::TerminalNode *FUNCTIONS();
    antlr4::tree::TerminalNode *GATHER_PLAN_STATISTICS();
    antlr4::tree::TerminalNode *GBY_CONC_ROLLUP();
    antlr4::tree::TerminalNode *GBY_PUSHDOWN();
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *GLOBAL_NAME();
    antlr4::tree::TerminalNode *GLOBAL_TOPIC_ENABLED();
    antlr4::tree::TerminalNode *GREATEST();
    antlr4::tree::TerminalNode *GROUP_BY();
    antlr4::tree::TerminalNode *GROUP_ID();
    antlr4::tree::TerminalNode *GROUPING_ID();
    antlr4::tree::TerminalNode *GROUPING();
    antlr4::tree::TerminalNode *GROUPS();
    antlr4::tree::TerminalNode *GUARANTEED();
    antlr4::tree::TerminalNode *GUARANTEE();
    antlr4::tree::TerminalNode *GUARD();
    antlr4::tree::TerminalNode *HASH_AJ();
    antlr4::tree::TerminalNode *HASHKEYS();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *HASH_SJ();
    antlr4::tree::TerminalNode *HEADER();
    antlr4::tree::TerminalNode *HEAP();
    antlr4::tree::TerminalNode *HELP();
    antlr4::tree::TerminalNode *HEXTORAW();
    antlr4::tree::TerminalNode *HEXTOREF();
    antlr4::tree::TerminalNode *HIDDEN_KEYWORD();
    antlr4::tree::TerminalNode *HIDE();
    antlr4::tree::TerminalNode *HIERARCHY();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *HINTSET_BEGIN();
    antlr4::tree::TerminalNode *HINTSET_END();
    antlr4::tree::TerminalNode *HOT();
    antlr4::tree::TerminalNode *HOUR();
    antlr4::tree::TerminalNode *HWM_BROKERED();
    antlr4::tree::TerminalNode *HYBRID();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *IDENTITY();
    antlr4::tree::TerminalNode *IDGENERATORS();
    antlr4::tree::TerminalNode *IDLE_TIME();
    antlr4::tree::TerminalNode *ID();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *IGNORE();
    antlr4::tree::TerminalNode *IGNORE_OPTIM_EMBEDDED_HINTS();
    antlr4::tree::TerminalNode *IGNORE_ROW_ON_DUPKEY_INDEX();
    antlr4::tree::TerminalNode *IGNORE_WHERE_CLAUSE();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *IMPACT();
    antlr4::tree::TerminalNode *IMPORT();
    antlr4::tree::TerminalNode *INCLUDE();
    antlr4::tree::TerminalNode *INCLUDE_VERSION();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *INCREMENTAL();
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *INCR();
    antlr4::tree::TerminalNode *INDENT();
    antlr4::tree::TerminalNode *INDEX_ASC();
    antlr4::tree::TerminalNode *INDEX_COMBINE();
    antlr4::tree::TerminalNode *INDEX_DESC();
    antlr4::tree::TerminalNode *INDEXED();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *INDEX_FFS();
    antlr4::tree::TerminalNode *INDEX_FILTER();
    antlr4::tree::TerminalNode *INDEX_JOIN();
    antlr4::tree::TerminalNode *INDEX_ROWS();
    antlr4::tree::TerminalNode *INDEX_RRS();
    antlr4::tree::TerminalNode *INDEX_RS_ASC();
    antlr4::tree::TerminalNode *INDEX_RS_DESC();
    antlr4::tree::TerminalNode *INDEX_RS();
    antlr4::tree::TerminalNode *INDEX_SCAN();
    antlr4::tree::TerminalNode *INDEX_SKIP_SCAN();
    antlr4::tree::TerminalNode *INDEX_SS_ASC();
    antlr4::tree::TerminalNode *INDEX_SS_DESC();
    antlr4::tree::TerminalNode *INDEX_SS();
    antlr4::tree::TerminalNode *INDEX_STATS();
    antlr4::tree::TerminalNode *INDEXTYPE();
    antlr4::tree::TerminalNode *INDEXTYPES();
    antlr4::tree::TerminalNode *INDICATOR();
    antlr4::tree::TerminalNode *INFINITE();
    antlr4::tree::TerminalNode *INFORMATIONAL();
    antlr4::tree::TerminalNode *INITCAP();
    antlr4::tree::TerminalNode *INITIALIZED();
    antlr4::tree::TerminalNode *INITIALLY();
    antlr4::tree::TerminalNode *INITIAL();
    antlr4::tree::TerminalNode *INITRANS();
    antlr4::tree::TerminalNode *INLINE();
    antlr4::tree::TerminalNode *INLINE_XMLTYPE_NT();
    antlr4::tree::TerminalNode *IN_MEMORY_METADATA();
    antlr4::tree::TerminalNode *INNER();
    antlr4::tree::TerminalNode *INSERTCHILDXMLAFTER();
    antlr4::tree::TerminalNode *INSERTCHILDXMLBEFORE();
    antlr4::tree::TerminalNode *INSERTCHILDXML();
    antlr4::tree::TerminalNode *INSERTXMLAFTER();
    antlr4::tree::TerminalNode *INSERTXMLBEFORE();
    antlr4::tree::TerminalNode *INSTANCE();
    antlr4::tree::TerminalNode *INSTANCES();
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *INSTANTLY();
    antlr4::tree::TerminalNode *INSTEAD();
    antlr4::tree::TerminalNode *INSTR2();
    antlr4::tree::TerminalNode *INSTR4();
    antlr4::tree::TerminalNode *INSTRB();
    antlr4::tree::TerminalNode *INSTRC();
    antlr4::tree::TerminalNode *INSTR();
    antlr4::tree::TerminalNode *INTERMEDIATE();
    antlr4::tree::TerminalNode *INTERNAL_CONVERT();
    antlr4::tree::TerminalNode *INTERNAL_USE();
    antlr4::tree::TerminalNode *INTERPRETED();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *INT();
    antlr4::tree::TerminalNode *INVALIDATE();
    antlr4::tree::TerminalNode *INVISIBLE();
    antlr4::tree::TerminalNode *IN_XQUERY();
    antlr4::tree::TerminalNode *ISOLATION_LEVEL();
    antlr4::tree::TerminalNode *ISOLATION();
    antlr4::tree::TerminalNode *ITERATE();
    antlr4::tree::TerminalNode *ITERATION_NUMBER();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *JOB();
    antlr4::tree::TerminalNode *JOIN();
    antlr4::tree::TerminalNode *KEEP_DUPLICATES();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *KERBEROS();
    antlr4::tree::TerminalNode *KEY_LENGTH();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *KEYSIZE();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *KILL();
    antlr4::tree::TerminalNode *LAG();
    antlr4::tree::TerminalNode *LAST_DAY();
    antlr4::tree::TerminalNode *LAST();
    antlr4::tree::TerminalNode *LAST_VALUE();
    antlr4::tree::TerminalNode *LATERAL();
    antlr4::tree::TerminalNode *LAYER();
    antlr4::tree::TerminalNode *LDAP_REGISTRATION_ENABLED();
    antlr4::tree::TerminalNode *LDAP_REGISTRATION();
    antlr4::tree::TerminalNode *LDAP_REG_SYNC_INTERVAL();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *LEAD();
    antlr4::tree::TerminalNode *LEAST();
    antlr4::tree::TerminalNode *LEFT();
    antlr4::tree::TerminalNode *LENGTH2();
    antlr4::tree::TerminalNode *LENGTH4();
    antlr4::tree::TerminalNode *LENGTHB();
    antlr4::tree::TerminalNode *LENGTHC();
    antlr4::tree::TerminalNode *LENGTH();
    antlr4::tree::TerminalNode *LESS();
    antlr4::tree::TerminalNode *LEVEL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *LIBRARY();
    antlr4::tree::TerminalNode *LIFE();
    antlr4::tree::TerminalNode *LIFETIME();
    antlr4::tree::TerminalNode *LIKE2();
    antlr4::tree::TerminalNode *LIKE4();
    antlr4::tree::TerminalNode *LIKEC();
    antlr4::tree::TerminalNode *LIKE_EXPAND();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *LINK();
    antlr4::tree::TerminalNode *LISTAGG();
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *LN();
    antlr4::tree::TerminalNode *LNNVL();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *LOB();
    antlr4::tree::TerminalNode *LOBNVL();
    antlr4::tree::TerminalNode *LOBS();
    antlr4::tree::TerminalNode *LOCAL_INDEXES();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *LOCALTIME();
    antlr4::tree::TerminalNode *LOCALTIMESTAMP();
    antlr4::tree::TerminalNode *LOCATION();
    antlr4::tree::TerminalNode *LOCATOR();
    antlr4::tree::TerminalNode *LOCKED();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *LOGFILES();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_CALL();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_SESSION();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *LOGOFF();
    antlr4::tree::TerminalNode *LOGON();
    antlr4::tree::TerminalNode *LOG_READ_ONLY_VIOLATIONS();
    antlr4::tree::TerminalNode *LOWER();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *LPAD();
    antlr4::tree::TerminalNode *LTRIM();
    antlr4::tree::TerminalNode *MAIN();
    antlr4::tree::TerminalNode *MAKE_REF();
    antlr4::tree::TerminalNode *MANAGED();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *MANAGE();
    antlr4::tree::TerminalNode *MANAGER();
    antlr4::tree::TerminalNode *MANUAL();
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *MASTER();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *MATERIALIZE();
    antlr4::tree::TerminalNode *MAXARCHLOGS();
    antlr4::tree::TerminalNode *MAXDATAFILES();
    antlr4::tree::TerminalNode *MAXEXTENTS();
    antlr4::tree::TerminalNode *MAXIMIZE();
    antlr4::tree::TerminalNode *MAXINSTANCES();
    antlr4::tree::TerminalNode *MAXLOGFILES();
    antlr4::tree::TerminalNode *MAXLOGHISTORY();
    antlr4::tree::TerminalNode *MAXLOGMEMBERS();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MAXSIZE();
    antlr4::tree::TerminalNode *MAXTRANS();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *MEASURES();
    antlr4::tree::TerminalNode *MEDIAN();
    antlr4::tree::TerminalNode *MEDIUM();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *MEMORY();
    antlr4::tree::TerminalNode *MERGEACTIONS();
    antlr4::tree::TerminalNode *MERGE_AJ();
    antlr4::tree::TerminalNode *MERGE_CONST_ON();
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *MERGE_SJ();
    antlr4::tree::TerminalNode *METHOD();
    antlr4::tree::TerminalNode *MIGRATE();
    antlr4::tree::TerminalNode *MIGRATION();
    antlr4::tree::TerminalNode *MINEXTENTS();
    antlr4::tree::TerminalNode *MINIMIZE();
    antlr4::tree::TerminalNode *MINIMUM();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *MINUS_NULL();
    antlr4::tree::TerminalNode *MINUTE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *MIRRORCOLD();
    antlr4::tree::TerminalNode *MIRRORHOT();
    antlr4::tree::TerminalNode *MIRROR();
    antlr4::tree::TerminalNode *MLSLABEL();
    antlr4::tree::TerminalNode *MODEL_COMPILE_SUBQUERY();
    antlr4::tree::TerminalNode *MODEL_DONTVERIFY_UNIQUENESS();
    antlr4::tree::TerminalNode *MODEL_DYNAMIC_SUBQUERY();
    antlr4::tree::TerminalNode *MODEL_MIN_ANALYSIS();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *MODEL_NO_ANALYSIS();
    antlr4::tree::TerminalNode *MODEL_PBY();
    antlr4::tree::TerminalNode *MODEL_PUSH_REF();
    antlr4::tree::TerminalNode *MODIFY_COLUMN_TYPE();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *MOD();
    antlr4::tree::TerminalNode *MONITORING();
    antlr4::tree::TerminalNode *MONITOR();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *MONTHS_BETWEEN();
    antlr4::tree::TerminalNode *MOUNT();
    antlr4::tree::TerminalNode *MOUNTPATH();
    antlr4::tree::TerminalNode *MOVEMENT();
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *MULTISET();
    antlr4::tree::TerminalNode *MV_MERGE();
    antlr4::tree::TerminalNode *NAMED();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *NAMESPACE();
    antlr4::tree::TerminalNode *NAN();
    antlr4::tree::TerminalNode *NANVL();
    antlr4::tree::TerminalNode *NATIONAL();
    antlr4::tree::TerminalNode *NATIVE_FULL_OUTER_JOIN();
    antlr4::tree::TerminalNode *NATIVE();
    antlr4::tree::TerminalNode *NATURAL();
    antlr4::tree::TerminalNode *NAV();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *NCHAR();
    antlr4::tree::TerminalNode *NCHR();
    antlr4::tree::TerminalNode *NCLOB();
    antlr4::tree::TerminalNode *NEEDED();
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *NESTED_TABLE_FAST_INSERT();
    antlr4::tree::TerminalNode *NESTED_TABLE_GET_REFS();
    antlr4::tree::TerminalNode *NESTED_TABLE_ID();
    antlr4::tree::TerminalNode *NESTED_TABLE_SET_REFS();
    antlr4::tree::TerminalNode *NESTED_TABLE_SET_SETID();
    antlr4::tree::TerminalNode *NETWORK();
    antlr4::tree::TerminalNode *NEVER();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *NEW_TIME();
    antlr4::tree::TerminalNode *NEXT_DAY();
    antlr4::tree::TerminalNode *NEXT();
    antlr4::tree::TerminalNode *NL_AJ();
    antlr4::tree::TerminalNode *NLJ_BATCHING();
    antlr4::tree::TerminalNode *NLJ_INDEX_FILTER();
    antlr4::tree::TerminalNode *NLJ_INDEX_SCAN();
    antlr4::tree::TerminalNode *NLJ_PREFETCH();
    antlr4::tree::TerminalNode *NLS_CALENDAR();
    antlr4::tree::TerminalNode *NLS_CHARACTERSET();
    antlr4::tree::TerminalNode *NLS_CHARSET_DECL_LEN();
    antlr4::tree::TerminalNode *NLS_CHARSET_ID();
    antlr4::tree::TerminalNode *NLS_CHARSET_NAME();
    antlr4::tree::TerminalNode *NLS_COMP();
    antlr4::tree::TerminalNode *NLS_CURRENCY();
    antlr4::tree::TerminalNode *NLS_DATE_FORMAT();
    antlr4::tree::TerminalNode *NLS_DATE_LANGUAGE();
    antlr4::tree::TerminalNode *NLS_INITCAP();
    antlr4::tree::TerminalNode *NLS_ISO_CURRENCY();
    antlr4::tree::TerminalNode *NL_SJ();
    antlr4::tree::TerminalNode *NLS_LANG();
    antlr4::tree::TerminalNode *NLS_LANGUAGE();
    antlr4::tree::TerminalNode *NLS_LENGTH_SEMANTICS();
    antlr4::tree::TerminalNode *NLS_LOWER();
    antlr4::tree::TerminalNode *NLS_NCHAR_CONV_EXCP();
    antlr4::tree::TerminalNode *NLS_NUMERIC_CHARACTERS();
    antlr4::tree::TerminalNode *NLS_SORT();
    antlr4::tree::TerminalNode *NLSSORT();
    antlr4::tree::TerminalNode *NLS_SPECIAL_CHARS();
    antlr4::tree::TerminalNode *NLS_TERRITORY();
    antlr4::tree::TerminalNode *NLS_UPPER();
    antlr4::tree::TerminalNode *NO_ACCESS();
    antlr4::tree::TerminalNode *NOAPPEND();
    antlr4::tree::TerminalNode *NOARCHIVELOG();
    antlr4::tree::TerminalNode *NOAUDIT();
    antlr4::tree::TerminalNode *NO_BASETABLE_MULTIMV_REWRITE();
    antlr4::tree::TerminalNode *NO_BIND_AWARE();
    antlr4::tree::TerminalNode *NO_BUFFER();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *NO_CARTESIAN();
    antlr4::tree::TerminalNode *NO_CHECK_ACL_REWRITE();
    antlr4::tree::TerminalNode *NO_CLUSTER_BY_ROWID();
    antlr4::tree::TerminalNode *NO_COALESCE_SQ();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_CB_WHR_ONLY();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_COMBINE_SW();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_COST_BASED();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_ELIM_DUPS();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_FILTERING();
    antlr4::tree::TerminalNode *NO_COST_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *NO_CPU_COSTING();
    antlr4::tree::TerminalNode *NOCPU_COSTING();
    antlr4::tree::TerminalNode *NOCYCLE();
    antlr4::tree::TerminalNode *NODELAY();
    antlr4::tree::TerminalNode *NO_DOMAIN_INDEX_FILTER();
    antlr4::tree::TerminalNode *NO_DST_UPGRADE_INSERT_CONV();
    antlr4::tree::TerminalNode *NO_ELIMINATE_JOIN();
    antlr4::tree::TerminalNode *NO_ELIMINATE_OBY();
    antlr4::tree::TerminalNode *NO_ELIMINATE_OUTER_JOIN();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *NO_EXPAND_GSET_TO_UNION();
    antlr4::tree::TerminalNode *NO_EXPAND();
    antlr4::tree::TerminalNode *NO_EXPAND_TABLE();
    antlr4::tree::TerminalNode *NO_FACT();
    antlr4::tree::TerminalNode *NO_FACTORIZE_JOIN();
    antlr4::tree::TerminalNode *NO_FILTERING();
    antlr4::tree::TerminalNode *NOFORCE();
    antlr4::tree::TerminalNode *NO_FULL_OUTER_JOIN_TO_OUTER();
    antlr4::tree::TerminalNode *NO_GBY_PUSHDOWN();
    antlr4::tree::TerminalNode *NOGUARANTEE();
    antlr4::tree::TerminalNode *NO_INDEX_FFS();
    antlr4::tree::TerminalNode *NO_INDEX();
    antlr4::tree::TerminalNode *NO_INDEX_SS();
    antlr4::tree::TerminalNode *NO_LOAD();
    antlr4::tree::TerminalNode *NOLOCAL();
    antlr4::tree::TerminalNode *NOLOGGING();
    antlr4::tree::TerminalNode *NOMAPPING();
    antlr4::tree::TerminalNode *NOMAXVALUE();
    antlr4::tree::TerminalNode *NO_MERGE();
    antlr4::tree::TerminalNode *NOMINIMIZE();
    antlr4::tree::TerminalNode *NOMINVALUE();
    antlr4::tree::TerminalNode *NO_MODEL_PUSH_REF();
    antlr4::tree::TerminalNode *NO_MONITORING();
    antlr4::tree::TerminalNode *NOMONITORING();
    antlr4::tree::TerminalNode *NO_MONITOR();
    antlr4::tree::TerminalNode *NO_MULTIMV_REWRITE();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *NO_NATIVE_FULL_OUTER_JOIN();
    antlr4::tree::TerminalNode *NONBLOCKING();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *NO_NLJ_BATCHING();
    antlr4::tree::TerminalNode *NO_NLJ_PREFETCH();
    antlr4::tree::TerminalNode *NONSCHEMA();
    antlr4::tree::TerminalNode *NOORDER();
    antlr4::tree::TerminalNode *NO_ORDER_ROLLUPS();
    antlr4::tree::TerminalNode *NO_OUTER_JOIN_TO_ANTI();
    antlr4::tree::TerminalNode *NO_OUTER_JOIN_TO_INNER();
    antlr4::tree::TerminalNode *NOOVERRIDE();
    antlr4::tree::TerminalNode *NO_PARALLEL_INDEX();
    antlr4::tree::TerminalNode *NOPARALLEL_INDEX();
    antlr4::tree::TerminalNode *NO_PARALLEL();
    antlr4::tree::TerminalNode *NOPARALLEL();
    antlr4::tree::TerminalNode *NO_PARTIAL_COMMIT();
    antlr4::tree::TerminalNode *NO_PLACE_DISTINCT();
    antlr4::tree::TerminalNode *NO_PLACE_GROUP_BY();
    antlr4::tree::TerminalNode *NO_PQ_MAP();
    antlr4::tree::TerminalNode *NO_PRUNE_GSETS();
    antlr4::tree::TerminalNode *NO_PULL_PRED();
    antlr4::tree::TerminalNode *NO_PUSH_PRED();
    antlr4::tree::TerminalNode *NO_PUSH_SUBQ();
    antlr4::tree::TerminalNode *NO_PX_JOIN_FILTER();
    antlr4::tree::TerminalNode *NO_QKN_BUFF();
    antlr4::tree::TerminalNode *NO_QUERY_TRANSFORMATION();
    antlr4::tree::TerminalNode *NO_REF_CASCADE();
    antlr4::tree::TerminalNode *NORELY();
    antlr4::tree::TerminalNode *NOREPAIR();
    antlr4::tree::TerminalNode *NORESETLOGS();
    antlr4::tree::TerminalNode *NO_RESULT_CACHE();
    antlr4::tree::TerminalNode *NOREVERSE();
    antlr4::tree::TerminalNode *NO_REWRITE();
    antlr4::tree::TerminalNode *NOREWRITE();
    antlr4::tree::TerminalNode *NORMAL();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOSCHEMACHECK();
    antlr4::tree::TerminalNode *NOSEGMENT();
    antlr4::tree::TerminalNode *NO_SEMIJOIN();
    antlr4::tree::TerminalNode *NO_SEMI_TO_INNER();
    antlr4::tree::TerminalNode *NO_SET_TO_JOIN();
    antlr4::tree::TerminalNode *NOSORT();
    antlr4::tree::TerminalNode *NO_SQL_TUNE();
    antlr4::tree::TerminalNode *NO_STAR_TRANSFORMATION();
    antlr4::tree::TerminalNode *NO_STATEMENT_QUEUING();
    antlr4::tree::TerminalNode *NO_STATS_GSETS();
    antlr4::tree::TerminalNode *NOSTRICT();
    antlr4::tree::TerminalNode *NO_SUBQUERY_PRUNING();
    antlr4::tree::TerminalNode *NO_SUBSTRB_PAD();
    antlr4::tree::TerminalNode *NO_SWAP_JOIN_INPUTS();
    antlr4::tree::TerminalNode *NOSWITCH();
    antlr4::tree::TerminalNode *NO_TABLE_LOOKUP_BY_NL();
    antlr4::tree::TerminalNode *NO_TEMP_TABLE();
    antlr4::tree::TerminalNode *NOTHING();
    antlr4::tree::TerminalNode *NOTIFICATION();
    antlr4::tree::TerminalNode *NO_TRANSFORM_DISTINCT_AGG();
    antlr4::tree::TerminalNode *NO_UNNEST();
    antlr4::tree::TerminalNode *NO_USE_HASH_AGGREGATION();
    antlr4::tree::TerminalNode *NO_USE_HASH_GBY_FOR_PUSHDOWN();
    antlr4::tree::TerminalNode *NO_USE_HASH();
    antlr4::tree::TerminalNode *NO_USE_INVISIBLE_INDEXES();
    antlr4::tree::TerminalNode *NO_USE_MERGE();
    antlr4::tree::TerminalNode *NO_USE_NL();
    antlr4::tree::TerminalNode *NOVALIDATE();
    antlr4::tree::TerminalNode *NO_XDB_FASTPATH_INSERT();
    antlr4::tree::TerminalNode *NO_XML_DML_REWRITE();
    antlr4::tree::TerminalNode *NO_XMLINDEX_REWRITE_IN_SELECT();
    antlr4::tree::TerminalNode *NO_XMLINDEX_REWRITE();
    antlr4::tree::TerminalNode *NO_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *NTH_VALUE();
    antlr4::tree::TerminalNode *NTILE();
    antlr4::tree::TerminalNode *NULLIF();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *NUMERIC();
    antlr4::tree::TerminalNode *NUM_INDEX_KEYS();
    antlr4::tree::TerminalNode *NUMTODSINTERVAL();
    antlr4::tree::TerminalNode *NUMTOYMINTERVAL();
    antlr4::tree::TerminalNode *NVARCHAR2();
    antlr4::tree::TerminalNode *NVL2();
    antlr4::tree::TerminalNode *NVL();
    antlr4::tree::TerminalNode *OBJECT2XML();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *OBJNO();
    antlr4::tree::TerminalNode *OBJNO_REUSE();
    antlr4::tree::TerminalNode *OCCURENCES();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *OFF();
    antlr4::tree::TerminalNode *OIDINDEX();
    antlr4::tree::TerminalNode *OID();
    antlr4::tree::TerminalNode *OLAP();
    antlr4::tree::TerminalNode *OLD();
    antlr4::tree::TerminalNode *OLD_PUSH_PRED();
    antlr4::tree::TerminalNode *OLTP();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *OPAQUE();
    antlr4::tree::TerminalNode *OPAQUE_TRANSFORM();
    antlr4::tree::TerminalNode *OPAQUE_XCANONICAL();
    antlr4::tree::TerminalNode *OPCODE();
    antlr4::tree::TerminalNode *OPEN();
    antlr4::tree::TerminalNode *OPERATIONS();
    antlr4::tree::TerminalNode *OPERATOR();
    antlr4::tree::TerminalNode *OPT_ESTIMATE();
    antlr4::tree::TerminalNode *OPTIMAL();
    antlr4::tree::TerminalNode *OPTIMIZE();
    antlr4::tree::TerminalNode *OPTIMIZER_FEATURES_ENABLE();
    antlr4::tree::TerminalNode *OPTIMIZER_GOAL();
    antlr4::tree::TerminalNode *OPT_PARAM();
    antlr4::tree::TerminalNode *ORA_BRANCH();
    antlr4::tree::TerminalNode *ORADEBUG();
    antlr4::tree::TerminalNode *ORA_DST_AFFECTED();
    antlr4::tree::TerminalNode *ORA_DST_CONVERT();
    antlr4::tree::TerminalNode *ORA_DST_ERROR();
    antlr4::tree::TerminalNode *ORA_GET_ACLIDS();
    antlr4::tree::TerminalNode *ORA_GET_PRIVILEGES();
    antlr4::tree::TerminalNode *ORA_HASH();
    antlr4::tree::TerminalNode *ORA_ROWSCN();
    antlr4::tree::TerminalNode *ORA_ROWSCN_RAW();
    antlr4::tree::TerminalNode *ORA_ROWVERSION();
    antlr4::tree::TerminalNode *ORA_TABVERSION();
    antlr4::tree::TerminalNode *ORDERED();
    antlr4::tree::TerminalNode *ORDERED_PREDICATES();
    antlr4::tree::TerminalNode *ORDINALITY();
    antlr4::tree::TerminalNode *OR_EXPAND();
    antlr4::tree::TerminalNode *ORGANIZATION();
    antlr4::tree::TerminalNode *OR_PREDICATES();
    antlr4::tree::TerminalNode *OTHER();
    antlr4::tree::TerminalNode *OUTER_JOIN_TO_ANTI();
    antlr4::tree::TerminalNode *OUTER_JOIN_TO_INNER();
    antlr4::tree::TerminalNode *OUTER();
    antlr4::tree::TerminalNode *OUTLINE_LEAF();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *OUT_OF_LINE();
    antlr4::tree::TerminalNode *OVERFLOW();
    antlr4::tree::TerminalNode *OVERFLOW_NOMOVE();
    antlr4::tree::TerminalNode *OVERLAPS();
    antlr4::tree::TerminalNode *OVER();
    antlr4::tree::TerminalNode *OWNER();
    antlr4::tree::TerminalNode *OWNERSHIP();
    antlr4::tree::TerminalNode *OWN();
    antlr4::tree::TerminalNode *PACKAGE();
    antlr4::tree::TerminalNode *PACKAGES();
    antlr4::tree::TerminalNode *PARALLEL_INDEX();
    antlr4::tree::TerminalNode *PARALLEL();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *PARAM();
    antlr4::tree::TerminalNode *PARENT();
    antlr4::tree::TerminalNode *PARITY();
    antlr4::tree::TerminalNode *PARTIALLY();
    antlr4::tree::TerminalNode *PARTITION_HASH();
    antlr4::tree::TerminalNode *PARTITION_LIST();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *PARTITION_RANGE();
    antlr4::tree::TerminalNode *PARTITIONS();
    antlr4::tree::TerminalNode *PARTNUMINST();
    antlr4::tree::TerminalNode *PASSING();
    antlr4::tree::TerminalNode *PASSWORD_GRACE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_LIFE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_LOCK_TIME();
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_MAX();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_VERIFY_FUNCTION();
    antlr4::tree::TerminalNode *PATH();
    antlr4::tree::TerminalNode *PATHS();
    antlr4::tree::TerminalNode *PBL_HS_BEGIN();
    antlr4::tree::TerminalNode *PBL_HS_END();
    antlr4::tree::TerminalNode *PCTINCREASE();
    antlr4::tree::TerminalNode *PCTTHRESHOLD();
    antlr4::tree::TerminalNode *PCTUSED();
    antlr4::tree::TerminalNode *PCTVERSION();
    antlr4::tree::TerminalNode *PENDING();
    antlr4::tree::TerminalNode *PERCENTILE_CONT();
    antlr4::tree::TerminalNode *PERCENTILE_DISC();
    antlr4::tree::TerminalNode *PERCENT_KEYWORD();
    antlr4::tree::TerminalNode *PERCENT_RANKM();
    antlr4::tree::TerminalNode *PERCENT_RANK();
    antlr4::tree::TerminalNode *PERFORMANCE();
    antlr4::tree::TerminalNode *PERMANENT();
    antlr4::tree::TerminalNode *PERMISSION();
    antlr4::tree::TerminalNode *PFILE();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *PIKEY();
    antlr4::tree::TerminalNode *PIV_GB();
    antlr4::tree::TerminalNode *PIVOT();
    antlr4::tree::TerminalNode *PIV_SSF();
    antlr4::tree::TerminalNode *PLACE_DISTINCT();
    antlr4::tree::TerminalNode *PLACE_GROUP_BY();
    antlr4::tree::TerminalNode *PLAN();
    antlr4::tree::TerminalNode *PLSCOPE_SETTINGS();
    antlr4::tree::TerminalNode *PLSQL_CCFLAGS();
    antlr4::tree::TerminalNode *PLSQL_CODE_TYPE();
    antlr4::tree::TerminalNode *PLSQL_DEBUG();
    antlr4::tree::TerminalNode *PLSQL_OPTIMIZE_LEVEL();
    antlr4::tree::TerminalNode *PLSQL_WARNINGS();
    antlr4::tree::TerminalNode *POINT();
    antlr4::tree::TerminalNode *POLICY();
    antlr4::tree::TerminalNode *POST_TRANSACTION();
    antlr4::tree::TerminalNode *POWERMULTISET_BY_CARDINALITY();
    antlr4::tree::TerminalNode *POWERMULTISET();
    antlr4::tree::TerminalNode *POWER();
    antlr4::tree::TerminalNode *PQ_DISTRIBUTE();
    antlr4::tree::TerminalNode *PQ_MAP();
    antlr4::tree::TerminalNode *PQ_NOMAP();
    antlr4::tree::TerminalNode *PREBUILT();
    antlr4::tree::TerminalNode *PRECEDES();
    antlr4::tree::TerminalNode *PRECEDING();
    antlr4::tree::TerminalNode *PRECISION();
    antlr4::tree::TerminalNode *PRECOMPUTE_SUBQUERY();
    antlr4::tree::TerminalNode *PREDICATE_REORDERS();
    antlr4::tree::TerminalNode *PREDICTION_BOUNDS();
    antlr4::tree::TerminalNode *PREDICTION_COST();
    antlr4::tree::TerminalNode *PREDICTION_DETAILS();
    antlr4::tree::TerminalNode *PREDICTION();
    antlr4::tree::TerminalNode *PREDICTION_PROBABILITY();
    antlr4::tree::TerminalNode *PREDICTION_SET();
    antlr4::tree::TerminalNode *PREPARE();
    antlr4::tree::TerminalNode *PRESENT();
    antlr4::tree::TerminalNode *PRESENTNNV();
    antlr4::tree::TerminalNode *PRESENTV();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *PRESERVE_OID();
    antlr4::tree::TerminalNode *PREVIOUS();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *PRIVATE();
    antlr4::tree::TerminalNode *PRIVATE_SGA();
    antlr4::tree::TerminalNode *PRIVILEGE();
    antlr4::tree::TerminalNode *PRIVILEGES();
    antlr4::tree::TerminalNode *PROCEDURAL();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *PROCESS();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *PROGRAM();
    antlr4::tree::TerminalNode *PROJECT();
    antlr4::tree::TerminalNode *PROPAGATE();
    antlr4::tree::TerminalNode *PROTECTED();
    antlr4::tree::TerminalNode *PROTECTION();
    antlr4::tree::TerminalNode *PULL_PRED();
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *PUSH_PRED();
    antlr4::tree::TerminalNode *PUSH_SUBQ();
    antlr4::tree::TerminalNode *PX_GRANULE();
    antlr4::tree::TerminalNode *PX_JOIN_FILTER();
    antlr4::tree::TerminalNode *QB_NAME();
    antlr4::tree::TerminalNode *QUERY_BLOCK();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *QUEUE_CURR();
    antlr4::tree::TerminalNode *QUEUE();
    antlr4::tree::TerminalNode *QUEUE_ROWP();
    antlr4::tree::TerminalNode *QUIESCE();
    antlr4::tree::TerminalNode *QUORUM();
    antlr4::tree::TerminalNode *QUOTA();
    antlr4::tree::TerminalNode *RANDOM_LOCAL();
    antlr4::tree::TerminalNode *RANDOM();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *RANKM();
    antlr4::tree::TerminalNode *RANK();
    antlr4::tree::TerminalNode *RAPIDLY();
    antlr4::tree::TerminalNode *RATIO_TO_REPORT();
    antlr4::tree::TerminalNode *RAWTOHEX();
    antlr4::tree::TerminalNode *RAWTONHEX();
    antlr4::tree::TerminalNode *RBA();
    antlr4::tree::TerminalNode *RBO_OUTLINE();
    antlr4::tree::TerminalNode *RDBA();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *READS();
    antlr4::tree::TerminalNode *REAL();
    antlr4::tree::TerminalNode *REBALANCE();
    antlr4::tree::TerminalNode *REBUILD();
    antlr4::tree::TerminalNode *RECORDS_PER_BLOCK();
    antlr4::tree::TerminalNode *RECOVERABLE();
    antlr4::tree::TerminalNode *RECOVER();
    antlr4::tree::TerminalNode *RECOVERY();
    antlr4::tree::TerminalNode *RECYCLEBIN();
    antlr4::tree::TerminalNode *RECYCLE();
    antlr4::tree::TerminalNode *REDACTION();
    antlr4::tree::TerminalNode *REDO();
    antlr4::tree::TerminalNode *REDUCED();
    antlr4::tree::TerminalNode *REDUNDANCY();
    antlr4::tree::TerminalNode *REF_CASCADE_CURSOR();
    antlr4::tree::TerminalNode *REFERENCED();
    antlr4::tree::TerminalNode *REFERENCE();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *REFERENCING();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *REFTOHEX();
    antlr4::tree::TerminalNode *REGEXP_COUNT();
    antlr4::tree::TerminalNode *REGEXP_INSTR();
    antlr4::tree::TerminalNode *REGEXP_LIKE();
    antlr4::tree::TerminalNode *REGEXP_REPLACE();
    antlr4::tree::TerminalNode *REGEXP_SUBSTR();
    antlr4::tree::TerminalNode *REGISTER();
    antlr4::tree::TerminalNode *REGR_AVGX();
    antlr4::tree::TerminalNode *REGR_AVGY();
    antlr4::tree::TerminalNode *REGR_COUNT();
    antlr4::tree::TerminalNode *REGR_INTERCEPT();
    antlr4::tree::TerminalNode *REGR_R2();
    antlr4::tree::TerminalNode *REGR_SLOPE();
    antlr4::tree::TerminalNode *REGR_SXX();
    antlr4::tree::TerminalNode *REGR_SXY();
    antlr4::tree::TerminalNode *REGR_SYY();
    antlr4::tree::TerminalNode *REGULAR();
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *REKEY();
    antlr4::tree::TerminalNode *RELATIONAL();
    antlr4::tree::TerminalNode *RELY();
    antlr4::tree::TerminalNode *REMAINDER();
    antlr4::tree::TerminalNode *REMOTE_MAPPED();
    antlr4::tree::TerminalNode *REMOVE();
    antlr4::tree::TerminalNode *REPAIR();
    antlr4::tree::TerminalNode *REPEAT();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *REPLICATION();
    antlr4::tree::TerminalNode *REQUIRED();
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *RESET();
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *RESOLVE();
    antlr4::tree::TerminalNode *RESOLVER();
    antlr4::tree::TerminalNode *RESPECT();
    antlr4::tree::TerminalNode *RESTORE_AS_INTERVALS();
    antlr4::tree::TerminalNode *RESTORE();
    antlr4::tree::TerminalNode *RESTRICT_ALL_REF_CONS();
    antlr4::tree::TerminalNode *RESTRICTED();
    antlr4::tree::TerminalNode *RESTRICT();
    antlr4::tree::TerminalNode *RESULT_CACHE();
    antlr4::tree::TerminalNode *RESUMABLE();
    antlr4::tree::TerminalNode *RESUME();
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *RETRY_ON_ROW_CHANGE();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *REVERSE();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *REWRITE_OR_ERROR();
    antlr4::tree::TerminalNode *RIGHT();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *ROLES();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *ROLLING();
    antlr4::tree::TerminalNode *ROLLUP();
    antlr4::tree::TerminalNode *ROUND();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *ROWIDTOCHAR();
    antlr4::tree::TerminalNode *ROWIDTONCHAR();
    antlr4::tree::TerminalNode *ROW_LENGTH();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROW_NUMBER();
    antlr4::tree::TerminalNode *ROWNUM();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *RPAD();
    antlr4::tree::TerminalNode *RTRIM();
    antlr4::tree::TerminalNode *RULE();
    antlr4::tree::TerminalNode *RULES();
    antlr4::tree::TerminalNode *SALT();
    antlr4::tree::TerminalNode *SAMPLE();
    antlr4::tree::TerminalNode *SAVE_AS_INTERVALS();
    antlr4::tree::TerminalNode *SAVEPOINT();
    antlr4::tree::TerminalNode *SB4();
    antlr4::tree::TerminalNode *SCALE();
    antlr4::tree::TerminalNode *SCALE_ROWS();
    antlr4::tree::TerminalNode *SCAN_INSTANCES();
    antlr4::tree::TerminalNode *SCAN();
    antlr4::tree::TerminalNode *SCHEDULER();
    antlr4::tree::TerminalNode *SCHEMACHECK();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *SCN_ASCENDING();
    antlr4::tree::TerminalNode *SCN();
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *SD_ALL();
    antlr4::tree::TerminalNode *SD_INHIBIT();
    antlr4::tree::TerminalNode *SD_SHOW();
    antlr4::tree::TerminalNode *SEARCH();
    antlr4::tree::TerminalNode *SECOND();
    antlr4::tree::TerminalNode *SECUREFILE_DBA();
    antlr4::tree::TerminalNode *SECUREFILE();
    antlr4::tree::TerminalNode *SECURITY();
    antlr4::tree::TerminalNode *SEED();
    antlr4::tree::TerminalNode *SEG_BLOCK();
    antlr4::tree::TerminalNode *SEG_FILE();
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SELECTIVITY();
    antlr4::tree::TerminalNode *SEMIJOIN_DRIVER();
    antlr4::tree::TerminalNode *SEMIJOIN();
    antlr4::tree::TerminalNode *SEMI_TO_INNER();
    antlr4::tree::TerminalNode *SEQUENCED();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *SEQUENTIAL();
    antlr4::tree::TerminalNode *SERIALIZABLE();
    antlr4::tree::TerminalNode *SERVERERROR();
    antlr4::tree::TerminalNode *SESSION_CACHED_CURSORS();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *SESSIONS_PER_USER();
    antlr4::tree::TerminalNode *SESSIONTIMEZONE();
    antlr4::tree::TerminalNode *SESSIONTZNAME();
    antlr4::tree::TerminalNode *SETS();
    antlr4::tree::TerminalNode *SETTINGS();
    antlr4::tree::TerminalNode *SET_TO_JOIN();
    antlr4::tree::TerminalNode *SEVERE();
    antlr4::tree::TerminalNode *SHARED();
    antlr4::tree::TerminalNode *SHARED_POOL();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SHUTDOWN();
    antlr4::tree::TerminalNode *SIBLINGS();
    antlr4::tree::TerminalNode *SID();
    antlr4::tree::TerminalNode *SIGNAL_COMPONENT();
    antlr4::tree::TerminalNode *SIGNAL_FUNCTION();
    antlr4::tree::TerminalNode *SIGN();
    antlr4::tree::TerminalNode *SIMPLE();
    antlr4::tree::TerminalNode *SINGLE();
    antlr4::tree::TerminalNode *SINGLETASK();
    antlr4::tree::TerminalNode *SINH();
    antlr4::tree::TerminalNode *SIN();
    antlr4::tree::TerminalNode *SKIP_EXT_OPTIMIZER();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *SKIP_UNQ_UNUSABLE_IDX();
    antlr4::tree::TerminalNode *SKIP_UNUSABLE_INDEXES();
    antlr4::tree::TerminalNode *SMALLFILE();
    antlr4::tree::TerminalNode *SNAPSHOT();
    antlr4::tree::TerminalNode *SOME();
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *SOUNDEX();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *SPECIFICATION();
    antlr4::tree::TerminalNode *SPFILE();
    antlr4::tree::TerminalNode *SPLIT();
    antlr4::tree::TerminalNode *SPREADSHEET();
    antlr4::tree::TerminalNode *SQLLDR();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *SQL_TRACE();
    antlr4::tree::TerminalNode *SQRT();
    antlr4::tree::TerminalNode *STALE();
    antlr4::tree::TerminalNode *STANDALONE();
    antlr4::tree::TerminalNode *STANDBY_MAX_DATA_DELAY();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *STAR();
    antlr4::tree::TerminalNode *STAR_TRANSFORMATION();
    antlr4::tree::TerminalNode *STARTUP();
    antlr4::tree::TerminalNode *STATEMENT_ID();
    antlr4::tree::TerminalNode *STATEMENT_QUEUING();
    antlr4::tree::TerminalNode *STATEMENTS();
    antlr4::tree::TerminalNode *STATIC();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *STATS_BINOMIAL_TEST();
    antlr4::tree::TerminalNode *STATS_CROSSTAB();
    antlr4::tree::TerminalNode *STATS_F_TEST();
    antlr4::tree::TerminalNode *STATS_KS_TEST();
    antlr4::tree::TerminalNode *STATS_MODE();
    antlr4::tree::TerminalNode *STATS_MW_TEST();
    antlr4::tree::TerminalNode *STATS_ONE_WAY_ANOVA();
    antlr4::tree::TerminalNode *STATS_T_TEST_INDEP();
    antlr4::tree::TerminalNode *STATS_T_TEST_INDEPU();
    antlr4::tree::TerminalNode *STATS_T_TEST_ONE();
    antlr4::tree::TerminalNode *STATS_T_TEST_PAIRED();
    antlr4::tree::TerminalNode *STATS_WSR_TEST();
    antlr4::tree::TerminalNode *STDDEV();
    antlr4::tree::TerminalNode *STDDEV_POP();
    antlr4::tree::TerminalNode *STDDEV_SAMP();
    antlr4::tree::TerminalNode *STOP();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *STREAMS();
    antlr4::tree::TerminalNode *STRICT();
    antlr4::tree::TerminalNode *STRING();
    antlr4::tree::TerminalNode *STRIPE_COLUMNS();
    antlr4::tree::TerminalNode *STRIPE_WIDTH();
    antlr4::tree::TerminalNode *STRIP();
    antlr4::tree::TerminalNode *STRUCTURE();
    antlr4::tree::TerminalNode *SUBMULTISET();
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *SUBPARTITION_REL();
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    antlr4::tree::TerminalNode *SUBQUERIES();
    antlr4::tree::TerminalNode *SUBQUERY_PRUNING();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *SUBSTR2();
    antlr4::tree::TerminalNode *SUBSTR4();
    antlr4::tree::TerminalNode *SUBSTRB();
    antlr4::tree::TerminalNode *SUBSTRC();
    antlr4::tree::TerminalNode *SUBSTR();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    antlr4::tree::TerminalNode *SUMMARY();
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *SUPPLEMENTAL();
    antlr4::tree::TerminalNode *SUSPEND();
    antlr4::tree::TerminalNode *SWAP_JOIN_INPUTS();
    antlr4::tree::TerminalNode *SWITCH();
    antlr4::tree::TerminalNode *SWITCHOVER();
    antlr4::tree::TerminalNode *SYNCHRONOUS();
    antlr4::tree::TerminalNode *SYNC();
    antlr4::tree::TerminalNode *SYSASM();
    antlr4::tree::TerminalNode *SYS_AUDIT();
    antlr4::tree::TerminalNode *SYSAUX();
    antlr4::tree::TerminalNode *SYS_CHECKACL();
    antlr4::tree::TerminalNode *SYS_CONNECT_BY_PATH();
    antlr4::tree::TerminalNode *SYS_CONTEXT();
    antlr4::tree::TerminalNode *SYSDATE();
    antlr4::tree::TerminalNode *SYSDBA();
    antlr4::tree::TerminalNode *SYS_DBURIGEN();
    antlr4::tree::TerminalNode *SYS_DL_CURSOR();
    antlr4::tree::TerminalNode *SYS_DM_RXFORM_CHR();
    antlr4::tree::TerminalNode *SYS_DM_RXFORM_NUM();
    antlr4::tree::TerminalNode *SYS_DOM_COMPARE();
    antlr4::tree::TerminalNode *SYS_DST_PRIM2SEC();
    antlr4::tree::TerminalNode *SYS_DST_SEC2PRIM();
    antlr4::tree::TerminalNode *SYS_ET_BFILE_TO_RAW();
    antlr4::tree::TerminalNode *SYS_ET_BLOB_TO_IMAGE();
    antlr4::tree::TerminalNode *SYS_ET_IMAGE_TO_BLOB();
    antlr4::tree::TerminalNode *SYS_ET_RAW_TO_BFILE();
    antlr4::tree::TerminalNode *SYS_EXTPDTXT();
    antlr4::tree::TerminalNode *SYS_EXTRACT_UTC();
    antlr4::tree::TerminalNode *SYS_FBT_INSDEL();
    antlr4::tree::TerminalNode *SYS_FILTER_ACLS();
    antlr4::tree::TerminalNode *SYS_FNMATCHES();
    antlr4::tree::TerminalNode *SYS_FNREPLACE();
    antlr4::tree::TerminalNode *SYS_GET_ACLIDS();
    antlr4::tree::TerminalNode *SYS_GET_PRIVILEGES();
    antlr4::tree::TerminalNode *SYS_GETTOKENID();
    antlr4::tree::TerminalNode *SYS_GETXTIVAL();
    antlr4::tree::TerminalNode *SYS_GUID();
    antlr4::tree::TerminalNode *SYS_MAKEXML();
    antlr4::tree::TerminalNode *SYS_MAKE_XMLNODEID();
    antlr4::tree::TerminalNode *SYS_MKXMLATTR();
    antlr4::tree::TerminalNode *SYS_OP_ADT2BIN();
    antlr4::tree::TerminalNode *SYS_OP_ADTCONS();
    antlr4::tree::TerminalNode *SYS_OP_ALSCRVAL();
    antlr4::tree::TerminalNode *SYS_OP_ATG();
    antlr4::tree::TerminalNode *SYS_OP_BIN2ADT();
    antlr4::tree::TerminalNode *SYS_OP_BITVEC();
    antlr4::tree::TerminalNode *SYS_OP_BL2R();
    antlr4::tree::TerminalNode *SYS_OP_BLOOM_FILTER_LIST();
    antlr4::tree::TerminalNode *SYS_OP_BLOOM_FILTER();
    antlr4::tree::TerminalNode *SYS_OP_C2C();
    antlr4::tree::TerminalNode *SYS_OP_CAST();
    antlr4::tree::TerminalNode *SYS_OP_CEG();
    antlr4::tree::TerminalNode *SYS_OP_CL2C();
    antlr4::tree::TerminalNode *SYS_OP_COMBINED_HASH();
    antlr4::tree::TerminalNode *SYS_OP_COMP();
    antlr4::tree::TerminalNode *SYS_OP_CONVERT();
    antlr4::tree::TerminalNode *SYS_OP_COUNTCHG();
    antlr4::tree::TerminalNode *SYS_OP_CSCONV();
    antlr4::tree::TerminalNode *SYS_OP_CSCONVTEST();
    antlr4::tree::TerminalNode *SYS_OP_CSR();
    antlr4::tree::TerminalNode *SYS_OP_CSX_PATCH();
    antlr4::tree::TerminalNode *SYS_OP_DECOMP();
    antlr4::tree::TerminalNode *SYS_OP_DESCEND();
    antlr4::tree::TerminalNode *SYS_OP_DISTINCT();
    antlr4::tree::TerminalNode *SYS_OP_DRA();
    antlr4::tree::TerminalNode *SYS_OP_DUMP();
    antlr4::tree::TerminalNode *SYS_OP_DV_CHECK();
    antlr4::tree::TerminalNode *SYS_OP_ENFORCE_NOT_NULL();
    antlr4::tree::TerminalNode *SYSOPER();
    antlr4::tree::TerminalNode *SYS_OP_EXTRACT();
    antlr4::tree::TerminalNode *SYS_OP_GROUPING();
    antlr4::tree::TerminalNode *SYS_OP_GUID();
    antlr4::tree::TerminalNode *SYS_OP_IIX();
    antlr4::tree::TerminalNode *SYS_OP_ITR();
    antlr4::tree::TerminalNode *SYS_OP_LBID();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2BLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2CLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2ID();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2NCLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2TYP();
    antlr4::tree::TerminalNode *SYS_OP_LSVI();
    antlr4::tree::TerminalNode *SYS_OP_LVL();
    antlr4::tree::TerminalNode *SYS_OP_MAKEOID();
    antlr4::tree::TerminalNode *SYS_OP_MAP_NONNULL();
    antlr4::tree::TerminalNode *SYS_OP_MSR();
    antlr4::tree::TerminalNode *SYS_OP_NICOMBINE();
    antlr4::tree::TerminalNode *SYS_OP_NIEXTRACT();
    antlr4::tree::TerminalNode *SYS_OP_NII();
    antlr4::tree::TerminalNode *SYS_OP_NIX();
    antlr4::tree::TerminalNode *SYS_OP_NOEXPAND();
    antlr4::tree::TerminalNode *SYS_OP_NTCIMG();
    antlr4::tree::TerminalNode *SYS_OP_NUMTORAW();
    antlr4::tree::TerminalNode *SYS_OP_OIDVALUE();
    antlr4::tree::TerminalNode *SYS_OP_OPNSIZE();
    antlr4::tree::TerminalNode *SYS_OP_PAR_1();
    antlr4::tree::TerminalNode *SYS_OP_PARGID_1();
    antlr4::tree::TerminalNode *SYS_OP_PARGID();
    antlr4::tree::TerminalNode *SYS_OP_PAR();
    antlr4::tree::TerminalNode *SYS_OP_PIVOT();
    antlr4::tree::TerminalNode *SYS_OP_R2O();
    antlr4::tree::TerminalNode *SYS_OP_RAWTONUM();
    antlr4::tree::TerminalNode *SYS_OP_RDTM();
    antlr4::tree::TerminalNode *SYS_OP_REF();
    antlr4::tree::TerminalNode *SYS_OP_RMTD();
    antlr4::tree::TerminalNode *SYS_OP_ROWIDTOOBJ();
    antlr4::tree::TerminalNode *SYS_OP_RPB();
    antlr4::tree::TerminalNode *SYS_OPTLOBPRBSC();
    antlr4::tree::TerminalNode *SYS_OP_TOSETID();
    antlr4::tree::TerminalNode *SYS_OP_TPR();
    antlr4::tree::TerminalNode *SYS_OP_TRTB();
    antlr4::tree::TerminalNode *SYS_OPTXICMP();
    antlr4::tree::TerminalNode *SYS_OPTXQCASTASNQ();
    antlr4::tree::TerminalNode *SYS_OP_UNDESCEND();
    antlr4::tree::TerminalNode *SYS_OP_VECAND();
    antlr4::tree::TerminalNode *SYS_OP_VECBIT();
    antlr4::tree::TerminalNode *SYS_OP_VECOR();
    antlr4::tree::TerminalNode *SYS_OP_VECXOR();
    antlr4::tree::TerminalNode *SYS_OP_VERSION();
    antlr4::tree::TerminalNode *SYS_OP_VREF();
    antlr4::tree::TerminalNode *SYS_OP_VVD();
    antlr4::tree::TerminalNode *SYS_OP_XMLCONS_FOR_CSX();
    antlr4::tree::TerminalNode *SYS_OP_XPTHATG();
    antlr4::tree::TerminalNode *SYS_OP_XPTHIDX();
    antlr4::tree::TerminalNode *SYS_OP_XPTHOP();
    antlr4::tree::TerminalNode *SYS_OP_XTXT2SQLT();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_DEPTH();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_MAXCHILD();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_PARENT();
    antlr4::tree::TerminalNode *SYS_PARALLEL_TXN();
    antlr4::tree::TerminalNode *SYS_PATHID_IS_ATTR();
    antlr4::tree::TerminalNode *SYS_PATHID_IS_NMSPC();
    antlr4::tree::TerminalNode *SYS_PATHID_LASTNAME();
    antlr4::tree::TerminalNode *SYS_PATHID_LASTNMSPC();
    antlr4::tree::TerminalNode *SYS_PATH_REVERSE();
    antlr4::tree::TerminalNode *SYS_PXQEXTRACT();
    antlr4::tree::TerminalNode *SYS_RID_ORDER();
    antlr4::tree::TerminalNode *SYS_ROW_DELTA();
    antlr4::tree::TerminalNode *SYS_SC_2_XMLT();
    antlr4::tree::TerminalNode *SYS_SYNRCIREDO();
    antlr4::tree::TerminalNode *SYSTEM_DEFINED();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *SYSTIMESTAMP();
    antlr4::tree::TerminalNode *SYS_TYPEID();
    antlr4::tree::TerminalNode *SYS_UMAKEXML();
    antlr4::tree::TerminalNode *SYS_XMLANALYZE();
    antlr4::tree::TerminalNode *SYS_XMLCONTAINS();
    antlr4::tree::TerminalNode *SYS_XMLCONV();
    antlr4::tree::TerminalNode *SYS_XMLEXNSURI();
    antlr4::tree::TerminalNode *SYS_XMLGEN();
    antlr4::tree::TerminalNode *SYS_XMLI_LOC_ISNODE();
    antlr4::tree::TerminalNode *SYS_XMLI_LOC_ISTEXT();
    antlr4::tree::TerminalNode *SYS_XMLINSTR();
    antlr4::tree::TerminalNode *SYS_XMLLOCATOR_GETSVAL();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETCID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETLOCATOR();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETOKEY();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETPATHID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETPTRID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETRID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETSVAL();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETTID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID();
    antlr4::tree::TerminalNode *SYS_XMLT_2_SC();
    antlr4::tree::TerminalNode *SYS_XMLTRANSLATE();
    antlr4::tree::TerminalNode *SYS_XMLTYPE2SQL();
    antlr4::tree::TerminalNode *SYS_XQ_ASQLCNV();
    antlr4::tree::TerminalNode *SYS_XQ_ATOMCNVCHK();
    antlr4::tree::TerminalNode *SYS_XQBASEURI();
    antlr4::tree::TerminalNode *SYS_XQCASTABLEERRH();
    antlr4::tree::TerminalNode *SYS_XQCODEP2STR();
    antlr4::tree::TerminalNode *SYS_XQCODEPEQ();
    antlr4::tree::TerminalNode *SYS_XQCON2SEQ();
    antlr4::tree::TerminalNode *SYS_XQCONCAT();
    antlr4::tree::TerminalNode *SYS_XQDELETE();
    antlr4::tree::TerminalNode *SYS_XQDFLTCOLATION();
    antlr4::tree::TerminalNode *SYS_XQDOC();
    antlr4::tree::TerminalNode *SYS_XQDOCURI();
    antlr4::tree::TerminalNode *SYS_XQDURDIV();
    antlr4::tree::TerminalNode *SYS_XQED4URI();
    antlr4::tree::TerminalNode *SYS_XQENDSWITH();
    antlr4::tree::TerminalNode *SYS_XQERRH();
    antlr4::tree::TerminalNode *SYS_XQERR();
    antlr4::tree::TerminalNode *SYS_XQESHTMLURI();
    antlr4::tree::TerminalNode *SYS_XQEXLOBVAL();
    antlr4::tree::TerminalNode *SYS_XQEXSTWRP();
    antlr4::tree::TerminalNode *SYS_XQEXTRACT();
    antlr4::tree::TerminalNode *SYS_XQEXTRREF();
    antlr4::tree::TerminalNode *SYS_XQEXVAL();
    antlr4::tree::TerminalNode *SYS_XQFB2STR();
    antlr4::tree::TerminalNode *SYS_XQFNBOOL();
    antlr4::tree::TerminalNode *SYS_XQFNCMP();
    antlr4::tree::TerminalNode *SYS_XQFNDATIM();
    antlr4::tree::TerminalNode *SYS_XQFNLNAME();
    antlr4::tree::TerminalNode *SYS_XQFNNM();
    antlr4::tree::TerminalNode *SYS_XQFNNSURI();
    antlr4::tree::TerminalNode *SYS_XQFNPREDTRUTH();
    antlr4::tree::TerminalNode *SYS_XQFNQNM();
    antlr4::tree::TerminalNode *SYS_XQFNROOT();
    antlr4::tree::TerminalNode *SYS_XQFORMATNUM();
    antlr4::tree::TerminalNode *SYS_XQFTCONTAIN();
    antlr4::tree::TerminalNode *SYS_XQFUNCR();
    antlr4::tree::TerminalNode *SYS_XQGETCONTENT();
    antlr4::tree::TerminalNode *SYS_XQINDXOF();
    antlr4::tree::TerminalNode *SYS_XQINSERT();
    antlr4::tree::TerminalNode *SYS_XQINSPFX();
    antlr4::tree::TerminalNode *SYS_XQIRI2URI();
    antlr4::tree::TerminalNode *SYS_XQLANG();
    antlr4::tree::TerminalNode *SYS_XQLLNMFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQMKNODEREF();
    antlr4::tree::TerminalNode *SYS_XQNILLED();
    antlr4::tree::TerminalNode *SYS_XQNODENAME();
    antlr4::tree::TerminalNode *SYS_XQNORMSPACE();
    antlr4::tree::TerminalNode *SYS_XQNORMUCODE();
    antlr4::tree::TerminalNode *SYS_XQ_NRNG();
    antlr4::tree::TerminalNode *SYS_XQNSP4PFX();
    antlr4::tree::TerminalNode *SYS_XQNSPFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQPFXFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQ_PKSQL2XML();
    antlr4::tree::TerminalNode *SYS_XQPOLYABS();
    antlr4::tree::TerminalNode *SYS_XQPOLYADD();
    antlr4::tree::TerminalNode *SYS_XQPOLYCEL();
    antlr4::tree::TerminalNode *SYS_XQPOLYCSTBL();
    antlr4::tree::TerminalNode *SYS_XQPOLYCST();
    antlr4::tree::TerminalNode *SYS_XQPOLYDIV();
    antlr4::tree::TerminalNode *SYS_XQPOLYFLR();
    antlr4::tree::TerminalNode *SYS_XQPOLYMOD();
    antlr4::tree::TerminalNode *SYS_XQPOLYMUL();
    antlr4::tree::TerminalNode *SYS_XQPOLYRND();
    antlr4::tree::TerminalNode *SYS_XQPOLYSQRT();
    antlr4::tree::TerminalNode *SYS_XQPOLYSUB();
    antlr4::tree::TerminalNode *SYS_XQPOLYUMUS();
    antlr4::tree::TerminalNode *SYS_XQPOLYUPLS();
    antlr4::tree::TerminalNode *SYS_XQPOLYVEQ();
    antlr4::tree::TerminalNode *SYS_XQPOLYVGE();
    antlr4::tree::TerminalNode *SYS_XQPOLYVGT();
    antlr4::tree::TerminalNode *SYS_XQPOLYVLE();
    antlr4::tree::TerminalNode *SYS_XQPOLYVLT();
    antlr4::tree::TerminalNode *SYS_XQPOLYVNE();
    antlr4::tree::TerminalNode *SYS_XQREF2VAL();
    antlr4::tree::TerminalNode *SYS_XQRENAME();
    antlr4::tree::TerminalNode *SYS_XQREPLACE();
    antlr4::tree::TerminalNode *SYS_XQRESVURI();
    antlr4::tree::TerminalNode *SYS_XQRNDHALF2EVN();
    antlr4::tree::TerminalNode *SYS_XQRSLVQNM();
    antlr4::tree::TerminalNode *SYS_XQRYENVPGET();
    antlr4::tree::TerminalNode *SYS_XQRYVARGET();
    antlr4::tree::TerminalNode *SYS_XQRYWRP();
    antlr4::tree::TerminalNode *SYS_XQSEQ2CON4XC();
    antlr4::tree::TerminalNode *SYS_XQSEQ2CON();
    antlr4::tree::TerminalNode *SYS_XQSEQDEEPEQ();
    antlr4::tree::TerminalNode *SYS_XQSEQINSB();
    antlr4::tree::TerminalNode *SYS_XQSEQRM();
    antlr4::tree::TerminalNode *SYS_XQSEQRVS();
    antlr4::tree::TerminalNode *SYS_XQSEQSUB();
    antlr4::tree::TerminalNode *SYS_XQSEQTYPMATCH();
    antlr4::tree::TerminalNode *SYS_XQSTARTSWITH();
    antlr4::tree::TerminalNode *SYS_XQSTATBURI();
    antlr4::tree::TerminalNode *SYS_XQSTR2CODEP();
    antlr4::tree::TerminalNode *SYS_XQSTRJOIN();
    antlr4::tree::TerminalNode *SYS_XQSUBSTRAFT();
    antlr4::tree::TerminalNode *SYS_XQSUBSTRBEF();
    antlr4::tree::TerminalNode *SYS_XQTOKENIZE();
    antlr4::tree::TerminalNode *SYS_XQTREATAS();
    antlr4::tree::TerminalNode *SYS_XQ_UPKXML2SQL();
    antlr4::tree::TerminalNode *SYS_XQXFORM();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *TABLE_LOOKUP_BY_NL();
    antlr4::tree::TerminalNode *TABLES();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *TABLESPACE_NO();
    antlr4::tree::TerminalNode *TABLE_STATS();
    antlr4::tree::TerminalNode *TABNO();
    antlr4::tree::TerminalNode *TANH();
    antlr4::tree::TerminalNode *TAN();
    antlr4::tree::TerminalNode *TBLORIDXPARTNUM();
    antlr4::tree::TerminalNode *TEMPFILE();
    antlr4::tree::TerminalNode *TEMPLATE();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *TEMP_TABLE();
    antlr4::tree::TerminalNode *TEST();
    antlr4::tree::TerminalNode *THAN();
    antlr4::tree::TerminalNode *THE();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *THREAD();
    antlr4::tree::TerminalNode *THROUGH();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *TIMEOUT();
    antlr4::tree::TerminalNode *TIMES();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *TIMEZONE_ABBR();
    antlr4::tree::TerminalNode *TIMEZONE_HOUR();
    antlr4::tree::TerminalNode *TIMEZONE_MINUTE();
    antlr4::tree::TerminalNode *TIME_ZONE();
    antlr4::tree::TerminalNode *TIMEZONE_OFFSET();
    antlr4::tree::TerminalNode *TIMEZONE_REGION();
    antlr4::tree::TerminalNode *TIV_GB();
    antlr4::tree::TerminalNode *TIV_SSF();
    antlr4::tree::TerminalNode *TO_BINARY_DOUBLE();
    antlr4::tree::TerminalNode *TO_BINARY_FLOAT();
    antlr4::tree::TerminalNode *TO_BLOB();
    antlr4::tree::TerminalNode *TO_CHAR();
    antlr4::tree::TerminalNode *TO_CLOB();
    antlr4::tree::TerminalNode *TO_DATE();
    antlr4::tree::TerminalNode *TO_DSINTERVAL();
    antlr4::tree::TerminalNode *TO_LOB();
    antlr4::tree::TerminalNode *TO_MULTI_BYTE();
    antlr4::tree::TerminalNode *TO_NCHAR();
    antlr4::tree::TerminalNode *TO_NCLOB();
    antlr4::tree::TerminalNode *TO_NUMBER();
    antlr4::tree::TerminalNode *TOPLEVEL();
    antlr4::tree::TerminalNode *TO_SINGLE_BYTE();
    antlr4::tree::TerminalNode *TO_TIME();
    antlr4::tree::TerminalNode *TO_TIMESTAMP();
    antlr4::tree::TerminalNode *TO_TIMESTAMP_TZ();
    antlr4::tree::TerminalNode *TO_TIME_TZ();
    antlr4::tree::TerminalNode *TO_YMINTERVAL();
    antlr4::tree::TerminalNode *TRACE();
    antlr4::tree::TerminalNode *TRACING();
    antlr4::tree::TerminalNode *TRACKING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *TRANSFORM_DISTINCT_AGG();
    antlr4::tree::TerminalNode *TRANSITIONAL();
    antlr4::tree::TerminalNode *TRANSITION();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *TREAT();
    antlr4::tree::TerminalNode *TRIGGERS();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *TRUE();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *TRUNC();
    antlr4::tree::TerminalNode *TRUSTED();
    antlr4::tree::TerminalNode *TUNING();
    antlr4::tree::TerminalNode *TX();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *TYPES();
    antlr4::tree::TerminalNode *TZ_OFFSET();
    antlr4::tree::TerminalNode *UB2();
    antlr4::tree::TerminalNode *UBA();
    antlr4::tree::TerminalNode *UID();
    antlr4::tree::TerminalNode *UNARCHIVED();
    antlr4::tree::TerminalNode *UNBOUNDED();
    antlr4::tree::TerminalNode *UNBOUND();
    antlr4::tree::TerminalNode *UNDER();
    antlr4::tree::TerminalNode *UNDO();
    antlr4::tree::TerminalNode *UNDROP();
    antlr4::tree::TerminalNode *UNIFORM();
    antlr4::tree::TerminalNode *UNISTR();
    antlr4::tree::TerminalNode *UNLIMITED();
    antlr4::tree::TerminalNode *UNLOAD();
    antlr4::tree::TerminalNode *UNLOCK();
    antlr4::tree::TerminalNode *UNNEST_INNERJ_DISTINCT_VIEW();
    antlr4::tree::TerminalNode *UNNEST();
    antlr4::tree::TerminalNode *UNNEST_NOSEMIJ_NODISTINCTVIEW();
    antlr4::tree::TerminalNode *UNNEST_SEMIJ_VIEW();
    antlr4::tree::TerminalNode *UNPACKED();
    antlr4::tree::TerminalNode *UNPIVOT();
    antlr4::tree::TerminalNode *UNPROTECTED();
    antlr4::tree::TerminalNode *UNQUIESCE();
    antlr4::tree::TerminalNode *UNRECOVERABLE();
    antlr4::tree::TerminalNode *UNRESTRICTED();
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *UNUSABLE();
    antlr4::tree::TerminalNode *UNUSED();
    antlr4::tree::TerminalNode *UPDATABLE();
    antlr4::tree::TerminalNode *UPDATED();
    antlr4::tree::TerminalNode *UPDATEXML();
    antlr4::tree::TerminalNode *UPD_INDEXES();
    antlr4::tree::TerminalNode *UPD_JOININDEX();
    antlr4::tree::TerminalNode *UPGRADE();
    antlr4::tree::TerminalNode *UPPER();
    antlr4::tree::TerminalNode *UPSERT();
    antlr4::tree::TerminalNode *UROWID();
    antlr4::tree::TerminalNode *USAGE();
    antlr4::tree::TerminalNode *USE_ANTI();
    antlr4::tree::TerminalNode *USE_CONCAT();
    antlr4::tree::TerminalNode *USE_HASH_AGGREGATION();
    antlr4::tree::TerminalNode *USE_HASH_GBY_FOR_PUSHDOWN();
    antlr4::tree::TerminalNode *USE_HASH();
    antlr4::tree::TerminalNode *USE_INVISIBLE_INDEXES();
    antlr4::tree::TerminalNode *USE_MERGE_CARTESIAN();
    antlr4::tree::TerminalNode *USE_MERGE();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *USE_NL();
    antlr4::tree::TerminalNode *USE_NL_WITH_INDEX();
    antlr4::tree::TerminalNode *USE_PRIVATE_OUTLINES();
    antlr4::tree::TerminalNode *USER_DEFINED();
    antlr4::tree::TerminalNode *USERENV();
    antlr4::tree::TerminalNode *USERGROUP();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *USER_RECYCLEBIN();
    antlr4::tree::TerminalNode *USERS();
    antlr4::tree::TerminalNode *USE_SEMI();
    antlr4::tree::TerminalNode *USE_STORED_OUTLINES();
    antlr4::tree::TerminalNode *USE_TTT_FOR_GSETS();
    antlr4::tree::TerminalNode *USE_WEAK_NAME_RESL();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *VALIDATE();
    antlr4::tree::TerminalNode *VALIDATION();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *VARIANCE();
    antlr4::tree::TerminalNode *VAR_POP();
    antlr4::tree::TerminalNode *VARRAY();
    antlr4::tree::TerminalNode *VARRAYS();
    antlr4::tree::TerminalNode *VAR_SAMP();
    antlr4::tree::TerminalNode *VARYING();
    antlr4::tree::TerminalNode *VECTOR_READ();
    antlr4::tree::TerminalNode *VECTOR_READ_TRACE();
    antlr4::tree::TerminalNode *VERIFY();
    antlr4::tree::TerminalNode *VERSIONING();
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *VERSIONS_ENDSCN();
    antlr4::tree::TerminalNode *VERSIONS_ENDTIME();
    antlr4::tree::TerminalNode *VERSIONS();
    antlr4::tree::TerminalNode *VERSIONS_OPERATION();
    antlr4::tree::TerminalNode *VERSIONS_STARTSCN();
    antlr4::tree::TerminalNode *VERSIONS_STARTTIME();
    antlr4::tree::TerminalNode *VERSIONS_XID();
    antlr4::tree::TerminalNode *VIRTUAL();
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *VOLUME();
    antlr4::tree::TerminalNode *VSIZE();
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *WALLET();
    antlr4::tree::TerminalNode *WELLFORMED();
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *WHITESPACE();
    antlr4::tree::TerminalNode *WIDTH_BUCKET();
    antlr4::tree::TerminalNode *WITHIN();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *WORK();
    antlr4::tree::TerminalNode *WRAPPED();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *XDB_FASTPATH_INSERT();
    antlr4::tree::TerminalNode *X_DYN_PRUNE();
    antlr4::tree::TerminalNode *XID();
    antlr4::tree::TerminalNode *XML2OBJECT();
    antlr4::tree::TerminalNode *XMLATTRIBUTES();
    antlr4::tree::TerminalNode *XMLCAST();
    antlr4::tree::TerminalNode *XMLCDATA();
    antlr4::tree::TerminalNode *XMLCOLATTVAL();
    antlr4::tree::TerminalNode *XMLCOMMENT();
    antlr4::tree::TerminalNode *XMLCONCAT();
    antlr4::tree::TerminalNode *XMLDIFF();
    antlr4::tree::TerminalNode *XML_DML_RWT_STMT();
    antlr4::tree::TerminalNode *XMLELEMENT();
    antlr4::tree::TerminalNode *XMLEXISTS2();
    antlr4::tree::TerminalNode *XMLEXISTS();
    antlr4::tree::TerminalNode *XMLFOREST();
    antlr4::tree::TerminalNode *XMLINDEX_REWRITE_IN_SELECT();
    antlr4::tree::TerminalNode *XMLINDEX_REWRITE();
    antlr4::tree::TerminalNode *XMLINDEX_SEL_IDX_TBL();
    antlr4::tree::TerminalNode *XMLISNODE();
    antlr4::tree::TerminalNode *XMLISVALID();
    antlr4::tree::TerminalNode *XML();
    antlr4::tree::TerminalNode *XMLNAMESPACES();
    antlr4::tree::TerminalNode *XMLPARSE();
    antlr4::tree::TerminalNode *XMLPATCH();
    antlr4::tree::TerminalNode *XMLPI();
    antlr4::tree::TerminalNode *XMLQUERY();
    antlr4::tree::TerminalNode *XMLQUERYVAL();
    antlr4::tree::TerminalNode *XMLROOT();
    antlr4::tree::TerminalNode *XMLSCHEMA();
    antlr4::tree::TerminalNode *XMLSERIALIZE();
    antlr4::tree::TerminalNode *XMLTABLE();
    antlr4::tree::TerminalNode *XMLTRANSFORMBLOB();
    antlr4::tree::TerminalNode *XMLTRANSFORM();
    antlr4::tree::TerminalNode *XMLTYPE();
    antlr4::tree::TerminalNode *XPATHTABLE();
    antlr4::tree::TerminalNode *XS_SYS_CONTEXT();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *YES();
    antlr4::tree::TerminalNode *ZONE();

    virtual void enterRule(antlr4::tree::ParseTreeListener *listener) override;
    virtual void exitRule(antlr4::tree::ParseTreeListener *listener) override;

    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_reserved_keywords_pre12cContext* non_reserved_keywords_pre12c();


  virtual bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;
  bool logical_expressionSempred(Logical_expressionContext *_localctx, size_t predicateIndex);
  bool relational_expressionSempred(Relational_expressionContext *_localctx, size_t predicateIndex);
  bool concatenationSempred(ConcatenationContext *_localctx, size_t predicateIndex);

private:
  static std::vector<antlr4::dfa::DFA> _decisionToDFA;
  static antlr4::atn::PredictionContextCache _sharedContextCache;
  static std::vector<std::string> _ruleNames;
  static std::vector<std::string> _tokenNames;

  static std::vector<std::string> _literalNames;
  static std::vector<std::string> _symbolicNames;
  static antlr4::dfa::Vocabulary _vocabulary;
  static antlr4::atn::ATN _atn;
  static std::vector<uint16_t> _serializedATN;


  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};

